import imports
lemma new_lemma_16000 (h3 : topological_space (linear_ordered_add_comm_group to_additive.value_type)) : path_connected_space (linear_ordered_add_comm_group to_additive.value_type) := sorry --non-trivial
lemma new_lemma_16001 (h0 : group (id (linear_ordered_semiring (has_top empty)))) : group.fg (id (linear_ordered_semiring (has_top empty))) := sorry --non-trivial
lemma new_lemma_16002 (h0 : has_mem.mem (with_bot congr_arg_kind) has_emptyc.emptyc) : @is_domain.{0} (with_bot.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type ring.{0} (with_bot.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_16003 (h0 : topological_space (has_add (option unsigned))) : normal_space (has_add (option unsigned)) := sorry --non-trivial
lemma new_lemma_16004 (h0 : add_group (has_nndist num)) : is_add_cyclic (has_nndist num) := sorry --non-trivial
lemma new_lemma_16005 (h0 : functor.add_const (topological_space (as_linear_order num)) num) : @path_connected_space.{0} (as_linear_order.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (as_linear_order.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_16006 (h0 : not (function.extfun (finset Type) (has_mem.mem (linear_ordered_semiring linarith.comp)) -> false)) : @separated_space.{0} (linear_ordered_semiring.{0} linarith.comp) (@finset.pi.empty.{1 0} Type uniform_space.{0} (linear_ordered_semiring.{0} linarith.comp) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (linear_ordered_semiring.{0} linarith.comp)) (@classical.by_contradiction'.{0} (function.extfun.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (linear_ordered_semiring.{0} linarith.comp))) h0) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_16007 (h0 : ring (normed_comm_ring (has_add pos))) : rank_condition (normed_comm_ring (has_add pos)) := sorry --non-trivial
lemma new_lemma_16008 (h0 : functor.add_const (topological_space (boolean_algebra.core name)) linarith.comp) : @totally_separated_space.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_16009 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (linear_ordered_field.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_field.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_16010 (h0 : false) : @Lim.{0} Prop sierpinski_space (@nonempty_of_inhabited.{1} Prop sort.inhabited.{0}) (@id.{1} (filter.{0} Prop) (@id.{1} (filter.{0} Prop) (@false.elim.{1} (filter.{0} Prop) h0)))  := sorry --trivial
lemma new_lemma_16011 (h0 : functor.add_const (topological_space (comm_group linarith.comp)) name) : @loc_path_connected_space.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_16012 (h0 : function.extfun Type topological_space) : @t0_space.{0} (linear_ordered_semiring.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_16013 (h0 : functor.add_const (function.extfun (Type 1) topological_space) pos) : @preirreducible_space.{1} Type (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) pos h0) Type)  := sorry --non-trivial
lemma new_lemma_16014 (h0 : functor.add_const (topological_space (boolean_algebra pos)) real) : @preirreducible_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} pos)) real h0)  := sorry --non-trivial
lemma new_lemma_16015 (h0 : fin has_zero.zero) : @preirreducible_space.{1} (has_pos_part.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (has_pos_part.{1} Type)) (@function.extfun_app.{1 1} nat fin (@matrix.vec_empty.{0} (function.extfun.{1 1} nat fin) h0) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_16016 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (normed_lattice_add_comm_group.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_lattice_add_comm_group.{0} real))  := sorry --non-trivial
lemma new_lemma_16017 (h0 : ring (canonically_ordered_comm_semiring ennreal)) : is_principal_ideal_ring (canonically_ordered_comm_semiring ennreal) := sorry --non-trivial
lemma new_lemma_16018 (h0 : complete_lattice (monoid congr_arg_kind)) : is_compactly_generated (monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_16019 (h0 : functor.add_const (topological_space (has_neg linarith.comp)) (has_neg environment.implicit_infer_kind)) : @loc_path_connected_space.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} linarith.comp)) (has_neg.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_16020 (h0 : topological_space (linear_ordered_add_comm_group (has_inv linarith.ineq))) : totally_disconnected_space (linear_ordered_add_comm_group (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_16021 (h0 : topological_space (has_pos_part (has_add (has_Inf pos)))) : t0_space (has_pos_part (has_add (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_16022 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} auto.case_option (@function.extfun_app.{2 1} Type topological_space.{0} h0 auto.case_option)  := sorry --non-trivial
lemma new_lemma_16023 (h0 : not (has_mem.mem (linear_ordered_semiring fun_info) has_emptyc.emptyc -> false)) : @strong_rank_condition.{0} (linear_ordered_semiring.{0} fun_info) (@finset.pi.empty.{1 0} Type ring.{0} (linear_ordered_semiring.{0} fun_info) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (linear_ordered_semiring.{0} fun_info) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_16024 (h0 : ring (add_cancel_monoid linarith.comp)) : is_principal_ideal_ring (add_cancel_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_16025 (h0 : ring (add_right_cancel_monoid empty)) : strong_rank_condition (add_right_cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_16026 (h0 : topological_space (measurable_space string_imp)) : totally_disconnected_space (measurable_space string_imp) := sorry --non-trivial
lemma new_lemma_16027 (h0 : ring (has_inter num)) : rank_condition (has_inter num) := sorry --non-trivial
lemma new_lemma_16028 (h0 : functor.add_const (topological_space (ring environment.implicit_infer_kind)) Type) : @t0_space.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (ring.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_16029 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_16030 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (has_nndist.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_nndist.{0} empty))  := sorry --non-trivial
lemma new_lemma_16031 (h0 : ring (has_top (random_gen (has_top congr_arg_kind)))) : is_domain (has_top (random_gen (has_top congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_16032 (h0 : ordered_comm_monoid (has_pos_part (has_pos_part (finset linarith.comp)))) : has_exists_mul_of_le (has_pos_part (has_pos_part (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_16033 (h0 : not (prod (partial_order unsigned) (partial_order unsigned) -> false)) : id_rel (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_16034 (h0 : functor.add_const (topological_space (generalized_boolean_algebra Type)) (ring Type)) : @preconnected_space.{1} (generalized_boolean_algebra.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (generalized_boolean_algebra.{1} Type)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_16035 (h0 : not (uniform_space (with_bot linarith.comp) -> false)) : @separated_space.{0} (with_bot.{0} linarith.comp) (@classical.by_contradiction'.{1} (uniform_space.{0} (with_bot.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_16036 (h0 : ring (encodable (has_nnnorm linarith.comp_source))) : strong_rank_condition (encodable (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_16037 (h0 : topological_space (add_comm_semigroup std_gen)) : preirreducible_space (add_comm_semigroup std_gen) := sorry --non-trivial
lemma new_lemma_16038 (h0 : topological_space (dlist (comm_ring to_additive.value_type))) : totally_disconnected_space (dlist (comm_ring to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_16039 (h0 : ring ennreal) : rank_condition ennreal := sorry --non-trivial
lemma new_lemma_16040 (h0 : function.extfun Type topological_space) : @t1_space.{0} (left_cancel_monoid.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} empty)))))) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (left_cancel_monoid.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} empty)))))))  := sorry --non-trivial
lemma new_lemma_16041 (h2 : complete_lattice (encodable to_additive.value_type)) : complete_lattice.is_Sup_finite_compact (encodable to_additive.value_type) := sorry --non-trivial
lemma new_lemma_16042 (h3 : uniform_space (has_div string_imp)) : complete_space (has_div string_imp) := sorry --non-trivial
lemma new_lemma_16043 (h0 : fin has_zero.zero) : @normalizer_condition.{1} (comm_semigroup.{1} Type) (@matrix.vec_empty.{1} (group.{1} (comm_semigroup.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_16044 (h2 : set (linarith.ineq -> enat)) : set.separates_points h2 := sorry --non-trivial
lemma new_lemma_16045 (h1 : has_mem.mem (has_emptyc num) has_emptyc.emptyc) : @strong_rank_condition.{0} (has_emptyc.{0} num) (@finset.pi.empty.{1 0} Type ring.{0} (has_emptyc.{0} num) h1)  := sorry --non-trivial
lemma new_lemma_16046 (h0 : fin has_zero.zero) : @t1_space.{0} (complete_distrib_lattice.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (complete_distrib_lattice.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_16047 (h0 : complete_lattice (complete_linear_order (semiring (semiring empty)))) : is_compactly_generated (complete_linear_order (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_16048 (h0 : functor.add_const (filter (has_to_string linarith.comp)) environment.implicit_infer_kind) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_16049 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @t0_space.{0} (has_top.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_top.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_16050 (h0 : topological_space (has_ssubset reducibility_hints)) : path_connected_space (has_ssubset reducibility_hints) := sorry --non-trivial
lemma new_lemma_16051 (h0 : group (with_bot (random_gen (comm_ring to_additive.value_type)))) : normalizer_condition (with_bot (random_gen (comm_ring to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_16052 (h0 : not (function.extfun Type finset -> false)) : finset.nonempty (function.extfun_app (classical.by_contradiction' h0) (monoid_with_zero num)) := sorry --non-trivial
lemma new_lemma_16053 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} (mul_zero_class.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (mul_zero_class.{0} num))  := sorry --non-trivial
lemma new_lemma_16054 (h0 : list (boolean_algebra.core (option (finset name)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_16055 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_16056 (h0 : ring (ring (has_add pos))) : rank_condition (ring (has_add pos)) := sorry --non-trivial
lemma new_lemma_16057 (h0 : functor.add_const (function.extfun (Type 1) add_group) Type) : @is_add_cyclic.{1} Type (@function.extfun_app.{3 2} (Type 1) add_group.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) add_group.{1}) Type h0) Type)  := sorry --non-trivial
lemma new_lemma_16058 (h0 : topological_space (has_zero (has_neg_part Type))) : totally_separated_space (has_zero (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_16059 (h0 : add_monoid (has_add (has_Inf Type))) : add_monoid.fg (has_add (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_16060 (h0 : fin has_zero.zero) : @is_cyclic.{0} (add_comm_monoid.{0} pos) (@matrix.vec_empty.{0} (group.{0} (add_comm_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_16061 (h0 : ring (measurable_space (has_inv (has_inv linarith.comp_source)))) : rank_condition (measurable_space (has_inv (has_inv linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_16062 (h0 : topological_space (has_div (has_div linarith.comp_source))) : path_connected_space (has_div (has_div linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_16063 (h0 : group (dlist (mul_one_class to_additive.value_type))) : is_cyclic (dlist (mul_one_class to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_16064 (h0 : finset (add_cancel_monoid (ring (has_neg linarith.comp)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_16065 (h0 : functor.add_const (topological_space (option congr_arg_kind)) congr_arg_kind) : @t1_space.{0} (option.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_16066 (h0 : not (topological_space (has_ssubset reducibility_hints) -> false)) : @path_connected_space.{0} (has_ssubset.{0} reducibility_hints) (@classical.by_contradiction'.{1} (topological_space.{0} (has_ssubset.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_16067 (h0 : functor.add_const (ordered_comm_monoid (semigroup Type)) linarith.comp) : @has_exists_mul_of_le.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (ordered_comm_monoid.{1} (semigroup.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_16068 (h0 : ring (has_one (semiring (has_top unsigned)))) : is_domain (has_one (semiring (has_top unsigned))) := sorry --non-trivial
lemma new_lemma_16069 (h0 : add_monoid (ordered_comm_monoid (has_Inf real))) : add_monoid.fg (ordered_comm_monoid (has_Inf real)) := sorry --non-trivial
lemma new_lemma_16070 (h0 : function.extfun Type group) : @is_simple_group.{0} (cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_16071 (h0 : add_monoid (boolean_algebra.core (finset linarith.comp))) : add_monoid.fg (boolean_algebra.core (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_16072 (h0 : ring environment.implicit_infer_kind) : is_principal_ideal_ring environment.implicit_infer_kind := sorry --non-trivial
lemma new_lemma_16073 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_16074 (h0 : group (finset (has_add (finset (finset linarith.comp))))) : normalizer_condition (finset (has_add (finset (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_16075 (h0 : function.extfun Type (functor.comp topological_space comm_group)) : @sequential_space.{0} (comm_group.{0} unsigned) (@functor.comp.run.{0 0 0} topological_space.{0} comm_group.{0} unsigned (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} comm_group.{0}) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_16076 (h0 : ordered_comm_monoid (has_to_string (option name))) : has_exists_mul_of_le (has_to_string (option name)) := sorry --non-trivial
lemma new_lemma_16077 (h0 : ring (boolean_algebra.core (has_add (finset name)))) : rank_condition (boolean_algebra.core (has_add (finset name))) := sorry --non-trivial
lemma new_lemma_16078 (h0 : functor.add_const (complete_lattice (free_add_monoid unsigned)) empty) : @is_compactly_generated.{0} (free_add_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (free_add_monoid.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_16079 (h0 : topological_space enat) (h1 : preorder enat) : order_closed_topology enat := sorry --non-trivial
lemma new_lemma_16080 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_top.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_top.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_16081 (h0 : functor.add_const (complete_lattice (semigroup unsigned)) empty) : @is_compactly_generated.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (semigroup.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_16082 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} (denumerable.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (denumerable.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_16083 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (linear_ordered_field unsigned)) := sorry --non-trivial
lemma new_lemma_16084 (h0 : function.extfun Type topological_space) : @normal_space.{0} (canonically_ordered_comm_semiring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} pos))  := sorry --non-trivial
lemma new_lemma_16085 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} fun_info (@function.extfun_app.{2 1} Type topological_space.{0} h0 fun_info)  := sorry --non-trivial
lemma new_lemma_16086 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_16087 (h0 : uniform_space (semiring (random_gen (has_top (has_top congr_arg_kind))))) : separated_space (semiring (random_gen (has_top (has_top congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_16088 (h0 : function.extfun Type (functor.add_const (topological_space (add_semigroup empty)))) : @preirreducible_space.{0} (add_semigroup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_semigroup.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (add_semigroup.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_16089 (h0 : topological_space (with_bot (has_top (has_top unsigned)))) : path_connected_space (with_bot (has_top (has_top unsigned))) := sorry --non-trivial
lemma new_lemma_16090 (h0 : topological_space (ordered_cancel_add_comm_monoid (option num))) : normal_space (ordered_cancel_add_comm_monoid (option num)) := sorry --non-trivial
lemma new_lemma_16091 (h0 : topological_space (boolean_algebra (has_add (has_add (add_comm_monoid (has_add pos)))))) : locally_compact_space (boolean_algebra (has_add (has_add (add_comm_monoid (has_add pos))))) := sorry --non-trivial
lemma new_lemma_16092 (h0 : not (group (dlist fun_info) -> false)) : @is_cyclic.{0} (dlist.{0} fun_info) (@classical.by_contradiction'.{1} (group.{0} (dlist.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_16093 (h0 : functor.add_const (uniform_space (normed_comm_ring linarith.comp)) (has_neg environment.implicit_infer_kind)) : @complete_space.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (normed_comm_ring.{0} linarith.comp)) (has_neg.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_16094 (h0 : topological_space (has_to_string Type)) : discrete_topology (has_to_string Type) := sorry --non-trivial
lemma new_lemma_16095 (h0 : function.extfun nat fin) : @is_cyclic.{1} (has_Inf.{1} Type) (@matrix.vec_empty.{1} (group.{1} (has_Inf.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_16096 (h0 : topological_space (linear_ordered_semiring fun_info)) : totally_separated_space (linear_ordered_semiring fun_info) := sorry --non-trivial
lemma new_lemma_16097 (h0 : uniform_space (has_emptyc (has_inv fun_info))) : complete_space (has_emptyc (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_16098 (h0 : fin has_zero.zero) : @totally_disconnected_space.{1} (sub_neg_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (sub_neg_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_16099 (h0 : functor.add_const (topological_space (cancel_monoid name)) Type) : @t1_space.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (cancel_monoid.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_16100 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (bin_tree.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (bin_tree.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_16101 (h0 : function.extfun (finset Type) (has_mem.mem (has_one empty))) : @strong_rank_condition.{0} (has_one.{0} empty) (@finset.pi.empty.{1 0} Type ring.{0} (has_one.{0} empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_one.{0} empty)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_16102 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (boolean_algebra.core.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.core.{0} pos))  := sorry --non-trivial
lemma new_lemma_16103 (h0 : not (complete_lattice (semi_normed_ring (has_lt char)) -> false)) : @is_compactly_generated.{0} (semi_normed_ring.{0} (has_lt.{0} char)) (@classical.by_contradiction'.{1} (complete_lattice.{0} (semi_normed_ring.{0} (has_lt.{0} char))) h0)  := sorry --non-trivial
lemma new_lemma_16104 (h0 : topological_space (ordered_cancel_add_comm_monoid (option (option num)))) : totally_separated_space (ordered_cancel_add_comm_monoid (option (option num))) := sorry --non-trivial
lemma new_lemma_16105 (h1 : has_mem.mem (id linarith.comp) has_emptyc.emptyc) : @is_add_cyclic.{0} (@id.{2} Type linarith.comp) (@finset.pi.empty.{1 0} Type add_group.{0} (@id.{2} Type linarith.comp) h1)  := sorry --non-trivial
lemma new_lemma_16106 (h0 : multiset (denumerable (metric_space char))) : multiset.nodup h0 := sorry --non-trivial
lemma new_lemma_16107 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (semiring empty)) := sorry --non-trivial
lemma new_lemma_16108 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : add_monoid.fg real := sorry --non-trivial
lemma new_lemma_16109 (h0 : topological_space (partial_order (non_assoc_semiring congr_arg_kind))) : totally_separated_space (partial_order (non_assoc_semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_16110 (h1 : group linarith.ineq) : normalizer_condition linarith.ineq := sorry --non-trivial
lemma new_lemma_16111 (h0 : functor.add_const (topological_space (preorder empty)) congr_arg_kind) : @topological_space.separable_space.{0} (preorder.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (preorder.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_16112 (h0 : functor.add_const (ring (has_to_string pos)) (add_cancel_monoid pos)) : @is_domain.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_to_string.{0} pos)) (add_cancel_monoid.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_16113 (h0 : topological_space (has_neg (has_to_string pos))) : discrete_topology (has_neg (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_16114 (h0 : not (group (has_inv to_additive.value_type) -> false)) : @group.fg.{0} (has_inv.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (group.{0} (has_inv.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_16115 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @is_cyclic.{0} (measurable_space.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) group.{0}) (measurable_space.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_16116 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (generalized_boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (generalized_boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_16117 (h0 : topological_space (add_comm_monoid (ordered_comm_monoid real))) : t1_space (add_comm_monoid (ordered_comm_monoid real)) := sorry --non-trivial
lemma new_lemma_16118 (h0 : has_lt (linear_ordered_comm_group_with_zero std_gen)) : no_max_order (linear_ordered_comm_group_with_zero std_gen) := sorry --non-trivial
lemma new_lemma_16119 (h0 : filter std_gen) (h1 : linarith.ineq -> Prop) (h2 : linarith.ineq -> set std_gen) : filter.has_countable_basis h0 h1 h2 := sorry --non-trivial
lemma new_lemma_16120 (h0 : complete_lattice (add_cancel_monoid (has_add linarith.comp))) : is_atomistic (add_cancel_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_16121 (h0 : has_mem.mem group has_emptyc.emptyc) : @is_cyclic.{0} (with_bot.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} h0) (with_bot.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_16122 (h0 : ring (ordered_comm_monoid (has_add (ring (ring (ring (ring linarith.comp))))))) : strong_rank_condition (ordered_comm_monoid (has_add (ring (ring (ring (ring linarith.comp)))))) := sorry --non-trivial
lemma new_lemma_16123 (h0 : topological_space (normed_comm_ring (has_pos_part linarith.comp))) : normal_space (normed_comm_ring (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_16124 (h2 : topological_space (add_comm_semigroup char)) : t0_space (add_comm_semigroup char) := sorry --non-trivial
lemma new_lemma_16125 (h0 : functor.add_const (topological_space (ordered_comm_monoid Type)) linarith.comp) : @sequential_space.{1} (ordered_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ordered_comm_monoid.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_16126 (h0 : functor.add_const (cancel_comm_monoid_with_zero (generalized_boolean_algebra Type)) pos) : @unique_factorization_monoid.{1} (generalized_boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (cancel_comm_monoid_with_zero.{1} (generalized_boolean_algebra.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_16127 (h0 : topological_space (ordered_comm_ring Type)) : totally_disconnected_space (ordered_comm_ring Type) := sorry --non-trivial
lemma new_lemma_16128 (h0 : group (has_pos_part (has_pos_part (has_add pos)))) : normalizer_condition (has_pos_part (has_pos_part (has_add pos))) := sorry --non-trivial
lemma new_lemma_16129 (h0 : monoid (measurable_space (random_gen linarith.ineq))) : monoid.fg (measurable_space (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_16130 (h0 : functor.add_const (topological_space name) unsigned) : @t1_space.{0} name (@functor.add_const.run.{0 0} (topological_space.{0} name) unsigned h0)  := sorry --non-trivial
lemma new_lemma_16131 (h0 : topological_space (boolean_algebra unsigned)) : locally_compact_space (boolean_algebra unsigned) := sorry --non-trivial
lemma new_lemma_16132 (h0 : complete_lattice (dlist (random_gen (random_gen to_additive.value_type)))) : is_compactly_generated (dlist (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_16133 (h1 : topological_space (normed_field reducibility_hints)) : path_connected_space (normed_field reducibility_hints) := sorry --non-trivial
lemma new_lemma_16134 (h0 : ring (is_R_or_C empty)) : is_principal_ideal_ring (is_R_or_C empty) := sorry --non-trivial
lemma new_lemma_16135 (h2 : complete_lattice (mul_one_class (mul_one_class string.iterator_imp))) : complete_lattice.is_Sup_finite_compact (mul_one_class (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_16136 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_16137 (h0 : topological_space (add_comm_semigroup enat)) (h2 : Prop) : is_path_connected (id (fun (h1 : add_comm_semigroup enat), h2)) := sorry --non-trivial
lemma new_lemma_16138 (h0 : topological_space (ring (has_Inf pos))) : preirreducible_space (ring (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_16139 (h0 : group (boolean_algebra.core Type)) : group.fg (boolean_algebra.core Type) := sorry --non-trivial
lemma new_lemma_16140 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_16141 (h0 : function.extfun Type group) : @group.fg.{0} (pseudo_metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (pseudo_metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_16142 (h0 : topological_space (has_zero (finset linarith.comp))) : totally_separated_space (has_zero (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_16143 (h0 : topological_space (ordered_comm_ring (has_pos_part linarith.comp))) : preirreducible_space (ordered_comm_ring (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_16144 (h0 : nat) (h1 : ring (ordered_cancel_add_comm_monoid (sym ennreal h0))) : rank_condition (ordered_cancel_add_comm_monoid (sym ennreal h0)) := sorry --non-trivial
lemma new_lemma_16145 (h0 : not (filter (denumerable string_imp) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_16146 (h0 : function.extfun nat fin) : @irreducible_space.{0} (canonically_linear_ordered_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (canonically_linear_ordered_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_16147 (h0 : functor.add_const (group (option num)) (semiring num)) : @normalizer_condition.{0} (option.{0} num) (@functor.add_const.run.{0 0} (group.{0} (option.{0} num)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_16148 (h0 : group (with_bot (has_norm linarith.ineq))) : is_cyclic (with_bot (has_norm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_16149 (h0 : topological_space (has_to_string (option pos))) : totally_disconnected_space (has_to_string (option pos)) := sorry --non-trivial
lemma new_lemma_16150 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (option.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} empty)))))) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (option.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} empty)))))))  := sorry --non-trivial
lemma new_lemma_16151 (h0 : topological_space (normed_linear_ordered_group (semiring num))) : totally_separated_space (normed_linear_ordered_group (semiring num)) := sorry --non-trivial
lemma new_lemma_16152 (h0 : topological_space (normed_comm_ring linarith.comp)) : irreducible_space (normed_comm_ring linarith.comp) := sorry --non-trivial
lemma new_lemma_16153 (h0 : topological_space (generalized_boolean_algebra (ordered_comm_ring (comm_semigroup (has_add real))))) : t1_space (generalized_boolean_algebra (ordered_comm_ring (comm_semigroup (has_add real)))) := sorry --non-trivial
lemma new_lemma_16154 (h0 : functor.add_const (topological_space (cancel_monoid pos)) linarith.comp) : @t0_space.{0} (cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_16155 (h0 : ring (simple_graph (has_Inf (boolean_algebra.core pos)))) : rank_condition (simple_graph (has_Inf (boolean_algebra.core pos))) := sorry --non-trivial
lemma new_lemma_16156 (h0 : complete_lattice (has_append (random_gen (metric_space char)))) : complete_lattice.is_Sup_finite_compact (has_append (random_gen (metric_space char))) := sorry --non-trivial
lemma new_lemma_16157 (h0 : functor.add_const (function.extfun Type topological_space) unsigned) : @topological_space.separable_space.{0} (normed_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) unsigned h0) (normed_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_16158 (h0 : not (complete_lattice (encodable linarith.ineq) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (encodable.{0} linarith.ineq) (@classical.by_contradiction'.{1} (complete_lattice.{0} (encodable.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_16159 (h0 : topological_space (has_bot (has_Inf (has_Inf name)))) : sequential_space (has_bot (has_Inf (has_Inf name))) := sorry --non-trivial
lemma new_lemma_16160 (h0 : topological_space (canonically_ordered_comm_semiring pos)) : preirreducible_space (canonically_ordered_comm_semiring pos) := sorry --non-trivial
lemma new_lemma_16161 (h0 : uniform_space (normed_group empty)) : complete_space (normed_group empty) := sorry --non-trivial
lemma new_lemma_16162 (h0 : topological_space (canonically_ordered_add_monoid num)) : t0_space (canonically_ordered_add_monoid num) := sorry --non-trivial
lemma new_lemma_16163 (h0 : list (has_neg (linear_ordered_add_comm_monoid_with_top Type))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_16164 (h0 : topological_space (complete_semilattice_Sup (random_gen (random_gen linarith.comp_source)))) : locally_compact_space (complete_semilattice_Sup (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_16165 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (ordered_cancel_add_comm_monoid.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_cancel_add_comm_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_16166 (h0 : complete_lattice (simple_graph string.iterator_imp)) : complete_lattice.is_Sup_finite_compact (simple_graph string.iterator_imp) := sorry --non-trivial
lemma new_lemma_16167 (h2 : complete_lattice (random_gen to_additive.value_type)) : is_compactly_generated (random_gen to_additive.value_type) := sorry --non-trivial
lemma new_lemma_16168 (h0 : ring (simple_graph name)) : is_domain (simple_graph name) := sorry --non-trivial
lemma new_lemma_16169 (h0 : functor.add_const (monoid (semigroup Type)) (ring (cancel_monoid environment.implicit_infer_kind))) : @monoid.fg.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (monoid.{1} (semigroup.{1} Type)) (ring.{0} (cancel_monoid.{0} environment.implicit_infer_kind)) h0)  := sorry --non-trivial
lemma new_lemma_16170 (h2 : topological_space (metric_space (metric_space linarith.comp_source))) (h3 : set (metric_space (metric_space linarith.comp_source))) : is_seq_closed h3 := sorry --non-trivial
lemma new_lemma_16171 (h2 : set (std_gen -> enat)) : set.separates_points h2 := sorry --non-trivial
lemma new_lemma_16172 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @monoid.fg.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) monoid.{0}) (complete_semilattice_Sup.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_16173 (h0 : add_group (denumerable (has_inv linarith.comp_source))) : is_add_cyclic (denumerable (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_16174 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (has_dist.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_dist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_16175 (h0 : list (normed_comm_ring (add_comm_monoid pos))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_16176 (h0 : topological_space (monoid congr_arg_kind)) : totally_separated_space (monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_16177 (h0 : functor.add_const (topological_space (generalized_boolean_algebra pos)) pos) : @irreducible_space.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_16178 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (denumerable.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (denumerable.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_16179 (h0 : not (ring (encodable linarith.ineq) -> false)) : @is_domain.{0} (encodable.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (encodable.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_16180 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (add_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_16181 (h1 : uniform_space (topological_space linarith.ineq)) : complete_space (topological_space linarith.ineq) := sorry --non-trivial
lemma new_lemma_16182 (h0 : function.extfun Type group) : @is_cyclic.{0} (filter.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (filter.{0} empty))  := sorry --non-trivial
lemma new_lemma_16183 (h0 : cancel_comm_monoid_with_zero (omega_complete_partial_order unsigned)) : unique_factorization_monoid (omega_complete_partial_order unsigned) := sorry --non-trivial
lemma new_lemma_16184 (h0 : add_monoid (with_one (semiring fun_info))) : add_monoid.fg (with_one (semiring fun_info)) := sorry --non-trivial
lemma new_lemma_16185 (h0 : add_comm_group (normed_field linarith.ineq)) (h1 : has_norm (normed_field linarith.ineq)) : normed_group.core (normed_field linarith.ineq) := sorry --non-trivial
lemma new_lemma_16186 (h0 : semiring (preorder unsigned)) : is_noetherian_ring (preorder unsigned) := sorry --non-trivial
lemma new_lemma_16187 (h0 : ring (monoid (option unsigned))) : rank_condition (monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_16188 (h0 : topological_space (has_add (ring Type))) : t0_space (has_add (ring Type)) := sorry --non-trivial
lemma new_lemma_16189 (h0 : functor.add_const (topological_space (semiring unsigned)) num) : @topological_space.separable_space.{0} (semiring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (semiring.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_16190 (h0 : group (has_to_string (has_add name))) : normalizer_condition (has_to_string (has_add name)) := sorry --non-trivial
lemma new_lemma_16191 (h0 : function.extfun Type (functor.comp complete_lattice has_neg)) : @complete_lattice.is_Sup_finite_compact.{0} (has_neg.{0} ennreal) (@functor.comp.run.{0 0 0} complete_lattice.{0} has_neg.{0} ennreal (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} complete_lattice.{0} has_neg.{0}) h0 ennreal))  := sorry --non-trivial
lemma new_lemma_16192 (h0 : filter (semigroup (ring linarith.comp))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_16193 (h0 : complete_lattice (normed_field (has_nnnorm string.iterator_imp))) : complete_lattice.is_Sup_finite_compact (normed_field (has_nnnorm string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_16194 (h0 : list (pseudo_metric_space empty)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_16195 (h0 : topological_space (plift (option empty))) : t1_space (plift (option empty)) := sorry --non-trivial
lemma new_lemma_16196 (h0 : ring (has_norm (has_norm to_additive.value_type))) : strong_rank_condition (has_norm (has_norm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_16197 (h0 : topological_space (ordered_comm_ring (has_add (has_add (has_add (has_Inf (has_Inf linarith.comp))))))) : regular_space (ordered_comm_ring (has_add (has_add (has_add (has_Inf (has_Inf linarith.comp)))))) := sorry --non-trivial
lemma new_lemma_16198 (h0 : functor.add_const (ordered_comm_monoid (normed_comm_ring name)) (has_add pos)) : @has_exists_mul_of_le.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (normed_comm_ring.{0} name)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_16199 (h0 : set (has_div linarith.ineq)) (h1 : has_div linarith.ineq -> has_div linarith.ineq -> Prop) : set.partially_well_ordered_on h0 h1 := sorry --non-trivial
lemma new_lemma_16200 (h0 : not (function.extfun Type topological_space -> false)) : @discrete_topology.{0} (has_norm.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_norm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_16201 (h0 : topological_space (ring (ring pos))) : loc_path_connected_space (ring (ring pos)) := sorry --non-trivial
lemma new_lemma_16202 (h0 : group (has_to_string (option name))) : normalizer_condition (has_to_string (option name)) := sorry --non-trivial
lemma new_lemma_16203 (h0 : ring (add_cancel_comm_monoid (random_gen (random_gen char)))) : is_domain (add_cancel_comm_monoid (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_16204 (h0 : topological_space (has_well_founded num)) : loc_path_connected_space (has_well_founded num) := sorry --non-trivial
lemma new_lemma_16205 (h0 : not (topological_space (partial_order empty) -> false)) : @t1_space.{0} (partial_order.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (partial_order.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_16206 (h0 : topological_space (has_zero (has_neg_part pos))) : regular_space (has_zero (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_16207 (h0 : ordered_comm_monoid (has_nndist (has_add name))) : has_exists_mul_of_le (has_nndist (has_add name)) := sorry --non-trivial
lemma new_lemma_16208 (h0 : ring (mul_zero_class ennreal)) : rank_condition (mul_zero_class ennreal) := sorry --non-trivial
lemma new_lemma_16209 (h0 : filter (has_to_string (ring linarith.comp))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_16210 (h0 : functor.add_const (finset (semiring unsigned)) unsigned) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_16211 (h0 : functor.add_const (function.extfun Type ring) Type) : @is_principal_ideal_ring.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ring.{0}) Type h0) (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_16212 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (semigroup.{0} ennreal) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (semigroup.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_16213 (h0 : group (metric_space empty)) : normalizer_condition (metric_space empty) := sorry --non-trivial
lemma new_lemma_16214 (h0 : topological_space (has_neg (has_pos_part pos))) : sequential_space (has_neg (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_16215 (h1 : not (topological_space (with_one linarith.comp) -> false)) : @totally_disconnected_space.{0} (with_one.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (with_one.{0} linarith.comp)) h1)  := sorry --non-trivial
lemma new_lemma_16216 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} real (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) real)  := sorry --non-trivial
lemma new_lemma_16217 (h0 : not (topological_space (topological_space (has_nnnorm linarith.comp_source)) -> false)) : @t0_space.{0} (topological_space.{0} (has_nnnorm.{0} linarith.comp_source)) (@classical.by_contradiction'.{1} (topological_space.{0} (topological_space.{0} (has_nnnorm.{0} linarith.comp_source))) h0)  := sorry --non-trivial
lemma new_lemma_16218 (h1 : complete_lattice (has_norm (has_norm fun_info))) : is_atomistic (has_norm (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_16219 (h0 : ordered_comm_monoid (simple_graph (has_add (has_add linarith.comp)))) : has_exists_mul_of_le (simple_graph (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_16220 (h0 : semiring (linear_ordered_field (has_neg pos))) : is_noetherian_ring (linear_ordered_field (has_neg pos)) := sorry --non-trivial
lemma new_lemma_16221 (h0 h1 : multiset (add_comm_semigroup ereal)) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_16222 (h0 : group (has_ssubset (has_nnnorm to_additive.value_type))) : is_cyclic (has_ssubset (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_16223 (h0 : complete_lattice (has_one (has_norm (has_norm congr_arg_kind)))) : is_compactly_generated (has_one (has_norm (has_norm congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_16224 (h0 : uniform_space (ring (has_pos_part Type))) : complete_space (ring (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_16225 (h0 : add_monoid (has_pos_part (has_Inf real))) : add_monoid.fg (has_pos_part (has_Inf real)) := sorry --non-trivial
lemma new_lemma_16226 (h0 : ordered_comm_monoid (ordered_comm_ring (boolean_algebra.core linarith.comp))) : has_exists_mul_of_le (ordered_comm_ring (boolean_algebra.core linarith.comp)) := sorry --non-trivial
lemma new_lemma_16227 (h2 : ring (linear_ordered_add_comm_group char)) : rank_condition (linear_ordered_add_comm_group char) := sorry --non-trivial
lemma new_lemma_16228 (h0 : functor.add_const (function.extfun Type monoid) Type) : @monoid.fg.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type monoid.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type monoid.{0}) Type h0) (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_16229 (h0 : function.extfun Type (functor.add_const (topological_space ennreal))) : path_connected_space ennreal := sorry --non-trivial
lemma new_lemma_16230 (h0 : ring (has_add (add_cancel_monoid environment.implicit_infer_kind))) : is_domain (has_add (add_cancel_monoid environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_16231 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (left_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type semiring.{0} h0 (left_cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_16232 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (add_semigroup.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_16233 (h0 : topological_space (complete_distrib_lattice Type)) : discrete_topology (complete_distrib_lattice Type) := sorry --non-trivial
lemma new_lemma_16234 (h1 : topological_space (has_lt (random_gen char))) : t0_space (has_lt (random_gen char)) := sorry --non-trivial
lemma new_lemma_16235 (h0 : functor.add_const (ordered_add_comm_monoid (left_cancel_semigroup empty)) congr_arg_kind) : @archimedean.{0} (left_cancel_semigroup.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (left_cancel_semigroup.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_16236 (h0 : functor.add_const (add_group (has_add environment.implicit_infer_kind)) linarith.comp) : @is_add_cyclic.{0} (has_add.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (add_group.{0} (has_add.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_16237 (h0 : monoid (ring (boolean_algebra environment.implicit_infer_kind))) : monoid.fg (ring (boolean_algebra environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_16238 (h0 : topological_space (option num)) : regular_space (option num) := sorry --non-trivial
lemma new_lemma_16239 (h0 : fin has_zero.zero) : @group.fg.{1} (canonically_linear_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (group.{1} (canonically_linear_ordered_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_16240 (h0 : topological_space (with_bot (has_norm linarith.comp))) : discrete_topology (with_bot (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_16241 (h0 : complete_lattice (add_comm_semigroup environment.projection_info)) : complete_lattice.is_Sup_finite_compact (add_comm_semigroup environment.projection_info) := sorry --non-trivial
lemma new_lemma_16242 (h0 : ring (option (option ennreal))) : is_domain (option (option ennreal)) := sorry --non-trivial
lemma new_lemma_16243 (h0 : complete_lattice (finset unsigned)) : is_compactly_generated (finset unsigned) := sorry --non-trivial
lemma new_lemma_16244 (h0 : ordered_comm_monoid (canonically_ordered_comm_semiring (option (option pos)))) : has_exists_mul_of_le (canonically_ordered_comm_semiring (option (option pos))) := sorry --non-trivial
lemma new_lemma_16245 (h1 : ring (measurable_space linarith.comp)) : rank_condition (measurable_space linarith.comp) := sorry --non-trivial
lemma new_lemma_16246 (h0 : ring (has_nnnorm (uniform_space (mul_one_class string.iterator_imp)))) : rank_condition (has_nnnorm (uniform_space (mul_one_class string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_16247 (h0 : topological_space (generalized_boolean_algebra (has_neg name))) : t1_space (generalized_boolean_algebra (has_neg name)) := sorry --non-trivial
lemma new_lemma_16248 (h0 : functor.add_const (topological_space (measurable_space.dynkin_system empty)) empty) : @t1_space.{0} (measurable_space.dynkin_system.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (measurable_space.dynkin_system.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_16249 (h0 : not (function.extfun (finset Type) (has_mem.mem (measurable_space empty)) -> false)) : @discrete_topology.{0} (measurable_space.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (measurable_space.{0} empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (measurable_space.{0} empty)) (@classical.by_contradiction'.{0} (function.extfun.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (measurable_space.{0} empty))) h0) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_16250 (h0 : group (monoid_with_zero pos)) : is_simple_group (monoid_with_zero pos) := sorry --non-trivial
lemma new_lemma_16251 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (linear_ordered_cancel_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (linear_ordered_cancel_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_16252 (h0 : filter (id (random_gen (semiring linarith.comp)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_16253 (h0 : functor.add_const (topological_space (has_add pos)) (finset linarith.comp)) : @loc_path_connected_space.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} pos)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_16254 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (random_gen.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (random_gen.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_16255 (h0 : ring (simple_graph unsigned)) : rank_condition (simple_graph unsigned) := sorry --non-trivial
lemma new_lemma_16256 (h0 : group (has_to_string (has_to_string (finset Type)))) : is_simple_group (has_to_string (has_to_string (finset Type))) := sorry --non-trivial
lemma new_lemma_16257 (h0 : uniform_space (has_one (semiring linarith.comp))) : separated_space (has_one (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_16258 (h0 : topological_space (has_top num)) : t0_space (has_top num) := sorry --non-trivial
lemma new_lemma_16259 (h0 : ring (semiring (has_top fun_info))) : is_domain (semiring (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_16260 (h0 : topological_space (has_zero (has_add unsigned))) : path_connected_space (has_zero (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_16261 (h0 : filter (add_comm_monoid unsigned)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_16262 (h0 : not (group (measurable_space.dynkin_system num) -> false)) : @normalizer_condition.{0} (measurable_space.dynkin_system.{0} num) (@classical.by_contradiction'.{1} (group.{0} (measurable_space.dynkin_system.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_16263 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_16264 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (normed_comm_ring.{0} name) (@function.extfun_app.{2 1} Type add_group.{0} h0 (normed_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_16265 (h0 : ring (ordered_comm_ring (has_add (ring linarith.comp)))) : strong_rank_condition (ordered_comm_ring (has_add (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_16266 (h0 : functor.add_const (topological_space (add_cancel_monoid environment.implicit_infer_kind)) linarith.comp) : @t1_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_16267 (h0 : topological_space (semiring (random_gen linarith.comp))) : sequential_space (semiring (random_gen linarith.comp)) := sorry --non-trivial
lemma new_lemma_16268 (h0 : function.extfun nat fin) : @path_connected_space.{1} (comm_semigroup.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (comm_semigroup.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_16269 (h0 : fin has_zero.zero) : @is_compactly_generated.{0} (uniform_space.core.{0} real) (@matrix.vec_empty.{0} (complete_lattice.{0} (uniform_space.core.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_16270 (h0 : not (function.extfun Type complete_lattice -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (with_bot.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (with_bot.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_16271 (h1 : add_group (add_comm_semigroup char)) : is_add_cyclic (add_comm_semigroup char) := sorry --non-trivial
lemma new_lemma_16272 (h0 : uniform_space (has_top (random_gen (random_gen linarith.ineq)))) : complete_space (has_top (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_16273 (h1 : ring (has_add fun_info)) : is_domain (has_add fun_info) := sorry --non-trivial
lemma new_lemma_16274 (h0 : topological_space (has_Inf (ring name))) : locally_compact_space (has_Inf (ring name)) := sorry --non-trivial
lemma new_lemma_16275 (h0 : functor.add_const (topological_space (finset name)) name) : @discrete_topology.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_16276 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (ordered_comm_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (ordered_comm_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_16277 (h0 : topological_space (add_cancel_monoid (finset (boolean_algebra (normed_comm_ring linarith.comp))))) : t1_space (add_cancel_monoid (finset (boolean_algebra (normed_comm_ring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_16278 (h0 : topological_space (boolean_algebra.core (has_add name))) : sequential_space (boolean_algebra.core (has_add name)) := sorry --non-trivial
lemma new_lemma_16279 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : countable_Inter_filter (function.extfun_app (function.extfun_app h0 filter) (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_16280 (h0 : functor.add_const (complete_lattice (non_assoc_semiring congr_arg_kind)) empty) : @complete_lattice.is_Sup_finite_compact.{0} (non_assoc_semiring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (non_assoc_semiring.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_16281 (h0 : function.extfun (Type 1) topological_space) : @preirreducible_space.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_16282 (h0 : functor.add_const (topological_space (normed_linear_ordered_group empty)) congr_arg_kind) : @loc_path_connected_space.{0} (normed_linear_ordered_group.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_linear_ordered_group.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_16283 (h0 : ordered_add_comm_monoid (semigroup (ring (has_pos_part (has_add linarith.comp))))) : archimedean (semigroup (ring (has_pos_part (has_add linarith.comp)))) := sorry --non-trivial
lemma new_lemma_16284 (h0 : not (complete_lattice (has_well_founded to_additive.value_type) -> false)) : @is_compactly_generated.{1} (has_well_founded.{1} to_additive.value_type) (@classical.by_contradiction'.{2} (complete_lattice.{1} (has_well_founded.{1} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_16285 (h0 : function.extfun Type (functor.add_const (topological_space auto.case_option))) : @t0_space.{0} auto.case_option (@functor.add_const.run.{0 0} (topological_space.{0} auto.case_option) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} auto.case_option)) h0 num))  := sorry --non-trivial
lemma new_lemma_16286 (h0 : complete_lattice (has_norm (has_inv linarith.ineq))) : is_atomistic (has_norm (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_16287 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (comm_group.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_group.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_16288 (h0 : cancel_comm_monoid_with_zero (semigroup (option (option (option (option pos)))))) : unique_factorization_monoid (semigroup (option (option (option (option pos))))) := sorry --non-trivial
lemma new_lemma_16289 (h0 : not (function.extfun (Type 1) topological_space -> false)) : @t0_space.{1} (plift.{1} empty) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@classical.by_contradiction'.{3} (function.extfun.{3 2} (Type 1) topological_space.{1}) h0) (plift.{1} empty))  := sorry --non-trivial
lemma new_lemma_16290 (h0 : functor.add_const (ring pos) (finset (finset (finset (finset (finset pos)))))) : @is_principal_ideal_ring.{0} pos (@functor.add_const.run.{0 0} (ring.{0} pos) (finset.{0} (finset.{0} (finset.{0} (finset.{0} (finset.{0} pos))))) h0)  := sorry --non-trivial
lemma new_lemma_16291 (h1 : add_group (has_ssubset (has_nnnorm char))) : is_add_cyclic (has_ssubset (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_16292 (h0 : add_group (has_top (random_gen linarith.comp_source))) : is_add_cyclic (has_top (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_16293 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (normed_group.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (normed_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_16294 (h0 : list (has_Inf (boolean_algebra.core (has_nndist linarith.comp)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_16295 (h0 : ring (with_bot unsigned)) : is_principal_ideal_ring (with_bot unsigned) := sorry --non-trivial
lemma new_lemma_16296 (h0 : ring (metric_space (has_norm (has_norm empty)))) : rank_condition (metric_space (has_norm (has_norm empty))) := sorry --non-trivial
lemma new_lemma_16297 (h0 : function.extfun (Type 1) add_group) : @is_add_cyclic.{1} (plift.{1} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_norm.{0} empty)))))) (@function.extfun_app.{3 2} (Type 1) add_group.{1} h0 (plift.{1} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_norm.{0} empty)))))))  := sorry --non-trivial
lemma new_lemma_16298 (h0 : function.extfun Type topological_space) : @normal_space.{0} (measurable_space.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measurable_space.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_16299 (h0 : uniform_space (has_add fun_info)) : complete_space (has_add fun_info) := sorry --non-trivial
lemma new_lemma_16300 (h0 : uniform_space (normed_group (semiring fun_info))) : separated_space (normed_group (semiring fun_info)) := sorry --non-trivial
lemma new_lemma_16301 (h0 : functor.add_const (function.extfun (Type 1) topological_space) pos) : @topological_space.separable_space.{1} (add_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) pos h0) (add_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_16302 (h0 : fin has_zero.zero) : @t0_space.{0} (sub_neg_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)) (sub_neg_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_16303 (h0 : functor.add_const (finset (cancel_monoid unsigned)) environment.implicit_infer_kind) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_16304 (h0 : functor.add_const (topological_space (normed_comm_ring environment.implicit_infer_kind)) linarith.comp) : @topological_space.separable_space.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_16305 (h0 : filter (bin_tree congr_arg_kind)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_16306 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (ordered_comm_monoid.{0} real) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (ordered_comm_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_16307 (h0 : functor.add_const (complete_lattice (normed_comm_ring unsigned)) pos) : @is_compactly_generated.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (normed_comm_ring.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_16308 (h0 : ring (ring (option (option unsigned)))) : is_principal_ideal_ring (ring (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_16309 (h0 : not (semiring (linear_ordered_semiring congr_arg_kind) -> false)) : @is_noetherian_ring.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (semiring.{0} (linear_ordered_semiring.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_16310 (h0 : not (function.extfun (finset Type) (has_mem.mem (measurable_space num)) -> false)) : @discrete_topology.{0} (measurable_space.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (measurable_space.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (measurable_space.{0} num)) (@classical.by_contradiction'.{0} (function.extfun.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (measurable_space.{0} num))) h0) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_16311 (h0 : functor.add_const (topological_space (ordered_comm_ring name)) Type) : @irreducible_space.{0} (ordered_comm_ring.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (ordered_comm_ring.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_16312 (h0 : functor.add_const (add_monoid (has_zero name)) (ring Type)) : @add_monoid.fg.{0} (has_zero.{0} name) (@functor.add_const.run.{0 1} (add_monoid.{0} (has_zero.{0} name)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_16313 (h0 : topological_space (has_compl (mul_one_class enat))) : t0_space (has_compl (mul_one_class enat)) := sorry --non-trivial
lemma new_lemma_16314 (h0 : uniform_space (semiring (has_norm fun_info))) : complete_space (semiring (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_16315 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @rank_condition.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ring.{1}) (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_16316 (h0 : functor.add_const (functor.add_const (topological_space name) num) (semiring congr_arg_kind)) : @preirreducible_space.{0} name (@functor.add_const.run.{0 0} (topological_space.{0} name) num (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (topological_space.{0} name) num) (semiring.{0} congr_arg_kind) h0))  := sorry --non-trivial
lemma new_lemma_16317 (h0 : not (ring (has_top to_additive.value_type) -> false)) : @is_domain.{0} (has_top.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (has_top.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_16318 (h0 : topological_space (finset pos)) : sequential_space (finset pos) := sorry --non-trivial
lemma new_lemma_16319 (h0 : list (linear_ordered_cancel_comm_monoid congr_arg_kind)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_16320 (h0 : add_monoid (has_union (has_union linarith.comp))) : add_monoid.fg (has_union (has_union linarith.comp)) := sorry --non-trivial
lemma new_lemma_16321 (h0 : filter (has_to_string (comm_group pos))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_16322 (h0 : functor.add_const (ring (free_add_monoid congr_arg_kind)) num) : @rank_condition.{0} (free_add_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ring.{0} (free_add_monoid.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_16323 (h0 : ring string.iterator) : strong_rank_condition string.iterator := sorry --non-trivial
lemma new_lemma_16324 (h0 : complete_lattice (pseudo_metric_space empty)) : is_atomistic (pseudo_metric_space empty) := sorry --non-trivial
lemma new_lemma_16325 (h0 : measurable_space ennreal) (h1 : function.extfun Type has_add) : has_measurable_add ennreal := sorry --non-trivial
lemma new_lemma_16326 (h0 : filter (has_nndist num)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_16327 (h0 : ring (finset (has_Inf (has_Inf (has_pos_part Type))))) : is_principal_ideal_ring (finset (has_Inf (has_Inf (has_pos_part Type)))) := sorry --non-trivial
lemma new_lemma_16328 (h0 : ring (has_Inf (has_Inf (has_Inf (has_pos_part (has_add (has_add name))))))) : rank_condition (has_Inf (has_Inf (has_Inf (has_pos_part (has_add (has_add name)))))) := sorry --non-trivial
lemma new_lemma_16329 (h1 : normed_group linarith.comp_source -> Prop) : @infi.{0 1} Prop (@conditionally_complete_lattice.to_has_Inf.{0} Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice)) (normed_group.{0} linarith.comp_source) h1  := sorry --non-trivial
lemma new_lemma_16330 (h0 : functor.add_const (topological_space (has_add name)) Type) : @sequential_space.{0} (has_add.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (has_add.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_16331 (h0 : list (comm_monoid congr_arg_kind)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_16332 (h0 : not (filter (has_ssubset linarith.comp_source) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_16333 (h0 : add_monoid (complete_distrib_lattice (has_neg environment.implicit_infer_kind))) : add_monoid.fg (complete_distrib_lattice (has_neg environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_16334 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (partial_order.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (partial_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_16335 (h0 : topological_space (add_group (semiring num))) : totally_separated_space (add_group (semiring num)) := sorry --non-trivial
lemma new_lemma_16336 (h0 : add_group (measurable_space (semiring congr_arg_kind))) : is_add_cyclic (measurable_space (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_16337 (h0 : complete_lattice (semigroup (option unsigned))) : is_compactly_generated (semigroup (option unsigned)) := sorry --non-trivial
lemma new_lemma_16338 (h0 : list (has_edist empty)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_16339 (h0 : list (add_cancel_monoid unsigned)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_16340 (h0 : topological_space (random_gen (random_gen linarith.ineq))) : locally_compact_space (random_gen (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_16341 (h0 : topological_space (has_inf (has_nnnorm to_additive.value_type))) : totally_disconnected_space (has_inf (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_16342 (h0 : functor.add_const (functor.add_const (topological_space string) environment.implicit_infer_kind) Type) : @locally_compact_space.{0} string (@functor.add_const.run.{0 0} (topological_space.{0} string) environment.implicit_infer_kind (@functor.add_const.run.{0 1} (functor.add_const.{0 0} (topological_space.{0} string) environment.implicit_infer_kind) Type h0))  := sorry --non-trivial
lemma new_lemma_16343 (h0 : functor.add_const (functor.add_const (topological_space pos) linarith.comp) Type) : @path_connected_space.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) linarith.comp (@functor.add_const.run.{0 1} (functor.add_const.{0 0} (topological_space.{0} pos) linarith.comp) Type h0))  := sorry --non-trivial
lemma new_lemma_16344 (h0 : function.extfun Type (functor.comp topological_space canonically_ordered_comm_semiring)) : @t1_space.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@functor.comp.run.{0 0 0} topological_space.{0} canonically_ordered_comm_semiring.{0} unsigned (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} canonically_ordered_comm_semiring.{0}) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_16345 (h0 : topological_space (with_zero (has_nnnorm (has_nnnorm (has_nnnorm linarith.ineq))))) : path_connected_space (with_zero (has_nnnorm (has_nnnorm (has_nnnorm linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_16346 (h0 : uniform_space (linear_ordered_comm_monoid_with_zero (option empty))) : separated_space (linear_ordered_comm_monoid_with_zero (option empty)) := sorry --non-trivial
lemma new_lemma_16347 (h0 : topological_space (dlist (random_gen fun_info))) : totally_disconnected_space (dlist (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_16348 (h0 : function.extfun (finset Type) (has_mem.mem (random_gen linarith.comp))) : @totally_disconnected_space.{0} (random_gen.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (random_gen.{0} linarith.comp) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} linarith.comp)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_16349 (h0 : ring (with_zero linarith.comp_source)) : is_domain (with_zero linarith.comp_source) := sorry --non-trivial
lemma new_lemma_16350 (h0 : list (normed_group (has_norm (has_norm fun_info)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_16351 (h0 : topological_space (has_nnnorm (random_gen (random_gen fun_info)))) : totally_disconnected_space (has_nnnorm (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_16352 (h0 : functor.add_const (ring (has_to_string Type)) (ring (ring (ring (ring Type))))) : @rank_condition.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 1} (ring.{1} (has_to_string.{1} Type)) (ring.{1} (ring.{1} (ring.{1} (ring.{1} Type)))) h0)  := sorry --non-trivial
lemma new_lemma_16353 (h0 : topological_space (has_neg (comm_monoid_with_zero linarith.comp))) : t0_space (has_neg (comm_monoid_with_zero linarith.comp)) := sorry --non-trivial
lemma new_lemma_16354 (h0 : ordered_comm_monoid (has_pos_part (ring linarith.comp))) : has_exists_mul_of_le (has_pos_part (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_16355 (h0 : uniform_space (id (random_gen (random_gen (random_gen string_imp))))) : complete_space (id (random_gen (random_gen (random_gen string_imp)))) := sorry --non-trivial
lemma new_lemma_16356 (h0 : add_group (has_zero (has_neg_part pos))) : is_add_cyclic (has_zero (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_16357 (h0 : complete_lattice (semi_normed_ring (mul_one_class string.iterator_imp))) : complete_lattice.is_Sup_finite_compact (semi_normed_ring (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_16358 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (normed_group.{0} (has_norm.{0} (has_norm.{0} (has_norm.{0} (has_top.{0} fun_info))))) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (normed_group.{0} (has_norm.{0} (has_norm.{0} (has_norm.{0} (has_top.{0} fun_info))))))  := sorry --non-trivial
lemma new_lemma_16359 (h0 : ring (has_compl (random_gen reducibility_hints))) : strong_rank_condition (has_compl (random_gen reducibility_hints)) := sorry --non-trivial
lemma new_lemma_16360 (h0 : add_group linarith.ineq) : is_add_cyclic linarith.ineq := sorry --non-trivial
lemma new_lemma_16361 (h0 : not (finset Prop -> false)) (h1 : function.extfun (finset Prop) finset.nonempty) : @finset.max'.{0} Prop Prop.linear_order (@classical.by_contradiction'.{1} (finset.{0} Prop) h0) (@function.extfun_app.{1 0} (finset.{0} Prop) (@finset.nonempty.{0} Prop) h1 (@classical.by_contradiction'.{1} (finset.{0} Prop) h0))  := sorry --non-trivial
lemma new_lemma_16362 (h0 : finset (normed_comm_ring empty)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_16363 (h1 : complete_lattice (with_bot fun_info)) : is_compactly_generated (with_bot fun_info) := sorry --non-trivial
lemma new_lemma_16364 (h0 : functor.add_const (finset (normed_comm_ring pos)) pos) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_16365 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (metric_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (metric_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_16366 (h1 : ring (topological_space reducibility_hints)) : strong_rank_condition (topological_space reducibility_hints) := sorry --non-trivial
lemma new_lemma_16367 (h0 : complete_lattice (boolean_algebra (comm_group (comm_group (comm_group name))))) : is_compactly_generated (boolean_algebra (comm_group (comm_group (comm_group name)))) := sorry --non-trivial
lemma new_lemma_16368 (h0 : functor.add_const (uniform_space (has_nndist linarith.comp)) linarith.comp) : @separated_space.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_nndist.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_16369 (h0 : has_mem.mem (has_emptyc num) has_emptyc.emptyc) : @complete_space.{0} (has_emptyc.{0} num) (@finset.pi.empty.{1 0} Type uniform_space.{0} (has_emptyc.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_16370 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} znum (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 znum)  := sorry --non-trivial
lemma new_lemma_16371 (h0 : not (filter (has_emptyc num) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_16372 (h0 : functor.add_const (function.extfun Type group) name) : @normalizer_condition.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) name h0) (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_16373 (h0 : not (complete_lattice (has_emptyc num) -> false)) : @is_atomistic.{0} (has_emptyc.{0} num) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_emptyc.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_16374 (h1 : complete_lattice (measurable_space (with_bot congr_arg_kind))) : complete_lattice.is_Sup_finite_compact (measurable_space (with_bot congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_16375 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (preorder.{0} empty) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (preorder.{0} empty))  := sorry --non-trivial
lemma new_lemma_16376 (h0 : functor.add_const Prop (has_norm (semiring (has_norm empty)))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_16377 (h0 : fin has_zero.zero) : @is_compactly_generated.{0} (canonically_ordered_monoid.{0} real) (@matrix.vec_empty.{0} (complete_lattice.{0} (canonically_ordered_monoid.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_16378 (h0 : heq (has_nnnorm (has_ssubset char)) (topological_space linarith.comp_source)) (h1 : uniform_space (has_nnnorm (has_ssubset char))) : @complete_space.{0} (topological_space.{0} linarith.comp_source) (@heq.elim.{2 1} Type (has_nnnorm.{0} (has_ssubset.{0} char)) uniform_space.{0} (topological_space.{0} linarith.comp_source) h0 h1)  := sorry --non-trivial
lemma new_lemma_16379 (h0 : filter (id (has_union (has_union congr_arg_kind)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_16380 (h0 : ring (has_neg_part name)) : rank_condition (has_neg_part name) := sorry --non-trivial
lemma new_lemma_16381 (h0 : functor.add_const (ring environment.implicit_infer_kind) (has_pos_part (has_pos_part (has_pos_part pos)))) : @is_domain.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 0} (ring.{0} environment.implicit_infer_kind) (has_pos_part.{0} (has_pos_part.{0} (has_pos_part.{0} pos))) h0)  := sorry --non-trivial
lemma new_lemma_16382 (h0 : ordered_add_comm_monoid (simple_graph (has_neg (has_neg name)))) : archimedean (simple_graph (has_neg (has_neg name))) := sorry --non-trivial
lemma new_lemma_16383 (h2 : uniform_space (topological_space linarith.comp_source)) : complete_space (topological_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_16384 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (has_edist.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type semiring.{0} h0 (has_edist.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_16385 (h0 : functor.add_const (uniform_space (generalized_boolean_algebra pos)) Type) : @complete_space.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 1} (uniform_space.{0} (generalized_boolean_algebra.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_16386 (h0 : set (has_neg string.iterator_imp)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_16387 (h0 : functor.add_const (add_monoid (plift empty)) (semiring empty)) : @add_monoid.fg.{1} (plift.{1} empty) (@functor.add_const.run.{1 0} (add_monoid.{1} (plift.{1} empty)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_16388 (h0 : monoid (random_gen (has_emptyc (complete_semilattice_Sup congr_arg_kind)))) : monoid.fg (random_gen (has_emptyc (complete_semilattice_Sup congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_16389 (h0 : functor.add_const (function.extfun Type group) Type) : @is_cyclic.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type group.{0}) Type h0) (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_16390 (h0 : ring (left_cancel_semigroup (left_cancel_semigroup (semiring empty)))) : is_domain (left_cancel_semigroup (left_cancel_semigroup (semiring empty))) := sorry --non-trivial
lemma new_lemma_16391 (h0 : filter (with_bot (has_ssubset linarith.ineq))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_16392 (h0 : functor.add_const (topological_space (simple_graph linarith.comp)) linarith.comp) : @loc_path_connected_space.{0} (simple_graph.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (simple_graph.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_16393 (h0 : semiring (sub_neg_monoid (has_Inf (has_Inf Type)))) : is_noetherian_ring (sub_neg_monoid (has_Inf (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_16394 (h0 : fin has_zero.zero) : @archimedean.{0} (ordered_comm_ring.{0} pos) (@matrix.vec_empty.{0} (ordered_add_comm_monoid.{0} (ordered_comm_ring.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_16395 (h0 : topological_space (boolean_algebra.core (finset name))) : loc_path_connected_space (boolean_algebra.core (finset name)) := sorry --non-trivial
lemma new_lemma_16396 (h0 : semiring (has_zero (finset (finset ennreal)))) : is_noetherian_ring (has_zero (finset (finset ennreal))) := sorry --non-trivial
lemma new_lemma_16397 (h0 : list (boolean_algebra (boolean_algebra.core name))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_16398 (h0 : topological_space (canonically_ordered_comm_semiring name)) : sequential_space (canonically_ordered_comm_semiring name) := sorry --non-trivial
lemma new_lemma_16399 (h0 : not (semiring (has_one fun_info) -> false)) : @is_noetherian_ring.{0} (has_one.{0} fun_info) (@classical.by_contradiction'.{1} (semiring.{0} (has_one.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_16400 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (ordered_ring unsigned)) := sorry --non-trivial
lemma new_lemma_16401 (h0 : functor.add_const (ring (has_Sup empty)) num) : @rank_condition.{0} (has_Sup.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (has_Sup.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_16402 (h0 : group (measurable_space (random_gen (has_inv linarith.comp_source)))) : is_cyclic (measurable_space (random_gen (has_inv linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_16403 (h1 : ring (denumerable (random_gen string_imp))) : is_domain (denumerable (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_16404 (h0 : ring (has_le environment.projection_info)) : rank_condition (has_le environment.projection_info) := sorry --non-trivial
lemma new_lemma_16405 (h0 : group (is_R_or_C congr_arg_kind)) : is_cyclic (is_R_or_C congr_arg_kind) := sorry --non-trivial
lemma new_lemma_16406 (h0 : ordered_add_comm_monoid (linear_ordered_cancel_comm_monoid (semiring empty))) : archimedean (linear_ordered_cancel_comm_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_16407 (h0 : not (topological_space (has_top num) -> false)) : @totally_separated_space.{0} (has_top.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (has_top.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_16408 (h0 : group (id (semiring num))) : is_cyclic (id (semiring num)) := sorry --non-trivial
lemma new_lemma_16409 (h0 : functor.comp topological_space semigroup environment.implicit_infer_kind) : @locally_compact_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_16410 (h0 : topological_space (has_neg_part (comm_group name))) : sequential_space (has_neg_part (comm_group name)) := sorry --non-trivial
lemma new_lemma_16411 (h0 : group string_imp) : normalizer_condition string_imp := sorry --non-trivial
lemma new_lemma_16412 (h0 : not (ring (has_nnnorm to_additive.value_type) -> false)) : @strong_rank_condition.{0} (has_nnnorm.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (has_nnnorm.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_16413 (h1 : topological_space (simple_graph (normed_field std_gen))) : path_connected_space (simple_graph (normed_field std_gen)) := sorry --non-trivial
lemma new_lemma_16414 (h0 : topological_space (comm_group congr_arg_kind)) : locally_compact_space (comm_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_16415 (h0 : complete_lattice (finset (has_neg (has_add Type)))) : is_atomistic (finset (has_neg (has_add Type))) := sorry --non-trivial
lemma new_lemma_16416 (h1 : ring (complete_semilattice_Sup string_imp)) : rank_condition (complete_semilattice_Sup string_imp) := sorry --non-trivial
lemma new_lemma_16417 (h0 : function.extfun (Type 1) complete_lattice) : @is_atomistic.{1} (comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} h0 (comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_16418 (h0 : ring (add_monoid (finset linarith.comp_source))) : is_domain (add_monoid (finset linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_16419 (h0 : complete_lattice (mul_zero_class (finset pos))) : is_compactly_generated (mul_zero_class (finset pos)) := sorry --non-trivial
lemma new_lemma_16420 (h1 : ring (has_emptyc linarith.comp)) : rank_condition (has_emptyc linarith.comp) := sorry --non-trivial
lemma new_lemma_16421 (h0 : add_group (semiring linarith.comp_source)) : is_add_cyclic (semiring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_16422 (h0 : functor.add_const (function.extfun (Type 1) uniform_space) pos) : @separated_space.{1} (ordered_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) uniform_space.{1}) pos h0) (ordered_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_16423 (h0 : topological_space (canonically_ordered_comm_semiring (has_add (has_add ennreal)))) : t0_space (canonically_ordered_comm_semiring (has_add (has_add ennreal))) := sorry --non-trivial
lemma new_lemma_16424 (h0 : not (topological_space (has_union fun_info) -> false)) : @locally_compact_space.{0} (has_union.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (has_union.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_16425 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_nndist.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_nndist.{0} empty))  := sorry --non-trivial
lemma new_lemma_16426 (h0 : functor.comp topological_space canonically_ordered_comm_semiring name) : @locally_compact_space.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} canonically_ordered_comm_semiring.{0} name h0)  := sorry --non-trivial
lemma new_lemma_16427 (h0 : functor.add_const (topological_space (add_cancel_monoid Type)) (has_pos_part (has_neg Type))) : @totally_disconnected_space.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (add_cancel_monoid.{1} Type)) (has_pos_part.{1} (has_neg.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_16428 (h0 : group (has_one (has_norm linarith.comp))) : normalizer_condition (has_one (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_16429 (h0 : function.extfun Type (functor.add_const (ring (mul_zero_class empty)))) : @strong_rank_condition.{0} (mul_zero_class.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (mul_zero_class.{0} empty)) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} (mul_zero_class.{0} empty))) h0 num))  := sorry --non-trivial
lemma new_lemma_16430 (h0 : functor.add_const (ring (comm_group unsigned)) pos) : @is_domain.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (comm_group.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_16431 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_16432 (h0 : not (add_group (partial_order num) -> false)) : @is_add_cyclic.{0} (partial_order.{0} num) (@classical.by_contradiction'.{1} (add_group.{0} (partial_order.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_16433 (h0 : ring (normed_field (has_nnnorm linarith.comp_source))) : rank_condition (normed_field (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_16434 (h1 : has_lt (normed_field (random_gen ereal))) : no_max_order (normed_field (random_gen ereal)) := sorry --non-trivial
lemma new_lemma_16435 (h0 : filter (complete_distrib_lattice (has_to_string unsigned))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_16436 (h0 : topological_space (has_dist (option (option empty)))) : discrete_topology (has_dist (option (option empty))) := sorry --non-trivial
lemma new_lemma_16437 (h0 : ring (non_unital_non_assoc_semiring (mul_one_class reducibility_hints)) -> Prop) (h1 : Exists (fun (x : ring (non_unital_non_assoc_semiring (mul_one_class reducibility_hints))), h0 x)) : @strong_rank_condition.{0} (non_unital_non_assoc_semiring.{0} (mul_one_class.{0} reducibility_hints)) (@classical.some.{1} (ring.{0} (non_unital_non_assoc_semiring.{0} (mul_one_class.{0} reducibility_hints))) h0 h1)  := sorry --non-trivial
lemma new_lemma_16438 (h0 : functor.add_const (add_group (measure_theory.measure_space num)) empty) : @is_add_cyclic.{0} (measure_theory.measure_space.{0} num) (@functor.add_const.run.{0 0} (add_group.{0} (measure_theory.measure_space.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_16439 (h0 : complete_lattice (normed_comm_ring (comm_group (has_neg_part ennreal)))) : is_compactly_generated (normed_comm_ring (comm_group (has_neg_part ennreal))) := sorry --non-trivial
lemma new_lemma_16440 (h0 : topological_space (has_compl (mul_one_class fun_info))) : path_connected_space (has_compl (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_16441 (h0 : function.extfun (finset Type) (has_mem.mem (measurable_space num))) : @normalizer_condition.{0} (measurable_space.{0} num) (@finset.pi.empty.{1 0} Type group.{0} (measurable_space.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (measurable_space.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_16442 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @path_connected_space.{0} (with_one.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (with_one.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_16443 (h0 : functor.add_const (function.extfun (Type 1) list) Type) : list.nodup (function.extfun_app (functor.add_const.run h0) (has_add Type)) := sorry --non-trivial
lemma new_lemma_16444 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (metric_space.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (metric_space.{0} num))  := sorry --non-trivial
lemma new_lemma_16445 (h0 : complete_lattice (add_comm_monoid (add_comm_monoid Type))) : is_atomistic (add_comm_monoid (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_16446 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (has_pos_part.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_pos_part.{0} name))  := sorry --non-trivial
lemma new_lemma_16447 (h0 : function.extfun Type (functor.add_const (group (semigroup empty)))) : @normalizer_condition.{0} (semigroup.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (semigroup.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (group.{0} (semigroup.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_16448 (h0 : complete_lattice (has_neg (boolean_algebra.core Type))) : is_compactly_generated (has_neg (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_16449 (h0 : functor.comp topological_space ring name) : @loc_path_connected_space.{0} (ring.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} ring.{0} name h0)  := sorry --non-trivial
lemma new_lemma_16450 (h0 : functor.add_const (ring (has_neg Type)) pos) : @is_domain.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_neg.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_16451 (h1 : add_group (distrib linarith.comp_source)) : is_add_cyclic (distrib linarith.comp_source) := sorry --non-trivial
lemma new_lemma_16452 (h0 : function.extfun Type list) : list.ilast (function.extfun_app h0 Prop) := sorry --non-trivial
lemma new_lemma_16453 (h0 : uniform_space (ordered_cancel_add_comm_monoid pos)) : complete_space (ordered_cancel_add_comm_monoid pos) := sorry --non-trivial
lemma new_lemma_16454 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (bin_tree.{0} unsigned) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (bin_tree.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_16455 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (canonically_linear_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_linear_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_16456 (h0 : complete_lattice (has_nndist ennreal)) : is_atomistic (has_nndist ennreal) := sorry --non-trivial
lemma new_lemma_16457 (h0 : functor.add_const (ordered_add_comm_monoid (has_neg name)) (has_add pos)) : @archimedean.{0} (has_neg.{0} name) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_neg.{0} name)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_16458 (h0 : complete_lattice (linear_ordered_add_comm_group (with_bot to_additive.value_type))) : is_compactly_generated (linear_ordered_add_comm_group (with_bot to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_16459 (h0 : functor.add_const (topological_space (measurable_space.dynkin_system num)) empty) : @discrete_topology.{0} (measurable_space.dynkin_system.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (measurable_space.dynkin_system.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_16460 (h0 : topological_space (id (semiring (semiring (semiring (semiring (semiring congr_arg_kind))))))) : totally_separated_space (id (semiring (semiring (semiring (semiring (semiring congr_arg_kind)))))) := sorry --non-trivial
lemma new_lemma_16461 (h0 : semiring (has_inter ennreal)) (h1 : has_inter ennreal) : odd h1 := sorry --non-trivial
lemma new_lemma_16462 (h0 : topological_space (has_add (has_neg_part unsigned))) : totally_disconnected_space (has_add (has_neg_part unsigned)) := sorry --non-trivial
lemma new_lemma_16463 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_to_string.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_to_string.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_16464 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} (has_top.{0} num) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (has_top.{0} num))  := sorry --non-trivial
lemma new_lemma_16465 (h0 : functor.comp topological_space ring unsigned) : @irreducible_space.{0} (ring.{0} unsigned) (@functor.comp.run.{0 0 0} topological_space.{0} ring.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_16466 (h0 : not (complete_lattice (semi_normed_ring (random_gen to_additive.value_type)) -> false)) : @is_compactly_generated.{0} (semi_normed_ring.{0} (random_gen.{0} to_additive.value_type)) (@classical.by_contradiction'.{1} (complete_lattice.{0} (semi_normed_ring.{0} (random_gen.{0} to_additive.value_type))) h0)  := sorry --non-trivial
lemma new_lemma_16467 (h0 : not (topological_space (metric_space num) -> false)) : @preirreducible_space.{0} (metric_space.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (metric_space.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_16468 (h0 : functor.add_const (ring (has_zero pos)) Type) : @is_principal_ideal_ring.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (has_zero.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_16469 (h0 : topological_space (has_nndist empty)) : topological_space.separable_space (has_nndist empty) := sorry --non-trivial
lemma new_lemma_16470 (h0 : topological_space (add_comm_monoid (ordered_comm_monoid real))) : topological_space.separable_space (add_comm_monoid (ordered_comm_monoid real)) := sorry --non-trivial
lemma new_lemma_16471 (h0 : ring (has_nnnorm (mul_one_class (mul_one_class string_imp)))) : is_domain (has_nnnorm (mul_one_class (mul_one_class string_imp))) := sorry --non-trivial
lemma new_lemma_16472 (h0 : function.extfun nat fin) : @is_noetherian_ring.{0} (add_comm_monoid.{0} real) (@matrix.vec_empty.{0} (semiring.{0} (add_comm_monoid.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_16473 (h0 : topological_space (has_add (has_Inf (has_Inf Type)))) : totally_disconnected_space (has_add (has_Inf (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_16474 (h0 : uniform_space (uniform_space (has_lt reducibility_hints))) : complete_space (uniform_space (has_lt reducibility_hints)) := sorry --non-trivial
lemma new_lemma_16475 (h0 : ring (has_nnnorm (mul_one_class (mul_one_class string_imp)))) : strong_rank_condition (has_nnnorm (mul_one_class (mul_one_class string_imp))) := sorry --non-trivial
lemma new_lemma_16476 (h1 : function.extfun Type topological_space) : @totally_separated_space.{0} (with_bot.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (with_bot.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_16477 (h1 : ring (has_lt linarith.comp_source)) : rank_condition (has_lt linarith.comp_source) := sorry --non-trivial
lemma new_lemma_16478 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (random_gen.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (random_gen.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_16479 (h0 : topological_space (boolean_algebra.core (has_add pos))) : t1_space (boolean_algebra.core (has_add pos)) := sorry --non-trivial
lemma new_lemma_16480 (h0 : functor.comp group has_nndist ennreal) : @is_cyclic.{0} (has_nndist.{0} ennreal) (@functor.comp.run.{0 0 0} group.{0} has_nndist.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_16481 (h0 : group (monoid (option (option (option ennreal))))) : is_cyclic (monoid (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_16482 (h0 : topological_space (pseudo_metric_space (boolean_algebra.core name))) : totally_separated_space (pseudo_metric_space (boolean_algebra.core name)) := sorry --non-trivial
lemma new_lemma_16483 (h0 : functor.add_const (group (normed_comm_ring pos)) pos) : @is_cyclic.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (normed_comm_ring.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_16484 (h0 : functor.add_const (topological_space (ordered_ring empty)) empty) : @irreducible_space.{0} (ordered_ring.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_16485 (h0 : functor.add_const (monoid (has_add Type)) linarith.comp) : @monoid.fg.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (monoid.{1} (has_add.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_16486 (h0 : filter (has_compl (random_gen linarith.comp_source))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_16487 (h0 : fin has_zero.zero) : @path_connected_space.{0} (canonically_ordered_monoid.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (canonically_ordered_monoid.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_16488 (h0 : ring (monoid unsigned)) : is_domain (monoid unsigned) := sorry --non-trivial
lemma new_lemma_16489 (h0 : not (complete_lattice (random_gen (metric_space char)) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (random_gen.{0} (metric_space.{0} char)) (@classical.by_contradiction'.{1} (complete_lattice.{0} (random_gen.{0} (metric_space.{0} char))) h0)  := sorry --non-trivial
lemma new_lemma_16490 (h0 : list (generalized_boolean_algebra (boolean_algebra.core pos))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_16491 (h0 : not (topological_space (partial_order empty) -> false)) : @totally_disconnected_space.{0} (partial_order.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (partial_order.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_16492 (h0 : not (pseudo_metric_space (has_add linarith.comp_source) -> false)) : @proper_space.{0} (has_add.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (pseudo_metric_space.{0} (has_add.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_16493 (h0 : not (function.extfun (finset (Type -> Type)) (has_mem.mem topological_space) -> false)) : @totally_disconnected_space.{0} (normed_group.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) (@classical.by_contradiction'.{0} (function.extfun.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0})) h0) (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (normed_group.{0} num))  := sorry --non-trivial
lemma new_lemma_16494 (h1 : topological_space (has_top fun_info)) : totally_disconnected_space (has_top fun_info) := sorry --non-trivial
lemma new_lemma_16495 (h0 : list (semigroup unsigned)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_16496 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_semilattice_Sup.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_16497 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (with_bot.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_bot.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_16498 (h0 : functor.add_const (ring (linear_ordered_comm_group empty)) num) : @is_domain.{0} (linear_ordered_comm_group.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (linear_ordered_comm_group.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_16499 (h0 : topological_space (normed_field linarith.comp_source)) : path_connected_space (normed_field linarith.comp_source) := sorry --non-trivial
lemma new_lemma_16500 (h0 : topological_space (has_Sup (semiring (semiring (semiring congr_arg_kind))))) : irreducible_space (has_Sup (semiring (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_16501 (h0 : function.extfun (Type 1) (functor.comp ring comm_group)) : @rank_condition.{1} (comm_group.{1} Type) (@functor.comp.run.{1 1 1} ring.{1} comm_group.{1} Type (@function.extfun_app.{3 2} (Type 1) (functor.comp.{1 1 1} ring.{1} comm_group.{1}) h0 Type))  := sorry --non-trivial
lemma new_lemma_16502 (h0 : ordered_add_comm_monoid (normed_comm_ring (finset Type))) : archimedean (normed_comm_ring (finset Type)) := sorry --non-trivial
lemma new_lemma_16503 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (is_R_or_C.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (is_R_or_C.{0} empty))  := sorry --non-trivial
lemma new_lemma_16504 (h0 : topological_space (linear_ordered_cancel_comm_monoid unsigned)) : t0_space (linear_ordered_cancel_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_16505 (h0 : ring (random_gen (random_gen (comm_ring to_additive.value_type)))) : is_domain (random_gen (random_gen (comm_ring to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_16506 (h0 : topological_space (ordered_comm_monoid (ring (canonically_ordered_comm_semiring linarith.comp)))) : locally_compact_space (ordered_comm_monoid (ring (canonically_ordered_comm_semiring linarith.comp))) := sorry --non-trivial
lemma new_lemma_16507 (h0 : group (denumerable (random_gen (random_gen (random_gen to_additive.value_type))))) : is_cyclic (denumerable (random_gen (random_gen (random_gen to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_16508 (h0 : group (add_right_cancel_monoid (semiring empty))) : is_cyclic (add_right_cancel_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_16509 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @t1_space.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_16510 (h0 : topological_space (linear_order unsigned)) : t0_space (linear_order unsigned) := sorry --non-trivial
lemma new_lemma_16511 (h0 : not (topological_space (option unsigned) -> false)) : @path_connected_space.{0} (option.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (option.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_16512 (h0 : ring (with_zero (random_gen (random_gen (random_gen (random_gen char)))))) : is_domain (with_zero (random_gen (random_gen (random_gen (random_gen char))))) := sorry --non-trivial
lemma new_lemma_16513 (h0 : functor.add_const (topological_space (has_neg pos)) Type) : @irreducible_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_16514 (h0 : function.extfun (Type 1) topological_space) : @normal_space.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_16515 (h0 : topological_space (semigroup empty)) : irreducible_space (semigroup empty) := sorry --non-trivial
lemma new_lemma_16516 (h1 : group (dlist to_additive.value_type)) : is_cyclic (dlist to_additive.value_type) := sorry --non-trivial
lemma new_lemma_16517 (h1 : ring (distrib (normed_field string_imp))) : rank_condition (distrib (normed_field string_imp)) := sorry --non-trivial
lemma new_lemma_16518 (h0 : functor.add_const (group (boolean_algebra linarith.comp)) (has_neg environment.implicit_infer_kind)) : @is_simple_group.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.{0} linarith.comp)) (has_neg.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_16519 (h0 : group (random_gen (random_gen (has_top fun_info)))) : normalizer_condition (random_gen (random_gen (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_16520 (h0 : group (ordered_comm_ring (has_add (has_add real)))) : is_simple_group (ordered_comm_ring (has_add (has_add real))) := sorry --non-trivial
lemma new_lemma_16521 (h2 : ring (semi_normed_comm_ring (has_ssubset char))) : is_domain (semi_normed_comm_ring (has_ssubset char)) := sorry --non-trivial
lemma new_lemma_16522 (h0 : group (has_ssubset (has_nnnorm linarith.comp_source))) : group.fg (has_ssubset (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_16523 (h0 : topological_space (comm_group (boolean_algebra name))) : discrete_topology (comm_group (boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_16524 (h0 : functor.add_const (group (preorder num)) num) : @is_cyclic.{0} (preorder.{0} num) (@functor.add_const.run.{0 0} (group.{0} (preorder.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_16525 (h0 : topological_space (semigroup (has_neg Type))) : preconnected_space (semigroup (has_neg Type)) := sorry --non-trivial
lemma new_lemma_16526 (h0 : group (has_nnnorm (has_append (has_lt linarith.comp_source)))) : is_cyclic (has_nnnorm (has_append (has_lt linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_16527 (h0 : topological_space (has_emptyc (random_gen (random_gen congr_arg_kind)))) : totally_disconnected_space (has_emptyc (random_gen (random_gen congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_16528 (h0 : functor.add_const (topological_space (has_to_string linarith.comp)) (has_add Type)) : @loc_path_connected_space.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_to_string.{0} linarith.comp)) (has_add.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_16529 (h0 : topological_space (sub_neg_monoid (has_neg real))) : locally_compact_space (sub_neg_monoid (has_neg real)) := sorry --non-trivial
lemma new_lemma_16530 (h0 : group (dlist (random_gen fun_info))) : group.fg (dlist (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_16531 (h0 : add_group (complete_semilattice_Sup (semiring unsigned))) : is_add_cyclic (complete_semilattice_Sup (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_16532 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (has_edist.{0} empty) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_edist.{0} empty))  := sorry --non-trivial
lemma new_lemma_16533 (h0 : ring (cancel_monoid (comm_group Type))) : strong_rank_condition (cancel_monoid (comm_group Type)) := sorry --non-trivial
lemma new_lemma_16534 (h0 : ring (has_zero (finset name))) : is_principal_ideal_ring (has_zero (finset name)) := sorry --non-trivial
lemma new_lemma_16535 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (canonically_ordered_comm_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_16536 (h0 : topological_space (id empty)) : totally_disconnected_space (id empty) := sorry --non-trivial
lemma new_lemma_16537 (h0 : add_group (measurable_space (random_gen (random_gen linarith.comp_source)))) : is_add_cyclic (measurable_space (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_16538 (h0 : topological_space (add_cancel_monoid (has_pos_part linarith.comp))) : discrete_topology (add_cancel_monoid (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_16539 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_16540 (h0 : list (linear_ordered_comm_group congr_arg_kind)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_16541 (h0 : ring (has_inv (random_gen (random_gen (with_bot (has_norm linarith.ineq)))))) : is_domain (has_inv (random_gen (random_gen (with_bot (has_norm linarith.ineq))))) := sorry --non-trivial
lemma new_lemma_16542 (h0 : ring (normed_comm_ring (boolean_algebra.core Type))) : rank_condition (normed_comm_ring (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_16543 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_16544 (h0 : topological_space (has_to_string (has_Inf linarith.comp))) : loc_path_connected_space (has_to_string (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_16545 (h0 : functor.add_const (complete_lattice (is_R_or_C empty)) empty) : @complete_lattice.is_Sup_finite_compact.{0} (is_R_or_C.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (is_R_or_C.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_16546 (h0 : functor.add_const (ordered_add_comm_monoid (finset pos)) (has_add (has_pos_part pos))) : @archimedean.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (finset.{0} pos)) (has_add.{0} (has_pos_part.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_16547 (h0 : functor.add_const (topological_space (add_cancel_monoid Type)) Type) : @t0_space.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (add_cancel_monoid.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_16548 (h0 : topological_space (has_nndist (finset pos))) : locally_compact_space (has_nndist (finset pos)) := sorry --non-trivial
lemma new_lemma_16549 (h0 : functor.add_const (finset (has_pos_part linarith.comp)) linarith.comp) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_16550 (h0 : ulower pnat) (h1 : pnat) : pnat.coprime (ulower.up (id h0)) h1 := sorry --non-trivial
lemma new_lemma_16551 (h0 : functor.add_const (finset (generalized_boolean_algebra pos)) (has_add pos)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_16552 (h0 : group (has_union (semiring empty))) : group.fg (has_union (semiring empty)) := sorry --non-trivial
lemma new_lemma_16553 (h0 : group (metric_space (semiring (semiring unsigned)))) : normalizer_condition (metric_space (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_16554 (h0 : functor.add_const (semiring (ring name)) pos) : @is_noetherian_ring.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (semiring.{0} (ring.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_16555 (h0 : functor.add_const (add_monoid (partial_order unsigned)) congr_arg_kind) : @add_monoid.fg.{0} (partial_order.{0} unsigned) (@functor.add_const.run.{0 0} (add_monoid.{0} (partial_order.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_16556 (h1 : topological_space (fintype (has_nnnorm (has_nnnorm fun_info)))) : t0_space (fintype (has_nnnorm (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_16557 (h0 : ring (has_norm (has_norm linarith.comp_source))) : rank_condition (has_norm (has_norm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_16558 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (pseudo_metric_space.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (pseudo_metric_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_16559 (h0 : functor.add_const (uniform_space (ring linarith.comp)) (ring pos)) : @complete_space.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (ring.{0} linarith.comp)) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_16560 (h0 : complete_lattice (complete_semilattice_Sup (with_bot (with_bot linarith.comp_source)))) : is_compactly_generated (complete_semilattice_Sup (with_bot (with_bot linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_16561 (h0 : not (filter (bin_tree empty) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_16562 (h1 : ring (has_add (comm_ring (has_append char)))) : strong_rank_condition (has_add (comm_ring (has_append char))) := sorry --non-trivial
lemma new_lemma_16563 (h0 : ring (ordered_cancel_add_comm_monoid (option (option empty)))) : rank_condition (ordered_cancel_add_comm_monoid (option (option empty))) := sorry --non-trivial
lemma new_lemma_16564 (h0 : not (topological_space (has_one linarith.comp) -> false)) : @discrete_topology.{0} (has_one.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (has_one.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_16565 (h0 : functor.add_const (add_monoid (has_zero Type)) name) : @add_monoid.fg.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (add_monoid.{1} (has_zero.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_16566 (h0 : complete_lattice (with_one num)) : is_atomistic (with_one num) := sorry --non-trivial
lemma new_lemma_16567 (h0 : ring (normed_group (has_nnnorm (random_gen to_additive.value_type)))) : rank_condition (normed_group (has_nnnorm (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_16568 (h0 : ereal -> Prop) (h1 : ereal) : set_of h0 h1 := sorry --non-trivial
lemma new_lemma_16569 (h0 : ordered_comm_monoid (ordered_comm_monoid (boolean_algebra.core pos))) : has_exists_mul_of_le (ordered_comm_monoid (boolean_algebra.core pos)) := sorry --non-trivial
lemma new_lemma_16570 (h0 : functor.add_const (function.extfun Type finset) name) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_16571 (h0 : not (group empty -> false)) : @normalizer_condition.{0} empty (@classical.by_contradiction'.{1} (group.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_16572 (h0 : function.extfun Type complete_lattice) : is_atomistic ennreal := sorry --non-trivial
lemma new_lemma_16573 (h0 : topological_space (has_neg_part ennreal)) : sequential_space (has_neg_part ennreal) := sorry --non-trivial
lemma new_lemma_16574 (h0 : functor.add_const (uniform_space (has_neg_part environment.implicit_infer_kind)) name) : @complete_space.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_neg_part.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_16575 (h0 : group (generalized_boolean_algebra (has_add linarith.comp))) : is_cyclic (generalized_boolean_algebra (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_16576 (h0 : topological_space (add_comm_semigroup string.iterator_imp)) : t0_space (add_comm_semigroup string.iterator_imp) := sorry --non-trivial
lemma new_lemma_16577 (h0 : topological_space (has_to_string empty)) : irreducible_space (has_to_string empty) := sorry --non-trivial
lemma new_lemma_16578 (h0 : functor.add_const (complete_lattice (complete_distrib_lattice num)) unsigned) : @is_compactly_generated.{0} (complete_distrib_lattice.{0} num) (@functor.add_const.run.{0 0} (complete_lattice.{0} (complete_distrib_lattice.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_16579 (h0 : functor.add_const (topological_space (boolean_algebra nnreal)) linarith.comp) : @t1_space.{0} (boolean_algebra.{0} nnreal) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} nnreal)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_16580 (h0 : list (has_pos_part (has_Inf linarith.comp))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_16581 (h0 h1 : list (has_inv congr_arg_kind)) : list.subperm h0 h1 := sorry --non-trivial
lemma new_lemma_16582 (h0 : functor.add_const (complete_lattice (linear_order unsigned)) empty) : @complete_lattice.is_Sup_finite_compact.{0} (linear_order.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (linear_order.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_16583 (h0 : complete_lattice (topological_space (random_gen char))) : is_compactly_generated (topological_space (random_gen char)) := sorry --non-trivial
lemma new_lemma_16584 (h0 : topological_space (normed_group (has_norm fun_info))) : totally_separated_space (normed_group (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_16585 (h0 : functor.add_const (topological_space (ordered_comm_monoid pos)) (ring pos)) : @totally_disconnected_space.{0} (ordered_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_monoid.{0} pos)) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_16586 (h0 : filter (distrib (add_monoid to_additive.value_type))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_16587 (h0 : complete_lattice (linear_ordered_semiring (has_norm linarith.comp))) : complete_lattice.is_Sup_finite_compact (linear_ordered_semiring (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_16588 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_16589 (h0 : functor.add_const (group pos) Type) : @normalizer_condition.{0} pos (@functor.add_const.run.{0 1} (group.{0} pos) Type h0)  := sorry --non-trivial
lemma new_lemma_16590 (h0 : monoid (has_neg (comm_group (has_add unsigned)))) : monoid.fg (has_neg (comm_group (has_add unsigned))) := sorry --non-trivial
lemma new_lemma_16591 (h0 : function.extfun Type topological_space) : @t1_space.{0} (option.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (option.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_16592 (h0 : functor.add_const (group (semigroup environment.implicit_infer_kind)) name) : @group.fg.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (semigroup.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_16593 (h0 : topological_space (with_one (has_norm (random_gen empty)))) : topological_space.separable_space (with_one (has_norm (random_gen empty))) := sorry --non-trivial
lemma new_lemma_16594 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_16595 (h0 : topological_space (linear_ordered_comm_group unsigned)) : discrete_topology (linear_ordered_comm_group unsigned) := sorry --non-trivial
lemma new_lemma_16596 (h0 : uniform_space (add_comm_monoid (finset name))) : separated_space (add_comm_monoid (finset name)) := sorry --non-trivial
lemma new_lemma_16597 (h0 : topological_space (complete_semilattice_Sup (random_gen (with_bot linarith.ineq)))) : t0_space (complete_semilattice_Sup (random_gen (with_bot linarith.ineq))) := sorry --non-trivial
lemma new_lemma_16598 (h0 : functor.add_const (topological_space (pseudo_metric_space unsigned)) Type) : @preconnected_space.{0} (pseudo_metric_space.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (pseudo_metric_space.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_16599 (h0 : functor.add_const (topological_space (finset unsigned)) unsigned) : @loc_path_connected_space.{0} (finset.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_16600 (h0 : topological_space (ring (has_neg_part (comm_group name)))) : normal_space (ring (has_neg_part (comm_group name))) := sorry --non-trivial
lemma new_lemma_16601 (h0 : set (string.iterator_imp -> mul_one_class string.iterator_imp)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_16602 (h0 : topological_space (has_one (semiring (semiring (semiring empty))))) : path_connected_space (has_one (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_16603 (h0 : topological_space (mul_one_class string.iterator_imp)) (h1 : preorder (mul_one_class string.iterator_imp)) : order_closed_topology (mul_one_class string.iterator_imp) := sorry --non-trivial
lemma new_lemma_16604 (h0 : functor.add_const (add_monoid (mul_zero_class num)) (semiring unsigned)) : @add_monoid.fg.{0} (mul_zero_class.{0} num) (@functor.add_const.run.{0 0} (add_monoid.{0} (mul_zero_class.{0} num)) (semiring.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_16605 (h0 : monoid (has_neg (option (option (option (option num)))))) : monoid.fg (has_neg (option (option (option (option num))))) := sorry --non-trivial
lemma new_lemma_16606 (h0 : topological_space (has_norm (semiring linarith.comp))) : discrete_topology (has_norm (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_16607 (h0 : functor.add_const (topological_space (has_nndist linarith.comp)) pos) : @locally_compact_space.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_16608 (h0 : topological_space (canonically_linear_ordered_monoid (add_comm_monoid ennreal))) : locally_compact_space (canonically_linear_ordered_monoid (add_comm_monoid ennreal)) := sorry --non-trivial
lemma new_lemma_16609 (h0 : topological_space (free_add_monoid (semiring congr_arg_kind))) : totally_separated_space (free_add_monoid (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_16610 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (has_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_16611 (h0 : functor.add_const (ring (has_to_string pos)) linarith.comp) : @is_domain.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_to_string.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_16612 (h0 : topological_space (random_gen (has_top (has_top fun_info)))) : irreducible_space (random_gen (has_top (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_16613 (h1 : ring (semi_normed_comm_ring reducibility_hints)) : rank_condition (semi_normed_comm_ring reducibility_hints) := sorry --non-trivial
lemma new_lemma_16614 (h0 : functor.comp group has_neg name) : @is_simple_group.{0} (has_neg.{0} name) (@functor.comp.run.{0 0 0} group.{0} has_neg.{0} name h0)  := sorry --non-trivial
lemma new_lemma_16615 (h0 : ring ereal) : is_field ereal := sorry --non-trivial
lemma new_lemma_16616 (h0 : not (topological_space (semiring to_additive.value_type) -> false)) : @locally_compact_space.{0} (semiring.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (semiring.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_16617 (h0 : functor.add_const (add_group (add_cancel_monoid pos)) name) : @is_add_cyclic.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (add_cancel_monoid.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_16618 (h0 : topological_space (add_group congr_arg_kind)) : totally_separated_space (add_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_16619 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (group_with_zero.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (group_with_zero.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_16620 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (semi_normed_comm_ring.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semi_normed_comm_ring.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_16621 (h0 : functor.add_const (function.extfun (Type 1) ring) linarith.comp) : @strong_rank_condition.{1} (has_zero.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ring.{1}) linarith.comp h0) (has_zero.{1} Type))  := sorry --non-trivial
lemma new_lemma_16622 (h0 : cancel_comm_monoid_with_zero (linear_order empty)) : unique_factorization_monoid (linear_order empty) := sorry --non-trivial
lemma new_lemma_16623 (h0 : functor.add_const (topological_space (semigroup linarith.comp)) (has_pos_part linarith.comp)) : @regular_space.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} linarith.comp)) (has_pos_part.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_16624 (h0 : topological_space (has_nnnorm (mul_one_class char))) : totally_disconnected_space (has_nnnorm (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_16625 (h0 : topological_space (finset (finset linarith.comp))) : t1_space (finset (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_16626 (h0 : list (has_neg unsigned)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_16627 (h0 : group (has_lt reducibility_hints)) : is_cyclic (has_lt reducibility_hints) := sorry --non-trivial
lemma new_lemma_16628 (h0 : topological_space (boolean_algebra.core (add_comm_monoid Type))) : t1_space (boolean_algebra.core (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_16629 (h0 : topological_space (add_cancel_monoid pos)) : t0_space (add_cancel_monoid pos) := sorry --non-trivial
lemma new_lemma_16630 (h0 : functor.add_const (topological_space (normed_lattice_add_comm_group name)) linarith.comp) : @loc_path_connected_space.{0} (normed_lattice_add_comm_group.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_lattice_add_comm_group.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_16631 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (complete_distrib_lattice.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (complete_distrib_lattice.{0} empty))  := sorry --non-trivial
lemma new_lemma_16632 (h0 : finset (semigroup (has_neg pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_16633 (h0 : functor.add_const (topological_space (finset pos)) linarith.comp) : @regular_space.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_16634 (h0 : functor.add_const (group (boolean_algebra pos)) pos) : @is_simple_group.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_16635 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (has_nndist environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_16636 (h0 : functor.add_const (topological_space (add_cancel_monoid name)) Type) : @locally_compact_space.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (add_cancel_monoid.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_16637 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @preconnected_space.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_16638 (h0 : ring (has_dist (has_top fun_info))) : strong_rank_condition (has_dist (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_16639 (h0 : function.extfun Type group) : @normalizer_condition.{0} (normed_group.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (normed_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_16640 (h0 : group (boolean_algebra (has_add real))) : is_simple_group (boolean_algebra (has_add real)) := sorry --non-trivial
lemma new_lemma_16641 (h1 : monoid (pseudo_metric_space (random_gen linarith.ineq))) : monoid.fg (pseudo_metric_space (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_16642 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_16643 (h0 : ring (mul_one_class char)) : is_domain (mul_one_class char) := sorry --non-trivial
lemma new_lemma_16644 (h0 : topological_space (has_nndist (has_pos_part (normed_comm_ring linarith.comp)))) : totally_separated_space (has_nndist (has_pos_part (normed_comm_ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_16645 (h0 : functor.comp topological_space comm_group Type) : @discrete_topology.{1} (comm_group.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} comm_group.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_16646 (h0 : functor.add_const (ring (has_Inf linarith.comp)) Type) : @is_domain.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 1} (ring.{0} (has_Inf.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_16647 (h0 : monoid (has_to_string (has_add linarith.comp))) : monoid.fg (has_to_string (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_16648 (h0 : ordered_comm_monoid (has_nndist (finset (has_pos_part pos)))) : has_exists_mul_of_le (has_nndist (finset (has_pos_part pos))) := sorry --non-trivial
lemma new_lemma_16649 (h0 : functor.add_const (topological_space (ordered_comm_ring Type)) name) : @discrete_topology.{1} (ordered_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ordered_comm_ring.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_16650 (h3 : ring (distrib (comm_ring (comm_ring reducibility_hints)))) : is_domain (distrib (comm_ring (comm_ring reducibility_hints))) := sorry --non-trivial
lemma new_lemma_16651 (h2 : group empty) : is_cyclic empty := sorry --non-trivial
lemma new_lemma_16652 (h0 : functor.add_const (topological_space (bin_tree unsigned)) empty) : @normal_space.{0} (bin_tree.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (bin_tree.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_16653 (h0 : complete_lattice (normed_group (semiring (has_norm empty)))) : is_compactly_generated (normed_group (semiring (has_norm empty))) := sorry --non-trivial
lemma new_lemma_16654 (h0 : functor.add_const (ring (ring pos)) pos) : @is_domain.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (ring.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_16655 (h0 : function.extfun Type group) : @is_simple_group.{0} (finset.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (finset.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_16656 (h0 : ordered_add_comm_monoid (complete_distrib_lattice (option (option (option ennreal))))) : archimedean (complete_distrib_lattice (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_16657 (h0 : finset (complete_lattice unsigned)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_16658 (h0 : functor.add_const (list (has_edist unsigned)) empty) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_16659 (h0 : ring (ordered_comm_group (option (option unsigned)))) : is_domain (ordered_comm_group (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_16660 (h0 : topological_space (has_nndist (has_add (has_to_string name)))) : totally_disconnected_space (has_nndist (has_add (has_to_string name))) := sorry --non-trivial
lemma new_lemma_16661 (h0 : add_group (has_ssubset (has_nnnorm (has_nnnorm char)))) : is_add_cyclic (has_ssubset (has_nnnorm (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_16662 (h0 : ordered_add_comm_monoid (sub_neg_monoid (sub_neg_monoid name))) : archimedean (sub_neg_monoid (sub_neg_monoid name)) := sorry --non-trivial
lemma new_lemma_16663 (h0 : not (topological_space (semi_normed_ring char) -> false)) (h1 : preorder (semi_normed_ring char)) : @order_topology.{0} (semi_normed_ring.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (semi_normed_ring.{0} char)) h0) h1  := sorry --non-trivial
lemma new_lemma_16664 (h0 : functor.add_const (function.extfun nat fin) linarith.comp) : @t1_space.{0} (has_bot.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (has_bot.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin (@functor.add_const.run.{0 0} (function.extfun.{1 1} nat fin) linarith.comp h0) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_16665 (h0 : list (generalized_boolean_algebra (ring (ring (ring pos))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_16666 (h0 : has_neg_part name -> has_neg_part name -> Prop) : is_antisymm (has_neg_part name) h0 := sorry --non-trivial
lemma new_lemma_16667 (h0 : functor.add_const (topological_space (has_neg pos)) environment.implicit_infer_kind) : @locally_compact_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_16668 (h0 : uniform_space (has_neg pos)) : complete_space (has_neg pos) := sorry --non-trivial
lemma new_lemma_16669 (h0 : add_group (monoid_with_zero (option pos))) : is_add_cyclic (monoid_with_zero (option pos)) := sorry --non-trivial
lemma new_lemma_16670 (h0 : functor.add_const (ring (has_neg Type)) (has_neg (normed_comm_ring pos))) : @is_domain.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_neg.{1} Type)) (has_neg.{0} (normed_comm_ring.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_16671 (h2 : preorder linarith.ineq) (h3 : set linarith.ineq) : set.is_pwo h3 := sorry --non-trivial
lemma new_lemma_16672 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} (semiring.{0} num) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_16673 (h0 : functor.add_const (group (has_to_string environment.implicit_infer_kind)) linarith.comp) : @is_simple_group.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (has_to_string.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_16674 (h2 : group fun_info) : is_cyclic fun_info := sorry --non-trivial
lemma new_lemma_16675 (h0 : uniform_space (has_norm (has_norm linarith.ineq))) : complete_space (has_norm (has_norm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_16676 (h0 : uniform_space (has_edist pos)) : complete_space (has_edist pos) := sorry --non-trivial
lemma new_lemma_16677 (h0 : ring (has_to_string (has_add pos))) : rank_condition (has_to_string (has_add pos)) := sorry --non-trivial
lemma new_lemma_16678 (h0 : topological_space (measurable_space.dynkin_system num)) : totally_disconnected_space (measurable_space.dynkin_system num) := sorry --non-trivial
lemma new_lemma_16679 (h0 : topological_space (normed_group unsigned)) : irreducible_space (normed_group unsigned) := sorry --non-trivial
lemma new_lemma_16680 (h0 : functor.add_const (function.extfun Type ring) linarith.comp) : @strong_rank_condition.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) linarith.comp h0) (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_16681 (h0 : functor.add_const (topological_space (add_comm_monoid name)) name) : @locally_compact_space.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_16682 (h0 : add_group (has_lt (has_nnnorm string.iterator_imp))) : is_add_cyclic (has_lt (has_nnnorm string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_16683 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_16684 (h0 : functor.add_const (function.extfun (Type 1) filter) environment.implicit_infer_kind) : countable_Inter_filter (function.extfun_app (functor.add_const.run h0) (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_16685 (h0 : semiring (comm_group (has_neg_part Type))) : is_noetherian_ring (comm_group (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_16686 (h0 : cancel_comm_monoid_with_zero (mul_zero_class num)) : unique_factorization_monoid (mul_zero_class num) := sorry --non-trivial
lemma new_lemma_16687 (h0 : functor.add_const (topological_space (has_nndist unsigned)) Type) : @t0_space.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (has_nndist.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_16688 (h0 : functor.add_const (complete_lattice (add_cancel_monoid linarith.comp)) (has_neg Type)) : @is_atomistic.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (complete_lattice.{0} (add_cancel_monoid.{0} linarith.comp)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_16689 (h0 : topological_space (complete_distrib_lattice unsigned)) : discrete_topology (complete_distrib_lattice unsigned) := sorry --non-trivial
lemma new_lemma_16690 (h0 : uniform_space (mul_zero_class empty)) : separated_space (mul_zero_class empty) := sorry --non-trivial
lemma new_lemma_16691 (h0 : function.extfun Type ring) : @is_domain.{0} (finset.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (finset.{0} empty))  := sorry --non-trivial
lemma new_lemma_16692 (h2 : uniform_space string.iterator_imp) : complete_space string.iterator_imp := sorry --non-trivial
lemma new_lemma_16693 (h3 : has_le (has_div (monoid_with_zero (mul_one_class (mul_one_class linarith.comp_source))))) (h4 : bounded_order (has_div (monoid_with_zero (mul_one_class (mul_one_class linarith.comp_source))))) : is_simple_order (has_div (monoid_with_zero (mul_one_class (mul_one_class linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_16694 (h0 : topological_space (measurable_space (has_norm empty))) : totally_separated_space (measurable_space (has_norm empty)) := sorry --non-trivial
lemma new_lemma_16695 (h0 : functor.add_const (ordered_add_comm_monoid (simple_graph linarith.comp)) linarith.comp) : @archimedean.{0} (simple_graph.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (simple_graph.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_16696 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_16697 (h1 : uniform_space (has_top (has_norm string_imp))) : complete_space (has_top (has_norm string_imp)) := sorry --non-trivial
lemma new_lemma_16698 (h0 : topological_space (add_comm_semigroup linarith.ineq)) (h2 : preorder (add_comm_semigroup linarith.ineq)) : order_closed_topology (add_comm_semigroup linarith.ineq) := sorry --non-trivial
lemma new_lemma_16699 (h0 : topological_space (semigroup (has_add (has_add pos)))) : t1_space (semigroup (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_16700 (h0 : topological_space (id unsigned)) : totally_disconnected_space (id unsigned) := sorry --non-trivial
lemma new_lemma_16701 (h0 : functor.add_const (ring (add_cancel_monoid empty)) num) : @is_principal_ideal_ring.{0} (add_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (add_cancel_monoid.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_16702 (h0 : not (function.extfun Type group -> false)) : @normalizer_condition.{0} (has_one.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (has_one.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_16703 (h0 : topological_space (has_bot (sub_neg_monoid (sub_neg_monoid name)))) : path_connected_space (has_bot (sub_neg_monoid (sub_neg_monoid name))) := sorry --non-trivial
lemma new_lemma_16704 (h0 : add_group (non_unital_non_assoc_semiring (mul_one_class (mul_one_class to_additive.value_type)))) : is_add_cyclic (non_unital_non_assoc_semiring (mul_one_class (mul_one_class to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_16705 (h0 : functor.add_const (group (semigroup linarith.comp)) (has_neg environment.implicit_infer_kind)) : @is_simple_group.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (semigroup.{0} linarith.comp)) (has_neg.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_16706 (h0 : complete_lattice (semi_normed_comm_ring fun_info)) : is_compactly_generated (semi_normed_comm_ring fun_info) := sorry --non-trivial
lemma new_lemma_16707 (h0 : group (semiring fun_info)) : group.fg (semiring fun_info) := sorry --non-trivial
lemma new_lemma_16708 (h1 : ring (with_one (random_gen char))) : strong_rank_condition (with_one (random_gen char)) := sorry --non-trivial
lemma new_lemma_16709 (h0 : functor.add_const (ordered_comm_monoid (ring Type)) (has_pos_part linarith.comp)) : @has_exists_mul_of_le.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (ordered_comm_monoid.{1} (ring.{1} Type)) (has_pos_part.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_16710 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (canonically_ordered_comm_semiring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_16711 (h0 : functor.add_const (topological_space (boolean_algebra.core name)) pos) : @sequential_space.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_16712 (h0 : topological_space (id num)) : t0_space (id num) := sorry --non-trivial
lemma new_lemma_16713 (h0 : functor.add_const (topological_space (has_add Type)) (has_zero name)) : @locally_compact_space.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_add.{1} Type)) (has_zero.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_16714 (h0 : topological_space (measure_theory.measure_space num)) : totally_disconnected_space (measure_theory.measure_space num) := sorry --non-trivial
lemma new_lemma_16715 (h0 : topological_space (has_lt string.iterator_imp)) : t0_space (has_lt string.iterator_imp) := sorry --non-trivial
lemma new_lemma_16716 (h0 : group (left_cancel_monoid num)) : is_cyclic (left_cancel_monoid num) := sorry --non-trivial
lemma new_lemma_16717 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_dist.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_dist.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_16718 (h0 : functor.add_const (add_group (semigroup linarith.comp)) unsigned) : @is_add_cyclic.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_group.{0} (semigroup.{0} linarith.comp)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_16719 (h0 : measurable_space num) (h1 : has_add num) (h2 : measure_theory.measure num) : measure_theory.measure.is_add_left_invariant h2 := sorry --non-trivial
lemma new_lemma_16720 (h0 : uniform_space (measurable_space (random_gen (random_gen (has_norm linarith.ineq))))) : complete_space (measurable_space (random_gen (random_gen (has_norm linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_16721 (h0 : complete_lattice (comm_ring (has_nnnorm linarith.comp_source))) : complete_lattice.is_Sup_finite_compact (comm_ring (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_16722 (h0 : topological_space (has_le environment.projection_info)) (h1 : preorder (has_le environment.projection_info)) : order_closed_topology (has_le environment.projection_info) := sorry --non-trivial
lemma new_lemma_16723 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (has_neg_part.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_neg_part.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_16724 (h0 : topological_space (add_comm_monoid (finset environment.implicit_infer_kind))) : path_connected_space (add_comm_monoid (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_16725 (h0 : ring (with_one (has_norm unsigned))) : strong_rank_condition (with_one (has_norm unsigned)) := sorry --non-trivial
lemma new_lemma_16726 (h0 : ereal -> ereal -> Prop) : is_per ereal h0 := sorry --non-trivial
lemma new_lemma_16727 (h0 : add_monoid (has_norm congr_arg_kind)) : add_monoid.fg (has_norm congr_arg_kind) := sorry --non-trivial
lemma new_lemma_16728 (h0 : filter (ordered_cancel_add_comm_monoid ennreal)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_16729 (h0 : functor.add_const (monoid (finset environment.implicit_infer_kind)) linarith.comp) : @monoid.fg.{0} (finset.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (monoid.{0} (finset.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_16730 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (canonically_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_16731 (h0 : functor.add_const (group (ordered_comm_ring linarith.comp)) Type) : @normalizer_condition.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (group.{0} (ordered_comm_ring.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_16732 (h0 : ordered_add_comm_monoid (comm_group (finset name))) : archimedean (comm_group (finset name)) := sorry --non-trivial
lemma new_lemma_16733 (h0 : ring (semiring (has_norm (has_norm linarith.comp_source)))) : is_domain (semiring (has_norm (has_norm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_16734 (h0 : functor.add_const (topological_space (add_group num)) congr_arg_kind) : @discrete_topology.{0} (add_group.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (add_group.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_16735 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_16736 (h0 : finset (plift (semiring num))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_16737 (h0 : function.extfun Type (functor.add_const (topological_space (left_cancel_monoid unsigned)))) : @normal_space.{0} (left_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} unsigned)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (left_cancel_monoid.{0} unsigned))) h0 empty))  := sorry --non-trivial
lemma new_lemma_16738 (h2 : ring environment.projection_info) : strong_rank_condition environment.projection_info := sorry --non-trivial
lemma new_lemma_16739 (h1 : group (semi_normed_ring (topological_space char))) : is_cyclic (semi_normed_ring (topological_space char)) := sorry --non-trivial
lemma new_lemma_16740 (h0 : group (cancel_monoid (option (option unsigned)))) : is_cyclic (cancel_monoid (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_16741 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (denumerable.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (denumerable.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_16742 (h0 : uniform_space (semigroup (ring linarith.comp))) : separated_space (semigroup (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_16743 (h0 : not (function.extfun Type filter -> false)) : filter.ne_bot (function.extfun_app (classical.by_contradiction' h0) (mul_zero_class unsigned)) := sorry --non-trivial
lemma new_lemma_16744 (h0 : fin has_zero.zero) : @totally_disconnected_space.{1} (generalized_boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (generalized_boolean_algebra.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_16745 (h0 : topological_space (measurable_space linarith.ineq)) : t0_space (measurable_space linarith.ineq) := sorry --non-trivial
lemma new_lemma_16746 (h0 : ordered_comm_monoid (simple_graph (has_add linarith.comp))) : has_exists_mul_of_le (simple_graph (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_16747 (h0 : ring (has_norm (measurable_space congr_arg_kind))) : is_domain (has_norm (measurable_space congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_16748 (h0 h1 : multiset (has_compl linarith.ineq)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_16749 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (ordered_cancel_add_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_cancel_add_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_16750 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (denumerable.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (denumerable.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_16751 (h0 : functor.add_const (topological_space (semigroup linarith.comp)) (ring (has_neg (has_neg (has_neg pos))))) : @totally_separated_space.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} linarith.comp)) (ring.{0} (has_neg.{0} (has_neg.{0} (has_neg.{0} pos)))) h0)  := sorry --non-trivial
lemma new_lemma_16752 (h0 : topological_space (linear_ordered_semiring (has_top (has_top fun_info)))) : irreducible_space (linear_ordered_semiring (has_top (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_16753 (h0 : ring (has_inv to_additive.value_type)) : rank_condition (has_inv to_additive.value_type) := sorry --non-trivial
lemma new_lemma_16754 (h0 : topological_space (left_cancel_monoid congr_arg_kind)) : loc_path_connected_space (left_cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_16755 (h0 : ring (add_comm_semigroup (has_Sup environment.projection_info))) : is_domain (add_comm_semigroup (has_Sup environment.projection_info)) := sorry --non-trivial
lemma new_lemma_16756 (h0 : uniform_space (has_ssubset (has_nnnorm to_additive.value_type))) : complete_space (has_ssubset (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_16757 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (normed_comm_ring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_16758 (h0 : ring (has_to_string (option ennreal))) : is_principal_ideal_ring (has_to_string (option ennreal)) := sorry --non-trivial
lemma new_lemma_16759 (h0 : add_monoid (complete_linear_order (semiring (semiring (semiring (semiring (semiring num))))))) : add_monoid.fg (complete_linear_order (semiring (semiring (semiring (semiring (semiring num)))))) := sorry --non-trivial
lemma new_lemma_16760 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (complete_distrib_lattice.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (complete_distrib_lattice.{0} pos))  := sorry --non-trivial
lemma new_lemma_16761 (h0 : functor.add_const (group (canonically_linear_ordered_monoid pos)) unsigned) : @is_simple_group.{0} (canonically_linear_ordered_monoid.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (canonically_linear_ordered_monoid.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_16762 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (group_with_zero.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (group_with_zero.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_16763 (h0 : functor.add_const (function.extfun Type finset) environment.implicit_infer_kind) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_16764 (h0 : ring (has_inv (random_gen (random_gen fun_info)))) : rank_condition (has_inv (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_16765 (h1 : add_group (semi_normed_comm_ring (comm_ring reducibility_hints))) : is_add_cyclic (semi_normed_comm_ring (comm_ring reducibility_hints)) := sorry --non-trivial
lemma new_lemma_16766 (h0 : topological_space (has_neg ennreal)) : loc_path_connected_space (has_neg ennreal) := sorry --non-trivial
lemma new_lemma_16767 (h0 : topological_space (semigroup ennreal)) : irreducible_space (semigroup ennreal) := sorry --non-trivial
lemma new_lemma_16768 (h0 : function.extfun (finset Type) (has_mem.mem (random_gen unsigned))) : @monoid.fg.{0} (random_gen.{0} unsigned) (@finset.pi.empty.{1 0} Type monoid.{0} (random_gen.{0} unsigned) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} unsigned)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_16769 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (add_group_with_zero_nhd.{0} unsigned) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (add_group_with_zero_nhd.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_16770 (h0 : complete_lattice (ordered_ring (semiring (semiring empty)))) : is_compactly_generated (ordered_ring (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_16771 (h0 : group (sub_neg_monoid (sub_neg_monoid real))) : is_simple_group (sub_neg_monoid (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_16772 (h0 : function.extfun Type (functor.comp topological_space has_to_string)) : @sequential_space.{0} (has_to_string.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} has_to_string.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} has_to_string.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_16773 (h0 : complete_lattice (topological_space (linear_ordered_add_comm_group to_additive.value_type))) : is_compactly_generated (topological_space (linear_ordered_add_comm_group to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_16774 (h0 : uniform_space (add_group (has_top empty))) : complete_space (add_group (has_top empty)) := sorry --non-trivial
lemma new_lemma_16775 (h1 : topological_space (add_comm_semigroup char)) (h3 : preorder (add_comm_semigroup char)) : order_topology (add_comm_semigroup char) := sorry --non-trivial
lemma new_lemma_16776 (h0 : set (set (semiring (semiring (semiring congr_arg_kind))))) : is_countably_spanning h0 := sorry --non-trivial
lemma new_lemma_16777 (h0 : functor.add_const (list (semigroup name)) environment.implicit_infer_kind) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_16778 (h0 : not (filter (random_gen congr_arg_kind) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_16779 (h0 : uniform_space (option (semiring num))) : complete_space (option (semiring num)) := sorry --non-trivial
lemma new_lemma_16780 (h0 : complete_lattice (boolean_algebra.core congr_arg_kind)) : is_compactly_generated (boolean_algebra.core congr_arg_kind) := sorry --non-trivial
lemma new_lemma_16781 (h0 : not (semiring (add_right_cancel_monoid num) -> false)) : @is_noetherian_ring.{0} (add_right_cancel_monoid.{0} num) (@classical.by_contradiction'.{1} (semiring.{0} (add_right_cancel_monoid.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_16782 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (has_add.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (has_add.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_16783 (h0 : not (group (encodable string_imp) -> false)) : @is_cyclic.{0} (encodable.{0} string_imp) (@classical.by_contradiction'.{1} (group.{0} (encodable.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_16784 (h0 : topological_space (has_nndist (ring Type))) : topological_space.separable_space (has_nndist (ring Type)) := sorry --non-trivial
lemma new_lemma_16785 (h0 : functor.add_const (topological_space (measurable_space.dynkin_system unsigned)) congr_arg_kind) : @totally_separated_space.{0} (measurable_space.dynkin_system.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (measurable_space.dynkin_system.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_16786 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (order_dual.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (order_dual.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_16787 (h0 : functor.add_const (function.extfun Type ring) pos) : @rank_condition.{0} environment.implicit_infer_kind (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) pos h0) environment.implicit_infer_kind)  := sorry --non-trivial
lemma new_lemma_16788 (h0 : ring (has_Inf (has_add (has_add pos)))) : strong_rank_condition (has_Inf (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_16789 (h1 : ring (semi_normed_ring char)) : is_domain (semi_normed_ring char) := sorry --non-trivial
lemma new_lemma_16790 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (random_gen.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (random_gen.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_16791 (h0 : has_mem.mem group has_emptyc.emptyc) : @normalizer_condition.{0} congr_arg_kind (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} h0) congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_16792 (h0 : function.extfun Type group) : @normalizer_condition.{0} (with_one.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (with_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_16793 (h0 : ring (cancel_monoid unsigned)) : is_principal_ideal_ring (cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_16794 (h0 : uniform_space (measurable_space (random_gen linarith.ineq))) : complete_space (measurable_space (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_16795 (h0 : topological_space (has_repr (has_neg (has_neg name)))) : t0_space (has_repr (has_neg (has_neg name))) := sorry --non-trivial
lemma new_lemma_16796 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (has_add.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_add.{0} real))  := sorry --non-trivial
lemma new_lemma_16797 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_16798 (h0 : topological_space (measure_theory.measure_space (add_zero_class congr_arg_kind))) : topological_space.separable_space (measure_theory.measure_space (add_zero_class congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_16799 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (linear_ordered_field.{0} ennreal) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (linear_ordered_field.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_16800 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (has_add.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_add.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_16801 (h0 : topological_space (normed_field (random_gen char))) : t0_space (normed_field (random_gen char)) := sorry --non-trivial
lemma new_lemma_16802 (h0 : list (ring (random_gen linarith.comp_source))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_16803 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (has_bot empty)) := sorry --non-trivial
lemma new_lemma_16804 (h0 : group (has_bot linarith.comp)) : is_cyclic (has_bot linarith.comp) := sorry --non-trivial
lemma new_lemma_16805 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (ordered_cancel_add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (ordered_cancel_add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_16806 (h0 : semiring (ring (ring Type))) : is_noetherian_ring (ring (ring Type)) := sorry --non-trivial
lemma new_lemma_16807 (h0 : group (has_emptyc fun_info)) : is_cyclic (has_emptyc fun_info) := sorry --non-trivial
lemma new_lemma_16808 (h0 : topological_space (ring (has_neg_part pos))) : totally_separated_space (ring (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_16809 (h0 : fin has_zero.zero) : @totally_separated_space.{0} (option.{0} (semiring.{0} (semiring.{0} (semiring.{0} empty)))) (@matrix.vec_empty.{0} (topological_space.{0} (option.{0} (semiring.{0} (semiring.{0} (semiring.{0} empty))))) h0)  := sorry --non-trivial
lemma new_lemma_16810 (h0 : function.extfun (Type 1) (functor.comp group ring)) : @normalizer_condition.{1} (ring.{1} Type) (@functor.comp.run.{1 1 1} group.{1} ring.{1} Type (@function.extfun_app.{3 2} (Type 1) (functor.comp.{1 1 1} group.{1} ring.{1}) h0 Type))  := sorry --non-trivial
lemma new_lemma_16811 (h0 : topological_space (has_Inf (ring (ring name)))) : preirreducible_space (has_Inf (ring (ring name))) := sorry --non-trivial
lemma new_lemma_16812 (h0 : add_group (has_le (mul_one_class (has_nnnorm reducibility_hints)))) : is_add_cyclic (has_le (mul_one_class (has_nnnorm reducibility_hints))) := sorry --non-trivial
lemma new_lemma_16813 (h0 : group (id (random_gen (random_gen (has_norm fun_info))))) : normalizer_condition (id (random_gen (random_gen (has_norm fun_info)))) := sorry --non-trivial
lemma new_lemma_16814 (h0 : function.extfun Type (functor.add_const (topological_space name))) : @topological_space.separable_space.{0} name (@functor.add_const.run.{0 0} (topological_space.{0} name) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} name)) h0 empty))  := sorry --non-trivial
lemma new_lemma_16815 (h0 : topological_space (random_gen (mul_one_class (mul_one_class (has_lt char))))) : totally_disconnected_space (random_gen (mul_one_class (mul_one_class (has_lt char)))) := sorry --non-trivial
lemma new_lemma_16816 (h0 : topological_space (linear_ordered_comm_ring congr_arg_kind)) : t0_space (linear_ordered_comm_ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_16817 (h0 : functor.add_const (filter (has_nndist linarith.comp)) (ring (finset (finset linarith.comp)))) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_16818 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (generalized_boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (generalized_boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_16819 (h0 : group (complete_linear_order (semiring empty))) : is_cyclic (complete_linear_order (semiring empty)) := sorry --non-trivial
lemma new_lemma_16820 (h0 : semiring (complete_semilattice_Sup empty)) : is_noetherian_ring (complete_semilattice_Sup empty) := sorry --non-trivial
lemma new_lemma_16821 (h0 h2 : multiset (add_comm_semigroup char)) : multiset.disjoint h0 h2 := sorry --non-trivial
lemma new_lemma_16822 (h0 : monoid (has_to_string (semigroup Type))) : monoid.fg (has_to_string (semigroup Type)) := sorry --non-trivial
lemma new_lemma_16823 (h0 : topological_space (has_ssubset (has_top to_additive.value_type))) : irreducible_space (has_ssubset (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_16824 (h0 : topological_space (ordered_comm_ring (ordered_comm_monoid (has_pos_part Type)))) : sequential_space (ordered_comm_ring (ordered_comm_monoid (has_pos_part Type))) := sorry --non-trivial
lemma new_lemma_16825 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (ring ennreal)) := sorry --non-trivial
lemma new_lemma_16826 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (add_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (add_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_16827 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_16828 (h0 : topological_space (normed_group (comm_ring (random_gen to_additive.value_type)))) : irreducible_space (normed_group (comm_ring (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_16829 (h0 : filter (power_series string_imp)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_16830 (h0 : functor.add_const (function.extfun Type topological_space) environment.implicit_infer_kind) : @preconnected_space.{0} (semigroup.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) environment.implicit_infer_kind h0) (semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_16831 (h0 : functor.add_const (group (has_zero unsigned)) linarith.comp) : @group.fg.{0} (has_zero.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (has_zero.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_16832 (h0 : ring (complete_distrib_lattice (semigroup environment.implicit_infer_kind))) : is_domain (complete_distrib_lattice (semigroup environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_16833 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (add_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (add_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_16834 (h0 : group (distrib (denumerable linarith.ineq))) : is_cyclic (distrib (denumerable linarith.ineq)) := sorry --non-trivial
lemma new_lemma_16835 (h0 : finset (has_edist num)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_16836 (h0 : ring (random_gen (has_nnnorm char))) : rank_condition (random_gen (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_16837 (h0 : add_monoid (has_dist congr_arg_kind)) : add_monoid.fg (has_dist congr_arg_kind) := sorry --non-trivial
lemma new_lemma_16838 (h0 : topological_space (has_neg_part (comm_group name))) : totally_separated_space (has_neg_part (comm_group name)) := sorry --non-trivial
lemma new_lemma_16839 (h0 : prod (has_add (finset (finset (option (has_add name))))) (has_add (finset (finset (option (has_add name)))))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_16840 (h0 : functor.add_const (function.extfun (Type 1) filter) pos) : filter.ne_bot (function.extfun_app (functor.add_const.run h0) (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_16841 (h0 : simple_graph (has_add (has_add Type))) (h1 h2 : has_add (has_add Type)) : simple_graph.neighbor_set h0 h1 h2 := sorry --non-trivial
lemma new_lemma_16842 (h0 : not (add_monoid (has_union unsigned) -> false)) : @add_monoid.fg.{0} (has_union.{0} unsigned) (@classical.by_contradiction'.{1} (add_monoid.{0} (has_union.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_16843 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (has_add.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type monoid.{0} h0 (has_add.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_16844 (h0 : topological_space (canonically_ordered_add_monoid (option (option empty)))) : t1_space (canonically_ordered_add_monoid (option (option empty))) := sorry --non-trivial
lemma new_lemma_16845 (h1 : set (string.iterator_imp -> mul_one_class enat)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_16846 (h0 : functor.add_const (topological_space (has_add environment.implicit_infer_kind)) pos) : @loc_path_connected_space.{0} (has_add.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_16847 (h0 : complete_lattice (ring unsigned)) : is_compactly_generated (ring unsigned) := sorry --non-trivial
lemma new_lemma_16848 (h0 : uniform_space (cancel_monoid linarith.comp)) : complete_space (cancel_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_16849 (h0 : ring (complete_distrib_lattice (finset linarith.comp))) : is_principal_ideal_ring (complete_distrib_lattice (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_16850 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (linear_ordered_comm_ring.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (linear_ordered_comm_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_16851 (h0 : fin has_zero.zero) : @is_principal_ideal_ring.{0} (has_Inf.{0} real) (@function.extfun_app.{2 1} Type ring.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ring.{0}) h0) (has_Inf.{0} real))  := sorry --non-trivial
lemma new_lemma_16852 (h0 : functor.add_const (finset (has_zero linarith.comp)) name) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_16853 (h0 : list (ring (has_neg Type))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_16854 (h1 : function.extfun Type topological_space) : @preirreducible_space.{0} (has_union.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (has_union.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_16855 (h0 : list (has_to_string (has_neg (has_neg (has_neg (finset linarith.comp)))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_16856 (h0 : cancel_comm_monoid_with_zero (has_Sup (semiring (semiring (semiring (semiring (semiring empty))))))) : unique_factorization_monoid (has_Sup (semiring (semiring (semiring (semiring (semiring empty)))))) := sorry --non-trivial
lemma new_lemma_16857 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (has_sub.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_sub.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_16858 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (semigroup.{0} (option.{0} num)) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (semigroup.{0} (option.{0} num)))  := sorry --non-trivial
lemma new_lemma_16859 (h0 : group (ordered_comm_ring real)) : is_cyclic (ordered_comm_ring real) := sorry --non-trivial
lemma new_lemma_16860 (h0 : group (has_nnnorm (random_gen fun_info))) : group.fg (has_nnnorm (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_16861 (h0 : functor.add_const (group (as_linear_order unsigned)) congr_arg_kind) : @is_cyclic.{0} (as_linear_order.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (as_linear_order.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_16862 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (linear_ordered_comm_group.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_16863 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_16864 (h0 : ring (linear_order empty)) : is_principal_ideal_ring (linear_order empty) := sorry --non-trivial
lemma new_lemma_16865 (h2 : topological_space (add_comm_semigroup ereal)) : totally_disconnected_space (add_comm_semigroup ereal) := sorry --non-trivial
lemma new_lemma_16866 (h0 : topological_space (measurable_space (random_gen (has_inv (has_inv to_additive.value_type))))) : path_connected_space (measurable_space (random_gen (has_inv (has_inv to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_16867 (h0 : fin has_zero.zero) : @separated_space.{0} (boolean_algebra.core.{0} (has_Inf.{0} pos)) (@matrix.vec_empty.{0} (uniform_space.{0} (boolean_algebra.core.{0} (has_Inf.{0} pos))) h0)  := sorry --non-trivial
lemma new_lemma_16868 (h0 : group (boolean_algebra.core (has_add (has_neg (finset (has_add linarith.comp)))))) : is_simple_group (boolean_algebra.core (has_add (has_neg (finset (has_add linarith.comp))))) := sorry --non-trivial
lemma new_lemma_16869 (h0 : function.extfun Type group) : @group.fg.{0} (monoid_with_zero.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} h0 (monoid_with_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_16870 (h0 : ring (pseudo_metric_space name)) : is_principal_ideal_ring (pseudo_metric_space name) := sorry --non-trivial
lemma new_lemma_16871 (h2 : not (function.extfun Type topological_space -> false)) : @irreducible_space.{0} congr_arg_kind (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h2) congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_16872 (h0 : topological_space (ordered_ring congr_arg_kind)) : t1_space (ordered_ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_16873 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (sub_neg_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (sub_neg_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_16874 (h0 : functor.add_const (topological_space (linear_ordered_comm_monoid_with_zero unsigned)) empty) : @t0_space.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_16875 (h0 : filter (has_dist ennreal)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_16876 (h0 : not (ring (metric_space char) -> false)) : @is_domain.{0} (metric_space.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (metric_space.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_16877 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (has_bot.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_bot.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_16878 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (measurable_space.dynkin_system.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (measurable_space.dynkin_system.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_16879 (h0 : topological_space (has_nndist (finset (finset (finset linarith.comp))))) : totally_separated_space (has_nndist (finset (finset (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_16880 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (bin_tree.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (bin_tree.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_16881 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (mul_zero_class.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (mul_zero_class.{0} name))  := sorry --non-trivial
lemma new_lemma_16882 (h0 : functor.add_const (topological_space (linear_ordered_field empty)) congr_arg_kind) : @totally_disconnected_space.{0} (linear_ordered_field.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_field.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_16883 (h0 : topological_space (has_neg_part (option ennreal))) : regular_space (has_neg_part (option ennreal)) := sorry --non-trivial
lemma new_lemma_16884 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (ordered_comm_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (ordered_comm_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_16885 (h0 : ordered_comm_monoid (has_add (has_add linarith.comp))) : has_exists_mul_of_le (has_add (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_16886 (h0 : topological_space (generalized_boolean_algebra (has_pos_part name))) : totally_disconnected_space (generalized_boolean_algebra (has_pos_part name)) := sorry --non-trivial
lemma new_lemma_16887 (h0 : functor.add_const (function.extfun Type topological_space) environment.implicit_infer_kind) : @normal_space.{0} (ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) environment.implicit_infer_kind h0) (ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_16888 (h0 : topological_space (add_cancel_monoid (has_Inf pos))) : discrete_topology (add_cancel_monoid (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_16889 (h1 : uniform_space (non_unital_non_assoc_semiring linarith.comp_source)) : complete_space (non_unital_non_assoc_semiring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_16890 (h2 : ring ereal) : is_domain ereal := sorry --non-trivial
lemma new_lemma_16891 (h0 : ordered_comm_monoid pos -> ordered_comm_monoid pos -> Prop) : transitive h0 := sorry --non-trivial
lemma new_lemma_16892 (h0 : complete_lattice (normed_lattice_add_comm_group (has_Inf pos))) : is_compactly_generated (normed_lattice_add_comm_group (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_16893 (h0 : group (generalized_boolean_algebra (finset linarith.comp))) : is_simple_group (generalized_boolean_algebra (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_16894 (h0 : functor.add_const (topological_space (ring linarith.comp)) pos) : @preirreducible_space.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_16895 (h0 : functor.add_const (add_monoid (comm_group name)) name) : @add_monoid.fg.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (add_monoid.{0} (comm_group.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_16896 (h0 : functor.add_const (function.extfun Type ordered_add_comm_monoid) linarith.comp) : @archimedean.{0} (normed_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_add_comm_monoid.{0}) linarith.comp h0) (normed_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_16897 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (normed_linear_ordered_group congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_16898 (h0 : ring (normed_lattice_add_comm_group Type)) : is_domain (normed_lattice_add_comm_group Type) := sorry --non-trivial
lemma new_lemma_16899 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @group.fg.{0} (dlist.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) group.{0}) (dlist.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_16900 (h0 : ring (has_inv (random_gen (random_gen (random_gen (random_gen char)))))) : is_domain (has_inv (random_gen (random_gen (random_gen (random_gen char))))) := sorry --non-trivial
lemma new_lemma_16901 (h0 : functor.add_const (ring (boolean_algebra environment.implicit_infer_kind)) name) : @is_principal_ideal_ring.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_16902 (h0 : not (function.extfun Type ring -> false)) : @strong_rank_condition.{0} (random_gen.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (random_gen.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_16903 (h0 : topological_space (encodable (random_gen (random_gen to_additive.value_type)))) : path_connected_space (encodable (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_16904 (h0 : list (cancel_monoid (option ennreal))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_16905 (h0 : finset (has_zero (has_add (comm_group (comm_group Type))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_16906 (h1 : complete_lattice (has_emptyc (random_gen linarith.comp_source))) : is_compactly_generated (has_emptyc (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_16907 (h0 : filter (has_pos_part (has_pos_part (has_pos_part (has_add linarith.comp))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_16908 (h0 : complete_lattice (ordered_semiring linarith.comp)) : is_atomistic (ordered_semiring linarith.comp) := sorry --non-trivial
lemma new_lemma_16909 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (boolean_algebra.core.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.core.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_16910 (h0 : ring (complete_distrib_lattice pos)) : rank_condition (complete_distrib_lattice pos) := sorry --non-trivial
lemma new_lemma_16911 (h0 : not (ring (has_sub empty) -> false)) : @is_domain.{0} (has_sub.{0} empty) (@classical.by_contradiction'.{1} (ring.{0} (has_sub.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_16912 (h0 : topological_space (add_right_cancel_monoid linarith.comp)) : normal_space (add_right_cancel_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_16913 (h1 : has_lt linarith.ineq) : no_max_order linarith.ineq := sorry --non-trivial
lemma new_lemma_16914 (h0 : topological_space (add_cancel_monoid (has_add (has_neg_part name)))) : irreducible_space (add_cancel_monoid (has_add (has_neg_part name))) := sorry --non-trivial
lemma new_lemma_16915 (h0 : functor.add_const (monoid (mul_zero_class ennreal)) environment.implicit_infer_kind) : @monoid.fg.{0} (mul_zero_class.{0} ennreal) (@functor.add_const.run.{0 0} (monoid.{0} (mul_zero_class.{0} ennreal)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_16916 (h0 : group (ordered_comm_ring (has_bot (has_bot real)))) : is_simple_group (ordered_comm_ring (has_bot (has_bot real))) := sorry --non-trivial
lemma new_lemma_16917 (h0 : functor.add_const (ordered_comm_monoid (add_comm_monoid name)) name) : @has_exists_mul_of_le.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (add_comm_monoid.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_16918 (h0 : functor.add_const (complete_lattice (add_comm_monoid unsigned)) name) : @is_atomistic.{0} (add_comm_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_comm_monoid.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_16919 (h0 : topological_space (has_star unsigned)) : discrete_topology (has_star unsigned) := sorry --non-trivial
lemma new_lemma_16920 (h0 : topological_space (has_union (semiring unsigned))) : path_connected_space (has_union (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_16921 (h0 : not (topological_space (topological_space to_additive.value_type) -> false)) : @path_connected_space.{0} (topological_space.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (topological_space.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_16922 (h0 : topological_space (has_zero name)) : regular_space (has_zero name) := sorry --non-trivial
lemma new_lemma_16923 (h0 : cancel_comm_monoid_with_zero (has_bot (semiring (semiring empty)))) : unique_factorization_monoid (has_bot (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_16924 (h0 : ring (with_zero (has_ssubset linarith.ineq))) : is_domain (with_zero (has_ssubset linarith.ineq)) := sorry --non-trivial
lemma new_lemma_16925 (h0 : functor.add_const (monoid (normed_comm_ring ennreal)) Type) : @monoid.fg.{0} (normed_comm_ring.{0} ennreal) (@functor.add_const.run.{0 1} (monoid.{0} (normed_comm_ring.{0} ennreal)) Type h0)  := sorry --non-trivial
lemma new_lemma_16926 (h1 : add_group (comm_ring fun_info)) : is_add_cyclic (comm_ring fun_info) := sorry --non-trivial
lemma new_lemma_16927 (h0 : functor.add_const (topological_space (has_nndist ennreal)) name) : @preirreducible_space.{0} (has_nndist.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_16928 (h2 : topological_space char) (h3 : preorder char) : order_topology char := sorry --non-trivial
lemma new_lemma_16929 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_semilattice_Sup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_16930 (h0 : complete_lattice (distrib (has_nnnorm (has_nnnorm linarith.comp_source)))) : complete_lattice.is_Sup_finite_compact (distrib (has_nnnorm (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_16931 (h0 : semiring (boolean_algebra.core (measurable_space Type))) : is_noetherian_ring (boolean_algebra.core (measurable_space Type)) := sorry --non-trivial
lemma new_lemma_16932 (h0 : set (add_comm_semigroup (boolean_algebra.core fun_info) -> std_gen)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_16933 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (linear_ordered_semiring.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_16934 (h1 : not (ring (topological_space char) -> false)) : @strong_rank_condition.{0} (topological_space.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (topological_space.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_16935 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (has_ssubset.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_ssubset.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_16936 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (linear_ordered_semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_16937 (h0 : functor.add_const (complete_lattice (finset linarith.comp)) (has_nndist Type)) : @is_compactly_generated.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 1} (complete_lattice.{0} (finset.{0} linarith.comp)) (has_nndist.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_16938 (h0 : complete_lattice (complete_distrib_lattice (option (option (option ennreal))))) : is_compactly_generated (complete_distrib_lattice (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_16939 (h0 : fin has_zero.zero) : @rank_condition.{1} (sub_neg_monoid.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (sub_neg_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_16940 (h1 : list (has_inv (has_top to_additive.value_type))) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_16941 (h0 : ring (finset (has_add (has_nndist pos)))) : rank_condition (finset (has_add (has_nndist pos))) := sorry --non-trivial
lemma new_lemma_16942 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (has_dist ennreal)) := sorry --non-trivial
lemma new_lemma_16943 (h0 : ring (complete_semilattice_Sup linarith.comp_source)) : is_domain (complete_semilattice_Sup linarith.comp_source) := sorry --non-trivial
lemma new_lemma_16944 (h0 : topological_space (has_bot (has_add pos))) : regular_space (has_bot (has_add pos)) := sorry --non-trivial
lemma new_lemma_16945 (h0 : functor.add_const (function.extfun (Type 1) topological_space) name) : @discrete_topology.{1} (ordered_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) name h0) (ordered_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_16946 (h0 : add_group (add_comm_monoid (has_add (has_add Type)))) : is_add_cyclic (add_comm_monoid (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_16947 (h0 : group (has_zero (has_neg linarith.comp))) : normalizer_condition (has_zero (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_16948 (h0 : complete_lattice (with_one congr_arg_kind)) : complete_lattice.is_Sup_finite_compact (with_one congr_arg_kind) := sorry --non-trivial
lemma new_lemma_16949 (h0 : uniform_space (ordered_comm_monoid (has_neg pos))) : complete_space (ordered_comm_monoid (has_neg pos)) := sorry --non-trivial
lemma new_lemma_16950 (h0 : function.extfun Type (functor.comp topological_space canonically_ordered_comm_semiring)) : @regular_space.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} canonically_ordered_comm_semiring.{0} ennreal (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} canonically_ordered_comm_semiring.{0}) h0 ennreal))  := sorry --non-trivial
lemma new_lemma_16951 (h0 : finset (generalized_boolean_algebra (has_nndist pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_16952 (h0 : functor.add_const (topological_space (cancel_monoid linarith.comp)) name) : @t1_space.{0} (cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_16953 (h0 : functor.add_const (list (normed_comm_ring name)) name) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_16954 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (encodable.{0} (random_gen.{0} to_additive.value_type)) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (encodable.{0} (random_gen.{0} to_additive.value_type)))  := sorry --non-trivial
lemma new_lemma_16955 (h0 : functor.add_const (ordered_add_comm_monoid (pseudo_metric_space congr_arg_kind)) unsigned) : @archimedean.{0} (pseudo_metric_space.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (pseudo_metric_space.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_16956 (h0 : semiring char) (h2 : char) : even h2 := sorry --non-trivial
lemma new_lemma_16957 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (semiring.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_16958 (h0 : ring (id (has_norm (has_norm unsigned)))) : rank_condition (id (has_norm (has_norm unsigned))) := sorry --non-trivial
lemma new_lemma_16959 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (free_add_monoid.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (free_add_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_16960 (h0 : group (linear_ordered_comm_group ennreal)) : group.fg (linear_ordered_comm_group ennreal) := sorry --non-trivial
lemma new_lemma_16961 (h0 : list (complete_semilattice_Sup (random_gen (has_nnnorm fun_info)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_16962 (h0 : semiring (semigroup (finset pos))) : is_noetherian_ring (semigroup (finset pos)) := sorry --non-trivial
lemma new_lemma_16963 (h0 : list (has_top (random_gen (has_nnnorm fun_info)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_16964 (h0 : complete_lattice (mul_one_class (add_comm_semigroup (mul_one_class std_gen)))) : complete_lattice.is_Sup_finite_compact (mul_one_class (add_comm_semigroup (mul_one_class std_gen))) := sorry --non-trivial
lemma new_lemma_16965 (h0 : group (has_top (has_top linarith.comp_source))) : normalizer_condition (has_top (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_16966 (h0 : not (group (has_inv (random_gen linarith.comp_source)) -> false)) : @group.fg.{0} (has_inv.{0} (random_gen.{0} linarith.comp_source)) (@classical.by_contradiction'.{1} (group.{0} (has_inv.{0} (random_gen.{0} linarith.comp_source))) h0)  := sorry --non-trivial
lemma new_lemma_16967 (h0 : semiring (free_add_monoid (option (option (option unsigned))))) : is_noetherian_ring (free_add_monoid (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_16968 (h1 h2 : multiset (add_comm_semigroup char)) : multiset.subset h1 h2 := sorry --non-trivial
lemma new_lemma_16969 (h0 : functor.add_const (filter (has_neg linarith.comp)) linarith.comp) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_16970 (h0 : topological_space (cancel_monoid environment.implicit_infer_kind)) : irreducible_space (cancel_monoid environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_16971 (h0 : has_mem.mem linarith.comp has_emptyc.emptyc) : @is_cyclic.{0} linarith.comp (@finset.pi.empty.{1 0} Type group.{0} linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_16972 (h0 : topological_space (semigroup (finset environment.implicit_infer_kind))) : loc_path_connected_space (semigroup (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_16973 (h0 : functor.add_const (topological_space (add_cancel_monoid linarith.comp)) pos) : @discrete_topology.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_16974 (h0 : functor.add_const (add_monoid (ring Type)) pos) : @add_monoid.fg.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (add_monoid.{1} (ring.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_16975 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (add_cancel_monoid.{0} (semiring.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_cancel_monoid.{0} (semiring.{0} empty)))  := sorry --non-trivial
lemma new_lemma_16976 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (has_top.{0} string_imp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 group.{0}) (has_top.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_16977 (h0 : complete_lattice (semi_normed_ring (has_nnnorm reducibility_hints))) : is_compactly_generated (semi_normed_ring (has_nnnorm reducibility_hints)) := sorry --non-trivial
lemma new_lemma_16978 (h0 : list (has_inter (option ennreal))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_16979 (h0 : functor.add_const (topological_space (boolean_algebra.core Type)) linarith.comp) : @locally_compact_space.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.core.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_16980 (h0 : not (group (has_emptyc linarith.comp_source) -> false)) : @normalizer_condition.{0} (has_emptyc.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (group.{0} (has_emptyc.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_16981 (h1 : topological_space (has_emptyc linarith.comp)) : irreducible_space (has_emptyc linarith.comp) := sorry --non-trivial
lemma new_lemma_16982 (h0 : topological_space (metric_space (has_norm linarith.comp))) : totally_disconnected_space (metric_space (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_16983 (h0 : functor.add_const (ring Type) Type) : @is_principal_ideal_ring.{1} Type (@functor.add_const.run.{1 1} (ring.{1} Type) Type h0)  := sorry --non-trivial
lemma new_lemma_16984 (h0 : list (has_to_string (ordered_ring linarith.comp))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_16985 (h0 : has_mem.mem (has_top fun_info) has_emptyc.emptyc) : @strong_rank_condition.{0} (has_top.{0} fun_info) (@finset.pi.empty.{1 0} Type ring.{0} (has_top.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_16986 (h0 : function.extfun Type group) : @is_simple_group.{0} pos (@function.extfun_app.{2 1} Type group.{0} h0 pos)  := sorry --non-trivial
lemma new_lemma_16987 (h0 : function.extfun (Type 1) topological_space) : @t1_space.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_16988 (h0 : not (topological_space (mul_zero_class unsigned) -> false)) : @path_connected_space.{0} (mul_zero_class.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (mul_zero_class.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_16989 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (has_inner.{0 0} empty congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inner.{0 0} empty congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_16990 (h0 : topological_space (has_Inf (has_Inf name))) : t0_space (has_Inf (has_Inf name)) := sorry --non-trivial
lemma new_lemma_16991 (h0 : functor.add_const (list (semigroup environment.implicit_infer_kind)) Type) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_16992 (h0 : topological_space (finset (finset pos))) : totally_disconnected_space (finset (finset pos)) := sorry --non-trivial
lemma new_lemma_16993 (h0 : add_group (plift (option num))) : is_add_cyclic (plift (option num)) := sorry --non-trivial
lemma new_lemma_16994 (h0 : not (function.extfun Type list -> false)) : list.nodup (function.extfun_app (classical.by_contradiction' h0) (comm_ring to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_16995 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (finset.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_16996 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (normed_comm_ring.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (normed_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_16997 (h0 : topological_space (canonically_ordered_comm_semiring (has_pos_part linarith.comp))) : locally_compact_space (canonically_ordered_comm_semiring (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_16998 (h0 h1 : set char) (h2 : char) : set.union h0 h1 h2 := sorry --non-trivial
lemma new_lemma_16999 (h0 : monoid (complete_linear_order congr_arg_kind)) : monoid.fg (complete_linear_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_17000 (h0 : group (linear_ordered_add_comm_group (denumerable linarith.comp_source))) : group.fg (linear_ordered_add_comm_group (denumerable linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_17001 (h0 : topological_space (bin_tree (has_top fun_info))) : t0_space (bin_tree (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_17002 (h0 : function.extfun (finset Type) (has_mem.mem (semiring linarith.ineq))) : @totally_separated_space.{0} (semiring.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type topological_space.{0} (semiring.{0} linarith.ineq) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} linarith.ineq)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_17003 (h0 : ordered_comm_monoid (ordered_comm_ring linarith.comp)) : has_exists_mul_of_le (ordered_comm_ring linarith.comp) := sorry --non-trivial
lemma new_lemma_17004 (h0 : ring (add_comm_monoid (comm_group name))) : is_domain (add_comm_monoid (comm_group name)) := sorry --non-trivial
lemma new_lemma_17005 (h0 : topological_space (pseudo_metric_space (option (option (option ennreal))))) : topological_space.separable_space (pseudo_metric_space (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_17006 (h0 : functor.add_const (monoid (finset linarith.comp)) (finset (has_add (ring Type)))) : @monoid.fg.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 1} (monoid.{0} (finset.{0} linarith.comp)) (finset.{1} (has_add.{1} (ring.{1} Type))) h0)  := sorry --non-trivial
lemma new_lemma_17007 (h1 : topological_space (distrib (has_nnnorm char))) : t0_space (distrib (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_17008 (h0 : functor.add_const (topological_space (cancel_monoid ennreal)) (option ennreal)) : @irreducible_space.{0} (cancel_monoid.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} ennreal)) (option.{0} ennreal) h0)  := sorry --non-trivial
lemma new_lemma_17009 (h0 : topological_space (denumerable (random_gen to_additive.value_type))) : locally_compact_space (denumerable (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_17010 (h0 : semiring (has_add (has_nndist environment.implicit_infer_kind))) : is_noetherian_ring (has_add (has_nndist environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_17011 (h0 : topological_space (comm_ring (mul_one_class char))) : t0_space (comm_ring (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_17012 (h0 : filter (has_zero (finset pos))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_17013 (h0 : functor.add_const (topological_space (complete_distrib_lattice (has_add Type))) Type) : @t1_space.{1} (complete_distrib_lattice.{1} (has_add.{1} Type)) (@functor.add_const.run.{1 1} (topological_space.{1} (complete_distrib_lattice.{1} (has_add.{1} Type))) Type h0)  := sorry --non-trivial
lemma new_lemma_17014 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (semiring.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_17015 (h0 : finset (has_zero (has_to_string name))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_17016 (h0 : ring (has_compl string_imp)) : rank_condition (has_compl string_imp) := sorry --non-trivial
lemma new_lemma_17017 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @regular_space.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_17018 (h0 : ulower pnat) (h1 : fin has_zero.zero) : pnat.coprime (id (ulower.up h0)) (matrix.vec_empty h1) := sorry --non-trivial
lemma new_lemma_17019 (h0 : set (has_nnnorm (mul_one_class linarith.ineq))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_17020 (h0 : topological_space (sub_neg_monoid (has_add (finset linarith.comp)))) : irreducible_space (sub_neg_monoid (has_add (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_17021 (h0 : not (group linarith.comp_source -> false)) : @normalizer_condition.{0} linarith.comp_source (@classical.by_contradiction'.{1} (group.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_17022 (h1 : group (has_norm string_imp)) : is_cyclic (has_norm string_imp) := sorry --non-trivial
lemma new_lemma_17023 (h0 : complete_lattice (has_append (comm_ring char))) : complete_lattice.is_Sup_finite_compact (has_append (comm_ring char)) := sorry --non-trivial
lemma new_lemma_17024 (h0 : functor.add_const (topological_space (add_cancel_comm_monoid empty)) empty) : @preirreducible_space.{0} (add_cancel_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_comm_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_17025 (h0 : ordered_add_comm_monoid (has_pos_part (ring (boolean_algebra pos)))) : archimedean (has_pos_part (ring (boolean_algebra pos))) := sorry --non-trivial
lemma new_lemma_17026 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (comm_group.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_17027 (h0 : functor.add_const (topological_space (comm_group unsigned)) name) : @t0_space.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_17028 (h0 : list (has_neg_part (semigroup name))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_17029 (h0 : ring (semigroup environment.implicit_infer_kind)) : rank_condition (semigroup environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_17030 (h0 : option (option (option ennreal)) -> option (option (option ennreal)) -> Prop) : is_symm (option (option (option ennreal))) h0 := sorry --non-trivial
lemma new_lemma_17031 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (normed_comm_ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (normed_comm_ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_17032 (h0 : topological_space (canonically_ordered_comm_semiring pos)) : locally_compact_space (canonically_ordered_comm_semiring pos) := sorry --non-trivial
lemma new_lemma_17033 (h0 : add_group (has_add (has_neg pos))) : is_add_cyclic (has_add (has_neg pos)) := sorry --non-trivial
lemma new_lemma_17034 (h0 : ring (add_comm_semigroup linarith.ineq)) : is_domain (add_comm_semigroup linarith.ineq) := sorry --non-trivial
lemma new_lemma_17035 (h0 : topological_space (cancel_monoid (has_add (comm_group (boolean_algebra environment.implicit_infer_kind))))) : t1_space (cancel_monoid (has_add (comm_group (boolean_algebra environment.implicit_infer_kind)))) := sorry --non-trivial
lemma new_lemma_17036 (h0 : topological_space (ordered_comm_ring real)) : loc_path_connected_space (ordered_comm_ring real) := sorry --non-trivial
lemma new_lemma_17037 (h0 : functor.add_const (topological_space (group_with_zero ennreal)) ennreal) : @preirreducible_space.{0} (group_with_zero.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (group_with_zero.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_17038 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (omega_complete_partial_order.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (omega_complete_partial_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_17039 (h0 : option (add_monoid (preorder congr_arg_kind))) (h1 : add_monoid (preorder congr_arg_kind)) : add_monoid.fg (preorder congr_arg_kind) := sorry --non-trivial
lemma new_lemma_17040 (h0 : topological_space (ordered_comm_monoid (has_Inf (has_add pos)))) : irreducible_space (ordered_comm_monoid (has_Inf (has_add pos))) := sorry --non-trivial
lemma new_lemma_17041 (h0 : not (ring (topological_space linarith.comp_source) -> false)) : @strong_rank_condition.{0} (topological_space.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (topological_space.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_17042 (h0 : fin has_zero.zero) : @irreducible_space.{0} (ordered_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (ordered_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_17043 (h1 : group (comm_ring (has_ssubset string_imp))) : group.fg (comm_ring (has_ssubset string_imp)) := sorry --non-trivial
lemma new_lemma_17044 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (option.{0} name) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (option.{0} name))  := sorry --non-trivial
lemma new_lemma_17045 (h0 : not (add_group (linear_ordered_add_comm_group reducibility_hints) -> false)) : @is_add_cyclic.{0} (linear_ordered_add_comm_group.{0} reducibility_hints) (@classical.by_contradiction'.{1} (add_group.{0} (linear_ordered_add_comm_group.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_17046 (h0 : functor.add_const (topological_space (normed_comm_ring linarith.comp)) linarith.comp) : @regular_space.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_17047 (h0 : group (normed_group (has_nnnorm (has_nnnorm linarith.ineq)))) : group.fg (normed_group (has_nnnorm (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_17048 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (measurable_space.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (measurable_space.{0} num))  := sorry --non-trivial
lemma new_lemma_17049 (h0 : functor.comp topological_space canonically_ordered_comm_semiring ennreal) : @t0_space.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} canonically_ordered_comm_semiring.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_17050 (h0 : add_group (comm_ring (denumerable to_additive.value_type))) : is_add_cyclic (comm_ring (denumerable to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_17051 (h0 : functor.comp list has_nndist name) : list.nodup (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_17052 (h0 : functor.add_const (monoid (add_cancel_monoid pos)) (add_comm_monoid pos)) : @monoid.fg.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (monoid.{0} (add_cancel_monoid.{0} pos)) (add_comm_monoid.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_17053 (h0 : topological_space (has_add name)) : topological_space.separable_space (has_add name) := sorry --non-trivial
lemma new_lemma_17054 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (complete_distrib_lattice.{0} ennreal) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (complete_distrib_lattice.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_17055 (h0 : topological_space (non_assoc_semiring (semiring (semiring (semiring empty))))) : normal_space (non_assoc_semiring (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_17056 (h0 : functor.add_const (function.extfun Type ordered_comm_monoid) (has_neg Type)) : @has_exists_mul_of_le.{0} (ordered_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) (has_neg.{1} Type) h0) (ordered_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_17057 (h0 : topological_space (add_cancel_monoid (semigroup (has_nndist Type)))) : topological_space.separable_space (add_cancel_monoid (semigroup (has_nndist Type))) := sorry --non-trivial
lemma new_lemma_17058 (h0 : topological_space (add_comm_monoid (add_comm_monoid real))) : totally_disconnected_space (add_comm_monoid (add_comm_monoid real)) := sorry --non-trivial
lemma new_lemma_17059 (h0 : monoid (has_top (semiring (semiring (has_top empty))))) : monoid.fg (has_top (semiring (semiring (has_top empty)))) := sorry --non-trivial
lemma new_lemma_17060 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_17061 (h0 : monoid (canonically_ordered_comm_semiring (has_add (has_add name)))) : monoid.fg (canonically_ordered_comm_semiring (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_17062 (h0 : functor.add_const (complete_lattice (normed_comm_ring Type)) Type) : @complete_lattice.is_Sup_finite_compact.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 1} (complete_lattice.{1} (normed_comm_ring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_17063 (h0 : ring (add_cancel_comm_monoid (has_ssubset (has_nnnorm reducibility_hints)))) : rank_condition (add_cancel_comm_monoid (has_ssubset (has_nnnorm reducibility_hints))) := sorry --non-trivial
lemma new_lemma_17064 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_principal_ideal_ring.{1} (add_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ring.{1}) (add_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_17065 (h0 : functor.add_const (ring (normed_comm_ring pos)) (ordered_ring Type)) : @is_principal_ideal_ring.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (normed_comm_ring.{0} pos)) (ordered_ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_17066 (h0 : fin has_zero.zero) : @t1_space.{0} (normed_lattice_add_comm_group.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (normed_lattice_add_comm_group.{0} pos)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_17067 (h0 : functor.add_const (topological_space (add_cancel_monoid num)) num) : @irreducible_space.{0} (add_cancel_monoid.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_17068 (h0 : functor.add_const (complete_lattice (boolean_algebra unsigned)) environment.implicit_infer_kind) : @complete_lattice.is_Sup_finite_compact.{0} (boolean_algebra.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (boolean_algebra.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_17069 (h0 : topological_space (ordered_comm_monoid (has_pos_part (finset Type)))) : normal_space (ordered_comm_monoid (has_pos_part (finset Type))) := sorry --non-trivial
lemma new_lemma_17070 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @preirreducible_space.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_17071 (h0 : group (measurable_space (random_gen linarith.ineq))) : is_cyclic (measurable_space (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_17072 (h0 : add_monoid (linear_ordered_field (option unsigned))) : add_monoid.fg (linear_ordered_field (option unsigned)) := sorry --non-trivial
lemma new_lemma_17073 (h2 : topological_space (linear_ordered_add_comm_group to_additive.value_type)) : totally_disconnected_space (linear_ordered_add_comm_group to_additive.value_type) := sorry --non-trivial
lemma new_lemma_17074 (h0 : functor.add_const (function.extfun Type filter) pos) : countable_Inter_filter (function.extfun_app (functor.add_const.run h0) (add_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_17075 (h0 : topological_space (add_comm_semigroup (add_comm_semigroup string.iterator_imp))) : t0_space (add_comm_semigroup (add_comm_semigroup string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_17076 (h0 : filter (has_bot (has_Inf linarith.comp))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_17077 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (finset.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (finset.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_17078 (h0 : functor.add_const (topological_space (has_nndist name)) name) : @preconnected_space.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_17079 (h0 : has_mem.mem (has_norm to_additive.value_type) has_emptyc.emptyc) : @t0_space.{0} (has_norm.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_norm.{0} to_additive.value_type) h0)  := sorry --non-trivial
lemma new_lemma_17080 (h0 : topological_space (has_zero (normed_comm_ring (ring pos)))) : normal_space (has_zero (normed_comm_ring (ring pos))) := sorry --non-trivial
lemma new_lemma_17081 (h1 : set (distrib (normed_field std_gen))) : set.finite h1 := sorry --non-trivial
lemma new_lemma_17082 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (add_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (add_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_17083 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} (add_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (add_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_17084 (h0 : uniform_space (canonically_ordered_monoid (has_Inf (has_Inf (has_Inf (sub_neg_monoid pos)))))) : separated_space (canonically_ordered_monoid (has_Inf (has_Inf (has_Inf (sub_neg_monoid pos))))) := sorry --non-trivial
lemma new_lemma_17085 (h0 : not (ring (non_assoc_semiring congr_arg_kind) -> false)) : @is_domain.{0} (non_assoc_semiring.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (ring.{0} (non_assoc_semiring.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_17086 (h0 : finset (generalized_boolean_algebra (has_add (has_add Type)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_17087 (h0 : not (topological_space (measure_theory.measure_space num) -> false)) : @normal_space.{0} (measure_theory.measure_space.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (measure_theory.measure_space.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_17088 (h0 : topological_space (add_cancel_monoid (has_pos_part linarith.comp))) : loc_path_connected_space (add_cancel_monoid (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_17089 (h0 : topological_space (left_cancel_monoid (semiring empty))) : t1_space (left_cancel_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_17090 (h0 : topological_space (measurable_space.dynkin_system (semiring (semiring (semiring unsigned))))) : locally_compact_space (measurable_space.dynkin_system (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_17091 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @totally_disconnected_space.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_17092 (h0 : complete_lattice (id linarith.comp)) : complete_lattice.is_Sup_finite_compact (id linarith.comp) := sorry --non-trivial
lemma new_lemma_17093 (h0 : topological_space (has_to_string linarith.comp)) : path_connected_space (has_to_string linarith.comp) := sorry --non-trivial
lemma new_lemma_17094 (h3 : not (filter (random_gen to_additive.value_type) -> false)) : filter.ne_bot (classical.by_contradiction' h3) := sorry --non-trivial
lemma new_lemma_17095 (h0 : not (group (measurable_space congr_arg_kind) -> false)) : @group.fg.{0} (measurable_space.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (group.{0} (measurable_space.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_17096 (h0 : functor.add_const (function.extfun Type topological_space) name) : @irreducible_space.{0} (add_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (add_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_17097 (h0 : add_monoid (boolean_algebra (has_Inf linarith.comp))) : add_monoid.fg (boolean_algebra (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_17098 (h0 : add_monoid (boolean_algebra (normed_comm_ring (has_add Type)))) : add_monoid.fg (boolean_algebra (normed_comm_ring (has_add Type))) := sorry --non-trivial
lemma new_lemma_17099 (h0 : complete_lattice (has_div (distrib to_additive.value_type))) : complete_lattice.is_Sup_finite_compact (has_div (distrib to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_17100 (h0 : function.extfun Type topological_space) : @regular_space.{0} (canonically_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_17101 (h0 : ring (has_nnnorm fun_info) -> Prop) (h1 : Exists (fun (x : ring (has_nnnorm fun_info)), h0 x)) : @is_domain.{0} (has_nnnorm.{0} fun_info) (@classical.some.{1} (ring.{0} (has_nnnorm.{0} fun_info)) h0 h1)  := sorry --non-trivial
lemma new_lemma_17102 (h0 : ring (group_with_zero unsigned)) : is_domain (group_with_zero unsigned) := sorry --non-trivial
lemma new_lemma_17103 (h0 : functor.add_const (ring (add_comm_monoid name)) Type) : @is_domain.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 1} (ring.{0} (add_comm_monoid.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_17104 (h0 : topological_space (canonically_ordered_monoid (has_add (has_add linarith.comp)))) : t0_space (canonically_ordered_monoid (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_17105 (h0 : function.extfun (finset Type) (has_mem.mem (semiring to_additive.value_type))) : @strong_rank_condition.{0} (semiring.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type ring.{0} (semiring.{0} to_additive.value_type) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} to_additive.value_type)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_17106 (h0 : functor.add_const (topological_space nnreal) empty) : preirreducible_space nnreal := sorry --non-trivial
lemma new_lemma_17107 (h0 : ring (add_cancel_monoid (finset Type))) : is_domain (add_cancel_monoid (finset Type)) := sorry --non-trivial
lemma new_lemma_17108 (h2 : uniform_space (dlist (has_nnnorm linarith.comp_source))) : complete_space (dlist (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_17109 (h0 : functor.add_const (topological_space (boolean_algebra.core name)) pos) : @preirreducible_space.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_17110 (h0 : topological_space (has_neg (has_add (has_add environment.implicit_infer_kind)))) : irreducible_space (has_neg (has_add (has_add environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_17111 (h0 : complete_lattice (has_div (mul_one_class string.iterator_imp))) : is_compactly_generated (has_div (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_17112 (h2 : topological_space (comm_ring linarith.comp_source)) : t0_space (comm_ring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_17113 (h0 : topological_space (has_inter (option ennreal))) : t1_space (has_inter (option ennreal)) := sorry --non-trivial
lemma new_lemma_17114 (h0 : functor.add_const (complete_lattice (add_left_cancel_semigroup empty)) empty) : @is_compactly_generated.{0} (add_left_cancel_semigroup.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_left_cancel_semigroup.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_17115 (h0 : ring (denumerable (has_nnnorm (has_nnnorm (has_nnnorm to_additive.value_type))))) : rank_condition (denumerable (has_nnnorm (has_nnnorm (has_nnnorm to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_17116 (h0 : ring (normed_group (has_nnnorm (has_nnnorm (random_gen fun_info))))) : strong_rank_condition (normed_group (has_nnnorm (has_nnnorm (random_gen fun_info)))) := sorry --non-trivial
lemma new_lemma_17117 (h0 : function.extfun Type topological_space) : @t0_space.{0} (ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_17118 (h1 : has_mem.mem (id linarith.comp) has_emptyc.emptyc) : @add_monoid.fg.{0} (@id.{2} Type linarith.comp) (@finset.pi.empty.{1 0} Type add_monoid.{0} (@id.{2} Type linarith.comp) h1)  := sorry --non-trivial
lemma new_lemma_17119 (h0 : complete_lattice (add_semigroup (option (option (option unsigned))))) : is_compactly_generated (add_semigroup (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_17120 (h0 : functor.add_const (ordered_add_comm_monoid (boolean_algebra linarith.comp)) linarith.comp) : @archimedean.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (boolean_algebra.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_17121 (h0 : topological_space (has_to_string (has_to_string pos))) : totally_separated_space (has_to_string (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_17122 (h0 : ring (has_Inf (has_Inf name))) : strong_rank_condition (has_Inf (has_Inf name)) := sorry --non-trivial
lemma new_lemma_17123 (h0 : uniform_space (with_one (complete_semilattice_Sup empty))) : complete_space (with_one (complete_semilattice_Sup empty)) := sorry --non-trivial
lemma new_lemma_17124 (h0 : functor.add_const (cancel_comm_monoid_with_zero (semigroup name)) pos) : @unique_factorization_monoid.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (semigroup.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_17125 (h0 : complete_lattice (ordered_comm_ring (has_neg Type))) : is_compactly_generated (ordered_comm_ring (has_neg Type)) := sorry --non-trivial
lemma new_lemma_17126 (h0 : topological_space (option (option name))) : regular_space (option (option name)) := sorry --non-trivial
lemma new_lemma_17127 (h4 : complete_lattice (mul_one_class environment.implicit_infer_kind)) : complete_lattice.is_Sup_finite_compact (mul_one_class environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_17128 (h0 : uniform_space (has_pos_part (finset linarith.comp))) : separated_space (has_pos_part (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_17129 (h1 : topological_space (encodable linarith.ineq)) : totally_disconnected_space (encodable linarith.ineq) := sorry --non-trivial
lemma new_lemma_17130 (h0 : topological_space (semigroup (has_neg linarith.comp))) : irreducible_space (semigroup (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_17131 (h0 : group (finset unsigned)) : is_cyclic (finset unsigned) := sorry --non-trivial
lemma new_lemma_17132 (h0 : topological_space (has_one (random_gen (has_norm (random_gen (has_top empty)))))) : locally_compact_space (has_one (random_gen (has_norm (random_gen (has_top empty))))) := sorry --non-trivial
lemma new_lemma_17133 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_17134 (h0 : ring (add_comm_semigroup (add_comm_semigroup linarith.ineq))) : is_domain (add_comm_semigroup (add_comm_semigroup linarith.ineq)) := sorry --non-trivial
lemma new_lemma_17135 (h0 : ring (mul_zero_class (semiring empty))) : is_domain (mul_zero_class (semiring empty)) := sorry --non-trivial
lemma new_lemma_17136 (h1 : group (has_lt string_imp)) : is_cyclic (has_lt string_imp) := sorry --non-trivial
lemma new_lemma_17137 (h0 : ring (non_unital_non_assoc_semiring string.iterator_imp)) : is_domain (non_unital_non_assoc_semiring string.iterator_imp) := sorry --non-trivial
lemma new_lemma_17138 (h0 : not (function.extfun Type list -> false)) : list.nodup (function.extfun_app (classical.by_contradiction' h0) (has_emptyc linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_17139 (h1 : add_group (normed_field reducibility_hints)) : is_add_cyclic (normed_field reducibility_hints) := sorry --non-trivial
lemma new_lemma_17140 (h0 : topological_space (mul_one_class linarith.ineq)) (h1 : add_group (mul_one_class linarith.ineq)) : topological_add_group (mul_one_class linarith.ineq) := sorry --non-trivial
lemma new_lemma_17141 (h0 : ring (normed_comm_ring char)) : rank_condition (normed_comm_ring char) := sorry --non-trivial
lemma new_lemma_17142 (h0 : filter (ordered_comm_ring (ordered_comm_monoid Type))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_17143 (h0 : functor.add_const (topological_space (has_add linarith.comp)) name) : @locally_compact_space.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_17144 (h0 : finset (has_Inf (ring (has_add Type)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_17145 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_nndist.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} name))  := sorry --non-trivial
lemma new_lemma_17146 (h0 : functor.add_const (uniform_space (complete_distrib_lattice linarith.comp)) Type) : @separated_space.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.add_const.run.{0 1} (uniform_space.{0} (complete_distrib_lattice.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_17147 (h0 : filter (left_cancel_monoid empty)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_17148 (h0 : ordered_add_comm_monoid (bin_tree (option (semiring empty)))) : archimedean (bin_tree (option (semiring empty))) := sorry --non-trivial
lemma new_lemma_17149 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_inter.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inter.{0} empty))  := sorry --non-trivial
lemma new_lemma_17150 (h0 : ring (linear_ordered_field (option (option unsigned)))) : is_domain (linear_ordered_field (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_17151 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (mul_zero_class.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (mul_zero_class.{0} name))  := sorry --non-trivial
lemma new_lemma_17152 (h0 : functor.add_const (topological_space (has_neg linarith.comp)) (ring Type)) : @preirreducible_space.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg.{0} linarith.comp)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_17153 (h0 : functor.add_const (function.extfun Type group) (has_Inf pos)) : @group.fg.{0} (has_zero.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) (has_Inf.{0} pos) h0) (has_zero.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_17154 (h1 : topological_space (random_gen linarith.ineq)) : totally_disconnected_space (random_gen linarith.ineq) := sorry --non-trivial
lemma new_lemma_17155 (h0 : function.extfun nat fin) : @complete_lattice.is_Sup_finite_compact.{0} (simple_graph.{0} (has_neg.{0} name)) (@matrix.vec_empty.{0} (complete_lattice.{0} (simple_graph.{0} (has_neg.{0} name))) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_17156 (h0 : uniform_space (has_lt (mul_one_class linarith.ineq))) : complete_space (has_lt (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_17157 (h0 : ring (canonically_ordered_monoid (ordered_comm_monoid pos))) : strong_rank_condition (canonically_ordered_monoid (ordered_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_17158 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (add_cancel_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_cancel_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_17159 (h0 : semiring (has_edist (option empty))) : is_noetherian_ring (has_edist (option empty)) := sorry --non-trivial
lemma new_lemma_17160 (h0 : topological_space (has_norm (random_gen (has_top (random_gen to_additive.value_type))))) (h1 : set (has_norm (random_gen (has_top (random_gen to_additive.value_type))))) : is_seq_closed h1 := sorry --non-trivial
lemma new_lemma_17161 (h0 : functor.add_const (function.extfun Type add_group) (finset Type)) : @is_add_cyclic.{0} (finset.{0} name) (@function.extfun_app.{2 1} Type add_group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type add_group.{0}) (finset.{1} Type) h0) (finset.{0} name))  := sorry --non-trivial
lemma new_lemma_17162 (h0 : functor.add_const (group (has_neg unsigned)) linarith.comp) : @normalizer_condition.{0} (has_neg.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (has_neg.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_17163 (h0 : ordered_comm_monoid (has_nndist (option (option name)))) : has_exists_mul_of_le (has_nndist (option (option name))) := sorry --non-trivial
lemma new_lemma_17164 (h0 : functor.add_const (cancel_comm_monoid_with_zero (normed_lattice_add_comm_group num)) unsigned) : @unique_factorization_monoid.{0} (normed_lattice_add_comm_group.{0} num) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (normed_lattice_add_comm_group.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_17165 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (with_bot.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_bot.{0} empty))  := sorry --non-trivial
lemma new_lemma_17166 (h0 : ring (normed_comm_ring (boolean_algebra (boolean_algebra name)))) : rank_condition (normed_comm_ring (boolean_algebra (boolean_algebra name))) := sorry --non-trivial
lemma new_lemma_17167 (h0 : topological_space (has_nndist (comm_group Type))) : locally_compact_space (has_nndist (comm_group Type)) := sorry --non-trivial
lemma new_lemma_17168 (h0 : functor.comp ring normed_comm_ring ennreal) : @strong_rank_condition.{0} (normed_comm_ring.{0} ennreal) (@functor.comp.run.{0 0 0} ring.{0} normed_comm_ring.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_17169 (h0 : not (group (distrib_lattice char) -> false)) : @group.fg.{0} (distrib_lattice.{0} char) (@classical.by_contradiction'.{1} (group.{0} (distrib_lattice.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_17170 (h0 : function.extfun Type topological_space) : @normal_space.{0} (ordered_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_17171 (h0 : topological_space (normed_comm_ring (finset environment.implicit_infer_kind))) : normal_space (normed_comm_ring (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_17172 (h0 : function.extfun Type ring) : @is_domain.{0} (with_one.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} h0 (with_one.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_17173 (h0 : topological_space (is_R_or_C num)) : totally_disconnected_space (is_R_or_C num) := sorry --non-trivial
lemma new_lemma_17174 (h1 : topological_space (mul_one_class (mul_one_class enat))) : t0_space (mul_one_class (mul_one_class enat)) := sorry --non-trivial
lemma new_lemma_17175 (h2 : add_group (semi_normed_comm_ring (random_gen char))) : is_add_cyclic (semi_normed_comm_ring (random_gen char)) := sorry --non-trivial
lemma new_lemma_17176 (h0 : topological_space (semigroup (option ennreal))) : loc_path_connected_space (semigroup (option ennreal)) := sorry --non-trivial
lemma new_lemma_17177 (h0 : not (complete_lattice (set linarith.ineq) -> false)) : complete_lattice.is_Sup_finite_compact (set linarith.ineq) := sorry --non-trivial
lemma new_lemma_17178 (h1 : topological_space (complete_semilattice_Sup to_additive.value_type)) : path_connected_space (complete_semilattice_Sup to_additive.value_type) := sorry --non-trivial
lemma new_lemma_17179 (h0 : ring (semi_normed_comm_ring (random_gen char))) : rank_condition (semi_normed_comm_ring (random_gen char)) := sorry --non-trivial
lemma new_lemma_17180 (h0 : finset (has_one unsigned)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_17181 (h0 : topological_space (generalized_boolean_algebra (has_neg (has_neg Type)))) : preconnected_space (generalized_boolean_algebra (has_neg (has_neg Type))) := sorry --non-trivial
lemma new_lemma_17182 (h1 : topological_space (semi_normed_comm_ring to_additive.value_type)) : t0_space (semi_normed_comm_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_17183 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} znum (@function.extfun_app.{2 1} Type add_group.{0} h0 znum)  := sorry --non-trivial
lemma new_lemma_17184 (h0 : set (sub_neg_monoid linarith.ineq)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_17185 (h0 : topological_space (has_to_string (ordered_ring (has_Inf name)))) : irreducible_space (has_to_string (ordered_ring (has_Inf name))) := sorry --non-trivial
lemma new_lemma_17186 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (canonically_ordered_comm_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_17187 (h0 : fin has_zero.zero) : @sequential_space.{0} (boolean_algebra.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (boolean_algebra.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_17188 (h0 : add_group (topological_space linarith.comp_source)) : is_add_cyclic (topological_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_17189 (h0 : ring (complete_semilattice_Sup to_additive.value_type)) : is_domain (complete_semilattice_Sup to_additive.value_type) := sorry --non-trivial
lemma new_lemma_17190 (h0 : functor.add_const (monoid (has_zero linarith.comp)) linarith.comp) : @monoid.fg.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (monoid.{0} (has_zero.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_17191 (h0 : monoid (comm_semigroup (sub_neg_monoid (has_bot (has_bot pos))))) : monoid.fg (comm_semigroup (sub_neg_monoid (has_bot (has_bot pos)))) := sorry --non-trivial
lemma new_lemma_17192 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_17193 (h0 : uniform_space (cancel_monoid empty)) : separated_space (cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_17194 (h0 : functor.add_const (topological_space (has_to_string environment.implicit_infer_kind)) Type) : @sequential_space.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (has_to_string.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_17195 (h0 : complete_lattice unsigned) : is_atomistic unsigned := sorry --non-trivial
lemma new_lemma_17196 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (as_linear_order.{0} empty) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (as_linear_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_17197 (h0 : topological_space (option (option (mul_zero_class (option (option congr_arg_kind)))))) : locally_compact_space (option (option (mul_zero_class (option (option congr_arg_kind))))) := sorry --non-trivial
lemma new_lemma_17198 (h0 : functor.add_const (finset (ring name)) (has_to_string Type)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_17199 (h0 : set (mul_one_class ereal -> enat)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_17200 (h0 : topological_space (has_nndist (add_comm_monoid (right_cancel_semigroup name)))) : irreducible_space (has_nndist (add_comm_monoid (right_cancel_semigroup name))) := sorry --non-trivial
lemma new_lemma_17201 (h0 : ring (has_compl (random_gen fun_info))) : rank_condition (has_compl (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_17202 (h0 : complete_lattice (has_ssubset (has_nnnorm (has_nnnorm fun_info)))) : is_compactly_generated (has_ssubset (has_nnnorm (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_17203 (h0 : measurable_space real) (h1 : measure_theory.measure real) (h2 : not (measure_theory.measure real -> false)) (h3 : Prop) : xor (measure_theory.measure.absolutely_continuous h1 (classical.by_contradiction' h2)) h3 := sorry --non-trivial
lemma new_lemma_17204 (h0 : ring (canonically_ordered_monoid empty)) : is_domain (canonically_ordered_monoid empty) := sorry --non-trivial
lemma new_lemma_17205 (h0 : function.extfun ((finset Type -> Prop) -> Prop) (function.extfun (finset Type -> Prop))) : @strong_rank_condition.{0} linarith.comp_source (@finset.pi.empty.{1 0} Type ring.{0} linarith.comp_source (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type → Prop) (function.extfun.{2 0} (finset.{1} Type)) (@function.extfun_app.{2 0} ((finset.{1} Type → Prop) → Prop) (function.extfun.{2 0} (finset.{1} Type → Prop)) h0 (function.extfun.{2 0} (finset.{1} Type))) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) linarith.comp_source)) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_17206 (h0 : ring (pseudo_metric_space name)) : rank_condition (pseudo_metric_space name) := sorry --non-trivial
lemma new_lemma_17207 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (with_one.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 uniform_space.{0}) (with_one.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_17208 (h0 : uniform_space (normed_comm_ring ennreal)) : complete_space (normed_comm_ring ennreal) := sorry --non-trivial
lemma new_lemma_17209 (h1 : has_lt (nondiscrete_normed_field reducibility_hints)) : no_max_order (nondiscrete_normed_field reducibility_hints) := sorry --non-trivial
lemma new_lemma_17210 (h0 : uniform_space (normed_lattice_add_comm_group (has_Inf pos))) : separated_space (normed_lattice_add_comm_group (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_17211 (h0 : functor.add_const (uniform_space auto.case_option) (option empty)) : @complete_space.{0} auto.case_option (@functor.add_const.run.{0 0} (uniform_space.{0} auto.case_option) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_17212 (h1 : has_mul (random_gen char)) (h2 : not (group (con (random_gen char)) -> false)) : @is_cyclic.{0} (@con.{0} (random_gen.{0} char) h1) (@classical.by_contradiction'.{1} (group.{0} (@con.{0} (random_gen.{0} char) h1)) h2)  := sorry --non-trivial
lemma new_lemma_17213 (h0 : functor.add_const (function.extfun (Type 1) semiring) linarith.comp) : @is_noetherian_ring.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) semiring.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) semiring.{1}) linarith.comp h0) (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_17214 (h0 : fin has_zero.zero) : @group.fg.{0} (ordered_comm_ring.{0} pos) (@matrix.vec_empty.{0} (group.{0} (ordered_comm_ring.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_17215 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (with_bot string_imp)) := sorry --non-trivial
lemma new_lemma_17216 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (has_nndist.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_nndist.{0} num))  := sorry --non-trivial
lemma new_lemma_17217 (h0 : topological_space (sub_neg_monoid (has_Inf (has_add pos)))) : irreducible_space (sub_neg_monoid (has_Inf (has_add pos))) := sorry --non-trivial
lemma new_lemma_17218 (h0 : topological_space (canonically_ordered_comm_semiring (semigroup (has_add Type)))) : locally_compact_space (canonically_ordered_comm_semiring (semigroup (has_add Type))) := sorry --non-trivial
lemma new_lemma_17219 (h0 : complete_lattice (normed_field to_additive.value_type)) : complete_lattice.is_Sup_finite_compact (normed_field to_additive.value_type) := sorry --non-trivial
lemma new_lemma_17220 (h0 : functor.add_const (topological_space (ordered_comm_ring linarith.comp)) (has_neg Type)) : @loc_path_connected_space.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (ordered_comm_ring.{0} linarith.comp)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_17221 (h0 : empty -> Prop) : zzz_forall h0 := sorry --non-trivial
lemma new_lemma_17222 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 fun_info) := sorry --non-trivial
lemma new_lemma_17223 (h0 : group (with_bot (has_inv to_additive.value_type))) : normalizer_condition (with_bot (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_17224 (h0 : functor.add_const (list (semigroup unsigned)) Type) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_17225 (h0 : functor.add_const (topological_space (has_nndist environment.implicit_infer_kind)) environment.implicit_infer_kind) : @path_connected_space.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_17226 (h0 : functor.add_const (finset (comm_group environment.implicit_infer_kind)) linarith.comp) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_17227 (h0 : add_group string.iterator) (h1 : add_subgroup string.iterator) : add_subgroup.characteristic h1 := sorry --non-trivial
lemma new_lemma_17228 (h0 : add_group (comm_semigroup (comm_semigroup (complete_distrib_lattice name)))) : is_add_cyclic (comm_semigroup (comm_semigroup (complete_distrib_lattice name))) := sorry --non-trivial
lemma new_lemma_17229 (h0 : topological_space (finset (finset (finset pos)))) : t1_space (finset (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_17230 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (ordered_comm_group.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_17231 (h0 : uniform_space.core (has_ssubset (random_gen to_additive.value_type))) : @locally_compact_space.{0} (has_ssubset.{0} (random_gen.{0} to_additive.value_type)) (@uniform_space.core.to_topological_space.{0} (has_ssubset.{0} (random_gen.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_17232 (h0 : list (linear_ordered_comm_group (option ennreal))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_17233 (h0 : fin has_zero.zero) : @totally_disconnected_space.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_17234 (h2 : uniform_space (has_lt (metric_space to_additive.value_type))) : complete_space (has_lt (metric_space to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_17235 (h0 : functor.add_const (add_group (boolean_algebra Type)) linarith.comp) : @is_add_cyclic.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (add_group.{1} (boolean_algebra.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_17236 (h0 : functor.add_const (ordered_comm_monoid (cancel_monoid pos)) (has_add environment.implicit_infer_kind)) : @has_exists_mul_of_le.{0} (cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (cancel_monoid.{0} pos)) (has_add.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_17237 (h0 : ring (linear_ordered_semiring (has_top (has_top congr_arg_kind)))) : rank_condition (linear_ordered_semiring (has_top (has_top congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_17238 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_union.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_union.{0} num))  := sorry --non-trivial
lemma new_lemma_17239 (h2 : ring (simple_graph string_imp)) : strong_rank_condition (simple_graph string_imp) := sorry --non-trivial
lemma new_lemma_17240 (h0 : uniform_space (left_cancel_monoid (semiring (semiring (semiring num))))) : separated_space (left_cancel_monoid (semiring (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_17241 (h0 : functor.add_const (topological_space (boolean_algebra.core name)) linarith.comp) : @preconnected_space.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_17242 (h0 : topological_space (normed_group num)) : discrete_topology (normed_group num) := sorry --non-trivial
lemma new_lemma_17243 (h0 : functor.add_const (uniform_space (boolean_algebra.core name)) pos) : @complete_space.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (boolean_algebra.core.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_17244 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (group_with_zero.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (group_with_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_17245 (h0 : complete_lattice (mul_zero_class empty)) : complete_lattice.is_Sup_finite_compact (mul_zero_class empty) := sorry --non-trivial
lemma new_lemma_17246 (h0 : filter (cancel_monoid ennreal)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_17247 (h0 : finset (add_cancel_monoid (has_neg Type))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_17248 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (normed_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type monoid.{0} h0 (normed_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_17249 (h0 : topological_space (boolean_algebra.core (has_nndist environment.implicit_infer_kind))) : locally_compact_space (boolean_algebra.core (has_nndist environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_17250 (h0 : complete_lattice (canonically_linear_ordered_monoid congr_arg_kind)) : is_atomistic (canonically_linear_ordered_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_17251 (h0 : functor.add_const (ring (comm_group unsigned)) linarith.comp) : @strong_rank_condition.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (comm_group.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_17252 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (canonically_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (canonically_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_17253 (h0 : topological_space (has_star congr_arg_kind)) : discrete_topology (has_star congr_arg_kind) := sorry --non-trivial
lemma new_lemma_17254 (h0 : functor.add_const (function.extfun Type uniform_space) Type) : @separated_space.{0} (has_neg_part.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type uniform_space.{0}) Type h0) (has_neg_part.{0} name))  := sorry --non-trivial
lemma new_lemma_17255 (h1 : has_mem.mem (with_one linarith.comp_source) has_emptyc.emptyc) : @totally_separated_space.{0} (with_one.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_one.{0} linarith.comp_source) h1)  := sorry --non-trivial
lemma new_lemma_17256 (h0 : topological_space (random_gen (has_top linarith.comp))) : discrete_topology (random_gen (has_top linarith.comp)) := sorry --non-trivial
lemma new_lemma_17257 (h0 : ring (has_to_string (has_Inf (has_neg (has_Inf (has_Inf Type)))))) : rank_condition (has_to_string (has_Inf (has_neg (has_Inf (has_Inf Type))))) := sorry --non-trivial
lemma new_lemma_17258 (h0 : complete_lattice (has_append (metric_space linarith.comp_source))) : complete_lattice.is_Sup_finite_compact (has_append (metric_space linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_17259 (h0 : functor.add_const (list (add_comm_monoid linarith.comp)) linarith.comp) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_17260 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem uniform_space)) : @complete_space.{0} fun_info (@function.extfun_app.{2 1} Type uniform_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) uniform_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) uniform_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) fun_info)  := sorry --non-trivial
lemma new_lemma_17261 (h2 : topological_space (measurable_space to_additive.value_type)) : locally_compact_space (measurable_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_17262 (h0 : not (complete_lattice (fintype to_additive.value_type) -> false)) : @is_compactly_generated.{0} (fintype.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (complete_lattice.{0} (fintype.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_17263 (h0 : functor.add_const (topological_space (has_zero linarith.comp)) pos) : @path_connected_space.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_17264 (h0 : ring (has_zero linarith.comp)) : rank_condition (has_zero linarith.comp) := sorry --non-trivial
lemma new_lemma_17265 (h0 : function.extfun Type complete_lattice) : is_compactly_generated (measurable_space fun_info) := sorry --non-trivial
lemma new_lemma_17266 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (has_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_17267 (h0 : functor.add_const (function.extfun (Type 1) topological_space) (semigroup pos)) : @totally_disconnected_space.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) (semigroup.{0} pos) h0) (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_17268 (h0 : complete_lattice (has_zero Type)) : is_atomistic (has_zero Type) := sorry --non-trivial
lemma new_lemma_17269 (h0 : complete_lattice (mul_one_class linarith.ineq)) : is_compactly_generated (mul_one_class linarith.ineq) := sorry --non-trivial
lemma new_lemma_17270 (h0 : functor.add_const (add_group (ordered_comm_monoid Type)) Type) : @is_add_cyclic.{1} (ordered_comm_monoid.{1} Type) (@functor.add_const.run.{1 1} (add_group.{1} (ordered_comm_monoid.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_17271 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (comm_semigroup.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_semigroup.{0} real))  := sorry --non-trivial
lemma new_lemma_17272 (h0 : topological_space (has_dist unsigned)) : totally_separated_space (has_dist unsigned) := sorry --non-trivial
lemma new_lemma_17273 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_17274 (h0 : topological_space (mul_zero_class (has_add ennreal))) : totally_disconnected_space (mul_zero_class (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_17275 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (generalized_boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (generalized_boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_17276 (h0 : topological_space (left_cancel_monoid congr_arg_kind)) : normal_space (left_cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_17277 (h0 : group (semigroup (has_zero (has_to_string linarith.comp)))) : is_simple_group (semigroup (has_zero (has_to_string linarith.comp))) := sorry --non-trivial
lemma new_lemma_17278 (h0 : functor.add_const (function.extfun Type ring) pos) : @rank_condition.{0} (has_add.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) pos h0) (has_add.{0} name))  := sorry --non-trivial
lemma new_lemma_17279 (h1 : group (with_one string_imp)) : is_cyclic (with_one string_imp) := sorry --non-trivial
lemma new_lemma_17280 (h0 : uniform_space (semigroup (option pos))) : complete_space (semigroup (option pos)) := sorry --non-trivial
lemma new_lemma_17281 (h0 : topological_space (cancel_monoid (finset (has_nndist Type)))) : t1_space (cancel_monoid (finset (has_nndist Type))) := sorry --non-trivial
lemma new_lemma_17282 (h0 : Type -> has_nnnorm fun_info -> topological_space (add_left_cancel_monoid fun_info)) (h1 : prod Type (has_nnnorm fun_info)) : @t0_space.{0} (add_left_cancel_monoid.{0} fun_info) (@function.uncurry.{1 0 0} Type (has_nnnorm.{0} fun_info) (topological_space.{0} (add_left_cancel_monoid.{0} fun_info)) h0 h1)  := sorry --non-trivial
lemma new_lemma_17283 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (non_assoc_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (non_assoc_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_17284 (h0 : functor.comp ring has_neg_part name) : @strong_rank_condition.{0} (has_neg_part.{0} name) (@functor.comp.run.{0 0 0} ring.{0} has_neg_part.{0} name h0)  := sorry --non-trivial
lemma new_lemma_17285 (h0 : group (has_to_string ennreal)) : is_simple_group (has_to_string ennreal) := sorry --non-trivial
lemma new_lemma_17286 (h0 : functor.add_const (semiring (is_R_or_C empty)) empty) : @is_noetherian_ring.{0} (is_R_or_C.{0} empty) (@functor.add_const.run.{0 0} (semiring.{0} (is_R_or_C.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_17287 (h0 : function.extfun Type (functor.add_const (group (add_right_cancel_monoid congr_arg_kind)))) : @group.fg.{0} (add_right_cancel_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (group.{0} (add_right_cancel_monoid.{0} congr_arg_kind)) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (group.{0} (add_right_cancel_monoid.{0} congr_arg_kind))) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_17288 (h2 : complete_lattice (random_gen string_imp)) : is_compactly_generated (random_gen string_imp) := sorry --non-trivial
lemma new_lemma_17289 (h0 : ring (has_nnnorm enat)) : strong_rank_condition (has_nnnorm enat) := sorry --non-trivial
lemma new_lemma_17290 (h0 : list (boolean_algebra.core (has_add environment.implicit_infer_kind))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_17291 (h0 : topological_space (has_bot (semigroup name))) : loc_path_connected_space (has_bot (semigroup name)) := sorry --non-trivial
lemma new_lemma_17292 (h0 : topological_space (has_sub congr_arg_kind)) : locally_compact_space (has_sub congr_arg_kind) := sorry --non-trivial
lemma new_lemma_17293 (h0 : measurable_space (uniform_space string_imp)) (h1 : filter (uniform_space string_imp)) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_17294 (h0 : functor.add_const (monoid (has_zero linarith.comp)) Type) : @monoid.fg.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 1} (monoid.{0} (has_zero.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_17295 (h0 : uniform_space (has_emptyc (random_gen (random_gen (has_inv linarith.comp_source))))) : complete_space (has_emptyc (random_gen (random_gen (has_inv linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_17296 (h0 : ring Type) : list.nodup (list.ret h0) := sorry --non-trivial
lemma new_lemma_17297 (h0 : ring (denumerable (has_nnnorm (random_gen char)))) : strong_rank_condition (denumerable (has_nnnorm (random_gen char))) := sorry --non-trivial
lemma new_lemma_17298 (h0 : group (semigroup (has_neg Type))) : normalizer_condition (semigroup (has_neg Type)) := sorry --non-trivial
lemma new_lemma_17299 (h0 : add_comm_monoid (cancel_monoid ennreal) -> add_comm_monoid (cancel_monoid ennreal) -> Prop) : reflexive h0 := sorry --non-trivial
lemma new_lemma_17300 (h0 : functor.add_const (ordered_comm_monoid (sub_neg_monoid linarith.comp)) (has_Inf (has_add name))) : @has_exists_mul_of_le.{0} (sub_neg_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (sub_neg_monoid.{0} linarith.comp)) (has_Inf.{0} (has_add.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_17301 (h0 : functor.add_const (group (add_cancel_monoid Type)) (semigroup linarith.comp)) : @is_simple_group.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (add_cancel_monoid.{1} Type)) (semigroup.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_17302 (h0 : monoid (left_cancel_semigroup (ordered_cancel_comm_monoid unsigned))) : monoid.fg (left_cancel_semigroup (ordered_cancel_comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_17303 (h0 : measurable_space (mul_one_class linarith.ineq)) (h1 : filter (mul_one_class linarith.ineq)) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_17304 (h0 : functor.add_const (topological_space (has_neg pos)) linarith.comp) : @normal_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_17305 (h0 : topological_space (with_one (has_norm empty))) : t0_space (with_one (has_norm empty)) := sorry --non-trivial
lemma new_lemma_17306 (h1 : not (topological_space (measurable_space linarith.comp) -> false)) : @t0_space.{0} (measurable_space.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (measurable_space.{0} linarith.comp)) h1)  := sorry --non-trivial
lemma new_lemma_17307 (h0 : topological_space (add_right_cancel_monoid congr_arg_kind)) : irreducible_space (add_right_cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_17308 (h0 : group (free_add_monoid (semiring empty))) : group.fg (free_add_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_17309 (h0 : topological_space (ring (comm_group name))) : locally_compact_space (ring (comm_group name)) := sorry --non-trivial
lemma new_lemma_17310 (h0 : topological_space (random_gen (semiring unsigned))) : totally_disconnected_space (random_gen (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_17311 (h0 : topological_space (has_nndist (has_nndist Type))) : loc_path_connected_space (has_nndist (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_17312 (h0 : functor.add_const (group (has_zero linarith.comp)) linarith.comp) : @normalizer_condition.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (has_zero.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_17313 (h0 : set (add_comm_semigroup (add_comm_semigroup enat) -> add_comm_semigroup enat)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_17314 (h0 : not (group (has_star congr_arg_kind) -> false)) : @group.fg.{0} (has_star.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (group.{0} (has_star.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_17315 (h0 : add_monoid (has_pos_part (ordered_comm_monoid (ordered_comm_monoid (ordered_comm_monoid Type))))) : add_monoid.fg (has_pos_part (ordered_comm_monoid (ordered_comm_monoid (ordered_comm_monoid Type)))) := sorry --non-trivial
lemma new_lemma_17316 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (boolean_algebra.core.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.core.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_17317 (h0 : topological_space (boolean_algebra (finset (has_pos_part linarith.comp)))) : topological_space.separable_space (boolean_algebra (finset (has_pos_part linarith.comp))) := sorry --non-trivial
lemma new_lemma_17318 (h0 : complete_lattice (measurable_space (has_norm num))) : is_compactly_generated (measurable_space (has_norm num)) := sorry --non-trivial
lemma new_lemma_17319 (h0 : complete_lattice (has_neg_part pos)) : is_compactly_generated (has_neg_part pos) := sorry --non-trivial
lemma new_lemma_17320 (h0 : topological_space (denumerable (has_vadd reducibility_hints char))) : path_connected_space (denumerable (has_vadd reducibility_hints char)) := sorry --non-trivial
lemma new_lemma_17321 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem complete_lattice)) : @is_compactly_generated.{0} (linear_ordered_semiring.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) complete_lattice.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (linear_ordered_semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_17322 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (comm_group.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_17323 (h0 : topological_space (semigroup (comm_group unsigned))) : regular_space (semigroup (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_17324 (h0 : not (topological_space (has_emptyc linarith.comp) -> false)) : @t0_space.{0} (has_emptyc.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (has_emptyc.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_17325 (h0 : topological_space (normed_comm_ring (has_pos_part pos))) : irreducible_space (normed_comm_ring (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_17326 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @sequential_space.{0} (simple_graph.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (simple_graph.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_17327 (h0 : monoid (linear_ordered_comm_group (option unsigned))) : monoid.fg (linear_ordered_comm_group (option unsigned)) := sorry --non-trivial
lemma new_lemma_17328 (h0 : function.extfun Type topological_space) : @t1_space.{0} (boolean_algebra.core.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} name))  := sorry --non-trivial
lemma new_lemma_17329 (h0 : function.extfun (Type -> Type) (function.extfun Type) -> Prop) (h1 : function.extfun (function.extfun (Type -> Type) (function.extfun Type) -> Prop) Exists) : @unique_factorization_monoid.{0} (has_to_string.{0} num) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.some.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0 (@function.extfun_app.{2 0} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type) → Prop) (@Exists.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type))) h1 (λ (x : function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)), h0 x))) cancel_comm_monoid_with_zero.{0}) (has_to_string.{0} num))  := sorry --non-trivial
lemma new_lemma_17330 (h0 : ring (has_pos_part (has_pos_part (has_add (has_add pos))))) : is_domain (has_pos_part (has_pos_part (has_add (has_add pos)))) := sorry --non-trivial
lemma new_lemma_17331 (h1 h2 : multiset ordering) : multiset.subset h1 h2 := sorry --non-trivial
lemma new_lemma_17332 (h0 : ring (has_compl (random_gen (random_gen fun_info)))) : strong_rank_condition (has_compl (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_17333 (h0 : ordered_comm_monoid (linear_ordered_field (option unsigned))) : has_exists_mul_of_le (linear_ordered_field (option unsigned)) := sorry --non-trivial
lemma new_lemma_17334 (h0 : complete_lattice (normed_group (has_inv linarith.ineq))) : complete_lattice.is_Sup_finite_compact (normed_group (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_17335 (h0 : topological_space (canonically_ordered_monoid (has_pos_part (has_nndist linarith.comp)))) : irreducible_space (canonically_ordered_monoid (has_pos_part (has_nndist linarith.comp))) := sorry --non-trivial
lemma new_lemma_17336 (h0 : topological_space (complete_distrib_lattice (sub_neg_monoid name))) : preirreducible_space (complete_distrib_lattice (sub_neg_monoid name)) := sorry --non-trivial
lemma new_lemma_17337 (h0 : not (function.extfun Type semiring -> false)) : @is_noetherian_ring.{0} (option.{0} num) (@function.extfun_app.{2 1} Type semiring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type semiring.{0}) h0) (option.{0} num))  := sorry --non-trivial
lemma new_lemma_17338 (h0 : topological_space (semiring (semiring empty))) : t1_space (semiring (semiring empty)) := sorry --non-trivial
lemma new_lemma_17339 (h0 : functor.add_const (function.extfun Type group) (ring pos)) : @normalizer_condition.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) (ring.{0} pos) h0) (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_17340 (h0 : functor.add_const (ring pos) (has_Inf pos)) : @strong_rank_condition.{0} pos (@functor.add_const.run.{0 0} (ring.{0} pos) (has_Inf.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_17341 (h0 : functor.comp (prod (pseudo_metric_space pos)) pseudo_metric_space pos) : id_rel (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_17342 (h0 : topological_space (add_cancel_monoid (has_pos_part linarith.comp))) : preconnected_space (add_cancel_monoid (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_17343 (h0 : not (add_group num -> false)) : @is_add_cyclic.{0} num (@classical.by_contradiction'.{1} (add_group.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_17344 (h0 : list (boolean_algebra.core unsigned)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_17345 (h0 : functor.add_const (topological_space (boolean_algebra unsigned)) name) : @locally_compact_space.{0} (boolean_algebra.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_17346 (h0 : topological_space (boolean_algebra (ring (has_pos_part pos)))) : discrete_topology (boolean_algebra (ring (has_pos_part pos))) := sorry --non-trivial
lemma new_lemma_17347 (h0 : topological_space (ordered_comm_monoid (has_bot (sub_neg_monoid (has_bot (has_pos_part real)))))) : path_connected_space (ordered_comm_monoid (has_bot (sub_neg_monoid (has_bot (has_pos_part real))))) := sorry --non-trivial
lemma new_lemma_17348 (h0 : ring (linear_order (semiring empty))) : strong_rank_condition (linear_order (semiring empty)) := sorry --non-trivial
lemma new_lemma_17349 (h0 : function.extfun Type topological_space) : @normal_space.{0} (pseudo_metric_space.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (pseudo_metric_space.{0} pos))  := sorry --non-trivial
lemma new_lemma_17350 (h0 : not (topological_space (distrib linarith.comp_source) -> false)) : @totally_disconnected_space.{0} (distrib.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (distrib.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_17351 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (has_neg.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (has_neg.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_17352 (h0 : ring (measurable_space linarith.comp_source)) : is_principal_ideal_ring (measurable_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_17353 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (has_one.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (has_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_17354 (h0 : functor.add_const (function.extfun Type group) Type) : @normalizer_condition.{0} (has_zero.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type group.{0}) Type h0) (has_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_17355 (h0 : not (ring (distrib_lattice linarith.comp_source) -> false)) : @rank_condition.{0} (distrib_lattice.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (distrib_lattice.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_17356 (h0 : topological_space (boolean_algebra.core ennreal)) : irreducible_space (boolean_algebra.core ennreal) := sorry --non-trivial
lemma new_lemma_17357 (h0 : function.extfun Type topological_space) : @t0_space.{0} (generalized_boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (generalized_boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_17358 (h0 : topological_space (has_norm (has_inv to_additive.value_type))) : t0_space (has_norm (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_17359 (h0 : not (topological_space (add_group unsigned) -> false)) : @totally_separated_space.{0} (add_group.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (add_group.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_17360 (h0 : ring (topological_space (has_ssubset (random_gen string.iterator_imp)))) : is_domain (topological_space (has_ssubset (random_gen string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_17361 (h0 : finset (has_to_string num)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_17362 (h2 : add_group (distrib_lattice to_additive.value_type)) : is_add_cyclic (distrib_lattice to_additive.value_type) := sorry --non-trivial
lemma new_lemma_17363 (h0 : group (has_to_string (ring Type))) : is_simple_group (has_to_string (ring Type)) := sorry --non-trivial
lemma new_lemma_17364 (h0 : functor.add_const (filter (has_zero environment.implicit_infer_kind)) Type) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_17365 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} (has_union.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (has_union.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_17366 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @complete_space.{0} (semiring.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) uniform_space.{0}) (semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_17367 (h1 : not (complete_lattice (random_gen to_additive.value_type) -> false)) : @is_atomistic.{0} (random_gen.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (complete_lattice.{0} (random_gen.{0} to_additive.value_type)) h1)  := sorry --non-trivial
lemma new_lemma_17368 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} real (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) real)  := sorry --non-trivial
lemma new_lemma_17369 (h0 : ring (random_gen (has_nnnorm (has_nnnorm char)))) : rank_condition (random_gen (has_nnnorm (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_17370 (h0 : topological_space (add_cancel_monoid (boolean_algebra.core (add_cancel_monoid Type)))) : sequential_space (add_cancel_monoid (boolean_algebra.core (add_cancel_monoid Type))) := sorry --non-trivial
lemma new_lemma_17371 (h0 : not (uniform_space (has_one empty) -> false)) : @separated_space.{0} (has_one.{0} empty) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_one.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_17372 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (add_cancel_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_17373 (h0 : functor.add_const (topological_space (add_cancel_monoid Type)) name) : @irreducible_space.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_cancel_monoid.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_17374 (h0 : functor.add_const (add_monoid (has_neg_part name)) (boolean_algebra name)) : @add_monoid.fg.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_neg_part.{0} name)) (boolean_algebra.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_17375 (h0 : functor.add_const (topological_space linarith.comp) Type) : @totally_separated_space.{0} linarith.comp (@functor.add_const.run.{0 1} (topological_space.{0} linarith.comp) Type h0)  := sorry --non-trivial
lemma new_lemma_17376 (h0 : ring (normed_lattice_add_comm_group (has_add real))) : strong_rank_condition (normed_lattice_add_comm_group (has_add real)) := sorry --non-trivial
lemma new_lemma_17377 (h0 : ulower pnat) (h1 : fin has_zero.zero) : pnat.coprime (ulower.up h0) (id (matrix.vec_empty h1)) := sorry --non-trivial
lemma new_lemma_17378 (h0 : group (normed_lattice_add_comm_group (has_Inf (has_Inf real)))) : is_simple_group (normed_lattice_add_comm_group (has_Inf (has_Inf real))) := sorry --non-trivial
lemma new_lemma_17379 (h0 : functor.add_const (topological_space (sub_neg_monoid linarith.comp)) (has_neg (has_Inf (has_neg pos)))) : @preconnected_space.{0} (sub_neg_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (sub_neg_monoid.{0} linarith.comp)) (has_neg.{0} (has_Inf.{0} (has_neg.{0} pos))) h0)  := sorry --non-trivial
lemma new_lemma_17380 (h0 : topological_space (semigroup (has_to_string (has_neg_part (has_add (has_to_string ennreal)))))) : discrete_topology (semigroup (has_to_string (has_neg_part (has_add (has_to_string ennreal))))) := sorry --non-trivial
lemma new_lemma_17381 (h0 : ordered_add_comm_monoid (comm_group (has_neg Type))) : archimedean (comm_group (has_neg Type)) := sorry --non-trivial
lemma new_lemma_17382 (h0 : functor.add_const (filter (monoid congr_arg_kind)) congr_arg_kind) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_17383 (h0 : functor.add_const (function.extfun (Type 1) filter) name) : countable_Inter_filter (function.extfun_app (functor.add_const.run h0) (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_17384 (h1 : ring (non_unital_non_assoc_semiring linarith.comp_source)) : strong_rank_condition (non_unital_non_assoc_semiring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_17385 (h1 : group (complete_semilattice_Sup num)) : group.fg (complete_semilattice_Sup num) := sorry --non-trivial
lemma new_lemma_17386 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_17387 (h0 : add_monoid (linear_ordered_semiring (has_norm empty))) : add_monoid.fg (linear_ordered_semiring (has_norm empty)) := sorry --non-trivial
lemma new_lemma_17388 (h0 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} (random_gen.{0} fun_info) (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h0) (random_gen.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_17389 (h1 : topological_space (has_add to_additive.value_type)) : t0_space (has_add to_additive.value_type) := sorry --non-trivial
lemma new_lemma_17390 (h0 : functor.add_const (functor.add_const (topological_space name) num) unsigned) : @totally_separated_space.{0} name (@functor.add_const.run.{0 0} (topological_space.{0} name) num (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (topological_space.{0} name) num) unsigned h0))  := sorry --non-trivial
lemma new_lemma_17391 (h0 : ordered_add_comm_monoid (finset (finset linarith.comp))) : archimedean (finset (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_17392 (h0 : fin has_zero.zero) : @regular_space.{1} (canonically_linear_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (canonically_linear_ordered_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_17393 (h0 : functor.add_const (finset (is_R_or_C unsigned)) num) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_17394 (h0 : not (group (id num) -> false)) : @normalizer_condition.{0} (@id.{2} Type num) (@classical.by_contradiction'.{1} (group.{0} (@id.{2} Type num)) h0)  := sorry --non-trivial
lemma new_lemma_17395 (h0 : uniform_space (normed_lattice_add_comm_group (has_Inf (has_Inf Type)))) : separated_space (normed_lattice_add_comm_group (has_Inf (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_17396 (h0 : function.extfun nat fin) : @loc_path_connected_space.{1} (has_bot.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (has_bot.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_17397 (h1 : topological_space (normed_group (random_gen string_imp))) : totally_disconnected_space (normed_group (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_17398 (h0 : functor.add_const (group (generalized_boolean_algebra linarith.comp)) (has_neg name)) : @is_cyclic.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (generalized_boolean_algebra.{0} linarith.comp)) (has_neg.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_17399 (h1 : has_mem.mem (linear_ordered_add_comm_group (with_bot string_imp)) has_zero.zero) : @is_atomistic.{0} (linear_ordered_add_comm_group.{0} (with_bot.{0} string_imp)) (@multiset.pi.empty.{1 0} Type complete_lattice.{0} (linear_ordered_add_comm_group.{0} (with_bot.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_17400 (h0 : topological_space (comm_semigroup (sub_neg_monoid real))) : regular_space (comm_semigroup (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_17401 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_17402 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (linear_ordered_comm_group.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (linear_ordered_comm_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_17403 (h0 : functor.add_const (monoid (semigroup pos)) (has_neg pos)) : @monoid.fg.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (monoid.{0} (semigroup.{0} pos)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_17404 (h0 : not (ring (has_le linarith.ineq) -> false)) : @strong_rank_condition.{0} (has_le.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (has_le.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_17405 (h0 : topological_space (ordered_comm_group (option unsigned))) : t0_space (ordered_comm_group (option unsigned)) := sorry --non-trivial
lemma new_lemma_17406 (h0 : nat) (h1 : fin (nat.succ h0) -> fin has_zero.zero) (h2 : fin h0) : @ulower.up.{0} Prop encodable.Prop (@matrix.vec_empty.{0} (@ulower.{0} Prop encodable.Prop) (@id.{1} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@id.{1} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_tail.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0 h1 h2))))  := sorry --non-trivial
lemma new_lemma_17407 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (finset.{0} real) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (finset.{0} real))  := sorry --non-trivial
lemma new_lemma_17408 (h0 : functor.add_const (list (complete_distrib_lattice name)) pos) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_17409 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (ordered_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (ordered_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_17410 (h0 : cancel_comm_monoid_with_zero (has_to_string (boolean_algebra Type))) : unique_factorization_monoid (has_to_string (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_17411 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (canonically_ordered_comm_semiring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_ordered_comm_semiring.{0} name))  := sorry --non-trivial
lemma new_lemma_17412 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} fun_info (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 fun_info)  := sorry --non-trivial
lemma new_lemma_17413 (h0 : function.extfun Type (functor.add_const Prop)) : functor.add_const.run (function.extfun_app h0 name) := sorry --non-trivial
lemma new_lemma_17414 (h0 : functor.add_const (list (has_Sup congr_arg_kind)) empty) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_17415 (h0 : functor.add_const (topological_space (has_to_string ennreal)) (option (option (option (option (option ennreal)))))) : @loc_path_connected_space.{0} (has_to_string.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} ennreal)) (option.{0} (option.{0} (option.{0} (option.{0} (option.{0} ennreal))))) h0)  := sorry --non-trivial
lemma new_lemma_17416 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (preorder.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (preorder.{0} empty))  := sorry --non-trivial
lemma new_lemma_17417 (h0 : functor.add_const (filter (complete_distrib_lattice name)) environment.implicit_infer_kind) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_17418 (h0 : functor.add_const (uniform_space (has_to_string environment.implicit_infer_kind)) name) : @separated_space.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_to_string.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_17419 (h0 : group (simple_graph (has_add pos))) : normalizer_condition (simple_graph (has_add pos)) := sorry --non-trivial
lemma new_lemma_17420 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (canonically_ordered_add_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_add_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_17421 (h0 : ordered_comm_monoid (sub_neg_monoid linarith.comp)) : has_exists_mul_of_le (sub_neg_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_17422 (h0 : topological_space (canonically_ordered_monoid (has_Inf (has_Inf pos)))) : topological_space.separable_space (canonically_ordered_monoid (has_Inf (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_17423 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (measure_theory.measure_space.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (measure_theory.measure_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_17424 (h0 : function.extfun Type (functor.add_const Prop)) : functor.add_const.run (function.extfun_app h0 (has_union unsigned)) := sorry --non-trivial
lemma new_lemma_17425 (h0 : not (topological_space (left_cancel_semigroup congr_arg_kind) -> false)) : @t1_space.{0} (left_cancel_semigroup.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (left_cancel_semigroup.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_17426 (h0 : topological_space (random_gen (has_norm (semiring linarith.comp)))) : discrete_topology (random_gen (has_norm (semiring linarith.comp))) := sorry --non-trivial
lemma new_lemma_17427 (h1 : has_lt (has_ssubset fun_info)) : no_max_order (has_ssubset fun_info) := sorry --non-trivial
lemma new_lemma_17428 (h0 h1 : multiset (nondiscrete_normed_field (add_comm_semigroup enat))) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_17429 (h0 : ring (has_neg congr_arg_kind)) : is_domain (has_neg congr_arg_kind) := sorry --non-trivial
lemma new_lemma_17430 (h0 : fin has_zero.zero) : @has_exists_mul_of_le.{0} (complete_distrib_lattice.{0} real) (@matrix.vec_empty.{0} (ordered_comm_monoid.{0} (complete_distrib_lattice.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_17431 (h0 : ring (div_inv_monoid (random_gen (comm_ring to_additive.value_type)))) : strong_rank_condition (div_inv_monoid (random_gen (comm_ring to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_17432 (h0 : group (comm_group (option ennreal))) : is_simple_group (comm_group (option ennreal)) := sorry --non-trivial
lemma new_lemma_17433 (h0 : linarith.ineq -> Prop) : @infi.{0 1} Prop (@conditionally_complete_lattice.to_has_Inf.{0} Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice)) linarith.ineq h0  := sorry --non-trivial
lemma new_lemma_17434 (h0 : group (canonically_ordered_comm_semiring (sub_neg_monoid name))) : is_cyclic (canonically_ordered_comm_semiring (sub_neg_monoid name)) := sorry --non-trivial
lemma new_lemma_17435 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_17436 (h0 : topological_space (id (has_norm linarith.comp))) : irreducible_space (id (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_17437 (h1 : topological_space (measurable_space (random_gen linarith.ineq))) : path_connected_space (measurable_space (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_17438 (h0 : functor.add_const (function.extfun (Type 1) ring) Type) : @rank_condition.{1} (ordered_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) ring.{1}) Type h0) (ordered_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_17439 (h0 : topological_space (cancel_monoid (ring (ring environment.implicit_infer_kind)))) : preconnected_space (cancel_monoid (ring (ring environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_17440 (h0 : ring (has_nndist (ring (ring linarith.comp)))) : strong_rank_condition (has_nndist (ring (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_17441 (h0 : filter (comm_ring char)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_17442 (h0 : finset (normed_comm_ring unsigned)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_17443 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_neg_part pos)) Type) : @unique_factorization_monoid.{0} (has_neg_part.{0} pos) (@functor.add_const.run.{0 1} (cancel_comm_monoid_with_zero.{0} (has_neg_part.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_17444 (h0 : filter (has_neg environment.implicit_infer_kind)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_17445 (h0 : function.extfun nat fin) : @complete_lattice.is_Sup_finite_compact.{0} (comm_semigroup.{0} pos) (@matrix.vec_empty.{0} (complete_lattice.{0} (comm_semigroup.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_17446 (h0 : functor.add_const (function.extfun Type ring) (has_add (has_neg linarith.comp))) : @is_domain.{0} (has_add.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) (has_add.{0} (has_neg.{0} linarith.comp)) h0) (has_add.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_17447 (h0 : topological_space (has_norm to_additive.value_type)) : t0_space (has_norm to_additive.value_type) := sorry --non-trivial
lemma new_lemma_17448 (h0 : topological_space (linear_ordered_add_comm_group (random_gen (random_gen char)))) : totally_disconnected_space (linear_ordered_add_comm_group (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_17449 (h0 : topological_space (has_top linarith.comp_source)) : t0_space (has_top linarith.comp_source) := sorry --non-trivial
lemma new_lemma_17450 (h0 : functor.add_const (list (canonically_linear_ordered_monoid pos)) name) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_17451 (h0 : functor.add_const (uniform_space (generalized_boolean_algebra linarith.comp)) (has_pos_part Type)) : @complete_space.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 1} (uniform_space.{0} (generalized_boolean_algebra.{0} linarith.comp)) (has_pos_part.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_17452 (h0 : group (complete_semilattice_Sup (random_gen char))) : is_cyclic (complete_semilattice_Sup (random_gen char)) := sorry --non-trivial
lemma new_lemma_17453 (h0 : functor.add_const (add_group (mul_zero_class environment.implicit_infer_kind)) pos) : @is_add_cyclic.{0} (mul_zero_class.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (add_group.{0} (mul_zero_class.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_17454 (h0 : functor.add_const (function.extfun (Type 1) cancel_comm_monoid_with_zero) linarith.comp) : @unique_factorization_monoid.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1}) linarith.comp h0) (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_17455 (h0 : topological_space (linear_ordered_add_comm_group (with_bot string_imp))) : totally_separated_space (linear_ordered_add_comm_group (with_bot string_imp)) := sorry --non-trivial
lemma new_lemma_17456 (h0 : topological_space (has_neg (has_neg unsigned))) : t1_space (has_neg (has_neg unsigned)) := sorry --non-trivial
lemma new_lemma_17457 (h0 : measurable_space (add_left_cancel_monoid to_additive.value_type)) (h1 : measure_theory.measure (add_left_cancel_monoid to_additive.value_type)) : filter.ne_bot (measure_theory.measure.cofinite h1) := sorry --non-trivial
lemma new_lemma_17458 (h0 : complete_lattice (metric_space (semiring empty))) : is_atomistic (metric_space (semiring empty)) := sorry --non-trivial
lemma new_lemma_17459 (h0 : functor.add_const (function.extfun (Type 1) ordered_comm_monoid) Type) : @has_exists_mul_of_le.{1} (has_neg.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_comm_monoid.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) ordered_comm_monoid.{1}) Type h0) (has_neg.{1} Type))  := sorry --non-trivial
lemma new_lemma_17460 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (linear_ordered_comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_17461 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @discrete_topology.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) topological_space.{0}) (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_17462 (h0 : topological_space (has_to_string (has_to_string ennreal))) : sequential_space (has_to_string (has_to_string ennreal)) := sorry --non-trivial
lemma new_lemma_17463 (h0 : topological_space (canonically_ordered_comm_semiring (option (option unsigned)))) : t1_space (canonically_ordered_comm_semiring (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_17464 (h0 : topological_space (ordered_comm_monoid (ring (has_add (has_to_string (has_add (has_add Type))))))) : sequential_space (ordered_comm_monoid (ring (has_add (has_to_string (has_add (has_add Type)))))) := sorry --non-trivial
lemma new_lemma_17465 (h0 : non_assoc_semiring empty -> non_assoc_semiring empty -> Prop) : transitive h0 := sorry --non-trivial
lemma new_lemma_17466 (h0 : functor.add_const (ring (ordered_comm_ring Type)) name) : @strong_rank_condition.{1} (ordered_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (ordered_comm_ring.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_17467 (h1 : ring (div_inv_monoid (has_ssubset char))) : rank_condition (div_inv_monoid (has_ssubset char)) := sorry --non-trivial
lemma new_lemma_17468 (h0 : ordered_add_comm_monoid (generalized_boolean_algebra (ring name))) : archimedean (generalized_boolean_algebra (ring name)) := sorry --non-trivial
lemma new_lemma_17469 (h0 : functor.add_const (topological_space (has_add linarith.comp)) name) : @path_connected_space.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_17470 (h0 : topological_space (has_nndist linarith.comp)) : sequential_space (has_nndist linarith.comp) := sorry --non-trivial
lemma new_lemma_17471 (h0 : topological_space (semigroup (has_to_string (has_to_string pos)))) : irreducible_space (semigroup (has_to_string (has_to_string pos))) := sorry --non-trivial
lemma new_lemma_17472 (h0 : cancel_comm_monoid_with_zero (comm_group (option unsigned))) : unique_factorization_monoid (comm_group (option unsigned)) := sorry --non-trivial
lemma new_lemma_17473 (h0 : functor.add_const (add_group (comm_group Type)) linarith.comp) : @is_add_cyclic.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (add_group.{1} (comm_group.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_17474 (h0 : functor.add_const (topological_space (simple_graph Type)) (ring pos)) : @totally_separated_space.{1} (simple_graph.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (simple_graph.{1} Type)) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_17475 (h0 : ring name) : is_domain name := sorry --non-trivial
lemma new_lemma_17476 (h0 : finset (has_to_string (option unsigned))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_17477 (h0 : functor.add_const (complete_lattice znum) unsigned) : @is_atomistic.{0} znum (@functor.add_const.run.{0 0} (complete_lattice.{0} znum) unsigned h0)  := sorry --non-trivial
lemma new_lemma_17478 (h0 : functor.add_const (complete_lattice (has_Sup unsigned)) empty) : @is_atomistic.{0} (has_Sup.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_Sup.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_17479 (h1 : ring (mul_one_class string_imp)) : rank_condition (mul_one_class string_imp) := sorry --non-trivial
lemma new_lemma_17480 (h0 : topological_space (fintype (has_nnnorm fun_info))) : path_connected_space (fintype (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_17481 (h0 : monoid (has_to_string (has_zero linarith.comp))) : monoid.fg (has_to_string (has_zero linarith.comp)) := sorry --non-trivial
lemma new_lemma_17482 (h0 : function.extfun Type (functor.add_const (ring (add_semigroup empty)))) : @is_principal_ideal_ring.{0} (add_semigroup.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (add_semigroup.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} (add_semigroup.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_17483 (h1 h2 : multiset std_gen) : multiset.subset h1 h2 := sorry --non-trivial
lemma new_lemma_17484 (h0 : topological_space (with_bot (random_gen fun_info))) : path_connected_space (with_bot (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_17485 (h0 : ring (add_comm_monoid (has_to_string pos))) : is_domain (add_comm_monoid (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_17486 (h0 : functor.add_const (topological_space (has_pos_part real)) real) : @path_connected_space.{0} (has_pos_part.{0} real) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} real)) real h0)  := sorry --non-trivial
lemma new_lemma_17487 (h0 : add_monoid (finset (option (option name)))) : add_monoid.fg (finset (option (option name))) := sorry --non-trivial
lemma new_lemma_17488 (h0 : functor.comp cancel_comm_monoid_with_zero has_neg name) : @unique_factorization_monoid.{0} (has_neg.{0} name) (@functor.comp.run.{0 0 0} cancel_comm_monoid_with_zero.{0} has_neg.{0} name h0)  := sorry --non-trivial
lemma new_lemma_17489 (h0 : functor.add_const (function.extfun Type topological_space) real) : @t1_space.{0} (generalized_boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) real h0) (generalized_boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_17490 (h0 : topological_space (linear_ordered_semiring (has_top congr_arg_kind))) : totally_separated_space (linear_ordered_semiring (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_17491 (h0 : finset (left_cancel_monoid (option unsigned))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_17492 (h0 : ring (fintype fun_info)) : is_domain (fintype fun_info) := sorry --non-trivial
lemma new_lemma_17493 (h0 : list (simple_graph linarith.comp)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_17494 (h0 : uniform_space (has_nndist (has_add (has_add environment.implicit_infer_kind)))) : complete_space (has_nndist (has_add (has_add environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_17495 (h0 : function.extfun Type (functor.add_const (complete_lattice (non_assoc_semiring empty)))) : @is_compactly_generated.{0} (non_assoc_semiring.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (non_assoc_semiring.{0} empty)) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (complete_lattice.{0} (non_assoc_semiring.{0} empty))) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_17496 (h0 : ring (has_neg_part (has_neg_part (has_neg_part pos)))) : is_principal_ideal_ring (has_neg_part (has_neg_part (has_neg_part pos))) := sorry --non-trivial
lemma new_lemma_17497 (h0 : not (group (topological_space fun_info) -> false)) : @group.fg.{0} (topological_space.{0} fun_info) (@classical.by_contradiction'.{1} (group.{0} (topological_space.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_17498 (h0 : complete_lattice (add_cancel_monoid (has_zero pos))) : is_compactly_generated (add_cancel_monoid (has_zero pos)) := sorry --non-trivial
lemma new_lemma_17499 (h0 : topological_space (semigroup (comm_group unsigned))) : t1_space (semigroup (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_17500 (h0 : functor.add_const (topological_space (has_dist congr_arg_kind)) congr_arg_kind) : @t0_space.{0} (has_dist.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_dist.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_17501 (h0 : ring (has_inv (has_nnnorm linarith.comp_source))) : rank_condition (has_inv (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_17502 (h0 : functor.add_const (topological_space (normed_linear_ordered_group num)) num) : @preirreducible_space.{0} (normed_linear_ordered_group.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_linear_ordered_group.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_17503 (h0 : functor.add_const (ring (ring ordering)) name) : @is_principal_ideal_ring.{0} (ring.{0} ordering) (@functor.add_const.run.{0 0} (ring.{0} (ring.{0} ordering)) name h0)  := sorry --non-trivial
lemma new_lemma_17504 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (normed_group.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (normed_group.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_17505 (h0 : functor.add_const (add_monoid (has_nndist name)) environment.implicit_infer_kind) : @add_monoid.fg.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_nndist.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_17506 (h0 : ring (linear_ordered_semiring (has_norm linarith.comp_source))) : rank_condition (linear_ordered_semiring (has_norm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_17507 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (complete_distrib_lattice.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (complete_distrib_lattice.{0} empty))  := sorry --non-trivial
lemma new_lemma_17508 (h0 : group (boolean_algebra environment.implicit_infer_kind)) : is_simple_group (boolean_algebra environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_17509 (h1 : not (topological_space (has_compl (random_gen linarith.comp_source)) -> false)) : @t0_space.{0} (has_compl.{0} (random_gen.{0} linarith.comp_source)) (@classical.by_contradiction'.{1} (topological_space.{0} (has_compl.{0} (random_gen.{0} linarith.comp_source))) h1)  := sorry --non-trivial
lemma new_lemma_17510 (h0 : topological_space (has_compl (random_gen fun_info))) : t0_space (has_compl (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_17511 (h0 : functor.add_const (ring (generalized_boolean_algebra pos)) (has_add linarith.comp)) : @strong_rank_condition.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (generalized_boolean_algebra.{0} pos)) (has_add.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_17512 (h0 : topological_space (cancel_monoid (option pos))) : normal_space (cancel_monoid (option pos)) := sorry --non-trivial
lemma new_lemma_17513 (h0 : topological_space ereal) : connected_space ereal := sorry --non-trivial
lemma new_lemma_17514 (h0 : monoid (complete_distrib_lattice (option unsigned))) : monoid.fg (complete_distrib_lattice (option unsigned)) := sorry --non-trivial
lemma new_lemma_17515 (h0 : topological_space (generalized_boolean_algebra (has_nndist pos))) : locally_compact_space (generalized_boolean_algebra (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_17516 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (complete_semilattice_Sup.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_semilattice_Sup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_17517 (h0 : semiring (mul_one_class (add_comm_semigroup enat))) (h1 : ideal (mul_one_class (add_comm_semigroup enat))) : ideal.is_prime h1 := sorry --non-trivial
lemma new_lemma_17518 (h0 : group (monoid pos)) : group.fg (monoid pos) := sorry --non-trivial
lemma new_lemma_17519 (h0 : topological_space (ordered_comm_ring Type)) : t0_space (ordered_comm_ring Type) := sorry --non-trivial
lemma new_lemma_17520 (h0 : not (topological_space (measure_theory.measure_space congr_arg_kind) -> false)) : @t1_space.{0} (measure_theory.measure_space.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (measure_theory.measure_space.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_17521 (h0 : not (topological_space (comm_ring string.iterator_imp) -> false)) : @totally_disconnected_space.{0} (comm_ring.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (topological_space.{0} (comm_ring.{0} string.iterator_imp)) h0)  := sorry --non-trivial
lemma new_lemma_17522 (h0 : functor.add_const (function.extfun Type topological_space) (has_add linarith.comp)) : @preconnected_space.{0} (add_cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (has_add.{0} linarith.comp) h0) (add_cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_17523 (h0 : has_le (option num)) (h1 : functor.add_const (bounded_order (option num)) congr_arg_kind) : @is_simple_order.{0} (option.{0} num) h0 (@functor.add_const.run.{0 0} (@bounded_order.{0} (option.{0} num) h0) congr_arg_kind h1)  := sorry --non-trivial
lemma new_lemma_17524 (h0 : fin has_zero.zero) : @path_connected_space.{1} (simple_graph.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@matrix.vec_empty.{2} (function.extfun.{3 2} (Type 1) topological_space.{1}) h0) (simple_graph.{1} Type))  := sorry --non-trivial
lemma new_lemma_17525 (h0 : add_group (has_Inf (complete_distrib_lattice name))) : is_add_cyclic (has_Inf (complete_distrib_lattice name)) := sorry --non-trivial
lemma new_lemma_17526 (h0 : topological_space (semiring linarith.comp)) : irreducible_space (semiring linarith.comp) := sorry --non-trivial
lemma new_lemma_17527 (h0 : ring (normed_comm_ring empty)) : strong_rank_condition (normed_comm_ring empty) := sorry --non-trivial
lemma new_lemma_17528 (h0 : add_monoid (boolean_algebra.core pos)) : add_monoid.fg (boolean_algebra.core pos) := sorry --non-trivial
lemma new_lemma_17529 (h0 : monoid (generalized_boolean_algebra (has_neg real))) : monoid.fg (generalized_boolean_algebra (has_neg real)) := sorry --non-trivial
lemma new_lemma_17530 (h0 : group (has_ssubset (denumerable (random_gen (random_gen linarith.comp_source))))) : group.fg (has_ssubset (denumerable (random_gen (random_gen linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_17531 (h1 : uniform_space (has_norm (random_gen (random_gen (random_gen (random_gen to_additive.value_type)))))) : complete_space (has_norm (random_gen (random_gen (random_gen (random_gen to_additive.value_type))))) := sorry --non-trivial
lemma new_lemma_17532 (h0 : function.extfun Type topological_space) : t1_space real := sorry --non-trivial
lemma new_lemma_17533 (h0 : topological_space (linear_order congr_arg_kind)) : totally_disconnected_space (linear_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_17534 (h0 : functor.add_const (function.extfun (Type 1) ring) (has_add (has_neg (finset (has_add pos))))) : @is_principal_ideal_ring.{1} (normed_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ring.{1}) (has_add.{0} (has_neg.{0} (finset.{0} (has_add.{0} pos)))) h0) (normed_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_17535 (h0 : topological_space (has_add (has_neg name))) : t1_space (has_add (has_neg name)) := sorry --non-trivial
lemma new_lemma_17536 (h0 : filter (normed_group (has_top (has_top unsigned)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_17537 (h0 : uniform_space (canonically_linear_ordered_monoid (option pos))) : complete_space (canonically_linear_ordered_monoid (option pos)) := sorry --non-trivial
lemma new_lemma_17538 (h0 : topological_space (ordered_comm_monoid name)) : sequential_space (ordered_comm_monoid name) := sorry --non-trivial
lemma new_lemma_17539 (h0 : filter (finset (has_neg Type))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_17540 (h0 : has_mem.mem (id (has_norm empty)) has_emptyc.emptyc) : @is_atomistic.{0} (@id.{2} Type (has_norm.{0} empty)) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (@id.{2} Type (has_norm.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_17541 (h0 : complete_lattice (distrib_lattice (has_inv linarith.comp_source))) : is_compactly_generated (distrib_lattice (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_17542 (h0 : topological_space (linear_ordered_field (option empty))) : totally_separated_space (linear_ordered_field (option empty)) := sorry --non-trivial
lemma new_lemma_17543 (h0 : topological_space (add_group (linear_ordered_semiring congr_arg_kind))) : normal_space (add_group (linear_ordered_semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_17544 (h0 : function.extfun (finset Type) (has_mem.mem (has_one unsigned))) : @discrete_topology.{0} (has_one.{0} unsigned) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_one.{0} unsigned) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_one.{0} unsigned)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_17545 (h0 : ring (semi_normed_ring (mul_one_class reducibility_hints))) : strong_rank_condition (semi_normed_ring (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_17546 (h0 : add_monoid (add_cancel_monoid (finset (finset pos)))) : add_monoid.fg (add_cancel_monoid (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_17547 (h0 : uniform_space (has_to_string (has_neg_part (finset unsigned)))) : separated_space (has_to_string (has_neg_part (finset unsigned))) := sorry --non-trivial
lemma new_lemma_17548 (h0 : not (complete_lattice (uniform_space string.iterator_imp) -> false)) : is_compactly_generated (uniform_space string.iterator_imp) := sorry --non-trivial
lemma new_lemma_17549 (h0 : fin has_zero.zero) : @strong_rank_condition.{0} (has_star.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ring.{0}) h0) (has_star.{0} empty))  := sorry --non-trivial
lemma new_lemma_17550 (h1 : add_group (normed_field ereal)) : is_add_cyclic (normed_field ereal) := sorry --non-trivial
lemma new_lemma_17551 (h0 : add_monoid (cancel_monoid (option (option empty)))) : add_monoid.fg (cancel_monoid (option (option empty))) := sorry --non-trivial
lemma new_lemma_17552 (h0 : topological_space (has_neg (ring linarith.comp))) : t0_space (has_neg (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_17553 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (has_Inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_Inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_17554 (h0 : topological_space (has_add name)) : discrete_topology (has_add name) := sorry --non-trivial
lemma new_lemma_17555 (h0 : functor.add_const (uniform_space (normed_linear_ordered_group num)) (semiring (semiring num))) : @complete_space.{0} (normed_linear_ordered_group.{0} num) (@functor.add_const.run.{0 0} (uniform_space.{0} (normed_linear_ordered_group.{0} num)) (semiring.{0} (semiring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_17556 (h0 h3 : multiset linarith.ineq) : multiset.subset h0 h3 := sorry --non-trivial
lemma new_lemma_17557 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (ordered_cancel_add_comm_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (ordered_cancel_add_comm_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_17558 (h0 : ring (has_nndist ennreal)) : is_principal_ideal_ring (has_nndist ennreal) := sorry --non-trivial
lemma new_lemma_17559 (h0 : functor.add_const (topological_space (has_zero pos)) pos) : @topological_space.separable_space.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_17560 (h0 : topological_space (has_to_string (boolean_algebra.core name))) : regular_space (has_to_string (boolean_algebra.core name)) := sorry --non-trivial
lemma new_lemma_17561 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_add.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} real))  := sorry --non-trivial
lemma new_lemma_17562 (h0 : ring (random_gen (random_gen char))) : strong_rank_condition (random_gen (random_gen char)) := sorry --non-trivial
lemma new_lemma_17563 (h1 : complete_lattice (semi_normed_comm_ring to_additive.value_type)) : complete_lattice.is_Sup_finite_compact (semi_normed_comm_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_17564 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (omega_complete_partial_order.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (omega_complete_partial_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_17565 (h0 : not (uniform_space (with_one fun_info) -> false)) : @separated_space.{0} (with_one.{0} fun_info) (@classical.by_contradiction'.{1} (uniform_space.{0} (with_one.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_17566 (h0 : topological_space (has_bot (has_bot (sub_neg_monoid real)))) : t0_space (has_bot (has_bot (sub_neg_monoid real))) := sorry --non-trivial
lemma new_lemma_17567 (h0 : function.extfun nat fin) : @totally_disconnected_space.{0} (has_bot.{0} (has_add.{0} (has_add.{0} (has_add.{0} pos)))) (@matrix.vec_empty.{0} (topological_space.{0} (has_bot.{0} (has_add.{0} (has_add.{0} (has_add.{0} pos))))) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_17568 (h0 : functor.add_const (topological_space (has_zero environment.implicit_infer_kind)) name) : @sequential_space.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_17569 (h0 : monoid (finset (normed_comm_ring (boolean_algebra Type)))) : monoid.fg (finset (normed_comm_ring (boolean_algebra Type))) := sorry --non-trivial
lemma new_lemma_17570 (h0 : uniform_space (nondiscrete_normed_field (mul_one_class string.iterator_imp))) : complete_space (nondiscrete_normed_field (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_17571 (h0 : functor.add_const (function.extfun Type group) linarith.comp) : @group.fg.{0} (ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) linarith.comp h0) (ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_17572 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @loc_path_connected_space.{0} (complete_distrib_lattice.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (complete_distrib_lattice.{0} pos))  := sorry --non-trivial
lemma new_lemma_17573 (h0 : complete_lattice (ordered_ring (semiring empty))) : complete_lattice.is_Sup_finite_compact (ordered_ring (semiring empty)) := sorry --non-trivial
lemma new_lemma_17574 (h0 : functor.add_const (group (complete_distrib_lattice pos)) name) : @is_simple_group.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (complete_distrib_lattice.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_17575 (h0 : uniform_space (linear_ordered_comm_ring unsigned)) : separated_space (linear_ordered_comm_ring unsigned) := sorry --non-trivial
lemma new_lemma_17576 (h0 : topological_space (with_bot num)) : t1_space (with_bot num) := sorry --non-trivial
lemma new_lemma_17577 (h0 : uniform_space (semi_normed_comm_ring (has_nnnorm (has_nnnorm (has_nnnorm linarith.ineq))))) : complete_space (semi_normed_comm_ring (has_nnnorm (has_nnnorm (has_nnnorm linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_17578 (h0 : ordered_add_comm_monoid (mul_zero_class (has_neg_part name))) : archimedean (mul_zero_class (has_neg_part name)) := sorry --non-trivial
lemma new_lemma_17579 (h0 : complete_lattice (has_top (has_norm (has_inv string_imp)))) : is_atomistic (has_top (has_norm (has_inv string_imp))) := sorry --non-trivial
lemma new_lemma_17580 (h0 : group pos) : is_cyclic pos := sorry --non-trivial
lemma new_lemma_17581 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (ordered_ring.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (ordered_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_17582 (h0 : functor.add_const (function.extfun Type filter) linarith.comp) : countable_Inter_filter (function.extfun_app (functor.add_const.run h0) (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_17583 (h0 : has_mem.mem (normed_group linarith.comp) has_emptyc.emptyc) : @complete_space.{0} (normed_group.{0} linarith.comp) (@finset.pi.empty.{1 0} Type uniform_space.{0} (normed_group.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_17584 (h3 : topological_space (add_comm_semigroup char)) (h4 : preorder (add_comm_semigroup char)) : order_closed_topology (add_comm_semigroup char) := sorry --non-trivial
lemma new_lemma_17585 (h0 : topological_space (has_nndist (finset (has_add (finset pos))))) : locally_compact_space (has_nndist (finset (has_add (finset pos)))) := sorry --non-trivial
lemma new_lemma_17586 (h0 : group (filter congr_arg_kind)) : group.fg (filter congr_arg_kind) := sorry --non-trivial
lemma new_lemma_17587 (h0 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} (normed_group.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h0) (normed_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_17588 (h1 : has_mem.mem topological_space has_emptyc.emptyc) : @discrete_topology.{0} num (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h1) num)  := sorry --non-trivial
lemma new_lemma_17589 (h0 : function.extfun Type group) : @normalizer_condition.{0} (option.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (option.{0} pos))  := sorry --non-trivial
lemma new_lemma_17590 (h0 : functor.add_const (function.extfun (Type 1) ring) pos) : @is_domain.{1} Type (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ring.{1}) pos h0) Type)  := sorry --non-trivial
lemma new_lemma_17591 (h0 : functor.add_const (function.extfun Type uniform_space) (has_to_string pos)) : @separated_space.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) (has_to_string.{0} pos) h0) (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_17592 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (as_linear_order.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (as_linear_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_17593 (h0 : functor.add_const (topological_space (has_pos_part name)) linarith.comp) : @path_connected_space.{0} (has_pos_part.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_17594 (h0 : ring (fintype (add_left_cancel_monoid linarith.comp_source))) : strong_rank_condition (fintype (add_left_cancel_monoid linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_17595 (h0 : not (prod (add_group empty) (add_group empty) -> false)) : id_rel (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_17596 (h0 : group (denumerable (random_gen string_imp))) : is_cyclic (denumerable (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_17597 (h0 : complete_lattice (measurable_space (random_gen congr_arg_kind))) : is_compactly_generated (measurable_space (random_gen congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_17598 (h0 : group (has_star (semiring num))) : group.fg (has_star (semiring num)) := sorry --non-trivial
lemma new_lemma_17599 (h0 : not (function.extfun Type topological_space -> false)) : @normal_space.{0} (@id.{2} Type congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (@id.{2} Type congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_17600 (h0 : topological_space (option (has_norm num))) : t0_space (option (has_norm num)) := sorry --non-trivial
lemma new_lemma_17601 (h0 : pnat) (h1 : ulower pnat) : pnat.coprime (id h0) (ulower.up h1) := sorry --non-trivial
lemma new_lemma_17602 (h0 : not (uniform_space (non_assoc_semiring congr_arg_kind) -> false)) : @complete_space.{0} (non_assoc_semiring.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (uniform_space.{0} (non_assoc_semiring.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_17603 (h0 : topological_space (linear_ordered_field ennreal)) : t0_space (linear_ordered_field ennreal) := sorry --non-trivial
lemma new_lemma_17604 (h0 : topological_space (partial_order num)) : totally_separated_space (partial_order num) := sorry --non-trivial
lemma new_lemma_17605 (h0 : filter (has_union (has_top empty))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_17606 (h0 : ring (has_neg (finset (finset (finset pos))))) : rank_condition (has_neg (finset (finset (finset pos)))) := sorry --non-trivial
lemma new_lemma_17607 (h0 : filter (linear_ordered_comm_ring (semiring (semiring congr_arg_kind)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_17608 (h2 : monoid (with_one (with_bot (with_bot string_imp)))) : monoid.fg (with_one (with_bot (with_bot string_imp))) := sorry --non-trivial
lemma new_lemma_17609 (h0 : functor.add_const (topological_space (complete_distrib_lattice linarith.comp)) pos) : @totally_separated_space.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_17610 (h0 : topological_space (boolean_algebra.core (has_neg name))) : path_connected_space (boolean_algebra.core (has_neg name)) := sorry --non-trivial
lemma new_lemma_17611 (h0 : list (has_nndist (left_cancel_monoid (left_cancel_monoid unsigned)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_17612 (h0 : (nat -> Prop) -> (nat -> Prop) -> Prop) (h1 : well_founded h0) (h2 : Pi (x : nat -> Prop), (Pi (y : nat -> Prop), h0 y x -> subtype y) -> subtype x) : pnat.prime (well_founded.recursion h1 (fun (n : nat), has_lt.lt has_zero.zero n) h2) := sorry --non-trivial
lemma new_lemma_17613 (h0 : function.extfun Type (functor.add_const (uniform_space (bin_tree unsigned)))) : @separated_space.{0} (bin_tree.{0} unsigned) (@functor.add_const.run.{0 0} (uniform_space.{0} (bin_tree.{0} unsigned)) congr_arg_kind (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (uniform_space.{0} (bin_tree.{0} unsigned))) h0 congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_17614 (h0 : function.extfun Type topological_space) : @normal_space.{0} (normed_comm_ring.{0} (option.{0} ennreal)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} (option.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_17615 (h0 : functor.add_const (group (canonically_ordered_monoid linarith.comp)) linarith.comp) : @group.fg.{0} (canonically_ordered_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (canonically_ordered_monoid.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_17616 (h0 : function.extfun nat fin) : @has_exists_mul_of_le.{0} (has_Inf.{0} real) (@matrix.vec_empty.{0} (ordered_comm_monoid.{0} (has_Inf.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_17617 (h1 : topological_space (mul_one_class (add_comm_semigroup (mul_one_class std_gen)))) : t0_space (mul_one_class (add_comm_semigroup (mul_one_class std_gen))) := sorry --non-trivial
lemma new_lemma_17618 (h0 : functor.add_const (function.extfun Type ordered_add_comm_monoid) (finset pos)) : @archimedean.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_add_comm_monoid.{0}) (finset.{0} pos) h0) (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_17619 (h0 : ring (complete_distrib_lattice (has_bot Type))) : rank_condition (complete_distrib_lattice (has_bot Type)) := sorry --non-trivial
lemma new_lemma_17620 (h0 : complete_lattice (order_dual string_imp)) : is_compactly_generated (order_dual string_imp) := sorry --non-trivial
lemma new_lemma_17621 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (random_gen.{0} (semiring.{0} (has_norm.{0} empty))) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (random_gen.{0} (semiring.{0} (has_norm.{0} empty))))  := sorry --non-trivial
lemma new_lemma_17622 (h0 : not (complete_lattice (denumerable (has_nnnorm linarith.ineq)) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (denumerable.{0} (has_nnnorm.{0} linarith.ineq)) (@classical.by_contradiction'.{1} (complete_lattice.{0} (denumerable.{0} (has_nnnorm.{0} linarith.ineq))) h0)  := sorry --non-trivial
lemma new_lemma_17623 (h0 : group (has_zero (has_neg Type))) : is_simple_group (has_zero (has_neg Type)) := sorry --non-trivial
lemma new_lemma_17624 (h0 : add_group (ring (has_to_string (has_zero (ring (ring Type)))))) : is_add_cyclic (ring (has_to_string (has_zero (ring (ring Type))))) := sorry --non-trivial
lemma new_lemma_17625 (h0 : ring (encodable (has_nnnorm (random_gen fun_info)))) : strong_rank_condition (encodable (has_nnnorm (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_17626 (h0 : functor.add_const (function.extfun Type group) name) : @normalizer_condition.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) name h0) (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_17627 (h0 : topological_space (finset congr_arg_kind)) : path_connected_space (finset congr_arg_kind) := sorry --non-trivial
lemma new_lemma_17628 (h0 : group (semiring num)) : group.fg (semiring num) := sorry --non-trivial
lemma new_lemma_17629 (h0 : functor.add_const (list (plift empty)) (option (option unsigned))) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_17630 (h1 : topological_space (has_ssubset (random_gen (has_nnnorm (random_gen char))))) : path_connected_space (has_ssubset (random_gen (has_nnnorm (random_gen char)))) := sorry --non-trivial
lemma new_lemma_17631 (h0 : topological_space (boolean_algebra.core (has_add (ring Type)))) : preconnected_space (boolean_algebra.core (has_add (ring Type))) := sorry --non-trivial
lemma new_lemma_17632 (h0 : functor.add_const (filter (comm_group unsigned)) linarith.comp) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_17633 (h0 : uniform_space (cancel_monoid (option pos))) : complete_space (cancel_monoid (option pos)) := sorry --non-trivial
lemma new_lemma_17634 (h0 : topological_space (linear_ordered_comm_group_with_zero linarith.ineq)) (h1 : add_group (linear_ordered_comm_group_with_zero linarith.ineq)) : topological_add_group (linear_ordered_comm_group_with_zero linarith.ineq) := sorry --non-trivial
lemma new_lemma_17635 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (metric_space.{0} (has_norm.{0} congr_arg_kind)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (metric_space.{0} (has_norm.{0} congr_arg_kind)))  := sorry --non-trivial
lemma new_lemma_17636 (h0 : functor.add_const (topological_space znum) (option (option num))) : @totally_separated_space.{0} znum (@functor.add_const.run.{0 0} (topological_space.{0} znum) (option.{0} (option.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_17637 (h0 : ring (has_le environment.projection_info)) : is_domain (has_le environment.projection_info) := sorry --non-trivial
lemma new_lemma_17638 (h0 : not (topological_space (semi_normed_ring (denumerable reducibility_hints)) -> false)) : @t0_space.{0} (semi_normed_ring.{0} (denumerable.{0} reducibility_hints)) (@classical.by_contradiction'.{1} (topological_space.{0} (semi_normed_ring.{0} (denumerable.{0} reducibility_hints))) h0)  := sorry --non-trivial
lemma new_lemma_17639 (h0 : complete_lattice pos) : complete_lattice.is_Sup_finite_compact pos := sorry --non-trivial
lemma new_lemma_17640 (h0 : uniform_space (has_pos_part (has_Inf (has_nndist (has_add linarith.comp))))) : separated_space (has_pos_part (has_Inf (has_nndist (has_add linarith.comp)))) := sorry --non-trivial
lemma new_lemma_17641 (h0 : functor.add_const (semiring (free_add_monoid unsigned)) num) : @is_noetherian_ring.{0} (free_add_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (semiring.{0} (free_add_monoid.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_17642 (h0 : functor.comp topological_space add_comm_monoid Type) : @regular_space.{1} (add_comm_monoid.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} add_comm_monoid.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_17643 (h0 : has_mem.mem (complete_semilattice_Sup congr_arg_kind) has_emptyc.emptyc) : @locally_compact_space.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (complete_semilattice_Sup.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_17644 (h0 : functor.add_const (group (finset Type)) (ring environment.implicit_infer_kind)) : @is_simple_group.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (finset.{1} Type)) (ring.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_17645 (h0 : topological_space (add_cancel_monoid (option name))) : t1_space (add_cancel_monoid (option name)) := sorry --non-trivial
lemma new_lemma_17646 (h0 : functor.comp topological_space ring (normed_comm_ring environment.implicit_infer_kind)) : @path_connected_space.{0} (ring.{0} (normed_comm_ring.{0} environment.implicit_infer_kind)) (@functor.comp.run.{0 0 0} topological_space.{0} ring.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_17647 (h0 : functor.add_const (topological_space (linear_ordered_comm_monoid_with_zero empty)) (option empty)) : @totally_disconnected_space.{0} (linear_ordered_comm_monoid_with_zero.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_comm_monoid_with_zero.{0} empty)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_17648 (h1 : topological_space (encodable string_imp)) : totally_disconnected_space (encodable string_imp) := sorry --non-trivial
lemma new_lemma_17649 (h0 : uniform_space (linear_ordered_comm_monoid_with_zero unsigned)) : separated_space (linear_ordered_comm_monoid_with_zero unsigned) := sorry --non-trivial
lemma new_lemma_17650 (h0 : functor.add_const (list (finset name)) pos) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_17651 (h0 : topological_space fun_info) : discrete_topology fun_info := sorry --non-trivial
lemma new_lemma_17652 (h0 : ring (nondiscrete_normed_field (mul_one_class string.iterator_imp))) : strong_rank_condition (nondiscrete_normed_field (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_17653 (h0 : function.extfun nat fin) : @monoid.fg.{1} (boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (monoid.{1} (boolean_algebra.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_17654 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @discrete_topology.{1} (sub_neg_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (sub_neg_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_17655 (h0 : uniform_space (linear_order (option (option unsigned)))) : separated_space (linear_order (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_17656 (h0 : complete_lattice (has_pos_part name)) : is_compactly_generated (has_pos_part name) := sorry --non-trivial
lemma new_lemma_17657 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_17658 (h0 : ring (add_right_cancel_monoid (semiring (semiring empty)))) : is_principal_ideal_ring (add_right_cancel_monoid (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_17659 (h0 : not (topological_space (has_top to_additive.value_type) -> false)) : @totally_separated_space.{0} (has_top.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (has_top.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_17660 (h0 : not (complete_lattice (encodable char) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (encodable.{0} char) (@classical.by_contradiction'.{1} (complete_lattice.{0} (encodable.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_17661 (h0 : add_monoid (canonically_ordered_add_monoid unsigned)) : add_monoid.fg (canonically_ordered_add_monoid unsigned) := sorry --non-trivial
lemma new_lemma_17662 (h0 : set (set (has_top (has_top fun_info)))) : is_countably_spanning h0 := sorry --non-trivial
lemma new_lemma_17663 (h0 : functor.add_const (complete_lattice (has_neg linarith.comp)) linarith.comp) : @complete_lattice.is_Sup_finite_compact.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_neg.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_17664 (h0 : filter (ordered_comm_monoid (has_pos_part pos))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_17665 (h0 : functor.add_const (monoid (ring linarith.comp)) environment.implicit_infer_kind) : @monoid.fg.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (monoid.{0} (ring.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_17666 (h0 : group (comm_group (comm_group name))) : is_cyclic (comm_group (comm_group name)) := sorry --non-trivial
lemma new_lemma_17667 (h0 : not (ring (distrib reducibility_hints) -> false)) : @is_domain.{0} (distrib.{0} reducibility_hints) (@classical.by_contradiction'.{1} (ring.{0} (distrib.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_17668 (h0 : complete_lattice (non_assoc_semiring congr_arg_kind)) : complete_lattice.is_Sup_finite_compact (non_assoc_semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_17669 (h0 : prod (partial_order unsigned) (partial_order unsigned)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_17670 (h0 : group (comm_group (ring (has_nndist Type)))) : is_simple_group (comm_group (ring (has_nndist Type))) := sorry --non-trivial
lemma new_lemma_17671 (h0 : topological_space (dlist (random_gen to_additive.value_type))) : totally_disconnected_space (dlist (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_17672 (h2 : ring (has_div linarith.comp_source)) : strong_rank_condition (has_div linarith.comp_source) := sorry --non-trivial
lemma new_lemma_17673 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (measurable_space.dynkin_system num)) := sorry --non-trivial
lemma new_lemma_17674 (h0 : complete_lattice (measurable_space linarith.comp_source)) : complete_lattice.is_Sup_finite_compact (measurable_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_17675 (h0 : add_group (has_lt (has_lt linarith.comp_source))) : is_add_cyclic (has_lt (has_lt linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_17676 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_17677 (h0 : topological_space (has_nndist (has_add name))) : normal_space (has_nndist (has_add name)) := sorry --non-trivial
lemma new_lemma_17678 (h0 : function.extfun nat fin) : @sequential_space.{0} (add_comm_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (add_comm_monoid.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_17679 (h0 : list (generalized_boolean_algebra (ordered_ring linarith.comp))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_17680 (h0 : uniform_space (has_top congr_arg_kind)) : complete_space (has_top congr_arg_kind) := sorry --non-trivial
lemma new_lemma_17681 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (random_gen.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (random_gen.{0} empty))  := sorry --non-trivial
lemma new_lemma_17682 (h0 : not (has_mem.mem (with_bot linarith.ineq) has_emptyc.emptyc -> false)) : @locally_compact_space.{0} (with_bot.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_bot.{0} linarith.ineq) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_bot.{0} linarith.ineq) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_17683 (h0 : functor.add_const (add_group (boolean_algebra environment.implicit_infer_kind)) (normed_comm_ring pos)) : @is_add_cyclic.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (add_group.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) (normed_comm_ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_17684 (h0 : functor.add_const (group (semigroup Type)) environment.implicit_infer_kind) : @normalizer_condition.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (semigroup.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_17685 (h1 : comm_semiring (add_right_cancel_monoid linarith.comp_source)) (h2 : polynomial (add_right_cancel_monoid linarith.comp_source)) : polynomial.separable h2 := sorry --non-trivial
lemma new_lemma_17686 (h0 : topological_space (generalized_boolean_algebra (has_pos_part linarith.comp))) : normal_space (generalized_boolean_algebra (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_17687 (h0 : topological_space (normed_lattice_add_comm_group pos)) : irreducible_space (normed_lattice_add_comm_group pos) := sorry --non-trivial
lemma new_lemma_17688 (h0 : topological_space (has_to_string (has_to_string name))) : sequential_space (has_to_string (has_to_string name)) := sorry --non-trivial
lemma new_lemma_17689 (h0 : topological_space (add_cancel_monoid num)) : t1_space (add_cancel_monoid num) := sorry --non-trivial
lemma new_lemma_17690 (h0 : functor.add_const (topological_space (boolean_algebra name)) environment.implicit_infer_kind) : @locally_compact_space.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_17691 (h0 : prod (complete_distrib_lattice pos) (complete_distrib_lattice pos)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_17692 (h0 : add_group (random_gen (has_norm (has_norm empty)))) : is_add_cyclic (random_gen (has_norm (has_norm empty))) := sorry --non-trivial
lemma new_lemma_17693 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_noetherian_ring.{1} (has_pos_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) semiring.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 semiring.{1}) (has_pos_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_17694 (h0 : has_mem.mem (random_gen empty) has_emptyc.emptyc) : @is_cyclic.{0} (random_gen.{0} empty) (@finset.pi.empty.{1 0} Type group.{0} (random_gen.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_17695 (h0 : topological_space (semigroup (has_nndist (has_nndist ennreal)))) : sequential_space (semigroup (has_nndist (has_nndist ennreal))) := sorry --non-trivial
lemma new_lemma_17696 (h0 : complete_lattice (has_union (semiring congr_arg_kind))) : is_atomistic (has_union (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_17697 (h0 : ring (has_top (random_gen empty))) : is_domain (has_top (random_gen empty)) := sorry --non-trivial
lemma new_lemma_17698 (h0 : ring (metric_space empty)) : is_principal_ideal_ring (metric_space empty) := sorry --non-trivial
lemma new_lemma_17699 (h0 : complete_lattice (add_comm_monoid (comm_group (comm_group name)))) : complete_lattice.is_Sup_finite_compact (add_comm_monoid (comm_group (comm_group name))) := sorry --non-trivial
lemma new_lemma_17700 (h0 : topological_space (ordered_comm_group (option (option empty)))) : totally_disconnected_space (ordered_comm_group (option (option empty))) := sorry --non-trivial
lemma new_lemma_17701 (h0 : not (uniform_space (has_norm congr_arg_kind) -> false)) : @complete_space.{0} (has_norm.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_norm.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_17702 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_edist.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_edist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_17703 (h0 : ring (ordered_comm_ring (has_neg name))) : is_principal_ideal_ring (ordered_comm_ring (has_neg name)) := sorry --non-trivial
lemma new_lemma_17704 (h0 : group (has_inv string_imp)) : normalizer_condition (has_inv string_imp) := sorry --non-trivial
lemma new_lemma_17705 (h0 : functor.add_const (function.extfun Type semiring) name) : @is_noetherian_ring.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type semiring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type semiring.{0}) name h0) (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_17706 (h0 : function.extfun Type ring) : @is_domain.{0} (has_inter.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_inter.{0} num))  := sorry --non-trivial
lemma new_lemma_17707 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (boolean_algebra.core name)) := sorry --non-trivial
lemma new_lemma_17708 (h0 : not (has_mem.mem (has_emptyc linarith.ineq) has_emptyc.emptyc -> false)) : @rank_condition.{0} (has_emptyc.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type ring.{0} (has_emptyc.{0} linarith.ineq) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_emptyc.{0} linarith.ineq) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_17709 (h0 : topological_space (add_comm_semigroup (mul_one_class (mul_one_class std_gen)))) : path_connected_space (add_comm_semigroup (mul_one_class (mul_one_class std_gen))) := sorry --non-trivial
lemma new_lemma_17710 (h0 : topological_space (has_ssubset char)) : t0_space (has_ssubset char) := sorry --non-trivial
lemma new_lemma_17711 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @add_monoid.fg.{1} (comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_monoid.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 add_monoid.{1}) (comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_17712 (h0 : group (pseudo_metric_space (option pos))) : is_cyclic (pseudo_metric_space (option pos)) := sorry --non-trivial
lemma new_lemma_17713 (h1 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_emptyc.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (has_emptyc.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_17714 (h0 : function.extfun Type group) : @normalizer_condition.{0} (complete_semilattice_Sup.{0} (has_top.{0} linarith.comp_source)) (@function.extfun_app.{2 1} Type group.{0} h0 (complete_semilattice_Sup.{0} (has_top.{0} linarith.comp_source)))  := sorry --non-trivial
lemma new_lemma_17715 (h0 : functor.add_const (topological_space (mul_zero_class name)) ennreal) : @discrete_topology.{0} (mul_zero_class.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} name)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_17716 (h0 : topological_space (boolean_algebra (has_neg_part Type))) : path_connected_space (boolean_algebra (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_17717 (h0 : functor.add_const (topological_space (comm_group linarith.comp)) name) : @regular_space.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_17718 (h0 : group (canonically_linear_ordered_monoid congr_arg_kind)) : is_simple_group (canonically_linear_ordered_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_17719 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (dlist linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_17720 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} linarith.ineq (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) linarith.ineq)  := sorry --non-trivial
lemma new_lemma_17721 (h0 : topological_space (as_linear_order congr_arg_kind)) : totally_disconnected_space (as_linear_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_17722 (h0 : function.extfun (finset Type -> Prop) (function.extfun (finset Type))) : @locally_compact_space.{0} (normed_group.{0} unsigned) (@finset.pi.empty.{1 0} Type topological_space.{0} (normed_group.{0} unsigned) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (normed_group.{0} unsigned)) (@function.extfun_app.{2 0} (finset.{1} Type → Prop) (function.extfun.{2 0} (finset.{1} Type)) h0 (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (normed_group.{0} unsigned))) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_17723 (h0 : set (canonically_linear_ordered_monoid string.iterator_imp)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_17724 (h0 : list (linear_ordered_field (option ennreal))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_17725 (h1 : set (has_ssubset linarith.ineq)) : set.finite h1 := sorry --non-trivial
lemma new_lemma_17726 (h0 : ring (ring (boolean_algebra (boolean_algebra Type)))) : rank_condition (ring (boolean_algebra (boolean_algebra Type))) := sorry --non-trivial
lemma new_lemma_17727 (h0 : fin has_zero.zero) : @totally_disconnected_space.{1} (ordered_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@matrix.vec_empty.{2} (function.extfun.{3 2} (Type 1) topological_space.{1}) h0) (ordered_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_17728 (h0 : complete_lattice (has_one (semiring empty))) : complete_lattice.is_Sup_finite_compact (has_one (semiring empty)) := sorry --non-trivial
lemma new_lemma_17729 (h0 : topological_space (canonically_linear_ordered_monoid (option ennreal))) : sequential_space (canonically_linear_ordered_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_17730 (h0 : filter (has_Inf real)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_17731 (h0 : add_group (generalized_boolean_algebra (has_neg pos))) : is_add_cyclic (generalized_boolean_algebra (has_neg pos)) := sorry --non-trivial
lemma new_lemma_17732 (h0 : functor.add_const (finset (finset Type)) linarith.comp) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_17733 (h0 : uniform_space (add_comm_monoid Type)) : separated_space (add_comm_monoid Type) := sorry --non-trivial
lemma new_lemma_17734 (h0 : uniform_space (has_append (comm_ring char))) : complete_space (has_append (comm_ring char)) := sorry --non-trivial
lemma new_lemma_17735 (h0 : add_group (has_div (metric_space reducibility_hints))) : is_add_cyclic (has_div (metric_space reducibility_hints)) := sorry --non-trivial
lemma new_lemma_17736 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (linear_ordered_comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (linear_ordered_comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_17737 (h0 : ring (has_ssubset char)) : rank_condition (has_ssubset char) := sorry --non-trivial
lemma new_lemma_17738 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (has_emptyc.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_emptyc.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_17739 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_nndist.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} empty))  := sorry --non-trivial
lemma new_lemma_17740 (h0 : ordered_add_comm_monoid (has_zero (has_add unsigned))) : archimedean (has_zero (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_17741 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @add_monoid.fg.{1} (canonically_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (add_monoid.{1} (canonically_ordered_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_17742 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem ring)) : @rank_condition.{0} (complete_semilattice_Sup.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) ring.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (complete_semilattice_Sup.{0} num))  := sorry --non-trivial
lemma new_lemma_17743 (h0 : function.extfun (Type 1) (prod (plift unsigned))) : id_rel (function.extfun_app h0 (plift unsigned)) := sorry --non-trivial
lemma new_lemma_17744 (h3 : topological_space (has_add (has_nnnorm linarith.comp_source))) : totally_disconnected_space (has_add (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_17745 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (@id.{2} Type empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (@id.{2} Type empty))  := sorry --non-trivial
lemma new_lemma_17746 (h0 : functor.add_const (topological_space (has_star congr_arg_kind)) empty) : @totally_separated_space.{0} (has_star.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_17747 (h2 : ring (has_ssubset (random_gen linarith.ineq))) : is_domain (has_ssubset (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_17748 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (canonically_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (canonically_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_17749 (h0 : function.extfun Type (functor.add_const (topological_space (linear_ordered_field unsigned)))) : @locally_compact_space.{0} (linear_ordered_field.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_field.{0} unsigned)) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (linear_ordered_field.{0} unsigned))) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_17750 (h0 : group (has_top (has_nnnorm string_imp))) : is_cyclic (has_top (has_nnnorm string_imp)) := sorry --non-trivial
lemma new_lemma_17751 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_atomistic.{0} (has_union.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (has_union.{0} num))  := sorry --non-trivial
lemma new_lemma_17752 (h0 : functor.add_const (group (mul_zero_class name)) Type) : @group.fg.{0} (mul_zero_class.{0} name) (@functor.add_const.run.{0 1} (group.{0} (mul_zero_class.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_17753 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (has_pos_part.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_pos_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_17754 (h0 : functor.comp topological_space cancel_monoid pos) : @totally_disconnected_space.{0} (cancel_monoid.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} cancel_monoid.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_17755 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} (has_one.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_17756 (h0 h1 : multiset (normed_field to_additive.value_type)) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_17757 (h0 : group (add_cancel_monoid (generalized_boolean_algebra (has_add pos)))) : is_simple_group (add_cancel_monoid (generalized_boolean_algebra (has_add pos))) := sorry --non-trivial
lemma new_lemma_17758 (h0 : topological_space (has_add (option unsigned))) : t0_space (has_add (option unsigned)) := sorry --non-trivial
lemma new_lemma_17759 (h0 : group (add_cancel_monoid (has_add linarith.comp))) : is_simple_group (add_cancel_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_17760 (h0 : has_mem.mem (with_bot empty) has_emptyc.emptyc) : @irreducible_space.{0} (with_bot.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_bot.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_17761 (h0 : generalized_boolean_algebra real -> generalized_boolean_algebra real -> Prop) : is_equiv (generalized_boolean_algebra real) h0 := sorry --non-trivial
lemma new_lemma_17762 (h0 : functor.add_const (add_group (boolean_algebra linarith.comp)) (finset Type)) : @is_add_cyclic.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 1} (add_group.{0} (boolean_algebra.{0} linarith.comp)) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_17763 (h0 : functor.add_const (add_group (cancel_monoid Type)) name) : @is_add_cyclic.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (add_group.{1} (cancel_monoid.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_17764 (h0 : add_group (uniform_space linarith.comp_source)) : is_add_cyclic (uniform_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_17765 (h0 : group (has_norm (has_inv (has_inv to_additive.value_type)))) : is_cyclic (has_norm (has_inv (has_inv to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_17766 (h0 : functor.add_const (group (add_cancel_monoid Type)) pos) : @group.fg.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (add_cancel_monoid.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_17767 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (boolean_algebra.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_17768 (h0 : topological_space (add_cancel_monoid (finset (finset linarith.comp)))) : t1_space (add_cancel_monoid (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_17769 (h0 : functor.add_const (topological_space (complete_distrib_lattice ennreal)) (option (option ennreal))) : @locally_compact_space.{0} (complete_distrib_lattice.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} ennreal)) (option.{0} (option.{0} ennreal)) h0)  := sorry --non-trivial
lemma new_lemma_17770 (h0 : functor.add_const (topological_space (has_add name)) name) : @topological_space.separable_space.{0} (has_add.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_17771 (h0 : ring (has_div (mul_one_class linarith.ineq))) : rank_condition (has_div (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_17772 (h0 : uniform_space (metric_space congr_arg_kind)) : separated_space (metric_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_17773 (h0 : topological_space (simple_graph (boolean_algebra.core linarith.comp))) : sequential_space (simple_graph (boolean_algebra.core linarith.comp)) := sorry --non-trivial
lemma new_lemma_17774 (h0 : complete_lattice (has_zero (has_add (has_add (has_add linarith.comp))))) : is_atomistic (has_zero (has_add (has_add (has_add linarith.comp)))) := sorry --non-trivial
lemma new_lemma_17775 (h0 : topological_space (add_cancel_monoid (finset (has_add Type)))) : path_connected_space (add_cancel_monoid (finset (has_add Type))) := sorry --non-trivial
lemma new_lemma_17776 (h0 : topological_space (has_star (has_norm empty))) : normal_space (has_star (has_norm empty)) := sorry --non-trivial
lemma new_lemma_17777 (h0 : group (semigroup (has_to_string (has_to_string (has_to_string pos))))) : normalizer_condition (semigroup (has_to_string (has_to_string (has_to_string pos)))) := sorry --non-trivial
lemma new_lemma_17778 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (has_inter.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_inter.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_17779 (h0 : topological_space (has_bot unsigned)) : topological_space.separable_space (has_bot unsigned) := sorry --non-trivial
lemma new_lemma_17780 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (with_one.{0} linarith.ineq) (@function.extfun_app.{2 1} Type monoid.{0} h0 (with_one.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_17781 (h0 : topological_space (has_add (has_nndist (semigroup environment.implicit_infer_kind)))) : irreducible_space (has_add (has_nndist (semigroup environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_17782 (h0 : topological_space (preorder empty)) : normal_space (preorder empty) := sorry --non-trivial
lemma new_lemma_17783 (h0 : uniform_space (has_nndist (option (option (option (option (option empty))))))) : separated_space (has_nndist (option (option (option (option (option empty)))))) := sorry --non-trivial
lemma new_lemma_17784 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} nnreal (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) nnreal)  := sorry --non-trivial
lemma new_lemma_17785 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (has_norm.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_norm.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_17786 (h0 : functor.add_const (group (has_zero linarith.comp)) Type) : @group.fg.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 1} (group.{0} (has_zero.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_17787 (h0 : functor.add_const (function.extfun (Type 1) add_group) name) : @is_add_cyclic.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) add_group.{1}) name h0) (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_17788 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (has_nndist.{0} name) (@function.extfun_app.{2 1} Type monoid.{0} h0 (has_nndist.{0} name))  := sorry --non-trivial
lemma new_lemma_17789 (h0 : topological_space (has_nndist (comm_group unsigned))) : t0_space (has_nndist (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_17790 (h0 : topological_space (linear_ordered_semiring (random_gen (random_gen (random_gen congr_arg_kind))))) : discrete_topology (linear_ordered_semiring (random_gen (random_gen (random_gen congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_17791 (h0 : ring (simple_graph (ring pos))) : is_domain (simple_graph (ring pos)) := sorry --non-trivial
lemma new_lemma_17792 (h0 : functor.add_const (topological_space (finset name)) linarith.comp) : @loc_path_connected_space.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_17793 (h0 : finset (boolean_algebra.core environment.implicit_infer_kind)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_17794 (h0 : functor.add_const (topological_space (ordered_comm_ring pos)) pos) : @preirreducible_space.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_17795 (h0 : has_mem.mem (measurable_space num) has_emptyc.emptyc) : @locally_compact_space.{0} (measurable_space.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (measurable_space.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_17796 (h0 : topological_space (add_cancel_monoid (finset (finset linarith.comp)))) : locally_compact_space (add_cancel_monoid (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_17797 (h0 : function.extfun Type ring) : @is_domain.{0} (linear_ordered_field.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_ordered_field.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_17798 (h0 : fin has_zero.zero) : @strong_rank_condition.{0} (has_Inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ring.{0}) h0) (has_Inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_17799 (h0 : topological_space (finset (finset (finset linarith.comp)))) : regular_space (finset (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_17800 (h0 : group (has_inv (has_nnnorm char))) : group.fg (has_inv (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_17801 (h0 : complete_lattice (has_nndist (mul_zero_class pos))) : is_compactly_generated (has_nndist (mul_zero_class pos)) := sorry --non-trivial
lemma new_lemma_17802 (h0 : monoid (ring (finset environment.implicit_infer_kind))) : monoid.fg (ring (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_17803 (h0 : not (multiset (has_lt char) -> false)) (h1 : multiset (has_lt char)) : multiset.disjoint (classical.by_contradiction' h0) h1 := sorry --non-trivial
lemma new_lemma_17804 (h0 : functor.add_const (add_monoid (has_pos_part linarith.comp)) linarith.comp) : @add_monoid.fg.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_pos_part.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_17805 (h0 : not (add_group (metric_space num) -> false)) : @is_add_cyclic.{0} (metric_space.{0} num) (@classical.by_contradiction'.{1} (add_group.{0} (metric_space.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_17806 (h0 : topological_space (normed_comm_ring (ring (ring Type)))) : path_connected_space (normed_comm_ring (ring (ring Type))) := sorry --non-trivial
lemma new_lemma_17807 (h0 : group (generalized_boolean_algebra (has_add (has_Inf (has_add (has_nndist linarith.comp)))))) : group.fg (generalized_boolean_algebra (has_add (has_Inf (has_add (has_nndist linarith.comp))))) := sorry --non-trivial
lemma new_lemma_17808 (h0 : topological_space (has_nndist (finset environment.implicit_infer_kind))) : topological_space.separable_space (has_nndist (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_17809 (h0 : group (has_neg_part (option (has_neg_part name)))) : is_cyclic (has_neg_part (option (has_neg_part name))) := sorry --non-trivial
lemma new_lemma_17810 (h0 h1 : multiset (add_comm_semigroup (add_cancel_monoid environment.projection_info))) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_17811 (h0 : uniform_space (canonically_ordered_monoid linarith.comp)) : separated_space (canonically_ordered_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_17812 (h0 : functor.add_const (topological_space (non_assoc_semiring empty)) empty) : @irreducible_space.{0} (non_assoc_semiring.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (non_assoc_semiring.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_17813 (h0 : functor.add_const (complete_lattice (comm_group unsigned)) (has_to_string environment.implicit_infer_kind)) : @is_atomistic.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (comm_group.{0} unsigned)) (has_to_string.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_17814 (h0 : complete_lattice (normed_linear_ordered_group congr_arg_kind)) : is_compactly_generated (normed_linear_ordered_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_17815 (h0 : ordered_add_comm_monoid (add_cancel_monoid (has_Inf linarith.comp))) : archimedean (add_cancel_monoid (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_17816 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (with_bot linarith.ineq)) := sorry --non-trivial
lemma new_lemma_17817 (h0 : function.extfun (Type 1) topological_space) : @totally_disconnected_space.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_17818 (h0 : topological_space (mul_zero_class num)) : normal_space (mul_zero_class num) := sorry --non-trivial
lemma new_lemma_17819 (h0 : topological_space (has_nndist (ring (has_Inf Type)))) : path_connected_space (has_nndist (ring (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_17820 (h0 : not (add_group (add_monoid linarith.comp_source) -> false)) : @is_add_cyclic.{0} (add_monoid.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (add_group.{0} (add_monoid.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_17821 (h0 : function.extfun Type (functor.add_const (functor.add_const (topological_space empty) empty))) : locally_compact_space empty := sorry --non-trivial
lemma new_lemma_17822 (h0 : functor.add_const (topological_space (add_cancel_monoid Type)) linarith.comp) : @t0_space.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_cancel_monoid.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_17823 (h0 : functor.comp topological_space boolean_algebra.core name) : @regular_space.{0} (boolean_algebra.core.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} boolean_algebra.core.{0} name h0)  := sorry --non-trivial
lemma new_lemma_17824 (h0 : functor.add_const (ring (add_cancel_monoid Type)) (has_Inf linarith.comp)) : @is_domain.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (add_cancel_monoid.{1} Type)) (has_Inf.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_17825 (h0 : filter (plift congr_arg_kind)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_17826 (h0 : not (ring (has_union congr_arg_kind) -> false)) : @rank_condition.{0} (has_union.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (ring.{0} (has_union.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_17827 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_simple_group.{0} (add_comm_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (add_comm_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_17828 (h0 : list (add_semigroup congr_arg_kind)) (h1 : option (list (add_semigroup congr_arg_kind))) : palindrome (option.lhoare h0 h1) := sorry --non-trivial
lemma new_lemma_17829 (h0 : topological_space (complete_distrib_lattice unsigned)) : t0_space (complete_distrib_lattice unsigned) := sorry --non-trivial
lemma new_lemma_17830 (h0 : add_group (has_emptyc to_additive.value_type)) : is_add_cyclic (has_emptyc to_additive.value_type) := sorry --non-trivial
lemma new_lemma_17831 (h0 : topological_space (complete_distrib_lattice (ring linarith.comp))) : sequential_space (complete_distrib_lattice (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_17832 (h0 : functor.add_const (topological_space (is_R_or_C empty)) (semiring empty)) : @totally_disconnected_space.{0} (is_R_or_C.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (is_R_or_C.{0} empty)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_17833 (h0 : topological_space (linear_ordered_semiring (has_norm (has_norm (has_norm num))))) : path_connected_space (linear_ordered_semiring (has_norm (has_norm (has_norm num)))) := sorry --non-trivial
lemma new_lemma_17834 (h0 : group (has_nndist (finset (finset (canonically_linear_ordered_monoid pos))))) : group.fg (has_nndist (finset (finset (canonically_linear_ordered_monoid pos)))) := sorry --non-trivial
lemma new_lemma_17835 (h0 : filter (add_cancel_monoid (has_add (has_add Type)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_17836 (h0 : topological_space (normed_lattice_add_comm_group (has_neg name))) : discrete_topology (normed_lattice_add_comm_group (has_neg name)) := sorry --non-trivial
lemma new_lemma_17837 (h0 : function.extfun Type (functor.add_const (topological_space pos))) : @regular_space.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) name (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} pos)) h0 name))  := sorry --non-trivial
lemma new_lemma_17838 (h0 : ereal -> Prop) (h1 : filter ereal) : filter.frequently h0 h1 := sorry --non-trivial
lemma new_lemma_17839 (h0 : topological_space (has_Inf (ring linarith.comp))) : preconnected_space (has_Inf (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_17840 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (comm_group.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (comm_group.{0} name))  := sorry --non-trivial
lemma new_lemma_17841 (h0 : std_gen) (h1 : sym2 std_gen) : sym2.mem h0 h1 := sorry --non-trivial
lemma new_lemma_17842 (h0 : fin has_zero.zero) : @normalizer_condition.{0} (ring.{0} linarith.comp) (@matrix.vec_empty.{0} (group.{0} (ring.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_17843 (h0 : cancel_comm_monoid_with_zero (boolean_algebra.core (boolean_algebra.core pos))) : unique_factorization_monoid (boolean_algebra.core (boolean_algebra.core pos)) := sorry --non-trivial
lemma new_lemma_17844 (h0 : group (has_add (ring linarith.comp))) : is_cyclic (has_add (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_17845 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_bot.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_bot.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_17846 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (ordered_comm_group.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_group.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_17847 (h0 : function.extfun Type group) : @is_cyclic.{0} (ordered_comm_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} h0 (ordered_comm_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_17848 (h0 : topological_space (has_to_string (finset linarith.comp))) : topological_space.separable_space (has_to_string (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_17849 (h0 : function.extfun Type topological_space) : @t1_space.{0} (simple_graph.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (simple_graph.{0} num))  := sorry --non-trivial
lemma new_lemma_17850 (h0 : topological_space (has_norm (random_gen (random_gen (random_gen (random_gen fun_info)))))) : path_connected_space (has_norm (random_gen (random_gen (random_gen (random_gen fun_info))))) := sorry --non-trivial
lemma new_lemma_17851 (h0 : group (add_right_cancel_monoid to_additive.value_type)) : is_cyclic (add_right_cancel_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_17852 (h0 : ring (denumerable (comm_ring (random_gen char)))) : rank_condition (denumerable (comm_ring (random_gen char))) := sorry --non-trivial
lemma new_lemma_17853 (h0 : add_group (has_bot (has_Inf Type))) : is_add_cyclic (has_bot (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_17854 (h0 : function.extfun (Type 1) topological_space) : @t0_space.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_17855 (h1 : topological_space enat) (h2 : preorder enat) : order_closed_topology enat := sorry --non-trivial
lemma new_lemma_17856 (h0 : topological_space (add_monoid char)) : t0_space (add_monoid char) := sorry --non-trivial
lemma new_lemma_17857 (h0 : topological_space (add_comm_monoid (has_neg_part (has_add linarith.comp)))) : regular_space (add_comm_monoid (has_neg_part (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_17858 (h0 : functor.add_const (ring (has_add linarith.comp)) linarith.comp) : @is_principal_ideal_ring.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_add.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_17859 (h0 : has_mem.mem (has_emptyc fun_info) has_emptyc.emptyc) : @locally_compact_space.{0} (has_emptyc.{0} fun_info) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_emptyc.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_17860 (h0 : complete_lattice (has_ssubset (semi_normed_comm_ring string.iterator_imp))) : is_compactly_generated (has_ssubset (semi_normed_comm_ring string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_17861 (h0 : group (has_append (random_gen (random_gen (random_gen (random_gen (random_gen string_imp))))))) : is_cyclic (has_append (random_gen (random_gen (random_gen (random_gen (random_gen string_imp)))))) := sorry --non-trivial
lemma new_lemma_17862 (h0 : list (has_add (finset (finset (has_pos_part linarith.comp))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_17863 (h0 : group (has_nndist (finset (finset (add_comm_monoid ennreal))))) : is_simple_group (has_nndist (finset (finset (add_comm_monoid ennreal)))) := sorry --non-trivial
lemma new_lemma_17864 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @is_noetherian_ring.{0} (has_norm.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) semiring.{0}) (has_norm.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_17865 (h0 : functor.add_const (function.extfun (Type 1) topological_space) (has_neg name)) : @sequential_space.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) (has_neg.{0} name) h0) (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_17866 (h0 : topological_space (ring (finset (finset linarith.comp)))) : irreducible_space (ring (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_17867 (h1 : topological_space (normed_group fun_info)) : t0_space (normed_group fun_info) := sorry --non-trivial
lemma new_lemma_17868 (h0 : complete_lattice (has_neg_part (finset (complete_distrib_lattice pos)))) : is_atomistic (has_neg_part (finset (complete_distrib_lattice pos))) := sorry --non-trivial
lemma new_lemma_17869 (h0 : ring (has_to_string (comm_group name))) : rank_condition (has_to_string (comm_group name)) := sorry --non-trivial
lemma new_lemma_17870 (h0 : uniform_space (normed_field (normed_field std_gen))) : complete_space (normed_field (normed_field std_gen)) := sorry --non-trivial
lemma new_lemma_17871 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (has_norm.{0} string_imp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 complete_lattice.{0}) (has_norm.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_17872 (h0 : functor.add_const (topological_space (add_comm_monoid name)) linarith.comp) : @sequential_space.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_17873 (h0 : ring (semi_normed_comm_ring (has_nnnorm string.iterator_imp))) : rank_condition (semi_normed_comm_ring (has_nnnorm string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_17874 (h0 : group (plift unsigned)) : normalizer_condition (plift unsigned) := sorry --non-trivial
lemma new_lemma_17875 (h0 : topological_space (plift (has_top num))) : irreducible_space (plift (has_top num)) := sorry --non-trivial
lemma new_lemma_17876 (h0 : function.extfun Type (functor.add_const (topological_space (omega_complete_partial_order unsigned)))) : @topological_space.separable_space.{0} (omega_complete_partial_order.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (omega_complete_partial_order.{0} unsigned)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (omega_complete_partial_order.{0} unsigned))) h0 empty))  := sorry --non-trivial
lemma new_lemma_17877 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (group_with_zero.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (group_with_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_17878 (h0 : topological_space (simple_graph (ring linarith.comp))) : preconnected_space (simple_graph (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_17879 (h0 : functor.add_const (list (add_comm_monoid name)) environment.implicit_infer_kind) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_17880 (h0 : add_monoid (ring (semigroup Type))) : add_monoid.fg (ring (semigroup Type)) := sorry --non-trivial
lemma new_lemma_17881 (h0 : ring (has_neg name)) : is_principal_ideal_ring (has_neg name) := sorry --non-trivial
lemma new_lemma_17882 (h0 : functor.add_const Prop (has_neg Type)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_17883 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (bin_tree.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (bin_tree.{0} num))  := sorry --non-trivial
lemma new_lemma_17884 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (comm_group environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_17885 (h0 : topological_space (complete_distrib_lattice (option (option empty)))) : preirreducible_space (complete_distrib_lattice (option (option empty))) := sorry --non-trivial
lemma new_lemma_17886 (h0 : fin has_zero.zero) : @is_compactly_generated.{0} (has_pos_part.{0} real) (@matrix.vec_empty.{0} (complete_lattice.{0} (has_pos_part.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_17887 (h0 : uniform_space (has_top num)) : complete_space (has_top num) := sorry --non-trivial
lemma new_lemma_17888 (h0 : add_group (monoid_with_zero unsigned)) : is_add_cyclic (monoid_with_zero unsigned) := sorry --non-trivial
lemma new_lemma_17889 (h0 : topological_space (has_inv num)) : path_connected_space (has_inv num) := sorry --non-trivial
lemma new_lemma_17890 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (boolean_algebra.{0} (semigroup.{0} name)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.{0} (semigroup.{0} name)))  := sorry --non-trivial
lemma new_lemma_17891 (h0 : ring (distrib_lattice string_imp)) : strong_rank_condition (distrib_lattice string_imp) := sorry --non-trivial
lemma new_lemma_17892 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_17893 (h0 : ordered_add_comm_monoid (boolean_algebra.core (has_Inf linarith.comp))) : archimedean (boolean_algebra.core (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_17894 (h0 : topological_space (boolean_algebra (has_bot pos))) : preconnected_space (boolean_algebra (has_bot pos)) := sorry --non-trivial
lemma new_lemma_17895 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (canonically_ordered_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (canonically_ordered_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_17896 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (linear_ordered_add_comm_group.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_add_comm_group.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_17897 (h0 : functor.add_const (ring auto.case_option) num) : @is_principal_ideal_ring.{0} auto.case_option (@functor.add_const.run.{0 0} (ring.{0} auto.case_option) num h0)  := sorry --non-trivial
lemma new_lemma_17898 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @is_compactly_generated.{0} (has_star.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) complete_lattice.{0}) (has_star.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_17899 (h0 : function.extfun Type topological_space) : @t1_space.{0} (canonically_ordered_comm_semiring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_17900 (h0 : decidable_eq char) (h1 : add_comm_monoid char) (h2 : char -> add_submonoid char) : direct_sum.add_submonoid_is_internal h2 := sorry --non-trivial
lemma new_lemma_17901 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (add_semigroup.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (add_semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_17902 (h0 : add_group num -> Prop) (h1 : Exists (fun (x : add_group num), h0 x)) : @is_add_cyclic.{0} num (@classical.some.{1} (add_group.{0} num) h0 h1)  := sorry --non-trivial
lemma new_lemma_17903 (h0 : has_add ennreal -> has_add ennreal -> Prop) : is_symm (has_add ennreal) h0 := sorry --non-trivial
lemma new_lemma_17904 (h0 : group (add_comm_monoid (finset linarith.comp))) : normalizer_condition (add_comm_monoid (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_17905 (h0 : group (has_norm (has_norm unsigned))) : normalizer_condition (has_norm (has_norm unsigned)) := sorry --non-trivial
lemma new_lemma_17906 (h0 : add_group (with_one (has_inv (has_inv linarith.comp_source)))) : is_add_cyclic (with_one (has_inv (has_inv linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_17907 (h0 : group (boolean_algebra (finset unsigned))) : normalizer_condition (boolean_algebra (finset unsigned)) := sorry --non-trivial
lemma new_lemma_17908 (h0 : functor.add_const (ring (has_Inf pos)) Type) : @is_principal_ideal_ring.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (has_Inf.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_17909 (h0 : functor.add_const (topological_space (sub_neg_monoid pos)) Type) : @discrete_topology.{0} (sub_neg_monoid.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (sub_neg_monoid.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_17910 (h0 : group (has_ssubset (random_gen fun_info))) : group.fg (has_ssubset (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_17911 (h0 : functor.add_const (topological_space environment.implicit_infer_kind) linarith.comp) : @totally_separated_space.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 0} (topological_space.{0} environment.implicit_infer_kind) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_17912 (h0 : monoid (add_comm_monoid (add_cancel_monoid name))) : monoid.fg (add_comm_monoid (add_cancel_monoid name)) := sorry --non-trivial
lemma new_lemma_17913 (h0 : has_mem.mem (has_norm num) has_emptyc.emptyc) : @locally_compact_space.{0} (has_norm.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_norm.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_17914 (h0 : ring (nondiscrete_normed_field (add_comm_semigroup ereal))) : strong_rank_condition (nondiscrete_normed_field (add_comm_semigroup ereal)) := sorry --non-trivial
lemma new_lemma_17915 (h0 : monoid (has_norm (random_gen (has_norm (has_norm num))))) : monoid.fg (has_norm (random_gen (has_norm (has_norm num)))) := sorry --non-trivial
lemma new_lemma_17916 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_semilattice_Sup.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_17917 (h0 : topological_space (has_nndist (ring (finset linarith.comp)))) : discrete_topology (has_nndist (ring (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_17918 (h0 : functor.add_const (topological_space (omega_complete_partial_order empty)) empty) : @normal_space.{0} (omega_complete_partial_order.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (omega_complete_partial_order.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_17919 (h0 : not (add_monoid (normed_group congr_arg_kind) -> false)) : @add_monoid.fg.{0} (normed_group.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (add_monoid.{0} (normed_group.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_17920 (h0 : not (function.extfun Type topological_space -> false)) : @discrete_topology.{0} (has_top.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_top.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_17921 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (linear_ordered_cancel_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type semiring.{0} h0 (linear_ordered_cancel_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_17922 (h0 : add_monoid (boolean_algebra (has_bot (has_pos_part real)))) : add_monoid.fg (boolean_algebra (has_bot (has_pos_part real))) := sorry --non-trivial
lemma new_lemma_17923 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_17924 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (sub_neg_monoid.{0} real) (@function.extfun_app.{2 1} Type monoid.{0} h0 (sub_neg_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_17925 (h0 : ring (canonically_linear_ordered_monoid Type)) : strong_rank_condition (canonically_linear_ordered_monoid Type) := sorry --non-trivial
lemma new_lemma_17926 (h0 : topological_space (ordered_ring (semiring (semiring empty)))) : path_connected_space (ordered_ring (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_17927 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (has_neg.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_17928 (h0 : functor.add_const (topological_space (add_cancel_monoid environment.implicit_infer_kind)) unsigned) : @preirreducible_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_17929 (h0 : ring (mul_zero_class (option pos))) : is_domain (mul_zero_class (option pos)) := sorry --non-trivial
lemma new_lemma_17930 (h0 : ordered_add_comm_monoid (has_Sup (option unsigned))) : archimedean (has_Sup (option unsigned)) := sorry --non-trivial
lemma new_lemma_17931 (h0 : complete_lattice (has_pos_part (has_neg name))) : is_atomistic (has_pos_part (has_neg name)) := sorry --non-trivial
lemma new_lemma_17932 (h0 : semiring (ring empty)) : is_noetherian_ring (ring empty) := sorry --non-trivial
lemma new_lemma_17933 (h0 : topological_space (semi_normed_comm_ring enat)) : t0_space (semi_normed_comm_ring enat) := sorry --non-trivial
lemma new_lemma_17934 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (preorder.{0} (option.{0} unsigned)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (preorder.{0} (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_17935 (h0 : not (topological_space linarith.comp -> false)) : @path_connected_space.{0} linarith.comp (@classical.by_contradiction'.{1} (topological_space.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_17936 (h0 : ordered_comm_monoid (boolean_algebra (normed_comm_ring environment.implicit_infer_kind))) : has_exists_mul_of_le (boolean_algebra (normed_comm_ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_17937 (h3 : add_group (has_div string_imp)) : is_add_cyclic (has_div string_imp) := sorry --non-trivial
lemma new_lemma_17938 (h0 : topological_space (comm_semigroup (has_bot name))) : t1_space (comm_semigroup (has_bot name)) := sorry --non-trivial
lemma new_lemma_17939 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (random_gen.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (random_gen.{0} empty))  := sorry --non-trivial
lemma new_lemma_17940 (h0 : group (has_zero linarith.comp)) : normalizer_condition (has_zero linarith.comp) := sorry --non-trivial
lemma new_lemma_17941 (h1 : ring (denumerable (random_gen reducibility_hints))) : rank_condition (denumerable (random_gen reducibility_hints)) := sorry --non-trivial
lemma new_lemma_17942 (h0 : not (has_mem.mem empty has_emptyc.emptyc -> false)) : @is_atomistic.{0} empty (@finset.pi.empty.{1 0} Type complete_lattice.{0} empty (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) empty (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_17943 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (complete_semilattice_Sup.{0} linarith.ineq) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (complete_semilattice_Sup.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_17944 (h0 : ring (with_bot string_imp)) : is_domain (with_bot string_imp) := sorry --non-trivial
lemma new_lemma_17945 (h0 : complete_lattice (has_norm (random_gen (random_gen (random_gen num))))) : is_compactly_generated (has_norm (random_gen (random_gen (random_gen num)))) := sorry --non-trivial
lemma new_lemma_17946 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (has_star.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (has_star.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_17947 (h0 : ring (multiplicative environment.projection_info)) : is_domain (multiplicative environment.projection_info) := sorry --non-trivial
lemma new_lemma_17948 (h0 : functor.add_const (topological_space (has_neg Type)) environment.implicit_infer_kind) : @preirreducible_space.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_neg.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_17949 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_sub.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_sub.{0} empty))  := sorry --non-trivial
lemma new_lemma_17950 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (normed_group.{0} num) (@function.extfun_app.{2 1} Type add_group.{0} h0 (normed_group.{0} num))  := sorry --non-trivial
lemma new_lemma_17951 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (has_add.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_add.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_17952 (h0 : complete_lattice (measurable_space (random_gen (random_gen linarith.comp_source)))) : is_atomistic (measurable_space (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_17953 (h0 : functor.add_const (cancel_comm_monoid_with_zero (add_cancel_monoid unsigned)) unsigned) : @unique_factorization_monoid.{0} (add_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (add_cancel_monoid.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_17954 (h0 : finset (boolean_algebra.core (option (option (option unsigned))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_17955 (h1 : set (non_unital_non_assoc_semiring linarith.ineq)) : set.finite h1 := sorry --non-trivial
lemma new_lemma_17956 (h0 : list Type) : palindrome h0 := sorry --non-trivial
lemma new_lemma_17957 (h0 : topological_space (has_neg (has_to_string pos))) : normal_space (has_neg (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_17958 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (normed_comm_ring unsigned)) := sorry --non-trivial
lemma new_lemma_17959 (h0 : functor.add_const (topological_space (left_cancel_semigroup congr_arg_kind)) unsigned) : @totally_separated_space.{0} (left_cancel_semigroup.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_semigroup.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_17960 (h0 : function.extfun Type topological_space) : @normal_space.{0} (measurable_space.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measurable_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_17961 (h0 : function.extfun (finset Type) (has_mem.mem (has_top num))) : @strong_rank_condition.{0} (has_top.{0} num) (@finset.pi.empty.{1 0} Type ring.{0} (has_top.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_top.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_17962 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_simple_group.{0} (has_pos_part.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_pos_part.{0} name))  := sorry --non-trivial
lemma new_lemma_17963 (h0 : group (comm_group (ring (finset Type)))) : is_cyclic (comm_group (ring (finset Type))) := sorry --non-trivial
lemma new_lemma_17964 (h0 : topological_space (semigroup (has_pos_part linarith.comp))) : sequential_space (semigroup (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_17965 (h0 : topological_space (has_to_string Type)) : loc_path_connected_space (has_to_string Type) := sorry --non-trivial
lemma new_lemma_17966 (h1 : ring (denumerable (has_nnnorm char))) : is_domain (denumerable (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_17967 (h0 : topological_space (semigroup (has_neg name))) : topological_space.separable_space (semigroup (has_neg name)) := sorry --non-trivial
lemma new_lemma_17968 (h0 : monoid (has_union (has_norm (add_group empty)))) : monoid.fg (has_union (has_norm (add_group empty))) := sorry --non-trivial
lemma new_lemma_17969 (h0 : ring (comm_group (add_cancel_monoid name))) : rank_condition (comm_group (add_cancel_monoid name)) := sorry --non-trivial
lemma new_lemma_17970 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_emptyc.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_emptyc.{0} num))  := sorry --non-trivial
lemma new_lemma_17971 (h0 : topological_space (has_norm (has_norm (has_norm linarith.comp)))) : discrete_topology (has_norm (has_norm (has_norm linarith.comp))) := sorry --non-trivial
lemma new_lemma_17972 (h0 : function.extfun Type ring) : @is_domain.{0} unsigned (@function.extfun_app.{2 1} Type ring.{0} h0 unsigned)  := sorry --non-trivial
lemma new_lemma_17973 (h0 : function.extfun Type (functor.add_const (filter Prop))) : @filter.Limsup.{0} Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice) (@functor.add_const.run.{0 0} (filter.{0} Prop) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (filter.{0} Prop)) h0 num))  := sorry --non-trivial
lemma new_lemma_17974 (h0 : complete_lattice (has_lt to_additive.value_type)) : is_compactly_generated (has_lt to_additive.value_type) := sorry --non-trivial
lemma new_lemma_17975 (h0 : topological_space (has_inter (option ennreal))) : normal_space (has_inter (option ennreal)) := sorry --non-trivial
lemma new_lemma_17976 (h0 : topological_space (has_le (has_ssubset string.iterator_imp))) : t0_space (has_le (has_ssubset string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_17977 (h0 : add_group (pseudo_metric_space (option (option unsigned)))) : is_add_cyclic (pseudo_metric_space (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_17978 (h0 : complete_lattice (mul_one_class (non_unital_non_assoc_semiring enat))) : is_compactly_generated (mul_one_class (non_unital_non_assoc_semiring enat)) := sorry --non-trivial
lemma new_lemma_17979 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (has_top.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_top.{0} empty))  := sorry --non-trivial
lemma new_lemma_17980 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @preconnected_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (boolean_algebra.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_17981 (h0 : functor.comp group has_to_string (option (option pos))) : @is_simple_group.{0} (has_to_string.{0} (option.{0} (option.{0} pos))) (@functor.comp.run.{0 0 0} group.{0} has_to_string.{0} (option.{0} (option.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_17982 (h0 : ring (pseudo_metric_space (option (option (option empty))))) : strong_rank_condition (pseudo_metric_space (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_17983 (h0 : functor.add_const (group (pseudo_metric_space ennreal)) unsigned) : @is_simple_group.{0} (pseudo_metric_space.{0} ennreal) (@functor.add_const.run.{0 0} (group.{0} (pseudo_metric_space.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_17984 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (linear_ordered_semiring.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_17985 (h0 : topological_space (measurable_space.dynkin_system (semiring (semiring num)))) : normal_space (measurable_space.dynkin_system (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_17986 (h0 : topological_space (has_nndist (normed_comm_ring environment.implicit_infer_kind))) : t1_space (has_nndist (normed_comm_ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_17987 (h0 : group (complete_distrib_lattice (has_Inf linarith.comp))) : normalizer_condition (complete_distrib_lattice (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_17988 (h0 : semiring (has_add (has_Inf real))) : is_noetherian_ring (has_add (has_Inf real)) := sorry --non-trivial
lemma new_lemma_17989 (h0 : function.extfun (Type 1) add_monoid) : @add_monoid.fg.{1} (complete_distrib_lattice.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_monoid.{1} h0 (complete_distrib_lattice.{1} Type))  := sorry --non-trivial
lemma new_lemma_17990 (h0 : ring (has_Inf (has_add (ordered_ring linarith.comp)))) : is_domain (has_Inf (has_add (ordered_ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_17991 (h0 : add_monoid (add_comm_monoid (ring (has_neg linarith.comp)))) : add_monoid.fg (add_comm_monoid (ring (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_17992 (h0 : ring (finset (boolean_algebra Type))) : strong_rank_condition (finset (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_17993 (h0 : cancel_comm_monoid_with_zero (has_pos_part (has_add name))) : unique_factorization_monoid (has_pos_part (has_add name)) := sorry --non-trivial
lemma new_lemma_17994 (h0 : group (ordered_ring num)) : group.fg (ordered_ring num) := sorry --non-trivial
lemma new_lemma_17995 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (has_Inf.{0} (boolean_algebra.{0} linarith.comp)) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_Inf.{0} (boolean_algebra.{0} linarith.comp)))  := sorry --non-trivial
lemma new_lemma_17996 (h0 : ring (denumerable (random_gen fun_info))) : strong_rank_condition (denumerable (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_17997 (h0 : functor.add_const (function.extfun Type add_group) pos) : @is_add_cyclic.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_group.{0}) pos h0) (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_17998 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_17999 (h0 : not (complete_lattice (has_lt (mul_one_class (mul_one_class (mul_one_class char)))) -> false)) : @is_compactly_generated.{0} (has_lt.{0} (mul_one_class.{0} (mul_one_class.{0} (mul_one_class.{0} char)))) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_lt.{0} (mul_one_class.{0} (mul_one_class.{0} (mul_one_class.{0} char))))) h0)  := sorry --non-trivial
lemma new_lemma_18000 (h0 : ring (boolean_algebra.core num)) : rank_condition (boolean_algebra.core num) := sorry --non-trivial
lemma new_lemma_18001 (h0 : ring (semigroup (finset (ring Type)))) : is_domain (semigroup (finset (ring Type))) := sorry --non-trivial
lemma new_lemma_18002 (h0 : functor.add_const (function.extfun (Type 1) group) Type) : @group.fg.{1} (add_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) group.{1}) Type h0) (add_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_18003 (h0 : topological_space (add_group (ordered_semiring (has_norm (has_norm unsigned))))) : path_connected_space (add_group (ordered_semiring (has_norm (has_norm unsigned)))) := sorry --non-trivial
lemma new_lemma_18004 (h0 : topological_space (with_bot (semiring (semiring (semiring (semiring (semiring empty))))))) : discrete_topology (with_bot (semiring (semiring (semiring (semiring (semiring empty)))))) := sorry --non-trivial
lemma new_lemma_18005 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (semiring.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_18006 (h0 : functor.add_const (complete_lattice (has_nndist name)) ennreal) : @complete_lattice.is_Sup_finite_compact.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_nndist.{0} name)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_18007 (h0 : topological_space (has_neg_part num)) : t0_space (has_neg_part num) := sorry --non-trivial
lemma new_lemma_18008 (h2 : topological_space (distrib char)) : path_connected_space (distrib char) := sorry --non-trivial
lemma new_lemma_18009 (h0 : uniform_space (id fun_info)) : complete_space (id fun_info) := sorry --non-trivial
lemma new_lemma_18010 (h0 : monoid (ring (measurable_space linarith.comp))) : monoid.fg (ring (measurable_space linarith.comp)) := sorry --non-trivial
lemma new_lemma_18011 (h0 : function.extfun (Type 1) (functor.add_const (add_monoid (ordered_comm_monoid linarith.comp)))) : @add_monoid.fg.{0} (ordered_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (add_monoid.{0} (ordered_comm_monoid.{0} linarith.comp)) Type (@function.extfun_app.{3 1} (Type 1) (functor.add_const.{0 1} (add_monoid.{0} (ordered_comm_monoid.{0} linarith.comp))) h0 Type))  := sorry --non-trivial
lemma new_lemma_18012 (h0 : uniform_space (semigroup unsigned)) : separated_space (semigroup unsigned) := sorry --non-trivial
lemma new_lemma_18013 (h0 : filter (preorder unsigned)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_18014 (h0 : functor.add_const (function.extfun (Type 1) add_group) Type) : @is_add_cyclic.{1} (generalized_boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_group.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) add_group.{1}) Type h0) (generalized_boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_18015 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (has_neg.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (has_neg.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_18016 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} (measurable_space.{0} linarith.ineq) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (measurable_space.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_18017 (h0 : add_group (has_neg char)) : is_add_cyclic (has_neg char) := sorry --non-trivial
lemma new_lemma_18018 (h0 : functor.add_const (ring (add_left_cancel_semigroup num)) empty) : @is_principal_ideal_ring.{0} (add_left_cancel_semigroup.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (add_left_cancel_semigroup.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_18019 (h0 : fin has_zero.zero) : @is_simple_group.{0} (complete_distrib_lattice.{0} pos) (@matrix.vec_empty.{0} (group.{0} (complete_distrib_lattice.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_18020 (h0 : topological_space (has_bot name)) : locally_compact_space (has_bot name) := sorry --non-trivial
lemma new_lemma_18021 (h1 : complete_lattice (complete_semilattice_Sup fun_info)) : is_compactly_generated (complete_semilattice_Sup fun_info) := sorry --non-trivial
lemma new_lemma_18022 (h0 : group (normed_group (has_nnnorm fun_info))) : group.fg (normed_group (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_18023 (h0 : Prop) (h1 : not h0) (h2 : h0) : not.elim h1 h2 := sorry --trivial
lemma new_lemma_18024 (h0 : topological_space (complete_distrib_lattice environment.implicit_infer_kind)) : t0_space (complete_distrib_lattice environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_18025 (h0 : function.extfun Type topological_space) : @normal_space.{0} (cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_18026 (h0 : functor.add_const (topological_space (complete_distrib_lattice name)) linarith.comp) : @preirreducible_space.{0} (complete_distrib_lattice.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_18027 (h0 : monoid (has_zero (ring linarith.comp))) : monoid.fg (has_zero (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_18028 (h0 : function.extfun (Type 1) (functor.add_const (group (semigroup linarith.comp)))) : @group.fg.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 1} (group.{0} (semigroup.{0} linarith.comp)) Type (@function.extfun_app.{3 1} (Type 1) (functor.add_const.{0 1} (group.{0} (semigroup.{0} linarith.comp))) h0 Type))  := sorry --non-trivial
lemma new_lemma_18029 (h0 : group (has_add (ring (ring Type)))) : is_cyclic (has_add (ring (ring Type))) := sorry --non-trivial
lemma new_lemma_18030 (h0 : functor.add_const (topological_space (complete_distrib_lattice pos)) Type) : @sequential_space.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (complete_distrib_lattice.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_18031 (h0 : not (function.extfun Type topological_space -> false)) : @irreducible_space.{0} (metric_space.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (metric_space.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_18032 (h0 : not (complete_lattice (add_cancel_comm_monoid linarith.comp_source) -> false)) : @is_compactly_generated.{0} (add_cancel_comm_monoid.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (complete_lattice.{0} (add_cancel_comm_monoid.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_18033 (h0 : topological_space (boolean_algebra.core (has_neg_part Type))) : totally_separated_space (boolean_algebra.core (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_18034 (h0 : function.extfun Type group) : @group.fg.{0} (comm_group.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} h0 (comm_group.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_18035 (h0 : list (with_bot (random_gen string_imp))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_18036 (h0 : group (normed_comm_ring (comm_group (has_to_string (has_to_string unsigned))))) : group.fg (normed_comm_ring (comm_group (has_to_string (has_to_string unsigned)))) := sorry --non-trivial
lemma new_lemma_18037 (h0 : uniform_space (has_add (has_pos_part Type))) : complete_space (has_add (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_18038 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (add_group.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (add_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_18039 (h0 : has_mem.mem (random_gen (semiring empty)) has_emptyc.emptyc) : @discrete_topology.{0} (random_gen.{0} (semiring.{0} empty)) (@finset.pi.empty.{1 0} Type topological_space.{0} (random_gen.{0} (semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_18040 (h0 : topological_space (has_emptyc (has_norm empty))) : discrete_topology (has_emptyc (has_norm empty)) := sorry --non-trivial
lemma new_lemma_18041 (h0 : uniform_space (boolean_algebra.core (has_neg (ring Type)))) : separated_space (boolean_algebra.core (has_neg (ring Type))) := sorry --non-trivial
lemma new_lemma_18042 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (bin_tree.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (bin_tree.{0} empty))  := sorry --non-trivial
lemma new_lemma_18043 (h0 : functor.add_const (topological_space (complete_distrib_lattice unsigned)) environment.implicit_infer_kind) : @normal_space.{0} (complete_distrib_lattice.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_18044 (h0 : topological_space (normed_group (random_gen (random_gen num)))) : irreducible_space (normed_group (random_gen (random_gen num))) := sorry --non-trivial
lemma new_lemma_18045 (h0 : not (function.extfun Type topological_space -> false)) : @discrete_topology.{0} (mul_zero_class.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (mul_zero_class.{0} empty))  := sorry --non-trivial
lemma new_lemma_18046 (h0 : functor.add_const (finset (has_nndist name)) Type) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_18047 (h0 : functor.add_const (semiring (ordered_ring num)) unsigned) : @is_noetherian_ring.{0} (ordered_ring.{0} num) (@functor.add_const.run.{0 0} (semiring.{0} (ordered_ring.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_18048 (h0 : functor.add_const (ordered_add_comm_monoid (has_Inf linarith.comp)) name) : @archimedean.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_Inf.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_18049 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @locally_compact_space.{0} (complete_distrib_lattice.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (complete_distrib_lattice.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_18050 (h0 : filter (ordered_comm_ring (ring (has_pos_part Type)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_18051 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (add_comm_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_18052 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_18053 (h0 : finset (semigroup (semigroup (has_pos_part pos)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_18054 (h0 : function.extfun Type topological_space) : @normal_space.{0} (partial_order.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (partial_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_18055 (h0 : add_monoid (has_zero (ring linarith.comp))) : add_monoid.fg (has_zero (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_18056 (h0 : functor.add_const (topological_space (normed_comm_ring environment.implicit_infer_kind)) Type) : @topological_space.separable_space.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (normed_comm_ring.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_18057 (h0 : functor.add_const (topological_space ennreal) unsigned) : loc_path_connected_space ennreal := sorry --non-trivial
lemma new_lemma_18058 (h0 : topological_space (monoid pos)) : totally_disconnected_space (monoid pos) := sorry --non-trivial
lemma new_lemma_18059 (h0 : add_group (canonically_ordered_comm_semiring (has_neg (has_neg (has_nndist (finset pos)))))) : is_add_cyclic (canonically_ordered_comm_semiring (has_neg (has_neg (has_nndist (finset pos))))) := sorry --non-trivial
lemma new_lemma_18060 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (with_bot.{0} num) (@function.extfun_app.{2 1} Type add_group.{0} h0 (with_bot.{0} num))  := sorry --non-trivial
lemma new_lemma_18061 (h0 : topological_space (pseudo_emetric_space Type)) : preconnected_space (pseudo_emetric_space Type) := sorry --non-trivial
lemma new_lemma_18062 (h0 : topological_space (has_top string_imp)) : locally_compact_space (has_top string_imp) := sorry --non-trivial
lemma new_lemma_18063 (h0 : measurable_space (comm_ring char)) (h1 : has_inf (comm_ring char)) : has_measurable_inf₂ (comm_ring char) := sorry --non-trivial
lemma new_lemma_18064 (h0 : topological_space (has_zero (finset (has_to_string environment.implicit_infer_kind)))) : t1_space (has_zero (finset (has_to_string environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_18065 (h0 : monoid (with_one num)) : monoid.fg (with_one num) := sorry --non-trivial
lemma new_lemma_18066 (h0 : functor.add_const (uniform_space (has_neg_part name)) name) : @separated_space.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_neg_part.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_18067 (h0 : functor.add_const (topological_space (has_nndist pos)) Type) : @t0_space.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_nndist.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_18068 (h0 : add_monoid (add_cancel_monoid num)) : add_monoid.fg (add_cancel_monoid num) := sorry --non-trivial
lemma new_lemma_18069 (h0 : function.extfun Type monoid) (h1 : option (monoid (complete_linear_order num))) : @monoid.fg.{0} (complete_linear_order.{0} num) (@option.lhoare.{0} (monoid.{0} (complete_linear_order.{0} num)) (@function.extfun_app.{2 1} Type monoid.{0} h0 (complete_linear_order.{0} num)) h1)  := sorry --non-trivial
lemma new_lemma_18070 (h0 : complete_lattice (boolean_algebra.core (finset name))) : is_compactly_generated (boolean_algebra.core (finset name)) := sorry --non-trivial
lemma new_lemma_18071 (h0 : topological_space (has_to_string (has_to_string environment.implicit_infer_kind))) : totally_disconnected_space (has_to_string (has_to_string environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_18072 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (semiring.{0} fun_info) (@function.extfun_app.{2 1} Type add_group.{0} h0 (semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_18073 (h0 : add_group (normed_field (mul_one_class (mul_one_class environment.projection_info)))) : is_add_cyclic (normed_field (mul_one_class (mul_one_class environment.projection_info))) := sorry --non-trivial
lemma new_lemma_18074 (h1 : has_lt (mul_one_class (normed_field std_gen))) : no_max_order (mul_one_class (normed_field std_gen)) := sorry --non-trivial
lemma new_lemma_18075 (h0 : functor.add_const (topological_space (finset linarith.comp)) pos) : @t1_space.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_18076 (h0 : topological_space (ring (has_pos_part linarith.comp))) : loc_path_connected_space (ring (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_18077 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_to_string.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_to_string.{0} name))  := sorry --non-trivial
lemma new_lemma_18078 (h0 : functor.comp topological_space comm_group name) : @sequential_space.{0} (comm_group.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} comm_group.{0} name h0)  := sorry --non-trivial
lemma new_lemma_18079 (h0 : ring (has_to_string pos)) : rank_condition (has_to_string pos) := sorry --non-trivial
lemma new_lemma_18080 (h0 : ring (generalized_boolean_algebra (has_add pos))) : rank_condition (generalized_boolean_algebra (has_add pos)) := sorry --non-trivial
lemma new_lemma_18081 (h0 : functor.add_const (function.extfun Type list) (ring (ring name))) : list.nodup (function.extfun_app (functor.add_const.run h0) (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_18082 (h0 : ring (complete_semilattice_Sup (has_norm empty))) : is_domain (complete_semilattice_Sup (has_norm empty)) := sorry --non-trivial
lemma new_lemma_18083 (h0 : function.extfun Type topological_space) : @t1_space.{0} (canonically_ordered_comm_semiring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} pos))  := sorry --non-trivial
lemma new_lemma_18084 (h0 : linarith.comp_source -> linarith.comp_source -> linarith.comp_source) : left_cancelative h0 := sorry --non-trivial
lemma new_lemma_18085 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (linear_ordered_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_18086 (h0 : function.extfun Type ring) : @is_domain.{0} (comm_group.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (comm_group.{0} name))  := sorry --non-trivial
lemma new_lemma_18087 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (linear_ordered_comm_ring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_18088 (h0 : ring (normed_group linarith.ineq)) : strong_rank_condition (normed_group linarith.ineq) := sorry --non-trivial
lemma new_lemma_18089 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_to_string.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_18090 (h0 : finset (partial_order num)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_18091 (h0 : topological_space (has_top (random_gen (random_gen (has_norm fun_info))))) : totally_disconnected_space (has_top (random_gen (random_gen (has_norm fun_info)))) := sorry --non-trivial
lemma new_lemma_18092 (h0 : functor.add_const (function.extfun Type topological_space) name) : @regular_space.{0} (complete_distrib_lattice.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (complete_distrib_lattice.{0} pos))  := sorry --non-trivial
lemma new_lemma_18093 (h0 : functor.add_const (finset (boolean_algebra name)) Type) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_18094 (h2 : complete_lattice (with_one (has_top num))) : is_compactly_generated (with_one (has_top num)) := sorry --non-trivial
lemma new_lemma_18095 (h0 : group (normed_linear_ordered_group unsigned)) : is_cyclic (normed_linear_ordered_group unsigned) := sorry --non-trivial
lemma new_lemma_18096 (h0 : topological_space (finset unsigned)) : locally_compact_space (finset unsigned) := sorry --non-trivial
lemma new_lemma_18097 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (preorder.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (preorder.{0} empty))  := sorry --non-trivial
lemma new_lemma_18098 (h0 : group (comm_semigroup (has_add (ordered_comm_monoid real)))) : is_simple_group (comm_semigroup (has_add (ordered_comm_monoid real))) := sorry --non-trivial
lemma new_lemma_18099 (h3 : ring (comm_ring (denumerable (denumerable char)))) : is_domain (comm_ring (denumerable (denumerable char))) := sorry --non-trivial
lemma new_lemma_18100 (h0 : uniform_space (distrib (has_nnnorm linarith.ineq))) : complete_space (distrib (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_18101 (h0 : functor.add_const (add_group (add_cancel_monoid Type)) Type) : @is_add_cyclic.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 1} (add_group.{1} (add_cancel_monoid.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_18102 (h0 : ring (with_zero to_additive.value_type)) : strong_rank_condition (with_zero to_additive.value_type) := sorry --non-trivial
lemma new_lemma_18103 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (normed_group.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (normed_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_18104 (h0 : topological_space (has_inv (random_gen string_imp))) : irreducible_space (has_inv (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_18105 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (normed_comm_ring.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (normed_comm_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_18106 (h0 : topological_space (normed_comm_ring (has_to_string (has_to_string ennreal)))) : preirreducible_space (normed_comm_ring (has_to_string (has_to_string ennreal))) := sorry --non-trivial
lemma new_lemma_18107 (h0 : group (canonically_ordered_comm_semiring (finset Type))) : normalizer_condition (canonically_ordered_comm_semiring (finset Type)) := sorry --non-trivial
lemma new_lemma_18108 (h0 : topological_space (cancel_monoid (option empty))) : preconnected_space (cancel_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_18109 (h0 : not (ring (uniform_space enat) -> false)) : @strong_rank_condition.{0} (uniform_space.{0} enat) (@classical.by_contradiction'.{1} (ring.{0} (uniform_space.{0} enat)) h0)  := sorry --non-trivial
lemma new_lemma_18110 (h0 : complete_lattice (add_comm_monoid (finset (has_to_string name)))) : complete_lattice.is_Sup_finite_compact (add_comm_monoid (finset (has_to_string name))) := sorry --non-trivial
lemma new_lemma_18111 (h0 : ring (simple_graph linarith.comp)) : is_domain (simple_graph linarith.comp) := sorry --non-trivial
lemma new_lemma_18112 (h0 : topological_space (id (random_gen (random_gen (random_gen to_additive.value_type))))) : locally_compact_space (id (random_gen (random_gen (random_gen to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_18113 (h0 : complete_lattice (add_group linarith.comp)) : complete_lattice.is_Sup_finite_compact (add_group linarith.comp) := sorry --non-trivial
lemma new_lemma_18114 (h0 : functor.add_const (functor.add_const Prop empty) (option (option empty))) : functor.add_const.run (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_18115 (h0 : topological_space (topological_space (comm_ring char))) : t0_space (topological_space (comm_ring char)) := sorry --non-trivial
lemma new_lemma_18116 (h0 : topological_space (has_add num)) : path_connected_space (has_add num) := sorry --non-trivial
lemma new_lemma_18117 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (simple_graph.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (simple_graph.{0} name))  := sorry --non-trivial
lemma new_lemma_18118 (h0 : filter (has_to_string (finset unsigned))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_18119 (h0 : function.extfun Type group) : @is_cyclic.{0} (mv_power_series.{0 0} (has_edist.{0} empty) congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (mv_power_series.{0 0} (has_edist.{0} empty) congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_18120 (h0 : topological_space (complete_distrib_lattice unsigned)) : sequential_space (complete_distrib_lattice unsigned) := sorry --non-trivial
lemma new_lemma_18121 (h0 : filter (simple_graph (sub_neg_monoid linarith.comp))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_18122 (h0 : topological_space (semigroup (has_add ennreal))) : topological_space.separable_space (semigroup (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_18123 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_add.{0} real) (@function.extfun_app.{2 1} Type group.{0} h0 (has_add.{0} real))  := sorry --non-trivial
lemma new_lemma_18124 (h0 : not (list (complete_semilattice_Sup linarith.comp_source) -> false)) : list.nodup (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_18125 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_zero linarith.comp)) name) : @unique_factorization_monoid.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_zero.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_18126 (h0 : topological_space (monoid_with_zero pos)) : normal_space (monoid_with_zero pos) := sorry --non-trivial
lemma new_lemma_18127 (h0 : functor.add_const (monoid (boolean_algebra.core environment.implicit_infer_kind)) Type) : @monoid.fg.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (monoid.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_18128 (h0 : topological_space (add_cancel_monoid (finset ennreal))) : discrete_topology (add_cancel_monoid (finset ennreal)) := sorry --non-trivial
lemma new_lemma_18129 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} fun_info (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 fun_info)  := sorry --non-trivial
lemma new_lemma_18130 (h0 : group (denumerable (has_norm linarith.comp_source))) : is_cyclic (denumerable (has_norm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_18131 (h0 : has_mem.mem uniform_space has_emptyc.emptyc) : @separated_space.{0} unsigned (@function.extfun_app.{2 1} Type uniform_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) uniform_space.{0} h0) unsigned)  := sorry --non-trivial
lemma new_lemma_18132 (h0 : finset (left_cancel_monoid empty)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_18133 (h0 : functor.add_const (complete_lattice (normed_group empty)) empty) : @complete_lattice.is_Sup_finite_compact.{0} (normed_group.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (normed_group.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_18134 (h0 : topological_space (measure_theory.measure_space (semiring num))) : path_connected_space (measure_theory.measure_space (semiring num)) := sorry --non-trivial
lemma new_lemma_18135 (h1 : ring (topological_space (comm_ring reducibility_hints))) : rank_condition (topological_space (comm_ring reducibility_hints)) := sorry --non-trivial
lemma new_lemma_18136 (h0 : ring (plift (option (option unsigned)))) : is_domain (plift (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_18137 (h0 : topological_space (comm_group (semigroup pos))) : normal_space (comm_group (semigroup pos)) := sorry --non-trivial
lemma new_lemma_18138 (h0 : ordered_add_comm_monoid (has_pos_part (has_Inf (ring (finset Type))))) : archimedean (has_pos_part (has_Inf (ring (finset Type)))) := sorry --non-trivial
lemma new_lemma_18139 (h0 : functor.add_const (function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) linarith.comp) : finset.nonempty (function.extfun_app (function.extfun_app (functor.add_const.run h0) finset) Type) := sorry --non-trivial
lemma new_lemma_18140 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (linear_ordered_field.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_field.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_18141 (h0 : functor.add_const (ring (free_add_monoid unsigned)) unsigned) : @is_principal_ideal_ring.{0} (free_add_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (free_add_monoid.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_18142 (h0 h1 : list (add_comm_semigroup fun_info)) : list.is_infix h0 h1 := sorry --non-trivial
lemma new_lemma_18143 (h0 : group (linear_ordered_field ennreal)) : normalizer_condition (linear_ordered_field ennreal) := sorry --non-trivial
lemma new_lemma_18144 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (canonically_ordered_comm_semiring.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (canonically_ordered_comm_semiring.{0} pos))  := sorry --non-trivial
lemma new_lemma_18145 (h0 : not (ring (semi_normed_ring char) -> false)) : @strong_rank_condition.{0} (semi_normed_ring.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (semi_normed_ring.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_18146 (h0 : filter (filter (semigroup congr_arg_kind))) : countable_Inter_filter (filter.Limsup h0) := sorry --non-trivial
lemma new_lemma_18147 (h0 : functor.add_const (topological_space (has_neg_part Type)) name) : @path_connected_space.{1} (has_neg_part.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_neg_part.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_18148 (h0 : functor.add_const (topological_space (has_zero pos)) name) : @totally_separated_space.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_18149 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_bot.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_bot.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_18150 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (has_inter.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inter.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_18151 (h0 : list (has_Inf (sub_neg_monoid Type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_18152 (h0 : ring (semi_normed_ring (normed_field (has_nnnorm linarith.comp_source)))) : is_domain (semi_normed_ring (normed_field (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_18153 (h0 : functor.add_const (topological_space (cancel_monoid empty)) ennreal) : @totally_disconnected_space.{0} (cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} empty)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_18154 (h0 : group (ordered_ring (semiring (semiring empty)))) : normalizer_condition (ordered_ring (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_18155 (h0 : topological_space (has_inter (mul_one_class (mul_one_class std_gen)))) : totally_disconnected_space (has_inter (mul_one_class (mul_one_class std_gen))) := sorry --non-trivial
lemma new_lemma_18156 (h0 : uniform_space (id (has_norm linarith.comp))) : separated_space (id (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_18157 (h0 : functor.add_const (add_group (left_cancel_monoid num)) unsigned) : @is_add_cyclic.{0} (left_cancel_monoid.{0} num) (@functor.add_const.run.{0 0} (add_group.{0} (left_cancel_monoid.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_18158 (h0 : functor.add_const (group (has_nndist environment.implicit_infer_kind)) pos) : @group.fg.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (has_nndist.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_18159 (h0 : list (with_bot fun_info)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_18160 (h0 : group (left_cancel_semigroup (semiring unsigned))) : is_cyclic (left_cancel_semigroup (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_18161 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (normed_group.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_group.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_18162 (h0 : functor.add_const (topological_space (finset linarith.comp)) environment.implicit_infer_kind) : @preconnected_space.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_18163 (h0 : functor.add_const (group (has_zero name)) Type) : @is_cyclic.{0} (has_zero.{0} name) (@functor.add_const.run.{0 1} (group.{0} (has_zero.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_18164 (h0 : topological_space (measure_theory.measure_space num)) : topological_space.separable_space (measure_theory.measure_space num) := sorry --non-trivial
lemma new_lemma_18165 (h0 : has_mem.mem (metric_space fun_info) has_emptyc.emptyc) : @is_atomistic.{0} (metric_space.{0} fun_info) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (metric_space.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_18166 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (linear_ordered_add_comm_group.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_add_comm_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_18167 (h0 : topological_space (has_ssubset (random_gen string_imp))) : totally_disconnected_space (has_ssubset (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_18168 (h0 : topological_space (sub_neg_monoid (has_pos_part Type))) : t0_space (sub_neg_monoid (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_18169 (h0 : functor.add_const (semiring (preorder unsigned)) unsigned) : @is_noetherian_ring.{0} (preorder.{0} unsigned) (@functor.add_const.run.{0 0} (semiring.{0} (preorder.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_18170 (h0 : add_group (ring unsigned)) : is_add_cyclic (ring unsigned) := sorry --non-trivial
lemma new_lemma_18171 (h0 : add_group (has_ssubset (has_nnnorm (has_inv (has_nnnorm linarith.ineq))))) : is_add_cyclic (has_ssubset (has_nnnorm (has_inv (has_nnnorm linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_18172 (h0 : filter (non_assoc_semiring (semiring (semiring (semiring (semiring congr_arg_kind)))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_18173 (h4 : topological_space (add_comm_semigroup linarith.ineq)) : totally_disconnected_space (add_comm_semigroup linarith.ineq) := sorry --non-trivial
lemma new_lemma_18174 (h0 : group (pseudo_metric_space empty)) : is_cyclic (pseudo_metric_space empty) := sorry --non-trivial
lemma new_lemma_18175 (h0 : topological_space (simple_graph (has_add Type))) : preirreducible_space (simple_graph (has_add Type)) := sorry --non-trivial
lemma new_lemma_18176 (h0 : filter (semigroup (has_neg name))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_18177 (h0 : topological_space (has_nndist (has_add (normed_comm_ring name)))) : sequential_space (has_nndist (has_add (normed_comm_ring name))) := sorry --non-trivial
lemma new_lemma_18178 (h0 : complete_lattice (sub_neg_monoid (has_add pos))) : is_compactly_generated (sub_neg_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_18179 (h0 : ring (complete_linear_order (semiring (semiring num)))) : is_domain (complete_linear_order (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_18180 (h0 : ordered_add_comm_monoid (generalized_boolean_algebra (has_Inf (has_Inf pos)))) : archimedean (generalized_boolean_algebra (has_Inf (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_18181 (h0 : add_group (has_nnnorm (mul_one_class (has_le std_gen)))) : is_add_cyclic (has_nnnorm (mul_one_class (has_le std_gen))) := sorry --non-trivial
lemma new_lemma_18182 (h0 : uniform_space (has_compl (mul_one_class (mul_one_class string.iterator_imp)))) : complete_space (has_compl (mul_one_class (mul_one_class string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_18183 (h0 : functor.add_const (topological_space (bin_tree empty)) num) : @totally_disconnected_space.{0} (bin_tree.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (bin_tree.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_18184 (h0 : functor.add_const (group (canonically_ordered_comm_semiring unsigned)) name) : @is_cyclic.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (canonically_ordered_comm_semiring.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_18185 (h0 : topological_space (has_one (semiring (semiring num)))) : normal_space (has_one (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_18186 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_18187 (h1 : complete_lattice (has_compl (random_gen (random_gen string_imp)))) : is_compactly_generated (has_compl (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_18188 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (option.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (option.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_18189 (h0 : functor.add_const (function.extfun Type topological_space) name) : @loc_path_connected_space.{0} (has_nndist.{0} nnreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (has_nndist.{0} nnreal))  := sorry --non-trivial
lemma new_lemma_18190 (h0 : add_group (has_ssubset (mul_one_class char))) : is_add_cyclic (has_ssubset (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_18191 (h0 : function.extfun Type group) : @group.fg.{0} (has_top.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} h0 (has_top.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_18192 (h0 : function.extfun Type ring) : @rank_condition.{0} (random_gen.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (random_gen.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_18193 (h0 : function.extfun Type group) : @normalizer_condition.{0} (with_one.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (with_one.{0} num))  := sorry --non-trivial
lemma new_lemma_18194 (h0 : ordered_add_comm_monoid (has_Inf (finset pos))) : archimedean (has_Inf (finset pos)) := sorry --non-trivial
lemma new_lemma_18195 (h0 : functor.add_const (complete_lattice (has_nndist unsigned)) Type) : @is_atomistic.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 1} (complete_lattice.{0} (has_nndist.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_18196 (h0 : group (normed_group (random_gen (random_gen linarith.ineq)))) : normalizer_condition (normed_group (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_18197 (h0 : topological_space (linear_ordered_semiring congr_arg_kind)) : t0_space (linear_ordered_semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_18198 (h0 : functor.add_const (cancel_comm_monoid_with_zero (add_comm_monoid name)) linarith.comp) : @unique_factorization_monoid.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (add_comm_monoid.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_18199 (h0 : add_group (with_bot (has_norm unsigned))) : is_add_cyclic (with_bot (has_norm unsigned)) := sorry --non-trivial
lemma new_lemma_18200 (h0 : functor.add_const (function.extfun (Type 1) topological_space) pos) : @t1_space.{1} (has_zero.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) pos h0) (has_zero.{1} Type))  := sorry --non-trivial
lemma new_lemma_18201 (h0 : topological_space (has_ssubset (comm_ring (has_ssubset reducibility_hints)))) : totally_disconnected_space (has_ssubset (comm_ring (has_ssubset reducibility_hints))) := sorry --non-trivial
lemma new_lemma_18202 (h0 : functor.add_const (group Type) pos) : @group.fg.{1} Type (@functor.add_const.run.{1 0} (group.{1} Type) pos h0)  := sorry --non-trivial
lemma new_lemma_18203 (h0 : function.extfun Type (functor.add_const (ring znum))) : @strong_rank_condition.{0} znum (@functor.add_const.run.{0 0} (ring.{0} znum) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} znum)) h0 num))  := sorry --non-trivial
lemma new_lemma_18204 (h0 : functor.add_const (function.extfun Type ring) (ring (ring linarith.comp))) : @rank_condition.{0} pos (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) (ring.{0} (ring.{0} linarith.comp)) h0) pos)  := sorry --non-trivial
lemma new_lemma_18205 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (option.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (option.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_18206 (h0 : cancel_comm_monoid_with_zero (simple_graph (ring (has_pos_part Type)))) : unique_factorization_monoid (simple_graph (ring (has_pos_part Type))) := sorry --non-trivial
lemma new_lemma_18207 (h0 : ring (has_norm (semiring fun_info))) : rank_condition (has_norm (semiring fun_info)) := sorry --non-trivial
lemma new_lemma_18208 (h0 : group (has_top (has_top (has_top (has_top linarith.comp_source))))) : is_cyclic (has_top (has_top (has_top (has_top linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_18209 (h0 : functor.add_const (topological_space (has_zero Type)) Type) : @topological_space.separable_space.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_zero.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_18210 (h0 : has_mul (has_nndist (finset (has_nndist Type)))) (h1 : con (has_nndist (finset (has_nndist Type)))) (h2 : monoid (finset (con.quotient h1))) : monoid.fg (finset (con.quotient h1)) := sorry --non-trivial
lemma new_lemma_18211 (h0 : ordered_comm_monoid (has_add (ordered_ring (has_Inf Type)))) : has_exists_mul_of_le (has_add (ordered_ring (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_18212 (h0 : functor.add_const (topological_space (has_bot pos)) Type) : @loc_path_connected_space.{0} (has_bot.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_bot.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_18213 (h0 : monoid (has_emptyc (random_gen (has_norm to_additive.value_type)))) : monoid.fg (has_emptyc (random_gen (has_norm to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_18214 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (canonically_linear_ordered_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (canonically_linear_ordered_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_18215 (h0 : ordered_comm_monoid (has_to_string (option ennreal))) : has_exists_mul_of_le (has_to_string (option ennreal)) := sorry --non-trivial
lemma new_lemma_18216 (h0 : topological_space (comm_semigroup (has_bot (has_Inf real)))) : preirreducible_space (comm_semigroup (has_bot (has_Inf real))) := sorry --non-trivial
lemma new_lemma_18217 (h0 : functor.comp topological_space comm_group name) : @discrete_topology.{0} (comm_group.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} comm_group.{0} name h0)  := sorry --non-trivial
lemma new_lemma_18218 (h0 : complete_lattice (random_gen (random_gen string_imp))) : is_atomistic (random_gen (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_18219 (h0 : ring (has_norm unsigned)) : strong_rank_condition (has_norm unsigned) := sorry --non-trivial
lemma new_lemma_18220 (h0 : ring (distrib (fintype (has_nnnorm linarith.ineq)))) : rank_condition (distrib (fintype (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_18221 (h0 : functor.add_const (ordered_comm_monoid (boolean_algebra.core pos)) (ring pos)) : @has_exists_mul_of_le.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (boolean_algebra.core.{0} pos)) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_18222 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (ring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} name))  := sorry --non-trivial
lemma new_lemma_18223 (h0 : complete_lattice (complete_linear_order (has_top empty))) : is_compactly_generated (complete_linear_order (has_top empty)) := sorry --non-trivial
lemma new_lemma_18224 (h0 : function.extfun (Type 1) topological_space) : @path_connected_space.{1} (comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_18225 (h0 : functor.add_const (group (has_pos_part pos)) Type) : @is_simple_group.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (has_pos_part.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_18226 (h0 : ordered_add_comm_monoid (canonically_ordered_monoid (has_bot (has_bot real)))) : archimedean (canonically_ordered_monoid (has_bot (has_bot real))) := sorry --non-trivial
lemma new_lemma_18227 (h4 : topological_space (distrib reducibility_hints)) : t0_space (distrib reducibility_hints) := sorry --non-trivial
lemma new_lemma_18228 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (measurable_space.{0} empty) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (measurable_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_18229 (h0 : functor.add_const (function.extfun (Type 1) topological_space) pos) : @sequential_space.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) pos h0) (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_18230 (h0 : functor.add_const (topological_space (has_zero Type)) name) : @preconnected_space.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_zero.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_18231 (h0 : topological_space (canonically_ordered_add_monoid congr_arg_kind)) : totally_disconnected_space (canonically_ordered_add_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_18232 (h0 : functor.add_const (cancel_comm_monoid_with_zero (add_cancel_monoid pos)) name) : @unique_factorization_monoid.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (add_cancel_monoid.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_18233 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_compactly_generated.{0} (linear_ordered_comm_ring.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (linear_ordered_comm_ring.{0} num))  := sorry --non-trivial
lemma new_lemma_18234 (h0 : fin has_zero.zero) : @add_monoid.fg.{1} Type (@function.extfun_app.{3 2} (Type 1) add_monoid.{1} (@matrix.vec_empty.{2} (function.extfun.{3 2} (Type 1) add_monoid.{1}) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)) Type)  := sorry --non-trivial
lemma new_lemma_18235 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (semigroup num)) := sorry --non-trivial
lemma new_lemma_18236 (h0 : ring (ring linarith.comp)) : is_principal_ideal_ring (ring linarith.comp) := sorry --non-trivial
lemma new_lemma_18237 (h0 : functor.add_const (add_monoid (finset pos)) (ring Type)) : @add_monoid.fg.{0} (finset.{0} pos) (@functor.add_const.run.{0 1} (add_monoid.{0} (finset.{0} pos)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_18238 (h0 : function.extfun Type topological_space) : @t0_space.{0} (mul_zero_class.{0} (has_to_string.{0} (cancel_monoid.{0} (option.{0} (option.{0} pos))))) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (mul_zero_class.{0} (has_to_string.{0} (cancel_monoid.{0} (option.{0} (option.{0} pos))))))  := sorry --non-trivial
lemma new_lemma_18239 (h0 : ring (has_zero ennreal)) : rank_condition (has_zero ennreal) := sorry --non-trivial
lemma new_lemma_18240 (h0 : functor.add_const (filter (cancel_monoid name)) environment.implicit_infer_kind) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_18241 (h0 : has_coe (mul_one_class (normed_field (normed_field (normed_field char)))) Prop) (h1 : mul_one_class (normed_field (normed_field (normed_field char)))) : @coe_b.{1 1} (mul_one_class.{0} (normed_field.{0} (normed_field.{0} (normed_field.{0} char)))) Prop h0 h1  := sorry --non-trivial
lemma new_lemma_18242 (h0 : group (left_cancel_semigroup (semiring empty))) : group.fg (left_cancel_semigroup (semiring empty)) := sorry --non-trivial
lemma new_lemma_18243 (h0 : ring (group_with_zero num)) : is_principal_ideal_ring (group_with_zero num) := sorry --non-trivial
lemma new_lemma_18244 (h0 : topological_space (add_comm_monoid (boolean_algebra (has_add (mul_zero_class (boolean_algebra name)))))) : t0_space (add_comm_monoid (boolean_algebra (has_add (mul_zero_class (boolean_algebra name))))) := sorry --non-trivial
lemma new_lemma_18245 (h0 : function.extfun nat fin) : @t0_space.{0} (complete_distrib_lattice.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (complete_distrib_lattice.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_18246 (h0 : functor.add_const (group (comm_group pos)) (has_to_string linarith.comp)) : @normalizer_condition.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (comm_group.{0} pos)) (has_to_string.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_18247 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (with_one congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_18248 (h0 : function.extfun Type topological_space) : preirreducible_space ennreal := sorry --non-trivial
lemma new_lemma_18249 (h0 : functor.add_const (complete_lattice auto.case_option) (option empty)) : @complete_lattice.is_Sup_finite_compact.{0} auto.case_option (@functor.add_const.run.{0 0} (complete_lattice.{0} auto.case_option) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_18250 (h0 : topological_space (has_neg (option unsigned))) : locally_compact_space (has_neg (option unsigned)) := sorry --non-trivial
lemma new_lemma_18251 (h0 : prod (monoid_with_zero ennreal) (monoid_with_zero ennreal)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_18252 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (boolean_algebra.core.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} name))  := sorry --non-trivial
lemma new_lemma_18253 (h0 : topological_space (with_bot fun_info)) : path_connected_space (with_bot fun_info) := sorry --non-trivial
lemma new_lemma_18254 (h0 : uniform_space (has_Inf (has_neg pos))) : complete_space (has_Inf (has_neg pos)) := sorry --non-trivial
lemma new_lemma_18255 (h0 : has_lt (has_le char)) : no_max_order (has_le char) := sorry --non-trivial
lemma new_lemma_18256 (h0 : topological_space (has_compl (random_gen (random_gen (random_gen (random_gen (random_gen fun_info))))))) : t0_space (has_compl (random_gen (random_gen (random_gen (random_gen (random_gen fun_info)))))) := sorry --non-trivial
lemma new_lemma_18257 (h0 : not (filter (has_norm unsigned) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_18258 (h0 : topological_space (linear_order num)) : discrete_topology (linear_order num) := sorry --non-trivial
lemma new_lemma_18259 (h0 : topological_space (id fun_info)) : totally_separated_space (id fun_info) := sorry --non-trivial
lemma new_lemma_18260 (h0 : not (ring (with_bot to_additive.value_type) -> false)) : @strong_rank_condition.{0} (with_bot.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (with_bot.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_18261 (h0 : uniform_space (distrib_lattice char)) : complete_space (distrib_lattice char) := sorry --non-trivial
lemma new_lemma_18262 (h1 : topological_space (encodable string_imp)) : path_connected_space (encodable string_imp) := sorry --non-trivial
lemma new_lemma_18263 (h1 h2 : multiset (has_nnnorm reducibility_hints)) : multiset.subset h1 h2 := sorry --non-trivial
lemma new_lemma_18264 (h0 : functor.comp semiring has_zero pos) : @is_noetherian_ring.{0} (has_zero.{0} pos) (@functor.comp.run.{0 0 0} semiring.{0} has_zero.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_18265 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (ordered_cancel_add_comm_monoid ennreal)) := sorry --non-trivial
lemma new_lemma_18266 (h0 : ring (simple_graph (mul_one_class (has_ssubset to_additive.value_type)))) : strong_rank_condition (simple_graph (mul_one_class (has_ssubset to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_18267 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (finset.{0} num) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (finset.{0} num))  := sorry --non-trivial
lemma new_lemma_18268 (h0 : ring (has_inter (option (option empty)))) : is_principal_ideal_ring (has_inter (option (option empty))) := sorry --non-trivial
lemma new_lemma_18269 (h0 : functor.add_const (add_monoid (has_Sup empty)) num) : @add_monoid.fg.{0} (has_Sup.{0} empty) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_Sup.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_18270 (h0 : add_group (complete_semilattice_Sup (semiring (semiring unsigned)))) : is_add_cyclic (complete_semilattice_Sup (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_18271 (h0 : filter (id (semiring (semiring unsigned)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_18272 (h1 : set (semi_normed_ring std_gen)) : set.finite h1 := sorry --non-trivial
lemma new_lemma_18273 (h0 : functor.add_const (complete_lattice (normed_comm_ring name)) pos) : @complete_lattice.is_Sup_finite_compact.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (normed_comm_ring.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_18274 (h0 : functor.add_const (ring (semigroup name)) pos) : @is_domain.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (semigroup.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_18275 (h0 : function.extfun Type topological_space) : @normal_space.{0} (canonically_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_18276 (h0 : functor.add_const (ring (complete_distrib_lattice pos)) (has_pos_part pos)) : @is_principal_ideal_ring.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (complete_distrib_lattice.{0} pos)) (has_pos_part.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_18277 (h0 : functor.add_const (function.extfun Type ring) name) : @rank_condition.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) name h0) (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_18278 (h0 : functor.add_const (list (mul_zero_class pos)) unsigned) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_18279 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (has_star.{0} empty) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (has_star.{0} empty))  := sorry --non-trivial
lemma new_lemma_18280 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_18281 (h0 : complete_lattice (metric_space (has_nnnorm char))) : complete_lattice.is_Sup_finite_compact (metric_space (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_18282 (h0 : complete_lattice (semi_normed_ring (has_nnnorm (uniform_space linarith.ineq)))) : complete_lattice.is_Sup_finite_compact (semi_normed_ring (has_nnnorm (uniform_space linarith.ineq))) := sorry --non-trivial
lemma new_lemma_18283 (h0 : ordered_comm_monoid (ordered_comm_monoid name)) : has_exists_mul_of_le (ordered_comm_monoid name) := sorry --non-trivial
lemma new_lemma_18284 (h0 : functor.add_const (ordered_add_comm_monoid (has_to_string pos)) Type) : @archimedean.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 1} (ordered_add_comm_monoid.{0} (has_to_string.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_18285 (h0 : topological_space (id (semiring linarith.comp))) : preirreducible_space (id (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_18286 (h0 : list (canonically_linear_ordered_monoid (option (option ennreal)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_18287 (h0 : functor.add_const (topological_space (has_zero linarith.comp)) pos) : @sequential_space.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_18288 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (monoid.{0} (option.{0} unsigned)) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (monoid.{0} (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_18289 (h0 : functor.comp ring boolean_algebra Type) : @is_domain.{1} (boolean_algebra.{1} Type) (@functor.comp.run.{1 1 1} ring.{1} boolean_algebra.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_18290 (h0 : semiring auto.case_option) : is_noetherian_ring auto.case_option := sorry --non-trivial
lemma new_lemma_18291 (h0 : topological_space (complete_semilattice_Sup string_imp)) : totally_disconnected_space (complete_semilattice_Sup string_imp) := sorry --non-trivial
lemma new_lemma_18292 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_18293 (h0 : list (has_neg_part ennreal)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_18294 (h0 : complete_lattice (has_div std_gen)) : complete_lattice.is_Sup_finite_compact (has_div std_gen) := sorry --non-trivial
lemma new_lemma_18295 (h0 : filter (pseudo_metric_space (option ennreal))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_18296 (h0 : function.extfun Type ring) : @rank_condition.{0} (semiring.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} h0 (semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_18297 (h0 : functor.add_const (filter (boolean_algebra linarith.comp)) Type) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_18298 (h0 : complete_lattice (normed_comm_ring name)) : is_atomistic (normed_comm_ring name) := sorry --non-trivial
lemma new_lemma_18299 (h0 : functor.add_const (finset (mul_zero_class pos)) Type) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_18300 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (boolean_algebra.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_18301 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (ordered_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_18302 (h0 : set (add_comm_semigroup linarith.ineq -> char)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_18303 (h0 : group (mul_zero_class to_additive.value_type)) : normalizer_condition (mul_zero_class to_additive.value_type) := sorry --non-trivial
lemma new_lemma_18304 (h0 : group (has_neg congr_arg_kind)) : is_simple_group (has_neg congr_arg_kind) := sorry --non-trivial
lemma new_lemma_18305 (h0 : ring (has_append (comm_ring reducibility_hints))) : strong_rank_condition (has_append (comm_ring reducibility_hints)) := sorry --non-trivial
lemma new_lemma_18306 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (non_assoc_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} h0 (non_assoc_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_18307 (h0 : functor.add_const (group (has_to_string unsigned)) pos) : @group.fg.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (has_to_string.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_18308 (h0 : filter (option (has_to_string (option (option (option (option (option (option (option ennreal)))))))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_18309 (h0 : complete_lattice (ordered_comm_ring reducibility_hints)) : complete_lattice.is_Sup_finite_compact (ordered_comm_ring reducibility_hints) := sorry --non-trivial
lemma new_lemma_18310 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_18311 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (left_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (left_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_18312 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (has_neg.{0} (finset.{0} ennreal)) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_neg.{0} (finset.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_18313 (h0 : not (group (partial_order empty) -> false)) : @normalizer_condition.{0} (partial_order.{0} empty) (@classical.by_contradiction'.{1} (group.{0} (partial_order.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_18314 (h0 : topological_space (semigroup (option (option pos)))) : loc_path_connected_space (semigroup (option (option pos))) := sorry --non-trivial
lemma new_lemma_18315 (h0 : functor.add_const (topological_space (generalized_boolean_algebra pos)) Type) : @regular_space.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (generalized_boolean_algebra.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_18316 (h0 : uniform_space (add_comm_monoid (sub_neg_monoid linarith.comp))) : complete_space (add_comm_monoid (sub_neg_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_18317 (h0 : functor.add_const (topological_space (cancel_monoid Type)) Type) : @t0_space.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (cancel_monoid.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_18318 (h0 : cancel_comm_monoid_with_zero (complete_linear_order (semiring empty))) : unique_factorization_monoid (complete_linear_order (semiring empty)) := sorry --non-trivial
lemma new_lemma_18319 (h0 : not (ring (distrib_lattice char) -> false)) : @is_domain.{0} (distrib_lattice.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (distrib_lattice.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_18320 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (comm_semigroup.{0} real) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (comm_semigroup.{0} real))  := sorry --non-trivial
lemma new_lemma_18321 (h0 : list pos) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_18322 (h0 : complete_lattice (pseudo_metric_space num)) : is_compactly_generated (pseudo_metric_space num) := sorry --non-trivial
lemma new_lemma_18323 (h0 : ring (uniform_space (comm_ring linarith.comp_source))) : strong_rank_condition (uniform_space (comm_ring linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_18324 (h0 : not (function.extfun Type group -> false)) : @normalizer_condition.{0} (has_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (has_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_18325 (h0 : monoid (measurable_space (has_inv linarith.comp_source))) : monoid.fg (measurable_space (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_18326 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_18327 (h0 : functor.add_const (topological_space (mul_zero_class Type)) ennreal) : @locally_compact_space.{1} (mul_zero_class.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (mul_zero_class.{1} Type)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_18328 (h0 : topological_space (add_comm_semigroup string.iterator_imp)) (h1 : add_group (add_comm_semigroup string.iterator_imp)) : topological_add_group (add_comm_semigroup string.iterator_imp) := sorry --non-trivial
lemma new_lemma_18329 (h0 : list (linear_ordered_add_comm_group (random_gen linarith.ineq))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_18330 (h0 : list (has_top (has_inv fun_info))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_18331 (h0 : add_monoid (has_nndist environment.implicit_infer_kind)) : add_monoid.fg (has_nndist environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_18332 (h0 : topological_space (semiring (semiring linarith.comp_source))) : totally_disconnected_space (semiring (semiring linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_18333 (h0 : functor.add_const (ring (boolean_algebra environment.implicit_infer_kind)) (ring Type)) : @is_principal_ideal_ring.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (ring.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_18334 (h1 : topological_space (has_ssubset linarith.ineq)) : path_connected_space (has_ssubset linarith.ineq) := sorry --non-trivial
lemma new_lemma_18335 (h0 : monoid (filter num)) : monoid.fg (filter num) := sorry --non-trivial
lemma new_lemma_18336 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (generalized_boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (generalized_boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_18337 (h0 : functor.add_const (topological_space (add_left_cancel_semigroup unsigned)) empty) : @irreducible_space.{0} (add_left_cancel_semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_left_cancel_semigroup.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_18338 (h1 : monoid to_additive.value_type) : monoid.fg to_additive.value_type := sorry --non-trivial
lemma new_lemma_18339 (h0 : topological_space (measurable_space (has_inv fun_info))) : t0_space (measurable_space (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_18340 (h0 : normed_comm_ring pos -> normed_comm_ring pos -> Prop) : is_symm (normed_comm_ring pos) h0 := sorry --non-trivial
lemma new_lemma_18341 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (has_to_string.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_to_string.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_18342 (h0 : topological_space (generalized_boolean_algebra (finset Type))) : irreducible_space (generalized_boolean_algebra (finset Type)) := sorry --non-trivial
lemma new_lemma_18343 (h1 : not (ring (distrib_lattice linarith.ineq) -> false)) : @strong_rank_condition.{0} (distrib_lattice.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (distrib_lattice.{0} linarith.ineq)) h1)  := sorry --non-trivial
lemma new_lemma_18344 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (preorder.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (preorder.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_18345 (h0 : complete_lattice (with_one char)) : is_compactly_generated (with_one char) := sorry --non-trivial
lemma new_lemma_18346 (h0 : set (uniform_space enat)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_18347 (h0 : uniform_space (canonically_ordered_add_monoid (option (option (option empty))))) : complete_space (canonically_ordered_add_monoid (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_18348 (h0 : topological_space (comm_ring (random_gen (has_ssubset fun_info)))) : totally_disconnected_space (comm_ring (random_gen (has_ssubset fun_info))) := sorry --non-trivial
lemma new_lemma_18349 (h0 : topological_space (sub_neg_monoid (has_add pos))) : preirreducible_space (sub_neg_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_18350 (h0 : not (ring (uniform_space (has_lt linarith.comp_source)) -> false)) : @is_domain.{0} (uniform_space.{0} (has_lt.{0} linarith.comp_source)) (@classical.by_contradiction'.{1} (ring.{0} (uniform_space.{0} (has_lt.{0} linarith.comp_source))) h0)  := sorry --non-trivial
lemma new_lemma_18351 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem ring)) : @rank_condition.{0} (measurable_space.{0} linarith.ineq) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) ring.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (measurable_space.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_18352 (h0 : functor.add_const (ordered_comm_monoid (finset pos)) environment.implicit_infer_kind) : @has_exists_mul_of_le.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (finset.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_18353 (h1 : set to_additive.value_type) : set.subsingleton h1 := sorry --non-trivial
lemma new_lemma_18354 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (has_neg.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_neg.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_18355 (h0 : topological_space (has_star (semiring (semiring (semiring num))))) : path_connected_space (has_star (semiring (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_18356 (h0 : functor.add_const (topological_space (has_to_string ennreal)) unsigned) : @path_connected_space.{0} (has_to_string.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_18357 (h0 : functor.add_const (topological_space (normed_comm_ring ennreal)) name) : @discrete_topology.{0} (normed_comm_ring.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_18358 (h0 : topological_space (random_gen (has_inv (has_inv linarith.ineq)))) : locally_compact_space (random_gen (has_inv (has_inv linarith.ineq))) := sorry --non-trivial
lemma new_lemma_18359 (h0 : not (topological_space (has_one num) -> false)) : @totally_separated_space.{0} (has_one.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (has_one.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_18360 (h0 : uniform_space (distrib (has_nnnorm (has_nnnorm (has_nnnorm reducibility_hints))))) : complete_space (distrib (has_nnnorm (has_nnnorm (has_nnnorm reducibility_hints)))) := sorry --non-trivial
lemma new_lemma_18361 (h0 : topological_space (add_group (semiring (semiring (semiring (semiring num)))))) : preirreducible_space (add_group (semiring (semiring (semiring (semiring num))))) := sorry --non-trivial
lemma new_lemma_18362 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @regular_space.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_18363 (h0 : topological_space (add_cancel_monoid (has_zero name))) : normal_space (add_cancel_monoid (has_zero name)) := sorry --non-trivial
lemma new_lemma_18364 (h1 : ring (random_gen (has_nnnorm char))) : rank_condition (random_gen (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_18365 (h0 : ordered_add_comm_monoid (free_add_monoid (option (option (option unsigned))))) : archimedean (free_add_monoid (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_18366 (h0 : add_group (add_comm_semigroup (mul_one_class (add_comm_semigroup string.iterator_imp)))) : is_add_cyclic (add_comm_semigroup (mul_one_class (add_comm_semigroup string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_18367 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_18368 (h0 : complete_lattice (canonically_ordered_comm_semiring Type)) : is_compactly_generated (canonically_ordered_comm_semiring Type) := sorry --non-trivial
lemma new_lemma_18369 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (option.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (option.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_18370 (h0 : group (has_emptyc (has_top (random_gen (has_top fun_info))))) : normalizer_condition (has_emptyc (has_top (random_gen (has_top fun_info)))) := sorry --non-trivial
lemma new_lemma_18371 (h0 : ring (non_assoc_semiring empty)) : is_domain (non_assoc_semiring empty) := sorry --non-trivial
lemma new_lemma_18372 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (ordered_cancel_add_comm_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (ordered_cancel_add_comm_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_18373 (h0 : topological_space (semiring (semiring (semiring num)))) : discrete_topology (semiring (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_18374 (h0 : add_group (semiring (semiring (semiring (semiring (semiring (semiring linarith.comp))))))) : is_add_cyclic (semiring (semiring (semiring (semiring (semiring (semiring linarith.comp)))))) := sorry --non-trivial
lemma new_lemma_18375 (h0 : not (function.extfun Type complete_lattice -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (with_zero.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (with_zero.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_18376 (h0 : functor.add_const (uniform_space (boolean_algebra Type)) (ring Type)) : @complete_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 1} (uniform_space.{1} (boolean_algebra.{1} Type)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_18377 (h0 : group (add_cancel_comm_monoid (metric_space (random_gen (random_gen char))))) : is_cyclic (add_cancel_comm_monoid (metric_space (random_gen (random_gen char)))) := sorry --non-trivial
lemma new_lemma_18378 (h3 : ring char) : is_domain char := sorry --non-trivial
lemma new_lemma_18379 (h0 : finset (has_nndist (has_add Type))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_18380 (h0 : ring (has_top (has_ssubset to_additive.value_type))) : strong_rank_condition (has_top (has_ssubset to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_18381 (h0 : topological_space (complete_semilattice_Sup linarith.comp_source)) : path_connected_space (complete_semilattice_Sup linarith.comp_source) := sorry --non-trivial
lemma new_lemma_18382 (h0 : cancel_comm_monoid_with_zero (ordered_comm_monoid linarith.comp)) : unique_factorization_monoid (ordered_comm_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_18383 (h0 : ring (measure_theory.measure_space empty)) : is_domain (measure_theory.measure_space empty) := sorry --non-trivial
lemma new_lemma_18384 (h0 : topological_space (add_cancel_monoid (has_add linarith.comp))) : irreducible_space (add_cancel_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_18385 (h0 : functor.add_const Prop (has_norm unsigned)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_18386 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (measurable_space.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (measurable_space.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_18387 (h0 : topological_space (add_comm_monoid pos)) : preconnected_space (add_comm_monoid pos) := sorry --non-trivial
lemma new_lemma_18388 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} environment.implicit_infer_kind (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) environment.implicit_infer_kind)  := sorry --non-trivial
lemma new_lemma_18389 (h0 : group (semi_normed_comm_ring linarith.comp_source)) : group.fg (semi_normed_comm_ring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_18390 (h0 : uniform_space (has_div fun_info)) : complete_space (has_div fun_info) := sorry --non-trivial
lemma new_lemma_18391 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @strong_rank_condition.{1} (canonically_ordered_comm_semiring.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ring.{1}) (canonically_ordered_comm_semiring.{1} Type))  := sorry --non-trivial
lemma new_lemma_18392 (h0 : functor.add_const (cancel_comm_monoid_with_zero (boolean_algebra Type)) pos) : @unique_factorization_monoid.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (cancel_comm_monoid_with_zero.{1} (boolean_algebra.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_18393 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (metric_space.{0} empty) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (metric_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_18394 (h0 : topological_space (mul_zero_class empty)) : t1_space (mul_zero_class empty) := sorry --non-trivial
lemma new_lemma_18395 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @locally_compact_space.{0} (semiring.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_18396 (h1 : semiring (add_comm_semigroup (normed_field (mul_one_class std_gen)))) (h2 : ideal (add_comm_semigroup (normed_field (mul_one_class std_gen)))) : ideal.is_prime h2 := sorry --non-trivial
lemma new_lemma_18397 (h0 : functor.add_const (monoid (has_neg_part pos)) environment.implicit_infer_kind) : @monoid.fg.{0} (has_neg_part.{0} pos) (@functor.add_const.run.{0 0} (monoid.{0} (has_neg_part.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_18398 (h1 : group (has_emptyc (has_inv linarith.comp_source))) : group.fg (has_emptyc (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_18399 (h0 : not (ring (metric_space empty) -> false)) : @rank_condition.{0} (metric_space.{0} empty) (@classical.by_contradiction'.{1} (ring.{0} (metric_space.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_18400 (h0 : fin has_zero.zero) : @separated_space.{0} (ordered_comm_ring.{0} real) (@matrix.vec_empty.{0} (uniform_space.{0} (ordered_comm_ring.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_18401 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_add.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_add.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_18402 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (has_pos_part.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_pos_part.{0} name))  := sorry --non-trivial
lemma new_lemma_18403 (h0 : ring (ordered_comm_monoid (has_add linarith.comp))) : is_principal_ideal_ring (ordered_comm_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_18404 (h0 : semiring (add_cancel_monoid (has_zero (boolean_algebra name)))) : is_noetherian_ring (add_cancel_monoid (has_zero (boolean_algebra name))) := sorry --non-trivial
lemma new_lemma_18405 (h0 : monoid (canonically_linear_ordered_monoid num)) : monoid.fg (canonically_linear_ordered_monoid num) := sorry --non-trivial
lemma new_lemma_18406 (h0 : topological_space (has_norm (has_norm num))) : totally_separated_space (has_norm (has_norm num)) := sorry --non-trivial
lemma new_lemma_18407 (h0 : function.extfun Type ring) : @is_domain.{0} (is_R_or_C.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (is_R_or_C.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_18408 (h0 : functor.add_const (monoid (has_neg_part name)) (has_add pos)) : @monoid.fg.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (monoid.{0} (has_neg_part.{0} name)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_18409 (h0 : functor.add_const (function.extfun Type uniform_space) name) : @separated_space.{0} (has_Inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) name h0) (has_Inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_18410 (h0 : ring (has_neg (has_add (has_add pos)))) : strong_rank_condition (has_neg (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_18411 (h0 : topological_space (has_add (finset pos))) : loc_path_connected_space (has_add (finset pos)) := sorry --non-trivial
lemma new_lemma_18412 (h0 : fin has_zero.zero) : rank_condition real := sorry --non-trivial
lemma new_lemma_18413 (h0 : add_monoid (has_nnnorm string.iterator_imp)) : add_monoid.fg (has_nnnorm string.iterator_imp) := sorry --non-trivial
lemma new_lemma_18414 (h0 : functor.add_const (function.extfun Type (functor.add_const Prop)) pos) : functor.add_const.run (function.extfun_app (functor.add_const.run h0) (comm_group name)) := sorry --non-trivial
lemma new_lemma_18415 (h0 : ring (has_nndist (option unsigned))) : is_domain (has_nndist (option unsigned)) := sorry --non-trivial
lemma new_lemma_18416 (h0 : ring (linear_ordered_comm_group_with_zero (mul_one_class linarith.comp_source))) : strong_rank_condition (linear_ordered_comm_group_with_zero (mul_one_class linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_18417 (h0 : group (random_gen linarith.comp)) : is_cyclic (random_gen linarith.comp) := sorry --non-trivial
lemma new_lemma_18418 (h0 : has_mem.mem (random_gen (random_gen linarith.comp_source)) has_emptyc.emptyc) : @irreducible_space.{0} (random_gen.{0} (random_gen.{0} linarith.comp_source)) (@finset.pi.empty.{1 0} Type topological_space.{0} (random_gen.{0} (random_gen.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_18419 (h0 : function.extfun nat fin) : @t1_space.{1} (canonically_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (canonically_ordered_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_18420 (h0 : topological_space (has_norm (has_norm linarith.comp_source))) : t0_space (has_norm (has_norm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_18421 (h0 : ring (has_top linarith.comp_source)) : strong_rank_condition (has_top linarith.comp_source) := sorry --non-trivial
lemma new_lemma_18422 (h1 : has_mem.mem (has_emptyc congr_arg_kind) has_emptyc.emptyc) : @separated_space.{0} (has_emptyc.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type uniform_space.{0} (has_emptyc.{0} congr_arg_kind) h1)  := sorry --non-trivial
lemma new_lemma_18423 (h0 : function.extfun (finset (Type -> Type) -> Prop) (function.extfun (finset (Type -> Type)))) : @totally_disconnected_space.{0} (linear_ordered_add_comm_group.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) (@function.extfun_app.{2 0} (finset.{1} (Type → Type) → Prop) (function.extfun.{2 0} (finset.{1} (Type → Type))) h0 (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0})) (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (linear_ordered_add_comm_group.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_18424 (h0 : topological_space (canonically_linear_ordered_monoid unsigned)) : regular_space (canonically_linear_ordered_monoid unsigned) := sorry --non-trivial
lemma new_lemma_18425 (h0 : topological_space (has_neg_part (has_add environment.implicit_infer_kind))) : sequential_space (has_neg_part (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_18426 (h0 : functor.add_const (ring (canonically_ordered_comm_semiring Type)) linarith.comp) : @rank_condition.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (canonically_ordered_comm_semiring.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_18427 (h0 : functor.add_const (uniform_space (boolean_algebra environment.implicit_infer_kind)) name) : @separated_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (uniform_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_18428 (h0 : has_le (add_comm_semigroup char)) (h1 : add_comm_semigroup char) : is_bot h1 := sorry --non-trivial
lemma new_lemma_18429 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_18430 (h0 : topological_space (has_nnnorm (has_ssubset char))) : locally_compact_space (has_nnnorm (has_ssubset char)) := sorry --non-trivial
lemma new_lemma_18431 (h0 : group (cancel_monoid congr_arg_kind)) : group.fg (cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_18432 (h0 : topological_space (has_neg unsigned)) : sequential_space (has_neg unsigned) := sorry --non-trivial
lemma new_lemma_18433 (h0 : semiring std_gen) (h2 : ideal std_gen) : ideal.is_prime h2 := sorry --non-trivial
lemma new_lemma_18434 (h0 : functor.add_const (topological_space (ordered_comm_ring linarith.comp)) (finset (finset pos))) : @loc_path_connected_space.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} linarith.comp)) (finset.{0} (finset.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_18435 (h0 : filter (ordered_comm_ring (option empty))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_18436 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @preirreducible_space.{1} (cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_18437 (h0 : functor.add_const (monoid (has_to_string linarith.comp)) linarith.comp) : @monoid.fg.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (monoid.{0} (has_to_string.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_18438 (h0 : functor.add_const (complete_lattice (generalized_boolean_algebra linarith.comp)) name) : @complete_lattice.is_Sup_finite_compact.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (generalized_boolean_algebra.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_18439 (h0 : function.extfun (Type 1) list) : list.nodup (function.extfun_app h0 (ring Type)) := sorry --non-trivial
lemma new_lemma_18440 (h0 : cancel_comm_monoid_with_zero (has_Inf (finset pos))) : unique_factorization_monoid (has_Inf (finset pos)) := sorry --non-trivial
lemma new_lemma_18441 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (encodable.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (encodable.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_18442 (h1 : complete_lattice (mul_one_class std_gen)) : complete_lattice.is_Sup_finite_compact (mul_one_class std_gen) := sorry --non-trivial
lemma new_lemma_18443 (h0 : functor.add_const (ring (generalized_boolean_algebra pos)) real) : @strong_rank_condition.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (generalized_boolean_algebra.{0} pos)) real h0)  := sorry --non-trivial
lemma new_lemma_18444 (h0 : functor.add_const (topological_space (has_to_string linarith.comp)) linarith.comp) : @topological_space.separable_space.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_18445 (h0 : topological_space (ordered_cancel_add_comm_monoid empty)) : irreducible_space (ordered_cancel_add_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_18446 (h0 : set (nondiscrete_normed_field environment.projection_info -> normed_field linarith.ineq)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_18447 (h1 : group (add_cancel_comm_monoid char)) : is_cyclic (add_cancel_comm_monoid char) := sorry --non-trivial
lemma new_lemma_18448 (h0 : fin has_zero.zero) : @has_exists_mul_of_le.{0} (has_Inf.{0} pos) (@matrix.vec_empty.{0} (ordered_comm_monoid.{0} (has_Inf.{0} pos)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_18449 (h0 : functor.add_const (uniform_space (bin_tree unsigned)) num) : @separated_space.{0} (bin_tree.{0} unsigned) (@functor.add_const.run.{0 0} (uniform_space.{0} (bin_tree.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_18450 (h0 : ring (comm_ring char)) : is_domain (comm_ring char) := sorry --non-trivial
lemma new_lemma_18451 (h0 : functor.add_const (filter (normed_comm_ring linarith.comp)) (ring (finset Type))) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_18452 (h0 : topological_space (comm_monoid (option (option empty)))) : loc_path_connected_space (comm_monoid (option (option empty))) := sorry --non-trivial
lemma new_lemma_18453 (h0 : complete_lattice (random_gen (random_gen to_additive.value_type))) : complete_lattice.is_Sup_finite_compact (random_gen (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_18454 (h0 : functor.add_const (semiring (is_R_or_C unsigned)) (semiring unsigned)) : @is_noetherian_ring.{0} (is_R_or_C.{0} unsigned) (@functor.add_const.run.{0 0} (semiring.{0} (is_R_or_C.{0} unsigned)) (semiring.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_18455 (h0 : function.extfun Type group) : @is_cyclic.{0} (add_cancel_monoid.{0} (option.{0} unsigned)) (@function.extfun_app.{2 1} Type group.{0} h0 (add_cancel_monoid.{0} (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_18456 (h0 : functor.add_const (group (boolean_algebra linarith.comp)) subsingleton_info) : @is_cyclic.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.{0} linarith.comp)) subsingleton_info h0)  := sorry --non-trivial
lemma new_lemma_18457 (h3 : topological_space reducibility_hints) : totally_disconnected_space reducibility_hints := sorry --non-trivial
lemma new_lemma_18458 (h2 : group (div_inv_monoid to_additive.value_type)) : is_cyclic (div_inv_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_18459 (h0 : functor.add_const (topological_space (add_comm_monoid name)) linarith.comp) : @locally_compact_space.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_18460 (h0 : functor.add_const (ring (has_Inf pos)) (has_neg (has_neg Type))) : @strong_rank_condition.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (has_Inf.{0} pos)) (has_neg.{1} (has_neg.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_18461 (h0 : ring (has_add Type)) : strong_rank_condition (has_add Type) := sorry --non-trivial
lemma new_lemma_18462 (h1 : ring (normed_field reducibility_hints)) : strong_rank_condition (normed_field reducibility_hints) := sorry --non-trivial
lemma new_lemma_18463 (h0 : prod (left_cancel_semigroup unsigned) (left_cancel_semigroup unsigned)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_18464 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (has_zero.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_18465 (h0 : topological_space (topological_space (random_gen linarith.ineq))) : locally_compact_space (topological_space (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_18466 (h0 : not (complete_lattice (fintype linarith.comp_source) -> false)) : @is_compactly_generated.{0} (fintype.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (complete_lattice.{0} (fintype.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_18467 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (measure_theory.measure_space.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (measure_theory.measure_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_18468 (h0 : group (has_neg name)) : is_simple_group (has_neg name) := sorry --non-trivial
lemma new_lemma_18469 (h0 : has_mem.mem (random_gen fun_info) has_emptyc.emptyc) : @totally_separated_space.{0} (random_gen.{0} fun_info) (@finset.pi.empty.{1 0} Type topological_space.{0} (random_gen.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_18470 (h0 : topological_space (has_ssubset to_additive.value_type)) : path_connected_space (has_ssubset to_additive.value_type) := sorry --non-trivial
lemma new_lemma_18471 (h0 : functor.add_const (topological_space pos) (finset Type)) : @topological_space.separable_space.{0} pos (@functor.add_const.run.{0 1} (topological_space.{0} pos) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_18472 (h1 : ring (denumerable (random_gen to_additive.value_type))) : is_domain (denumerable (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_18473 (h0 : has_lt complex) : no_max_order complex := sorry --non-trivial
lemma new_lemma_18474 (h0 : functor.add_const (cancel_comm_monoid_with_zero (canonically_ordered_comm_semiring Type)) Type) : @unique_factorization_monoid.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.add_const.run.{1 1} (cancel_comm_monoid_with_zero.{1} (canonically_ordered_comm_semiring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_18475 (h1 : ring (non_unital_non_assoc_semiring string_imp)) : is_domain (non_unital_non_assoc_semiring string_imp) := sorry --non-trivial
lemma new_lemma_18476 (h0 : uniform_space (has_Inf (finset Type))) : separated_space (has_Inf (finset Type)) := sorry --non-trivial
lemma new_lemma_18477 (h0 : topological_space (has_norm (semiring (semiring (semiring empty))))) : normal_space (has_norm (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_18478 (h0 : complete_lattice (has_dist ennreal)) : is_compactly_generated (has_dist ennreal) := sorry --non-trivial
lemma new_lemma_18479 (h0 : uniform_space (topological_space (has_nnnorm linarith.comp_source))) : complete_space (topological_space (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_18480 (h1 : topological_space (has_le std_gen)) : t0_space (has_le std_gen) := sorry --non-trivial
lemma new_lemma_18481 (h0 : functor.add_const (topological_space (semigroup environment.implicit_infer_kind)) environment.implicit_infer_kind) : @locally_compact_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_18482 (h0 : functor.add_const (functor.add_const (topological_space Type) linarith.comp) (has_Inf (has_add Type))) : @totally_separated_space.{1} Type (@functor.add_const.run.{1 0} (topological_space.{1} Type) linarith.comp (@functor.add_const.run.{1 1} (functor.add_const.{1 0} (topological_space.{1} Type) linarith.comp) (has_Inf.{1} (has_add.{1} Type)) h0))  := sorry --non-trivial
lemma new_lemma_18483 (h0 : complete_lattice (has_add (sub_neg_monoid real))) : is_compactly_generated (has_add (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_18484 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (has_bot.{0} linarith.comp) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (has_bot.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_18485 (h0 : has_mem.mem complete_lattice has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} (has_emptyc.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} h0) (has_emptyc.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_18486 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (with_one.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (with_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_18487 (h0 : ring (generalized_boolean_algebra (generalized_boolean_algebra pos))) : strong_rank_condition (generalized_boolean_algebra (generalized_boolean_algebra pos)) := sorry --non-trivial
lemma new_lemma_18488 (h1 h2 : multiset (distrib string_imp)) : multiset.disjoint h1 h2 := sorry --non-trivial
lemma new_lemma_18489 (h1 : not (ring (denumerable to_additive.value_type) -> false)) : @rank_condition.{0} (denumerable.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (denumerable.{0} to_additive.value_type)) h1)  := sorry --non-trivial
lemma new_lemma_18490 (h0 : ring (distrib (comm_ring reducibility_hints))) : strong_rank_condition (distrib (comm_ring reducibility_hints)) := sorry --non-trivial
lemma new_lemma_18491 (h0 : cancel_comm_monoid_with_zero (ordered_comm_monoid (has_neg pos))) : unique_factorization_monoid (ordered_comm_monoid (has_neg pos)) := sorry --non-trivial
lemma new_lemma_18492 (h0 : add_group (has_neg_part environment.implicit_infer_kind)) : is_add_cyclic (has_neg_part environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_18493 (h0 : topological_space (canonically_ordered_monoid (has_add linarith.comp))) : loc_path_connected_space (canonically_ordered_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_18494 (h0 : complete_lattice (boolean_algebra (comm_semigroup (sub_neg_monoid real)))) : is_compactly_generated (boolean_algebra (comm_semigroup (sub_neg_monoid real))) := sorry --non-trivial
lemma new_lemma_18495 (h0 : function.extfun Type (functor.comp topological_space comm_group)) : @irreducible_space.{0} (comm_group.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} comm_group.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} comm_group.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_18496 (h0 : linarith.comp_source -> linarith.comp_source -> Prop) : is_order_connected linarith.comp_source h0 := sorry --non-trivial
lemma new_lemma_18497 (h0 : functor.add_const (group (add_comm_monoid linarith.comp)) linarith.comp) : @group.fg.{0} (add_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (add_comm_monoid.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_18498 (h0 : topological_space (ordered_comm_monoid (simple_graph (has_to_string pos)))) : regular_space (ordered_comm_monoid (simple_graph (has_to_string pos))) := sorry --non-trivial
lemma new_lemma_18499 (h0 h1 : multiset (mul_one_class (normed_field (normed_field (has_neg enat))))) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_18500 (h0 : function.extfun Type (prod (ordered_cancel_add_comm_monoid ennreal))) : id_rel (function.extfun_app h0 (ordered_cancel_add_comm_monoid ennreal)) := sorry --non-trivial
lemma new_lemma_18501 (h0 : functor.add_const (semiring (has_Inf linarith.comp)) name) : @is_noetherian_ring.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (semiring.{0} (has_Inf.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_18502 (h0 : complete_lattice (complete_semilattice_Sup num)) : is_compactly_generated (complete_semilattice_Sup num) := sorry --non-trivial
lemma new_lemma_18503 (h0 : function.extfun Type (functor.add_const (functor.comp uniform_space add_comm_monoid name))) : @separated_space.{0} (add_comm_monoid.{0} name) (@functor.comp.run.{0 0 0} uniform_space.{0} add_comm_monoid.{0} name (@functor.add_const.run.{0 0} (functor.comp.{0 0 0} uniform_space.{0} add_comm_monoid.{0} name) name (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (functor.comp.{0 0 0} uniform_space.{0} add_comm_monoid.{0} name)) h0 name)))  := sorry --non-trivial
lemma new_lemma_18504 (h0 : group (mul_zero_class (semiring (semiring num)))) : group.fg (mul_zero_class (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_18505 (h0 : topological_space (dlist (dlist to_additive.value_type))) : t0_space (dlist (dlist to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_18506 (h0 : topological_space (has_nnnorm fun_info)) (h1 : preorder (has_nnnorm fun_info)) : order_topology (has_nnnorm fun_info) := sorry --non-trivial
lemma new_lemma_18507 (h2 : topological_space (linear_ordered_add_comm_group linarith.comp_source)) : locally_compact_space (linear_ordered_add_comm_group linarith.comp_source) := sorry --non-trivial
lemma new_lemma_18508 (h0 : functor.add_const (uniform_space (normed_comm_ring Type)) linarith.comp) : @separated_space.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (normed_comm_ring.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_18509 (h0 : filter (comm_group (comm_group unsigned))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_18510 (h0 : uniform_space (metric_space (semiring congr_arg_kind))) : complete_space (metric_space (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_18511 (h0 : has_mem.mem (has_top linarith.comp) has_emptyc.emptyc) : @discrete_topology.{0} (has_top.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_top.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_18512 (h0 : topological_space (bin_tree num)) : path_connected_space (bin_tree num) := sorry --non-trivial
lemma new_lemma_18513 (h0 : complete_lattice (generalized_boolean_algebra (has_add linarith.comp))) : is_compactly_generated (generalized_boolean_algebra (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_18514 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (filter.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (filter.{0} empty))  := sorry --non-trivial
lemma new_lemma_18515 (h0 : topological_space (has_ssubset (random_gen (random_gen (random_gen fun_info))))) : irreducible_space (has_ssubset (random_gen (random_gen (random_gen fun_info)))) := sorry --non-trivial
lemma new_lemma_18516 (h0 : group (add_cancel_monoid (has_add Type))) : is_cyclic (add_cancel_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_18517 (h0 : complete_lattice (linear_ordered_field (option unsigned))) : complete_lattice.is_Sup_finite_compact (linear_ordered_field (option unsigned)) := sorry --non-trivial
lemma new_lemma_18518 (h0 : function.extfun (Type 1) (functor.comp topological_space boolean_algebra)) : @regular_space.{1} (boolean_algebra.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} boolean_algebra.{1} Type (@function.extfun_app.{3 2} (Type 1) (functor.comp.{1 1 1} topological_space.{1} boolean_algebra.{1}) h0 Type))  := sorry --non-trivial
lemma new_lemma_18519 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_emptyc.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_emptyc.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_18520 (h0 : group (has_union (has_top unsigned))) : group.fg (has_union (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_18521 (h0 : topological_space (ring (boolean_algebra (boolean_algebra linarith.comp)))) : totally_separated_space (ring (boolean_algebra (boolean_algebra linarith.comp))) := sorry --non-trivial
lemma new_lemma_18522 (h0 : topological_space (has_neg_part (has_add ennreal))) : totally_separated_space (has_neg_part (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_18523 (h0 : group (measurable_space (has_top (random_gen (has_top linarith.comp_source))))) : normalizer_condition (measurable_space (has_top (random_gen (has_top linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_18524 (h0 : topological_space (generalized_boolean_algebra (finset (has_add linarith.comp)))) : totally_separated_space (generalized_boolean_algebra (finset (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_18525 (h0 : topological_space (has_neg_part (ring (option unsigned)))) : path_connected_space (has_neg_part (ring (option unsigned))) := sorry --non-trivial
lemma new_lemma_18526 (h0 : group (with_one (random_gen (comm_ring (random_gen linarith.ineq))))) : is_cyclic (with_one (random_gen (comm_ring (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_18527 (h0 : topological_space (semi_normed_comm_ring enat)) (h1 : add_group (semi_normed_comm_ring enat)) : topological_add_group (semi_normed_comm_ring enat) := sorry --non-trivial
lemma new_lemma_18528 (h0 : list (has_top (has_inv (normed_group to_additive.value_type)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_18529 (h0 : semiring (generalized_boolean_algebra (finset linarith.comp))) : is_noetherian_ring (generalized_boolean_algebra (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_18530 (h0 : add_monoid (free_add_monoid (semiring unsigned))) : add_monoid.fg (free_add_monoid (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_18531 (h1 : complete_lattice (fintype (random_gen linarith.comp_source))) : complete_lattice.is_Sup_finite_compact (fintype (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_18532 (h0 : cancel_comm_monoid_with_zero (mul_zero_class environment.implicit_infer_kind)) : unique_factorization_monoid (mul_zero_class environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_18533 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (ordered_comm_group congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_18534 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (with_bot.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 topological_space.{0}) (with_bot.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_18535 (h0 : ring (dlist linarith.comp_source)) : rank_condition (dlist linarith.comp_source) := sorry --non-trivial
lemma new_lemma_18536 (h0 : function.extfun Type (prod (comm_group environment.implicit_infer_kind))) : id_rel (function.extfun_app h0 (comm_group environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_18537 (h0 : not (topological_space (has_nnnorm linarith.ineq) -> false)) : @locally_compact_space.{0} (has_nnnorm.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (has_nnnorm.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_18538 (h0 : ring (random_gen (random_gen (comm_ring (comm_ring (random_gen to_additive.value_type)))))) : rank_condition (random_gen (random_gen (comm_ring (comm_ring (random_gen to_additive.value_type))))) := sorry --non-trivial
lemma new_lemma_18539 (h0 : cancel_comm_monoid_with_zero (boolean_algebra (has_neg_part Type))) : unique_factorization_monoid (boolean_algebra (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_18540 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring ennreal)) Type) : @discrete_topology.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@functor.add_const.run.{0 1} (topological_space.{0} (canonically_ordered_comm_semiring.{0} ennreal)) Type h0)  := sorry --non-trivial
lemma new_lemma_18541 (h0 : ring (has_inv (random_gen string_imp))) : rank_condition (has_inv (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_18542 (h0 : group (random_gen (has_norm num))) : group.fg (random_gen (has_norm num)) := sorry --non-trivial
lemma new_lemma_18543 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (has_inter.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (has_inter.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_18544 (h0 : not (topological_space (normed_group unsigned) -> false)) : @topological_space.separable_space.{0} (normed_group.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_group.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_18545 (h1 : has_le (uniform_space linarith.comp_source)) (h2 : bounded_order (uniform_space linarith.comp_source)) : is_simple_order (uniform_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_18546 (h0 : functor.add_const (topological_space (bin_tree num)) (semiring empty)) : @discrete_topology.{0} (bin_tree.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (bin_tree.{0} num)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_18547 (h0 : ordered_comm_monoid (has_bot pos)) : has_exists_mul_of_le (has_bot pos) := sorry --non-trivial
lemma new_lemma_18548 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_18549 (h0 : function.extfun (Type 1) topological_space) : @regular_space.{1} (has_neg.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_neg.{1} Type))  := sorry --non-trivial
lemma new_lemma_18550 (h0 : topological_space (with_bot (with_bot unsigned))) : normal_space (with_bot (with_bot unsigned)) := sorry --non-trivial
lemma new_lemma_18551 (h0 : group (comm_semigroup (has_bot name))) : group.fg (comm_semigroup (has_bot name)) := sorry --non-trivial
lemma new_lemma_18552 (h0 : group (with_one (has_norm fun_info))) : normalizer_condition (with_one (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_18553 (h0 : fin has_zero.zero) : @Lim.{0} Prop sierpinski_space (@nonempty_of_inhabited.{1} Prop sort.inhabited.{0}) (@matrix.vec_empty.{0} (filter.{0} Prop) (@id.{1} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@id.{1} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@id.{1} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))))  := sorry --non-trivial
lemma new_lemma_18554 (h0 : ring (measurable_space to_additive.value_type)) : strong_rank_condition (measurable_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_18555 (h0 : add_group (random_gen (has_nnnorm char))) : is_add_cyclic (random_gen (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_18556 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (has_one.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_18557 (h0 : topological_space (has_to_string (comm_group name))) : path_connected_space (has_to_string (comm_group name)) := sorry --non-trivial
lemma new_lemma_18558 (h0 : functor.add_const (topological_space (has_bot pos)) name) : @totally_disconnected_space.{0} (has_bot.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_bot.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_18559 (h0 : topological_space (boolean_algebra (finset (finset linarith.comp)))) : loc_path_connected_space (boolean_algebra (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_18560 (h0 : functor.add_const (topological_space (has_nndist pos)) Type) : @totally_separated_space.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_nndist.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_18561 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (has_star empty)) := sorry --non-trivial
lemma new_lemma_18562 (h0 : add_group (has_inf fun_info)) : is_add_cyclic (has_inf fun_info) := sorry --non-trivial
lemma new_lemma_18563 (h0 : topological_space (has_nndist (finset (finset pos)))) : totally_disconnected_space (has_nndist (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_18564 (h0 : prod (simple_graph (option (option unsigned))) (simple_graph (option (option unsigned)))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_18565 (h0 : topological_space (canonically_ordered_comm_semiring (cancel_monoid (finset name)))) : t1_space (canonically_ordered_comm_semiring (cancel_monoid (finset name))) := sorry --non-trivial
lemma new_lemma_18566 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (@id.{2} Type (semiring.{0} (semiring.{0} (has_norm.{0} (semiring.{0} num))))) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (@id.{2} Type (semiring.{0} (semiring.{0} (has_norm.{0} (semiring.{0} num))))))  := sorry --non-trivial
lemma new_lemma_18567 (h0 : measurable_space ereal) (h1 : eq char (measure_theory.measure ereal)) (h2 : char) : measure_theory.has_no_atoms (eq.mp h1 h2) := sorry --non-trivial
lemma new_lemma_18568 (h0 : has_le enat) : no_bot_order enat := sorry --non-trivial
lemma new_lemma_18569 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (simple_graph.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (simple_graph.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_18570 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (add_cancel_monoid.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (add_cancel_monoid.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_18571 (h0 : add_monoid (has_top (semiring linarith.comp))) : add_monoid.fg (has_top (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_18572 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (comm_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (comm_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_18573 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} (with_bot.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (with_bot.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_18574 (h0 : not (uniform_space (distrib_lattice char) -> false)) : @complete_space.{0} (distrib_lattice.{0} char) (@classical.by_contradiction'.{1} (uniform_space.{0} (distrib_lattice.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_18575 (h0 : ordered_comm_monoid (add_comm_monoid (finset (has_neg environment.implicit_infer_kind)))) : has_exists_mul_of_le (add_comm_monoid (finset (has_neg environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_18576 (h0 : functor.add_const (complete_lattice (ring pos)) Type) : @complete_lattice.is_Sup_finite_compact.{0} (ring.{0} pos) (@functor.add_const.run.{0 1} (complete_lattice.{0} (ring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_18577 (h0 : functor.add_const (group (has_add environment.implicit_infer_kind)) (ring environment.implicit_infer_kind)) : @normalizer_condition.{0} (has_add.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (has_add.{0} environment.implicit_infer_kind)) (ring.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_18578 (h1 : not (ring (has_lt linarith.comp_source) -> false)) : @strong_rank_condition.{0} (has_lt.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (has_lt.{0} linarith.comp_source)) h1)  := sorry --non-trivial
lemma new_lemma_18579 (h1 : ring (topological_space (random_gen char))) : is_domain (topological_space (random_gen char)) := sorry --non-trivial
lemma new_lemma_18580 (h0 : topological_space (normed_lattice_add_comm_group (has_Inf pos))) : irreducible_space (normed_lattice_add_comm_group (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_18581 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (option.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} h0 (option.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_18582 (h0 : ring (distrib (comm_ring reducibility_hints))) : is_domain (distrib (comm_ring reducibility_hints)) := sorry --non-trivial
lemma new_lemma_18583 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (canonically_linear_ordered_monoid.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_linear_ordered_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_18584 (h0 : measurable_space (has_div (mul_one_class string.iterator_imp))) (h1 : filter (has_div (mul_one_class string.iterator_imp))) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_18585 (h1 : ring (distrib (comm_ring reducibility_hints))) : is_domain (distrib (comm_ring reducibility_hints)) := sorry --non-trivial
lemma new_lemma_18586 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (canonically_ordered_comm_semiring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_18587 (h0 : uniform_space (has_to_string (finset (has_neg linarith.comp)))) : complete_space (has_to_string (finset (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_18588 (h0 : topological_space (ordered_comm_monoid (has_add (has_add linarith.comp)))) : regular_space (ordered_comm_monoid (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_18589 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (complete_semilattice_Sup.{0} (has_ssubset.{0} fun_info)) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (complete_semilattice_Sup.{0} (has_ssubset.{0} fun_info)))  := sorry --non-trivial
lemma new_lemma_18590 (h0 : functor.add_const (group (has_to_string pos)) linarith.comp) : @normalizer_condition.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_to_string.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_18591 (h1 : complete_lattice (add_group unsigned)) : is_atomistic (add_group unsigned) := sorry --non-trivial
lemma new_lemma_18592 (h0 : ring (normed_field (random_gen (has_nnnorm reducibility_hints)))) : rank_condition (normed_field (random_gen (has_nnnorm reducibility_hints))) := sorry --non-trivial
lemma new_lemma_18593 (h0 : group (has_zero (finset linarith.comp))) : is_simple_group (has_zero (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_18594 (h0 : not (ring (comm_ring fun_info) -> false)) : @is_domain.{0} (comm_ring.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (comm_ring.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_18595 (h0 : add_group (has_compl string.iterator_imp)) : is_add_cyclic (has_compl string.iterator_imp) := sorry --non-trivial
lemma new_lemma_18596 (h0 : functor.comp topological_space has_add name) : @t0_space.{0} (has_add.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} has_add.{0} name h0)  := sorry --non-trivial
lemma new_lemma_18597 (h0 : functor.add_const (ring (finset linarith.comp)) Type) : @is_domain.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 1} (ring.{0} (finset.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_18598 (h0 : uniform_space (has_top (has_top linarith.comp_source))) : complete_space (has_top (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_18599 (h0 : function.extfun Type topological_space) : @t0_space.{0} (left_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (left_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_18600 (h0 : functor.add_const (function.extfun Type uniform_space) Type) : @separated_space.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type uniform_space.{0}) Type h0) (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_18601 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (has_top.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_top.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_18602 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @regular_space.{1} (normed_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (normed_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_18603 (h0 : functor.add_const (topological_space (has_neg linarith.comp)) (finset linarith.comp)) : @loc_path_connected_space.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} linarith.comp)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_18604 (h0 : topological_space (complete_distrib_lattice linarith.comp)) : topological_space.separable_space (complete_distrib_lattice linarith.comp) := sorry --non-trivial
lemma new_lemma_18605 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (normed_group.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (normed_group.{0} num))  := sorry --non-trivial
lemma new_lemma_18606 (h0 : topological_space (random_gen (has_top (has_top linarith.ineq)))) : irreducible_space (random_gen (has_top (has_top linarith.ineq))) := sorry --non-trivial
lemma new_lemma_18607 (h0 : function.extfun Type ring) : @rank_condition.{0} (canonically_ordered_comm_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (canonically_ordered_comm_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_18608 (h0 : complete_lattice (semiring (has_top linarith.ineq))) : is_compactly_generated (semiring (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_18609 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (has_union.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_union.{0} empty))  := sorry --non-trivial
lemma new_lemma_18610 (h0 : decidable_eq (with_bot (has_top fun_info))) (h1 : equiv.perm (with_bot (has_top fun_info))) : equiv.perm.is_swap h1 := sorry --non-trivial
lemma new_lemma_18611 (h0 : function.extfun nat fin) : @totally_separated_space.{1} (has_add.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (has_add.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_18612 (h0 : topological_space (random_gen (semiring unsigned))) : t0_space (random_gen (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_18613 (h0 : topological_space (filter empty)) : totally_disconnected_space (filter empty) := sorry --non-trivial
lemma new_lemma_18614 (h2 : filter (add_monoid (comm_ring to_additive.value_type))) : filter.ne_bot h2 := sorry --non-trivial
lemma new_lemma_18615 (h0 : topological_space (complete_semilattice_Sup (has_norm (has_norm empty)))) : path_connected_space (complete_semilattice_Sup (has_norm (has_norm empty))) := sorry --non-trivial
lemma new_lemma_18616 (h0 : topological_space (mul_zero_class ennreal)) : locally_compact_space (mul_zero_class ennreal) := sorry --non-trivial
lemma new_lemma_18617 (h0 : list (random_gen (has_inv linarith.ineq))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_18618 (h0 : topological_space (has_emptyc (random_gen to_additive.value_type))) : irreducible_space (has_emptyc (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_18619 (h0 : topological_space (group_with_zero unsigned)) : totally_separated_space (group_with_zero unsigned) := sorry --non-trivial
lemma new_lemma_18620 (h3 : add_group (topological_space (random_gen fun_info))) : is_add_cyclic (topological_space (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_18621 (h0 : topological_space (has_pos_part (boolean_algebra.core name))) : topological_space.separable_space (has_pos_part (boolean_algebra.core name)) := sorry --non-trivial
lemma new_lemma_18622 (h0 : fin has_zero.zero) : @topological_space.separable_space.{0} (has_add.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (has_add.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_18623 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (monoid unsigned)) := sorry --non-trivial
lemma new_lemma_18624 (h0 : fin has_zero.zero) : @t0_space.{0} (add_comm_monoid.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (add_comm_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_18625 (h0 : topological_space (has_add (normed_comm_ring name))) : t0_space (has_add (normed_comm_ring name)) := sorry --non-trivial
lemma new_lemma_18626 (h2 : has_lt fun_info) : no_max_order fun_info := sorry --non-trivial
lemma new_lemma_18627 (h0 : topological_space (has_append (linear_ordered_add_comm_group_with_top (random_gen (random_gen char))))) : t0_space (has_append (linear_ordered_add_comm_group_with_top (random_gen (random_gen char)))) := sorry --non-trivial
lemma new_lemma_18628 (h0 : functor.add_const (list (linear_ordered_semiring empty)) empty) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_18629 (h0 : complete_lattice (has_neg (has_add Type))) : complete_lattice.is_Sup_finite_compact (has_neg (has_add Type)) := sorry --non-trivial
lemma new_lemma_18630 (h0 : complete_lattice (boolean_algebra.core (finset ennreal))) : complete_lattice.is_Sup_finite_compact (boolean_algebra.core (finset ennreal)) := sorry --non-trivial
lemma new_lemma_18631 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (ordered_ring.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (ordered_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_18632 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} (linear_ordered_add_comm_group.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (linear_ordered_add_comm_group.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_18633 (h0 : functor.add_const (ring (ring pos)) environment.implicit_infer_kind) : @is_principal_ideal_ring.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (ring.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_18634 (h0 : ring (comm_group (finset (add_comm_monoid Type)))) : rank_condition (comm_group (finset (add_comm_monoid Type))) := sorry --non-trivial
lemma new_lemma_18635 (h0 : complete_lattice (normed_comm_ring (finset (mul_one_class linarith.comp)))) : is_compactly_generated (normed_comm_ring (finset (mul_one_class linarith.comp))) := sorry --non-trivial
lemma new_lemma_18636 (h0 : topological_space (has_zero (has_neg_part (has_neg_part Type)))) : loc_path_connected_space (has_zero (has_neg_part (has_neg_part Type))) := sorry --non-trivial
lemma new_lemma_18637 (h0 : topological_space (canonically_ordered_monoid (has_Inf (has_pos_part linarith.comp)))) : totally_disconnected_space (canonically_ordered_monoid (has_Inf (has_pos_part linarith.comp))) := sorry --non-trivial
lemma new_lemma_18638 (h0 : uniform_space (has_Inf (ring pos))) : complete_space (has_Inf (ring pos)) := sorry --non-trivial
lemma new_lemma_18639 (h0 : topological_space (measurable_space.dynkin_system (semiring num))) : totally_disconnected_space (measurable_space.dynkin_system (semiring num)) := sorry --non-trivial
lemma new_lemma_18640 (h0 : uniform_space (mul_one_class linarith.comp_source)) : complete_space (mul_one_class linarith.comp_source) := sorry --non-trivial
lemma new_lemma_18641 (h0 : functor.comp topological_space comm_group name) : @normal_space.{0} (comm_group.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} comm_group.{0} name h0)  := sorry --non-trivial
lemma new_lemma_18642 (h1 : not (ring (with_zero string_imp) -> false)) : @rank_condition.{0} (with_zero.{0} string_imp) (@classical.by_contradiction'.{1} (ring.{0} (with_zero.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_18643 (h1 : function.extfun Type uniform_space) : @complete_space.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h1 (complete_semilattice_Sup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_18644 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_Sup.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_Sup.{0} empty))  := sorry --non-trivial
lemma new_lemma_18645 (h0 : group (has_emptyc (random_gen linarith.ineq))) : normalizer_condition (has_emptyc (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_18646 (h0 : functor.add_const (function.extfun Type finset) (has_pos_part (has_neg Type))) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (has_add pos)) := sorry --non-trivial
lemma new_lemma_18647 (h0 : topological_space (has_top (has_top linarith.ineq))) : t0_space (has_top (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_18648 (h0 : functor.add_const (ordered_comm_monoid (semigroup linarith.comp)) (has_neg (finset linarith.comp))) : @has_exists_mul_of_le.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (semigroup.{0} linarith.comp)) (has_neg.{0} (finset.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_18649 (h0 : topological_space (has_neg_part (cancel_monoid ennreal))) : locally_compact_space (has_neg_part (cancel_monoid ennreal)) := sorry --non-trivial
lemma new_lemma_18650 (h0 : topological_space (has_pos_part name)) : irreducible_space (has_pos_part name) := sorry --non-trivial
lemma new_lemma_18651 (h0 : functor.add_const (finset (group_with_zero empty)) num) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_18652 (h0 : functor.add_const (topological_space (cancel_monoid name)) unsigned) : @totally_disconnected_space.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_18653 (h0 : fin has_zero.zero) : @separated_space.{0} (ordered_comm_monoid.{0} name) (@matrix.vec_empty.{0} (uniform_space.{0} (ordered_comm_monoid.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_18654 (h0 : functor.add_const (ordered_comm_monoid (has_nndist pos)) environment.implicit_infer_kind) : @has_exists_mul_of_le.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_nndist.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_18655 (h0 : topological_space (with_one string_imp)) : locally_compact_space (with_one string_imp) := sorry --non-trivial
lemma new_lemma_18656 (h0 : functor.add_const (group (normed_comm_ring linarith.comp)) (has_to_string name)) : @normalizer_condition.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (normed_comm_ring.{0} linarith.comp)) (has_to_string.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_18657 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_Sup.{0} (add_right_cancel_monoid.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_Sup.{0} (add_right_cancel_monoid.{0} empty)))  := sorry --non-trivial
lemma new_lemma_18658 (h0 : topological_space (random_gen char)) : locally_compact_space (random_gen char) := sorry --non-trivial
lemma new_lemma_18659 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (as_linear_order.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (as_linear_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_18660 (h0 : not (topological_space (has_ssubset (has_ssubset linarith.comp_source)) -> false)) : @totally_disconnected_space.{0} (has_ssubset.{0} (has_ssubset.{0} linarith.comp_source)) (@classical.by_contradiction'.{1} (topological_space.{0} (has_ssubset.{0} (has_ssubset.{0} linarith.comp_source))) h0)  := sorry --non-trivial
lemma new_lemma_18661 (h0 : not (complete_lattice (topological_space linarith.ineq) -> false)) : complete_lattice.is_Sup_finite_compact (topological_space linarith.ineq) := sorry --non-trivial
lemma new_lemma_18662 (h0 : functor.add_const (ring (has_to_string name)) name) : @is_domain.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (has_to_string.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_18663 (h0 : function.extfun Type (functor.comp semiring has_nndist)) : @is_noetherian_ring.{0} (has_nndist.{0} pos) (@functor.comp.run.{0 0 0} semiring.{0} has_nndist.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} semiring.{0} has_nndist.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_18664 (h0 : complete_lattice (with_one (random_gen fun_info))) : is_compactly_generated (with_one (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_18665 (h0 : ring (boolean_algebra (has_neg name))) : is_domain (boolean_algebra (has_neg name)) := sorry --non-trivial
lemma new_lemma_18666 (h0 : complete_lattice (random_gen (with_bot string_imp))) : is_compactly_generated (random_gen (with_bot string_imp)) := sorry --non-trivial
lemma new_lemma_18667 (h0 : topological_space (has_emptyc (random_gen (random_gen fun_info)))) : totally_disconnected_space (has_emptyc (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_18668 (h0 : ring (has_ssubset (random_gen reducibility_hints))) : strong_rank_condition (has_ssubset (random_gen reducibility_hints)) := sorry --non-trivial
lemma new_lemma_18669 (h0 : semiring (linear_order (semiring unsigned))) : is_noetherian_ring (linear_order (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_18670 (h0 : functor.add_const (topological_space (option pos)) pos) : @topological_space.separable_space.{0} (option.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_18671 (h0 : set (char -> enat)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_18672 (h1 : ring (has_ssubset (mul_one_class enat))) : is_domain (has_ssubset (mul_one_class enat)) := sorry --non-trivial
lemma new_lemma_18673 (h0 : ring (plift (has_top (has_top (semiring empty))))) : rank_condition (plift (has_top (has_top (semiring empty)))) := sorry --non-trivial
lemma new_lemma_18674 (h0 : functor.add_const (uniform_space (complete_distrib_lattice linarith.comp)) pos) : @separated_space.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (complete_distrib_lattice.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_18675 (h0 : uniform_space (semi_normed_ring (mul_one_class string_imp))) : complete_space (semi_normed_ring (mul_one_class string_imp)) := sorry --non-trivial
lemma new_lemma_18676 (h1 : not (uniform_space (has_lt string_imp) -> false)) : @complete_space.{0} (has_lt.{0} string_imp) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_lt.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_18677 (h0 : topological_space (comm_group (normed_comm_ring environment.implicit_infer_kind))) : sequential_space (comm_group (normed_comm_ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_18678 (h0 : topological_space (mul_one_class (mul_one_class enat))) : t0_space (mul_one_class (mul_one_class enat)) := sorry --non-trivial
lemma new_lemma_18679 (h0 : uniform_space (has_top (has_inv (random_gen (has_inv fun_info))))) : complete_space (has_top (has_inv (random_gen (has_inv fun_info)))) := sorry --non-trivial
lemma new_lemma_18680 (h0 : filter (semigroup (has_nndist Type))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_18681 (h0 : functor.add_const (topological_space (normed_comm_ring pos)) (finset (comm_group (has_neg linarith.comp)))) : @path_connected_space.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} pos)) (finset.{0} (comm_group.{0} (has_neg.{0} linarith.comp))) h0)  := sorry --non-trivial
lemma new_lemma_18682 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @strong_rank_condition.{0} (add_right_cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) ring.{0}) (add_right_cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_18683 (h0 : uniform_space (complete_semilattice_Sup linarith.comp)) : separated_space (complete_semilattice_Sup linarith.comp) := sorry --non-trivial
lemma new_lemma_18684 (h0 : functor.add_const (monoid (ordered_comm_monoid linarith.comp)) Type) : @monoid.fg.{0} (ordered_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (monoid.{0} (ordered_comm_monoid.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_18685 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (add_left_cancel_monoid linarith.ineq)) := sorry --non-trivial
lemma new_lemma_18686 (h0 : functor.add_const Prop (has_to_string (has_neg_part (finset Type)))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_18687 (h0 : topological_space (has_emptyc string_imp)) : locally_compact_space (has_emptyc string_imp) := sorry --non-trivial
lemma new_lemma_18688 (h0 : function.extfun nat fin) : @normal_space.{0} (has_add.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (has_add.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_18689 (h0 : group (measure_theory.measure_space (semiring (semiring empty)))) : group.fg (measure_theory.measure_space (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_18690 (h1 : uniform_space (has_nnnorm (has_nnnorm char))) : complete_space (has_nnnorm (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_18691 (h0 : functor.comp uniform_space has_to_string ennreal) : @separated_space.{0} (has_to_string.{0} ennreal) (@functor.comp.run.{0 0 0} uniform_space.{0} has_to_string.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_18692 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (add_right_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (add_right_cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_18693 (h0 : ring (left_cancel_semigroup (ordered_cancel_comm_monoid num))) : is_domain (left_cancel_semigroup (ordered_cancel_comm_monoid num)) := sorry --non-trivial
lemma new_lemma_18694 (h0 : topological_space (boolean_algebra name)) : preirreducible_space (boolean_algebra name) := sorry --non-trivial
lemma new_lemma_18695 (h0 : function.extfun (Type 1) add_group) : @is_add_cyclic.{1} Type (@function.extfun_app.{3 2} (Type 1) add_group.{1} h0 Type)  := sorry --non-trivial
lemma new_lemma_18696 (h0 : group (finset (option name))) : group.fg (finset (option name)) := sorry --non-trivial
lemma new_lemma_18697 (h1 : group (has_ssubset (metric_space linarith.comp_source))) : is_cyclic (has_ssubset (metric_space linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_18698 (h0 : complete_lattice (generalized_boolean_algebra name)) : complete_lattice.is_Sup_finite_compact (generalized_boolean_algebra name) := sorry --non-trivial
lemma new_lemma_18699 (h0 : topological_space (comm_group (has_nndist environment.implicit_infer_kind))) : preirreducible_space (comm_group (has_nndist environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_18700 (h0 : functor.add_const (topological_space (normed_comm_ring environment.implicit_infer_kind)) linarith.comp) : @preconnected_space.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_18701 (h0 : functor.add_const (finset (semigroup empty)) (option empty)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_18702 (h0 : functor.add_const (function.extfun (Type 1) topological_space) name) : @totally_disconnected_space.{1} (canonically_ordered_comm_semiring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) name h0) (canonically_ordered_comm_semiring.{1} Type))  := sorry --non-trivial
lemma new_lemma_18703 (h0 : not (add_monoid (has_top linarith.comp) -> false)) : @add_monoid.fg.{0} (has_top.{0} linarith.comp) (@classical.by_contradiction'.{1} (add_monoid.{0} (has_top.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_18704 (h0 : ring (has_zero pos)) : strong_rank_condition (has_zero pos) := sorry --non-trivial
lemma new_lemma_18705 (h0 : ring (semi_normed_ring (mul_one_class (mul_one_class (has_lt linarith.ineq))))) : strong_rank_condition (semi_normed_ring (mul_one_class (mul_one_class (has_lt linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_18706 (h0 : topological_space (id (semiring congr_arg_kind))) : irreducible_space (id (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_18707 (h0 : functor.add_const (topological_space (left_cancel_monoid empty)) num) : @irreducible_space.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_18708 (h0 : topological_space (complete_linear_order num)) : t0_space (complete_linear_order num) := sorry --non-trivial
lemma new_lemma_18709 (h0 : add_monoid (has_inter num)) : add_monoid.fg (has_inter num) := sorry --non-trivial
lemma new_lemma_18710 (h0 : functor.add_const (topological_space pos) unsigned) : @irreducible_space.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) unsigned h0)  := sorry --non-trivial
lemma new_lemma_18711 (h0 : functor.add_const (topological_space (has_star pos)) name) : @locally_compact_space.{0} (has_star.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_18712 (h0 : group (with_bot (has_top (has_inv fun_info)))) : group.fg (with_bot (has_top (has_inv fun_info))) := sorry --non-trivial
lemma new_lemma_18713 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (has_edist.{0} (semiring.{0} empty)) (@function.extfun_app.{2 1} Type semiring.{0} h0 (has_edist.{0} (semiring.{0} empty)))  := sorry --non-trivial
lemma new_lemma_18714 (h0 : functor.add_const (topological_space (has_zero pos)) unsigned) : @normal_space.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_18715 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring unsigned)) pos) : @regular_space.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_18716 (h0 : topological_space (distrib (add_monoid char))) : totally_disconnected_space (distrib (add_monoid char)) := sorry --non-trivial
lemma new_lemma_18717 (h0 : functor.add_const (topological_space (has_bot empty)) num) : @preirreducible_space.{0} (has_bot.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_bot.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_18718 (h1 : uniform_space (add_comm_semigroup enat)) : complete_space (add_comm_semigroup enat) := sorry --non-trivial
lemma new_lemma_18719 (h0 : cancel_comm_monoid_with_zero (normed_lattice_add_comm_group unsigned)) : unique_factorization_monoid (normed_lattice_add_comm_group unsigned) := sorry --non-trivial
lemma new_lemma_18720 (h0 : functor.add_const (topological_space (cancel_monoid pos)) ennreal) : @irreducible_space.{0} (cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} pos)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_18721 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (add_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type semiring.{0} h0 (add_cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_18722 (h0 : not (function.extfun Type add_monoid -> false)) : @add_monoid.fg.{0} (has_top.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_monoid.{0}) h0) (has_top.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_18723 (h0 : topological_space (cancel_monoid (boolean_algebra (boolean_algebra Type)))) : path_connected_space (cancel_monoid (boolean_algebra (boolean_algebra Type))) := sorry --non-trivial
lemma new_lemma_18724 (h0 : group (with_one (random_gen (random_gen (random_gen (random_gen (random_gen string_imp))))))) : group.fg (with_one (random_gen (random_gen (random_gen (random_gen (random_gen string_imp)))))) := sorry --non-trivial
lemma new_lemma_18725 (h0 : cancel_comm_monoid_with_zero (ordered_comm_ring pos)) : unique_factorization_monoid (ordered_comm_ring pos) := sorry --non-trivial
lemma new_lemma_18726 (h0 : topological_space (with_one (has_nnnorm (random_gen (has_nnnorm linarith.comp_source))))) : t0_space (with_one (has_nnnorm (random_gen (has_nnnorm linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_18727 (h0 : topological_space (linear_ordered_comm_ring (left_cancel_semigroup congr_arg_kind))) : t1_space (linear_ordered_comm_ring (left_cancel_semigroup congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_18728 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (semigroup.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} h0 (semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_18729 (h0 : topological_space (boolean_algebra pos)) : irreducible_space (boolean_algebra pos) := sorry --non-trivial
lemma new_lemma_18730 (h0 : uniform_space (add_comm_monoid (ring Type))) : complete_space (add_comm_monoid (ring Type)) := sorry --non-trivial
lemma new_lemma_18731 (h0 : group (measurable_space (has_top (random_gen linarith.comp_source)))) : group.fg (measurable_space (has_top (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_18732 (h0 : add_monoid (add_comm_monoid (has_to_string Type))) : add_monoid.fg (add_comm_monoid (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_18733 (h1 : group (id linarith.ineq)) : normalizer_condition (id linarith.ineq) := sorry --non-trivial
lemma new_lemma_18734 (h0 : complete_lattice (linear_ordered_semiring num)) : is_compactly_generated (linear_ordered_semiring num) := sorry --non-trivial
lemma new_lemma_18735 (h0 : topological_space (has_zero (has_to_string pos))) : irreducible_space (has_zero (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_18736 (h0 : functor.add_const (ring (comm_group Type)) pos) : @rank_condition.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (comm_group.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_18737 (h0 : topological_space (topological_space (semi_normed_ring char))) : path_connected_space (topological_space (semi_normed_ring char)) := sorry --non-trivial
lemma new_lemma_18738 (h1 : complete_lattice (denumerable to_additive.value_type)) : is_compactly_generated (denumerable to_additive.value_type) := sorry --non-trivial
lemma new_lemma_18739 (h0 : function.extfun (finset Type) (has_mem.mem (with_bot unsigned))) : @is_compactly_generated.{0} (with_bot.{0} unsigned) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (with_bot.{0} unsigned) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_bot.{0} unsigned)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_18740 (h0 : ring (semiring (has_norm num))) : strong_rank_condition (semiring (has_norm num)) := sorry --non-trivial
lemma new_lemma_18741 (h0 : function.extfun Type ring) : @rank_condition.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_18742 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @sequential_space.{0} (ordered_comm_ring.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_ring.{0} real))  := sorry --non-trivial
lemma new_lemma_18743 (h0 : filter (has_neg_part unsigned)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_18744 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (left_cancel_semigroup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (left_cancel_semigroup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_18745 (h0 : cancel_comm_monoid_with_zero (mul_zero_class (semiring empty))) : unique_factorization_monoid (mul_zero_class (semiring empty)) := sorry --non-trivial
lemma new_lemma_18746 (h0 : group (has_nndist (has_to_string congr_arg_kind))) : is_simple_group (has_nndist (has_to_string congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_18747 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (add_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_18748 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (normed_comm_ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (normed_comm_ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_18749 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (comm_group.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_18750 (h0 : has_neg (has_le char)) (h1 : measurable_space (has_le char)) : has_measurable_neg (has_le char) := sorry --non-trivial
lemma new_lemma_18751 (h0 : topological_space (add_comm_monoid name)) : locally_compact_space (add_comm_monoid name) := sorry --non-trivial
lemma new_lemma_18752 (h0 : fin has_zero.zero) : @loc_path_connected_space.{0} (canonically_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (canonically_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_18753 (h0 : functor.add_const (function.extfun (Type 1) ring) linarith.comp) : @is_principal_ideal_ring.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ring.{1}) linarith.comp h0) (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_18754 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (linear_order.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_18755 (h0 : add_monoid (ordered_comm_ring (has_add (has_Inf linarith.comp)))) : add_monoid.fg (ordered_comm_ring (has_add (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_18756 (h0 : add_group (has_union (semiring congr_arg_kind))) : is_add_cyclic (has_union (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_18757 (h0 : functor.add_const (topological_space (has_neg_part ennreal)) ennreal) : @regular_space.{0} (has_neg_part.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_18758 (h0 : uniform_space (linear_ordered_semiring (has_norm num))) : complete_space (linear_ordered_semiring (has_norm num)) := sorry --non-trivial
lemma new_lemma_18759 (h0 : list (simple_graph Type)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_18760 (h0 : functor.add_const (topological_space (ordered_comm_monoid pos)) linarith.comp) : @t1_space.{0} (ordered_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_monoid.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_18761 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @is_domain.{0} (has_pos_part.{0} name) (@matrix.vec_empty.{0} (ring.{0} (has_pos_part.{0} name)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_18762 (h1 : has_lt (nondiscrete_normed_field (add_comm_semigroup (add_comm_semigroup char)))) : no_max_order (nondiscrete_normed_field (add_comm_semigroup (add_comm_semigroup char))) := sorry --non-trivial
lemma new_lemma_18763 (h0 : ring (add_left_cancel_monoid to_additive.value_type)) : rank_condition (add_left_cancel_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_18764 (h0 : add_monoid (semiring (measure_theory.measure_space num))) : add_monoid.fg (semiring (measure_theory.measure_space num)) := sorry --non-trivial
lemma new_lemma_18765 (h0 : uniform_space (linear_order congr_arg_kind)) : separated_space (linear_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_18766 (h0 : topological_space (bin_tree unsigned)) : normal_space (bin_tree unsigned) := sorry --non-trivial
lemma new_lemma_18767 (h0 : functor.add_const (filter (add_comm_monoid linarith.comp)) linarith.comp) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_18768 (h0 : functor.add_const (finset (canonically_linear_ordered_monoid unsigned)) (option name)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_18769 (h0 : topological_space (add_comm_monoid num)) : t1_space (add_comm_monoid num) := sorry --non-trivial
lemma new_lemma_18770 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (dlist.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (dlist.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_18771 (h0 : set (nondiscrete_normed_field string.iterator_imp -> enat)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_18772 (h0 : complete_lattice (has_top (has_norm (has_norm (semiring fun_info))))) : complete_lattice.is_Sup_finite_compact (has_top (has_norm (has_norm (semiring fun_info)))) := sorry --non-trivial
lemma new_lemma_18773 (h0 : semigroup num -> semigroup num -> Prop) : is_symm (semigroup num) h0 := sorry --non-trivial
lemma new_lemma_18774 (h0 : functor.add_const (function.extfun (Type 1) ring) (ring Type)) : @rank_condition.{1} (generalized_boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) ring.{1}) (ring.{1} Type) h0) (generalized_boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_18775 (h0 : uniform_space (has_nnnorm (mul_one_class (mul_one_class linarith.ineq)))) : complete_space (has_nnnorm (mul_one_class (mul_one_class linarith.ineq))) := sorry --non-trivial
lemma new_lemma_18776 (h0 : topological_space (monoid ennreal)) : totally_disconnected_space (monoid ennreal) := sorry --non-trivial
lemma new_lemma_18777 (h1 : group (has_ssubset (denumerable linarith.ineq))) : is_cyclic (has_ssubset (denumerable linarith.ineq)) := sorry --non-trivial
lemma new_lemma_18778 (h0 : group (sub_neg_monoid (has_Inf linarith.comp))) : group.fg (sub_neg_monoid (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_18779 (h0 : filter (has_to_string (option (option (option (option (option (option unsigned)))))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_18780 (h0 : ring (normed_comm_ring empty)) : is_domain (normed_comm_ring empty) := sorry --non-trivial
lemma new_lemma_18781 (h0 : functor.add_const (topological_space (boolean_algebra name)) pos) : @preirreducible_space.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_18782 (h0 : topological_space (add_comm_monoid real)) : topological_space.separable_space (add_comm_monoid real) := sorry --non-trivial
lemma new_lemma_18783 (h0 : complete_lattice (normed_lattice_add_comm_group (has_add linarith.comp))) : complete_lattice.is_Sup_finite_compact (normed_lattice_add_comm_group (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_18784 (h0 : uniform_space (normed_comm_ring (option (option empty)))) : complete_space (normed_comm_ring (option (option empty))) := sorry --non-trivial
lemma new_lemma_18785 (h0 : group (finset (has_neg (finset Type)))) : group.fg (finset (has_neg (finset Type))) := sorry --non-trivial
lemma new_lemma_18786 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (ordered_ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_18787 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (has_dist.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_dist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_18788 (h0 : semiring (ordered_comm_group (option unsigned))) : is_noetherian_ring (ordered_comm_group (option unsigned)) := sorry --non-trivial
lemma new_lemma_18789 (h0 : add_group (distrib_lattice to_additive.value_type)) : is_add_cyclic (distrib_lattice to_additive.value_type) := sorry --non-trivial
lemma new_lemma_18790 (h0 : topological_space name) : irreducible_space name := sorry --non-trivial
lemma new_lemma_18791 (h0 : group (simple_graph (has_to_string (has_add (has_add (has_add (has_add pos))))))) : is_cyclic (simple_graph (has_to_string (has_add (has_add (has_add (has_add pos)))))) := sorry --non-trivial
lemma new_lemma_18792 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (linear_ordered_field.{0} pos) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (linear_ordered_field.{0} pos))  := sorry --non-trivial
lemma new_lemma_18793 (h0 : not (ring (linear_ordered_semiring unsigned) -> false)) : @is_domain.{0} (linear_ordered_semiring.{0} unsigned) (@classical.by_contradiction'.{1} (ring.{0} (linear_ordered_semiring.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_18794 (h0 : order_hom nat (topological_space (topological_space linarith.comp_source))) : @t0_space.{0} (topological_space.{0} linarith.comp_source) (@monotonic_sequence_limit.{0} (topological_space.{0} (topological_space.{0} linarith.comp_source)) (@topological_space.partial_order.{0} (topological_space.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_18795 (h0 : uniform_space (has_add (normed_comm_ring (has_add (has_add name))))) : separated_space (has_add (normed_comm_ring (has_add (has_add name)))) := sorry --non-trivial
lemma new_lemma_18796 (h0 : topological_space (cancel_monoid (has_nndist name))) : t0_space (cancel_monoid (has_nndist name)) := sorry --non-trivial
lemma new_lemma_18797 (h0 : topological_space (has_neg (has_to_string (has_to_string congr_arg_kind)))) : preirreducible_space (has_neg (has_to_string (has_to_string congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_18798 (h0 : topological_space (add_comm_monoid (has_Inf real))) : totally_disconnected_space (add_comm_monoid (has_Inf real)) := sorry --non-trivial
lemma new_lemma_18799 (h0 : functor.add_const (topological_space (has_add pos)) environment.implicit_infer_kind) : @regular_space.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_18800 (h0 : topological_space (canonically_ordered_monoid (has_neg (has_neg name)))) : normal_space (canonically_ordered_monoid (has_neg (has_neg name))) := sorry --non-trivial
lemma new_lemma_18801 (h0 : topological_space (mul_zero_class name)) : path_connected_space (mul_zero_class name) := sorry --non-trivial
lemma new_lemma_18802 (h0 : monoid (comm_semigroup (has_bot (has_bot (has_bot real))))) : monoid.fg (comm_semigroup (has_bot (has_bot (has_bot real)))) := sorry --non-trivial
lemma new_lemma_18803 (h0 : uniform_space (has_add (option unsigned))) : separated_space (has_add (option unsigned)) := sorry --non-trivial
lemma new_lemma_18804 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (bin_tree.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (bin_tree.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_18805 (h0 : topological_space (add_cancel_monoid (has_add name))) : sequential_space (add_cancel_monoid (has_add name)) := sorry --non-trivial
lemma new_lemma_18806 (h0 : functor.add_const (group (finset linarith.comp)) Type) : @normalizer_condition.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 1} (group.{0} (finset.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_18807 (h0 : functor.add_const (group (has_Inf Type)) pos) : @group.fg.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (has_Inf.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_18808 (h0 : topological_space (boolean_algebra real)) : preirreducible_space (boolean_algebra real) := sorry --non-trivial
lemma new_lemma_18809 (h0 : functor.add_const (monoid (canonically_ordered_comm_semiring pos)) Type) : @monoid.fg.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.add_const.run.{0 1} (monoid.{0} (canonically_ordered_comm_semiring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_18810 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (ordered_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (ordered_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_18811 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_18812 (h0 : uniform_space (has_bot linarith.comp)) : complete_space (has_bot linarith.comp) := sorry --non-trivial
lemma new_lemma_18813 (h0 : uniform_space (has_to_string pos)) : separated_space (has_to_string pos) := sorry --non-trivial
lemma new_lemma_18814 (h0 : complete_lattice congr_arg_kind) : is_compactly_generated congr_arg_kind := sorry --non-trivial
lemma new_lemma_18815 (h0 : functor.add_const (topological_space (has_inter empty)) unsigned) : @topological_space.separable_space.{0} (has_inter.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_inter.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_18816 (h0 : topological_space (normed_field linarith.comp_source)) : totally_disconnected_space (normed_field linarith.comp_source) := sorry --non-trivial
lemma new_lemma_18817 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (ordered_comm_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_18818 (h0 : uniform_space (has_to_string (finset (finset (finset (ring linarith.comp)))))) : complete_space (has_to_string (finset (finset (finset (ring linarith.comp))))) := sorry --non-trivial
lemma new_lemma_18819 (h0 : semiring (has_union (semiring (semiring congr_arg_kind)))) : is_noetherian_ring (has_union (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_18820 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (ordered_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_18821 (h0 : uniform_space (ring (has_Inf name))) : separated_space (ring (has_Inf name)) := sorry --non-trivial
lemma new_lemma_18822 (h0 : topological_space (non_unital_non_assoc_semiring linarith.ineq)) (h1 : not (preorder (non_unital_non_assoc_semiring linarith.ineq) -> false)) : @order_topology.{0} (non_unital_non_assoc_semiring.{0} linarith.ineq) h0 (@classical.by_contradiction'.{1} (preorder.{0} (non_unital_non_assoc_semiring.{0} linarith.ineq)) h1)  := sorry --non-trivial
lemma new_lemma_18823 (h0 : topological_space (has_add (has_nnnorm (has_nnnorm fun_info)))) : path_connected_space (has_add (has_nnnorm (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_18824 (h0 : functor.add_const (semiring (omega_complete_partial_order empty)) empty) : @is_noetherian_ring.{0} (omega_complete_partial_order.{0} empty) (@functor.add_const.run.{0 0} (semiring.{0} (omega_complete_partial_order.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_18825 (h0 : topological_space (has_top (with_bot to_additive.value_type))) : t0_space (has_top (with_bot to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_18826 (h0 : not (topological_space (option num) -> false)) : @irreducible_space.{0} (option.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (option.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_18827 (h0 : functor.add_const (filter (normed_comm_ring name)) Type) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_18828 (h0 : topological_space (comm_group unsigned)) : irreducible_space (comm_group unsigned) := sorry --non-trivial
lemma new_lemma_18829 (h0 : functor.add_const (finset (semigroup name)) name) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_18830 (h0 : functor.add_const (filter (has_nndist pos)) Type) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_18831 (h0 : function.extfun Type ring) : @is_domain.{0} (has_zero.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_18832 (h0 : topological_space (is_R_or_C (has_neg_part (has_nndist (has_add linarith.comp))))) : totally_separated_space (is_R_or_C (has_neg_part (has_nndist (has_add linarith.comp)))) := sorry --non-trivial
lemma new_lemma_18833 (h0 : function.extfun Type group) : @is_cyclic.{0} (normed_group.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} h0 (normed_group.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_18834 (h0 : functor.add_const (complete_lattice (has_neg pos)) (has_neg (normed_comm_ring pos))) : @complete_lattice.is_Sup_finite_compact.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_neg.{0} pos)) (has_neg.{0} (normed_comm_ring.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_18835 (h0 : group (complete_semilattice_Sup (semiring empty))) : normalizer_condition (complete_semilattice_Sup (semiring empty)) := sorry --non-trivial
lemma new_lemma_18836 (h0 : Type) (h1 : eq h0 Prop) (h2 : h0) : cast h1 h2 := sorry --non-trivial
lemma new_lemma_18837 (h0 : topological_space (ring (has_neg (has_neg pos)))) : t0_space (ring (has_neg (has_neg pos))) := sorry --non-trivial
lemma new_lemma_18838 (h0 : functor.add_const (topological_space (add_cancel_monoid pos)) pos) : @discrete_topology.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_18839 (h0 : group (ring (ring Type))) : is_cyclic (ring (ring Type)) := sorry --non-trivial
lemma new_lemma_18840 (h0 : not (topological_space (has_div (has_nnnorm string.iterator_imp)) -> false)) : @totally_disconnected_space.{0} (has_div.{0} (has_nnnorm.{0} string.iterator_imp)) (@classical.by_contradiction'.{1} (topological_space.{0} (has_div.{0} (has_nnnorm.{0} string.iterator_imp))) h0)  := sorry --non-trivial
lemma new_lemma_18841 (h0 : ordered_add_comm_monoid (canonically_ordered_monoid (has_Inf Type))) : archimedean (canonically_ordered_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_18842 (h0 : not (complete_lattice (measurable_space empty) -> false)) : is_atomistic (measurable_space empty) := sorry --non-trivial
lemma new_lemma_18843 (h0 : ring (generalized_boolean_algebra (canonically_linear_ordered_monoid real))) : rank_condition (generalized_boolean_algebra (canonically_linear_ordered_monoid real)) := sorry --non-trivial
lemma new_lemma_18844 (h0 : functor.add_const (topological_space (boolean_algebra pos)) pos) : @irreducible_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_18845 (h0 : topological_space (boolean_algebra (has_neg pos))) : preirreducible_space (boolean_algebra (has_neg pos)) := sorry --non-trivial
lemma new_lemma_18846 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (add_group.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (add_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_18847 (h0 : ring (topological_space (random_gen (random_gen string_imp)))) : is_domain (topological_space (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_18848 (h0 : topological_space (semigroup (finset (has_Inf (finset linarith.comp))))) : discrete_topology (semigroup (finset (has_Inf (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_18849 (h0 : group (add_group (semiring congr_arg_kind))) : is_cyclic (add_group (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_18850 (h0 : functor.add_const (list (has_nndist congr_arg_kind)) unsigned) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_18851 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @path_connected_space.{0} (with_one.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) topological_space.{0}) (with_one.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_18852 (h0 : not (cancel_comm_monoid_with_zero (has_one empty) -> false)) : @unique_factorization_monoid.{0} (has_one.{0} empty) (@classical.by_contradiction'.{1} (cancel_comm_monoid_with_zero.{0} (has_one.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_18853 (h0 : function.extfun (Type 1) complete_lattice) : @is_compactly_generated.{1} (plift.{1} unsigned) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} h0 (plift.{1} unsigned))  := sorry --non-trivial
lemma new_lemma_18854 (h0 : add_monoid (has_bot (option (option (option (option (option (option (option unsigned))))))))) : add_monoid.fg (has_bot (option (option (option (option (option (option (option unsigned)))))))) := sorry --non-trivial
lemma new_lemma_18855 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (ring.{0} name) (@function.extfun_app.{2 1} Type monoid.{0} h0 (ring.{0} name))  := sorry --non-trivial
lemma new_lemma_18856 (h0 : functor.add_const (uniform_space (has_zero Type)) (ring pos)) : @separated_space.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (has_zero.{1} Type)) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_18857 (h0 : uniform_space (cancel_monoid (has_add name))) : complete_space (cancel_monoid (has_add name)) := sorry --non-trivial
lemma new_lemma_18858 (h0 : not (function.extfun Type topological_space -> false)) : @topological_space.separable_space.{0} (measure_theory.measure_space.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (measure_theory.measure_space.{0} num))  := sorry --non-trivial
lemma new_lemma_18859 (h0 : topological_space (encodable (has_inv (denumerable to_additive.value_type)))) : locally_compact_space (encodable (has_inv (denumerable to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_18860 (h0 : functor.add_const (topological_space (has_dist unsigned)) num) : @path_connected_space.{0} (has_dist.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_dist.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_18861 (h0 : function.extfun Type (functor.add_const (fin has_zero.zero))) : @is_atomistic.{1} (normed_lattice_add_comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@matrix.vec_empty.{2} (function.extfun.{3 2} (Type 1) complete_lattice.{1}) (@functor.add_const.run.{0 0} (fin (@has_zero.zero.{0} nat nat.has_zero)) real (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (fin (@has_zero.zero.{0} nat nat.has_zero))) h0 real))) (normed_lattice_add_comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_18862 (h0 : ring (with_one (random_gen (random_gen (random_gen fun_info))))) : strong_rank_condition (with_one (random_gen (random_gen (random_gen fun_info)))) := sorry --non-trivial
lemma new_lemma_18863 (h0 : not (has_mem.mem (has_top linarith.ineq) has_emptyc.emptyc -> false)) : @strong_rank_condition.{0} (has_top.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type ring.{0} (has_top.{0} linarith.ineq) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_top.{0} linarith.ineq) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_18864 (h0 : functor.add_const (function.extfun (Type 1) topological_space) Type) : @t1_space.{1} (generalized_boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) Type h0) (generalized_boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_18865 (h0 : functor.add_const (complete_lattice (has_neg name)) linarith.comp) : @complete_lattice.is_Sup_finite_compact.{0} (has_neg.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_neg.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_18866 (h0 : not (ring (measurable_space.dynkin_system unsigned) -> false)) : @rank_condition.{0} (measurable_space.dynkin_system.{0} unsigned) (@classical.by_contradiction'.{1} (ring.{0} (measurable_space.dynkin_system.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_18867 (h0 : topological_space (boolean_algebra unsigned)) : normal_space (boolean_algebra unsigned) := sorry --non-trivial
lemma new_lemma_18868 (h0 : uniform_space (simple_graph (has_scalar (mul_one_class (mul_one_class string.iterator_imp)) char))) : complete_space (simple_graph (has_scalar (mul_one_class (mul_one_class string.iterator_imp)) char)) := sorry --non-trivial
lemma new_lemma_18869 (h0 : filter (mul_one_class (mul_one_class linarith.ineq))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_18870 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @locally_compact_space.{0} (measurable_space.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (measurable_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_18871 (h0 : complete_lattice (with_bot (has_one (random_gen (semiring fun_info))))) : is_compactly_generated (with_bot (has_one (random_gen (semiring fun_info)))) := sorry --non-trivial
lemma new_lemma_18872 (h0 : filter (has_add to_additive.value_type)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_18873 (h0 : Prop -> occurrences) (h1 : coe_sort (set.range h0)) : set.range_splitting h0 h1 := sorry --non-trivial
lemma new_lemma_18874 (h0 : functor.add_const (topological_space (complete_distrib_lattice ennreal)) num) : @locally_compact_space.{0} (complete_distrib_lattice.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} ennreal)) num h0)  := sorry --non-trivial
lemma new_lemma_18875 (h0 : fin has_zero.zero) : @has_exists_mul_of_le.{0} (comm_semigroup.{0} real) (@matrix.vec_empty.{0} (ordered_comm_monoid.{0} (comm_semigroup.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_18876 (h0 : functor.add_const (topological_space (boolean_algebra pos)) (has_neg (has_neg name))) : @regular_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} pos)) (has_neg.{0} (has_neg.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_18877 (h0 : set (has_ssubset enat)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_18878 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_one.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_18879 (h0 : semiring (mul_zero_class empty)) : is_noetherian_ring (mul_zero_class empty) := sorry --non-trivial
lemma new_lemma_18880 (h0 : group (group_with_zero pos)) : group.fg (group_with_zero pos) := sorry --non-trivial
lemma new_lemma_18881 (h1 : topological_space (measurable_space (semiring (semiring empty)))) : locally_compact_space (measurable_space (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_18882 (h0 : complete_lattice (semi_normed_ring (comm_ring (comm_ring char)))) : is_compactly_generated (semi_normed_ring (comm_ring (comm_ring char))) := sorry --non-trivial
lemma new_lemma_18883 (h1 : function.extfun Type topological_space) : @totally_separated_space.{0} (semiring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_18884 (h0 : uniform_space (normed_comm_ring empty)) : separated_space (normed_comm_ring empty) := sorry --non-trivial
lemma new_lemma_18885 (h0 : group (with_one (preorder linarith.comp_source))) : normalizer_condition (with_one (preorder linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_18886 (h0 : group (has_nndist (has_to_string (has_add environment.implicit_infer_kind)))) : is_cyclic (has_nndist (has_to_string (has_add environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_18887 (h0 : uniform_space (has_to_string (has_zero pos))) : complete_space (has_to_string (has_zero pos)) := sorry --non-trivial
lemma new_lemma_18888 (h1 : not (ring (fintype (comm_ring (comm_ring (comm_ring char)))) -> false)) : @rank_condition.{0} (fintype.{0} (comm_ring.{0} (comm_ring.{0} (comm_ring.{0} char)))) (@classical.by_contradiction'.{1} (ring.{0} (fintype.{0} (comm_ring.{0} (comm_ring.{0} (comm_ring.{0} char))))) h1)  := sorry --non-trivial
lemma new_lemma_18889 (h0 : functor.add_const (topological_space (finset name)) unsigned) : @topological_space.separable_space.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_18890 (h0 : list (preorder (option empty))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_18891 (h0 : topological_space (group_with_zero congr_arg_kind)) : locally_compact_space (group_with_zero congr_arg_kind) := sorry --non-trivial
lemma new_lemma_18892 (h0 : topological_space enat) : t0_space enat := sorry --non-trivial
lemma new_lemma_18893 (h0 : not (function.extfun Type group -> false)) : @normalizer_condition.{0} (has_emptyc.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (has_emptyc.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_18894 (h0 : topological_space (ring (option (option empty)))) : normal_space (ring (option (option empty))) := sorry --non-trivial
lemma new_lemma_18895 (h0 : set (prod fun_info fun_info)) : symmetric_rel h0 := sorry --non-trivial
lemma new_lemma_18896 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_18897 (h0 : not (function.extfun Type ring -> false)) : @rank_condition.{0} (add_group.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (add_group.{0} num))  := sorry --non-trivial
lemma new_lemma_18898 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (encodable fun_info)) := sorry --non-trivial
lemma new_lemma_18899 (h0 : ring (div_inv_monoid fun_info)) : rank_condition (div_inv_monoid fun_info) := sorry --non-trivial
lemma new_lemma_18900 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} (comm_ring.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (comm_ring.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_18901 (h0 : add_group (random_gen (semiring (semiring (semiring empty))))) : is_add_cyclic (random_gen (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_18902 (h0 : function.extfun nat fin) : @separated_space.{0} (normed_lattice_add_comm_group.{0} (has_neg.{0} pos)) (@matrix.vec_empty.{0} (uniform_space.{0} (normed_lattice_add_comm_group.{0} (has_neg.{0} pos))) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_18903 (h0 : topological_space (normed_linear_ordered_group unsigned)) : irreducible_space (normed_linear_ordered_group unsigned) := sorry --non-trivial
lemma new_lemma_18904 (h0 : functor.add_const (add_monoid (finset linarith.comp)) pos) : @add_monoid.fg.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_monoid.{0} (finset.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_18905 (h0 : topological_space (canonically_linear_ordered_monoid (has_Inf (finset real)))) : path_connected_space (canonically_linear_ordered_monoid (has_Inf (finset real))) := sorry --non-trivial
lemma new_lemma_18906 (h0 : complete_lattice (has_nndist (has_nndist pos))) : is_atomistic (has_nndist (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_18907 (h0 : topological_space (complete_distrib_lattice (option (option pos)))) : totally_separated_space (complete_distrib_lattice (option (option pos))) := sorry --non-trivial
lemma new_lemma_18908 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (normed_lattice_add_comm_group.{0} real) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (normed_lattice_add_comm_group.{0} real))  := sorry --non-trivial
lemma new_lemma_18909 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @complete_space.{0} (linear_ordered_comm_ring.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) uniform_space.{0}) (linear_ordered_comm_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_18910 (h0 : complete_lattice (normed_comm_ring (has_add Type))) : is_compactly_generated (normed_comm_ring (has_add Type)) := sorry --non-trivial
lemma new_lemma_18911 (h0 : set (has_nnnorm (has_nnnorm reducibility_hints))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_18912 (h0 : functor.comp (functor.add_const Prop) has_neg pos) : functor.add_const.run (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_18913 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (add_comm_monoid.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (add_comm_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_18914 (h0 : ring (has_star num)) : rank_condition (has_star num) := sorry --non-trivial
lemma new_lemma_18915 (h0 : add_monoid (has_bot unsigned)) : add_monoid.fg (has_bot unsigned) := sorry --non-trivial
lemma new_lemma_18916 (h0 : topological_space (has_zero name)) : preirreducible_space (has_zero name) := sorry --non-trivial
lemma new_lemma_18917 (h0 : functor.add_const (complete_lattice (ordered_comm_monoid pos)) linarith.comp) : @is_compactly_generated.{0} (ordered_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ordered_comm_monoid.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_18918 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (measurable_space.dynkin_system.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (measurable_space.dynkin_system.{0} empty))  := sorry --non-trivial
lemma new_lemma_18919 (h0 : fin has_zero.zero) : @preirreducible_space.{0} pos (@matrix.vec_empty.{0} (topological_space.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_18920 (h0 : functor.add_const (group (has_nndist name)) (option pos)) : @is_simple_group.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (group.{0} (has_nndist.{0} name)) (option.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_18921 (h0 : topological_space (has_add (normed_comm_ring unsigned))) : discrete_topology (has_add (normed_comm_ring unsigned)) := sorry --non-trivial
lemma new_lemma_18922 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (preorder.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (preorder.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_18923 (h0 : topological_space (nondiscrete_normed_field (normed_field linarith.ineq))) (h1 : add_group (nondiscrete_normed_field (normed_field linarith.ineq))) : topological_add_group (nondiscrete_normed_field (normed_field linarith.ineq)) := sorry --non-trivial
lemma new_lemma_18924 (h0 : functor.add_const (topological_space znum) (option unsigned)) : @totally_separated_space.{0} znum (@functor.add_const.run.{0 0} (topological_space.{0} znum) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_18925 (h0 : functor.add_const (function.extfun Type group) pos) : @group.fg.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) pos h0) (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_18926 (h0 : fin has_zero.zero) : @archimedean.{0} (has_pos_part.{0} linarith.comp) (@matrix.vec_empty.{0} (ordered_add_comm_monoid.{0} (has_pos_part.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_18927 (h0 : not (ring (measure_theory.measure_space unsigned) -> false)) : @is_principal_ideal_ring.{0} (measure_theory.measure_space.{0} unsigned) (@classical.by_contradiction'.{1} (ring.{0} (measure_theory.measure_space.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_18928 (h0 : functor.add_const (ring (has_neg empty)) empty) : @is_principal_ideal_ring.{0} (has_neg.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (has_neg.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_18929 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_bot.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_bot.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_18930 (h0 : group (ordered_cancel_add_comm_monoid ennreal)) : group.fg (ordered_cancel_add_comm_monoid ennreal) := sorry --non-trivial
lemma new_lemma_18931 (h0 : functor.add_const (list (has_neg Type)) Type) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_18932 (h0 : not (topological_space (has_sub unsigned) -> false)) : @totally_disconnected_space.{0} (has_sub.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (has_sub.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_18933 (h0 : uniform_space (ordered_comm_ring (has_add pos))) : separated_space (ordered_comm_ring (has_add pos)) := sorry --non-trivial
lemma new_lemma_18934 (h0 : functor.add_const (filter (has_nndist pos)) (boolean_algebra Type)) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_18935 (h0 : functor.add_const (function.extfun Type group) pos) : @is_cyclic.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) pos h0) (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_18936 (h0 : ring (ordered_comm_monoid linarith.comp_source)) : strong_rank_condition (ordered_comm_monoid linarith.comp_source) := sorry --non-trivial
lemma new_lemma_18937 (h0 : ring (complete_distrib_lattice (finset (ordered_comm_ring Type)))) : is_domain (complete_distrib_lattice (finset (ordered_comm_ring Type))) := sorry --non-trivial
lemma new_lemma_18938 (h0 : functor.add_const (add_group (has_nndist linarith.comp)) Type) : @is_add_cyclic.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 1} (add_group.{0} (has_nndist.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_18939 (h1 : function.extfun Type topological_space) : @t0_space.{0} (comm_ring.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (comm_ring.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_18940 (h0 : topological_space (normed_comm_ring (comm_group pos))) : discrete_topology (normed_comm_ring (comm_group pos)) := sorry --non-trivial
lemma new_lemma_18941 (h0 : topological_space (has_to_string (finset pos))) : preirreducible_space (has_to_string (finset pos)) := sorry --non-trivial
lemma new_lemma_18942 (h0 : functor.add_const (topological_space znum) num) : @t1_space.{0} znum (@functor.add_const.run.{0 0} (topological_space.{0} znum) num h0)  := sorry --non-trivial
lemma new_lemma_18943 (h0 : functor.add_const (function.extfun (Type 1) topological_space) linarith.comp) : @discrete_topology.{1} (boolean_algebra.core.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) linarith.comp h0) (boolean_algebra.core.{1} Type))  := sorry --non-trivial
lemma new_lemma_18944 (h0 : not (group (has_top linarith.comp) -> false)) : @normalizer_condition.{0} (has_top.{0} linarith.comp) (@classical.by_contradiction'.{1} (group.{0} (has_top.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_18945 (h0 : functor.add_const (function.extfun Type ring) pos) : @is_principal_ideal_ring.{0} (has_to_string.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) pos h0) (has_to_string.{0} name))  := sorry --non-trivial
lemma new_lemma_18946 (h0 : topological_space (boolean_algebra.core (has_add (has_add Type)))) : t0_space (boolean_algebra.core (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_18947 (h0 : monoid (has_sub (has_norm empty))) : monoid.fg (has_sub (has_norm empty)) := sorry --non-trivial
lemma new_lemma_18948 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (normed_comm_ring pos)) := sorry --non-trivial
lemma new_lemma_18949 (h0 : monoid (simple_graph (has_add (boolean_algebra.core linarith.comp)))) : monoid.fg (simple_graph (has_add (boolean_algebra.core linarith.comp))) := sorry --non-trivial
lemma new_lemma_18950 (h1 : topological_space (metric_space (comm_ring reducibility_hints))) : t0_space (metric_space (comm_ring reducibility_hints)) := sorry --non-trivial
lemma new_lemma_18951 (h0 : group (semiring (semiring empty))) : normalizer_condition (semiring (semiring empty)) := sorry --non-trivial
lemma new_lemma_18952 (h1 : uniform_space (nondiscrete_normed_field environment.projection_info)) : complete_space (nondiscrete_normed_field environment.projection_info) := sorry --non-trivial
lemma new_lemma_18953 (h0 : topological_space (add_comm_monoid (has_to_string (has_to_string unsigned)))) : totally_separated_space (add_comm_monoid (has_to_string (has_to_string unsigned))) := sorry --non-trivial
lemma new_lemma_18954 (h0 : monoid (omega_complete_partial_order (option (semiring empty)))) : monoid.fg (omega_complete_partial_order (option (semiring empty))) := sorry --non-trivial
lemma new_lemma_18955 (h0 : functor.add_const (topological_space (comm_group environment.implicit_infer_kind)) name) : @loc_path_connected_space.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_18956 (h0 : functor.add_const (topological_space (left_cancel_monoid empty)) empty) : @preirreducible_space.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_18957 (h0 : add_group (ring (has_neg linarith.comp))) : is_add_cyclic (ring (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_18958 (h0 : functor.add_const (topological_space (has_to_string environment.implicit_infer_kind)) unsigned) : @path_connected_space.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} environment.implicit_infer_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_18959 (h0 : functor.add_const (add_monoid (has_neg_part environment.implicit_infer_kind)) Type) : @add_monoid.fg.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (add_monoid.{0} (has_neg_part.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_18960 (h0 : complete_lattice (has_neg (boolean_algebra name))) : is_compactly_generated (has_neg (boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_18961 (h0 : functor.add_const (monoid (simple_graph Type)) Type) : @monoid.fg.{1} (simple_graph.{1} Type) (@functor.add_const.run.{1 1} (monoid.{1} (simple_graph.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_18962 (h0 : topological_space (has_neg (comm_group (comm_group Type)))) : totally_separated_space (has_neg (comm_group (comm_group Type))) := sorry --non-trivial
lemma new_lemma_18963 (h0 : functor.add_const (group (pseudo_metric_space unsigned)) num) : @is_cyclic.{0} (pseudo_metric_space.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (pseudo_metric_space.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_18964 (h1 : set (has_ssubset (mul_one_class to_additive.value_type))) : set.finite h1 := sorry --non-trivial
lemma new_lemma_18965 (h0 : add_group (semigroup (has_neg linarith.comp))) : is_add_cyclic (semigroup (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_18966 (h1 : group (has_top fun_info)) : is_cyclic (has_top fun_info) := sorry --non-trivial
lemma new_lemma_18967 (h0 : topological_space (non_unital_non_assoc_semiring (mul_one_class linarith.comp_source))) : path_connected_space (non_unital_non_assoc_semiring (mul_one_class linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_18968 (h0 : ring real) : strong_rank_condition real := sorry --non-trivial
lemma new_lemma_18969 (h0 : topological_space (mul_zero_class (mul_zero_class ennreal))) : discrete_topology (mul_zero_class (mul_zero_class ennreal)) := sorry --non-trivial
lemma new_lemma_18970 (h0 : topological_space (has_add (has_Inf (finset linarith.comp)))) : t0_space (has_add (has_Inf (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_18971 (h0 : set (metric_space char -> fun_info)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_18972 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (ordered_cancel_add_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_cancel_add_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_18973 (h0 : function.extfun Type (functor.comp complete_lattice finset)) : @is_compactly_generated.{0} (finset.{0} pos) (@functor.comp.run.{0 0 0} complete_lattice.{0} finset.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} complete_lattice.{0} finset.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_18974 (h0 : topological_space (normed_lattice_add_comm_group (has_Inf Type))) : regular_space (normed_lattice_add_comm_group (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_18975 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (is_R_or_C unsigned)) := sorry --non-trivial
lemma new_lemma_18976 (h0 : topological_space (boolean_algebra.core (semigroup Type))) : preconnected_space (boolean_algebra.core (semigroup Type)) := sorry --non-trivial
lemma new_lemma_18977 (h1 : has_mem.mem complete_lattice has_emptyc.emptyc) : @is_atomistic.{0} (linear_ordered_semiring.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} h1) (linear_ordered_semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_18978 (h0 : monoid (with_one fun_info)) : monoid.fg (with_one fun_info) := sorry --non-trivial
lemma new_lemma_18979 (h0 : function.extfun nat fin) : @archimedean.{0} (sub_neg_monoid.{0} real) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ordered_add_comm_monoid.{0}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (sub_neg_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_18980 (h0 : add_group (has_ssubset fun_info)) : is_add_cyclic (has_ssubset fun_info) := sorry --non-trivial
lemma new_lemma_18981 (h0 : ordered_comm_monoid (has_to_string (add_comm_monoid ennreal))) : has_exists_mul_of_le (has_to_string (add_comm_monoid ennreal)) := sorry --non-trivial
lemma new_lemma_18982 (h0 : fin has_zero.zero) : @has_exists_mul_of_le.{0} (add_comm_monoid.{0} real) (@matrix.vec_empty.{0} (ordered_comm_monoid.{0} (add_comm_monoid.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_18983 (h0 : function.extfun (Type 1) (functor.comp topological_space has_to_string)) : @t0_space.{1} (has_to_string.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} has_to_string.{1} Type (@function.extfun_app.{3 2} (Type 1) (functor.comp.{1 1 1} topological_space.{1} has_to_string.{1}) h0 Type))  := sorry --non-trivial
lemma new_lemma_18984 (h0 : ring (canonically_linear_ordered_monoid (option ennreal))) : rank_condition (canonically_linear_ordered_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_18985 (h1 : has_le (add_comm_semigroup (add_comm_semigroup char))) (h2 : add_comm_semigroup (add_comm_semigroup char)) : is_bot h2 := sorry --non-trivial
lemma new_lemma_18986 (h0 : finset (pseudo_metric_space (option pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_18987 (h0 : filter (linear_ordered_comm_group ennreal)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_18988 (h0 : fin has_zero.zero) : @t1_space.{0} (has_bot.{0} name) (@matrix.vec_empty.{0} (topological_space.{0} (has_bot.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_18989 (h1 : uniform_space (denumerable (denumerable char))) : complete_space (denumerable (denumerable char)) := sorry --non-trivial
lemma new_lemma_18990 (h0 : function.extfun Type topological_space) : @regular_space.{0} (complete_distrib_lattice.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_18991 (h0 : functor.add_const (semiring (left_cancel_monoid unsigned)) empty) : @is_noetherian_ring.{0} (left_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (semiring.{0} (left_cancel_monoid.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_18992 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_norm.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} h0 (has_norm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_18993 (h0 : group (has_add (has_neg linarith.comp))) : normalizer_condition (has_add (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_18994 (h0 : ring (has_one (has_norm linarith.comp))) : is_domain (has_one (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_18995 (h0 : functor.add_const (monoid (has_to_string Type)) (ring (has_add (has_add linarith.comp)))) : @monoid.fg.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (monoid.{1} (has_to_string.{1} Type)) (ring.{0} (has_add.{0} (has_add.{0} linarith.comp))) h0)  := sorry --non-trivial
lemma new_lemma_18996 (h1 : uniform_space (has_nnnorm std_gen)) : complete_space (has_nnnorm std_gen) := sorry --non-trivial
lemma new_lemma_18997 (h0 : add_group (canonically_ordered_monoid (has_Inf Type))) : is_add_cyclic (canonically_ordered_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_18998 (h0 : filter (measure_theory.measure_space (semiring (semiring (semiring (semiring unsigned)))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_18999 (h1 : topological_space (id (random_gen linarith.comp_source))) : locally_compact_space (id (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_19000 (h0 : group (monoid_with_zero (option (option ennreal)))) : is_simple_group (monoid_with_zero (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_19001 (h0 : ring (distrib_lattice (has_nnnorm (has_nnnorm char)))) : rank_condition (distrib_lattice (has_nnnorm (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_19002 (h0 : function.extfun Type ring) : @is_domain.{0} (ordered_comm_ring.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (ordered_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_19003 (h0 : uniform_space (canonically_linear_ordered_monoid (sub_neg_monoid name))) : complete_space (canonically_linear_ordered_monoid (sub_neg_monoid name)) := sorry --non-trivial
lemma new_lemma_19004 (h0 : topological_space (comm_ring (has_top fun_info))) : locally_compact_space (comm_ring (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_19005 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @irreducible_space.{0} (normed_group.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (normed_group.{0} num))  := sorry --non-trivial
lemma new_lemma_19006 (h1 : set (distrib linarith.comp_source)) : set.finite h1 := sorry --non-trivial
lemma new_lemma_19007 (h0 : uniform_space (semiring (has_norm (semiring num)))) : complete_space (semiring (has_norm (semiring num))) := sorry --non-trivial
lemma new_lemma_19008 (h1 : ring (comm_ring to_additive.value_type)) : is_domain (comm_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_19009 (h0 : topological_space pos) : preirreducible_space pos := sorry --non-trivial
lemma new_lemma_19010 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (has_Inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_Inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_19011 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (linear_ordered_add_comm_group.{0} string_imp) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (linear_ordered_add_comm_group.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_19012 (h0 : ring (sub_neg_monoid (sub_neg_monoid (sub_neg_monoid real)))) : rank_condition (sub_neg_monoid (sub_neg_monoid (sub_neg_monoid real))) := sorry --non-trivial
lemma new_lemma_19013 (h0 : fin has_zero.zero) : @group.fg.{0} (normed_lattice_add_comm_group.{0} pos) (@matrix.vec_empty.{0} (group.{0} (normed_lattice_add_comm_group.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_19014 (h4 : group (topological_space to_additive.value_type)) : is_cyclic (topological_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_19015 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (linear_ordered_field.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_field.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_19016 (h0 : not (cancel_comm_monoid_with_zero (complete_linear_order congr_arg_kind) -> false)) : @unique_factorization_monoid.{0} (complete_linear_order.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (cancel_comm_monoid_with_zero.{0} (complete_linear_order.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_19017 (h0 : topological_space (canonically_ordered_comm_semiring (has_nndist name))) : regular_space (canonically_ordered_comm_semiring (has_nndist name)) := sorry --non-trivial
lemma new_lemma_19018 (h0 : group (linear_ordered_comm_ring congr_arg_kind)) : group.fg (linear_ordered_comm_ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_19019 (h0 : topological_space (has_top (has_norm (has_norm linarith.comp)))) : preirreducible_space (has_top (has_norm (has_norm linarith.comp))) := sorry --non-trivial
lemma new_lemma_19020 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (ordered_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (ordered_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_19021 (h0 : functor.add_const (ring (has_inner unsigned congr_arg_kind)) unsigned) : @is_domain.{0} (has_inner.{0 0} unsigned congr_arg_kind) (@functor.add_const.run.{0 0} (ring.{0} (has_inner.{0 0} unsigned congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_19022 (h0 : topological_space (has_top empty)) : totally_disconnected_space (has_top empty) := sorry --non-trivial
lemma new_lemma_19023 (h0 : topological_space (complete_distrib_lattice (has_Inf (has_Inf pos)))) : totally_separated_space (complete_distrib_lattice (has_Inf (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_19024 (h0 : add_group (add_left_cancel_semigroup (random_gen (random_gen linarith.ineq)))) : is_add_cyclic (add_left_cancel_semigroup (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_19025 (h0 : functor.add_const (topological_space (has_zero linarith.comp)) environment.implicit_infer_kind) : @normal_space.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_19026 (h0 : list (simple_graph (option empty))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_19027 (h0 : functor.add_const (group (has_to_string linarith.comp)) (has_to_string Type)) : @group.fg.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 1} (group.{0} (has_to_string.{0} linarith.comp)) (has_to_string.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_19028 (h0 : has_lt (ordered_comm_monoid linarith.ineq)) : no_max_order (ordered_comm_monoid linarith.ineq) := sorry --non-trivial
lemma new_lemma_19029 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (has_bot.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (has_bot.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_19030 (h0 : ring (has_to_string (ring (has_add Type)))) : strong_rank_condition (has_to_string (ring (has_add Type))) := sorry --non-trivial
lemma new_lemma_19031 (h0 : topological_space (mul_zero_class (mul_zero_class ennreal))) : t0_space (mul_zero_class (mul_zero_class ennreal)) := sorry --non-trivial
lemma new_lemma_19032 (h0 : group (boolean_algebra (has_to_string (has_neg (has_nndist (finset Type)))))) : group.fg (boolean_algebra (has_to_string (has_neg (has_nndist (finset Type))))) := sorry --non-trivial
lemma new_lemma_19033 (h0 : topological_space (finset environment.implicit_infer_kind)) : locally_compact_space (finset environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_19034 (h0 : fin has_zero.zero) : @loc_path_connected_space.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@matrix.vec_empty.{2} (function.extfun.{3 2} (Type 1) topological_space.{1}) h0) (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_19035 (h0 : uniform_space (has_nndist (finset linarith.comp))) : complete_space (has_nndist (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_19036 (h0 : functor.add_const (topological_space (finset linarith.comp)) linarith.comp) : @t0_space.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_19037 (h0 : add_group (random_gen (has_top (has_top fun_info)))) : is_add_cyclic (random_gen (has_top (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_19038 (h0 : list (has_to_string (boolean_algebra (option name)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_19039 (h0 : add_group (with_bot (random_gen fun_info))) : is_add_cyclic (with_bot (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_19040 (h0 : finset (add_cancel_monoid (has_neg pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_19041 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_simple_group.{0} (has_neg_part.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_neg_part.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_19042 (h0 : ordered_comm_monoid (cancel_monoid (comm_group (comm_group name)))) : has_exists_mul_of_le (cancel_monoid (comm_group (comm_group name))) := sorry --non-trivial
lemma new_lemma_19043 (h0 : ring (pseudo_metric_space pos)) : is_principal_ideal_ring (pseudo_metric_space pos) := sorry --non-trivial
lemma new_lemma_19044 (h0 : topological_space (complete_linear_order (semiring (semiring (semiring num))))) : discrete_topology (complete_linear_order (semiring (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_19045 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (normed_group.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (normed_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_19046 (h0 : function.extfun Type group) : @group.fg.{0} (linear_ordered_add_comm_group.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} h0 (linear_ordered_add_comm_group.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_19047 (h0 : monoid (filter (semiring (semiring empty)))) : monoid.fg (filter (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_19048 (h0 : fin has_zero.zero) : @totally_separated_space.{0} (add_comm_monoid.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (add_comm_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_19049 (h0 : topological_space (has_union (has_norm (has_norm (has_norm congr_arg_kind))))) : locally_compact_space (has_union (has_norm (has_norm (has_norm congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_19050 (h0 : topological_space (measure_theory.measure_space congr_arg_kind)) : topological_space.separable_space (measure_theory.measure_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_19051 (h0 : complete_lattice (non_unital_non_assoc_semiring fun_info)) : is_compactly_generated (non_unital_non_assoc_semiring fun_info) := sorry --non-trivial
lemma new_lemma_19052 (h0 : functor.add_const (group (semigroup linarith.comp)) pos) : @normalizer_condition.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (semigroup.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_19053 (h0 : topological_space (pseudo_metric_space (option (option ennreal)))) : t0_space (pseudo_metric_space (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_19054 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (normed_comm_ring.{0} ennreal) (@function.extfun_app.{2 1} Type monoid.{0} h0 (normed_comm_ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_19055 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (with_bot.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 topological_space.{0}) (with_bot.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_19056 (h0 : functor.add_const (add_monoid (semigroup pos)) (boolean_algebra (has_Inf pos))) : @add_monoid.fg.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (add_monoid.{0} (semigroup.{0} pos)) (boolean_algebra.{0} (has_Inf.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_19057 (h0 : complete_lattice (boolean_algebra (normed_lattice_add_comm_group real))) : is_atomistic (boolean_algebra (normed_lattice_add_comm_group real)) := sorry --non-trivial
lemma new_lemma_19058 (h0 : topological_space (has_add (has_add pos))) : discrete_topology (has_add (has_add pos)) := sorry --non-trivial
lemma new_lemma_19059 (h0 : functor.add_const (topological_space (has_add linarith.comp)) name) : @sequential_space.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_19060 (h0 : not (function.extfun (finset Type) (has_mem.mem (has_one empty)) -> false)) : @normal_space.{0} (has_one.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_one.{0} empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_one.{0} empty)) (@classical.by_contradiction'.{0} (function.extfun.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_one.{0} empty))) h0) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_19061 (h0 : real -> real -> Prop) : reflexive h0 := sorry --non-trivial
lemma new_lemma_19062 (h3 : function.extfun Type topological_space) : @totally_separated_space.{0} linarith.ineq (@function.extfun_app.{2 1} Type topological_space.{0} h3 linarith.ineq)  := sorry --non-trivial
lemma new_lemma_19063 (h0 : ring (uniform_space (has_compl linarith.ineq))) : strong_rank_condition (uniform_space (has_compl linarith.ineq)) := sorry --non-trivial
lemma new_lemma_19064 (h0 : add_group (has_inter (comm_monoid pos))) (h1 : topological_space (add_subgroup (has_inter (comm_monoid pos)))) : t0_space (add_subgroup (has_inter (comm_monoid pos))) := sorry --non-trivial
lemma new_lemma_19065 (h0 : not (topological_space (option unsigned) -> false)) : @discrete_topology.{0} (option.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (option.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_19066 (h0 : group (measurable_space (has_inv (random_gen linarith.ineq)))) : normalizer_condition (measurable_space (has_inv (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_19067 (h0 : uniform_space (ordered_cancel_add_comm_monoid (option (option ennreal)))) : separated_space (ordered_cancel_add_comm_monoid (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_19068 (h0 : ring (pseudo_metric_space (option (option unsigned)))) : strong_rank_condition (pseudo_metric_space (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_19069 (h0 : not (topological_space (uniform_space linarith.ineq) -> false)) : @path_connected_space.{0} (uniform_space.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (uniform_space.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_19070 (h0 : topological_space (ring (boolean_algebra (ring (has_add pos))))) : sequential_space (ring (boolean_algebra (ring (has_add pos)))) := sorry --non-trivial
lemma new_lemma_19071 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (division_ring.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (division_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_19072 (h0 : Prop -> std_gen) (h1 : coe_sort (set.range h0)) : set.range_splitting h0 h1 := sorry --non-trivial
lemma new_lemma_19073 (h1 : ring (has_ssubset (random_gen (has_nnnorm (has_nnnorm char))))) : rank_condition (has_ssubset (random_gen (has_nnnorm (has_nnnorm char)))) := sorry --non-trivial
lemma new_lemma_19074 (h0 : ring (finset pos)) : is_domain (finset pos) := sorry --non-trivial
lemma new_lemma_19075 (h0 : complete_lattice char) : complete_lattice.is_Sup_finite_compact char := sorry --non-trivial
lemma new_lemma_19076 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (with_bot.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (with_bot.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_19077 (h0 : functor.add_const (filter (has_nndist Type)) linarith.comp) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_19078 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (complete_linear_order.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_linear_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_19079 (h0 : functor.add_const (function.extfun Type uniform_space) linarith.comp) : @complete_space.{0} (normed_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) linarith.comp h0) (normed_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_19080 (h0 : functor.add_const (group (add_group unsigned)) num) : @normalizer_condition.{0} (add_group.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (add_group.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_19081 (h0 : uniform_space (has_top (has_top congr_arg_kind))) : separated_space (has_top (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_19082 (h0 : group (comm_group (comm_group (comm_group (comm_group (comm_group pos)))))) : normalizer_condition (comm_group (comm_group (comm_group (comm_group (comm_group pos))))) := sorry --non-trivial
lemma new_lemma_19083 (h0 : add_group (has_nnnorm (semi_normed_comm_ring reducibility_hints))) : is_add_cyclic (has_nnnorm (semi_normed_comm_ring reducibility_hints)) := sorry --non-trivial
lemma new_lemma_19084 (h0 : not (topological_space (ordered_cancel_comm_monoid char) -> false)) : @t0_space.{0} (ordered_cancel_comm_monoid.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (ordered_cancel_comm_monoid.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_19085 (h0 : function.extfun (Type 1) topological_space) : @sequential_space.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_19086 (h0 : complete_lattice (normed_field linarith.ineq)) : complete_lattice.is_Sup_finite_compact (normed_field linarith.ineq) := sorry --non-trivial
lemma new_lemma_19087 (h0 : ring (random_gen (has_lt char))) : strong_rank_condition (random_gen (has_lt char)) := sorry --non-trivial
lemma new_lemma_19088 (h0 : uniform_space (encodable to_additive.value_type)) : complete_space (encodable to_additive.value_type) := sorry --non-trivial
lemma new_lemma_19089 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) ennreal) := sorry --non-trivial
lemma new_lemma_19090 (h0 : ring (ordered_comm_monoid (finset Type))) : rank_condition (ordered_comm_monoid (finset Type)) := sorry --non-trivial
lemma new_lemma_19091 (h0 : semiring (has_zero (ring linarith.comp))) : is_noetherian_ring (has_zero (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_19092 (h0 : filter (option (has_top empty))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_19093 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_19094 (h0 : group (normed_field (has_nnnorm (has_nnnorm (has_nnnorm char))))) : is_cyclic (normed_field (has_nnnorm (has_nnnorm (has_nnnorm char)))) := sorry --non-trivial
lemma new_lemma_19095 (h0 : complete_lattice (has_lt char)) : complete_lattice.is_Sup_finite_compact (has_lt char) := sorry --non-trivial
lemma new_lemma_19096 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (generalized_boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (generalized_boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_19097 (h0 : functor.add_const (topological_space (ring name)) name) : @totally_disconnected_space.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_19098 (h0 : not (monoid (option unsigned) -> false)) : @monoid.fg.{0} (option.{0} unsigned) (@classical.by_contradiction'.{1} (monoid.{0} (option.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_19099 (h0 : ring (has_nndist (cancel_monoid pos))) : strong_rank_condition (has_nndist (cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_19100 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} linarith.comp (@function.extfun_app.{2 1} Type topological_space.{0} h0 linarith.comp)  := sorry --non-trivial
lemma new_lemma_19101 (h0 : functor.add_const (ring (complete_linear_order num)) num) : @strong_rank_condition.{0} (complete_linear_order.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (complete_linear_order.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_19102 (h0 : topological_space (has_one (semiring (semiring (linear_ordered_semiring empty))))) : discrete_topology (has_one (semiring (semiring (linear_ordered_semiring empty)))) := sorry --non-trivial
lemma new_lemma_19103 (h0 : finset (comm_group (option name))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_19104 (h0 : complete_lattice (sub_neg_monoid (has_neg (has_Inf (has_neg (has_neg name)))))) : complete_lattice.is_Sup_finite_compact (sub_neg_monoid (has_neg (has_Inf (has_neg (has_neg name))))) := sorry --non-trivial
lemma new_lemma_19105 (h0 : ring (ring (option (option (option num))))) : strong_rank_condition (ring (option (option (option num)))) := sorry --non-trivial
lemma new_lemma_19106 (h0 : topological_space (add_comm_monoid (has_nndist Type))) : preirreducible_space (add_comm_monoid (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_19107 (h0 : uniform_space (semigroup name)) : separated_space (semigroup name) := sorry --non-trivial
lemma new_lemma_19108 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_le.{0} environment.projection_info) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_le.{0} environment.projection_info))  := sorry --non-trivial
lemma new_lemma_19109 (h0 : complete_lattice (with_zero to_additive.value_type)) : complete_lattice.is_Sup_finite_compact (with_zero to_additive.value_type) := sorry --non-trivial
lemma new_lemma_19110 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (monoid_with_zero.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (monoid_with_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_19111 (h0 : function.extfun nat fin) : @normal_space.{0} (boolean_algebra.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (boolean_algebra.{0} pos)) (@function.extfun_app.{1 1} nat fin (@matrix.vec_empty.{0} (function.extfun.{1 1} nat fin) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_19112 (h0 : functor.add_const (topological_space (generalized_boolean_algebra Type)) Type) : @topological_space.separable_space.{1} (generalized_boolean_algebra.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (generalized_boolean_algebra.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_19113 (h0 : topological_space (has_to_string (has_Inf Type))) : topological_space.separable_space (has_to_string (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_19114 (h0 : monoid (measurable_space (has_norm congr_arg_kind))) : monoid.fg (measurable_space (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_19115 (h0 : topological_space (measurable_space.dynkin_system (has_union unsigned))) : locally_compact_space (measurable_space.dynkin_system (has_union unsigned)) := sorry --non-trivial
lemma new_lemma_19116 (h0 : topological_space (add_comm_monoid (finset pos))) : topological_space.separable_space (add_comm_monoid (finset pos)) := sorry --non-trivial
lemma new_lemma_19117 (h0 : fin has_zero.zero) : @totally_disconnected_space.{0} (ordered_comm_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (ordered_comm_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_19118 (h0 : complete_lattice (comm_semigroup (sub_neg_monoid (has_neg name)))) : is_atomistic (comm_semigroup (sub_neg_monoid (has_neg name))) := sorry --non-trivial
lemma new_lemma_19119 (h0 : functor.add_const (monoid (finset Type)) linarith.comp) : @monoid.fg.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (monoid.{1} (finset.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_19120 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @irreducible_space.{1} (mul_zero_class.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (mul_zero_class.{1} Type))  := sorry --non-trivial
lemma new_lemma_19121 (h0 : ring (linear_ordered_semiring (semiring unsigned))) : rank_condition (linear_ordered_semiring (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_19122 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (left_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (left_cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_19123 (h0 : ring (pseudo_metric_space (option unsigned))) : is_principal_ideal_ring (pseudo_metric_space (option unsigned)) := sorry --non-trivial
lemma new_lemma_19124 (h0 : topological_space real.angle) : path_connected_space real.angle := sorry --non-trivial
lemma new_lemma_19125 (h0 : topological_space (partial_order congr_arg_kind)) : totally_separated_space (partial_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_19126 (h0 : ring (div_inv_monoid string.iterator_imp)) : is_domain (div_inv_monoid string.iterator_imp) := sorry --non-trivial
lemma new_lemma_19127 (h0 : Prop -> Prop -> Prop) (h1 : filter ereal) (h2 : ereal) : set.sInter (filter.is_bounded_under h0 h1) h2 := sorry --non-trivial
lemma new_lemma_19128 (h0 : functor.add_const (function.extfun Type filter) unsigned) : countable_Inter_filter (function.extfun_app (functor.add_const.run h0) (has_inter empty)) := sorry --non-trivial
lemma new_lemma_19129 (h0 : functor.add_const (group (ring name)) (has_neg name)) : @group.fg.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (group.{0} (ring.{0} name)) (has_neg.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_19130 (h0 : ring (has_top (has_norm (random_gen (has_neg (random_gen to_additive.value_type)))))) : rank_condition (has_top (has_norm (random_gen (has_neg (random_gen to_additive.value_type))))) := sorry --non-trivial
lemma new_lemma_19131 (h0 : not (topological_space (left_cancel_monoid empty) -> false)) : @topological_space.separable_space.{0} (left_cancel_monoid.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (left_cancel_monoid.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_19132 (h0 : ring (mul_zero_class (semigroup (semigroup Type)))) : rank_condition (mul_zero_class (semigroup (semigroup Type))) := sorry --non-trivial
lemma new_lemma_19133 (h1 : topological_space (has_ssubset (has_ssubset (mul_one_class string.iterator_imp)))) : totally_disconnected_space (has_ssubset (has_ssubset (mul_one_class string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_19134 (h0 : functor.add_const (ordered_comm_monoid (finset pos)) (finset pos)) : @has_exists_mul_of_le.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (finset.{0} pos)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_19135 (h1 : add_group (with_one (has_nnnorm char))) : is_add_cyclic (with_one (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_19136 (h0 : cancel_comm_monoid_with_zero (filter (option empty))) : unique_factorization_monoid (filter (option empty)) := sorry --non-trivial
lemma new_lemma_19137 (h0 : list (as_linear_order (comm_monoid unsigned))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_19138 (h0 : ordered_add_comm_monoid (has_to_string (has_neg (has_add Type)))) : archimedean (has_to_string (has_neg (has_add Type))) := sorry --non-trivial
lemma new_lemma_19139 (h0 : topological_space (ring (option pos))) : discrete_topology (ring (option pos)) := sorry --non-trivial
lemma new_lemma_19140 (h0 : functor.add_const (ring (has_nndist linarith.comp)) linarith.comp) : @is_domain.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_nndist.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_19141 (h0 : uniform_space (comm_group (has_to_string environment.implicit_infer_kind))) : complete_space (comm_group (has_to_string environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_19142 (h0 : complete_lattice (boolean_algebra (has_neg_part (has_neg_part Type)))) : is_atomistic (boolean_algebra (has_neg_part (has_neg_part Type))) := sorry --non-trivial
lemma new_lemma_19143 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @archimedean.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_add_comm_monoid.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ordered_add_comm_monoid.{1}) (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_19144 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_19145 (h0 : topological_space (ordered_comm_ring real)) : totally_disconnected_space (ordered_comm_ring real) := sorry --non-trivial
lemma new_lemma_19146 (h0 : functor.add_const (complete_lattice (complete_distrib_lattice linarith.comp)) Type) : @is_compactly_generated.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.add_const.run.{0 1} (complete_lattice.{0} (complete_distrib_lattice.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_19147 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (pseudo_metric_space.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (pseudo_metric_space.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_19148 (h0 : function.extfun Type group) : @is_cyclic.{0} (option.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (option.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_19149 (h0 : group (metric_space (semiring (semiring (semiring num))))) : is_cyclic (metric_space (semiring (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_19150 (h0 : ring (has_inv (random_gen char))) : rank_condition (has_inv (random_gen char)) := sorry --non-trivial
lemma new_lemma_19151 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (ordered_comm_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_19152 (h0 : topological_space (finset name)) : totally_disconnected_space (finset name) := sorry --non-trivial
lemma new_lemma_19153 (h0 : ring (denumerable (metric_space to_additive.value_type))) : rank_condition (denumerable (metric_space to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_19154 (h0 : topological_space (has_norm num)) (h1 : not (has_vadd linarith.comp_source (has_norm num) -> false)) : @properly_discontinuous_vadd.{0 0} linarith.comp_source (has_norm.{0} num) h0 (@classical.by_contradiction'.{1} (has_vadd.{0 0} linarith.comp_source (has_norm.{0} num)) h1)  := sorry --non-trivial
lemma new_lemma_19155 (h0 : functor.add_const (topological_space (ring linarith.comp)) (mul_one_class environment.implicit_infer_kind)) : @regular_space.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} linarith.comp)) (mul_one_class.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_19156 (h0 : not (monoid linarith.comp_source -> false)) : @monoid.fg.{0} linarith.comp_source (@classical.by_contradiction'.{1} (monoid.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_19157 (h0 : cancel_comm_monoid_with_zero (ring (has_neg_part (has_add (has_add pos))))) : unique_factorization_monoid (ring (has_neg_part (has_add (has_add pos)))) := sorry --non-trivial
lemma new_lemma_19158 (h0 : add_monoid (has_add (has_add (has_add linarith.comp)))) : add_monoid.fg (has_add (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_19159 (h0 : functor.add_const (function.extfun Type ordered_comm_monoid) linarith.comp) : @has_exists_mul_of_le.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) linarith.comp h0) (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_19160 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_19161 (h0 : not (ring (non_unital_non_assoc_semiring (metric_space char)) -> false)) : @rank_condition.{0} (non_unital_non_assoc_semiring.{0} (metric_space.{0} char)) (@classical.by_contradiction'.{1} (ring.{0} (non_unital_non_assoc_semiring.{0} (metric_space.{0} char))) h0)  := sorry --non-trivial
lemma new_lemma_19162 (h0 : functor.add_const (topological_space (has_add unsigned)) unsigned) : @normal_space.{0} (has_add.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_19163 (h0 : topological_space (has_union (semiring congr_arg_kind))) : t0_space (has_union (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_19164 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (ordered_ring.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (ordered_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_19165 (h0 : functor.add_const (topological_space (complete_distrib_lattice empty)) (option empty)) : @path_connected_space.{0} (complete_distrib_lattice.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} empty)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_19166 (h0 : uniform_space (generalized_boolean_algebra (has_Inf (ordered_comm_monoid Type)))) : complete_space (generalized_boolean_algebra (has_Inf (ordered_comm_monoid Type))) := sorry --non-trivial
lemma new_lemma_19167 (h0 : functor.comp add_group boolean_algebra.core linarith.comp) : @is_add_cyclic.{0} (boolean_algebra.core.{0} linarith.comp) (@functor.comp.run.{0 0 0} add_group.{0} boolean_algebra.core.{0} linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_19168 (h0 : complete_lattice (has_union (has_norm congr_arg_kind))) : is_compactly_generated (has_union (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_19169 (h0 : function.extfun Type (prod (boolean_algebra.core num))) : id_rel (function.extfun_app h0 (boolean_algebra.core num)) := sorry --non-trivial
lemma new_lemma_19170 (h0 : function.extfun (finset Type) (has_mem.mem (has_norm linarith.comp))) : @add_monoid.fg.{0} (has_norm.{0} linarith.comp) (@finset.pi.empty.{1 0} Type add_monoid.{0} (has_norm.{0} linarith.comp) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_norm.{0} linarith.comp)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_19171 (h0 : function.extfun Type ring) : @is_domain.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_19172 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_one.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_one.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_19173 (h0 : topological_space (cancel_monoid (boolean_algebra (boolean_algebra environment.implicit_infer_kind)))) : normal_space (cancel_monoid (boolean_algebra (boolean_algebra environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_19174 (h0 : functor.add_const (function.extfun (Type 1) topological_space) pos) : @loc_path_connected_space.{1} (ordered_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) pos h0) (ordered_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_19175 (h0 : complete_lattice (has_top empty)) : is_atomistic (has_top empty) := sorry --non-trivial
lemma new_lemma_19176 (h1 : topological_space (dlist char)) : t0_space (dlist char) := sorry --non-trivial
lemma new_lemma_19177 (h0 : filter (metric_space num)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_19178 (h1 : uniform_space (distrib std_gen)) : complete_space (distrib std_gen) := sorry --non-trivial
lemma new_lemma_19179 (h0 : topological_space (ordered_comm_ring name)) : loc_path_connected_space (ordered_comm_ring name) := sorry --non-trivial
lemma new_lemma_19180 (h1 : topological_space (mul_one_class std_gen)) : totally_disconnected_space (mul_one_class std_gen) := sorry --non-trivial
lemma new_lemma_19181 (h0 : ring (has_top (has_top (has_top congr_arg_kind)))) : is_domain (has_top (has_top (has_top congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_19182 (h0 : topological_space (finset (finset (has_add (finset linarith.comp))))) : preirreducible_space (finset (finset (has_add (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_19183 (h1 : ring (add_comm_semigroup fun_info)) : strong_rank_condition (add_comm_semigroup fun_info) := sorry --non-trivial
lemma new_lemma_19184 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_zero.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_zero.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_19185 (h0 : topological_space (has_add fun_info)) : t0_space (has_add fun_info) := sorry --non-trivial
lemma new_lemma_19186 (h0 : topological_space (uniform_space enat)) : path_connected_space (uniform_space enat) := sorry --non-trivial
lemma new_lemma_19187 (h0 : topological_space (sub_neg_monoid (has_add pos))) : locally_compact_space (sub_neg_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_19188 (h0 : finset (has_Inf (has_add (ring (has_Inf (has_add (has_Inf (has_Inf (has_Inf (has_Inf (has_Inf pos))))))))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_19189 (h0 : topological_space (mul_zero_class (option name))) : sequential_space (mul_zero_class (option name)) := sorry --non-trivial
lemma new_lemma_19190 (h0 : functor.add_const (topological_space (has_neg Type)) (has_neg environment.implicit_infer_kind)) : @normal_space.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_neg.{1} Type)) (has_neg.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_19191 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @locally_compact_space.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_19192 (h0 : complete_lattice (omega_complete_partial_order unsigned)) : is_atomistic (omega_complete_partial_order unsigned) := sorry --non-trivial
lemma new_lemma_19193 (h0 : topological_space (div_inv_monoid (has_nnnorm to_additive.value_type))) : path_connected_space (div_inv_monoid (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_19194 (h0 : complete_lattice (with_bot (random_gen (random_gen (has_inv (has_inv fun_info)))))) : is_compactly_generated (with_bot (random_gen (random_gen (has_inv (has_inv fun_info))))) := sorry --non-trivial
lemma new_lemma_19195 (h0 : finset (has_nndist (ring pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_19196 (h0 : topological_space (ring (ring pos))) : sequential_space (ring (ring pos)) := sorry --non-trivial
lemma new_lemma_19197 (h0 : functor.add_const (topological_space (has_pos_part linarith.comp)) name) : @irreducible_space.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_19198 (h0 : topological_space (normed_comm_ring (has_neg pos))) : locally_compact_space (normed_comm_ring (has_neg pos)) := sorry --non-trivial
lemma new_lemma_19199 (h1 : list (ring (semi_normed_comm_ring string_imp))) (h2 : nat) (h3 : has_lt.lt h2 (list.length h1)) : @strong_rank_condition.{0} (semi_normed_comm_ring.{0} string_imp) (@list.nth_le.{0} (ring.{0} (semi_normed_comm_ring.{0} string_imp)) h1 h2 h3)  := sorry --non-trivial
lemma new_lemma_19200 (h0 : functor.add_const (topological_space (has_pos_part linarith.comp)) name) : @t1_space.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_19201 (h0 : topological_space (normed_group (random_gen (random_gen linarith.comp_source)))) : t0_space (normed_group (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_19202 (h0 : functor.add_const (list (has_add ennreal)) unsigned) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_19203 (h0 : functor.comp topological_space has_neg_part pos) : @path_connected_space.{0} (has_neg_part.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} pos)) pos (@functor.comp.run.{0 0 0} topological_space.{0} has_neg_part.{0} pos h0))  := sorry --non-trivial
lemma new_lemma_19204 (h0 : semiring (is_R_or_C (semiring unsigned))) : is_noetherian_ring (is_R_or_C (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_19205 (h0 : function.extfun nat fin) : @is_simple_group.{0} (complete_distrib_lattice.{0} pos) (@matrix.vec_empty.{0} (group.{0} (complete_distrib_lattice.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_19206 (h0 : filter (has_dist fun_info)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_19207 (h0 : ring (cancel_monoid (finset (has_nndist name)))) : strong_rank_condition (cancel_monoid (finset (has_nndist name))) := sorry --non-trivial
lemma new_lemma_19208 (h0 : functor.add_const (ordered_add_comm_monoid (ring pos)) (ordered_comm_ring linarith.comp)) : @archimedean.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (ring.{0} pos)) (ordered_comm_ring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_19209 (h0 : set (normed_field string_imp)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_19210 (h0 : cancel_comm_monoid_with_zero (has_neg_part (comm_group name))) : unique_factorization_monoid (has_neg_part (comm_group name)) := sorry --non-trivial
lemma new_lemma_19211 (h0 : topological_space (sub_neg_monoid real)) : sequential_space (sub_neg_monoid real) := sorry --non-trivial
lemma new_lemma_19212 (h0 : topological_space (simple_graph (has_add Type))) : loc_path_connected_space (simple_graph (has_add Type)) := sorry --non-trivial
lemma new_lemma_19213 (h0 : topological_space (group_with_zero (has_zero num))) : irreducible_space (group_with_zero (has_zero num)) := sorry --non-trivial
lemma new_lemma_19214 (h0 : function.extfun Type group) : @is_cyclic.{0} (boolean_algebra.core.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (boolean_algebra.core.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_19215 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (has_pos_part.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_pos_part.{0} name))  := sorry --non-trivial
lemma new_lemma_19216 (h0 : topological_space (has_zero (boolean_algebra Type))) : irreducible_space (has_zero (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_19217 (h0 : ring (has_edist (semiring unsigned))) : is_domain (has_edist (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_19218 (h0 : functor.add_const (topological_space (has_neg name)) pos) : @sequential_space.{0} (has_neg.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_19219 (h0 : functor.add_const (function.extfun Type complete_lattice) unsigned) : @is_compactly_generated.{0} (linear_ordered_field.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) unsigned h0) (linear_ordered_field.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_19220 (h0 : multiset (has_nnnorm fun_info)) (h1 : list (multiset (has_nnnorm fun_info))) : multiset.subset h0 (list.ilast h1) := sorry --non-trivial
lemma new_lemma_19221 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (ordered_comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_19222 (h0 : function.extfun Type (functor.add_const (topological_space (left_cancel_monoid empty)))) : @loc_path_connected_space.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} empty)) congr_arg_kind (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (left_cancel_monoid.{0} empty))) h0 congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_19223 (h0 : partial_order Type) (h1 : closure_operator Type) : closure_operator.closed h1 char := sorry --non-trivial
lemma new_lemma_19224 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (pseudo_metric_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type semiring.{0} h0 (pseudo_metric_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_19225 (h0 : topological_space (boolean_algebra.core (comm_group Type))) : normal_space (boolean_algebra.core (comm_group Type)) := sorry --non-trivial
lemma new_lemma_19226 (h0 : functor.add_const (cancel_comm_monoid_with_zero (boolean_algebra name)) (mul_zero_class pos)) : @unique_factorization_monoid.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (boolean_algebra.{0} name)) (mul_zero_class.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_19227 (h0 : list (add_cancel_monoid (has_neg (finset Type)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_19228 (h0 : group (complete_linear_order num)) : is_cyclic (complete_linear_order num) := sorry --non-trivial
lemma new_lemma_19229 (h0 : topological_space (dlist (has_nnnorm fun_info))) : t0_space (dlist (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_19230 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (has_nndist.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (has_nndist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_19231 (h0 : functor.add_const (filter (semigroup Type)) environment.implicit_infer_kind) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_19232 (h0 : topological_space (semi_normed_comm_ring (has_ssubset (random_gen string_imp)))) : path_connected_space (semi_normed_comm_ring (has_ssubset (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_19233 (h0 : not (topological_space (uniform_space reducibility_hints) -> false)) : @t0_space.{0} (uniform_space.{0} reducibility_hints) (@classical.by_contradiction'.{1} (topological_space.{0} (uniform_space.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_19234 (h0 : topological_space (simple_graph (finset linarith.comp))) : irreducible_space (simple_graph (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_19235 (h0 : topological_space (linear_ordered_semiring (random_gen (random_gen num)))) : irreducible_space (linear_ordered_semiring (random_gen (random_gen num))) := sorry --non-trivial
lemma new_lemma_19236 (h0 : functor.add_const (topological_space (measurable_space.dynkin_system unsigned)) congr_arg_kind) : @discrete_topology.{0} (measurable_space.dynkin_system.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (measurable_space.dynkin_system.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_19237 (h0 : not (has_mem.mem (has_top fun_info) has_emptyc.emptyc -> false)) : @totally_disconnected_space.{0} (has_top.{0} fun_info) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_top.{0} fun_info) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_top.{0} fun_info) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_19238 (h0 : with_bot (with_bot linarith.ineq) -> with_bot (with_bot linarith.ineq) -> with_bot (with_bot linarith.ineq)) : is_right_cancel (with_bot (with_bot linarith.ineq)) h0 := sorry --non-trivial
lemma new_lemma_19239 (h0 : not (has_mem.mem (function.extfun Type) has_emptyc.emptyc -> false)) : @is_atomistic.{0} (has_emptyc.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@finset.pi.empty.{2 1} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{0} (@has_mem.mem.{2 2} ((Type → Type) → Type 1) (finset.{2} ((Type → Type) → Type 1)) (@finset.has_mem.{2} ((Type → Type) → Type 1)) (function.extfun.{2 1} Type) (@has_emptyc.emptyc.{2} (finset.{2} ((Type → Type) → Type 1)) (@finset.has_emptyc.{2} ((Type → Type) → Type 1)))) h0)) complete_lattice.{0}) (has_emptyc.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_19240 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (has_emptyc.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_emptyc.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_19241 (h0 : functor.add_const (topological_space (canonically_linear_ordered_monoid empty)) unsigned) : @t0_space.{0} (canonically_linear_ordered_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_linear_ordered_monoid.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_19242 (h0 : group (multiplicative fun_info)) : is_cyclic (multiplicative fun_info) := sorry --non-trivial
lemma new_lemma_19243 (h0 : functor.add_const (topological_space (filter unsigned)) empty) : @normal_space.{0} (filter.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (filter.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_19244 (h0 : topological_space (add_cancel_monoid num)) : t0_space (add_cancel_monoid num) := sorry --non-trivial
lemma new_lemma_19245 (h0 : topological_space (with_bot (has_norm linarith.ineq))) : totally_separated_space (with_bot (has_norm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_19246 (h0 : topological_space (non_assoc_semiring (semiring (semiring unsigned)))) : totally_disconnected_space (non_assoc_semiring (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_19247 (h1 : not (ring (measurable_space congr_arg_kind) -> false)) : @is_domain.{0} (measurable_space.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (ring.{0} (measurable_space.{0} congr_arg_kind)) h1)  := sorry --non-trivial
lemma new_lemma_19248 (h1 : ring (has_inv (random_gen string_imp))) : rank_condition (has_inv (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_19249 (h0 : function.extfun (finset Type) (has_mem.mem (semiring linarith.comp))) : @add_monoid.fg.{0} (semiring.{0} linarith.comp) (@finset.pi.empty.{1 0} Type add_monoid.{0} (semiring.{0} linarith.comp) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} linarith.comp)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_19250 (h0 : ordered_add_comm_monoid (has_Inf (has_add (ring Type)))) : archimedean (has_Inf (has_add (ring Type))) := sorry --non-trivial
lemma new_lemma_19251 (h0 : functor.add_const (function.extfun Type complete_lattice) name) : @is_compactly_generated.{0} (has_zero.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) name h0) (has_zero.{0} name))  := sorry --non-trivial
lemma new_lemma_19252 (h0 : ring (add_comm_monoid (has_add Type))) : is_principal_ideal_ring (add_comm_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_19253 (h0 : functor.add_const (group (has_neg environment.implicit_infer_kind)) Type) : @group.fg.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (group.{0} (has_neg.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_19254 (h0 : functor.add_const (topological_space (generalized_boolean_algebra linarith.comp)) linarith.comp) : @t0_space.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_19255 (h0 : complete_lattice (add_cancel_monoid congr_arg_kind)) : complete_lattice.is_Sup_finite_compact (add_cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_19256 (h0 : functor.add_const (topological_space (has_neg_part environment.implicit_infer_kind)) (comm_group Type)) : @loc_path_connected_space.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg_part.{0} environment.implicit_infer_kind)) (comm_group.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_19257 (h0 : add_group (with_one fun_info)) : is_add_cyclic (with_one fun_info) := sorry --non-trivial
lemma new_lemma_19258 (h0 : cancel_comm_monoid_with_zero (has_dist (option num))) : unique_factorization_monoid (has_dist (option num)) := sorry --non-trivial
lemma new_lemma_19259 (h0 : list (canonically_ordered_comm_semiring (comm_monoid unsigned))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_19260 (h0 : topological_space (has_Inf (ring Type))) : topological_space.separable_space (has_Inf (ring Type)) := sorry --non-trivial
lemma new_lemma_19261 (h0 : topological_space (has_add (ring (ring (ring linarith.comp))))) : loc_path_connected_space (has_add (ring (ring (ring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_19262 (h0 : complete_lattice (cancel_monoid name)) : is_atomistic (cancel_monoid name) := sorry --non-trivial
lemma new_lemma_19263 (h0 : has_inter num -> has_inter num -> has_inter num) : left_cancelative h0 := sorry --non-trivial
lemma new_lemma_19264 (h0 : functor.add_const (function.extfun (Type 1) semiring) linarith.comp) : @is_noetherian_ring.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) semiring.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) semiring.{1}) linarith.comp h0) (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_19265 (h3 : topological_space (comm_ring fun_info)) : totally_disconnected_space (comm_ring fun_info) := sorry --non-trivial
lemma new_lemma_19266 (h1 : topological_space (dlist linarith.comp_source)) : t0_space (dlist linarith.comp_source) := sorry --non-trivial
lemma new_lemma_19267 (h0 : ordered_add_comm_monoid (has_nndist (has_add (has_add (has_add (has_add Type)))))) : archimedean (has_nndist (has_add (has_add (has_add (has_add Type))))) := sorry --non-trivial
lemma new_lemma_19268 (h0 : complete_lattice (has_lt ereal)) : is_compactly_generated (has_lt ereal) := sorry --non-trivial
lemma new_lemma_19269 (h0 : function.extfun Type ring) : @rank_condition.{0} (bin_tree.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (bin_tree.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_19270 (h1 : has_mem.mem (has_emptyc congr_arg_kind) has_emptyc.emptyc) : @path_connected_space.{0} (has_emptyc.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_emptyc.{0} congr_arg_kind) h1)  := sorry --non-trivial
lemma new_lemma_19271 (h0 : complete_lattice (has_nndist (finset environment.implicit_infer_kind))) : is_atomistic (has_nndist (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_19272 (h0 : functor.add_const (topological_space (has_zero Type)) linarith.comp) : @locally_compact_space.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_zero.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_19273 (h0 : not (complete_lattice (fintype (has_nnnorm (has_nnnorm fun_info))) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (fintype.{0} (has_nnnorm.{0} (has_nnnorm.{0} fun_info))) (@classical.by_contradiction'.{1} (complete_lattice.{0} (fintype.{0} (has_nnnorm.{0} (has_nnnorm.{0} fun_info)))) h0)  := sorry --non-trivial
lemma new_lemma_19274 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (finset.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (finset.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_19275 (h0 : topological_space (has_le char)) : path_connected_space (has_le char) := sorry --non-trivial
lemma new_lemma_19276 (h0 : topological_space (has_nnnorm (mul_one_class string.iterator_imp))) (h1 : preorder (has_nnnorm (mul_one_class string.iterator_imp))) : order_closed_topology (has_nnnorm (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_19277 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (complete_semilattice_Sup.{0} fun_info) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (complete_semilattice_Sup.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_19278 (h0 : complete_lattice (with_one (has_inv (random_gen linarith.ineq)))) : is_compactly_generated (with_one (has_inv (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_19279 (h0 : functor.comp topological_space pseudo_metric_space pos) : @sequential_space.{0} (pseudo_metric_space.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} pseudo_metric_space.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_19280 (h0 : complete_lattice (normed_group string_imp)) : is_compactly_generated (normed_group string_imp) := sorry --non-trivial
lemma new_lemma_19281 (h1 : complete_lattice (with_bot (has_inv string_imp))) : complete_lattice.is_Sup_finite_compact (with_bot (has_inv string_imp)) := sorry --non-trivial
lemma new_lemma_19282 (h0 : functor.add_const (topological_space (partial_order congr_arg_kind)) congr_arg_kind) : @irreducible_space.{0} (partial_order.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (partial_order.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_19283 (h0 : topological_space (is_R_or_C congr_arg_kind)) : locally_compact_space (is_R_or_C congr_arg_kind) := sorry --non-trivial
lemma new_lemma_19284 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (has_pos_part.{0} name) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (has_pos_part.{0} name))  := sorry --non-trivial
lemma new_lemma_19285 (h0 : (fun_info -> string.iterator_imp) -> (fun_info -> string.iterator_imp) -> Prop) (h1 : fun_info -> string.iterator_imp) : set.separates_points (eqv_gen h0 h1) := sorry --non-trivial
lemma new_lemma_19286 (h0 : complete_lattice (complete_distrib_lattice (option pos))) : complete_lattice.is_Sup_finite_compact (complete_distrib_lattice (option pos)) := sorry --non-trivial
lemma new_lemma_19287 (h0 : not (has_neg (has_compl fun_info) -> false)) (h1 : measurable_space (has_compl fun_info)) : @has_measurable_neg.{0} (has_compl.{0} fun_info) (@classical.by_contradiction'.{1} (has_neg.{0} (has_compl.{0} fun_info)) h0) h1  := sorry --non-trivial
lemma new_lemma_19288 (h0 : functor.add_const (group (cancel_monoid name)) name) : @group.fg.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (group.{0} (cancel_monoid.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_19289 (h1 : not (topological_space (with_one linarith.comp) -> false)) : @t0_space.{0} (with_one.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (with_one.{0} linarith.comp)) h1)  := sorry --non-trivial
lemma new_lemma_19290 (h0 : functor.add_const (group (simple_graph pos)) pos) : @group.fg.{0} (simple_graph.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (simple_graph.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_19291 (h1 : ring (semi_normed_comm_ring (comm_ring (comm_ring char)))) : is_domain (semi_normed_comm_ring (comm_ring (comm_ring char))) := sorry --non-trivial
lemma new_lemma_19292 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (option.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (option.{0} name))  := sorry --non-trivial
lemma new_lemma_19293 (h0 : group (linear_ordered_comm_group num)) : normalizer_condition (linear_ordered_comm_group num) := sorry --non-trivial
lemma new_lemma_19294 (h0 : functor.add_const (ordered_add_comm_monoid (ring empty)) empty) : @archimedean.{0} (ring.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (ring.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_19295 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (add_comm_monoid.{0} real) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (add_comm_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_19296 (h0 : topological_space (has_pos_part (has_Inf (has_Inf (has_Inf Type))))) : irreducible_space (has_pos_part (has_Inf (has_Inf (has_Inf Type)))) := sorry --non-trivial
lemma new_lemma_19297 (h0 : topological_space (add_comm_monoid (finset (finset (ring (has_add (ring (ring Type)))))))) : t0_space (add_comm_monoid (finset (finset (ring (has_add (ring (ring Type))))))) := sorry --non-trivial
lemma new_lemma_19298 (h0 h1 : multiset (has_nnnorm char)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_19299 (h0 : functor.add_const (finset (has_nndist pos)) name) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_19300 (h0 : functor.add_const (filter (has_nndist name)) (boolean_algebra name)) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_19301 (h0 : has_neg (normed_field std_gen)) (h1 : measurable_space (normed_field std_gen)) : has_measurable_neg (normed_field std_gen) := sorry --non-trivial
lemma new_lemma_19302 (h1 : topological_space (with_zero string_imp)) : path_connected_space (with_zero string_imp) := sorry --non-trivial
lemma new_lemma_19303 (h4 : prod char char) : set.diagonal char h4 := sorry --non-trivial
lemma new_lemma_19304 (h0 : uniform_space (semi_normed_ring string_imp)) : complete_space (semi_normed_ring string_imp) := sorry --non-trivial
lemma new_lemma_19305 (h0 : add_group (non_unital_non_assoc_semiring string.iterator_imp)) : is_add_cyclic (non_unital_non_assoc_semiring string.iterator_imp) := sorry --non-trivial
lemma new_lemma_19306 (h0 : ring (complete_semilattice_Sup empty)) : strong_rank_condition (complete_semilattice_Sup empty) := sorry --non-trivial
lemma new_lemma_19307 (h0 : list Prop) (h1 : false) (h2 : Prop) (h3 : decidable h2) : list.head (ite h2 h0 (false.elim h1)) := sorry --trivial
lemma new_lemma_19308 (h0 : functor.add_const (group (has_add pos)) (has_neg Type)) : @normalizer_condition.{0} (has_add.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (has_add.{0} pos)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_19309 (h0 : topological_space (boolean_algebra (has_Inf name))) : totally_separated_space (boolean_algebra (has_Inf name)) := sorry --non-trivial
lemma new_lemma_19310 (h0 : function.extfun Type ring) : @rank_condition.{0} (semiring.{0} nnreal) (@function.extfun_app.{2 1} Type ring.{0} h0 (semiring.{0} nnreal))  := sorry --non-trivial
lemma new_lemma_19311 (h0 : semiring (has_to_string (finset (mul_zero_class environment.implicit_infer_kind)))) : is_noetherian_ring (has_to_string (finset (mul_zero_class environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_19312 (h0 : functor.add_const (function.extfun Type uniform_space) linarith.comp) : @separated_space.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) linarith.comp h0) (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_19313 (h0 : topological_space (normed_comm_ring (finset environment.implicit_infer_kind))) : topological_space.separable_space (normed_comm_ring (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_19314 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} (linear_ordered_semiring.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (linear_ordered_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_19315 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (normed_lattice_add_comm_group.{0} (ordered_comm_monoid.{0} linarith.comp)) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (normed_lattice_add_comm_group.{0} (ordered_comm_monoid.{0} linarith.comp)))  := sorry --non-trivial
lemma new_lemma_19316 (h0 : topological_space (has_Inf (generalized_boolean_algebra Type))) : preirreducible_space (has_Inf (generalized_boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_19317 (h0 : topological_space (add_comm_monoid pos)) : locally_compact_space (add_comm_monoid pos) := sorry --non-trivial
lemma new_lemma_19318 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_dist.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_dist.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_19319 (h0 : functor.add_const (ring (complete_distrib_lattice pos)) (has_neg (has_neg pos))) : @is_principal_ideal_ring.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (complete_distrib_lattice.{0} pos)) (has_neg.{0} (has_neg.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_19320 (h0 : topological_space (mul_one_class (random_gen linarith.comp_source))) : path_connected_space (mul_one_class (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_19321 (h0 : add_group (semi_normed_comm_ring linarith.comp_source)) : is_add_cyclic (semi_normed_comm_ring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_19322 (h0 : topological_space (measure_theory.measure_space empty)) : topological_space.separable_space (measure_theory.measure_space empty) := sorry --non-trivial
lemma new_lemma_19323 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (has_neg.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} name))  := sorry --non-trivial
lemma new_lemma_19324 (h0 : functor.add_const (uniform_space (comm_group linarith.comp)) Type) : @separated_space.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 1} (uniform_space.{0} (comm_group.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_19325 (h0 : not (add_group (denumerable linarith.comp_source) -> false)) : @is_add_cyclic.{0} (denumerable.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (add_group.{0} (denumerable.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_19326 (h0 : functor.add_const (uniform_space pos) Type) : @complete_space.{0} pos (@functor.add_const.run.{0 1} (uniform_space.{0} pos) Type h0)  := sorry --non-trivial
lemma new_lemma_19327 (h0 : topological_space (complete_distrib_lattice (has_Inf (has_add Type)))) : preconnected_space (complete_distrib_lattice (has_Inf (has_add Type))) := sorry --non-trivial
lemma new_lemma_19328 (h0 : add_monoid (complete_distrib_lattice (option ennreal))) : add_monoid.fg (complete_distrib_lattice (option ennreal)) := sorry --non-trivial
lemma new_lemma_19329 (h0 : uniform_space (option congr_arg_kind)) : complete_space (option congr_arg_kind) := sorry --non-trivial
lemma new_lemma_19330 (h0 : add_group (normed_lattice_add_comm_group (has_Inf (has_Inf pos)))) : is_add_cyclic (normed_lattice_add_comm_group (has_Inf (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_19331 (h0 : functor.add_const (group (finset pos)) Type) : @is_simple_group.{0} (finset.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (finset.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_19332 (h0 : has_mem.mem (metric_space num) has_emptyc.emptyc) : @normal_space.{0} (metric_space.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (metric_space.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_19333 (h0 : functor.add_const (ring (boolean_algebra.core environment.implicit_infer_kind)) name) : @rank_condition.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_19334 (h0 : ordered_add_comm_monoid (finset (normed_comm_ring name))) : archimedean (finset (normed_comm_ring name)) := sorry --non-trivial
lemma new_lemma_19335 (h0 : complete_lattice (ordered_cancel_add_comm_monoid ennreal)) : is_atomistic (ordered_cancel_add_comm_monoid ennreal) := sorry --non-trivial
lemma new_lemma_19336 (h0 : functor.add_const (topological_space (finset Type)) unsigned) : @locally_compact_space.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (finset.{1} Type)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_19337 (h0 : group (has_top (has_inv fun_info))) : group.fg (has_top (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_19338 (h0 : functor.add_const (add_monoid (add_cancel_monoid name)) environment.implicit_infer_kind) : @add_monoid.fg.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (add_monoid.{0} (add_cancel_monoid.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_19339 (h0 : fin has_zero.zero) : @strong_rank_condition.{1} (ordered_comm_ring.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (ordered_comm_ring.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_19340 (h0 : group (boolean_algebra (finset environment.implicit_infer_kind))) : group.fg (boolean_algebra (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_19341 (h0 : complete_lattice (normed_lattice_add_comm_group (has_bot (has_Inf real)))) : is_compactly_generated (normed_lattice_add_comm_group (has_bot (has_Inf real))) := sorry --non-trivial
lemma new_lemma_19342 (h0 : add_monoid (complete_semilattice_Sup (semiring (semiring (semiring num))))) : add_monoid.fg (complete_semilattice_Sup (semiring (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_19343 (h0 : complete_lattice (has_nndist (cancel_monoid name))) : is_atomistic (has_nndist (cancel_monoid name)) := sorry --non-trivial
lemma new_lemma_19344 (h0 : add_group (canonically_ordered_comm_semiring (option pos))) : is_add_cyclic (canonically_ordered_comm_semiring (option pos)) := sorry --non-trivial
lemma new_lemma_19345 (h0 : topological_space (has_Inf name)) : preconnected_space (has_Inf name) := sorry --non-trivial
lemma new_lemma_19346 (h0 : group (has_one unsigned)) : normalizer_condition (has_one unsigned) := sorry --non-trivial
lemma new_lemma_19347 (h0 : topological_space (has_add unsigned)) : regular_space (has_add unsigned) := sorry --non-trivial
lemma new_lemma_19348 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_19349 (h0 : ring (has_zero (option name))) : is_principal_ideal_ring (has_zero (option name)) := sorry --non-trivial
lemma new_lemma_19350 (h0 : add_monoid (has_star (semiring num))) : add_monoid.fg (has_star (semiring num)) := sorry --non-trivial
lemma new_lemma_19351 (h0 : functor.add_const (finset (finset name)) name) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_19352 (h0 : uniform_space (linear_ordered_semiring (semiring congr_arg_kind))) : separated_space (linear_ordered_semiring (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_19353 (h0 : functor.add_const (function.extfun Type complete_lattice) pos) : @is_compactly_generated.{0} (comm_group.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) pos h0) (comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_19354 (h0 : cancel_comm_monoid_with_zero (ring (ring (has_nndist (has_add linarith.comp))))) : unique_factorization_monoid (ring (ring (has_nndist (has_add linarith.comp)))) := sorry --non-trivial
lemma new_lemma_19355 (h0 : group (random_gen (has_nnnorm (comm_ring (comm_ring linarith.ineq))))) : is_cyclic (random_gen (has_nnnorm (comm_ring (comm_ring linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_19356 (h0 : ordered_comm_monoid (canonically_ordered_monoid (has_pos_part pos))) : has_exists_mul_of_le (canonically_ordered_monoid (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_19357 (h0 : not (has_mem.mem (has_union congr_arg_kind) has_emptyc.emptyc -> false)) : @totally_separated_space.{0} (has_union.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_union.{0} congr_arg_kind) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_union.{0} congr_arg_kind) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_19358 (h0 : functor.comp filter has_neg (finset (has_add (finset (has_nndist (has_add name)))))) : filter.ne_bot (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_19359 (h0 : semiring (normed_comm_ring (finset linarith.comp))) : is_noetherian_ring (normed_comm_ring (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_19360 (h0 : function.extfun (Type 1) complete_lattice) : @is_atomistic.{1} (canonically_linear_ordered_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} h0 (canonically_linear_ordered_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_19361 (h0 : function.extfun nat fin) : @archimedean.{0} (has_Inf.{0} name) (@matrix.vec_empty.{0} (ordered_add_comm_monoid.{0} (has_Inf.{0} name)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@function.extfun_app.{1 1} nat fin (@matrix.vec_empty.{0} (function.extfun.{1 1} nat fin) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (@has_zero.zero.{0} nat nat.has_zero))))  := sorry --non-trivial
lemma new_lemma_19362 (h1 : ring (distrib linarith.ineq)) : is_domain (distrib linarith.ineq) := sorry --non-trivial
lemma new_lemma_19363 (h0 : add_group (has_compl (has_lt string_imp))) : is_add_cyclic (has_compl (has_lt string_imp)) := sorry --non-trivial
lemma new_lemma_19364 (h1 : topological_space (comm_ring fun_info)) : t0_space (comm_ring fun_info) := sorry --non-trivial
lemma new_lemma_19365 (h0 : ring (linear_ordered_comm_ring ereal)) : is_domain (linear_ordered_comm_ring ereal) := sorry --non-trivial
lemma new_lemma_19366 (h0 : functor.add_const (ordered_add_comm_monoid (complete_distrib_lattice linarith.comp)) (has_add unsigned)) : @archimedean.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (complete_distrib_lattice.{0} linarith.comp)) (has_add.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_19367 (h0 : topological_space (comm_ring (random_gen linarith.comp_source))) : path_connected_space (comm_ring (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_19368 (h0 : group (has_add (has_top (normed_group string_imp)))) : is_cyclic (has_add (has_top (normed_group string_imp))) := sorry --non-trivial
lemma new_lemma_19369 (h0 : functor.add_const (topological_space (ring name)) name) : @regular_space.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_19370 (h0 : semiring (id congr_arg_kind)) : is_noetherian_ring (id congr_arg_kind) := sorry --non-trivial
lemma new_lemma_19371 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (simple_graph.{0} pos) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (simple_graph.{0} pos))  := sorry --non-trivial
lemma new_lemma_19372 (h1 : topological_space (linear_ordered_add_comm_group linarith.comp_source)) : t0_space (linear_ordered_add_comm_group linarith.comp_source) := sorry --non-trivial
lemma new_lemma_19373 (h0 : topological_space (distrib_lattice (random_gen to_additive.value_type))) : totally_disconnected_space (distrib_lattice (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_19374 (h0 : function.extfun Type topological_space) : @normal_space.{0} (pseudo_metric_space.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (pseudo_metric_space.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_19375 (h0 : topological_space (boolean_algebra (canonically_linear_ordered_monoid (has_Inf Type)))) : totally_separated_space (boolean_algebra (canonically_linear_ordered_monoid (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_19376 (h0 : complete_lattice (has_nnnorm (mul_one_class string.iterator_imp))) : is_compactly_generated (has_nnnorm (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_19377 (h0 : topological_space (has_neg_part (has_add environment.implicit_infer_kind))) : path_connected_space (has_neg_part (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_19378 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (random_gen.{0} empty) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (random_gen.{0} empty))  := sorry --non-trivial
lemma new_lemma_19379 (h0 : functor.add_const (topological_space (has_Inf name)) name) : @preconnected_space.{0} (has_Inf.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_19380 (h0 : topological_space (preorder (semiring empty))) : totally_separated_space (preorder (semiring empty)) := sorry --non-trivial
lemma new_lemma_19381 (h0 : functor.add_const (function.extfun Type add_monoid) environment.implicit_infer_kind) : @add_monoid.fg.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_monoid.{0}) environment.implicit_infer_kind h0) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_19382 (h0 : fin has_zero.zero) : @loc_path_connected_space.{0} (boolean_algebra.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (boolean_algebra.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_19383 (h0 : function.extfun Type (functor.comp group boolean_algebra)) : @normalizer_condition.{0} (boolean_algebra.{0} name) (@functor.comp.run.{0 0 0} group.{0} boolean_algebra.{0} name (@functor.comp.run.{0 0 0} group.{0} boolean_algebra.{0} name (@functor.comp.run.{0 0 0} group.{0} boolean_algebra.{0} name (@functor.comp.run.{0 0 0} group.{0} boolean_algebra.{0} name (@functor.comp.run.{0 0 0} group.{0} boolean_algebra.{0} name (@functor.comp.run.{0 0 0} group.{0} boolean_algebra.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} group.{0} boolean_algebra.{0}) h0 name)))))))  := sorry --non-trivial
lemma new_lemma_19384 (h0 : topological_space (complete_distrib_lattice (comm_semigroup (comm_semigroup real)))) : totally_disconnected_space (complete_distrib_lattice (comm_semigroup (comm_semigroup real))) := sorry --non-trivial
lemma new_lemma_19385 (h0 : topological_space (canonically_ordered_add_monoid unsigned)) : locally_compact_space (canonically_ordered_add_monoid unsigned) := sorry --non-trivial
lemma new_lemma_19386 (h0 : functor.add_const (uniform_space (left_cancel_semigroup num)) (semiring congr_arg_kind)) : @complete_space.{0} (left_cancel_semigroup.{0} num) (@functor.add_const.run.{0 0} (uniform_space.{0} (left_cancel_semigroup.{0} num)) (semiring.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_19387 (h0 : functor.add_const (complete_lattice (has_zero unsigned)) (has_add (has_to_string pos))) : @is_atomistic.{0} (has_zero.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_zero.{0} unsigned)) (has_add.{0} (has_to_string.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_19388 (h0 : functor.add_const (topological_space (boolean_algebra.core name)) pos) : @locally_compact_space.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_19389 (h0 : topological_space (boolean_algebra.core (has_add environment.implicit_infer_kind))) : discrete_topology (boolean_algebra.core (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_19390 (h0 : topological_space (monoid_with_zero (option (option pos)))) : discrete_topology (monoid_with_zero (option (option pos))) := sorry --non-trivial
lemma new_lemma_19391 (h0 : topological_space (monoid_with_zero congr_arg_kind)) : totally_separated_space (monoid_with_zero congr_arg_kind) := sorry --non-trivial
lemma new_lemma_19392 (h2 : topological_space (has_compl linarith.ineq)) : path_connected_space (has_compl linarith.ineq) := sorry --non-trivial
lemma new_lemma_19393 (h0 : nat) (h1 : function.extfun (fin (nat.succ h0)) (fun (x : fin (nat.succ h0)), Prop)) : matrix.vec_head (function.extfun_app h1) := sorry --non-trivial
lemma new_lemma_19394 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_19395 (h0 : group (has_neg (has_to_string pos))) : normalizer_condition (has_neg (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_19396 (h0 : topological_space (normed_field (mul_one_class enat))) : t0_space (normed_field (mul_one_class enat)) := sorry --non-trivial
lemma new_lemma_19397 (h0 : ring (has_one congr_arg_kind)) : rank_condition (has_one congr_arg_kind) := sorry --non-trivial
lemma new_lemma_19398 (h0 : functor.add_const (finset (ordered_comm_ring Type)) (ring Type)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_19399 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (linear_order.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (linear_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_19400 (h0 : complete_lattice (encodable (has_top to_additive.value_type))) : complete_lattice.is_Sup_finite_compact (encodable (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_19401 (h0 : functor.add_const (topological_space (free_add_monoid congr_arg_kind)) unsigned) : @t1_space.{0} (free_add_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_19402 (h0 : semiring (linear_ordered_semiring (semiring congr_arg_kind))) : is_noetherian_ring (linear_ordered_semiring (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_19403 (h0 : ordered_comm_monoid (add_comm_monoid (ring (has_neg linarith.comp)))) : has_exists_mul_of_le (add_comm_monoid (ring (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_19404 (h0 : functor.add_const (topological_space (ring linarith.comp)) Type) : @sequential_space.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (ring.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_19405 (h0 : functor.add_const (function.extfun Type list) Type) : list.nodup (function.extfun_app (functor.add_const.run h0) (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_19406 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (has_nndist.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_nndist.{0} name))  := sorry --non-trivial
lemma new_lemma_19407 (h0 : functor.add_const (topological_space (boolean_algebra pos)) (has_Inf Type)) : @irreducible_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.{0} pos)) (has_Inf.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_19408 (h0 : add_group (has_inter (semiring empty))) : is_add_cyclic (has_inter (semiring empty)) := sorry --non-trivial
lemma new_lemma_19409 (h0 : functor.add_const (topological_space (has_to_string Type)) (has_add name)) : @loc_path_connected_space.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_to_string.{1} Type)) (has_add.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_19410 (h0 : ring (with_one (has_nnnorm (has_nnnorm fun_info)))) : is_domain (with_one (has_nnnorm (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_19411 (h0 : function.extfun Type topological_space) : @t1_space.{0} (has_zero.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_zero.{0} num))  := sorry --non-trivial
lemma new_lemma_19412 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : add_monoid.fg real.angle := sorry --non-trivial
lemma new_lemma_19413 (h0 : is_empty (normed_group num)) (h1 : normed_group num) : @t0_space.{0} (add_right_cancel_monoid.{0} (semiring.{0} empty)) (@is_empty.elim'.{1 1} (normed_group.{0} num) (topological_space.{0} (add_right_cancel_monoid.{0} (semiring.{0} empty))) h0 h1)  := sorry --non-trivial
lemma new_lemma_19414 (h0 : group (mul_zero_class empty)) : normalizer_condition (mul_zero_class empty) := sorry --non-trivial
lemma new_lemma_19415 (h0 : add_group (denumerable (has_neg (random_gen to_additive.value_type)))) : is_add_cyclic (denumerable (has_neg (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_19416 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_neg.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_neg.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_19417 (h0 : list (ordered_comm_monoid (ring (ring Type)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_19418 (h0 : topological_space (add_comm_monoid Type)) : t1_space (add_comm_monoid Type) := sorry --non-trivial
lemma new_lemma_19419 (h0 : functor.add_const (topological_space (boolean_algebra Type)) Type) : @loc_path_connected_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (boolean_algebra.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_19420 (h0 : topological_space (dlist (has_add to_additive.value_type))) : path_connected_space (dlist (has_add to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_19421 (h0 : functor.add_const empty congr_arg_kind) : @locally_compact_space.{0} (linear_ordered_comm_monoid_with_zero.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_comm_monoid_with_zero.{0} empty)) empty (@empty.elim.{1} (functor.add_const.{0 0} (topological_space.{0} (linear_ordered_comm_monoid_with_zero.{0} empty)) empty) (@functor.add_const.run.{0 0} empty congr_arg_kind h0)))  := sorry --non-trivial
lemma new_lemma_19422 (h0 : not (ring (comm_ring string_imp) -> false)) : @is_domain.{0} (comm_ring.{0} string_imp) (@classical.by_contradiction'.{1} (ring.{0} (comm_ring.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_19423 (h0 : ring ereal) : rank_condition ereal := sorry --non-trivial
lemma new_lemma_19424 (h0 : not (group (with_one char) -> false)) : @group.fg.{0} (with_one.{0} char) (@classical.by_contradiction'.{1} (group.{0} (with_one.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_19425 (h0 : complete_lattice (finset (option (option ennreal)))) : is_compactly_generated (finset (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_19426 (h1 : not (topological_space (semi_normed_comm_ring string_imp) -> false)) : @path_connected_space.{0} (semi_normed_comm_ring.{0} string_imp) (@classical.by_contradiction'.{1} (topological_space.{0} (semi_normed_comm_ring.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_19427 (h0 : semiring (has_top (semiring unsigned))) : is_noetherian_ring (has_top (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_19428 (h1 : topological_space (has_add linarith.ineq)) : path_connected_space (has_add linarith.ineq) := sorry --non-trivial
lemma new_lemma_19429 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (ring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ring.{0} name))  := sorry --non-trivial
lemma new_lemma_19430 (h0 : not (add_group (denumerable char) -> false)) : @is_add_cyclic.{0} (denumerable.{0} char) (@classical.by_contradiction'.{1} (add_group.{0} (denumerable.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_19431 (h0 : cancel_comm_monoid_with_zero (preorder (semiring (semiring (semiring num))))) : unique_factorization_monoid (preorder (semiring (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_19432 (h0 : topological_space (boolean_algebra (has_add (has_add (has_add pos))))) : discrete_topology (boolean_algebra (has_add (has_add (has_add pos)))) := sorry --non-trivial
lemma new_lemma_19433 (h0 : group (has_norm (has_inv linarith.comp_source))) : group.fg (has_norm (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_19434 (h0 : group (option (option (option unsigned)))) : is_cyclic (option (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_19435 (h0 : topological_space (ring (has_neg linarith.comp))) : totally_separated_space (ring (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_19436 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_norm.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_norm.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_19437 (h0 : ring (has_nndist (comm_group (comm_group Type)))) : strong_rank_condition (has_nndist (comm_group (comm_group Type))) := sorry --non-trivial
lemma new_lemma_19438 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (add_semigroup.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_semigroup.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_19439 (h0 : topological_space (has_inv fun_info)) : locally_compact_space (has_inv fun_info) := sorry --non-trivial
lemma new_lemma_19440 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (group_with_zero.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (group_with_zero.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_19441 (h0 : functor.add_const (topological_space (boolean_algebra.core unsigned)) (option unsigned)) : @totally_disconnected_space.{0} (boolean_algebra.core.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} unsigned)) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_19442 (h0 : topological_space (complete_linear_order (semiring (semiring congr_arg_kind)))) : t0_space (complete_linear_order (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_19443 (h0 : Type) (h1 : has_lt (parse_result h0)) : no_max_order (parse_result h0) := sorry --non-trivial
lemma new_lemma_19444 (h1 : add_group (nondiscrete_normed_field (mul_one_class reducibility_hints))) : is_add_cyclic (nondiscrete_normed_field (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_19445 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (non_assoc_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (non_assoc_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_19446 (h0 : random_gen (has_top (random_gen string_imp)) -> random_gen (has_top (random_gen string_imp)) -> bool) : is_dec_refl h0 := sorry --non-trivial
lemma new_lemma_19447 (h0 : group (has_dist num)) : is_cyclic (has_dist num) := sorry --non-trivial
lemma new_lemma_19448 (h0 : functor.add_const (functor.comp complete_lattice canonically_ordered_comm_semiring name) name) : @complete_lattice.is_Sup_finite_compact.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (canonically_ordered_comm_semiring.{0} name)) pos (@functor.comp.run.{0 0 0} complete_lattice.{0} canonically_ordered_comm_semiring.{0} name (@functor.add_const.run.{0 0} (functor.comp.{0 0 0} complete_lattice.{0} canonically_ordered_comm_semiring.{0} name) name h0)))  := sorry --non-trivial
lemma new_lemma_19449 (h0 : monoid (option ennreal)) : monoid.fg (option ennreal) := sorry --non-trivial
lemma new_lemma_19450 (h0 : functor.add_const (group (has_to_string Type)) Type) : @normalizer_condition.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 1} (group.{1} (has_to_string.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_19451 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_star.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_star.{0} num))  := sorry --non-trivial
lemma new_lemma_19452 (h0 : filter (dlist (has_nnnorm char))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_19453 (h0 : not (function.extfun Type filter -> false)) : filter.ne_bot (function.extfun_app (classical.by_contradiction' h0) (has_one linarith.comp)) := sorry --non-trivial
lemma new_lemma_19454 (h0 : ring (sub_neg_monoid (ring name))) : is_domain (sub_neg_monoid (ring name)) := sorry --non-trivial
lemma new_lemma_19455 (h0 : functor.add_const (complete_lattice (has_Sup unsigned)) empty) : @is_compactly_generated.{0} (has_Sup.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_Sup.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_19456 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (add_cancel_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_19457 (h0 : complete_lattice (add_comm_monoid (comm_group (comm_group (comm_group (comm_group (comm_group Type))))))) : is_atomistic (add_comm_monoid (comm_group (comm_group (comm_group (comm_group (comm_group Type)))))) := sorry --non-trivial
lemma new_lemma_19458 (h1 : ring (with_zero string_imp)) : is_domain (with_zero string_imp) := sorry --non-trivial
lemma new_lemma_19459 (h0 : not (has_mem.mem (normed_group num) has_emptyc.emptyc -> false)) : @irreducible_space.{0} (normed_group.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (normed_group.{0} num) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (normed_group.{0} num) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_19460 (h0 : group (has_norm (random_gen (random_gen (random_gen string_imp))))) : group.fg (has_norm (random_gen (random_gen (random_gen string_imp)))) := sorry --non-trivial
lemma new_lemma_19461 (h0 : ring (sub_neg_monoid (has_add Type))) : strong_rank_condition (sub_neg_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_19462 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (semigroup.{0} (option.{0} (option.{0} empty))) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} (option.{0} (option.{0} empty))))  := sorry --non-trivial
lemma new_lemma_19463 (h0 : topological_space (has_bot (has_add pos))) : t0_space (has_bot (has_add pos)) := sorry --non-trivial
lemma new_lemma_19464 (h0 : functor.add_const (finset (has_to_string linarith.comp)) (has_to_string Type)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_19465 (h0 : functor.add_const (function.extfun Type ring) (ring pos)) : @strong_rank_condition.{0} (has_to_string.{0} ordering) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) (ring.{0} pos) h0) (has_to_string.{0} ordering))  := sorry --non-trivial
lemma new_lemma_19466 (h0 : functor.add_const (topological_space (normed_linear_ordered_group empty)) (option empty)) : @path_connected_space.{0} (normed_linear_ordered_group.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_linear_ordered_group.{0} empty)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_19467 (h0 : fin has_zero.zero) : @path_connected_space.{0} (comm_semigroup.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (comm_semigroup.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_19468 (h0 : set (mul_one_class char)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_19469 (h0 : add_group (nondiscrete_normed_field environment.projection_info)) : is_add_cyclic (nondiscrete_normed_field environment.projection_info) := sorry --non-trivial
lemma new_lemma_19470 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_simple_group.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_19471 (h0 : topological_space (comm_group (has_to_string (comm_group name)))) : t0_space (comm_group (has_to_string (comm_group name))) := sorry --non-trivial
lemma new_lemma_19472 (h0 : topological_space (non_unital_non_assoc_semiring (mul_one_class string.iterator_imp))) : totally_disconnected_space (non_unital_non_assoc_semiring (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_19473 (h0 : topological_space (finset (finset linarith.comp))) : topological_space.separable_space (finset (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_19474 (h0 : functor.add_const (ring (ring linarith.comp)) (has_zero Type)) : @is_domain.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (ring.{0} (ring.{0} linarith.comp)) (has_zero.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_19475 (h0 : functor.add_const (finset (has_zero Type)) (has_pos_part pos)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_19476 (h0 : ring (has_append (has_nnnorm (comm_ring fun_info)))) : is_domain (has_append (has_nnnorm (comm_ring fun_info))) := sorry --non-trivial
lemma new_lemma_19477 (h0 : functor.add_const (topological_space (left_cancel_semigroup unsigned)) (option unsigned)) : @totally_disconnected_space.{0} (left_cancel_semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_semigroup.{0} unsigned)) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_19478 (h0 : semiring (add_right_cancel_monoid (linear_ordered_semiring (has_top empty)))) : is_noetherian_ring (add_right_cancel_monoid (linear_ordered_semiring (has_top empty))) := sorry --non-trivial
lemma new_lemma_19479 (h0 : semiring (mul_zero_class (finset (finset (has_nndist ennreal))))) : is_noetherian_ring (mul_zero_class (finset (finset (has_nndist ennreal)))) := sorry --non-trivial
lemma new_lemma_19480 (h0 : topological_space (has_nnnorm (has_nnnorm reducibility_hints))) : totally_disconnected_space (has_nnnorm (has_nnnorm reducibility_hints)) := sorry --non-trivial
lemma new_lemma_19481 (h0 : fin has_zero.zero) : @complete_space.{0} (comm_semigroup.{0} real) (@matrix.vec_empty.{0} (uniform_space.{0} (comm_semigroup.{0} real)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_19482 (h0 : functor.add_const (ring (ordered_comm_ring linarith.comp)) name) : @is_principal_ideal_ring.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (ordered_comm_ring.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_19483 (h0 : functor.add_const (add_group (normed_linear_ordered_group unsigned)) empty) : @is_add_cyclic.{0} (normed_linear_ordered_group.{0} unsigned) (@functor.add_const.run.{0 0} (add_group.{0} (normed_linear_ordered_group.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_19484 (h0 : topological_space (ring (finset pos))) : preconnected_space (ring (finset pos)) := sorry --non-trivial
lemma new_lemma_19485 (h0 : topological_space (nondiscrete_normed_field (add_comm_semigroup (normed_field std_gen)))) : path_connected_space (nondiscrete_normed_field (add_comm_semigroup (normed_field std_gen))) := sorry --non-trivial
lemma new_lemma_19486 (h0 : topological_space (boolean_algebra.core linarith.comp)) : sequential_space (boolean_algebra.core linarith.comp) := sorry --non-trivial
lemma new_lemma_19487 (h0 : complete_lattice (measurable_space.dynkin_system string.iterator_imp)) : is_compactly_generated (measurable_space.dynkin_system string.iterator_imp) := sorry --non-trivial
lemma new_lemma_19488 (h0 : topological_space (has_zero (has_neg Type))) : t1_space (has_zero (has_neg Type)) := sorry --non-trivial
lemma new_lemma_19489 (h0 : functor.add_const (finset (add_cancel_monoid pos)) Type) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_19490 (h0 : functor.add_const (group (cancel_monoid Type)) (cancel_monoid environment.implicit_infer_kind)) : @group.fg.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (cancel_monoid.{1} Type)) (cancel_monoid.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_19491 (h2 : add_group (with_one string_imp)) : is_add_cyclic (with_one string_imp) := sorry --non-trivial
lemma new_lemma_19492 (h1 : list (measurable_space (random_gen to_additive.value_type))) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_19493 (h0 : topological_space (has_nndist (has_zero name))) : totally_disconnected_space (has_nndist (has_zero name)) := sorry --non-trivial
lemma new_lemma_19494 (h0 : functor.add_const (finset (add_cancel_monoid name)) (ring (boolean_algebra (ring linarith.comp)))) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_19495 (h0 : group (add_comm_monoid (comm_group (comm_group (comm_group unsigned))))) : group.fg (add_comm_monoid (comm_group (comm_group (comm_group unsigned)))) := sorry --non-trivial
lemma new_lemma_19496 (h0 : filter (boolean_algebra.core (finset (finset (finset name))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_19497 (h0 : topological_space (has_add (has_Inf pos))) : regular_space (has_add (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_19498 (h0 : not (complete_lattice (has_compl fun_info) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_compl.{0} fun_info) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_compl.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_19499 (h0 : functor.add_const (finset (complete_distrib_lattice pos)) (has_add (boolean_algebra name))) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_19500 (h0 h1 : multiset (has_ssubset std_gen)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_19501 (h0 : group (ring (has_add name))) : group.fg (ring (has_add name)) := sorry --non-trivial
lemma new_lemma_19502 (h0 : filter (boolean_algebra name)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_19503 (h0 : topological_space (simple_graph (has_neg name))) : totally_disconnected_space (simple_graph (has_neg name)) := sorry --non-trivial
lemma new_lemma_19504 (h0 : ring (add_comm_monoid (has_neg (has_neg environment.implicit_infer_kind)))) : rank_condition (add_comm_monoid (has_neg (has_neg environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_19505 (h0 : ordered_comm_monoid (boolean_algebra (has_Inf Type))) : has_exists_mul_of_le (boolean_algebra (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_19506 (h0 : topological_space (semiring (has_norm (has_norm fun_info)))) : irreducible_space (semiring (has_norm (has_norm fun_info))) := sorry --non-trivial
lemma new_lemma_19507 (h0 : uniform_space (normed_lattice_add_comm_group (has_Inf real))) : complete_space (normed_lattice_add_comm_group (has_Inf real)) := sorry --non-trivial
lemma new_lemma_19508 (h0 : function.extfun Type (functor.add_const (ring (normed_linear_ordered_group congr_arg_kind)))) : @is_principal_ideal_ring.{0} (normed_linear_ordered_group.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ring.{0} (normed_linear_ordered_group.{0} congr_arg_kind)) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} (normed_linear_ordered_group.{0} congr_arg_kind))) h0 num))  := sorry --non-trivial
lemma new_lemma_19509 (h0 : measurable_space (has_le string.iterator_imp)) (h1 : filter (has_le string.iterator_imp)) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_19510 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_19511 (h0 : functor.add_const (cancel_comm_monoid_with_zero (add_cancel_monoid pos)) pos) : @unique_factorization_monoid.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (add_cancel_monoid.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_19512 (h0 : topological_space (distrib_lattice (random_gen (random_gen to_additive.value_type)))) : totally_separated_space (distrib_lattice (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_19513 (h0 : uniform_space (has_pos_part (ring (ring Type)))) : separated_space (has_pos_part (ring (ring Type))) := sorry --non-trivial
lemma new_lemma_19514 (h0 : ring ereal) : is_domain ereal := sorry --non-trivial
lemma new_lemma_19515 (h0 : topological_space (ordered_cancel_add_comm_monoid (option pos))) : discrete_topology (ordered_cancel_add_comm_monoid (option pos)) := sorry --non-trivial
lemma new_lemma_19516 (h0 : not (function.extfun Type ring -> false)) : @strong_rank_condition.{0} (random_gen.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (random_gen.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_19517 (h0 : filter (comm_group (option name))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_19518 (h0 : functor.add_const (topological_space (has_Inf Type)) (has_neg pos)) : @totally_separated_space.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_Inf.{1} Type)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_19519 (h0 : functor.add_const (topological_space (semigroup name)) pos) : @normal_space.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_19520 (h0 : topological_space (comm_group (has_to_string unsigned))) : path_connected_space (comm_group (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_19521 (h0 : function.extfun Type (functor.add_const (add_group (ordered_ring congr_arg_kind)))) : @is_add_cyclic.{0} (ordered_ring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (add_group.{0} (ordered_ring.{0} congr_arg_kind)) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (add_group.{0} (ordered_ring.{0} congr_arg_kind))) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_19522 (h0 : function.extfun Type topological_space) : @normal_space.{0} (has_nndist.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} real))  := sorry --non-trivial
lemma new_lemma_19523 (h0 : functor.add_const (ring (add_cancel_monoid environment.implicit_infer_kind)) unsigned) : @is_principal_ideal_ring.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_19524 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (has_one.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_one.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_19525 (h0 : topological_space (boolean_algebra.core (finset ennreal))) : path_connected_space (boolean_algebra.core (finset ennreal)) := sorry --non-trivial
lemma new_lemma_19526 (h0 : functor.add_const (topological_space (has_neg pos)) Type) : @topological_space.separable_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_19527 (h1 : not (ring (dlist char) -> false)) : @strong_rank_condition.{0} (dlist.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (dlist.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_19528 (h0 : functor.add_const (filter (cancel_monoid unsigned)) name) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_19529 (h0 : functor.add_const (ring (cancel_monoid unsigned)) Type) : @is_principal_ideal_ring.{0} (cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 1} (ring.{0} (cancel_monoid.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_19530 (h0 : cancel_comm_monoid_with_zero (boolean_algebra (has_add (has_add name)))) : unique_factorization_monoid (boolean_algebra (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_19531 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @preirreducible_space.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_19532 (h0 : ring (semi_normed_comm_ring (has_ssubset (has_nnnorm fun_info)))) : rank_condition (semi_normed_comm_ring (has_ssubset (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_19533 (h0 : functor.add_const (function.extfun Type complete_lattice) pos) : @is_compactly_generated.{0} (normed_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) pos h0) (normed_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_19534 (h0 : has_mem.mem (semiring to_additive.value_type) has_emptyc.emptyc) : @totally_separated_space.{0} (semiring.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type topological_space.{0} (semiring.{0} to_additive.value_type) h0)  := sorry --non-trivial
lemma new_lemma_19535 (h0 : not (ring (linear_ordered_semiring unsigned) -> false)) : @rank_condition.{0} (linear_ordered_semiring.{0} unsigned) (@classical.by_contradiction'.{1} (ring.{0} (linear_ordered_semiring.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_19536 (h0 : ordered_comm_monoid (has_pos_part (has_add (has_add (has_Inf (has_add linarith.comp)))))) : has_exists_mul_of_le (has_pos_part (has_add (has_add (has_Inf (has_add linarith.comp))))) := sorry --non-trivial
lemma new_lemma_19537 (h0 : function.extfun Type topological_space) : @normal_space.{0} (canonically_ordered_add_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_add_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_19538 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (ordered_comm_ring.{0} real) (@function.extfun_app.{2 1} Type semiring.{0} h0 (ordered_comm_ring.{0} real))  := sorry --non-trivial
lemma new_lemma_19539 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (as_linear_order.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (as_linear_order.{0} num))  := sorry --non-trivial
lemma new_lemma_19540 (h1 : uniform_space (has_compl (metric_space to_additive.value_type))) : complete_space (has_compl (metric_space to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_19541 (h0 : group (complete_semilattice_Sup (has_norm string_imp))) : group.fg (complete_semilattice_Sup (has_norm string_imp)) := sorry --non-trivial
lemma new_lemma_19542 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} auto.case_option (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) auto.case_option)  := sorry --non-trivial
lemma new_lemma_19543 (h0 : functor.add_const (uniform_space (filter empty)) unsigned) : @complete_space.{0} (filter.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (filter.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_19544 (h0 : complete_lattice (with_bot (has_norm fun_info))) : is_atomistic (with_bot (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_19545 (h0 : not (list (complete_semilattice_Sup (random_gen linarith.ineq)) -> false)) : list.nodup (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_19546 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (with_one.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (with_one.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_19547 (h0 : topological_space (measurable_space (semiring empty))) : normal_space (measurable_space (semiring empty)) := sorry --non-trivial
lemma new_lemma_19548 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (linear_ordered_field empty)) := sorry --non-trivial
lemma new_lemma_19549 (h0 : ring (has_dist num)) : rank_condition (has_dist num) := sorry --non-trivial
lemma new_lemma_19550 (h0 : topological_space (has_add (has_neg (ring Type)))) : normal_space (has_add (has_neg (ring Type))) := sorry --non-trivial
lemma new_lemma_19551 (h0 : functor.add_const (finset (has_neg name)) (has_neg pos)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_19552 (h0 : functor.add_const (complete_lattice (has_to_string name)) Type) : @is_atomistic.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 1} (complete_lattice.{0} (has_to_string.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_19553 (h0 : uniform_space (plift (semiring (semiring num)))) : complete_space (plift (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_19554 (h1 : has_mem.mem (has_emptyc linarith.comp) has_emptyc.emptyc) : @complete_space.{0} (has_emptyc.{0} linarith.comp) (@finset.pi.empty.{1 0} Type uniform_space.{0} (has_emptyc.{0} linarith.comp) h1)  := sorry --non-trivial
lemma new_lemma_19555 (h0 : function.extfun Type (functor.comp topological_space add_cancel_monoid)) : @t1_space.{0} (add_cancel_monoid.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} add_cancel_monoid.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} add_cancel_monoid.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_19556 (h0 : functor.add_const (ring (has_zero Type)) pos) : @rank_condition.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_zero.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_19557 (h0 : topological_space znum) : normal_space znum := sorry --non-trivial
lemma new_lemma_19558 (h0 : ordered_comm_monoid (has_neg (has_neg (ring name)))) : has_exists_mul_of_le (has_neg (has_neg (ring name))) := sorry --non-trivial
lemma new_lemma_19559 (h0 : group (has_to_string (finset Type))) : group.fg (has_to_string (finset Type)) := sorry --non-trivial
lemma new_lemma_19560 (h0 : topological_space (comm_group (has_neg_part (add_comm_monoid (comm_group Type))))) : loc_path_connected_space (comm_group (has_neg_part (add_comm_monoid (comm_group Type)))) := sorry --non-trivial
lemma new_lemma_19561 (h1 : not (has_mem.mem (normed_group to_additive.value_type) has_emptyc.emptyc -> false)) : @path_connected_space.{0} (normed_group.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type topological_space.{0} (normed_group.{0} to_additive.value_type) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (normed_group.{0} to_additive.value_type) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h1))  := sorry --non-trivial
lemma new_lemma_19562 (h0 : monoid (id (has_norm (has_norm num)))) : monoid.fg (id (has_norm (has_norm num))) := sorry --non-trivial
lemma new_lemma_19563 (h0 : cancel_comm_monoid_with_zero (has_pos_part (has_Inf (has_sdiff linarith.comp)))) : unique_factorization_monoid (has_pos_part (has_Inf (has_sdiff linarith.comp))) := sorry --non-trivial
lemma new_lemma_19564 (h0 : not (uniform_space (has_sub empty) -> false)) : @complete_space.{0} (has_sub.{0} empty) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_sub.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_19565 (h0 : functor.add_const (complete_lattice (has_to_string Type)) environment.implicit_infer_kind) : @complete_lattice.is_Sup_finite_compact.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (has_to_string.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_19566 (h1 : group (normed_group (has_top (has_nnnorm fun_info)))) : group.fg (normed_group (has_top (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_19567 (h0 : functor.add_const (topological_space (ordered_comm_monoid Type)) (has_add pos)) : @irreducible_space.{1} (ordered_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ordered_comm_monoid.{1} Type)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_19568 (h0 : topological_space (has_bot (has_neg name))) : irreducible_space (has_bot (has_neg name)) := sorry --non-trivial
lemma new_lemma_19569 (h0 : function.extfun Type topological_space) : @normal_space.{0} (has_to_string.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_19570 (h0 : topological_space (non_assoc_semiring unsigned)) : totally_disconnected_space (non_assoc_semiring unsigned) := sorry --non-trivial
lemma new_lemma_19571 (h1 : list (has_nnnorm (random_gen to_additive.value_type))) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_19572 (h0 : not (uniform_space (complete_lattice num) -> false)) : @complete_space.{0} (complete_lattice.{0} num) (@classical.by_contradiction'.{1} (uniform_space.{0} (complete_lattice.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_19573 (h0 : functor.add_const (add_monoid (bin_tree empty)) empty) : @add_monoid.fg.{0} (bin_tree.{0} empty) (@functor.add_const.run.{0 0} (add_monoid.{0} (bin_tree.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_19574 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_inner.{0 0} pos (option.{0} pos)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inner.{0 0} pos (option.{0} pos)))  := sorry --non-trivial
lemma new_lemma_19575 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (with_bot.{0} string_imp) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (with_bot.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_19576 (h0 : topological_space (add_cancel_monoid linarith.comp)) : locally_compact_space (add_cancel_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_19577 (h0 : function.extfun (finset Type) (has_mem.mem (has_one linarith.comp))) : @path_connected_space.{0} (has_one.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_one.{0} linarith.comp) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_one.{0} linarith.comp)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_19578 (h0 : topological_space (has_Inf (ring (has_add (ring pos))))) : preconnected_space (has_Inf (ring (has_add (ring pos)))) := sorry --non-trivial
lemma new_lemma_19579 (h0 : functor.add_const (list (has_star empty)) congr_arg_kind) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_19580 (h0 : functor.add_const (topological_space (semiring congr_arg_kind)) congr_arg_kind) : @topological_space.separable_space.{0} (semiring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (semiring.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_19581 (h0 : monoid (has_emptyc (with_bot linarith.comp_source))) : monoid.fg (has_emptyc (with_bot linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_19582 (h0 : function.extfun Type topological_space) : @t1_space.{0} (canonically_ordered_add_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_add_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_19583 (h0 : functor.add_const (topological_space (partial_order congr_arg_kind)) congr_arg_kind) : @discrete_topology.{0} (partial_order.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (partial_order.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_19584 (h0 : topological_space (has_nnnorm to_additive.value_type)) : locally_compact_space (has_nnnorm to_additive.value_type) := sorry --non-trivial
lemma new_lemma_19585 (h0 : complete_lattice (add_cancel_monoid (has_add Type))) : is_compactly_generated (add_cancel_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_19586 (h0 : topological_space (monoid_with_zero unsigned)) : t1_space (monoid_with_zero unsigned) := sorry --non-trivial
lemma new_lemma_19587 (h0 : functor.comp add_group has_add (has_add name)) : @is_add_cyclic.{0} (has_add.{0} (has_add.{0} name)) (@functor.comp.run.{0 0 0} add_group.{0} has_add.{0} (has_add.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_19588 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} linarith.comp (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) linarith.comp)  := sorry --non-trivial
lemma new_lemma_19589 (h0 : topological_space (ordered_comm_ring (has_neg (has_neg Type)))) : totally_separated_space (ordered_comm_ring (has_neg (has_neg Type))) := sorry --non-trivial
lemma new_lemma_19590 (h0 : functor.add_const (topological_space (has_Inf linarith.comp)) (has_Inf linarith.comp)) : @totally_separated_space.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} linarith.comp)) (has_Inf.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_19591 (h0 : functor.add_const (ring (comm_group linarith.comp)) pos) : @is_domain.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (comm_group.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_19592 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @strong_rank_condition.{0} (semiring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) ring.{0}) (semiring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_19593 (h0 : ring (add_comm_semigroup string.iterator_imp)) : strong_rank_condition (add_comm_semigroup string.iterator_imp) := sorry --non-trivial
lemma new_lemma_19594 (h0 : topological_space (boolean_algebra.core (option pos))) : totally_disconnected_space (boolean_algebra.core (option pos)) := sorry --non-trivial
lemma new_lemma_19595 (h0 : complete_lattice (has_Sup congr_arg_kind)) : complete_lattice.is_Sup_finite_compact (has_Sup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_19596 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (partial_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (partial_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_19597 (h0 h1 : multiset (semi_normed_group empty)) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_19598 (h0 : ring (has_top linarith.comp_source)) : rank_condition (has_top linarith.comp_source) := sorry --non-trivial
lemma new_lemma_19599 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_19600 (h0 : group (add_cancel_monoid Type)) : group.fg (add_cancel_monoid Type) := sorry --non-trivial
lemma new_lemma_19601 (h0 : not (filter (semiring empty) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_19602 (h0 : complete_lattice (non_unital_non_assoc_semiring (has_lt reducibility_hints))) : is_compactly_generated (non_unital_non_assoc_semiring (has_lt reducibility_hints)) := sorry --non-trivial
lemma new_lemma_19603 (h0 : group (has_nnnorm (has_nnnorm to_additive.value_type))) : group.fg (has_nnnorm (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_19604 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (has_nndist.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_nndist.{0} name))  := sorry --non-trivial
lemma new_lemma_19605 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (linear_ordered_field.{0} empty) (@function.extfun_app.{2 1} Type semiring.{0} h0 (linear_ordered_field.{0} empty))  := sorry --non-trivial
lemma new_lemma_19606 (h0 : uniform_space (add_semigroup (option empty))) : separated_space (add_semigroup (option empty)) := sorry --non-trivial
lemma new_lemma_19607 (h0 : not (ring (fintype linarith.comp_source) -> false)) : @strong_rank_condition.{0} (fintype.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (fintype.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_19608 (h0 : topological_space (normed_group (semiring (semiring unsigned)))) : locally_compact_space (normed_group (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_19609 (h0 : topological_space (comm_group (measurable_space.dynkin_system pos))) : totally_disconnected_space (comm_group (measurable_space.dynkin_system pos)) := sorry --non-trivial
lemma new_lemma_19610 (h0 : measurable_space (has_nnnorm enat)) (h1 : filter (has_nnnorm enat)) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_19611 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (with_bot.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_bot.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_19612 (h0 : functor.add_const (function.extfun (Type 1) list) (ring (ring Type))) : list.nodup (function.extfun_app (functor.add_const.run h0) (has_add Type)) := sorry --non-trivial
lemma new_lemma_19613 (h0 : topological_space (has_compl (has_nnnorm char))) : t0_space (has_compl (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_19614 (h0 : functor.add_const (ordered_comm_monoid (ordered_comm_ring pos)) name) : @has_exists_mul_of_le.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (ordered_comm_ring.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_19615 (h0 : group (has_Inf (has_add linarith.comp))) : is_simple_group (has_Inf (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_19616 (h0 : add_group ordering) : is_add_cyclic ordering := sorry --non-trivial
lemma new_lemma_19617 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @totally_separated_space.{0} (complete_semilattice_Sup.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) topological_space.{0}) (complete_semilattice_Sup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_19618 (h0 : function.extfun Type ring) : @rank_condition.{0} (filter.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (filter.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_19619 (h0 : function.extfun Type group) : @group.fg.{0} (has_norm.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (has_norm.{0} num))  := sorry --non-trivial
lemma new_lemma_19620 (h0 : fin has_zero.zero) : @locally_compact_space.{1} (canonically_ordered_comm_semiring.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (canonically_ordered_comm_semiring.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_19621 (h0 : functor.add_const (complete_lattice (add_cancel_monoid environment.implicit_infer_kind)) name) : @is_atomistic.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_19622 (h2 : string_imp -> to_additive.value_type -> Prop) : relator.left_total h2 := sorry --non-trivial
lemma new_lemma_19623 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (normed_group.{0} linarith.ineq) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (normed_group.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_19624 (h0 : functor.comp complete_lattice has_neg_part environment.implicit_infer_kind) : @is_atomistic.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} complete_lattice.{0} has_neg_part.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_19625 (h0 : has_lt (has_div environment.projection_info)) : no_max_order (has_div environment.projection_info) := sorry --non-trivial
lemma new_lemma_19626 (h0 : functor.add_const (finset (has_edist empty)) unsigned) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_19627 (h0 : has_mem.mem (metric_space (has_norm congr_arg_kind)) has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} (metric_space.{0} (has_norm.{0} congr_arg_kind)) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (metric_space.{0} (has_norm.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_19628 (h0 : ring (semiring (has_top (has_norm fun_info)))) : rank_condition (semiring (has_top (has_norm fun_info))) := sorry --non-trivial
lemma new_lemma_19629 (h0 : functor.add_const (topological_space (finset unsigned)) (option unsigned)) : @topological_space.separable_space.{0} (finset.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} unsigned)) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_19630 (h0 : measurable_space (add_comm_semigroup (add_comm_semigroup fun_info))) (h1 : measure_theory.measure (add_comm_semigroup (add_comm_semigroup fun_info))) : measure_theory.is_finite_measure h1 := sorry --non-trivial
lemma new_lemma_19631 (h0 : not (add_group fun_info -> false)) : @is_add_cyclic.{0} fun_info (@classical.by_contradiction'.{1} (add_group.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_19632 (h1 : complete_lattice (with_one linarith.comp_source)) : is_atomistic (with_one linarith.comp_source) := sorry --non-trivial
lemma new_lemma_19633 (h0 : uniform_space (with_one (has_norm (has_top unsigned)))) : separated_space (with_one (has_norm (has_top unsigned))) := sorry --non-trivial
lemma new_lemma_19634 (h0 : add_group (boolean_algebra.core (has_add (has_add environment.implicit_infer_kind)))) : is_add_cyclic (boolean_algebra.core (has_add (has_add environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_19635 (h1 : not (filter (add_left_cancel_monoid to_additive.value_type) -> false)) : filter.ne_bot (classical.by_contradiction' h1) := sorry --non-trivial
lemma new_lemma_19636 (h1 : uniform_space (non_unital_non_assoc_semiring string_imp)) : complete_space (non_unital_non_assoc_semiring string_imp) := sorry --non-trivial
lemma new_lemma_19637 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (measurable_space.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measurable_space.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_19638 (h0 : functor.comp group add_comm_monoid Type) : @normalizer_condition.{1} (add_comm_monoid.{1} Type) (@functor.comp.run.{1 1 1} group.{1} add_comm_monoid.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_19639 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (ordered_comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (ordered_comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_19640 (h1 : ring (mul_one_class char)) : rank_condition (mul_one_class char) := sorry --non-trivial
lemma new_lemma_19641 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_19642 (h0 : ring (linear_ordered_comm_group empty)) : is_principal_ideal_ring (linear_ordered_comm_group empty) := sorry --non-trivial
lemma new_lemma_19643 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (dlist.{0} linarith.ineq) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (dlist.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_19644 (h0 : function.extfun (Type 1) filter) : countable_Inter_filter (function.extfun_app h0 (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_19645 (h0 : function.extfun Type ring) : @is_domain.{0} (measurable_space.dynkin_system.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (measurable_space.dynkin_system.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_19646 (h0 : functor.add_const (topological_space (left_cancel_monoid congr_arg_kind)) num) : @path_connected_space.{0} (left_cancel_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_19647 (h0 : complete_lattice (measurable_space string_imp)) : is_compactly_generated (measurable_space string_imp) := sorry --non-trivial
lemma new_lemma_19648 (h0 : functor.add_const (topological_space (mul_zero_class unsigned)) Type) : @totally_disconnected_space.{0} (mul_zero_class.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (mul_zero_class.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_19649 (h0 : topological_space (has_inv (random_gen (random_gen linarith.comp_source)))) : totally_disconnected_space (has_inv (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_19650 (h0 : group (has_inv (random_gen (random_gen fun_info)))) : normalizer_condition (has_inv (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_19651 (h0 : functor.add_const (ring (left_cancel_monoid unsigned)) congr_arg_kind) : @is_principal_ideal_ring.{0} (left_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (left_cancel_monoid.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_19652 (h0 : functor.add_const (group (has_zero name)) (has_neg_part Type)) : @is_simple_group.{0} (has_zero.{0} name) (@functor.add_const.run.{0 1} (group.{0} (has_zero.{0} name)) (has_neg_part.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_19653 (h0 : monoid (comm_monoid congr_arg_kind)) : monoid.fg (comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_19654 (h0 : topological_space (ordered_comm_ring (sub_neg_monoid pos))) : irreducible_space (ordered_comm_ring (sub_neg_monoid pos)) := sorry --non-trivial
lemma new_lemma_19655 (h1 h2 : multiset (mul_one_class std_gen)) : multiset.disjoint h1 h2 := sorry --non-trivial
lemma new_lemma_19656 (h0 : function.extfun Type ring) : @is_domain.{0} (linear_ordered_comm_ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_ordered_comm_ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_19657 (h0 : topological_space (has_bot (has_Inf Type))) : locally_compact_space (has_bot (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_19658 (h0 : topological_space (boolean_algebra.core (has_neg name))) : locally_compact_space (boolean_algebra.core (has_neg name)) := sorry --non-trivial
lemma new_lemma_19659 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (normed_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_19660 (h0 : monoid (linear_ordered_comm_ring (semiring empty))) : monoid.fg (linear_ordered_comm_ring (semiring empty)) := sorry --non-trivial
lemma new_lemma_19661 (h0 : function.extfun (Type 1) topological_space) : @path_connected_space.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_19662 (h0 : ring (distrib (random_gen (has_nnnorm linarith.comp_source)))) : is_domain (distrib (random_gen (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_19663 (h0 : functor.add_const (uniform_space (has_pos_part Type)) pos) : @separated_space.{1} (has_pos_part.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (has_pos_part.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_19664 (h0 : topological_space (ordered_comm_group (option unsigned))) : irreducible_space (ordered_comm_group (option unsigned)) := sorry --non-trivial
lemma new_lemma_19665 (h0 : functor.add_const (topological_space (has_add linarith.comp)) name) : @totally_separated_space.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_19666 (h0 : topological_space (has_top (random_gen congr_arg_kind))) : path_connected_space (has_top (random_gen congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_19667 (h0 : topological_space (has_sub unsigned)) : topological_space.separable_space (has_sub unsigned) := sorry --non-trivial
lemma new_lemma_19668 (h0 : complete_lattice (has_lt (random_gen char))) : is_compactly_generated (has_lt (random_gen char)) := sorry --non-trivial
lemma new_lemma_19669 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (omega_complete_partial_order.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (omega_complete_partial_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_19670 (h0 h1 : multiset (mul_one_class (mul_one_class std_gen))) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_19671 (h0 : nat) (h1 : uniform_space (has_nnnorm (mul_one_class (zmod h0)))) : complete_space (has_nnnorm (mul_one_class (zmod h0))) := sorry --non-trivial
lemma new_lemma_19672 (h0 : ring (has_neg congr_arg_kind)) : strong_rank_condition (has_neg congr_arg_kind) := sorry --non-trivial
lemma new_lemma_19673 (h0 : ring (linear_ordered_add_comm_group (random_gen (random_gen to_additive.value_type)))) : rank_condition (linear_ordered_add_comm_group (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_19674 (h0 : ring (linear_ordered_add_comm_group (random_gen linarith.ineq))) : rank_condition (linear_ordered_add_comm_group (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_19675 (h0 : add_group (has_norm (measurable_space linarith.comp_source))) : is_add_cyclic (has_norm (measurable_space linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_19676 (h0 : topological_space (has_to_string (has_zero environment.implicit_infer_kind))) : topological_space.separable_space (has_to_string (has_zero environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_19677 (h0 : prod (add_comm_monoid name) (add_comm_monoid name)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_19678 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_19679 (h2 : has_lt (multiplicative reducibility_hints)) : no_max_order (multiplicative reducibility_hints) := sorry --non-trivial
lemma new_lemma_19680 (h0 : functor.comp (functor.add_const (ring environment.implicit_infer_kind)) has_add pos) : @rank_condition.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 0} (ring.{0} environment.implicit_infer_kind) (has_add.{0} pos) (@functor.comp.run.{0 0 0} (functor.add_const.{0 0} (ring.{0} environment.implicit_infer_kind)) has_add.{0} pos h0))  := sorry --non-trivial
lemma new_lemma_19681 (h0 : monoid (add_comm_monoid (comm_group unsigned))) : monoid.fg (add_comm_monoid (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_19682 (h0 : topological_space (ordered_comm_ring (has_add real))) : totally_disconnected_space (ordered_comm_ring (has_add real)) := sorry --non-trivial
lemma new_lemma_19683 (h0 : functor.add_const (topological_space (canonically_ordered_monoid real)) linarith.comp) : @normal_space.{0} (canonically_ordered_monoid.{0} real) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_monoid.{0} real)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_19684 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (semiring.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_19685 (h0 : ordered_add_comm_monoid (semigroup (has_neg (has_neg (finset linarith.comp))))) : archimedean (semigroup (has_neg (has_neg (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_19686 (h0 : group (add_cancel_monoid (has_pos_part pos))) : normalizer_condition (add_cancel_monoid (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_19687 (h1 : list (filter (dlist string_imp))) (h2 : ne h1 list.nil) : filter.ne_bot (list.last h1 h2) := sorry --non-trivial
lemma new_lemma_19688 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (ring.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ring.{0} real))  := sorry --non-trivial
lemma new_lemma_19689 (h0 : topological_space (left_cancel_semigroup (semiring (semiring empty)))) : totally_separated_space (left_cancel_semigroup (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_19690 (h0 : functor.comp add_group has_neg_part name) : @is_add_cyclic.{0} (has_neg_part.{0} name) (@functor.comp.run.{0 0 0} add_group.{0} has_neg_part.{0} name h0)  := sorry --non-trivial
lemma new_lemma_19691 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @is_cyclic.{0} (has_one.{0} empty) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) group.{0}) (has_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_19692 (h0 : ring (has_emptyc (has_norm to_additive.value_type))) : strong_rank_condition (has_emptyc (has_norm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_19693 (h0 : finset (finset (option name))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_19694 (h0 : semiring (has_nndist Type)) : is_noetherian_ring (has_nndist Type) := sorry --non-trivial
lemma new_lemma_19695 (h0 : topological_space (has_one (semiring num))) : irreducible_space (has_one (semiring num)) := sorry --non-trivial
lemma new_lemma_19696 (h0 : functor.comp ordered_add_comm_monoid add_comm_monoid name) : @archimedean.{0} (add_comm_monoid.{0} name) (@functor.comp.run.{0 0 0} ordered_add_comm_monoid.{0} add_comm_monoid.{0} name h0)  := sorry --non-trivial
lemma new_lemma_19697 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (linear_ordered_field.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (linear_ordered_field.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_19698 (h0 : has_le (has_emptyc (random_gen (random_gen num)))) (h1 : has_emptyc (random_gen (random_gen num))) : is_max h1 := sorry --non-trivial
lemma new_lemma_19699 (h0 : functor.add_const (finset (linear_ordered_cancel_comm_monoid empty)) (semiring num)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_19700 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_sub.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_sub.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_19701 (h0 : topological_space (omega_complete_partial_order (semiring unsigned))) : locally_compact_space (omega_complete_partial_order (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_19702 (h0 : functor.add_const (topological_space (has_to_string pos)) linarith.comp) : @loc_path_connected_space.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_19703 (h0 : uniform_space (field (complete_lattice linarith.ineq))) : complete_space (field (complete_lattice linarith.ineq)) := sorry --non-trivial
lemma new_lemma_19704 (h0 : fin has_zero.zero) : matrix.vec_empty (matrix.vec_empty (matrix.vec_empty (matrix.vec_empty (id h0)))) := sorry --non-trivial
lemma new_lemma_19705 (h0 : functor.add_const (uniform_space (ordered_comm_ring pos)) (has_neg name)) : @complete_space.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (ordered_comm_ring.{0} pos)) (has_neg.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_19706 (h0 : complete_lattice (has_compl enat)) : complete_lattice.is_Sup_finite_compact (has_compl enat) := sorry --non-trivial
lemma new_lemma_19707 (h0 : functor.add_const (topological_space (add_comm_monoid linarith.comp)) name) : @preconnected_space.{0} (add_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_19708 (h0 : preorder (mul_one_class (mul_one_class (mul_one_class string.iterator_imp)))) (h1 : set (mul_one_class (mul_one_class (mul_one_class string.iterator_imp)))) : set.is_pwo h1 := sorry --non-trivial
lemma new_lemma_19709 (h0 : uniform_space (linear_ordered_comm_group_with_zero string.iterator_imp)) : complete_space (linear_ordered_comm_group_with_zero string.iterator_imp) := sorry --non-trivial
lemma new_lemma_19710 (h0 : functor.add_const (topological_space (has_bot pos)) linarith.comp) : @totally_disconnected_space.{0} (has_bot.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_bot.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_19711 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (has_top.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_top.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_19712 (h0 : topological_space (has_nndist linarith.comp)) : preirreducible_space (has_nndist linarith.comp) := sorry --non-trivial
lemma new_lemma_19713 (h0 : cancel_comm_monoid_with_zero (has_neg_part (option (option name)))) : unique_factorization_monoid (has_neg_part (option (option name))) := sorry --non-trivial
lemma new_lemma_19714 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (has_add.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_19715 (h0 : function.extfun (Type 1) ordered_add_comm_monoid) : @archimedean.{1} Type (@function.extfun_app.{3 2} (Type 1) ordered_add_comm_monoid.{1} h0 Type)  := sorry --non-trivial
lemma new_lemma_19716 (h0 : functor.add_const (group (semigroup name)) pos) : @normalizer_condition.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (group.{0} (semigroup.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_19717 (h0 : uniform_space (linear_ordered_comm_group congr_arg_kind)) : complete_space (linear_ordered_comm_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_19718 (h1 : add_group (has_ssubset (has_ssubset char))) : is_add_cyclic (has_ssubset (has_ssubset char)) := sorry --non-trivial
lemma new_lemma_19719 (h0 : functor.add_const (topological_space (has_Inf name)) pos) : @locally_compact_space.{0} (has_Inf.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_19720 (h0 : topological_space (omega_complete_partial_order (semiring empty))) : normal_space (omega_complete_partial_order (semiring empty)) := sorry --non-trivial
lemma new_lemma_19721 (h0 : topological_space (ring pos)) : t1_space (ring pos) := sorry --non-trivial
lemma new_lemma_19722 (h0 : functor.add_const (topological_space (mul_zero_class environment.implicit_infer_kind)) name) : @locally_compact_space.{0} (mul_zero_class.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_19723 (h0 : functor.add_const (topological_space (has_add linarith.comp)) linarith.comp) : @topological_space.separable_space.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_19724 (h0 : fin has_zero.zero) : @totally_disconnected_space.{1} (has_pos_part.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (has_pos_part.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_19725 (h0 : cancel_comm_monoid_with_zero (linear_ordered_field (option name))) : unique_factorization_monoid (linear_ordered_field (option name)) := sorry --non-trivial
lemma new_lemma_19726 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @path_connected_space.{0} (linear_ordered_semiring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (linear_ordered_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_19727 (h0 : cancel_comm_monoid_with_zero (free_add_monoid empty)) : unique_factorization_monoid (free_add_monoid empty) := sorry --non-trivial
lemma new_lemma_19728 (h0 : functor.add_const (add_group (boolean_algebra.core pos)) (has_add name)) : @is_add_cyclic.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (boolean_algebra.core.{0} pos)) (has_add.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_19729 (h0 : topological_space (linear_ordered_semiring empty)) : totally_separated_space (linear_ordered_semiring empty) := sorry --non-trivial
lemma new_lemma_19730 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (has_star.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_star.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_19731 (h0 : functor.add_const (function.extfun Type topological_space) (mul_one_class pos)) : @t0_space.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (mul_one_class.{0} pos) h0) (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_19732 (h0 : functor.comp list has_add environment.implicit_infer_kind) : palindrome (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_19733 (h0 : functor.add_const (topological_space (left_cancel_monoid num)) num) : @locally_compact_space.{0} (left_cancel_monoid.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_19734 (h1 : ring (mul_one_class string.iterator_imp)) : rank_condition (mul_one_class string.iterator_imp) := sorry --non-trivial
lemma new_lemma_19735 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @sequential_space.{1} (has_bot.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (has_bot.{1} Type))  := sorry --non-trivial
lemma new_lemma_19736 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_top.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_top.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_19737 (h0 : function.extfun (finset Type) (has_mem.mem (has_emptyc linarith.comp_source))) : @complete_space.{0} (has_emptyc.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type uniform_space.{0} (has_emptyc.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_emptyc.{0} linarith.comp_source)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_19738 (h0 : ring (has_compl (random_gen char))) : rank_condition (has_compl (random_gen char)) := sorry --non-trivial
lemma new_lemma_19739 (h0 : functor.add_const (monoid (comm_group name)) pos) : @monoid.fg.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (monoid.{0} (comm_group.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_19740 (h0 : functor.add_const (ring (boolean_algebra pos)) Type) : @is_domain.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (boolean_algebra.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_19741 (h0 : complete_lattice (comm_ring (has_nnnorm linarith.comp_source))) : is_compactly_generated (comm_ring (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_19742 (h0 : finset (as_linear_order (option (option empty)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_19743 (h0 : functor.add_const (ring (bin_tree unsigned)) unsigned) : @strong_rank_condition.{0} (bin_tree.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (bin_tree.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_19744 (h0 : functor.add_const (function.extfun (Type 1) uniform_space) linarith.comp) : @separated_space.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) uniform_space.{1}) linarith.comp h0) (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_19745 (h0 : functor.add_const (topological_space (simple_graph unsigned)) unsigned) : @totally_disconnected_space.{0} (simple_graph.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (simple_graph.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_19746 (h0 : not (topological_space (complete_semilattice_Sup linarith.ineq) -> false)) : @path_connected_space.{0} (complete_semilattice_Sup.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (complete_semilattice_Sup.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_19747 (h0 : functor.add_const (function.extfun Type ring) Type) : @strong_rank_condition.{0} (has_neg.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ring.{0}) Type h0) (has_neg.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_19748 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 num) := sorry --non-trivial
lemma new_lemma_19749 (h0 : ring (with_one (comm_ring to_additive.value_type))) : is_domain (with_one (comm_ring to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_19750 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_one.{0} (has_norm.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_one.{0} (has_norm.{0} empty)))  := sorry --non-trivial
lemma new_lemma_19751 (h0 : set (has_compl (mul_one_class (mul_one_class (mul_one_class enat))))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_19752 (h0 : ordered_add_comm_monoid (has_add (has_neg (has_add (has_add Type))))) : archimedean (has_add (has_neg (has_add (has_add Type)))) := sorry --non-trivial
lemma new_lemma_19753 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @complete_lattice.is_Sup_finite_compact.{1} (comm_group.{1} (has_add.{1} (has_add.{1} (has_add.{1} (has_add.{1} Type))))) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 complete_lattice.{1}) (comm_group.{1} (has_add.{1} (has_add.{1} (has_add.{1} (has_add.{1} Type))))))  := sorry --non-trivial
lemma new_lemma_19754 (h0 : not (ring (partial_order unsigned) -> false)) : @is_domain.{0} (partial_order.{0} unsigned) (@classical.by_contradiction'.{1} (ring.{0} (partial_order.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_19755 (h0 : has_neg (simple_graph enat)) (h1 : measurable_space (simple_graph enat)) : has_measurable_neg (simple_graph enat) := sorry --non-trivial
lemma new_lemma_19756 (h0 : cancel_comm_monoid_with_zero (boolean_algebra.core congr_arg_kind)) : unique_factorization_monoid (boolean_algebra.core congr_arg_kind) := sorry --non-trivial
lemma new_lemma_19757 (h0 : functor.add_const (function.extfun Type ring) (has_neg Type)) : @rank_condition.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ring.{0}) (has_neg.{1} Type) h0) (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_19758 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (complete_distrib_lattice.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} empty))  := sorry --non-trivial
lemma new_lemma_19759 (h0 : topological_space (has_div (has_compl enat))) : t0_space (has_div (has_compl enat)) := sorry --non-trivial
lemma new_lemma_19760 (h0 : ring (cancel_monoid num)) : rank_condition (cancel_monoid num) := sorry --non-trivial
lemma new_lemma_19761 (h0 : functor.add_const (ring (complete_distrib_lattice linarith.comp)) (has_neg (ordered_ring pos))) : @strong_rank_condition.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (complete_distrib_lattice.{0} linarith.comp)) (has_neg.{0} (ordered_ring.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_19762 (h0 : topological_space (boolean_algebra.core (finset (has_add name)))) : t0_space (boolean_algebra.core (finset (has_add name))) := sorry --non-trivial
lemma new_lemma_19763 (h0 : functor.add_const (topological_space (ring Type)) linarith.comp) : @discrete_topology.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ring.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_19764 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (comm_group.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_group.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_19765 (h0 : ordered_add_comm_monoid (semigroup (option congr_arg_kind))) : archimedean (semigroup (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_19766 (h0 : topological_space ereal) : regular_space ereal := sorry --non-trivial
lemma new_lemma_19767 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (measurable_space.dynkin_system.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measurable_space.dynkin_system.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_19768 (h0 : topological_space (id (has_nnnorm fun_info))) : locally_compact_space (id (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_19769 (h0 : topological_space (add_left_cancel_monoid (has_nnnorm (has_nnnorm char)))) : totally_disconnected_space (add_left_cancel_monoid (has_nnnorm (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_19770 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (left_cancel_semigroup.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (left_cancel_semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_19771 (h0 : group (sub_neg_monoid (has_add real))) : is_cyclic (sub_neg_monoid (has_add real)) := sorry --non-trivial
lemma new_lemma_19772 (h0 : complete_lattice (finset (boolean_algebra Type))) : complete_lattice.is_Sup_finite_compact (finset (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_19773 (h0 : option Type) (h1 : topological_space (option.get_or_else h0 ennreal)) : regular_space (option.get_or_else h0 ennreal) := sorry --non-trivial
lemma new_lemma_19774 (h0 : group (semiring (has_top (has_top fun_info)))) : normalizer_condition (semiring (has_top (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_19775 (h0 : topological_space (add_cancel_monoid (has_to_string Type))) : preirreducible_space (add_cancel_monoid (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_19776 (h0 : topological_space (has_one (has_norm (has_norm fun_info)))) : normal_space (has_one (has_norm (has_norm fun_info))) := sorry --non-trivial
lemma new_lemma_19777 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (finset num)) := sorry --non-trivial
lemma new_lemma_19778 (h0 : functor.add_const (topological_space (finset Type)) linarith.comp) : @loc_path_connected_space.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (finset.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_19779 (h0 : topological_space (boolean_algebra (has_add (has_add (finset pos))))) : irreducible_space (boolean_algebra (has_add (has_add (finset pos)))) := sorry --non-trivial
lemma new_lemma_19780 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (has_sub.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (has_sub.{0} empty))  := sorry --non-trivial
lemma new_lemma_19781 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} fun_info (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) fun_info)  := sorry --non-trivial
lemma new_lemma_19782 (h0 : topological_space (has_norm (semiring (semiring empty)))) : normal_space (has_norm (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_19783 (h0 : topological_space (boolean_algebra Type)) : locally_compact_space (boolean_algebra Type) := sorry --non-trivial
lemma new_lemma_19784 (h0 : topological_space (has_pos_part name)) : normal_space (has_pos_part name) := sorry --non-trivial
lemma new_lemma_19785 (h0 : semiring (has_edist unsigned)) : is_noetherian_ring (has_edist unsigned) := sorry --non-trivial
lemma new_lemma_19786 (h0 : not (complete_lattice (comm_ring char) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (comm_ring.{0} char) (@classical.by_contradiction'.{1} (complete_lattice.{0} (comm_ring.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_19787 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (has_neg empty)) := sorry --non-trivial
lemma new_lemma_19788 (h0 : topological_space (sub_neg_monoid (has_neg (has_neg pos)))) : regular_space (sub_neg_monoid (has_neg (has_neg pos))) := sorry --non-trivial
lemma new_lemma_19789 (h0 : topological_space (measurable_space.dynkin_system num)) : t1_space (measurable_space.dynkin_system num) := sorry --non-trivial
lemma new_lemma_19790 (h0 : functor.add_const (functor.add_const (uniform_space Type) linarith.comp) Type) : @separated_space.{1} Type (@functor.add_const.run.{1 0} (uniform_space.{1} Type) linarith.comp (@functor.add_const.run.{1 1} (functor.add_const.{1 0} (uniform_space.{1} Type) linarith.comp) Type h0))  := sorry --non-trivial
lemma new_lemma_19791 (h0 : complete_lattice (add_comm_monoid ennreal)) : is_atomistic (add_comm_monoid ennreal) := sorry --non-trivial
lemma new_lemma_19792 (h0 : topological_space (ordered_comm_monoid (ordered_comm_ring Type))) : preconnected_space (ordered_comm_monoid (ordered_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_19793 (h0 : topological_space (option (semiring (semiring num)))) : preirreducible_space (option (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_19794 (h0 : functor.add_const (topological_space (normed_comm_ring pos)) (finset Type)) : @normal_space.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (normed_comm_ring.{0} pos)) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_19795 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (has_top.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_top.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_19796 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (canonically_ordered_comm_semiring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} pos))  := sorry --non-trivial
lemma new_lemma_19797 (h0 : set (normed_field (mul_one_class enat))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_19798 (h0 : list (has_nndist Type)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_19799 (h0 : fin has_zero.zero) : @normalizer_condition.{1} (canonically_linear_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (group.{1} (canonically_linear_ordered_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_19800 (h0 : not (topological_space (id unsigned) -> false)) : @normal_space.{0} (@id.{2} Type unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (@id.{2} Type unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_19801 (h0 : group (has_neg_part pos)) : is_simple_group (has_neg_part pos) := sorry --non-trivial
lemma new_lemma_19802 (h0 : filter (metric_space linarith.comp_source)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_19803 (h0 : functor.add_const (topological_space (non_assoc_semiring congr_arg_kind)) unsigned) : @t0_space.{0} (non_assoc_semiring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (non_assoc_semiring.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_19804 (h1 : uniform_space (semi_normed_ring reducibility_hints)) : complete_space (semi_normed_ring reducibility_hints) := sorry --non-trivial
lemma new_lemma_19805 (h0 : topological_space (has_add (has_neg (has_add linarith.comp)))) : totally_separated_space (has_add (has_neg (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_19806 (h1 : list (topological_space (has_emptyc linarith.ineq))) : @path_connected_space.{0} (has_emptyc.{0} linarith.ineq) (@list.head.{0} (topological_space.{0} (has_emptyc.{0} linarith.ineq)) (@inhabited_topological_space.{0} (has_emptyc.{0} linarith.ineq)) h1)  := sorry --non-trivial
lemma new_lemma_19807 (h0 : function.extfun Type group) : @is_cyclic.{0} (ordered_ring.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (ordered_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_19808 (h0 : functor.add_const (group (has_neg linarith.comp)) linarith.comp) : @is_simple_group.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (has_neg.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_19809 (h0 : monoid (mul_zero_class (semiring num))) : monoid.fg (mul_zero_class (semiring num)) := sorry --non-trivial
lemma new_lemma_19810 (h3 : complete_lattice (add_left_cancel_monoid to_additive.value_type)) : complete_lattice.is_Sup_finite_compact (add_left_cancel_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_19811 (h0 : functor.add_const (topological_space (boolean_algebra Type)) Type) : @preconnected_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (boolean_algebra.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_19812 (h0 : complete_lattice (normed_comm_ring pos)) : is_compactly_generated (normed_comm_ring pos) := sorry --non-trivial
lemma new_lemma_19813 (h0 : uniform_space (finset (has_add name))) (h1 : add_group (finset (has_add name))) : uniform_add_group (finset (has_add name)) := sorry --non-trivial
lemma new_lemma_19814 (h0 : list (complete_distrib_lattice (semigroup Type))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_19815 (h0 : topological_space (linear_ordered_field (cancel_monoid pos))) : discrete_topology (linear_ordered_field (cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_19816 (h0 : ring (sub_neg_monoid (has_neg name))) : rank_condition (sub_neg_monoid (has_neg name)) := sorry --non-trivial
lemma new_lemma_19817 (h0 : list (complete_linear_order unsigned)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_19818 (h0 : functor.add_const (topological_space (add_cancel_monoid name)) Type) : @topological_space.separable_space.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (add_cancel_monoid.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_19819 (h0 : ring (has_dist (option empty))) : rank_condition (has_dist (option empty)) := sorry --non-trivial
lemma new_lemma_19820 (h1 : topological_space (has_nnnorm reducibility_hints)) : totally_disconnected_space (has_nnnorm reducibility_hints) := sorry --non-trivial
lemma new_lemma_19821 (h0 : topological_space (linear_ordered_comm_ring empty)) : t0_space (linear_ordered_comm_ring empty) := sorry --non-trivial
lemma new_lemma_19822 (h0 : topological_space (has_top linarith.ineq)) : path_connected_space (has_top linarith.ineq) := sorry --non-trivial
lemma new_lemma_19823 (h0 : finset (linear_ordered_comm_ring num)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_19824 (h0 : function.extfun nat fin) : @archimedean.{0} (canonically_ordered_monoid.{0} real) (@matrix.vec_empty.{0} (ordered_add_comm_monoid.{0} (canonically_ordered_monoid.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_19825 (h0 : uniform_space (add_comm_monoid (has_add linarith.comp))) : complete_space (add_comm_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_19826 (h0 : group (comm_ring (random_gen to_additive.value_type))) : is_cyclic (comm_ring (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_19827 (h3 : uniform_space (distrib char)) : complete_space (distrib char) := sorry --non-trivial
lemma new_lemma_19828 (h0 : ring (ordered_comm_ring Type)) : strong_rank_condition (ordered_comm_ring Type) := sorry --non-trivial
lemma new_lemma_19829 (h0 : not (function.extfun Type topological_space -> false)) : @irreducible_space.{0} (measurable_space.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (measurable_space.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_19830 (h0 : functor.add_const (finset (has_neg_part unsigned)) pos) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_19831 (h0 : topological_space (left_cancel_monoid empty)) : t1_space (left_cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_19832 (h0 : topological_space (normed_comm_ring (add_comm_monoid Type))) : discrete_topology (normed_comm_ring (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_19833 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @irreducible_space.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_19834 (h0 : topological_space (has_top (has_nnnorm (random_gen string_imp)))) : t0_space (has_top (has_nnnorm (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_19835 (h0 : add_monoid (has_zero ennreal)) : add_monoid.fg (has_zero ennreal) := sorry --non-trivial
lemma new_lemma_19836 (h1 : ring (semi_normed_ring (random_gen char))) : strong_rank_condition (semi_normed_ring (random_gen char)) := sorry --non-trivial
lemma new_lemma_19837 (h0 : functor.add_const (semiring (has_add unsigned)) unsigned) : @is_noetherian_ring.{0} (has_add.{0} unsigned) (@functor.add_const.run.{0 0} (semiring.{0} (has_add.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_19838 (h0 : set (semi_normed_ring (mul_one_class string.iterator_imp))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_19839 (h0 : topological_space (has_neg Type)) : t0_space (has_neg Type) := sorry --non-trivial
lemma new_lemma_19840 (h0 : topological_space (canonically_linear_ordered_monoid (option (option ennreal)))) : t0_space (canonically_linear_ordered_monoid (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_19841 (h0 : functor.add_const (uniform_space (has_neg linarith.comp)) name) : @complete_space.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_neg.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_19842 (h0 : topological_space (mul_zero_class pos)) : totally_separated_space (mul_zero_class pos) := sorry --non-trivial
lemma new_lemma_19843 (h0 : functor.add_const (functor.add_const (cancel_comm_monoid_with_zero Type) name) name) : @unique_factorization_monoid.{1} Type (@functor.add_const.run.{1 0} (cancel_comm_monoid_with_zero.{1} Type) name (@functor.add_const.run.{1 0} (functor.add_const.{1 0} (cancel_comm_monoid_with_zero.{1} Type) name) name h0))  := sorry --non-trivial
lemma new_lemma_19844 (h0 : topological_space (has_add (option unsigned))) : discrete_topology (has_add (option unsigned)) := sorry --non-trivial
lemma new_lemma_19845 (h0 : functor.add_const (ring (boolean_algebra real)) linarith.comp) : @rank_condition.{0} (boolean_algebra.{0} real) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.{0} real)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_19846 (h0 : pfun (mul_one_class (add_comm_semigroup (mul_one_class ereal))) Prop) (h1 : coe_sort (pfun.dom h0)) : pfun.as_subtype h0 h1 := sorry --non-trivial
lemma new_lemma_19847 (h0 : functor.add_const (group (semigroup pos)) Type) : @normalizer_condition.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (semigroup.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_19848 (h0 : functor.add_const (complete_lattice (has_pos_part pos)) linarith.comp) : @complete_lattice.is_Sup_finite_compact.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_pos_part.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_19849 (h0 : not (group (dlist linarith.comp_source) -> false)) : @group.fg.{0} (dlist.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (group.{0} (dlist.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_19850 (h0 : ring (sub_neg_monoid (has_neg (has_neg Type)))) : strong_rank_condition (sub_neg_monoid (has_neg (has_neg Type))) := sorry --non-trivial
lemma new_lemma_19851 (h0 : function.extfun Type group) : @is_simple_group.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (normed_comm_ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_19852 (h0 : add_group (canonically_ordered_comm_semiring (has_nndist pos))) : is_add_cyclic (canonically_ordered_comm_semiring (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_19853 (h0 : list (normed_comm_ring (option (option (option (option (option ennreal))))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_19854 (h0 : finset (complete_distrib_lattice (has_add Type))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_19855 (h0 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} (has_emptyc.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h0) (has_emptyc.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_19856 (h0 : topological_space (free_add_monoid unsigned)) : loc_path_connected_space (free_add_monoid unsigned) := sorry --non-trivial
lemma new_lemma_19857 (h0 : group (finset (boolean_algebra (boolean_algebra name)))) : group.fg (finset (boolean_algebra (boolean_algebra name))) := sorry --non-trivial
lemma new_lemma_19858 (h0 : functor.add_const (ring (generalized_boolean_algebra linarith.comp)) Type) : @rank_condition.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 1} (ring.{0} (generalized_boolean_algebra.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_19859 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (bin_tree num)) := sorry --non-trivial
lemma new_lemma_19860 (h0 : ordered_add_comm_monoid (has_zero (has_neg (has_neg (has_neg (measurable_space linarith.comp)))))) : archimedean (has_zero (has_neg (has_neg (has_neg (measurable_space linarith.comp))))) := sorry --non-trivial
lemma new_lemma_19861 (h0 : fin has_zero.zero) : @separated_space.{1} (has_bot.{1} Type) (@matrix.vec_empty.{1} (uniform_space.{1} (has_bot.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_19862 (h0 : function.extfun (finset Type) (has_mem.mem (linear_ordered_add_comm_group num))) : @complete_space.{0} (linear_ordered_add_comm_group.{0} num) (@finset.pi.empty.{1 0} Type uniform_space.{0} (linear_ordered_add_comm_group.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (linear_ordered_add_comm_group.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_19863 (h0 : ring (mul_zero_class (semiring (semiring congr_arg_kind)))) : is_principal_ideal_ring (mul_zero_class (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_19864 (h0 : functor.add_const (ordered_add_comm_monoid (ring Type)) Type) : @archimedean.{1} (ring.{1} Type) (@functor.add_const.run.{1 1} (ordered_add_comm_monoid.{1} (ring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_19865 (h0 : not (has_mem.mem (linear_ordered_add_comm_group fun_info) has_emptyc.emptyc -> false)) : @locally_compact_space.{0} (linear_ordered_add_comm_group.{0} fun_info) (@finset.pi.empty.{1 0} Type topological_space.{0} (linear_ordered_add_comm_group.{0} fun_info) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (linear_ordered_add_comm_group.{0} fun_info) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_19866 (h0 : function.extfun Type (functor.add_const Prop)) : functor.add_const.run (function.extfun_app h0 (has_add name)) := sorry --non-trivial
lemma new_lemma_19867 (h0 : ring (non_assoc_semiring unsigned)) : rank_condition (non_assoc_semiring unsigned) := sorry --non-trivial
lemma new_lemma_19868 (h0 : functor.add_const (add_group (has_neg linarith.comp)) (ring (ring Type))) : @is_add_cyclic.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 1} (add_group.{0} (has_neg.{0} linarith.comp)) (ring.{1} (ring.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_19869 (h0 : functor.add_const (function.extfun Type topological_space) environment.implicit_infer_kind) : @irreducible_space.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) environment.implicit_infer_kind h0) (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_19870 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (has_Sup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Sup.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (has_Sup.{0} empty))) (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 (functor.add_const.{0 0} (topological_space.{0} (has_Sup.{0} empty)))) empty))  := sorry --non-trivial
lemma new_lemma_19871 (h0 : ring (has_to_string (canonically_linear_ordered_monoid name))) : is_principal_ideal_ring (has_to_string (canonically_linear_ordered_monoid name)) := sorry --non-trivial
lemma new_lemma_19872 (h0 : not (topological_space (linear_ordered_comm_ring num) -> false)) : @discrete_topology.{0} (linear_ordered_comm_ring.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_comm_ring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_19873 (h0 : group (has_ssubset (has_nnnorm (has_top (has_top fun_info))))) : group.fg (has_ssubset (has_nnnorm (has_top (has_top fun_info)))) := sorry --non-trivial
lemma new_lemma_19874 (h0 : not (topological_space (uniform_space fun_info) -> false)) : @t0_space.{0} (uniform_space.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (uniform_space.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_19875 (h0 : topological_space (has_neg_part (has_nndist (has_add name)))) : t0_space (has_neg_part (has_nndist (has_add name))) := sorry --non-trivial
lemma new_lemma_19876 (h0 : complete_lattice (has_neg (has_add (finset (has_add (has_neg Type)))))) : complete_lattice.is_Sup_finite_compact (has_neg (has_add (finset (has_add (has_neg Type))))) := sorry --non-trivial
lemma new_lemma_19877 (h0 : function.extfun (Type 1) ring) : @is_principal_ideal_ring.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_19878 (h0 : functor.add_const (topological_space (normed_comm_ring environment.implicit_infer_kind)) Type) : @t1_space.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (normed_comm_ring.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_19879 (h0 : not (group (normed_group linarith.ineq) -> false)) : @is_cyclic.{0} (normed_group.{0} linarith.ineq) (@classical.by_contradiction'.{1} (group.{0} (normed_group.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_19880 (h0 : fin has_zero.zero) : @sequential_space.{0} (comm_semigroup.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (comm_semigroup.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_19881 (h0 : complete_lattice (pseudo_metric_space unsigned)) : is_atomistic (pseudo_metric_space unsigned) := sorry --non-trivial
lemma new_lemma_19882 (h0 : not (complete_lattice (partial_order congr_arg_kind) -> false)) : @is_compactly_generated.{0} (partial_order.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (complete_lattice.{0} (partial_order.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_19883 (h0 : group (has_nndist (ring (ring (ring linarith.comp))))) : group.fg (has_nndist (ring (ring (ring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_19884 (h0 : topological_space (has_bot pos)) : discrete_topology (has_bot pos) := sorry --non-trivial
lemma new_lemma_19885 (h0 : topological_space (simple_graph (finset Type))) : totally_separated_space (simple_graph (finset Type)) := sorry --non-trivial
lemma new_lemma_19886 (h0 : list (boolean_algebra (normed_comm_ring environment.implicit_infer_kind))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_19887 (h0 : topological_space (ordered_cancel_add_comm_monoid unsigned)) : path_connected_space (ordered_cancel_add_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_19888 (h0 : topological_space (has_neg (cancel_monoid (has_add (add_comm_monoid (cancel_monoid Type)))))) : irreducible_space (has_neg (cancel_monoid (has_add (add_comm_monoid (cancel_monoid Type))))) := sorry --non-trivial
lemma new_lemma_19889 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (linear_ordered_field.{0} ennreal) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (linear_ordered_field.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_19890 (h0 : semiring (has_nndist (option empty))) : is_noetherian_ring (has_nndist (option empty)) := sorry --non-trivial
lemma new_lemma_19891 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (random_gen.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (random_gen.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_19892 (h1 : topological_space (random_gen (with_bot linarith.comp_source))) : totally_separated_space (random_gen (with_bot linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_19893 (h1 : topological_space (has_norm (distrib_lattice (has_norm to_additive.value_type)))) : path_connected_space (has_norm (distrib_lattice (has_norm to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_19894 (h0 : topological_space (cancel_monoid unsigned)) : discrete_topology (cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_19895 (h0 : topological_space (boolean_algebra (has_Inf (has_Inf Type)))) : regular_space (boolean_algebra (has_Inf (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_19896 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} auto.case_option (@function.extfun_app.{2 1} Type topological_space.{0} h0 auto.case_option)  := sorry --non-trivial
lemma new_lemma_19897 (h0 : group (add_group (semiring (semiring (semiring num))))) : normalizer_condition (add_group (semiring (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_19898 (h0 : uniform_space (ordered_comm_ring (sub_neg_monoid name))) : separated_space (ordered_comm_ring (sub_neg_monoid name)) := sorry --non-trivial
lemma new_lemma_19899 (h0 : functor.add_const (function.extfun Type semiring) linarith.comp) : @is_noetherian_ring.{0} (normed_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type semiring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type semiring.{0}) linarith.comp h0) (normed_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_19900 (h0 : group (has_neg (cancel_monoid ennreal))) : normalizer_condition (has_neg (cancel_monoid ennreal)) := sorry --non-trivial
lemma new_lemma_19901 (h0 : group (finset (has_add (has_add name)))) : normalizer_condition (finset (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_19902 (h0 : functor.add_const (topological_space (complete_distrib_lattice pos)) name) : @locally_compact_space.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_19903 (h0 : function.extfun Type (prod unsigned)) : id_rel (function.extfun_app h0 unsigned) := sorry --non-trivial
lemma new_lemma_19904 (h0 : function.extfun Type ring) : @is_domain.{0} (has_top.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_top.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_19905 (h0 : topological_space (measurable_space.dynkin_system (has_top (has_top empty)))) : totally_disconnected_space (measurable_space.dynkin_system (has_top (has_top empty))) := sorry --non-trivial
lemma new_lemma_19906 (h0 : to_additive.value_type -> random_gen string_imp -> Prop) : relator.right_total h0 := sorry --non-trivial
lemma new_lemma_19907 (h0 : functor.add_const (ring (complete_distrib_lattice unsigned)) name) : @is_principal_ideal_ring.{0} (complete_distrib_lattice.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (complete_distrib_lattice.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_19908 (h0 : complete_lattice (encodable (has_nnnorm fun_info))) : complete_lattice.is_Sup_finite_compact (encodable (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_19909 (h0 : topological_space (finset (has_neg_part pos))) : discrete_topology (finset (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_19910 (h0 : topological_space (has_add (ring (add_left_cancel_monoid (finset Type))))) : preconnected_space (has_add (ring (add_left_cancel_monoid (finset Type)))) := sorry --non-trivial
lemma new_lemma_19911 (h0 : add_group (has_top (comm_ring linarith.comp_source))) : is_add_cyclic (has_top (comm_ring linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_19912 (h1 : ring (has_append (random_gen to_additive.value_type))) : strong_rank_condition (has_append (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_19913 (h0 : group (sub_neg_monoid real)) : normalizer_condition (sub_neg_monoid real) := sorry --non-trivial
lemma new_lemma_19914 (h0 : topological_space nnreal) : totally_separated_space nnreal := sorry --non-trivial
lemma new_lemma_19915 (h0 : functor.add_const (functor.add_const (uniform_space (mul_zero_class empty)) empty) empty) : @separated_space.{0} (mul_zero_class.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (mul_zero_class.{0} empty)) empty (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (uniform_space.{0} (mul_zero_class.{0} empty)) empty) empty h0))  := sorry --non-trivial
lemma new_lemma_19916 (h0 : functor.add_const (monoid (has_to_string unsigned)) name) : @monoid.fg.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 0} (monoid.{0} (has_to_string.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_19917 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} (semiring.{0} (random_gen.{0} to_additive.value_type)) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (semiring.{0} (random_gen.{0} to_additive.value_type)))  := sorry --non-trivial
lemma new_lemma_19918 (h0 : topological_space (free_add_monoid (semiring empty))) : totally_separated_space (free_add_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_19919 (h1 : topological_space (dlist fun_info)) : totally_disconnected_space (dlist fun_info) := sorry --non-trivial
lemma new_lemma_19920 (h0 : group (complete_distrib_lattice (has_Inf real))) : group.fg (complete_distrib_lattice (has_Inf real)) := sorry --non-trivial
lemma new_lemma_19921 (h0 : group (pseudo_metric_space (option (option empty)))) : is_cyclic (pseudo_metric_space (option (option empty))) := sorry --non-trivial
lemma new_lemma_19922 (h0 : ring (measure_theory.measure_space (has_top num))) : strong_rank_condition (measure_theory.measure_space (has_top num)) := sorry --non-trivial
lemma new_lemma_19923 (h0 : list nat) : nat.prime (list.head h0) := sorry --non-trivial
lemma new_lemma_19924 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (option.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (option.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_19925 (h0 : has_mem.mem (has_one linarith.comp) has_emptyc.emptyc) : @rank_condition.{0} (has_one.{0} linarith.comp) (@finset.pi.empty.{1 0} Type ring.{0} (has_one.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_19926 (h0 : functor.add_const (finset (simple_graph Type)) pos) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_19927 (h0 : function.extfun Type uniform_space) : @separated_space.{0} ordering (@function.extfun_app.{2 1} Type uniform_space.{0} h0 ordering)  := sorry --non-trivial
lemma new_lemma_19928 (h6 : not (filter (random_gen fun_info) -> false)) : filter.ne_bot (classical.by_contradiction' h6) := sorry --non-trivial
lemma new_lemma_19929 (h0 : Type -> Type -> Prop) : is_per Type h0 := sorry --non-trivial
lemma new_lemma_19930 (h0 : fin has_zero.zero) : @rank_condition.{0} (canonically_ordered_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (ring.{0} (canonically_ordered_monoid.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_19931 (h0 : linarith.ineq -> Prop) : zzz_forall h0 := sorry --non-trivial
lemma new_lemma_19932 (h0 : add_group string.iterator) : is_add_cyclic string.iterator := sorry --non-trivial
lemma new_lemma_19933 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (has_neg (option empty))) := sorry --non-trivial
lemma new_lemma_19934 (h1 : add_group (with_one (with_bot string_imp))) : is_add_cyclic (with_one (with_bot string_imp)) := sorry --non-trivial
lemma new_lemma_19935 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (linear_ordered_add_comm_group linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_19936 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @locally_compact_space.{0} (measurable_space.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) topological_space.{0}) (measurable_space.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_19937 (h0 : functor.comp topological_space normed_comm_ring name) : @preconnected_space.{0} (normed_comm_ring.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} normed_comm_ring.{0} name h0)  := sorry --non-trivial
lemma new_lemma_19938 (h0 : topological_space (has_neg (has_add pos))) : totally_separated_space (has_neg (has_add pos)) := sorry --non-trivial
lemma new_lemma_19939 (h0 : topological_space (has_to_string ennreal)) : loc_path_connected_space (has_to_string ennreal) := sorry --non-trivial
lemma new_lemma_19940 (h0 : topological_space (has_nndist (option (option (option unsigned))))) : loc_path_connected_space (has_nndist (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_19941 (h0 : ordered_comm_monoid (boolean_algebra (has_pos_part (finset linarith.comp)))) : has_exists_mul_of_le (boolean_algebra (has_pos_part (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_19942 (h0 : group (normed_comm_ring unsigned)) : is_cyclic (normed_comm_ring unsigned) := sorry --non-trivial
lemma new_lemma_19943 (h0 : functor.add_const (uniform_space (has_neg linarith.comp)) pos) : @separated_space.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_neg.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_19944 (h0 : ordered_add_comm_monoid (ordered_comm_ring (has_neg Type))) : archimedean (ordered_comm_ring (has_neg Type)) := sorry --non-trivial
lemma new_lemma_19945 (h0 : topological_space (has_union congr_arg_kind)) : totally_separated_space (has_union congr_arg_kind) := sorry --non-trivial
lemma new_lemma_19946 (h0 : functor.add_const (function.extfun Type ring) pos) : @rank_condition.{0} (add_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) pos h0) (add_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_19947 (h0 : set (linear_ordered_semiring to_additive.value_type)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_19948 (h0 : topological_space (has_one (semiring (has_norm empty)))) : normal_space (has_one (semiring (has_norm empty))) := sorry --non-trivial
lemma new_lemma_19949 (h0 : function.extfun Type (functor.add_const (complete_lattice name))) : @complete_lattice.is_Sup_finite_compact.{0} name (@functor.add_const.run.{0 0} (complete_lattice.{0} name) name (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (complete_lattice.{0} name)) h0 name))  := sorry --non-trivial
lemma new_lemma_19950 (h0 : topological_space (normed_group (random_gen linarith.ineq))) : t0_space (normed_group (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_19951 (h0 : function.extfun Type topological_space) : @t1_space.{0} (group_with_zero.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (group_with_zero.{0} num))  := sorry --non-trivial
lemma new_lemma_19952 (h0 : functor.add_const (function.extfun Type list) (has_pos_part (has_Inf (metric_space linarith.comp)))) : list.nodup (function.extfun_app (functor.add_const.run h0) (has_add pos)) := sorry --non-trivial
lemma new_lemma_19953 (h0 : ring (semi_normed_ring fun_info)) : rank_condition (semi_normed_ring fun_info) := sorry --non-trivial
lemma new_lemma_19954 (h0 : topological_space (add_comm_monoid name)) : t1_space (add_comm_monoid name) := sorry --non-trivial
lemma new_lemma_19955 (h1 : add_group (id (random_gen string_imp))) : is_add_cyclic (id (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_19956 (h0 : functor.add_const (topological_space (cancel_monoid Type)) name) : @topological_space.separable_space.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (cancel_monoid.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_19957 (h0 : fin has_zero.zero) : @is_add_cyclic.{1} (generalized_boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (add_group.{1} (generalized_boolean_algebra.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_19958 (h0 : group (boolean_algebra.core (option Type))) : normalizer_condition (boolean_algebra.core (option Type)) := sorry --non-trivial
lemma new_lemma_19959 (h0 : topological_space (ordered_cancel_add_comm_monoid (option (option (option (option unsigned)))))) : preconnected_space (ordered_cancel_add_comm_monoid (option (option (option (option unsigned))))) := sorry --non-trivial
lemma new_lemma_19960 (h0 : topological_space (has_Inf (has_add (has_add linarith.comp)))) : t1_space (has_Inf (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_19961 (h0 : uniform_space (has_inter ennreal)) : separated_space (has_inter ennreal) := sorry --non-trivial
lemma new_lemma_19962 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (linear_ordered_add_comm_group.{0} char) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (linear_ordered_add_comm_group.{0} char))  := sorry --non-trivial
lemma new_lemma_19963 (h1 : topological_space (fintype fun_info)) : t0_space (fintype fun_info) := sorry --non-trivial
lemma new_lemma_19964 (h0 : cancel_comm_monoid_with_zero (has_zero (finset Type))) : unique_factorization_monoid (has_zero (finset Type)) := sorry --non-trivial
lemma new_lemma_19965 (h0 : complete_lattice (has_neg_part empty)) : is_atomistic (has_neg_part empty) := sorry --non-trivial
lemma new_lemma_19966 (h0 : add_group (add_comm_semigroup (add_comm_semigroup ereal))) : is_add_cyclic (add_comm_semigroup (add_comm_semigroup ereal)) := sorry --non-trivial
lemma new_lemma_19967 (h0 : ring (uniform_space char)) : rank_condition (uniform_space char) := sorry --non-trivial
lemma new_lemma_19968 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (measurable_space.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (measurable_space.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_19969 (h0 : topological_space (semiring (has_top congr_arg_kind))) : discrete_topology (semiring (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_19970 (h0 : uniform_space (has_compl (mul_one_class linarith.ineq))) : complete_space (has_compl (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_19971 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (add_group.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} h0 (add_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_19972 (h0 : not (group (has_sub unsigned) -> false)) : @is_cyclic.{0} (has_sub.{0} unsigned) (@classical.by_contradiction'.{1} (group.{0} (has_sub.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_19973 (h1 : complete_lattice (encodable (linear_ordered_add_comm_group char))) : complete_lattice.is_Sup_finite_compact (encodable (linear_ordered_add_comm_group char)) := sorry --non-trivial
lemma new_lemma_19974 (h0 : ring (ordered_comm_ring (has_add (canonically_linear_ordered_monoid Type)))) : strong_rank_condition (ordered_comm_ring (has_add (canonically_linear_ordered_monoid Type))) := sorry --non-trivial
lemma new_lemma_19975 (h0 : functor.add_const (group (has_to_string linarith.comp)) pos) : @group.fg.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (has_to_string.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_19976 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @t0_space.{0} fun_info (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) fun_info)  := sorry --non-trivial
lemma new_lemma_19977 (h0 : ring (add_cancel_monoid (option ennreal))) : is_domain (add_cancel_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_19978 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (has_emptyc.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 topological_space.{0}) (has_emptyc.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_19979 (h1 : topological_space (distrib (random_gen to_additive.value_type))) : totally_disconnected_space (distrib (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_19980 (h0 : filter (sub_neg_monoid pos)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_19981 (h0 : function.extfun Type group) : @is_cyclic.{0} (canonically_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type group.{0} h0 (canonically_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_19982 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (omega_complete_partial_order.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (omega_complete_partial_order.{0} num))  := sorry --non-trivial
lemma new_lemma_19983 (h0 : ring (has_zero (has_to_string (has_to_string name)))) : is_principal_ideal_ring (has_zero (has_to_string (has_to_string name))) := sorry --non-trivial
lemma new_lemma_19984 (h0 : functor.add_const (filter (has_add linarith.comp)) Type) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_19985 (h0 : has_mem.mem (semiring (has_norm (has_norm congr_arg_kind))) has_emptyc.emptyc) : @monoid.fg.{0} (semiring.{0} (has_norm.{0} (has_norm.{0} congr_arg_kind))) (@finset.pi.empty.{1 0} Type monoid.{0} (semiring.{0} (has_norm.{0} (has_norm.{0} congr_arg_kind))) h0)  := sorry --non-trivial
lemma new_lemma_19986 (h0 : topological_space (linear_ordered_comm_group_with_zero linarith.ineq)) (h1 : preorder (linear_ordered_comm_group_with_zero linarith.ineq)) : order_closed_topology (linear_ordered_comm_group_with_zero linarith.ineq) := sorry --non-trivial
lemma new_lemma_19987 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (normed_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_19988 (h0 : group (add_group (has_norm empty))) : is_cyclic (add_group (has_norm empty)) := sorry --non-trivial
lemma new_lemma_19989 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_19990 (h0 : filter (normed_comm_ring (has_add linarith.comp))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_19991 (h0 : comm_ring (denumerable reducibility_hints) -> comm_ring (denumerable reducibility_hints) -> Prop) : is_total_preorder (comm_ring (denumerable reducibility_hints)) h0 := sorry --non-trivial
lemma new_lemma_19992 (h0 : ring (encodable (has_norm to_additive.value_type))) : rank_condition (encodable (has_norm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_19993 (h0 : add_monoid linarith.comp) : add_monoid.fg linarith.comp := sorry --non-trivial
lemma new_lemma_19994 (h0 : group (normed_group linarith.ineq)) : group.fg (normed_group linarith.ineq) := sorry --non-trivial
lemma new_lemma_19995 (h0 : topological_space (boolean_algebra (has_Inf pos))) : path_connected_space (boolean_algebra (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_19996 (h0 : not (ring (uniform_space reducibility_hints) -> false)) : @is_domain.{0} (uniform_space.{0} reducibility_hints) (@classical.by_contradiction'.{1} (ring.{0} (uniform_space.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_19997 (h0 : ulower Prop) : @id.{1} Prop (@ulower.up.{0} Prop encodable.Prop (@id.{1} (@ulower.{0} Prop encodable.Prop) (@id.{1} (@ulower.{0} Prop encodable.Prop) h0)))  := sorry --non-trivial
lemma new_lemma_19998 (h0 : uniform_space (semigroup (mul_one_class linarith.comp))) : complete_space (semigroup (mul_one_class linarith.comp)) := sorry --non-trivial
lemma new_lemma_19999 (h2 : set (ereal -> linarith.ineq)) : set.separates_points h2 := sorry --non-trivial
lemma new_lemma_20000 (h0 : not (ring (has_top num) -> false)) : @is_domain.{0} (has_top.{0} num) (@classical.by_contradiction'.{1} (ring.{0} (has_top.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_20001 (h0 : functor.add_const (function.extfun Type uniform_space) pos) : @separated_space.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) pos h0) (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_20002 (h0 : functor.add_const (add_group (has_add linarith.comp)) environment.implicit_infer_kind) : @is_add_cyclic.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_group.{0} (has_add.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_20003 (h0 : monoid (has_add (ring (ring environment.implicit_infer_kind)))) : monoid.fg (has_add (ring (ring environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_20004 (h0 : functor.add_const (topological_space pos) pos) : @t0_space.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) pos h0)  := sorry --non-trivial
lemma new_lemma_20005 (h0 : list (ring (option unsigned))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_20006 (h0 : functor.add_const (add_monoid (boolean_algebra linarith.comp)) Type) : @add_monoid.fg.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 1} (add_monoid.{0} (boolean_algebra.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_20007 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_20008 (h0 : set (mul_one_class (mul_one_class char) -> ereal)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_20009 (h0 : function.extfun Type has_norm) (h1 : has_mem.mem to_additive.value_type has_emptyc.emptyc) : @norm_one_class.{0} to_additive.value_type (@function.extfun_app.{2 1} Type has_norm.{0} h0 to_additive.value_type) (@finset.pi.empty.{1 0} Type has_one.{0} to_additive.value_type h1)  := sorry --non-trivial
lemma new_lemma_20010 (h0 : topological_space (add_comm_monoid (option unsigned))) : path_connected_space (add_comm_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_20011 (h0 : not (filter (semiring linarith.comp_source) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_20012 (h0 : complete_lattice (has_nndist (comm_group (comm_group (comm_group name))))) : is_compactly_generated (has_nndist (comm_group (comm_group (comm_group name)))) := sorry --non-trivial
lemma new_lemma_20013 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (ordered_ring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_ring.{0} num))  := sorry --non-trivial
lemma new_lemma_20014 (h0 : topological_space (linear_order empty)) : t0_space (linear_order empty) := sorry --non-trivial
lemma new_lemma_20015 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (add_right_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} h0 (add_right_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_20016 (h1 : complete_lattice (dlist char)) : complete_lattice.is_Sup_finite_compact (dlist char) := sorry --non-trivial
lemma new_lemma_20017 (h0 : topological_space (has_nndist (has_neg Type))) : totally_separated_space (has_nndist (has_neg Type)) := sorry --non-trivial
lemma new_lemma_20018 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @regular_space.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_20019 (h0 : topological_space (has_lt to_additive.value_type)) : path_connected_space (has_lt to_additive.value_type) := sorry --non-trivial
lemma new_lemma_20020 (h0 : complete_lattice (comm_monoid congr_arg_kind)) : is_atomistic (comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_20021 (h0 : filter (add_cancel_monoid (comm_group Type))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_20022 (h0 : ring (has_dist empty)) : is_principal_ideal_ring (has_dist empty) := sorry --non-trivial
lemma new_lemma_20023 (h0 : add_group (with_one (has_norm linarith.comp))) : is_add_cyclic (with_one (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_20024 (h0 : functor.add_const (uniform_space (ordered_comm_monoid pos)) (ring Type)) : @complete_space.{0} (ordered_comm_monoid.{0} pos) (@functor.add_const.run.{0 1} (uniform_space.{0} (ordered_comm_monoid.{0} pos)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_20025 (h0 : functor.add_const (function.extfun Type cancel_comm_monoid_with_zero) Type) : @unique_factorization_monoid.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type cancel_comm_monoid_with_zero.{0}) Type h0) (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_20026 (h0 : functor.add_const (function.extfun Type cancel_comm_monoid_with_zero) pos) : @unique_factorization_monoid.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type cancel_comm_monoid_with_zero.{0}) pos h0) (add_cancel_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_20027 (h0 : add_group (denumerable (random_gen (random_gen to_additive.value_type)))) : is_add_cyclic (denumerable (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_20028 (h0 : finset (has_to_string unsigned)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_20029 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (mul_zero_class.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (mul_zero_class.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_20030 (h0 : topological_space (has_Inf (has_neg (has_add linarith.comp)))) : path_connected_space (has_Inf (has_neg (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_20031 (h0 : function.extfun Type topological_space) : @regular_space.{0} (normed_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_20032 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring environment.implicit_infer_kind)) name) : @regular_space.{0} (canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_20033 (h0 : functor.add_const (topological_space (has_bot empty)) (option (option unsigned))) : @totally_separated_space.{0} (has_bot.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_bot.{0} empty)) (option.{0} (option.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_20034 (h0 : group (has_to_string (has_Inf linarith.comp))) : is_cyclic (has_to_string (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_20035 (h0 : functor.add_const (function.extfun Type topological_space) name) : @locally_compact_space.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_20036 (h0 : functor.add_const (complete_lattice (has_zero name)) Type) : @is_compactly_generated.{0} (has_zero.{0} name) (@functor.add_const.run.{0 1} (complete_lattice.{0} (has_zero.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_20037 (h2 : topological_space char) (h3 : set char) : is_path_connected h3 := sorry --non-trivial
lemma new_lemma_20038 (h0 : fin has_zero.zero) : @sequential_space.{1} (generalized_boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) (@matrix.vec_empty.{2} (function.extfun.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1))) h0) topological_space.{1}) (generalized_boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_20039 (h0 : functor.add_const (functor.add_const (finset linarith.comp) (finset linarith.comp)) Type) : finset.nonempty (functor.add_const.run (functor.add_const.run h0)) := sorry --non-trivial
lemma new_lemma_20040 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (semilattice_inf.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semilattice_inf.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_20041 (h0 : filter (linear_ordered_comm_monoid_with_zero (option (option (option (option (option (option empty)))))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_20042 (h1 : not (function.extfun Type ring -> false)) : @rank_condition.{0} (linear_ordered_semiring.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h1) (linear_ordered_semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_20043 (h0 : functor.add_const (filter (comm_group unsigned)) pos) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_20044 (h0 : ring (with_one (semiring unsigned))) : rank_condition (with_one (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_20045 (h0 : functor.add_const (function.extfun (Type 1) monoid) (add_comm_monoid Type)) : @monoid.fg.{1} (comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) monoid.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) monoid.{1}) (add_comm_monoid.{1} Type) h0) (comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_20046 (h0 : complete_lattice (semiring (semiring (semiring congr_arg_kind)))) : complete_lattice.is_Sup_finite_compact (semiring (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_20047 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (comm_group.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_group.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_20048 (h0 : topological_space (has_union unsigned)) : path_connected_space (has_union unsigned) := sorry --non-trivial
lemma new_lemma_20049 (h0 : functor.add_const (filter (has_nndist ennreal)) pos) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_20050 (h0 : uniform_space (pseudo_metric_space num)) : separated_space (pseudo_metric_space num) := sorry --non-trivial
lemma new_lemma_20051 (h1 : measurable_space (simple_graph std_gen)) (h2 : measure_theory.measure (simple_graph std_gen)) : measure_theory.is_finite_measure h2 := sorry --non-trivial
lemma new_lemma_20052 (h0 : ring (has_union num)) : strong_rank_condition (has_union num) := sorry --non-trivial
lemma new_lemma_20053 (h0 : topological_space (semigroup (boolean_algebra.core environment.implicit_infer_kind))) : loc_path_connected_space (semigroup (boolean_algebra.core environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_20054 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_neg_part.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_neg_part.{0} num))  := sorry --non-trivial
lemma new_lemma_20055 (h0 : finset (generalized_boolean_algebra (has_add pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_20056 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_add_cyclic.{1} (comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_group.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 add_group.{1}) (comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_20057 (h0 : topological_space (boolean_algebra (normed_comm_ring (has_add linarith.comp)))) : topological_space.separable_space (boolean_algebra (normed_comm_ring (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_20058 (h0 : functor.comp group normed_comm_ring environment.implicit_infer_kind) : @is_simple_group.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} group.{0} normed_comm_ring.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_20059 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (distrib_lattice string_imp)) := sorry --non-trivial
lemma new_lemma_20060 (h0 : has_mem.mem complete_lattice has_emptyc.emptyc) : @is_compactly_generated.{0} (metric_space.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} h0) (metric_space.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_20061 (h0 : topological_space (finset (ring (finset (complete_semilattice_Sup Type))))) : regular_space (finset (ring (finset (complete_semilattice_Sup Type)))) := sorry --non-trivial
lemma new_lemma_20062 (h0 : topological_space (plift (complete_distrib_lattice congr_arg_kind))) : t1_space (plift (complete_distrib_lattice congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_20063 (h0 : filter (complete_distrib_lattice (ring linarith.comp))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_20064 (h0 : topological_space (has_top (random_gen string_imp))) : locally_compact_space (has_top (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_20065 (h0 : complete_lattice (mul_zero_class (finset Type))) : is_atomistic (mul_zero_class (finset Type)) := sorry --non-trivial
lemma new_lemma_20066 (h0 : group (linear_ordered_field (has_to_string pos))) : group.fg (linear_ordered_field (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_20067 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (complete_distrib_lattice.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (complete_distrib_lattice.{0} pos))  := sorry --non-trivial
lemma new_lemma_20068 (h0 : monoid (boolean_algebra (has_add (add_cancel_monoid (semigroup name))))) : monoid.fg (boolean_algebra (has_add (add_cancel_monoid (semigroup name)))) := sorry --non-trivial
lemma new_lemma_20069 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type add_group.{0} h0 (cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_20070 (h0 : topological_space (has_to_string (has_add environment.implicit_infer_kind))) : t0_space (has_to_string (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_20071 (h0 : function.extfun Type ring) : @rank_condition.{0} name (@function.extfun_app.{2 1} Type ring.{0} h0 name)  := sorry --non-trivial
lemma new_lemma_20072 (h1 : complete_lattice (has_add char)) : is_compactly_generated (has_add char) := sorry --non-trivial
lemma new_lemma_20073 (h0 : filter (finset (has_add (has_add linarith.comp)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_20074 (h0 : not (complete_lattice (denumerable reducibility_hints) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (denumerable.{0} reducibility_hints) (@classical.by_contradiction'.{1} (complete_lattice.{0} (denumerable.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_20075 (h0 : add_monoid (option ennreal)) : add_monoid.fg (option ennreal) := sorry --non-trivial
lemma new_lemma_20076 (h0 : ring (add_cancel_monoid (has_pos_part (has_add (has_to_string (finset linarith.comp)))))) : is_domain (add_cancel_monoid (has_pos_part (has_add (has_to_string (finset linarith.comp))))) := sorry --non-trivial
lemma new_lemma_20077 (h0 : comm_ring (complete_semilattice_Sup string_imp) -> comm_ring (complete_semilattice_Sup string_imp) -> bool) : is_dec_refl h0 := sorry --non-trivial
lemma new_lemma_20078 (h0 : topological_space (ordered_cancel_add_comm_monoid pos)) : preirreducible_space (ordered_cancel_add_comm_monoid pos) := sorry --non-trivial
lemma new_lemma_20079 (h1 : topological_space (has_le environment.projection_info)) (h2 : preorder (has_le environment.projection_info)) : order_closed_topology (has_le environment.projection_info) := sorry --non-trivial
lemma new_lemma_20080 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (canonically_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_20081 (h0 : topological_space (has_one (has_top (semiring (linear_ordered_semiring (semiring empty)))))) : locally_compact_space (has_one (has_top (semiring (linear_ordered_semiring (semiring empty))))) := sorry --non-trivial
lemma new_lemma_20082 (h0 : filter (has_Inf (normed_comm_ring pos))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_20083 (h0 : functor.add_const (group (canonically_ordered_add_monoid empty)) unsigned) : @normalizer_condition.{0} (canonically_ordered_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (canonically_ordered_add_monoid.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_20084 (h0 : list (boolean_algebra.core (generalized_boolean_algebra (generalized_boolean_algebra Type)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_20085 (h1 h2 : multiset (uniform_space to_additive.value_type)) : multiset.disjoint h1 h2 := sorry --non-trivial
lemma new_lemma_20086 (h0 : function.extfun Type (functor.comp topological_space semigroup)) : @discrete_topology.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} environment.implicit_infer_kind (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} semigroup.{0}) h0 environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_20087 (h0 : topological_space (has_norm (random_gen (random_gen (random_gen linarith.ineq))))) : path_connected_space (has_norm (random_gen (random_gen (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_20088 (h0 : monoid (id (has_top num))) : monoid.fg (id (has_top num)) := sorry --non-trivial
lemma new_lemma_20089 (h0 : topological_space (random_gen (has_ssubset (has_ssubset char)))) : path_connected_space (random_gen (has_ssubset (has_ssubset char))) := sorry --non-trivial
lemma new_lemma_20090 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (add_monoid.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type add_group.{0} h0 (add_monoid.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_20091 (h0 : ring (has_nndist (has_add environment.implicit_infer_kind))) : is_principal_ideal_ring (has_nndist (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_20092 (h0 : semiring (normed_comm_ring (mul_one_class Type))) : is_noetherian_ring (normed_comm_ring (mul_one_class Type)) := sorry --non-trivial
lemma new_lemma_20093 (h0 : complete_lattice (add_cancel_monoid (has_neg (option num)))) : is_atomistic (add_cancel_monoid (has_neg (option num))) := sorry --non-trivial
lemma new_lemma_20094 (h0 : group (normed_linear_ordered_group num)) : is_cyclic (normed_linear_ordered_group num) := sorry --non-trivial
lemma new_lemma_20095 (h0 : ring (semi_normed_comm_ring (has_inv (random_gen linarith.ineq)))) : strong_rank_condition (semi_normed_comm_ring (has_inv (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_20096 (h0 : function.extfun (finset Type) (has_mem.mem (with_bot unsigned))) : @rank_condition.{0} (with_bot.{0} unsigned) (@finset.pi.empty.{1 0} Type ring.{0} (with_bot.{0} unsigned) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_bot.{0} unsigned)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_20097 (h0 : functor.add_const (functor.add_const Prop num) unsigned) : functor.add_const.run (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_20098 (h0 : semiring (ordered_comm_ring (has_bot (has_Inf real)))) : is_noetherian_ring (ordered_comm_ring (has_bot (has_Inf real))) := sorry --non-trivial
lemma new_lemma_20099 (h0 : not (monoid (has_emptyc empty) -> false)) : @monoid.fg.{0} (has_emptyc.{0} empty) (@classical.by_contradiction'.{1} (monoid.{0} (has_emptyc.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_20100 (h0 : topological_space (comm_monoid unsigned)) : discrete_topology (comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_20101 (h0 : complete_lattice (normed_comm_ring (has_neg (ring linarith.comp)))) : complete_lattice.is_Sup_finite_compact (normed_comm_ring (has_neg (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_20102 (h0 : prod name name) : id_rel h0 := sorry --non-trivial
lemma new_lemma_20103 (h0 : complete_lattice (has_one (semiring num))) : is_atomistic (has_one (semiring num)) := sorry --non-trivial
lemma new_lemma_20104 (h0 : ordered_add_comm_monoid (has_add (has_bot real))) : archimedean (has_add (has_bot real)) := sorry --non-trivial
lemma new_lemma_20105 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem monoid)) : @monoid.fg.{0} (random_gen.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type monoid.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) monoid.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) monoid.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (random_gen.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_20106 (h0 : complete_lattice (has_top (has_nnnorm to_additive.value_type))) : is_compactly_generated (has_top (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_20107 (h0 : function.extfun Type (functor.comp topological_space has_zero)) : @normal_space.{0} (has_zero.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} has_zero.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} has_zero.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_20108 (h0 : has_mem.mem (has_norm fun_info) has_emptyc.emptyc) : @rank_condition.{0} (has_norm.{0} fun_info) (@finset.pi.empty.{1 0} Type ring.{0} (has_norm.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_20109 (h0 : function.extfun Type ring) : @rank_condition.{0} (comm_ring.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} h0 (comm_ring.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_20110 (h0 : topological_space (linear_ordered_semiring (random_gen linarith.comp_source))) : irreducible_space (linear_ordered_semiring (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_20111 (h0 : functor.add_const (topological_space (normed_comm_ring pos)) (mul_one_class environment.implicit_infer_kind)) : @locally_compact_space.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} pos)) (mul_one_class.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_20112 (h0 : fin has_zero.zero) : @separated_space.{0} (finset.{0} name) (@matrix.vec_empty.{0} (uniform_space.{0} (finset.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_20113 (h0 : topological_space (pseudo_metric_space empty)) : t0_space (pseudo_metric_space empty) := sorry --non-trivial
lemma new_lemma_20114 (h0 : uniform_space (add_comm_monoid (has_add (has_add Type)))) : complete_space (add_comm_monoid (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_20115 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (option num)) := sorry --non-trivial
lemma new_lemma_20116 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @path_connected_space.{0} (metric_space.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (metric_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_20117 (h0 : functor.add_const (ring (has_neg pos)) name) : @is_domain.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_neg.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_20118 (h0 : topological_space (has_to_string (comm_group Type))) : loc_path_connected_space (has_to_string (comm_group Type)) := sorry --non-trivial
lemma new_lemma_20119 (h0 : ring (semigroup num)) : is_principal_ideal_ring (semigroup num) := sorry --non-trivial
lemma new_lemma_20120 (h1 : not (topological_space (has_norm linarith.comp) -> false)) : @t0_space.{0} (has_norm.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (has_norm.{0} linarith.comp)) h1)  := sorry --non-trivial
lemma new_lemma_20121 (h0 : add_monoid (preorder (semiring empty))) : add_monoid.fg (preorder (semiring empty)) := sorry --non-trivial
lemma new_lemma_20122 (h0 : functor.add_const (ring (has_neg name)) linarith.comp) : @is_domain.{0} (has_neg.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (has_neg.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_20123 (h0 : group (has_pos_part (has_pos_part real))) : normalizer_condition (has_pos_part (has_pos_part real)) := sorry --non-trivial
lemma new_lemma_20124 (h0 : ring (metric_space (semiring unsigned))) : is_domain (metric_space (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_20125 (h0 : group (comm_ring (has_nnnorm linarith.ineq))) : is_cyclic (comm_ring (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_20126 (h0 : functor.add_const (complete_lattice (has_to_string unsigned)) pos) : @complete_lattice.is_Sup_finite_compact.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_to_string.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_20127 (h0 : filter (has_zero (normed_comm_ring (add_cancel_monoid pos)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_20128 (h0 : function.extfun Type topological_space) : @t1_space.{0} (has_neg_part.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg_part.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_20129 (h0 : semiring (add_comm_semigroup string.iterator_imp)) (h1 : ideal (add_comm_semigroup string.iterator_imp)) : ideal.is_prime h1 := sorry --non-trivial
lemma new_lemma_20130 (h1 : uniform_space linarith.ineq) : complete_space linarith.ineq := sorry --non-trivial
lemma new_lemma_20131 (h0 : topological_space (div_inv_monoid string_imp)) : t0_space (div_inv_monoid string_imp) := sorry --non-trivial
lemma new_lemma_20132 (h0 : functor.add_const (topological_space (has_to_string Type)) environment.implicit_infer_kind) : @irreducible_space.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_to_string.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_20133 (h0 : measurable_space (nondiscrete_normed_field ereal)) (h1 : filter (nondiscrete_normed_field ereal)) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_20134 (h0 : functor.add_const (complete_lattice (ordered_comm_ring Type)) pos) : @complete_lattice.is_Sup_finite_compact.{1} (ordered_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (ordered_comm_ring.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_20135 (h0 : group (comm_group linarith.comp)) : group.fg (comm_group linarith.comp) := sorry --non-trivial
lemma new_lemma_20136 (h0 : group (complete_distrib_lattice (has_pos_part Type))) : normalizer_condition (complete_distrib_lattice (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_20137 (h0 : uniform_space (mul_zero_class (finset name))) : separated_space (mul_zero_class (finset name)) := sorry --non-trivial
lemma new_lemma_20138 (h0 : filter (comm_group Type)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_20139 (h0 : topological_space (has_Sup (semiring unsigned))) : totally_separated_space (has_Sup (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_20140 (h0 : functor.add_const (topological_space (add_cancel_monoid linarith.comp)) name) : @locally_compact_space.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_20141 (h0 : has_mem.mem (with_one (has_top fun_info)) has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} (with_one.{0} (has_top.{0} fun_info)) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (with_one.{0} (has_top.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_20142 (h0 : group (semi_normed_comm_ring (has_nnnorm (has_nnnorm linarith.ineq)))) : group.fg (semi_normed_comm_ring (has_nnnorm (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_20143 (h0 : normed_comm_ring (has_add ennreal) -> normed_comm_ring (has_add ennreal) -> Prop) : is_symm (normed_comm_ring (has_add ennreal)) h0 := sorry --non-trivial
lemma new_lemma_20144 (h0 : topological_space (has_zero (finset pos))) : regular_space (has_zero (finset pos)) := sorry --non-trivial
lemma new_lemma_20145 (h0 : group (complete_distrib_lattice linarith.comp)) : group.fg (complete_distrib_lattice linarith.comp) := sorry --non-trivial
lemma new_lemma_20146 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_20147 (h0 : not (function.extfun Type monoid -> false)) : @monoid.fg.{0} (linear_ordered_add_comm_group.{0} fun_info) (@function.extfun_app.{2 1} Type monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type monoid.{0}) h0) (linear_ordered_add_comm_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_20148 (h0 : finset (ordered_comm_group num)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_20149 (h1 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_top.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} h1 (has_top.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_20150 (h0 : topological_space (ordered_comm_monoid (ordered_comm_monoid pos))) : t1_space (ordered_comm_monoid (ordered_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_20151 (h0 : functor.add_const (topological_space (has_to_string unsigned)) linarith.comp) : @t1_space.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_20152 (h0 : topological_space (has_emptyc (random_gen (random_gen linarith.comp_source)))) : t0_space (has_emptyc (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_20153 (h0 : measurable_space (option (option (option (option empty))))) (h1 : has_mul (option (option (option (option empty))))) : has_measurable_mul₂ (option (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_20154 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_norm.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_norm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_20155 (h0 : topological_space (mul_zero_class (semiring (semiring num)))) : normal_space (mul_zero_class (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_20156 (h0 : monoid (boolean_algebra (ring (ring (has_add (finset (has_neg linarith.comp))))))) : monoid.fg (boolean_algebra (ring (ring (has_add (finset (has_neg linarith.comp)))))) := sorry --non-trivial
lemma new_lemma_20157 (h0 : function.extfun (Type 1) (functor.add_const (list linarith.comp))) : list.nodup (functor.add_const.run (function.extfun_app h0 Type)) := sorry --non-trivial
lemma new_lemma_20158 (h0 : filter (has_neg (finset (finset (finset (has_to_string (finset name))))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_20159 (h0 : ring (has_norm (has_top (has_top linarith.ineq)))) : is_domain (has_norm (has_top (has_top linarith.ineq))) := sorry --non-trivial
lemma new_lemma_20160 (h1 : function.extfun Type ring) : @is_domain.{0} (distrib_lattice.{0} string_imp) (@function.extfun_app.{2 1} Type ring.{0} h1 (distrib_lattice.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_20161 (h0 : complete_lattice (plift (semiring num))) : is_compactly_generated (plift (semiring num)) := sorry --non-trivial
lemma new_lemma_20162 (h0 : topological_space (add_comm_semigroup (add_comm_semigroup char))) : t1_space (add_comm_semigroup (add_comm_semigroup char)) := sorry --non-trivial
lemma new_lemma_20163 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (canonically_linear_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (canonically_linear_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_20164 (h0 : group (has_zero (ring (ring environment.implicit_infer_kind)))) : normalizer_condition (has_zero (ring (ring environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_20165 (h0 : functor.add_const (topological_space (has_zero linarith.comp)) pos) : @regular_space.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_20166 (h0 : functor.add_const (ordered_comm_monoid (has_neg_part Type)) char) : @has_exists_mul_of_le.{1} (has_neg_part.{1} Type) (@functor.add_const.run.{1 0} (ordered_comm_monoid.{1} (has_neg_part.{1} Type)) char h0)  := sorry --non-trivial
lemma new_lemma_20167 (h3 : topological_space (has_compl (mul_one_class (random_gen (random_gen (random_gen char)))))) : path_connected_space (has_compl (mul_one_class (random_gen (random_gen (random_gen char))))) := sorry --non-trivial
lemma new_lemma_20168 (h0 : not (uniform_space (has_emptyc num) -> false)) : @complete_space.{0} (has_emptyc.{0} num) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_emptyc.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_20169 (h1 : set (add_comm_semigroup ereal -> linarith.ineq)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_20170 (h0 : has_mem.mem (random_gen fun_info) has_emptyc.emptyc) : @monoid.fg.{0} (random_gen.{0} fun_info) (@finset.pi.empty.{1 0} Type monoid.{0} (random_gen.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_20171 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (generalized_boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type monoid.{0} h0 (generalized_boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_20172 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @is_atomistic.{0} (with_one.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) complete_lattice.{0}) (with_one.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_20173 (h0 : topological_space (finset (option ennreal))) : path_connected_space (finset (option ennreal)) := sorry --non-trivial
lemma new_lemma_20174 (h0 : topological_space (sub_neg_monoid (has_to_string pos))) : preirreducible_space (sub_neg_monoid (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_20175 (h0 : topological_space (has_zero (option (option ennreal)))) : path_connected_space (has_zero (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_20176 (h0 : uniform_space congr_arg_kind) : complete_space congr_arg_kind := sorry --non-trivial
lemma new_lemma_20177 (h0 : group (ordered_comm_ring (has_Inf (has_pos_part pos)))) : normalizer_condition (ordered_comm_ring (has_Inf (has_pos_part pos))) := sorry --non-trivial
lemma new_lemma_20178 (h0 : functor.add_const (ring (has_add Type)) linarith.comp) : @is_principal_ideal_ring.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_add.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_20179 (h0 : semiring (has_bot (has_neg pos))) : is_noetherian_ring (has_bot (has_neg pos)) := sorry --non-trivial
lemma new_lemma_20180 (h0 : topological_space ereal) : preirreducible_space ereal := sorry --non-trivial
lemma new_lemma_20181 (h0 : ring (with_bot to_additive.value_type)) : is_domain (with_bot to_additive.value_type) := sorry --non-trivial
lemma new_lemma_20182 (h0 : functor.add_const (function.extfun Type cancel_comm_monoid_with_zero) (boolean_algebra linarith.comp)) : @unique_factorization_monoid.{0} (ordered_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type cancel_comm_monoid_with_zero.{0}) (boolean_algebra.{0} linarith.comp) h0) (ordered_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_20183 (h0 : functor.add_const (topological_space name) unsigned) : @preirreducible_space.{0} name (@functor.add_const.run.{0 0} (topological_space.{0} name) unsigned h0)  := sorry --non-trivial
lemma new_lemma_20184 (h0 : functor.add_const (topological_space (left_cancel_monoid num)) empty) : @irreducible_space.{0} (left_cancel_monoid.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_20185 (h0 : not (ring (add_right_cancel_monoid unsigned) -> false)) : @rank_condition.{0} (add_right_cancel_monoid.{0} unsigned) (@classical.by_contradiction'.{1} (ring.{0} (add_right_cancel_monoid.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_20186 (h1 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (semiring.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} h1 (semiring.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_20187 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (linear_ordered_comm_monoid_with_zero.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_comm_monoid_with_zero.{0} empty))  := sorry --non-trivial
lemma new_lemma_20188 (h0 : topological_space (semiring (semiring linarith.comp))) : discrete_topology (semiring (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_20189 (h0 : cancel_comm_monoid_with_zero (has_star (option empty))) : unique_factorization_monoid (has_star (option empty)) := sorry --non-trivial
lemma new_lemma_20190 (h0 : topological_space (has_bot empty)) : normal_space (has_bot empty) := sorry --non-trivial
lemma new_lemma_20191 (h0 : ring (random_gen (random_gen fun_info))) : is_domain (random_gen (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_20192 (h2 : not (uniform_space (with_one congr_arg_kind) -> false)) : @complete_space.{0} (with_one.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (uniform_space.{0} (with_one.{0} congr_arg_kind)) h2)  := sorry --non-trivial
lemma new_lemma_20193 (h0 : topological_space (add_left_cancel_semigroup (option (option (option (option empty)))))) : path_connected_space (add_left_cancel_semigroup (option (option (option (option empty))))) := sorry --non-trivial
lemma new_lemma_20194 (h2 : add_group (nondiscrete_normed_field reducibility_hints)) : is_add_cyclic (nondiscrete_normed_field reducibility_hints) := sorry --non-trivial
lemma new_lemma_20195 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (add_right_cancel_monoid empty)) := sorry --non-trivial
lemma new_lemma_20196 (h0 : not (group (plift num) -> false)) : @is_cyclic.{1} (plift.{1} num) (@classical.by_contradiction'.{2} (group.{1} (plift.{1} num)) h0)  := sorry --non-trivial
lemma new_lemma_20197 (h0 : ring (semiring (semiring empty))) : strong_rank_condition (semiring (semiring empty)) := sorry --non-trivial
lemma new_lemma_20198 (h0 : add_monoid (comm_group (option (option (option (option (option (option (option pos))))))))) : add_monoid.fg (comm_group (option (option (option (option (option (option (option pos)))))))) := sorry --non-trivial
lemma new_lemma_20199 (h0 : add_group (simple_graph (mul_one_class char))) : is_add_cyclic (simple_graph (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_20200 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_nndist.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_nndist.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_20201 (h0 : functor.add_const (filter (has_neg pos)) linarith.comp) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_20202 (h0 : not (group (with_bot fun_info) -> false)) : @normalizer_condition.{0} (with_bot.{0} fun_info) (@classical.by_contradiction'.{1} (group.{0} (with_bot.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_20203 (h0 : functor.add_const (ring (ring Type)) linarith.comp) : @is_principal_ideal_ring.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (ring.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_20204 (h0 : topological_space (add_cancel_comm_monoid (option empty))) : totally_separated_space (add_cancel_comm_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_20205 (h0 : group (comm_semigroup name)) : group.fg (comm_semigroup name) := sorry --non-trivial
lemma new_lemma_20206 (h0 : add_monoid (linear_ordered_comm_group (option empty))) : add_monoid.fg (linear_ordered_comm_group (option empty)) := sorry --non-trivial
lemma new_lemma_20207 (h0 : ring (has_nndist (finset linarith.comp))) : is_principal_ideal_ring (has_nndist (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_20208 (h0 : list (add_cancel_monoid Type)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_20209 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_20210 (h0 : complete_lattice (has_compl (uniform_space linarith.comp_source))) : complete_lattice.is_Sup_finite_compact (has_compl (uniform_space linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_20211 (h1 : group (semi_normed_ring linarith.ineq)) : is_cyclic (semi_normed_ring linarith.ineq) := sorry --non-trivial
lemma new_lemma_20212 (h0 : functor.add_const (filter (add_cancel_monoid unsigned)) pos) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_20213 (h0 : monoid (metric_space congr_arg_kind)) : monoid.fg (metric_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_20214 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (linear_ordered_add_comm_group.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_add_comm_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_20215 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_edist.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_edist.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_20216 (h0 : function.extfun Type ring) : @is_domain.{0} (denumerable.{0} string_imp) (@function.extfun_app.{2 1} Type ring.{0} h0 (denumerable.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_20217 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (semiring.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_20218 (h0 : topological_space (complete_distrib_lattice (sub_neg_monoid pos))) : locally_compact_space (complete_distrib_lattice (sub_neg_monoid pos)) := sorry --non-trivial
lemma new_lemma_20219 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_Sup.{0} (has_Sup.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_Sup.{0} (has_Sup.{0} empty)))  := sorry --non-trivial
lemma new_lemma_20220 (h0 : monoid (pseudo_metric_space congr_arg_kind)) : monoid.fg (pseudo_metric_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_20221 (h0 : monoid (linear_ordered_comm_group (option num))) : monoid.fg (linear_ordered_comm_group (option num)) := sorry --non-trivial
lemma new_lemma_20222 (h0 : linarith.comp_source -> linarith.comp_source -> Prop) (h1 : set linarith.comp_source) : directed_on h0 h1 := sorry --non-trivial
lemma new_lemma_20223 (h0 : topological_space (has_compl (mul_one_class (has_nnnorm char)))) : totally_disconnected_space (has_compl (mul_one_class (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_20224 (h0 : has_mem.mem (has_top fun_info) has_emptyc.emptyc) : @monoid.fg.{0} (has_top.{0} fun_info) (@finset.pi.empty.{1 0} Type monoid.{0} (has_top.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_20225 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @is_compactly_generated.{0} (has_norm.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) complete_lattice.{0}) (has_norm.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_20226 (h0 : not (monoid (with_one (has_norm num)) -> false)) : @monoid.fg.{0} (with_one.{0} (has_norm.{0} num)) (@classical.by_contradiction'.{1} (monoid.{0} (with_one.{0} (has_norm.{0} num))) h0)  := sorry --non-trivial
lemma new_lemma_20227 (h0 : topological_space (random_gen (normed_field linarith.ineq))) : totally_disconnected_space (random_gen (normed_field linarith.ineq)) := sorry --non-trivial
lemma new_lemma_20228 (h0 : functor.add_const (topological_space (complete_distrib_lattice name)) linarith.comp) : @locally_compact_space.{0} (complete_distrib_lattice.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_20229 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (finset.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (finset.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_20230 (h0 : generalized_boolean_algebra pos -> generalized_boolean_algebra pos -> Prop) : is_symm (generalized_boolean_algebra pos) h0 := sorry --non-trivial
lemma new_lemma_20231 (h1 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h1 fun_info) := sorry --non-trivial
lemma new_lemma_20232 (h0 : topological_space (canonically_linear_ordered_monoid (has_Inf pos))) : preconnected_space (canonically_linear_ordered_monoid (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_20233 (h0 : topological_space (ring (has_neg_part (has_add name)))) : totally_disconnected_space (ring (has_neg_part (has_add name))) := sorry --non-trivial
lemma new_lemma_20234 (h0 : functor.add_const (complete_lattice (ring unsigned)) empty) : @is_compactly_generated.{0} (ring.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ring.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_20235 (h0 : list (has_neg (option (option (option ennreal))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_20236 (h0 : function.extfun Type ring) : @rank_condition.{0} znum (@function.extfun_app.{2 1} Type ring.{0} h0 znum)  := sorry --non-trivial
lemma new_lemma_20237 (h0 : functor.add_const (group (has_pos_part pos)) (has_neg Type)) : @normalizer_condition.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (has_pos_part.{0} pos)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_20238 (h0 : ring (uniform_space (has_nnnorm to_additive.value_type))) : strong_rank_condition (uniform_space (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_20239 (h0 : not (topological_space (normed_group (normed_group linarith.ineq)) -> false)) : @totally_separated_space.{0} (normed_group.{0} (normed_group.{0} linarith.ineq)) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_group.{0} (normed_group.{0} linarith.ineq))) h0)  := sorry --non-trivial
lemma new_lemma_20240 (h0 : group (normed_comm_ring (finset (finset (finset linarith.comp))))) : is_simple_group (normed_comm_ring (finset (finset (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_20241 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (boolean_algebra.core.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (boolean_algebra.core.{0} pos))  := sorry --non-trivial
lemma new_lemma_20242 (h0 : functor.add_const (topological_space (has_zero linarith.comp)) pos) : @preirreducible_space.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_20243 (h0 : function.extfun nat fin) : @is_simple_group.{1} (add_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (group.{1} (add_comm_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_20244 (h0 : finset (normed_comm_ring (option (option (option empty))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_20245 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (dlist to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_20246 (h0 : topological_space (measurable_space (random_gen (has_top (random_gen (has_top num)))))) : t0_space (measurable_space (random_gen (has_top (random_gen (has_top num))))) := sorry --non-trivial
lemma new_lemma_20247 (h0 : functor.add_const (uniform_space (cancel_monoid Type)) linarith.comp) : @separated_space.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (cancel_monoid.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_20248 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} (canonically_linear_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) (canonically_linear_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_20249 (h0 : function.extfun Type (functor.add_const (topological_space (mul_zero_class empty)))) : @topological_space.separable_space.{0} (mul_zero_class.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} empty)) congr_arg_kind (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (mul_zero_class.{0} empty))) h0 congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_20250 (h0 : functor.add_const (ring (finset name)) environment.implicit_infer_kind) : @strong_rank_condition.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (finset.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_20251 (h0 : ring (has_compl (random_gen linarith.comp_source))) : strong_rank_condition (has_compl (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_20252 (h3 : ring environment.projection_info) : rank_condition environment.projection_info := sorry --non-trivial
lemma new_lemma_20253 (h0 : add_monoid (cancel_monoid (boolean_algebra.core Type))) : add_monoid.fg (cancel_monoid (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_20254 (h0 : ordered_comm_monoid (has_pos_part name)) : has_exists_mul_of_le (has_pos_part name) := sorry --non-trivial
lemma new_lemma_20255 (h0 : has_lt (nondiscrete_normed_field (mul_one_class string.iterator_imp))) : no_max_order (nondiscrete_normed_field (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_20256 (h3 : topological_space (comm_ring char)) : path_connected_space (comm_ring char) := sorry --non-trivial
lemma new_lemma_20257 (h0 : uniform_space (has_neg (finset pos))) : separated_space (has_neg (finset pos)) := sorry --non-trivial
lemma new_lemma_20258 (h0 : add_group (has_append (comm_ring (has_ssubset reducibility_hints)))) : is_add_cyclic (has_append (comm_ring (has_ssubset reducibility_hints))) := sorry --non-trivial
lemma new_lemma_20259 (h0 : not (ring (non_unital_non_assoc_semiring linarith.comp_source) -> false)) : @rank_condition.{0} (non_unital_non_assoc_semiring.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (non_unital_non_assoc_semiring.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_20260 (h0 : topological_space (measure_theory.measure_space linarith.comp)) : path_connected_space (measure_theory.measure_space linarith.comp) := sorry --non-trivial
lemma new_lemma_20261 (h0 : complete_lattice (left_cancel_semigroup num)) : is_compactly_generated (left_cancel_semigroup num) := sorry --non-trivial
lemma new_lemma_20262 (h0 : functor.comp ring comm_group environment.implicit_infer_kind) : @strong_rank_condition.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} ring.{0} comm_group.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_20263 (h0 : measurable_space (normed_field (add_comm_semigroup string.iterator_imp))) (h1 : filter (normed_field (add_comm_semigroup string.iterator_imp))) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_20264 (h0 : filter (has_top (has_norm unsigned))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_20265 (h0 : functor.add_const (topological_space (ring Type)) (boolean_algebra Type)) : @preirreducible_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (ring.{1} Type)) (boolean_algebra.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_20266 (h0 : cancel_comm_monoid_with_zero (add_comm_monoid (has_neg_part unsigned))) : unique_factorization_monoid (add_comm_monoid (has_neg_part unsigned)) := sorry --non-trivial
lemma new_lemma_20267 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @is_compactly_generated.{0} (has_norm.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) complete_lattice.{0}) (has_norm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_20268 (h0 : functor.add_const (topological_space (add_cancel_monoid environment.implicit_infer_kind)) Type) : @t1_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_20269 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (sub_neg_monoid.{0} name) (@function.extfun_app.{2 1} Type monoid.{0} h0 (sub_neg_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_20270 (h0 : topological_space (normed_linear_ordered_group congr_arg_kind)) : t1_space (normed_linear_ordered_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_20271 (h0 : complete_lattice (add_comm_semigroup enat)) : is_compactly_generated (add_comm_semigroup enat) := sorry --non-trivial
lemma new_lemma_20272 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @totally_separated_space.{0} (has_add.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (has_add.{0} name))  := sorry --non-trivial
lemma new_lemma_20273 (h0 : topological_space (nondiscrete_normed_field (mul_one_class enat))) : totally_disconnected_space (nondiscrete_normed_field (mul_one_class enat)) := sorry --non-trivial
lemma new_lemma_20274 (h0 : functor.add_const (topological_space (finset linarith.comp)) (finset pos)) : @preconnected_space.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} linarith.comp)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_20275 (h0 : topological_space (has_inner pos pos)) : locally_compact_space (has_inner pos pos) := sorry --non-trivial
lemma new_lemma_20276 (h0 : topological_space (monoid_with_zero ennreal)) : preirreducible_space (monoid_with_zero ennreal) := sorry --non-trivial
lemma new_lemma_20277 (h0 : group (normed_group empty)) : group.fg (normed_group empty) := sorry --non-trivial
lemma new_lemma_20278 (h0 : topological_space (has_bot (has_Inf pos))) : loc_path_connected_space (has_bot (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_20279 (h0 : ring (has_bot (has_Inf (has_Inf Type)))) : rank_condition (has_bot (has_Inf (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_20280 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_20281 (h0 : group (finset empty)) : is_cyclic (finset empty) := sorry --non-trivial
lemma new_lemma_20282 (h0 : complete_lattice (has_top to_additive.value_type)) : complete_lattice.is_Sup_finite_compact (has_top to_additive.value_type) := sorry --non-trivial
lemma new_lemma_20283 (h2 : has_lt (has_compl std_gen)) : no_max_order (has_compl std_gen) := sorry --non-trivial
lemma new_lemma_20284 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_nndist.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_nndist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_20285 (h0 : functor.add_const (ring (semigroup Type)) Type) : @strong_rank_condition.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 1} (ring.{1} (semigroup.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_20286 (h0 : complete_lattice (has_to_string (option (option num)))) : is_compactly_generated (has_to_string (option (option num))) := sorry --non-trivial
lemma new_lemma_20287 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_atomistic.{0} (has_union.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (has_union.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_20288 (h0 : function.extfun Type ring) : @rank_condition.{0} (sub_neg_monoid.{0} real) (@function.extfun_app.{2 1} Type ring.{0} h0 (sub_neg_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_20289 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_add_cyclic.{1} (canonically_ordered_comm_semiring.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_group.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 add_group.{1}) (canonically_ordered_comm_semiring.{1} Type))  := sorry --non-trivial
lemma new_lemma_20290 (h0 : ring (partial_order (option (option unsigned)))) : is_domain (partial_order (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_20291 (h0 : group (omega_complete_partial_order (option empty))) : is_cyclic (omega_complete_partial_order (option empty)) := sorry --non-trivial
lemma new_lemma_20292 (h0 : topological_space (linear_ordered_comm_group unsigned)) : t0_space (linear_ordered_comm_group unsigned) := sorry --non-trivial
lemma new_lemma_20293 (h0 : not (add_group (random_gen fun_info) -> false)) : @is_add_cyclic.{0} (random_gen.{0} fun_info) (@classical.by_contradiction'.{1} (add_group.{0} (random_gen.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_20294 (h0 : uniform_space (distrib (has_ssubset linarith.ineq))) : complete_space (distrib (has_ssubset linarith.ineq)) := sorry --non-trivial
lemma new_lemma_20295 (h0 : function.extfun nat fin) : @has_exists_mul_of_le.{0} (ring.{0} pos) (@matrix.vec_empty.{0} (ordered_comm_monoid.{0} (ring.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_20296 (h0 : functor.add_const (cancel_comm_monoid_with_zero pos) pos) : @unique_factorization_monoid.{0} pos (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} pos) pos h0)  := sorry --non-trivial
lemma new_lemma_20297 (h2 : topological_space reducibility_hints) (h3 : preorder reducibility_hints) : order_closed_topology reducibility_hints := sorry --non-trivial
lemma new_lemma_20298 (h0 : monoid (measurable_space (comm_ring fun_info))) : monoid.fg (measurable_space (comm_ring fun_info)) := sorry --non-trivial
lemma new_lemma_20299 (h0 : topological_space (is_R_or_C empty)) : totally_separated_space (is_R_or_C empty) := sorry --non-trivial
lemma new_lemma_20300 (h0 : finset (canonically_linear_ordered_monoid (option (mul_zero_class (option pos))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_20301 (h0 : add_group (boolean_algebra (cancel_monoid Type))) : is_add_cyclic (boolean_algebra (cancel_monoid Type)) := sorry --non-trivial
lemma new_lemma_20302 (h0 : functor.add_const (complete_lattice (has_add linarith.comp)) name) : @complete_lattice.is_Sup_finite_compact.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_add.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_20303 (h0 : topological_space (ordered_ring empty)) : preirreducible_space (ordered_ring empty) := sorry --non-trivial
lemma new_lemma_20304 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (ordered_comm_group.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (ordered_comm_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_20305 (h0 : not (group (ordered_ring empty) -> false)) : @group.fg.{0} (ordered_ring.{0} empty) (@classical.by_contradiction'.{1} (group.{0} (ordered_ring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_20306 (h0 : topological_space (ring (option (option (option unsigned))))) : totally_disconnected_space (ring (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_20307 (h0 : topological_space (boolean_algebra (has_Inf Type))) : regular_space (boolean_algebra (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_20308 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (complete_distrib_lattice.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (complete_distrib_lattice.{0} pos))  := sorry --non-trivial
lemma new_lemma_20309 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @group.fg.{0} real (@matrix.vec_empty.{0} (group.{0} real) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_20310 (h0 : topological_space (as_linear_order num)) : path_connected_space (as_linear_order num) := sorry --non-trivial
lemma new_lemma_20311 (h0 : function.extfun Type ring) : @is_domain.{0} (linear_ordered_add_comm_group.{0} (comm_ring.{0} to_additive.value_type)) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_ordered_add_comm_group.{0} (comm_ring.{0} to_additive.value_type)))  := sorry --non-trivial
lemma new_lemma_20312 (h0 : not (topological_space (with_one empty) -> false)) : @discrete_topology.{0} (with_one.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (with_one.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_20313 (h0 : topological_space (topological_space (has_ssubset to_additive.value_type))) : locally_compact_space (topological_space (has_ssubset to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_20314 (h0 : has_lt (mul_one_class enat)) : no_max_order (mul_one_class enat) := sorry --non-trivial
lemma new_lemma_20315 (h0 : group (has_star empty)) : is_cyclic (has_star empty) := sorry --non-trivial
lemma new_lemma_20316 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @complete_space.{0} (has_edist.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) uniform_space.{0}) (has_edist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_20317 (h0 : ring (add_cancel_monoid (add_comm_monoid (add_comm_monoid name)))) : rank_condition (add_cancel_monoid (add_comm_monoid (add_comm_monoid name))) := sorry --non-trivial
lemma new_lemma_20318 (h0 : preorder (mul_one_class (mul_one_class enat))) (h1 : set (mul_one_class (mul_one_class enat))) : set.is_pwo h1 := sorry --non-trivial
lemma new_lemma_20319 (h0 : uniform_space (with_bot (has_norm (has_norm empty)))) : complete_space (with_bot (has_norm (has_norm empty))) := sorry --non-trivial
lemma new_lemma_20320 (h0 : monoid real.angle) : monoid.fg real.angle := sorry --non-trivial
lemma new_lemma_20321 (h0 : add_group (has_add (finset (has_add linarith.comp)))) : is_add_cyclic (has_add (finset (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_20322 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (has_to_string.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_to_string.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_20323 (h0 : semiring (boolean_algebra real)) : is_noetherian_ring (boolean_algebra real) := sorry --non-trivial
lemma new_lemma_20324 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_20325 (h0 : topological_space (has_ssubset (has_nnnorm (has_nnnorm (has_nnnorm (random_gen fun_info)))))) : path_connected_space (has_ssubset (has_nnnorm (has_nnnorm (has_nnnorm (random_gen fun_info))))) := sorry --non-trivial
lemma new_lemma_20326 (h0 : topological_space (linear_ordered_semiring (random_gen (random_gen (semiring num))))) : irreducible_space (linear_ordered_semiring (random_gen (random_gen (semiring num)))) := sorry --non-trivial
lemma new_lemma_20327 (h0 : function.extfun Type (functor.add_const (complete_lattice znum))) : @is_compactly_generated.{0} znum (@functor.add_const.run.{0 0} (complete_lattice.{0} znum) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (complete_lattice.{0} znum)) h0 num))  := sorry --non-trivial
lemma new_lemma_20328 (h0 : complete_lattice (add_left_cancel_semigroup congr_arg_kind)) : is_compactly_generated (add_left_cancel_semigroup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_20329 (h0 : topological_space (complete_distrib_lattice (finset name))) : locally_compact_space (complete_distrib_lattice (finset name)) := sorry --non-trivial
lemma new_lemma_20330 (h3 : complete_lattice (distrib char)) : complete_lattice.is_Sup_finite_compact (distrib char) := sorry --non-trivial
lemma new_lemma_20331 (h1 : ring (non_unital_non_assoc_semiring to_additive.value_type)) : is_domain (non_unital_non_assoc_semiring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_20332 (h0 : topological_space (random_gen (mul_one_class string_imp))) : path_connected_space (random_gen (mul_one_class string_imp)) := sorry --non-trivial
lemma new_lemma_20333 (h0 : topological_space (linear_ordered_add_comm_group (random_gen (random_gen linarith.ineq)))) : t0_space (linear_ordered_add_comm_group (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_20334 (h0 : functor.add_const (function.extfun Type semiring) Type) : @is_noetherian_ring.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type semiring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type semiring.{0}) Type h0) (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_20335 (h1 : add_group (semi_normed_comm_ring string.iterator_imp)) : is_add_cyclic (semi_normed_comm_ring string.iterator_imp) := sorry --non-trivial
lemma new_lemma_20336 (h0 : topological_space (ordered_comm_monoid (has_add (has_add real)))) : normal_space (ordered_comm_monoid (has_add (has_add real))) := sorry --non-trivial
lemma new_lemma_20337 (h1 : not (ring (semi_normed_comm_ring char) -> false)) : @is_domain.{0} (semi_normed_comm_ring.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (semi_normed_comm_ring.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_20338 (h0 : functor.add_const (group (normed_comm_ring name)) name) : @is_cyclic.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (group.{0} (normed_comm_ring.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_20339 (h1 : complete_lattice (distrib (distrib (semi_normed_ring linarith.comp_source)))) : is_compactly_generated (distrib (distrib (semi_normed_ring linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_20340 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (has_inter congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_20341 (h0 : function.extfun Type (functor.add_const (topological_space (comm_monoid empty)))) : @totally_disconnected_space.{0} (comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_monoid.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (comm_monoid.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_20342 (h0 : functor.add_const (filter (mul_zero_class environment.implicit_infer_kind)) (has_neg unsigned)) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_20343 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (preorder.{0} num) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (preorder.{0} num))  := sorry --non-trivial
lemma new_lemma_20344 (h0 : uniform_space (plift (plift unsigned))) : complete_space (plift (plift unsigned)) := sorry --non-trivial
lemma new_lemma_20345 (h0 : ring (pseudo_emetric_space congr_arg_kind)) : rank_condition (pseudo_emetric_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_20346 (h0 : group (non_assoc_semiring empty)) : is_cyclic (non_assoc_semiring empty) := sorry --non-trivial
lemma new_lemma_20347 (h0 : ring (semi_normed_comm_ring (comm_ring (random_gen (random_gen char))))) : rank_condition (semi_normed_comm_ring (comm_ring (random_gen (random_gen char)))) := sorry --non-trivial
lemma new_lemma_20348 (h0 : ring (has_sub (has_top (semiring (semiring empty))))) : is_principal_ideal_ring (has_sub (has_top (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_20349 (h0 : functor.add_const (filter (monoid ennreal)) congr_arg_kind) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_20350 (h1 : not (function.extfun Type topological_space -> false)) : @irreducible_space.{0} to_additive.value_type (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h1) to_additive.value_type)  := sorry --non-trivial
lemma new_lemma_20351 (h1 : topological_space num) : locally_compact_space num := sorry --non-trivial
lemma new_lemma_20352 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (left_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (left_cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_20353 (h0 : topological_space (ordered_comm_ring (ring Type))) : topological_space.separable_space (ordered_comm_ring (ring Type)) := sorry --non-trivial
lemma new_lemma_20354 (h2 : ring (has_ssubset linarith.ineq)) : is_domain (has_ssubset linarith.ineq) := sorry --non-trivial
lemma new_lemma_20355 (h0 : ring (measure_theory.measure_space (semiring (semiring congr_arg_kind)))) : strong_rank_condition (measure_theory.measure_space (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_20356 (h0 : add_group (linear_ordered_cancel_comm_monoid (option (option (option (option (option empty))))))) : is_add_cyclic (linear_ordered_cancel_comm_monoid (option (option (option (option (option empty)))))) := sorry --non-trivial
lemma new_lemma_20357 (h1 : not (ring (has_div linarith.ineq) -> false)) : @is_domain.{0} (has_div.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (has_div.{0} linarith.ineq)) h1)  := sorry --non-trivial
lemma new_lemma_20358 (h0 : ring (mul_one_class environment.projection_info)) : is_domain (mul_one_class environment.projection_info) := sorry --non-trivial
lemma new_lemma_20359 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_20360 (h0 : functor.add_const (group (has_bot real)) (has_Inf Type)) : @is_cyclic.{0} (has_bot.{0} real) (@functor.add_const.run.{0 1} (group.{0} (has_bot.{0} real)) (has_Inf.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_20361 (h0 : functor.add_const (add_group (canonically_ordered_comm_semiring Type)) Type) : @is_add_cyclic.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.add_const.run.{1 1} (add_group.{1} (canonically_ordered_comm_semiring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_20362 (h0 : ring (has_ssubset (random_gen (random_gen (random_gen linarith.ineq))))) : rank_condition (has_ssubset (random_gen (random_gen (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_20363 (h1 : has_lt string_imp) : no_max_order string_imp := sorry --non-trivial
lemma new_lemma_20364 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 nnreal) := sorry --non-trivial
lemma new_lemma_20365 (h0 : not (topological_space (measurable_space linarith.ineq) -> false)) : @discrete_topology.{0} (measurable_space.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (measurable_space.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_20366 (h0 h1 : multiset (has_nnnorm (mul_one_class fun_info))) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_20367 (h0 : group (semiring (has_norm (has_norm (has_norm (has_norm to_additive.value_type)))))) : normalizer_condition (semiring (has_norm (has_norm (has_norm (has_norm to_additive.value_type))))) := sorry --non-trivial
lemma new_lemma_20368 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (boolean_algebra.core.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} pos))  := sorry --non-trivial
lemma new_lemma_20369 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (semiring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_20370 (h0 : functor.add_const (topological_space (ring linarith.comp)) pos) : @topological_space.separable_space.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_20371 (h2 : complete_lattice (has_ssubset to_additive.value_type)) : complete_lattice.is_Sup_finite_compact (has_ssubset to_additive.value_type) := sorry --non-trivial
lemma new_lemma_20372 (h0 : complete_lattice (has_dist ennreal)) : complete_lattice.is_Sup_finite_compact (has_dist ennreal) := sorry --non-trivial
lemma new_lemma_20373 (h0 : add_monoid (canonically_ordered_comm_semiring (finset (ring pos)))) : add_monoid.fg (canonically_ordered_comm_semiring (finset (ring pos))) := sorry --non-trivial
lemma new_lemma_20374 (h0 : functor.add_const (list (complete_distrib_lattice Type)) (has_add (has_neg_part (has_add Type)))) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_20375 (h0 : topological_space (has_to_string (ring (has_add (ring Type))))) : preirreducible_space (has_to_string (ring (has_add (ring Type)))) := sorry --non-trivial
lemma new_lemma_20376 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (generalized_boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (generalized_boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_20377 (h0 : group (with_bot (has_top fun_info))) : normalizer_condition (with_bot (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_20378 (h0 : topological_space (non_assoc_semiring unsigned)) : locally_compact_space (non_assoc_semiring unsigned) := sorry --non-trivial
lemma new_lemma_20379 (h0 : uniform_space (with_bot (has_norm (semiring (semiring congr_arg_kind))))) : separated_space (with_bot (has_norm (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_20380 (h0 : ring (semigroup (has_to_string pos))) : rank_condition (semigroup (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_20381 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_20382 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_20383 (h0 : ring (ordered_comm_monoid (has_Inf (has_Inf (has_Inf Type))))) : is_domain (ordered_comm_monoid (has_Inf (has_Inf (has_Inf Type)))) := sorry --non-trivial
lemma new_lemma_20384 (h0 : functor.add_const (topological_space (left_cancel_semigroup congr_arg_kind)) empty) : @totally_disconnected_space.{0} (left_cancel_semigroup.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_semigroup.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_20385 (h0 : functor.add_const (cancel_comm_monoid_with_zero (semiring congr_arg_kind)) congr_arg_kind) : @unique_factorization_monoid.{0} (semiring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (semiring.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_20386 (h0 : topological_space (has_ssubset char)) : locally_compact_space (has_ssubset char) := sorry --non-trivial
lemma new_lemma_20387 (h0 : function.extfun (Type 1) group) : @group.fg.{1} (comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} h0 (comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_20388 (h0 : topological_space (has_to_string ennreal)) : locally_compact_space (has_to_string ennreal) := sorry --non-trivial
lemma new_lemma_20389 (h0 : not (function.extfun Type group -> false)) : @normalizer_condition.{0} (has_emptyc.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} empty)))))) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (has_emptyc.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} empty)))))))  := sorry --non-trivial
lemma new_lemma_20390 (h0 : complete_lattice (id (has_norm (semiring (semiring (semiring (semiring empty))))))) : is_atomistic (id (has_norm (semiring (semiring (semiring (semiring empty)))))) := sorry --non-trivial
lemma new_lemma_20391 (h0 : topological_space (has_dist (option (option num)))) : totally_disconnected_space (has_dist (option (option num))) := sorry --non-trivial
lemma new_lemma_20392 (h0 : not (topological_space (dlist linarith.comp_source) -> false)) : @t0_space.{0} (dlist.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (dlist.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_20393 (h0 : ring (complete_distrib_lattice (ring (ring Type)))) : is_domain (complete_distrib_lattice (ring (ring Type))) := sorry --non-trivial
lemma new_lemma_20394 (h0 : functor.add_const (add_group (complete_distrib_lattice Type)) unsigned) : @is_add_cyclic.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 0} (add_group.{1} (complete_distrib_lattice.{1} Type)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_20395 (h1 : measurable_space (has_compl reducibility_hints)) (h2 : filter (has_compl reducibility_hints)) : filter.is_measurably_generated h2 := sorry --non-trivial
lemma new_lemma_20396 (h0 : function.extfun Type (functor.add_const (topological_space environment.implicit_infer_kind))) : @preirreducible_space.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 0} (topological_space.{0} environment.implicit_infer_kind) linarith.comp (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} environment.implicit_infer_kind)) h0 linarith.comp))  := sorry --non-trivial
lemma new_lemma_20397 (h0 : function.extfun Type topological_space) : @t1_space.{0} (add_cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_20398 (h1 : complete_lattice (simple_graph linarith.ineq)) : complete_lattice.is_Sup_finite_compact (simple_graph linarith.ineq) := sorry --non-trivial
lemma new_lemma_20399 (h0 : uniform_space (add_comm_monoid (sub_neg_monoid (has_Inf Type)))) : separated_space (add_comm_monoid (sub_neg_monoid (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_20400 (h0 : not (complete_lattice (complete_semilattice_Sup fun_info) -> false)) : @is_compactly_generated.{0} (complete_semilattice_Sup.{0} fun_info) (@classical.by_contradiction'.{1} (complete_lattice.{0} (complete_semilattice_Sup.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_20401 (h0 : topological_space (add_cancel_monoid linarith.comp)) : regular_space (add_cancel_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_20402 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (normed_group to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_20403 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (add_right_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_right_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_20404 (h1 : complete_lattice (random_gen (metric_space (metric_space to_additive.value_type)))) : is_compactly_generated (random_gen (metric_space (metric_space to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_20405 (h0 : functor.add_const (uniform_space (linear_ordered_comm_monoid_with_zero empty)) (option empty)) : @separated_space.{0} (linear_ordered_comm_monoid_with_zero.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (linear_ordered_comm_monoid_with_zero.{0} empty)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_20406 (h0 : set (semi_normed_ring std_gen)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_20407 (h0 : functor.add_const (topological_space (measure_theory.measure_space num)) unsigned) : @t0_space.{0} (measure_theory.measure_space.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (measure_theory.measure_space.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_20408 (h0 : ring (with_zero (random_gen fun_info))) : rank_condition (with_zero (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_20409 (h0 : functor.add_const (filter (has_bot unsigned)) congr_arg_kind) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_20410 (h0 : not (topological_space (measurable_space congr_arg_kind) -> false)) : @path_connected_space.{0} (measurable_space.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (measurable_space.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_20411 (h0 : monoid (complete_distrib_lattice linarith.comp)) : monoid.fg (complete_distrib_lattice linarith.comp) := sorry --non-trivial
lemma new_lemma_20412 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (distrib_lattice.{0} string_imp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (distrib_lattice.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_20413 (h0 : uniform_space (linear_ordered_add_comm_group (with_bot (with_bot string_imp)))) : complete_space (linear_ordered_add_comm_group (with_bot (with_bot string_imp))) := sorry --non-trivial
lemma new_lemma_20414 (h0 : ring (random_gen (comm_ring (has_inv linarith.ineq)))) : is_domain (random_gen (comm_ring (has_inv linarith.ineq))) := sorry --non-trivial
lemma new_lemma_20415 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (sub_neg_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (sub_neg_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_20416 (h0 : topological_space (has_pos_part Type)) : totally_separated_space (has_pos_part Type) := sorry --non-trivial
lemma new_lemma_20417 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (add_comm_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (add_comm_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_20418 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (has_emptyc.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_emptyc.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_20419 (h0 : functor.add_const (topological_space (has_nndist pos)) linarith.comp) : @normal_space.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_20420 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_emptyc.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_emptyc.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_20421 (h0 : function.extfun (Type 1) complete_lattice) : @is_atomistic.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} h0 (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_20422 (h0 : cancel_comm_monoid_with_zero (add_left_cancel_semigroup (semiring empty))) : unique_factorization_monoid (add_left_cancel_semigroup (semiring empty)) := sorry --non-trivial
lemma new_lemma_20423 (h0 : topological_space (linear_ordered_add_comm_group (measurable_space (random_gen linarith.ineq)))) : locally_compact_space (linear_ordered_add_comm_group (measurable_space (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_20424 (h0 : not (ring (add_right_cancel_monoid unsigned) -> false)) : @is_principal_ideal_ring.{0} (add_right_cancel_monoid.{0} unsigned) (@classical.by_contradiction'.{1} (ring.{0} (add_right_cancel_monoid.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_20425 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (pseudo_metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (pseudo_metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_20426 (h0 : topological_space (normed_linear_ordered_group empty)) : path_connected_space (normed_linear_ordered_group empty) := sorry --non-trivial
lemma new_lemma_20427 (h0 : functor.add_const (topological_space (has_nndist name)) name) : @t0_space.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_20428 (h3 : topological_space linarith.comp_source) : totally_separated_space linarith.comp_source := sorry --non-trivial
lemma new_lemma_20429 (h0 : functor.add_const (cancel_comm_monoid_with_zero (bin_tree congr_arg_kind)) unsigned) : @unique_factorization_monoid.{0} (bin_tree.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (bin_tree.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_20430 (h0 : group (has_bot (sub_neg_monoid real))) : normalizer_condition (has_bot (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_20431 (h0 : topological_space (semi_normed_comm_ring (random_gen (has_nnnorm linarith.comp_source)))) : path_connected_space (semi_normed_comm_ring (random_gen (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_20432 (h0 : topological_space (partial_order (semiring (semiring num)))) : t1_space (partial_order (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_20433 (h0 : group (canonically_ordered_add_monoid (option unsigned))) : normalizer_condition (canonically_ordered_add_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_20434 (h1 : has_mem.mem (has_emptyc to_additive.value_type) has_emptyc.emptyc) : @path_connected_space.{0} (has_emptyc.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_emptyc.{0} to_additive.value_type) h1)  := sorry --non-trivial
lemma new_lemma_20435 (h0 : fun_info -> filter fun_info) (h1 : set fun_info) : @is_open.{0} fun_info (@topological_space.mk_of_nhds.{0} fun_info h0) h1  := sorry --non-trivial
lemma new_lemma_20436 (h0 : filter (has_top (has_norm (has_nnnorm fun_info)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_20437 (h0 : functor.add_const (filter (add_cancel_monoid ennreal)) Type) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_20438 (h0 : functor.add_const (topological_space (ring name)) unsigned) : @path_connected_space.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_20439 (h1 : topological_space (add_comm_semigroup (add_comm_semigroup string.iterator_imp))) (h2 : add_group (add_comm_semigroup (add_comm_semigroup string.iterator_imp))) : topological_add_group (add_comm_semigroup (add_comm_semigroup string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_20440 (h0 : complete_lattice (ordered_comm_monoid (has_pos_part (finset name)))) : is_compactly_generated (ordered_comm_monoid (has_pos_part (finset name))) := sorry --non-trivial
lemma new_lemma_20441 (h0 : topological_space (has_add (has_add Type))) : sequential_space (has_add (has_add Type)) := sorry --non-trivial
lemma new_lemma_20442 (h3 : topological_space (semi_normed_comm_ring linarith.ineq)) : path_connected_space (semi_normed_comm_ring linarith.ineq) := sorry --non-trivial
lemma new_lemma_20443 (h0 : topological_space (has_compl (has_nnnorm std_gen))) : totally_disconnected_space (has_compl (has_nnnorm std_gen)) := sorry --non-trivial
lemma new_lemma_20444 (h0 : add_group (finset (option (option empty)))) : is_add_cyclic (finset (option (option empty))) := sorry --non-trivial
lemma new_lemma_20445 (h0 : topological_space (has_Inf (has_Inf (finset (has_pos_part pos))))) : locally_compact_space (has_Inf (has_Inf (finset (has_pos_part pos)))) := sorry --non-trivial
lemma new_lemma_20446 (h0 : set (linear_ordered_comm_group_with_zero linarith.comp_source)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_20447 (h0 : not (uniform_space (semi_normed_ring linarith.ineq) -> false)) : @complete_space.{0} (semi_normed_ring.{0} linarith.ineq) (@classical.by_contradiction'.{1} (uniform_space.{0} (semi_normed_ring.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_20448 (h0 : list (has_nndist (mul_zero_class (option pos)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_20449 (h0 : functor.add_const (topological_space (has_zero environment.implicit_infer_kind)) pos) : @t1_space.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_20450 (h0 : functor.add_const (topological_space (add_cancel_monoid pos)) (normed_comm_ring pos)) : @totally_separated_space.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} pos)) (normed_comm_ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_20451 (h0 : has_mem.mem complete_lattice has_emptyc.emptyc) : @is_compactly_generated.{0} (semiring.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} h0) (semiring.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_20452 (h0 : ring (mul_one_class (mul_one_class linarith.ineq))) : strong_rank_condition (mul_one_class (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_20453 (h0 : functor.add_const (function.extfun (Type 1) ordered_add_comm_monoid) Type) : @archimedean.{1} (normed_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_add_comm_monoid.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) ordered_add_comm_monoid.{1}) Type h0) (normed_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_20454 (h0 : functor.comp filter comm_group pos) : countable_Inter_filter (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_20455 (h0 : functor.add_const (topological_space (normed_comm_ring name)) (finset pos)) : @discrete_topology.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} name)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_20456 (h0 : functor.add_const (complete_lattice (semigroup pos)) pos) : @is_compactly_generated.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (semigroup.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_20457 (h0 : ring (finset (has_Inf Type))) : is_principal_ideal_ring (finset (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_20458 (h0 : fin has_zero.zero) : @regular_space.{0} (ordered_comm_monoid.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_monoid.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_20459 (h0 : not (complete_lattice (div_inv_monoid linarith.comp_source) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (div_inv_monoid.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (complete_lattice.{0} (div_inv_monoid.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_20460 (h0 : functor.add_const (complete_lattice (has_neg name)) name) : @functor.add_const.run.{0 0} Prop linarith.comp (@complete_lattice.is_Sup_finite_compact.{0} (has_neg.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_neg.{0} name)) name h0))  := sorry --non-trivial
lemma new_lemma_20461 (h0 : topological_space (complete_distrib_lattice (has_add name))) : t1_space (complete_distrib_lattice (has_add name)) := sorry --non-trivial
lemma new_lemma_20462 (h0 : not (topological_space (bin_tree unsigned) -> false)) : @irreducible_space.{0} (bin_tree.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (bin_tree.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_20463 (h0 : group (normed_group fun_info)) : normalizer_condition (normed_group fun_info) := sorry --non-trivial
lemma new_lemma_20464 (h0 : function.extfun Type topological_space) : @t0_space.{0} (complete_linear_order.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_linear_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_20465 (h0 : complete_lattice (normed_comm_ring (pseudo_metric_space (comm_group name)))) : complete_lattice.is_Sup_finite_compact (normed_comm_ring (pseudo_metric_space (comm_group name))) := sorry --non-trivial
lemma new_lemma_20466 (h3 : ring (random_gen linarith.ineq)) : is_domain (random_gen linarith.ineq) := sorry --non-trivial
lemma new_lemma_20467 (h0 : functor.add_const (topological_space (has_add ennreal)) num) : @loc_path_connected_space.{0} (has_add.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} ennreal)) num h0)  := sorry --non-trivial
lemma new_lemma_20468 (h0 : not (ring (complete_semilattice_Sup num) -> false)) : @rank_condition.{0} (complete_semilattice_Sup.{0} num) (@classical.by_contradiction'.{1} (ring.{0} (complete_semilattice_Sup.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_20469 (h0 : fin has_zero.zero) : @locally_compact_space.{1} (ordered_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) (@matrix.vec_empty.{2} (function.extfun.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1))) (@functor.add_const.run.{0 0} (fin (@has_zero.zero.{0} nat nat.has_zero)) name (@matrix.vec_empty.{0} (functor.add_const.{0 0} (fin (@has_zero.zero.{0} nat nat.has_zero)) name) h0))) topological_space.{1}) (ordered_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_20470 (h0 : function.extfun Type ring) : @is_domain.{0} (add_group.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_20471 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (mul_zero_class.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (mul_zero_class.{0} num))  := sorry --non-trivial
lemma new_lemma_20472 (h0 : functor.add_const (function.extfun Type uniform_space) linarith.comp) : @separated_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) linarith.comp h0) (semigroup.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_20473 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (semigroup (option pos))) := sorry --non-trivial
lemma new_lemma_20474 (h0 : functor.add_const (complete_lattice (semigroup linarith.comp)) linarith.comp) : @is_compactly_generated.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (semigroup.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_20475 (h0 : add_group (ordered_comm_monoid (ring pos))) : is_add_cyclic (ordered_comm_monoid (ring pos)) := sorry --non-trivial
lemma new_lemma_20476 (h0 : functor.add_const (topological_space (boolean_algebra empty)) empty) : @path_connected_space.{0} (boolean_algebra.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_20477 (h0 : monoid (complete_distrib_lattice (option (option (option empty))))) : monoid.fg (complete_distrib_lattice (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_20478 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (option.{0} num) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (option.{0} num))  := sorry --non-trivial
lemma new_lemma_20479 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_20480 (h0 : group (distrib_lattice (has_top (has_nnnorm fun_info)))) : group.fg (distrib_lattice (has_top (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_20481 (h0 : monoid (add_group (has_top num))) : monoid.fg (add_group (has_top num)) := sorry --non-trivial
lemma new_lemma_20482 (h0 : group (complete_distrib_lattice (has_bot (sub_neg_monoid (has_bot (sub_neg_monoid pos)))))) : is_simple_group (complete_distrib_lattice (has_bot (sub_neg_monoid (has_bot (sub_neg_monoid pos))))) := sorry --non-trivial
lemma new_lemma_20483 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (generalized_boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (generalized_boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_20484 (h0 : uniform_space (omega_complete_partial_order empty)) : separated_space (omega_complete_partial_order empty) := sorry --non-trivial
lemma new_lemma_20485 (h0 : functor.add_const (ring (complete_distrib_lattice linarith.comp)) (generalized_boolean_algebra pos)) : @strong_rank_condition.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (complete_distrib_lattice.{0} linarith.comp)) (generalized_boolean_algebra.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_20486 (h0 : ring (metric_space (has_norm (semiring linarith.comp)))) : is_domain (metric_space (has_norm (semiring linarith.comp))) := sorry --non-trivial
lemma new_lemma_20487 (h0 : function.extfun nat fin) : @is_cyclic.{0} (canonically_ordered_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (group.{0} (canonically_ordered_monoid.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_20488 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @complete_lattice.is_Sup_finite_compact.{0} (linear_ordered_field.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) complete_lattice.{0}) (linear_ordered_field.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_20489 (h0 : add_group (comm_group (semigroup pos))) : is_add_cyclic (comm_group (semigroup pos)) := sorry --non-trivial
lemma new_lemma_20490 (h0 : topological_space (boolean_algebra.core (has_add name))) : discrete_topology (boolean_algebra.core (has_add name)) := sorry --non-trivial
lemma new_lemma_20491 (h0 : group (complete_distrib_lattice (add_cancel_monoid empty))) : normalizer_condition (complete_distrib_lattice (add_cancel_monoid empty)) := sorry --non-trivial
lemma new_lemma_20492 (h0 : topological_space (mul_one_class (add_comm_semigroup (add_comm_semigroup (add_comm_semigroup fun_info))))) : t0_space (mul_one_class (add_comm_semigroup (add_comm_semigroup (add_comm_semigroup fun_info)))) := sorry --non-trivial
lemma new_lemma_20493 (h0 : function.extfun (finset Type) (has_mem.mem (id linarith.comp))) : @totally_disconnected_space.{0} (@id.{2} Type linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (@id.{2} Type linarith.comp) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (@id.{2} Type linarith.comp)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_20494 (h0 : not (function.extfun Type ring -> false)) : @rank_condition.{0} (has_nnnorm.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (has_nnnorm.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_20495 (h0 : functor.add_const (complete_lattice (normed_lattice_add_comm_group real)) real) : @complete_lattice.is_Sup_finite_compact.{0} (normed_lattice_add_comm_group.{0} real) (@functor.add_const.run.{0 0} (complete_lattice.{0} (normed_lattice_add_comm_group.{0} real)) real h0)  := sorry --non-trivial
lemma new_lemma_20496 (h1 : topological_space (mul_one_class (has_ssubset (mul_one_class fun_info)))) : totally_disconnected_space (mul_one_class (has_ssubset (mul_one_class fun_info))) := sorry --non-trivial
lemma new_lemma_20497 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (has_to_string.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_to_string.{0} empty))  := sorry --non-trivial
lemma new_lemma_20498 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (linear_ordered_comm_monoid_with_zero.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (linear_ordered_comm_monoid_with_zero.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_20499 (h0 : functor.comp topological_space cancel_monoid Type) : @totally_disconnected_space.{1} (cancel_monoid.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} cancel_monoid.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_20500 (h0 : finset (complete_distrib_lattice (option num))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_20501 (h0 : topological_space (linear_ordered_comm_group unsigned)) : locally_compact_space (linear_ordered_comm_group unsigned) := sorry --non-trivial
lemma new_lemma_20502 (h0 : group (as_linear_order (option (option (option (option empty)))))) : normalizer_condition (as_linear_order (option (option (option (option empty))))) := sorry --non-trivial
lemma new_lemma_20503 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (has_norm.{0} string_imp) (@function.extfun_app.{2 1} Type monoid.{0} h0 (has_norm.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_20504 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (add_left_cancel_semigroup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_left_cancel_semigroup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_20505 (h0 : function.extfun Type ring) : @rank_condition.{0} (pseudo_metric_space.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (pseudo_metric_space.{0} pos))  := sorry --non-trivial
lemma new_lemma_20506 (h0 : not (add_group (has_div (mul_one_class reducibility_hints)) -> false)) : @is_add_cyclic.{0} (has_div.{0} (mul_one_class.{0} reducibility_hints)) (@classical.by_contradiction'.{1} (add_group.{0} (has_div.{0} (mul_one_class.{0} reducibility_hints))) h0)  := sorry --non-trivial
lemma new_lemma_20507 (h0 : ordered_add_comm_monoid (normed_comm_ring (finset (normed_comm_ring name)))) : archimedean (normed_comm_ring (finset (normed_comm_ring name))) := sorry --non-trivial
lemma new_lemma_20508 (h0 : list (add_cancel_monoid (has_add (has_add (has_add linarith.comp))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_20509 (h0 : functor.add_const (filter (complete_distrib_lattice Type)) (has_neg_part linarith.comp)) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_20510 (h0 : finset (boolean_algebra.core (has_add pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_20511 (h0 : nat -> topological_space (add_comm_semigroup ereal) -> topological_space (add_comm_semigroup ereal)) (h1 : nat) (h2 : topological_space (add_comm_semigroup ereal)) : totally_disconnected_space (add_comm_semigroup ereal) := sorry --non-trivial
lemma new_lemma_20512 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @preconnected_space.{0} (comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_20513 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (has_dist.{0} empty) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (has_dist.{0} empty))  := sorry --non-trivial
lemma new_lemma_20514 (h0 : functor.add_const (ring (mul_zero_class unsigned)) (semiring num)) : @rank_condition.{0} (mul_zero_class.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (mul_zero_class.{0} unsigned)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_20515 (h0 : functor.add_const (topological_space (has_neg pos)) (finset Type)) : @topological_space.separable_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg.{0} pos)) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_20516 (h0 : functor.add_const (filter (has_zero unsigned)) linarith.comp) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_20517 (h0 : functor.add_const (add_group (has_to_string pos)) (ring pos)) : @is_add_cyclic.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (has_to_string.{0} pos)) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_20518 (h0 : functor.add_const (function.extfun Type group) pos) : @group.fg.{0} (complete_distrib_lattice.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) pos h0) (complete_distrib_lattice.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_20519 (h0 : not (add_group (has_compl (mul_one_class (mul_one_class (mul_one_class linarith.ineq)))) -> false)) : @is_add_cyclic.{0} (has_compl.{0} (mul_one_class.{0} (mul_one_class.{0} (mul_one_class.{0} linarith.ineq)))) (@classical.by_contradiction'.{1} (add_group.{0} (has_compl.{0} (mul_one_class.{0} (mul_one_class.{0} (mul_one_class.{0} linarith.ineq))))) h0)  := sorry --non-trivial
lemma new_lemma_20520 (h0 : topological_space (ordered_comm_monoid (has_pos_part Type))) : t1_space (ordered_comm_monoid (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_20521 (h1 : group (has_nnnorm string.iterator_imp)) : is_cyclic (has_nnnorm string.iterator_imp) := sorry --non-trivial
lemma new_lemma_20522 (h0 : complete_lattice (has_ssubset (has_inv to_additive.value_type))) : is_compactly_generated (has_ssubset (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_20523 (h1 : group (measurable_space (random_gen string_imp))) : normalizer_condition (measurable_space (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_20524 (h0 : functor.add_const (topological_space (normed_linear_ordered_group unsigned)) unsigned) : @loc_path_connected_space.{0} (normed_linear_ordered_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_linear_ordered_group.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_20525 (h0 : function.extfun (Type 1) complete_lattice) : @is_atomistic.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} h0 (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_20526 (h0 : complete_lattice (ring (has_add (has_neg_part (boolean_algebra Type))))) : is_compactly_generated (ring (has_add (has_neg_part (boolean_algebra Type)))) := sorry --non-trivial
lemma new_lemma_20527 (h0 : group (random_gen (random_gen fun_info))) : group.fg (random_gen (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_20528 (h0 : topological_space (with_bot (has_top to_additive.value_type))) : totally_separated_space (with_bot (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_20529 (h0 : function.extfun Type (functor.add_const (semiring (cancel_monoid unsigned)))) : @is_noetherian_ring.{0} (cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (semiring.{0} (cancel_monoid.{0} unsigned)) (option.{0} (option.{0} (option.{0} (option.{0} (option.{0} (option.{0} (option.{0} (option.{0} ennreal)))))))) (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (semiring.{0} (cancel_monoid.{0} unsigned))) h0 (option.{0} (option.{0} (option.{0} (option.{0} (option.{0} (option.{0} (option.{0} (option.{0} ennreal))))))))))  := sorry --non-trivial
lemma new_lemma_20530 (h0 : complete_lattice (has_compl (mul_one_class to_additive.value_type))) : complete_lattice.is_Sup_finite_compact (has_compl (mul_one_class to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_20531 (h0 : function.extfun Type topological_space) : @t1_space.{0} (canonically_ordered_comm_semiring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} name))  := sorry --non-trivial
lemma new_lemma_20532 (h0 : topological_space (has_pos_part (has_Inf real))) : topological_space.separable_space (has_pos_part (has_Inf real)) := sorry --non-trivial
lemma new_lemma_20533 (h0 : not (complete_lattice (has_lt string.iterator_imp) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_lt.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_lt.{0} string.iterator_imp)) h0)  := sorry --non-trivial
lemma new_lemma_20534 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_20535 (h0 : list (bin_tree (semiring (semiring (semiring (semiring (semiring empty))))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_20536 (h0 : ring (with_one linarith.comp)) : rank_condition (with_one linarith.comp) := sorry --non-trivial
lemma new_lemma_20537 (h0 : add_group (has_norm linarith.comp_source)) : is_add_cyclic (has_norm linarith.comp_source) := sorry --non-trivial
lemma new_lemma_20538 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (measurable_space.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (measurable_space.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_20539 (h0 : function.extfun Type (functor.add_const (ring Type))) : @is_domain.{1} Type (@functor.add_const.run.{1 0} (ring.{1} Type) pos (@function.extfun_app.{2 2} Type (functor.add_const.{1 0} (ring.{1} Type)) h0 pos))  := sorry --non-trivial
lemma new_lemma_20540 (h0 : function.extfun Type topological_space) : @normal_space.{0} (normed_lattice_add_comm_group.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_lattice_add_comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_20541 (h0 : group (has_norm (random_gen linarith.ineq))) : group.fg (has_norm (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_20542 (h1 : set (semi_normed_ring string_imp)) : set.subsingleton h1 := sorry --non-trivial
lemma new_lemma_20543 (h0 : function.extfun nat fin) : @is_cyclic.{0} (canonically_linear_ordered_monoid.{0} pos) (@matrix.vec_empty.{0} (group.{0} (canonically_linear_ordered_monoid.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_20544 (h0 : functor.add_const (group (linear_order num)) unsigned) : @group.fg.{0} (linear_order.{0} num) (@functor.add_const.run.{0 0} (group.{0} (linear_order.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_20545 (h0 : ring (semi_normed_comm_ring (mul_one_class string_imp))) : strong_rank_condition (semi_normed_comm_ring (mul_one_class string_imp)) := sorry --non-trivial
lemma new_lemma_20546 (h0 : add_monoid (canonically_ordered_add_monoid (option unsigned))) : add_monoid.fg (canonically_ordered_add_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_20547 (h0 : list (random_gen (random_gen (has_inv (has_top (random_gen (has_inv (random_gen linarith.comp_source)))))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_20548 (h0 : functor.add_const (ring (boolean_algebra pos)) linarith.comp) : @rank_condition.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_20549 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (mul_zero_class.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (mul_zero_class.{0} name))  := sorry --non-trivial
lemma new_lemma_20550 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_norm.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_norm.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_20551 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (linear_ordered_field empty)) := sorry --non-trivial
lemma new_lemma_20552 (h0 : function.extfun (Type 1) topological_space) : @totally_separated_space.{1} (complete_distrib_lattice.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (complete_distrib_lattice.{1} Type))  := sorry --non-trivial
lemma new_lemma_20553 (h0 : topological_space (has_inv fun_info)) : totally_disconnected_space (has_inv fun_info) := sorry --non-trivial
lemma new_lemma_20554 (h0 : topological_space (has_zero (boolean_algebra (comm_group pos)))) : regular_space (has_zero (boolean_algebra (comm_group pos))) := sorry --non-trivial
lemma new_lemma_20555 (h0 : ring (complete_distrib_lattice (cancel_monoid Type))) : rank_condition (complete_distrib_lattice (cancel_monoid Type)) := sorry --non-trivial
lemma new_lemma_20556 (h0 : function.extfun (finset Type) (has_mem.mem string_imp)) : @path_connected_space.{0} string_imp (@finset.pi.empty.{1 0} Type topological_space.{0} string_imp (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) string_imp) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_20557 (h0 : topological_space (non_assoc_semiring (semiring unsigned))) : path_connected_space (non_assoc_semiring (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_20558 (h0 : complete_lattice (normed_group (semiring (semiring fun_info)))) : is_compactly_generated (normed_group (semiring (semiring fun_info))) := sorry --non-trivial
lemma new_lemma_20559 (h0 : functor.add_const (ring (finset environment.implicit_infer_kind)) (ring environment.implicit_infer_kind)) : @rank_condition.{0} (finset.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (finset.{0} environment.implicit_infer_kind)) (ring.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_20560 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem ring)) : @rank_condition.{0} (with_bot.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) ring.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (with_bot.{0} num))  := sorry --non-trivial
lemma new_lemma_20561 (h0 : functor.add_const (ordered_add_comm_monoid Type) pos) : @archimedean.{1} Type (@functor.add_const.run.{1 0} (ordered_add_comm_monoid.{1} Type) pos h0)  := sorry --non-trivial
lemma new_lemma_20562 (h0 : functor.add_const (group (preorder congr_arg_kind)) congr_arg_kind) : @normalizer_condition.{0} (preorder.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (group.{0} (preorder.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_20563 (h0 : monoid (has_bot (has_add (has_add pos)))) : monoid.fg (has_bot (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_20564 (h0 : topological_space (ring (has_Inf name))) : sequential_space (ring (has_Inf name)) := sorry --non-trivial
lemma new_lemma_20565 (h0 : fin has_zero.zero) : @totally_separated_space.{1} (boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (boolean_algebra.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_20566 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (complete_distrib_lattice.{0} real) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (complete_distrib_lattice.{0} real))  := sorry --non-trivial
lemma new_lemma_20567 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (has_zero.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_20568 (h0 : has_mem.mem (has_top num) has_emptyc.emptyc) : @path_connected_space.{0} (has_top.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_top.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_20569 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (measurable_space.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (measurable_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_20570 (h0 : list (linear_ordered_comm_group empty)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_20571 (h0 : functor.add_const (uniform_space (has_Inf Type)) linarith.comp) : @separated_space.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (has_Inf.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_20572 (h0 : ring (add_semigroup num)) : strong_rank_condition (add_semigroup num) := sorry --non-trivial
lemma new_lemma_20573 (h0 : topological_space (add_comm_semigroup reducibility_hints)) : path_connected_space (add_comm_semigroup reducibility_hints) := sorry --non-trivial
lemma new_lemma_20574 (h0 : function.extfun Type group) : @group.fg.{0} (has_add.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (has_add.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_20575 (h0 : function.extfun Type (functor.comp topological_space canonically_ordered_comm_semiring)) : @loc_path_connected_space.{0} (canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} canonically_ordered_comm_semiring.{0}) h0 environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_20576 (h0 : topological_space (has_inner empty unsigned)) : t1_space (has_inner empty unsigned) := sorry --non-trivial
lemma new_lemma_20577 (h0 : has_neg (has_inner empty (option empty))) (h1 : measurable_space (has_inner empty (option empty))) : has_measurable_neg (has_inner empty (option empty)) := sorry --non-trivial
lemma new_lemma_20578 (h0 : topological_space (mul_zero_class (finset (finset (has_add pos))))) : totally_disconnected_space (mul_zero_class (finset (finset (has_add pos)))) := sorry --non-trivial
lemma new_lemma_20579 (h0 : filter (add_left_cancel_semigroup unsigned)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_20580 (h0 : monoid (has_pos_part (ring (has_neg Type)))) : monoid.fg (has_pos_part (ring (has_neg Type))) := sorry --non-trivial
lemma new_lemma_20581 (h0 : topological_space (complete_distrib_lattice (complete_distrib_lattice Type))) : topological_space.separable_space (complete_distrib_lattice (complete_distrib_lattice Type)) := sorry --non-trivial
lemma new_lemma_20582 (h0 : topological_space (canonically_ordered_monoid (sub_neg_monoid real))) : normal_space (canonically_ordered_monoid (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_20583 (h0 : topological_space (linear_ordered_comm_group_with_zero to_additive.value_type)) : path_connected_space (linear_ordered_comm_group_with_zero to_additive.value_type) := sorry --non-trivial
lemma new_lemma_20584 (h0 : functor.add_const (filter (canonically_ordered_comm_semiring pos)) Type) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_20585 (h0 : functor.add_const (filter (has_add unsigned)) pos) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_20586 (h0 : functor.add_const (topological_space (has_neg name)) environment.implicit_infer_kind) : @discrete_topology.{0} (has_neg.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_20587 (h0 : uniform_space (pseudo_metric_space environment.implicit_infer_kind)) : complete_space (pseudo_metric_space environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_20588 (h0 : filter to_additive.value_type) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_20589 (h0 : functor.add_const (semiring (free_add_monoid empty)) empty) : @is_noetherian_ring.{0} (free_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (semiring.{0} (free_add_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_20590 (h0 : functor.comp complete_lattice canonically_ordered_comm_semiring name) : @is_compactly_generated.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (canonically_ordered_comm_semiring.{0} name)) name (@functor.comp.run.{0 0 0} complete_lattice.{0} canonically_ordered_comm_semiring.{0} name h0))  := sorry --non-trivial
lemma new_lemma_20591 (h0 : group (has_zero (ring (has_neg pos)))) : is_cyclic (has_zero (ring (has_neg pos))) := sorry --non-trivial
lemma new_lemma_20592 (h0 : semiring (normed_comm_ring (ring (mul_one_class Type)))) : is_noetherian_ring (normed_comm_ring (ring (mul_one_class Type))) := sorry --non-trivial
lemma new_lemma_20593 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (has_bot.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_bot.{0} empty))  := sorry --non-trivial
lemma new_lemma_20594 (h1 : group (has_emptyc to_additive.value_type)) : is_cyclic (has_emptyc to_additive.value_type) := sorry --non-trivial
lemma new_lemma_20595 (h0 : topological_space (simple_graph (ring Type))) : t0_space (simple_graph (ring Type)) := sorry --non-trivial
lemma new_lemma_20596 (h0 : has_mem.mem (has_norm linarith.ineq) has_emptyc.emptyc) : @is_add_cyclic.{0} (has_norm.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type add_group.{0} (has_norm.{0} linarith.ineq) h0)  := sorry --non-trivial
lemma new_lemma_20597 (h0 : complete_lattice (normed_comm_ring (option (option empty)))) : complete_lattice.is_Sup_finite_compact (normed_comm_ring (option (option empty))) := sorry --non-trivial
lemma new_lemma_20598 (h0 : not (add_monoid nnreal -> false)) : add_monoid.fg nnreal := sorry --non-trivial
lemma new_lemma_20599 (h0 : functor.add_const (cancel_comm_monoid_with_zero (complete_distrib_lattice real)) real) : @unique_factorization_monoid.{0} (complete_distrib_lattice.{0} real) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (complete_distrib_lattice.{0} real)) real h0)  := sorry --non-trivial
lemma new_lemma_20600 (h0 : topological_space (canonically_linear_ordered_monoid (has_neg real))) : totally_disconnected_space (canonically_linear_ordered_monoid (has_neg real)) := sorry --non-trivial
lemma new_lemma_20601 (h0 : uniform_space (has_inv (with_zero (comm_ring linarith.ineq)))) : complete_space (has_inv (with_zero (comm_ring linarith.ineq))) := sorry --non-trivial
lemma new_lemma_20602 (h0 : measurable_space (has_compl (mul_one_class fun_info))) (h1 : filter (has_compl (mul_one_class fun_info))) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_20603 (h0 : ring (cancel_monoid (finset (finset environment.implicit_infer_kind)))) : rank_condition (cancel_monoid (finset (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_20604 (h0 : functor.add_const (function.extfun (Type 1) uniform_space) environment.implicit_infer_kind) : @complete_space.{1} (boolean_algebra.core.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) uniform_space.{1}) environment.implicit_infer_kind h0) (boolean_algebra.core.{1} Type))  := sorry --non-trivial
lemma new_lemma_20605 (h0 : ring (canonically_ordered_comm_semiring (semigroup unsigned))) : rank_condition (canonically_ordered_comm_semiring (semigroup unsigned)) := sorry --non-trivial
lemma new_lemma_20606 (h0 : functor.add_const (complete_lattice (normed_comm_ring Type)) environment.implicit_infer_kind) : @complete_lattice.is_Sup_finite_compact.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (normed_comm_ring.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_20607 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_union.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} linarith.comp)))))) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_union.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} linarith.comp)))))))  := sorry --non-trivial
lemma new_lemma_20608 (h0 : group (has_nndist (finset (finset pos)))) : is_simple_group (has_nndist (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_20609 (h0 : fin has_zero.zero) : id (matrix.vec_empty (matrix.vec_empty h0)) := sorry --non-trivial
lemma new_lemma_20610 (h0 : has_neg (option (option (option (option ennreal)))) -> has_neg (option (option (option (option ennreal)))) -> Prop) : is_symm (has_neg (option (option (option (option ennreal))))) h0 := sorry --non-trivial
lemma new_lemma_20611 (h0 : complete_lattice (normed_group linarith.ineq)) : complete_lattice.is_Sup_finite_compact (normed_group linarith.ineq) := sorry --non-trivial
lemma new_lemma_20612 (h0 : complete_lattice (has_star (semiring unsigned))) : complete_lattice.is_Sup_finite_compact (has_star (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_20613 (h0 : functor.comp topological_space ring name) : @normal_space.{0} (ring.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} ring.{0} name h0)  := sorry --non-trivial
lemma new_lemma_20614 (h0 : reducibility_hints -> reducibility_hints -> Prop) : well_founded h0 := sorry --non-trivial
lemma new_lemma_20615 (h1 : group (semi_normed_comm_ring char)) : is_cyclic (semi_normed_comm_ring char) := sorry --non-trivial
lemma new_lemma_20616 (h0 : function.extfun Type ring) : @rank_condition.{0} (add_cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_20617 (h0 : ring (has_one (has_norm linarith.comp))) : strong_rank_condition (has_one (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_20618 (h0 : topological_space (has_nndist unsigned)) : preconnected_space (has_nndist unsigned) := sorry --non-trivial
lemma new_lemma_20619 (h0 : function.extfun Type (functor.comp topological_space boolean_algebra.core)) : @path_connected_space.{0} (boolean_algebra.core.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} boolean_algebra.core.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} boolean_algebra.core.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_20620 (h0 : topological_space (finset (finset (has_neg (ring environment.implicit_infer_kind))))) : regular_space (finset (finset (has_neg (ring environment.implicit_infer_kind)))) := sorry --non-trivial
lemma new_lemma_20621 (h0 : complete_lattice (filter empty)) : complete_lattice.is_Sup_finite_compact (filter empty) := sorry --non-trivial
lemma new_lemma_20622 (h0 : functor.add_const (topological_space (semigroup environment.implicit_infer_kind)) pos) : @locally_compact_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_20623 (h0 : group (random_gen fun_info)) : is_cyclic (random_gen fun_info) := sorry --non-trivial
lemma new_lemma_20624 (h0 : finset (add_comm_monoid (option ennreal))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_20625 (h0 : topological_space (has_nndist (has_to_string Type))) : t0_space (has_nndist (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_20626 (h0 : monoid (has_pos_part (has_Inf (has_add pos)))) : monoid.fg (has_pos_part (has_Inf (has_add pos))) := sorry --non-trivial
lemma new_lemma_20627 (h0 : not (semiring (semiring empty) -> false)) : @is_noetherian_ring.{0} (semiring.{0} empty) (@classical.by_contradiction'.{1} (semiring.{0} (semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_20628 (h3 : ring (distrib linarith.comp_source)) : rank_condition (distrib linarith.comp_source) := sorry --non-trivial
lemma new_lemma_20629 (h0 : topological_space (has_Sup ennreal)) : irreducible_space (has_Sup ennreal) := sorry --non-trivial
lemma new_lemma_20630 (h0 : not (cancel_comm_monoid_with_zero num -> false)) : @unique_factorization_monoid.{0} num (@classical.by_contradiction'.{1} (cancel_comm_monoid_with_zero.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_20631 (h0 : topological_space (add_comm_monoid (option (option (option unsigned))))) : preconnected_space (add_comm_monoid (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_20632 (h0 : topological_space environment.implicit_infer_kind) : preconnected_space environment.implicit_infer_kind := sorry --non-trivial
lemma new_lemma_20633 (h0 : topological_space (finset (has_neg (finset linarith.comp)))) : path_connected_space (finset (has_neg (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_20634 (h0 : not (ring (add_left_cancel_monoid linarith.comp_source) -> false)) : @strong_rank_condition.{0} (add_left_cancel_monoid.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (add_left_cancel_monoid.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_20635 (h0 : functor.add_const (ring (add_cancel_monoid name)) environment.implicit_infer_kind) : @rank_condition.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (add_cancel_monoid.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_20636 (h0 : list (dlist (random_gen (random_gen (random_gen (has_nnnorm (random_gen (random_gen (has_nnnorm fun_info))))))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_20637 (h0 : topological_space (cancel_monoid (semigroup Type))) : preconnected_space (cancel_monoid (semigroup Type)) := sorry --non-trivial
lemma new_lemma_20638 (h0 : functor.add_const (complete_lattice (semigroup empty)) (semiring empty)) : @is_atomistic.{0} (semigroup.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (semigroup.{0} empty)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_20639 (h0 : ring (plift empty)) (h1 : complete_lattice (subring (plift empty))) : is_compactly_generated (subring (plift empty)) := sorry --non-trivial
lemma new_lemma_20640 (h0 : set (string.iterator_imp -> string.iterator_imp)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_20641 (h0 : filter (has_top (has_norm (has_norm (has_norm to_additive.value_type))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_20642 (h0 : function.extfun Type (functor.add_const (complete_lattice (left_cancel_semigroup congr_arg_kind)))) : @is_compactly_generated.{0} (left_cancel_semigroup.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (left_cancel_semigroup.{0} congr_arg_kind)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (complete_lattice.{0} (left_cancel_semigroup.{0} congr_arg_kind))) h0 empty))  := sorry --non-trivial
lemma new_lemma_20643 (h0 : topological_space (complete_distrib_lattice (option empty))) : discrete_topology (complete_distrib_lattice (option empty)) := sorry --non-trivial
lemma new_lemma_20644 (h0 : complete_lattice (has_one (semiring (semiring unsigned)))) : is_atomistic (has_one (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_20645 (h0 : functor.add_const (topological_space (cancel_monoid unsigned)) (has_add pos)) : @locally_compact_space.{0} (cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} unsigned)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_20646 (h0 : functor.add_const (group (finset Type)) name) : @is_cyclic.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (finset.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_20647 (h0 : functor.add_const (topological_space (complete_distrib_lattice environment.implicit_infer_kind)) (ring name)) : @t0_space.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind)) (ring.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_20648 (h1 : complete_lattice (comm_ring to_additive.value_type)) : is_compactly_generated (comm_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_20649 (h0 : filter congr_arg_kind) (h1 : congr_arg_kind -> Prop) : @id.{1} Prop (@filter.limsup.{0 0} Prop congr_arg_kind (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice) h0 h1)  := sorry --non-trivial
lemma new_lemma_20650 (h0 : complete_lattice (random_gen (has_inv (comm_ring linarith.comp_source)))) : is_compactly_generated (random_gen (has_inv (comm_ring linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_20651 (h0 : add_monoid (with_bot unsigned)) (h1 : function.extfun (Type -> Type) (function.extfun Type)) : char_zero (with_bot unsigned) := sorry --non-trivial
lemma new_lemma_20652 (h0 : topological_space (ordered_ring (semiring (semiring empty)))) : loc_path_connected_space (ordered_ring (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_20653 (h0 : complete_lattice (has_zero (finset (semigroup (cancel_monoid name))))) : is_compactly_generated (has_zero (finset (semigroup (cancel_monoid name)))) := sorry --non-trivial
lemma new_lemma_20654 (h0 : topological_space (monoid (option congr_arg_kind))) : irreducible_space (monoid (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_20655 (h1 : not (complete_lattice (uniform_space linarith.comp_source) -> false)) : is_compactly_generated (uniform_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_20656 (h0 : functor.add_const (topological_space (simple_graph pos)) Type) : @regular_space.{0} (simple_graph.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (simple_graph.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_20657 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (ordered_cancel_add_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (ordered_cancel_add_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_20658 (h1 : group (id (semiring (has_norm fun_info)))) : normalizer_condition (id (semiring (has_norm fun_info))) := sorry --non-trivial
lemma new_lemma_20659 (h0 : functor.add_const (topological_space (complete_distrib_lattice unsigned)) linarith.comp) : @regular_space.{0} (complete_distrib_lattice.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_20660 (h0 : group (has_sub (semiring congr_arg_kind))) : is_cyclic (has_sub (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_20661 (h0 : group (has_bot name)) : group.fg (has_bot name) := sorry --non-trivial
lemma new_lemma_20662 (h0 : group (has_Inf (has_neg (has_neg pos)))) : group.fg (has_Inf (has_neg (has_neg pos))) := sorry --non-trivial
lemma new_lemma_20663 (h0 : ring (ordered_comm_group empty)) : strong_rank_condition (ordered_comm_group empty) := sorry --non-trivial
lemma new_lemma_20664 (h0 : pfun (mul_one_class (nondiscrete_normed_field ereal)) Prop) (h1 : coe_sort (pfun.dom h0)) : pfun.as_subtype h0 h1 := sorry --non-trivial
lemma new_lemma_20665 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (linear_ordered_add_comm_group.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_add_comm_group.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_20666 (h0 : functor.add_const (topological_space (add_cancel_monoid environment.implicit_infer_kind)) linarith.comp) : @preconnected_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_20667 (h0 : function.extfun Type (functor.add_const (group (ordered_ring congr_arg_kind)))) : @normalizer_condition.{0} (ordered_ring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (group.{0} (ordered_ring.{0} congr_arg_kind)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (group.{0} (ordered_ring.{0} congr_arg_kind))) h0 empty))  := sorry --non-trivial
lemma new_lemma_20668 (h0 : functor.add_const (topological_space (complete_distrib_lattice ennreal)) num) : @irreducible_space.{0} (complete_distrib_lattice.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} ennreal)) num h0)  := sorry --non-trivial
lemma new_lemma_20669 (h0 : group (group_with_zero num)) : is_cyclic (group_with_zero num) := sorry --non-trivial
lemma new_lemma_20670 (h0 : function.extfun Type topological_space) : @normal_space.{0} (has_pos_part.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_pos_part.{0} name))  := sorry --non-trivial
lemma new_lemma_20671 (h0 : functor.add_const (topological_space (add_comm_monoid name)) environment.implicit_infer_kind) : @discrete_topology.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_20672 (h0 : group (has_zero (comm_group (boolean_algebra Type)))) : is_simple_group (has_zero (comm_group (boolean_algebra Type))) := sorry --non-trivial
lemma new_lemma_20673 (h1 : add_group (semi_normed_ring reducibility_hints)) : is_add_cyclic (semi_normed_ring reducibility_hints) := sorry --non-trivial
lemma new_lemma_20674 (h0 : topological_space (normed_comm_ring (finset (has_add (ring pos))))) : path_connected_space (normed_comm_ring (finset (has_add (ring pos)))) := sorry --non-trivial
lemma new_lemma_20675 (h0 : group (id fun_info)) : group.fg (id fun_info) := sorry --non-trivial
lemma new_lemma_20676 (h0 : not (topological_space (complete_semilattice_Sup empty) -> false)) : @locally_compact_space.{0} (complete_semilattice_Sup.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (complete_semilattice_Sup.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_20677 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : id_rel (function.extfun_app (function.extfun_app h0 (prod fun_info)) fun_info) := sorry --non-trivial
lemma new_lemma_20678 (h0 : filter (distrib linarith.comp_source)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_20679 (h0 : functor.add_const (monoid (semigroup linarith.comp)) pos) : @monoid.fg.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (monoid.{0} (semigroup.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_20680 (h0 : fin has_zero.zero) : @locally_compact_space.{1} (ordered_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@matrix.vec_empty.{2} (function.extfun.{3 2} (Type 1) topological_space.{1}) h0) (ordered_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_20681 (h0 : complete_lattice (linear_order congr_arg_kind)) : is_atomistic (linear_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_20682 (h0 : topological_space (complete_distrib_lattice num)) : locally_compact_space (complete_distrib_lattice num) := sorry --non-trivial
lemma new_lemma_20683 (h0 : functor.add_const (list (preorder unsigned)) (semiring (semiring congr_arg_kind))) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_20684 (h0 : functor.add_const (function.extfun (Type 1) topological_space) linarith.comp) : @sequential_space.{1} (complete_distrib_lattice.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) linarith.comp h0) (complete_distrib_lattice.{1} Type))  := sorry --non-trivial
lemma new_lemma_20685 (h0 : functor.add_const (cancel_comm_monoid_with_zero (ring linarith.comp)) pos) : @unique_factorization_monoid.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (ring.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_20686 (h0 : topological_space (has_Inf (ring pos))) : totally_separated_space (has_Inf (ring pos)) := sorry --non-trivial
lemma new_lemma_20687 (h0 : functor.add_const (filter (comm_group unsigned)) (has_add linarith.comp)) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_20688 (h0 : function.extfun (finset Type) (has_mem.mem (has_top linarith.comp_source))) : @t0_space.{0} (has_top.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_top.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_top.{0} linarith.comp_source)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_20689 (h0 : group (boolean_algebra (has_to_string name))) : normalizer_condition (boolean_algebra (has_to_string name)) := sorry --non-trivial
lemma new_lemma_20690 (h0 : topological_space (linear_ordered_field (has_add ennreal))) : irreducible_space (linear_ordered_field (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_20691 (h0 : semiring (has_bot (has_add Type))) : is_noetherian_ring (has_bot (has_add Type)) := sorry --non-trivial
lemma new_lemma_20692 (h0 : functor.add_const (topological_space (add_cancel_monoid linarith.comp)) (has_Inf linarith.comp)) : @totally_disconnected_space.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} linarith.comp)) (has_Inf.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_20693 (h0 : filter (has_edist empty)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_20694 (h0 : topological_space (add_cancel_monoid (comm_group (semigroup name)))) : preirreducible_space (add_cancel_monoid (comm_group (semigroup name))) := sorry --non-trivial
lemma new_lemma_20695 (h0 : topological_space (has_dist congr_arg_kind)) : totally_disconnected_space (has_dist congr_arg_kind) := sorry --non-trivial
lemma new_lemma_20696 (h0 : topological_space (topological_space (topological_space char))) : t0_space (topological_space (topological_space char)) := sorry --non-trivial
lemma new_lemma_20697 (h0 : topological_space (comm_group (add_comm_monoid Type))) : sequential_space (comm_group (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_20698 (h0 : cancel_comm_monoid_with_zero (has_bot (has_Inf (has_Inf Type)))) : unique_factorization_monoid (has_bot (has_Inf (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_20699 (h1 : semiring linarith.ineq) (h2 : ideal linarith.ineq) : ideal.is_prime h2 := sorry --non-trivial
lemma new_lemma_20700 (h0 : functor.add_const (ordered_comm_monoid (finset environment.implicit_infer_kind)) Type) : @has_exists_mul_of_le.{0} (finset.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (finset.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_20701 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (denumerable.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (denumerable.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_20702 (h0 : ring (measurable_space fun_info)) : strong_rank_condition (measurable_space fun_info) := sorry --non-trivial
lemma new_lemma_20703 (h0 : topological_space (normed_lattice_add_comm_group (has_add (has_add Type)))) : normal_space (normed_lattice_add_comm_group (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_20704 (h0 : functor.add_const (topological_space (ordered_comm_ring pos)) (has_add linarith.comp)) : @preirreducible_space.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} pos)) (has_add.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_20705 (h0 : filter (has_pos_part (has_nndist (has_add linarith.comp)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_20706 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (generalized_boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (generalized_boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_20707 (h0 : filter (linear_ordered_field (option pos))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_20708 (h0 : uniform_space (id fun_info)) : separated_space (id fun_info) := sorry --non-trivial
lemma new_lemma_20709 (h0 : functor.add_const (ring (ring linarith.comp)) environment.implicit_infer_kind) : @is_principal_ideal_ring.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (ring.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_20710 (h0 : group (measurable_space unsigned)) : group.fg (measurable_space unsigned) := sorry --non-trivial
lemma new_lemma_20711 (h0 : topological_space (has_nndist (normed_comm_ring name))) : sequential_space (has_nndist (normed_comm_ring name)) := sorry --non-trivial
lemma new_lemma_20712 (h0 : uniform_space (has_emptyc fun_info)) : complete_space (has_emptyc fun_info) := sorry --non-trivial
lemma new_lemma_20713 (h0 : monoid (measurable_space (has_top (has_top (has_top linarith.comp_source))))) : monoid.fg (measurable_space (has_top (has_top (has_top linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_20714 (h0 : functor.add_const (ring (mul_zero_class unsigned)) congr_arg_kind) : @rank_condition.{0} (mul_zero_class.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (mul_zero_class.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_20715 (h0 : functor.comp uniform_space comm_group Type) : @separated_space.{1} (comm_group.{1} Type) (@functor.comp.run.{1 1 1} uniform_space.{1} comm_group.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_20716 (h0 : not (finset (complete_linear_order empty) -> false)) : finset.nonempty (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_20717 (h0 : functor.add_const (monoid (has_nndist ennreal)) pos) : @monoid.fg.{0} (has_nndist.{0} ennreal) (@functor.add_const.run.{0 0} (monoid.{0} (has_nndist.{0} ennreal)) pos h0)  := sorry --non-trivial
lemma new_lemma_20718 (h0 : add_group (finset (option (option (option (option empty)))))) : is_add_cyclic (finset (option (option (option (option empty))))) := sorry --non-trivial
lemma new_lemma_20719 (h0 : functor.add_const (functor.add_const (finset (measurable_space.dynkin_system unsigned)) empty) num) : finset.nonempty (functor.add_const.run (functor.add_const.run h0)) := sorry --non-trivial
lemma new_lemma_20720 (h1 : ring (semi_normed_comm_ring (random_gen (has_nnnorm (has_nnnorm string_imp))))) : rank_condition (semi_normed_comm_ring (random_gen (has_nnnorm (has_nnnorm string_imp)))) := sorry --non-trivial
lemma new_lemma_20721 (h0 : topological_space (canonically_linear_ordered_monoid (option (option ennreal)))) : irreducible_space (canonically_linear_ordered_monoid (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_20722 (h0 : group (has_norm (random_gen (semiring num)))) : normalizer_condition (has_norm (random_gen (semiring num))) := sorry --non-trivial
lemma new_lemma_20723 (h0 : functor.add_const (list Type) unsigned) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_20724 (h0 : functor.add_const (topological_space (has_dist empty)) unsigned) : @path_connected_space.{0} (has_dist.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_dist.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_20725 (h0 : not (topological_space (uniform_space (add_cancel_comm_monoid linarith.comp_source)) -> false)) : @totally_disconnected_space.{0} (uniform_space.{0} (add_cancel_comm_monoid.{0} linarith.comp_source)) (@classical.by_contradiction'.{1} (topological_space.{0} (uniform_space.{0} (add_cancel_comm_monoid.{0} linarith.comp_source))) h0)  := sorry --non-trivial
lemma new_lemma_20726 (h0 : topological_space (has_neg (finset (has_pos_part name)))) : irreducible_space (has_neg (finset (has_pos_part name))) := sorry --non-trivial
lemma new_lemma_20727 (h0 : ring (has_nndist (finset linarith.comp))) : rank_condition (has_nndist (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_20728 (h0 : topological_space (complete_linear_order (semiring (semiring unsigned)))) : topological_space.separable_space (complete_linear_order (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_20729 (h0 : not (monoid (has_star num) -> false)) : @monoid.fg.{0} (has_star.{0} num) (@classical.by_contradiction'.{1} (monoid.{0} (has_star.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_20730 (h0 : group (cancel_monoid (has_add (has_nndist Type)))) : group.fg (cancel_monoid (has_add (has_nndist Type))) := sorry --non-trivial
lemma new_lemma_20731 (h0 : functor.add_const (complete_lattice (ring linarith.comp)) (mul_one_class Type)) : @is_compactly_generated.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (complete_lattice.{0} (ring.{0} linarith.comp)) (mul_one_class.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_20732 (h1 : has_neg reducibility_hints) (h2 : measurable_space reducibility_hints) : has_measurable_neg reducibility_hints := sorry --non-trivial
lemma new_lemma_20733 (h0 : topological_space (has_bot (has_neg name))) : preirreducible_space (has_bot (has_neg name)) := sorry --non-trivial
lemma new_lemma_20734 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (add_comm_monoid.{0} (option.{0} pos)) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_comm_monoid.{0} (option.{0} pos)))  := sorry --non-trivial
lemma new_lemma_20735 (h0 : function.extfun Type (functor.add_const (list auto.case_option))) : list.nodup (functor.add_const.run (function.extfun_app h0 unsigned)) := sorry --non-trivial
lemma new_lemma_20736 (h0 : function.extfun (finset Type) (has_mem.mem string_imp)) : @is_domain.{0} string_imp (@finset.pi.empty.{1 0} Type ring.{0} string_imp (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) string_imp) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_20737 (h0 : uniform_space (linear_ordered_field (option empty))) : separated_space (linear_ordered_field (option empty)) := sorry --non-trivial
lemma new_lemma_20738 (h0 : functor.add_const (ring ennreal) num) : @is_principal_ideal_ring.{0} ennreal (@functor.add_const.run.{0 0} (ring.{0} ennreal) num h0)  := sorry --non-trivial
lemma new_lemma_20739 (h0 : group (has_ssubset (has_top string_imp))) : group.fg (has_ssubset (has_top string_imp)) := sorry --non-trivial
lemma new_lemma_20740 (h0 : topological_space (has_compl (mul_one_class linarith.ineq))) : path_connected_space (has_compl (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_20741 (h0 : fin has_zero.zero) : @irreducible_space.{0} (ordered_comm_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_monoid.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_20742 (h0 : functor.comp ring pseudo_metric_space (option (option pos))) : @strong_rank_condition.{0} (pseudo_metric_space.{0} (option.{0} (option.{0} pos))) (@functor.comp.run.{0 0 0} ring.{0} pseudo_metric_space.{0} (option.{0} (option.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_20743 (h0 : function.extfun (Type 1) cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1} h0 (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_20744 (h0 : uniform_space (semigroup (has_add (has_add (finset linarith.comp))))) : complete_space (semigroup (has_add (has_add (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_20745 (h0 : topological_space (has_add fun_info)) (h1 : preorder (has_add fun_info)) : order_topology (has_add fun_info) := sorry --non-trivial
lemma new_lemma_20746 (h0 : fin has_zero.zero) : @complete_lattice.is_Sup_finite_compact.{0} (has_bot.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (has_bot.{0} name))  := sorry --non-trivial
lemma new_lemma_20747 (h0 : functor.add_const (topological_space (finset name)) environment.implicit_infer_kind) : @path_connected_space.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_20748 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (has_zero.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_zero.{0} num))  := sorry --non-trivial
lemma new_lemma_20749 (h0 : has_lt (mul_one_class fun_info)) : no_max_order (mul_one_class fun_info) := sorry --non-trivial
lemma new_lemma_20750 (h0 : topological_space (has_neg_part (ring pos))) : regular_space (has_neg_part (ring pos)) := sorry --non-trivial
lemma new_lemma_20751 (h0 : functor.add_const (topological_space (complete_distrib_lattice name)) linarith.comp) : @sequential_space.{0} (complete_distrib_lattice.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_20752 (h0 : multiset (linear_ordered_comm_monoid_with_zero (option (option (filter unsigned))))) : multiset.nodup h0 := sorry --non-trivial
lemma new_lemma_20753 (h0 : complete_lattice (has_emptyc (has_inv (has_inv linarith.ineq)))) : is_atomistic (has_emptyc (has_inv (has_inv linarith.ineq))) := sorry --non-trivial
lemma new_lemma_20754 (h0 : ring (semigroup (finset (has_add Type)))) : rank_condition (semigroup (finset (has_add Type))) := sorry --non-trivial
lemma new_lemma_20755 (h0 : ring (has_neg (option (option ennreal)))) : rank_condition (has_neg (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_20756 (h0 : topological_space (normed_group (has_norm (has_emptyc num)))) : locally_compact_space (normed_group (has_norm (has_emptyc num))) := sorry --non-trivial
lemma new_lemma_20757 (h0 : add_group (has_one congr_arg_kind)) : is_add_cyclic (has_one congr_arg_kind) := sorry --non-trivial
lemma new_lemma_20758 (h0 : ring (add_comm_monoid (semiring empty))) : strong_rank_condition (add_comm_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_20759 (h0 : functor.add_const (topological_space (mul_zero_class Type)) Type) : @path_connected_space.{1} (mul_zero_class.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (mul_zero_class.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_20760 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (with_zero fun_info)) := sorry --non-trivial
lemma new_lemma_20761 (h0 : group (preorder congr_arg_kind)) : is_cyclic (preorder congr_arg_kind) := sorry --non-trivial
lemma new_lemma_20762 (h0 : list (has_nndist (boolean_algebra.core (option name)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_20763 (h0 : add_monoid (boolean_algebra (has_neg_part name))) : add_monoid.fg (boolean_algebra (has_neg_part name)) := sorry --non-trivial
lemma new_lemma_20764 (h0 : topological_space (dlist (random_gen (random_gen (random_gen to_additive.value_type))))) : locally_compact_space (dlist (random_gen (random_gen (random_gen to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_20765 (h0 : preorder (std_gen -> std_gen -> Prop)) (h1 : preorder std_gen) (h2 : (std_gen -> std_gen -> Prop) -> std_gen) : antitone_on h2 (is_preorder std_gen) := sorry --non-trivial
lemma new_lemma_20766 (h0 : set std_gen) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_20767 (h0 : functor.add_const (complete_lattice (simple_graph linarith.comp)) linarith.comp) : @is_compactly_generated.{0} (simple_graph.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (simple_graph.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_20768 (h0 : topological_space (ordered_comm_monoid (ring linarith.comp))) : preirreducible_space (ordered_comm_monoid (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_20769 (h0 : topological_space (has_norm linarith.ineq)) : totally_disconnected_space (has_norm linarith.ineq) := sorry --non-trivial
lemma new_lemma_20770 (h0 : topological_space (normed_group (semiring (semiring empty)))) : t0_space (normed_group (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_20771 (h0 : functor.add_const (function.extfun Type list) Type) : palindrome (function.extfun_app (functor.add_const.run h0) (semigroup linarith.comp)) := sorry --non-trivial
lemma new_lemma_20772 (h0 : linear_ordered_field (option ennreal) -> linear_ordered_field (option ennreal) -> Prop) : reflexive h0 := sorry --non-trivial
lemma new_lemma_20773 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (has_to_string.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_to_string.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_20774 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (semi_normed_comm_ring.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (semi_normed_comm_ring.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_20775 (h0 : is_empty (environment.projection_info -> linarith.ineq)) : set.separates_points (is_empty.elim h0) := sorry --non-trivial
lemma new_lemma_20776 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_emptyc.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_emptyc.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_20777 (h0 : ordered_comm_monoid (ring environment.implicit_infer_kind)) : has_exists_mul_of_le (ring environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_20778 (h0 : functor.add_const (uniform_space (option empty)) empty) : @separated_space.{0} (option.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (option.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_20779 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_20780 (h0 : filter (bin_tree (has_norm empty))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_20781 (h0 : list (normed_linear_ordered_group congr_arg_kind)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_20782 (h0 : topological_space (as_linear_order (comm_monoid empty))) : t0_space (as_linear_order (comm_monoid empty)) := sorry --non-trivial
lemma new_lemma_20783 (h0 : group (complete_semilattice_Sup (random_gen linarith.comp_source))) : is_cyclic (complete_semilattice_Sup (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_20784 (h0 : functor.comp ring add_cancel_monoid environment.implicit_infer_kind) : @rank_condition.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} ring.{0} add_cancel_monoid.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_20785 (h0 : topological_space (with_zero (has_ssubset linarith.ineq))) : totally_disconnected_space (with_zero (has_ssubset linarith.ineq)) := sorry --non-trivial
lemma new_lemma_20786 (h0 : functor.add_const (ring (semigroup name)) name) : @rank_condition.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (semigroup.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_20787 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (sub_neg_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (sub_neg_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_20788 (h0 : functor.add_const (topological_space (has_to_string linarith.comp)) linarith.comp) : @t1_space.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_20789 (h0 : ring (denumerable (add_right_cancel_monoid (random_gen string_imp)))) : is_domain (denumerable (add_right_cancel_monoid (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_20790 (h0 : fin has_zero.zero) : @irreducible_space.{1} (complete_distrib_lattice.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (complete_distrib_lattice.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_20791 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_20792 (h0 : functor.add_const (complete_lattice (ring environment.implicit_infer_kind)) linarith.comp) : @is_compactly_generated.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ring.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_20793 (h1 : topological_space (denumerable (group_with_zero string_imp))) : t0_space (denumerable (group_with_zero string_imp)) := sorry --non-trivial
lemma new_lemma_20794 (h0 : functor.add_const (add_group (normed_comm_ring Type)) name) : @is_add_cyclic.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (add_group.{1} (normed_comm_ring.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_20795 (h0 : group (has_neg (finset (finset (finset pos))))) : is_simple_group (has_neg (finset (finset (finset pos)))) := sorry --non-trivial
lemma new_lemma_20796 (h0 : topological_space (has_pos_part (has_neg Type))) : normal_space (has_pos_part (has_neg Type)) := sorry --non-trivial
lemma new_lemma_20797 (h0 : functor.add_const (function.extfun Type monoid) (has_neg Type)) : @monoid.fg.{0} (add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type monoid.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type monoid.{0}) (has_neg.{1} Type) h0) (add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_20798 (h0 : functor.add_const (topological_space (ordered_comm_group unsigned)) unsigned) : @preirreducible_space.{0} (ordered_comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_group.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_20799 (h0 : finset (has_zero congr_arg_kind)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_20800 (h0 : complete_lattice (partial_order (semiring empty))) : complete_lattice.is_Sup_finite_compact (partial_order (semiring empty)) := sorry --non-trivial
lemma new_lemma_20801 (h0 : uniform_space (ordered_comm_ring (has_neg pos))) : separated_space (ordered_comm_ring (has_neg pos)) := sorry --non-trivial
lemma new_lemma_20802 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (has_dist.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_dist.{0} empty))  := sorry --non-trivial
lemma new_lemma_20803 (h0 : functor.add_const (function.extfun Type cancel_comm_monoid_with_zero) name) : @unique_factorization_monoid.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type cancel_comm_monoid_with_zero.{0}) name h0) (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_20804 (h0 : group (generalized_boolean_algebra (has_add (has_add (has_add linarith.comp))))) : is_simple_group (generalized_boolean_algebra (has_add (has_add (has_add linarith.comp)))) := sorry --non-trivial
lemma new_lemma_20805 (h0 : topological_space (has_inner empty num)) : irreducible_space (has_inner empty num) := sorry --non-trivial
lemma new_lemma_20806 (h1 : ring (normed_field (metric_space to_additive.value_type))) : is_domain (normed_field (metric_space to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_20807 (h0 : function.extfun Type group) : @is_cyclic.{0} (monoid_with_zero.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (monoid_with_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_20808 (h0 : ring (bin_tree (ordered_cancel_comm_monoid unsigned))) : strong_rank_condition (bin_tree (ordered_cancel_comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_20809 (h0 : functor.add_const Prop (ordered_comm_ring (ring (ring (has_pos_part (ring (ring Type))))))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_20810 (h0 : ring (normed_lattice_add_comm_group Type)) : is_principal_ideal_ring (normed_lattice_add_comm_group Type) := sorry --non-trivial
lemma new_lemma_20811 (h0 : functor.comp ring option pos) : @is_domain.{0} (option.{0} pos) (@functor.comp.run.{0 0 0} ring.{0} option.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_20812 (h0 : group (canonically_linear_ordered_monoid (option pos))) : is_cyclic (canonically_linear_ordered_monoid (option pos)) := sorry --non-trivial
lemma new_lemma_20813 (h0 : not (topological_space (complete_semilattice_Sup num) -> false)) : @t0_space.{0} (complete_semilattice_Sup.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (complete_semilattice_Sup.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_20814 (h0 : function.extfun Type group) : @group.fg.{0} (linear_ordered_semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} h0 (linear_ordered_semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_20815 (h0 : topological_space (canonically_linear_ordered_monoid (has_Inf real))) : discrete_topology (canonically_linear_ordered_monoid (has_Inf real)) := sorry --non-trivial
lemma new_lemma_20816 (h0 : topological_space (random_gen (mul_one_class reducibility_hints))) : totally_disconnected_space (random_gen (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_20817 (h0 : filter (measurable_space.dynkin_system (semiring num))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_20818 (h0 : group (random_gen (random_gen linarith.comp_source))) : normalizer_condition (random_gen (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_20819 (h1 : complete_lattice (distrib fun_info)) : complete_lattice.is_Sup_finite_compact (distrib fun_info) := sorry --non-trivial
lemma new_lemma_20820 (h0 : group (has_zero linarith.comp)) : is_simple_group (has_zero linarith.comp) := sorry --non-trivial
lemma new_lemma_20821 (h0 : topological_space (add_comm_monoid pos)) : discrete_topology (add_comm_monoid pos) := sorry --non-trivial
lemma new_lemma_20822 (h4 : group linarith.comp_source) : group.fg linarith.comp_source := sorry --non-trivial
lemma new_lemma_20823 (h0 : group (comm_group (has_add (has_add Type)))) : group.fg (comm_group (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_20824 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (add_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_20825 (h0 : topological_space (linear_ordered_field num)) : path_connected_space (linear_ordered_field num) := sorry --non-trivial
lemma new_lemma_20826 (h0 : not (function.extfun Type group -> false)) : @group.fg.{0} (semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_20827 (h0 : group (comm_group (has_to_string (has_add name)))) : group.fg (comm_group (has_to_string (has_add name))) := sorry --non-trivial
lemma new_lemma_20828 (h0 : fin has_zero.zero) : @complete_lattice.is_Sup_finite_compact.{0} (normed_lattice_add_comm_group.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (normed_lattice_add_comm_group.{0} name))  := sorry --non-trivial
lemma new_lemma_20829 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (has_union.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_union.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_20830 (h0 : topological_space (has_union (semiring (semiring (semiring (semiring empty)))))) : totally_separated_space (has_union (semiring (semiring (semiring (semiring empty))))) := sorry --non-trivial
lemma new_lemma_20831 (h0 : monoid (comm_group (finset Type))) : monoid.fg (comm_group (finset Type)) := sorry --non-trivial
lemma new_lemma_20832 (h0 : monoid (with_one (has_inv (has_inv (has_inv (has_inv to_additive.value_type)))))) : monoid.fg (with_one (has_inv (has_inv (has_inv (has_inv to_additive.value_type))))) := sorry --non-trivial
lemma new_lemma_20833 (h0 : topological_space (sub_neg_monoid (has_add pos))) : loc_path_connected_space (sub_neg_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_20834 (h0 : topological_space (metric_space (semiring empty))) : totally_disconnected_space (metric_space (semiring empty)) := sorry --non-trivial
lemma new_lemma_20835 (h0 : group (ordered_cancel_add_comm_monoid ennreal)) : is_cyclic (ordered_cancel_add_comm_monoid ennreal) := sorry --non-trivial
lemma new_lemma_20836 (h0 : function.extfun Type (functor.comp add_group mul_zero_class)) : @is_add_cyclic.{0} (mul_zero_class.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} add_group.{0} mul_zero_class.{0} environment.implicit_infer_kind (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} add_group.{0} mul_zero_class.{0}) h0 environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_20837 (h0 : functor.add_const (topological_space linarith.comp) (finset linarith.comp)) : @irreducible_space.{0} linarith.comp (@functor.add_const.run.{0 0} (topological_space.{0} linarith.comp) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_20838 (h0 : function.extfun Type (functor.comp topological_space has_neg)) : @preirreducible_space.{0} (has_neg.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} pos (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} has_neg.{0}) h0 pos)))  := sorry --non-trivial
lemma new_lemma_20839 (h0 : functor.add_const (group (partial_order num)) num) : @group.fg.{0} (partial_order.{0} num) (@functor.add_const.run.{0 0} (group.{0} (partial_order.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_20840 (h0 : topological_space (has_lt linarith.ineq)) : totally_disconnected_space (has_lt linarith.ineq) := sorry --non-trivial
lemma new_lemma_20841 (h0 : group (has_zero (semigroup linarith.comp))) : group.fg (has_zero (semigroup linarith.comp)) := sorry --non-trivial
lemma new_lemma_20842 (h0 : topological_space (add_cancel_monoid linarith.comp)) : t1_space (add_cancel_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_20843 (h0 : topological_space (semigroup (measurable_space pos))) : path_connected_space (semigroup (measurable_space pos)) := sorry --non-trivial
lemma new_lemma_20844 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (topological_space.{0} linarith.ineq) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (topological_space.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_20845 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @discrete_topology.{1} (simple_graph.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (simple_graph.{1} Type))  := sorry --non-trivial
lemma new_lemma_20846 (h1 : group (has_compl (random_gen string_imp))) : group.fg (has_compl (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_20847 (h0 : topological_space (boolean_algebra (has_Inf (finset (has_neg (finset pos)))))) : irreducible_space (boolean_algebra (has_Inf (finset (has_neg (finset pos))))) := sorry --non-trivial
lemma new_lemma_20848 (h0 : not (add_group (measurable_space empty) -> false)) : @is_add_cyclic.{0} (measurable_space.{0} empty) (@classical.by_contradiction'.{1} (add_group.{0} (measurable_space.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_20849 (h0 : ring (partial_order unsigned)) : is_principal_ideal_ring (partial_order unsigned) := sorry --non-trivial
lemma new_lemma_20850 (h0 : functor.add_const (topological_space (left_cancel_semigroup num)) unsigned) : @t0_space.{0} (left_cancel_semigroup.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_semigroup.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_20851 (h0 : ring (canonically_linear_ordered_monoid (has_neg (has_neg name)))) : strong_rank_condition (canonically_linear_ordered_monoid (has_neg (has_neg name))) := sorry --non-trivial
lemma new_lemma_20852 (h0 : functor.add_const (functor.add_const (list pos) pos) Type) : palindrome (functor.add_const.run (functor.add_const.run h0)) := sorry --non-trivial
lemma new_lemma_20853 (h0 : topological_space (has_neg (has_to_string name))) : preirreducible_space (has_neg (has_to_string name)) := sorry --non-trivial
lemma new_lemma_20854 (h0 : functor.add_const (topological_space (mul_zero_class unsigned)) empty) : @discrete_topology.{0} (mul_zero_class.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_20855 (h0 : set (set environment.projection_info)) (h1 : set environment.projection_info) : measurable_space.dynkin_system.generate_has h0 h1 := sorry --non-trivial
lemma new_lemma_20856 (h0 : ring empty) : is_domain empty := sorry --non-trivial
lemma new_lemma_20857 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (has_norm.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_norm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_20858 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type monoid.{0} h0 (semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_20859 (h0 : functor.add_const (group (has_Inf pos)) pos) : @is_cyclic.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_Inf.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_20860 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (add_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_20861 (h1 : ring (semi_normed_ring (normed_field (has_nnnorm reducibility_hints)))) : strong_rank_condition (semi_normed_ring (normed_field (has_nnnorm reducibility_hints))) := sorry --non-trivial
lemma new_lemma_20862 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : countable_Inter_filter (function.extfun_app (function.extfun_app h0 filter) (has_nndist ennreal)) := sorry --non-trivial
lemma new_lemma_20863 (h0 : group (simple_graph congr_arg_kind)) : is_cyclic (simple_graph congr_arg_kind) := sorry --non-trivial
lemma new_lemma_20864 (h0 : semiring to_additive.value_type) (h1 : list (ring (polynomial to_additive.value_type))) (h2 : ne h1 list.nil) : @rank_condition.{0} (@polynomial.{0} to_additive.value_type h0) (@list.last.{0} (ring.{0} (@polynomial.{0} to_additive.value_type h0)) h1 h2)  := sorry --non-trivial
lemma new_lemma_20865 (h0 : functor.add_const (function.extfun (Type 1) group) pos) : @group.fg.{1} (complete_distrib_lattice.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) group.{1}) pos h0) (complete_distrib_lattice.{1} Type))  := sorry --non-trivial
lemma new_lemma_20866 (h0 : ring (simple_graph congr_arg_kind)) : rank_condition (simple_graph congr_arg_kind) := sorry --non-trivial
lemma new_lemma_20867 (h0 : semiring (linear_order (semiring (semiring empty)))) : is_noetherian_ring (linear_order (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_20868 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (boolean_algebra.core.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_20869 (h1 : not (topological_space (complete_semilattice_Sup linarith.comp) -> false)) : @discrete_topology.{0} (complete_semilattice_Sup.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (complete_semilattice_Sup.{0} linarith.comp)) h1)  := sorry --non-trivial
lemma new_lemma_20870 (h0 : topological_space (has_to_string ennreal)) : discrete_topology (has_to_string ennreal) := sorry --non-trivial
lemma new_lemma_20871 (h0 : group (distrib (has_nnnorm linarith.comp_source))) : is_cyclic (distrib (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_20872 (h0 : functor.add_const (topological_space (cancel_monoid unsigned)) empty) : @t1_space.{0} (cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_20873 (h0 : complete_lattice (canonically_ordered_monoid (sub_neg_monoid pos))) : is_atomistic (canonically_ordered_monoid (sub_neg_monoid pos)) := sorry --non-trivial
lemma new_lemma_20874 (h1 : topological_space linarith.ineq) : preirreducible_space linarith.ineq := sorry --non-trivial
lemma new_lemma_20875 (h0 : complete_lattice (normed_field enat)) : complete_lattice.is_Sup_finite_compact (normed_field enat) := sorry --non-trivial
lemma new_lemma_20876 (h0 : ordered_comm_monoid (ordered_comm_ring (has_neg (has_neg (has_neg name))))) : has_exists_mul_of_le (ordered_comm_ring (has_neg (has_neg (has_neg name)))) := sorry --non-trivial
lemma new_lemma_20877 (h0 : monoid (has_sub congr_arg_kind)) : monoid.fg (has_sub congr_arg_kind) := sorry --non-trivial
lemma new_lemma_20878 (h0 : topological_space (has_neg pos)) : regular_space (has_neg pos) := sorry --non-trivial
lemma new_lemma_20879 (h0 : functor.add_const (topological_space (cancel_monoid pos)) ennreal) : @totally_separated_space.{0} (cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} pos)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_20880 (h0 : uniform_space (semigroup (has_neg_part Type))) : separated_space (semigroup (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_20881 (h0 : ring (linear_ordered_add_comm_group linarith.comp_source)) : strong_rank_condition (linear_ordered_add_comm_group linarith.comp_source) := sorry --non-trivial
lemma new_lemma_20882 (h0 : functor.add_const (group (has_nndist linarith.comp)) pos) : @is_cyclic.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (has_nndist.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_20883 (h0 : functor.add_const (cancel_comm_monoid_with_zero (mul_zero_class num)) (semiring num)) : @unique_factorization_monoid.{0} (mul_zero_class.{0} num) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (mul_zero_class.{0} num)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_20884 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_20885 (h0 : function.extfun nat fin) : @totally_separated_space.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_20886 (h0 : topological_space (has_zero fun_info)) : totally_disconnected_space (has_zero fun_info) := sorry --non-trivial
lemma new_lemma_20887 (h0 : topological_space (boolean_algebra (has_pos_part (ring pos)))) : t0_space (boolean_algebra (has_pos_part (ring pos))) := sorry --non-trivial
lemma new_lemma_20888 (h1 : group (add_comm_semigroup ereal)) (h2 : has_lt (group_topology (add_comm_semigroup ereal))) : no_max_order (group_topology (add_comm_semigroup ereal)) := sorry --non-trivial
lemma new_lemma_20889 (h0 : functor.add_const (ring (boolean_algebra pos)) name) : @rank_condition.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_20890 (h0 : group (random_gen (has_inv linarith.ineq))) : is_cyclic (random_gen (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_20891 (h0 : not (topological_space (with_bot (semiring (semiring (semiring (semiring empty))))) -> false)) : @t1_space.{0} (with_bot.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} empty))))) (@classical.by_contradiction'.{1} (topological_space.{0} (with_bot.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} empty)))))) h0)  := sorry --non-trivial
lemma new_lemma_20892 (h0 : ordered_add_comm_monoid (add_comm_monoid (has_add (has_add (has_pos_part Type))))) : archimedean (add_comm_monoid (has_add (has_add (has_pos_part Type)))) := sorry --non-trivial
lemma new_lemma_20893 (h0 : monoid (has_pos_part (has_neg Type))) : monoid.fg (has_pos_part (has_neg Type)) := sorry --non-trivial
lemma new_lemma_20894 (h0 : group (semi_normed_comm_ring reducibility_hints)) : is_cyclic (semi_normed_comm_ring reducibility_hints) := sorry --non-trivial
lemma new_lemma_20895 (h0 : group (has_to_string (has_add name))) : is_cyclic (has_to_string (has_add name)) := sorry --non-trivial
lemma new_lemma_20896 (h0 : not (add_group (plift unsigned) -> false)) : @is_add_cyclic.{1} (plift.{1} unsigned) (@classical.by_contradiction'.{2} (add_group.{1} (plift.{1} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_20897 (h0 : not (ring (partial_order congr_arg_kind) -> false)) : @is_domain.{0} (partial_order.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (ring.{0} (partial_order.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_20898 (h0 : functor.add_const (topological_space (left_cancel_monoid unsigned)) unsigned) : @irreducible_space.{0} (left_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_20899 (h0 : topological_space (simple_graph linarith.comp)) : totally_disconnected_space (simple_graph linarith.comp) := sorry --non-trivial
lemma new_lemma_20900 (h0 : not (complete_lattice (random_gen char) -> false)) : @is_compactly_generated.{0} (random_gen.{0} char) (@classical.by_contradiction'.{1} (complete_lattice.{0} (random_gen.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_20901 (h0 : topological_space (semigroup unsigned)) : sequential_space (semigroup unsigned) := sorry --non-trivial
lemma new_lemma_20902 (h0 : topological_space (has_top (has_nnnorm fun_info))) : t0_space (has_top (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_20903 (h0 : filter (dlist (random_gen (has_norm to_additive.value_type)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_20904 (h0 : fin has_zero.zero) : @t1_space.{0} (complete_distrib_lattice.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (complete_distrib_lattice.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_20905 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (free_add_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (free_add_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_20906 (h0 : monoid (has_add (has_to_string pos))) : monoid.fg (has_add (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_20907 (h0 : ring (uniform_space (uniform_space linarith.comp_source))) : strong_rank_condition (uniform_space (uniform_space linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_20908 (h0 : functor.add_const (cancel_comm_monoid_with_zero (add_cancel_monoid pos)) linarith.comp) : @unique_factorization_monoid.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (add_cancel_monoid.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_20909 (h0 : functor.add_const (complete_lattice (pseudo_metric_space unsigned)) congr_arg_kind) : @complete_lattice.is_Sup_finite_compact.{0} (pseudo_metric_space.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (pseudo_metric_space.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_20910 (h0 : filter (boolean_algebra (finset linarith.comp))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_20911 (h2 : group (add_left_cancel_monoid to_additive.value_type)) : is_cyclic (add_left_cancel_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_20912 (h0 : topological_space (boolean_algebra (has_Inf pos))) : t1_space (boolean_algebra (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_20913 (h0 : topological_space (ordered_comm_ring (sub_neg_monoid real))) : loc_path_connected_space (ordered_comm_ring (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_20914 (h0 : topological_space (has_div (mul_one_class string.iterator_imp))) : t0_space (has_div (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_20915 (h0 h1 : nat) (h2 : eq h0 (has_add.add h1 h1)) (h3 : fin h0 -> Prop) (h4 : fin h1) : id (matrix.vec_alt0 h2 h3 (id h4)) := sorry --non-trivial
lemma new_lemma_20916 (h0 : topological_space (comm_group (has_neg_part (has_neg_part pos)))) : t1_space (comm_group (has_neg_part (has_neg_part pos))) := sorry --non-trivial
lemma new_lemma_20917 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_zero.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_zero.{0} num))  := sorry --non-trivial
lemma new_lemma_20918 (h0 : function.extfun Type topological_space) : @t0_space.{0} (distrib_lattice.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (distrib_lattice.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_20919 (h0 : ring (semi_normed_comm_ring (uniform_space (has_ssubset linarith.ineq)))) : strong_rank_condition (semi_normed_comm_ring (uniform_space (has_ssubset linarith.ineq))) := sorry --non-trivial
lemma new_lemma_20920 (h0 : monoid (normed_comm_ring (has_add name))) : monoid.fg (normed_comm_ring (has_add name)) := sorry --non-trivial
lemma new_lemma_20921 (h0 : finset (ordered_comm_monoid (has_Inf pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_20922 (h0 : has_neg (has_dist enat)) (h1 : measurable_space (has_dist enat)) : has_measurable_neg (has_dist enat) := sorry --non-trivial
lemma new_lemma_20923 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (has_top.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 ring.{0}) (has_top.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_20924 (h0 : topological_space (finset (has_Inf (has_Inf Type)))) : irreducible_space (finset (has_Inf (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_20925 (h0 : monoid (semigroup (has_neg name))) : monoid.fg (semigroup (has_neg name)) := sorry --non-trivial
lemma new_lemma_20926 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (linear_ordered_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_20927 (h0 : topological_space (has_norm linarith.ineq)) : path_connected_space (has_norm linarith.ineq) := sorry --non-trivial
lemma new_lemma_20928 (h0 : ordered_add_comm_monoid (filter unsigned)) : archimedean (filter unsigned) := sorry --non-trivial
lemma new_lemma_20929 (h0 : functor.add_const (ring (boolean_algebra Type)) name) : @is_domain.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (boolean_algebra.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_20930 (h0 : semiring (add_comm_monoid pos)) : is_noetherian_ring (add_comm_monoid pos) := sorry --non-trivial
lemma new_lemma_20931 (h0 : functor.add_const (topological_space (has_add Type)) Type) : @topological_space.separable_space.{1} (has_add.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_add.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_20932 (h0 : functor.add_const (ordered_add_comm_monoid (has_zero Type)) (finset (finset linarith.comp))) : @archimedean.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (ordered_add_comm_monoid.{1} (has_zero.{1} Type)) (finset.{0} (finset.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_20933 (h0 : functor.add_const (topological_space (has_bot empty)) empty) : @t0_space.{0} (has_bot.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_bot.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_20934 (h0 : topological_space (simple_graph environment.projection_info)) (h1 : set (simple_graph environment.projection_info)) : is_path_connected h1 := sorry --non-trivial
lemma new_lemma_20935 (h0 : topological_space (generalized_boolean_algebra real)) : sequential_space (generalized_boolean_algebra real) := sorry --non-trivial
lemma new_lemma_20936 (h0 : topological_space (add_cancel_monoid (add_comm_monoid name))) : irreducible_space (add_cancel_monoid (add_comm_monoid name)) := sorry --non-trivial
lemma new_lemma_20937 (h0 : topological_space (has_bot real)) : discrete_topology (has_bot real) := sorry --non-trivial
lemma new_lemma_20938 (h0 : ring (has_one (semiring linarith.comp))) : rank_condition (has_one (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_20939 (h0 : functor.add_const (monoid (semigroup pos)) (add_left_cancel_monoid pos)) : @monoid.fg.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (monoid.{0} (semigroup.{0} pos)) (add_left_cancel_monoid.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_20940 (h0 : filter (has_add num)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_20941 (h0 : functor.add_const (topological_space (pseudo_metric_space empty)) unsigned) : @discrete_topology.{0} (pseudo_metric_space.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (pseudo_metric_space.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_20942 (h0 : functor.add_const (list (has_neg unsigned)) unsigned) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_20943 (h0 : monoid (sub_neg_monoid name)) : monoid.fg (sub_neg_monoid name) := sorry --non-trivial
lemma new_lemma_20944 (h0 : functor.add_const (topological_space (boolean_algebra.core pos)) name) : @sequential_space.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_20945 (h0 : ordered_comm_monoid (ordered_comm_ring (has_pos_part Type))) : has_exists_mul_of_le (ordered_comm_ring (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_20946 (h0 : ring (mul_zero_class congr_arg_kind)) : strong_rank_condition (mul_zero_class congr_arg_kind) := sorry --non-trivial
lemma new_lemma_20947 (h0 : ordered_comm_monoid (normed_comm_ring (has_add (has_add (has_add pos))))) : has_exists_mul_of_le (normed_comm_ring (has_add (has_add (has_add pos)))) := sorry --non-trivial
lemma new_lemma_20948 (h0 : group (complete_semilattice_Sup (semiring unsigned))) : group.fg (complete_semilattice_Sup (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_20949 (h0 : functor.comp (prod (mul_zero_class unsigned)) mul_zero_class unsigned) : id_rel (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_20950 (h0 : function.extfun Type topological_space) : @t0_space.{0} (semigroup.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_20951 (h0 : functor.add_const (function.extfun Type topological_space) environment.implicit_infer_kind) : @t1_space.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) environment.implicit_infer_kind h0) (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_20952 (h0 : topological_space (comm_monoid (semiring (semiring (semiring (semiring (semiring empty))))))) : t1_space (comm_monoid (semiring (semiring (semiring (semiring (semiring empty)))))) := sorry --non-trivial
lemma new_lemma_20953 (h0 : functor.add_const (topological_space (ring name)) linarith.comp) : @preconnected_space.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_20954 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (random_gen.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (random_gen.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_20955 (h0 : topological_space (normed_comm_ring (normed_comm_ring (boolean_algebra.core Type)))) : normal_space (normed_comm_ring (normed_comm_ring (boolean_algebra.core Type))) := sorry --non-trivial
lemma new_lemma_20956 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} (linear_ordered_semiring.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (linear_ordered_semiring.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_20957 (h0 : topological_space (has_to_string (has_add (has_add (has_add linarith.comp))))) : t1_space (has_to_string (has_add (has_add (has_add linarith.comp)))) := sorry --non-trivial
lemma new_lemma_20958 (h0 : topological_space (comm_ring (has_inv string_imp))) : irreducible_space (comm_ring (has_inv string_imp)) := sorry --non-trivial
lemma new_lemma_20959 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (semigroup pos)) := sorry --non-trivial
lemma new_lemma_20960 (h1 : function.extfun Type monoid) : @monoid.fg.{0} (has_top.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type monoid.{0} h1 (has_top.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_20961 (h0 : topological_space (add_cancel_monoid (has_to_string (has_to_string (has_to_string name))))) : preconnected_space (add_cancel_monoid (has_to_string (has_to_string (has_to_string name)))) := sorry --non-trivial
lemma new_lemma_20962 (h0 : functor.add_const (ordered_comm_monoid (add_cancel_monoid name)) (has_neg linarith.comp)) : @has_exists_mul_of_le.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (add_cancel_monoid.{0} name)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_20963 (h0 : functor.add_const (complete_lattice (ordered_ring unsigned)) congr_arg_kind) : @complete_lattice.is_Sup_finite_compact.{0} (ordered_ring.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ordered_ring.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_20964 (h0 : topological_space (boolean_algebra (add_comm_monoid environment.implicit_infer_kind))) : preirreducible_space (boolean_algebra (add_comm_monoid environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_20965 (h0 : add_group (has_add (random_gen linarith.ineq))) : is_add_cyclic (has_add (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_20966 (h0 : topological_space (mul_zero_class (option (option ennreal)))) : sequential_space (mul_zero_class (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_20967 (h0 : complete_lattice (has_neg (has_add (comm_group name)))) : is_compactly_generated (has_neg (has_add (comm_group name))) := sorry --non-trivial
lemma new_lemma_20968 (h0 : topological_space (semigroup (comm_group (comm_group Type)))) : locally_compact_space (semigroup (comm_group (comm_group Type))) := sorry --non-trivial
lemma new_lemma_20969 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (@id.{2} Type empty) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (@id.{2} Type empty))  := sorry --non-trivial
lemma new_lemma_20970 (h0 : ring (normed_group (has_inv (random_gen linarith.comp_source)))) : rank_condition (normed_group (has_inv (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_20971 (h0 : fin has_zero.zero) : @unique_factorization_monoid.{0} (generalized_boolean_algebra.{0} real) (@matrix.vec_empty.{0} (cancel_comm_monoid_with_zero.{0} (generalized_boolean_algebra.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_20972 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (ordered_comm_group.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_20973 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (has_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_20974 (h1 : ring (non_unital_non_assoc_semiring to_additive.value_type)) : rank_condition (non_unital_non_assoc_semiring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_20975 (h0 : functor.add_const (complete_lattice (add_comm_monoid Type)) Type) : @is_atomistic.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 1} (complete_lattice.{1} (add_comm_monoid.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_20976 (h0 : ring (has_one (semiring unsigned))) : is_domain (has_one (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_20977 (h0 : topological_space (has_neg (comm_group Type))) : normal_space (has_neg (comm_group Type)) := sorry --non-trivial
lemma new_lemma_20978 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (ring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_20979 (h0 : has_mem.mem unsigned has_emptyc.emptyc) : @is_compactly_generated.{0} unsigned (@finset.pi.empty.{1 0} Type complete_lattice.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_20980 (h0 : topological_space (ordered_comm_ring (has_Inf (has_Inf Type)))) : totally_separated_space (ordered_comm_ring (has_Inf (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_20981 (h0 : functor.add_const (complete_lattice (ring Type)) name) : @is_compactly_generated.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (ring.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_20982 (h0 : functor.add_const (ring (has_to_string Type)) pos) : @is_domain.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_to_string.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_20983 (h0 : functor.add_const (topological_space (linear_ordered_field empty)) (option (option unsigned))) : @discrete_topology.{0} (linear_ordered_field.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_field.{0} empty)) (option.{0} (option.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_20984 (h0 : monoid (normed_group (complete_semilattice_Sup (with_one (linear_ordered_semiring unsigned))))) : monoid.fg (normed_group (complete_semilattice_Sup (with_one (linear_ordered_semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_20985 (h0 : monoid (is_R_or_C (option (option unsigned)))) : monoid.fg (is_R_or_C (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_20986 (h0 : functor.add_const (ordered_add_comm_monoid (generalized_boolean_algebra name)) (has_nndist linarith.comp)) : @archimedean.{0} (generalized_boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (generalized_boolean_algebra.{0} name)) (has_nndist.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_20987 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (pseudo_metric_space.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (pseudo_metric_space.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_20988 (h0 : function.extfun Type (functor.add_const (semiring auto.case_option))) : @is_noetherian_ring.{0} auto.case_option (@functor.add_const.run.{0 0} (semiring.{0} auto.case_option) ennreal (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (semiring.{0} auto.case_option)) h0 ennreal))  := sorry --non-trivial
lemma new_lemma_20989 (h0 : not (group (random_gen num) -> false)) : @group.fg.{0} (random_gen.{0} num) (@classical.by_contradiction'.{1} (group.{0} (random_gen.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_20990 (h0 : topological_space (has_top (random_gen (has_union linarith.comp)))) : path_connected_space (has_top (random_gen (has_union linarith.comp))) := sorry --non-trivial
lemma new_lemma_20991 (h0 : topological_space (lattice num)) : path_connected_space (lattice num) := sorry --non-trivial
lemma new_lemma_20992 (h0 : list (ring (has_pos_part pos))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_20993 (h0 : ring (has_add (has_Inf pos))) : is_principal_ideal_ring (has_add (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_20994 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (ordered_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (ordered_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_20995 (h0 : topological_space (has_neg_part (option (mul_zero_class (mul_zero_class pos))))) : totally_separated_space (has_neg_part (option (mul_zero_class (mul_zero_class pos)))) := sorry --non-trivial
lemma new_lemma_20996 (h0 : group (random_gen (random_gen (random_gen (random_gen (random_gen to_additive.value_type)))))) : group.fg (random_gen (random_gen (random_gen (random_gen (random_gen to_additive.value_type))))) := sorry --non-trivial
lemma new_lemma_20997 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (ordered_cancel_add_comm_monoid.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (ordered_cancel_add_comm_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_20998 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (ordered_comm_ring.{0} (has_neg.{0} linarith.comp)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_ring.{0} (has_neg.{0} linarith.comp)))  := sorry --non-trivial
lemma new_lemma_20999 (h0 : list (with_bot (has_inv (random_gen fun_info)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_21000 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (ordered_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_21001 (h0 : finset (has_nndist (finset pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_21002 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (ordered_ring.{0} pos) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (ordered_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_21003 (h0 : semiring (has_add ennreal)) : is_noetherian_ring (has_add ennreal) := sorry --non-trivial
lemma new_lemma_21004 (h0 : function.extfun (Type 1) topological_space) : @preirreducible_space.{1} (has_neg.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_neg.{1} Type))  := sorry --non-trivial
lemma new_lemma_21005 (h0 : function.extfun (finset Type) (has_mem.mem (add_group unsigned))) : @preirreducible_space.{0} (add_group.{0} unsigned) (@finset.pi.empty.{1 0} Type topological_space.{0} (add_group.{0} unsigned) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (add_group.{0} unsigned)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_21006 (h0 : group (linear_order (option empty))) : is_cyclic (linear_order (option empty)) := sorry --non-trivial
lemma new_lemma_21007 (h1 : function.extfun Type group) : @group.fg.{0} to_additive.value_type (@function.extfun_app.{2 1} Type group.{0} h1 to_additive.value_type)  := sorry --non-trivial
lemma new_lemma_21008 (h0 : topological_space (complete_semilattice_Sup num)) : t0_space (complete_semilattice_Sup num) := sorry --non-trivial
lemma new_lemma_21009 (h0 : functor.add_const (function.extfun Type ring) pos) : @is_principal_ideal_ring.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) pos h0) (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_21010 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (add_comm_monoid congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_21011 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (has_neg_part.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_neg_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_21012 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (finset.{0} num) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (finset.{0} num))  := sorry --non-trivial
lemma new_lemma_21013 (h0 : function.extfun Type (functor.add_const (list (ordered_ring empty)))) : palindrome (functor.add_const.run (function.extfun_app h0 congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_21014 (h0 : topological_space (add_comm_monoid (normed_comm_ring (has_add pos)))) : topological_space.separable_space (add_comm_monoid (normed_comm_ring (has_add pos))) := sorry --non-trivial
lemma new_lemma_21015 (h0 : function.extfun Type (functor.add_const (function.extfun Type add_group))) : @is_add_cyclic.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type add_group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_group.{0}) environment.implicit_infer_kind (@function.extfun_app.{2 2} Type (functor.add_const.{1 0} (function.extfun.{2 1} Type add_group.{0})) h0 environment.implicit_infer_kind)) (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_21016 (h0 : functor.add_const (semiring (has_edist empty)) (semiring unsigned)) : @is_noetherian_ring.{0} (has_edist.{0} empty) (@functor.add_const.run.{0 0} (semiring.{0} (has_edist.{0} empty)) (semiring.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_21017 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (normed_comm_ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (normed_comm_ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_21018 (h0 : complete_lattice (random_gen linarith.comp_source)) : is_atomistic (random_gen linarith.comp_source) := sorry --non-trivial
lemma new_lemma_21019 (h0 : functor.add_const (complete_lattice (add_cancel_monoid linarith.comp)) (has_neg linarith.comp)) : @complete_lattice.is_Sup_finite_compact.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_cancel_monoid.{0} linarith.comp)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_21020 (h0 : functor.add_const (uniform_space (has_nndist environment.implicit_infer_kind)) (has_neg pos)) : @separated_space.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_nndist.{0} environment.implicit_infer_kind)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_21021 : infinite (has_neg linarith.comp) := sorry --non-trivial
lemma new_lemma_21022 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (semiring.{0} (random_gen.{0} (has_norm.{0} (has_norm.{0} (random_gen.{0} (random_gen.{0} num)))))) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (semiring.{0} (random_gen.{0} (has_norm.{0} (has_norm.{0} (random_gen.{0} (random_gen.{0} num)))))))  := sorry --non-trivial
lemma new_lemma_21023 (h0 : functor.add_const (topological_space (semigroup Type)) linarith.comp) : @path_connected_space.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (semigroup.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_21024 (h0 : has_mem.mem (semiring (has_norm num)) has_emptyc.emptyc) : @totally_separated_space.{0} (semiring.{0} (has_norm.{0} num)) (@finset.pi.empty.{1 0} Type topological_space.{0} (semiring.{0} (has_norm.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_21025 (h0 : function.extfun Type group) : @normalizer_condition.{0} (semigroup.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (semigroup.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_21026 (h0 : topological_space (semigroup (ring linarith.comp))) : irreducible_space (semigroup (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_21027 (h0 : not (ring (has_nnnorm char) -> false)) : @is_domain.{0} (has_nnnorm.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (has_nnnorm.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_21028 (h0 : has_mem.mem (semiring (semiring linarith.comp_source)) has_emptyc.emptyc) : @is_atomistic.{0} (semiring.{0} (semiring.{0} linarith.comp_source)) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (semiring.{0} (semiring.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_21029 (h0 : filter (partial_order (semiring (semiring (semiring unsigned))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_21030 (h0 : add_group name) : is_add_cyclic name := sorry --non-trivial
lemma new_lemma_21031 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (add_cancel_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (add_cancel_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_21032 (h0 : ring (has_neg (comm_group name))) : is_principal_ideal_ring (has_neg (comm_group name)) := sorry --non-trivial
lemma new_lemma_21033 (h0 : topological_space (normed_comm_ring (has_neg_part environment.implicit_infer_kind))) : irreducible_space (normed_comm_ring (has_neg_part environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_21034 (h0 : topological_space (has_sub (linear_ordered_semiring congr_arg_kind))) : topological_space.separable_space (has_sub (linear_ordered_semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_21035 (h0 : topological_space (boolean_algebra (ordered_comm_monoid Type))) : t0_space (boolean_algebra (ordered_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_21036 (h0 : ring (distrib_lattice (has_nnnorm fun_info))) : strong_rank_condition (distrib_lattice (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_21037 (h0 : topological_space (has_top (random_gen (has_norm (has_norm congr_arg_kind))))) : totally_disconnected_space (has_top (random_gen (has_norm (has_norm congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_21038 (h0 : not (ring (semiring to_additive.value_type) -> false)) : @rank_condition.{0} (semiring.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (semiring.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_21039 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (canonically_ordered_comm_semiring.{0} num) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (canonically_ordered_comm_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_21040 (h0 : ordered_comm_monoid (simple_graph (has_add (has_add (has_add linarith.comp))))) : has_exists_mul_of_le (simple_graph (has_add (has_add (has_add linarith.comp)))) := sorry --non-trivial
lemma new_lemma_21041 (h0 : ring (topological_space (has_nnnorm fun_info))) : rank_condition (topological_space (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_21042 (h0 : functor.add_const (ring (has_pos_part linarith.comp)) (ring name)) : @rank_condition.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_pos_part.{0} linarith.comp)) (ring.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_21043 (h0 : function.extfun nat fin) : @topological_space.separable_space.{0} (add_comm_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (add_comm_monoid.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_21044 (h1 : ring (comm_ring reducibility_hints)) : strong_rank_condition (comm_ring reducibility_hints) := sorry --non-trivial
lemma new_lemma_21045 (h0 : complete_lattice (has_add (option unsigned))) : is_atomistic (has_add (option unsigned)) := sorry --non-trivial
lemma new_lemma_21046 (h0 : complete_lattice (has_norm (random_gen (semiring congr_arg_kind)))) : is_atomistic (has_norm (random_gen (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_21047 (h0 : topological_space (has_nndist (has_add (has_neg_part name)))) : locally_compact_space (has_nndist (has_add (has_neg_part name))) := sorry --non-trivial
lemma new_lemma_21048 (h0 : group (linear_ordered_field (add_cancel_monoid pos))) : normalizer_condition (linear_ordered_field (add_cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_21049 (h0 : semiring (simple_graph (has_Inf pos))) : is_noetherian_ring (simple_graph (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_21050 (h0 : has_add (monoid num) -> has_add (monoid num) -> Prop) : is_symm (has_add (monoid num)) h0 := sorry --non-trivial
lemma new_lemma_21051 (h0 : topological_space (canonically_ordered_comm_semiring congr_arg_kind)) : totally_disconnected_space (canonically_ordered_comm_semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_21052 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_21053 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (linear_ordered_semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_21054 (h0 : functor.add_const (topological_space (normed_linear_ordered_group congr_arg_kind)) num) : @irreducible_space.{0} (normed_linear_ordered_group.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_linear_ordered_group.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_21055 (h0 : fin has_zero.zero) : @t1_space.{0} (generalized_boolean_algebra.{0} (has_neg.{0} pos)) (@matrix.vec_empty.{0} (topological_space.{0} (generalized_boolean_algebra.{0} (has_neg.{0} pos))) h0)  := sorry --non-trivial
lemma new_lemma_21056 (h1 : topological_space (encodable char)) : locally_compact_space (encodable char) := sorry --non-trivial
lemma new_lemma_21057 (h0 : functor.add_const (function.extfun (Type 1) group) pos) : @group.fg.{1} (has_pos_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) group.{1}) pos h0) (has_pos_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_21058 (h1 : ring (has_ssubset (has_nnnorm char))) : strong_rank_condition (has_ssubset (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_21059 (h1 : ring (has_ssubset string.iterator_imp)) : rank_condition (has_ssubset string.iterator_imp) := sorry --non-trivial
lemma new_lemma_21060 (h0 : monoid (normed_comm_ring (has_to_string pos))) : monoid.fg (normed_comm_ring (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_21061 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (linear_ordered_comm_monoid_with_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_21062 (h0 : function.extfun (Type 1) topological_space) : @preconnected_space.{1} (add_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (add_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_21063 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (preorder.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (preorder.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_21064 (h0 : complete_lattice (has_norm (has_norm congr_arg_kind))) : is_atomistic (has_norm (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_21065 (h0 : prod (add_comm_monoid congr_arg_kind) (add_comm_monoid congr_arg_kind)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_21066 (h0 : functor.comp ordered_comm_monoid has_neg_part name) : @has_exists_mul_of_le.{0} (has_neg_part.{0} name) (@functor.comp.run.{0 0 0} ordered_comm_monoid.{0} has_neg_part.{0} name (@functor.comp.run.{0 0 0} ordered_comm_monoid.{0} has_neg_part.{0} name (@functor.comp.run.{0 0 0} ordered_comm_monoid.{0} has_neg_part.{0} name (@functor.comp.run.{0 0 0} ordered_comm_monoid.{0} has_neg_part.{0} name (@functor.comp.run.{0 0 0} ordered_comm_monoid.{0} has_neg_part.{0} name (@functor.comp.run.{0 0 0} ordered_comm_monoid.{0} has_neg_part.{0} name (@functor.comp.run.{0 0 0} ordered_comm_monoid.{0} has_neg_part.{0} name (@functor.comp.run.{0 0 0} ordered_comm_monoid.{0} has_neg_part.{0} name (@functor.comp.run.{0 0 0} ordered_comm_monoid.{0} has_neg_part.{0} name h0)))))))))  := sorry --non-trivial
lemma new_lemma_21067 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (add_left_cancel_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (add_left_cancel_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_21068 (h0 : group (mul_zero_class (finset (finset Type)))) : group.fg (mul_zero_class (finset (finset Type))) := sorry --non-trivial
lemma new_lemma_21069 (h0 : partial_order linarith.comp) (h1 : functor.add_const (order_top linarith.comp) name) : @is_coatomic.{0} linarith.comp h0 (@functor.add_const.run.{0 0} (@order_top.{0} linarith.comp (@preorder.to_has_le.{0} linarith.comp (@partial_order.to_preorder.{0} linarith.comp h0))) name h1)  := sorry --non-trivial
lemma new_lemma_21070 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (has_dist.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_dist.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_21071 (h0 : topological_space (finset (has_neg environment.implicit_infer_kind))) : sequential_space (finset (has_neg environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_21072 (h0 : functor.add_const (topological_space (complete_distrib_lattice linarith.comp)) linarith.comp) : @totally_separated_space.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_21073 (h0 : add_group (has_to_string (has_add environment.implicit_infer_kind))) : is_add_cyclic (has_to_string (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_21074 (h0 : ring (complete_semilattice_Sup (semiring (semiring (semiring unsigned))))) : is_principal_ideal_ring (complete_semilattice_Sup (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_21075 (h0 : topological_space (left_cancel_semigroup empty)) : irreducible_space (left_cancel_semigroup empty) := sorry --non-trivial
lemma new_lemma_21076 (h0 : topological_space (ring linarith.comp)) : t1_space (ring linarith.comp) := sorry --non-trivial
lemma new_lemma_21077 (h0 : function.extfun Type (functor.add_const Prop)) : functor.add_const.run (function.extfun_app h0 (canonically_ordered_comm_semiring pos)) := sorry --non-trivial
lemma new_lemma_21078 (h0 : not (add_monoid (measure_theory.measure_space empty) -> false)) : @add_monoid.fg.{0} (measure_theory.measure_space.{0} empty) (@classical.by_contradiction'.{1} (add_monoid.{0} (measure_theory.measure_space.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_21079 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (has_union.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (has_union.{0} empty))  := sorry --non-trivial
lemma new_lemma_21080 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (comm_semigroup.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (comm_semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_21081 (h0 : complete_lattice (has_compl (mul_one_class char))) : is_compactly_generated (has_compl (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_21082 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @path_connected_space.{0} (with_one.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (with_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_21083 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_to_string.{0} name) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_to_string.{0} name))  := sorry --non-trivial
lemma new_lemma_21084 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @path_connected_space.{0} (has_neg.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (has_neg.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_21085 (h0 : complete_lattice (has_nndist (has_add Type))) : is_atomistic (has_nndist (has_add Type)) := sorry --non-trivial
lemma new_lemma_21086 (h0 : monoid (has_add (has_add Type))) : monoid.fg (has_add (has_add Type)) := sorry --non-trivial
lemma new_lemma_21087 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (normed_group.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (normed_group.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_21088 (h0 : topological_space (boolean_algebra (has_to_string unsigned))) : regular_space (boolean_algebra (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_21089 (h0 : functor.add_const (list (add_cancel_monoid environment.implicit_infer_kind)) pos) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_21090 (h0 : add_group (has_norm string_imp)) : is_add_cyclic (has_norm string_imp) := sorry --non-trivial
lemma new_lemma_21091 (h0 : topological_space (ordered_comm_ring (has_Inf real))) : path_connected_space (ordered_comm_ring (has_Inf real)) := sorry --non-trivial
lemma new_lemma_21092 (h1 : add_monoid (complete_semilattice_Sup linarith.comp)) : add_monoid.fg (complete_semilattice_Sup linarith.comp) := sorry --non-trivial
lemma new_lemma_21093 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (complete_semilattice_Sup empty)) := sorry --non-trivial
lemma new_lemma_21094 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (denumerable.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (denumerable.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_21095 (h0 : function.extfun Type (functor.add_const (ring pos))) : @strong_rank_condition.{0} pos (@functor.add_const.run.{0 0} (ring.{0} pos) (has_neg.{0} name) (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} pos)) h0 (has_neg.{0} name)))  := sorry --non-trivial
lemma new_lemma_21096 (h2 : complete_lattice (div_inv_monoid linarith.ineq)) : complete_lattice.is_Sup_finite_compact (div_inv_monoid linarith.ineq) := sorry --non-trivial
lemma new_lemma_21097 (h0 : list (normed_group linarith.ineq)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_21098 (h0 : not (topological_space (with_bot linarith.ineq) -> false)) : @t0_space.{0} (with_bot.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (with_bot.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_21099 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_top.{0} fun_info) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_top.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_21100 (h1 : ring (semi_normed_comm_ring string_imp)) : is_domain (semi_normed_comm_ring string_imp) := sorry --non-trivial
lemma new_lemma_21101 (h0 : uniform_space (add_right_cancel_monoid (has_top (semiring unsigned)))) : separated_space (add_right_cancel_monoid (has_top (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_21102 (h0 : topological_space (measure_theory.measure_space (semiring (semiring unsigned)))) : path_connected_space (measure_theory.measure_space (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_21103 (h0 : semiring (has_neg (has_pos_part (has_pos_part linarith.comp)))) : is_noetherian_ring (has_neg (has_pos_part (has_pos_part linarith.comp))) := sorry --non-trivial
lemma new_lemma_21104 (h0 : ordered_add_comm_monoid (ordered_cancel_add_comm_monoid empty)) : archimedean (ordered_cancel_add_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_21105 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (add_left_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (add_left_cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_21106 (h0 : list (preorder (option empty))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_21107 (h0 : ordered_add_comm_monoid (canonically_ordered_comm_semiring environment.implicit_infer_kind)) : archimedean (canonically_ordered_comm_semiring environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_21108 (h1 : ring reducibility_hints) : is_domain reducibility_hints := sorry --non-trivial
lemma new_lemma_21109 (h3 : set (has_ssubset environment.projection_info)) : set.finite h3 := sorry --non-trivial
lemma new_lemma_21110 (h1 : uniform_space (has_emptyc fun_info)) : complete_space (has_emptyc fun_info) := sorry --non-trivial
lemma new_lemma_21111 (h0 : function.extfun Type (functor.add_const (list (linear_order empty)))) : palindrome (functor.add_const.run (function.extfun_app h0 empty)) := sorry --non-trivial
lemma new_lemma_21112 (h0 : topological_space (has_one (has_norm congr_arg_kind))) : normal_space (has_one (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_21113 (h1 : preorder std_gen) (h2 : set std_gen) : set.is_pwo h2 := sorry --non-trivial
lemma new_lemma_21114 (h0 : topological_space (normed_comm_ring (option empty))) : loc_path_connected_space (normed_comm_ring (option empty)) := sorry --non-trivial
lemma new_lemma_21115 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @regular_space.{1} (simple_graph.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (simple_graph.{1} Type))  := sorry --non-trivial
lemma new_lemma_21116 (h0 : filter (add_cancel_monoid (has_add Type))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_21117 (h0 : functor.add_const (ring (has_pos_part linarith.comp)) linarith.comp) : @strong_rank_condition.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_pos_part.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_21118 (h0 : pnat) (h1 : ulower pnat) : pnat.coprime h0 (id (id (id (ulower.up h1)))) := sorry --non-trivial
lemma new_lemma_21119 (h0 : group (normed_lattice_add_comm_group linarith.comp)) : normalizer_condition (normed_lattice_add_comm_group linarith.comp) := sorry --non-trivial
lemma new_lemma_21120 (h0 : monoid (with_one (has_inv (has_inv to_additive.value_type)))) : monoid.fg (with_one (has_inv (has_inv to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_21121 (h0 : functor.add_const (topological_space (partial_order congr_arg_kind)) empty) : @locally_compact_space.{0} (partial_order.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (partial_order.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_21122 (h0 : topological_space (boolean_algebra.core (has_to_string (boolean_algebra linarith.comp)))) : discrete_topology (boolean_algebra.core (has_to_string (boolean_algebra linarith.comp))) := sorry --non-trivial
lemma new_lemma_21123 (h0 : functor.add_const (ring (has_neg unsigned)) unsigned) : @rank_condition.{0} (has_neg.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (has_neg.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_21124 (h0 : topological_space (with_one congr_arg_kind)) : irreducible_space (with_one congr_arg_kind) := sorry --non-trivial
lemma new_lemma_21125 (h0 : function.extfun Type group) : @group.fg.{0} (random_gen.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (random_gen.{0} empty))  := sorry --non-trivial
lemma new_lemma_21126 (h0 : topological_space (normed_comm_ring environment.implicit_infer_kind)) : discrete_topology (normed_comm_ring environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_21127 (h0 : not (topological_space (measurable_space num) -> false)) : @discrete_topology.{0} (measurable_space.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (measurable_space.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_21128 (h0 : function.extfun Type group) : @is_cyclic.{0} to_additive.value_type (@function.extfun_app.{2 1} Type group.{0} h0 to_additive.value_type)  := sorry --non-trivial
lemma new_lemma_21129 (h0 : uniform_space (add_comm_semigroup string.iterator_imp)) : complete_space (add_comm_semigroup string.iterator_imp) := sorry --non-trivial
lemma new_lemma_21130 (h0 : functor.add_const (filter (canonically_ordered_comm_semiring pos)) (option name)) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_21131 (h0 : function.extfun Type topological_space) : @t0_space.{0} (complete_distrib_lattice.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} real))  := sorry --non-trivial
lemma new_lemma_21132 (h0 : function.extfun Type (functor.comp topological_space finset)) : @locally_compact_space.{0} (finset.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} finset.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} finset.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_21133 (h0 : functor.add_const (topological_space (normed_comm_ring name)) pos) : @totally_disconnected_space.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_21134 (h0 : complete_lattice (semigroup Type)) : is_atomistic (semigroup Type) := sorry --non-trivial
lemma new_lemma_21135 (h0 : add_group (has_add (option (has_nndist name)))) : is_add_cyclic (has_add (option (has_nndist name))) := sorry --non-trivial
lemma new_lemma_21136 (h0 : uniform_space (boolean_algebra.core (has_add pos))) : complete_space (boolean_algebra.core (has_add pos)) := sorry --non-trivial
lemma new_lemma_21137 (h0 : topological_space (has_norm (semiring unsigned))) : preirreducible_space (has_norm (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_21138 (h0 : functor.add_const (topological_space (complete_distrib_lattice ennreal)) num) : @discrete_topology.{0} (complete_distrib_lattice.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} ennreal)) num h0)  := sorry --non-trivial
lemma new_lemma_21139 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (semigroup.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_21140 (h0 : functor.add_const (functor.add_const (list linarith.comp) (has_neg linarith.comp)) pos) : list.nodup (functor.add_const.run (functor.add_const.run h0)) := sorry --non-trivial
lemma new_lemma_21141 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (non_assoc_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (non_assoc_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_21142 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (ordered_comm_ring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_21143 (h0 : topological_space (topological_space (has_nnnorm char))) : t0_space (topological_space (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_21144 (h0 : functor.add_const (topological_space unsigned) empty) : @totally_separated_space.{0} unsigned (@functor.add_const.run.{0 0} (topological_space.{0} unsigned) empty h0)  := sorry --non-trivial
lemma new_lemma_21145 (h0 : topological_space (linear_order unsigned)) : discrete_topology (linear_order unsigned) := sorry --non-trivial
lemma new_lemma_21146 (h0 : fin has_zero.zero) : countable_Inter_filter (function.extfun_app (matrix.vec_empty h0) (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_21147 (h0 : add_monoid (finset (option (option ennreal)))) : add_monoid.fg (finset (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_21148 (h1 : topological_space (has_nnnorm char)) : locally_compact_space (has_nnnorm char) := sorry --non-trivial
lemma new_lemma_21149 (h0 : topological_space (has_inv (random_gen linarith.ineq))) : path_connected_space (has_inv (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_21150 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (measurable_space.dynkin_system.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measurable_space.dynkin_system.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_21151 (h0 : functor.add_const (topological_space (add_comm_monoid pos)) name) : @t0_space.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_21152 (h0 : topological_space (normed_comm_ring (option pos))) : preconnected_space (normed_comm_ring (option pos)) := sorry --non-trivial
lemma new_lemma_21153 (h0 : uniform_space (distrib (linear_ordered_comm_monoid_with_zero linarith.comp_source))) : complete_space (distrib (linear_ordered_comm_monoid_with_zero linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_21154 (h0 : functor.comp topological_space has_neg Type) : @loc_path_connected_space.{1} (has_neg.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} has_neg.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_21155 (h0 : functor.add_const (ordered_comm_monoid (normed_comm_ring name)) (has_add environment.implicit_infer_kind)) : @has_exists_mul_of_le.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (normed_comm_ring.{0} name)) (has_add.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_21156 (h0 : ring (distrib (mul_one_class string.iterator_imp))) : strong_rank_condition (distrib (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_21157 (h0 : topological_space (measurable_space (measurable_space.dynkin_system (has_top linarith.comp)))) : normal_space (measurable_space (measurable_space.dynkin_system (has_top linarith.comp))) := sorry --non-trivial
lemma new_lemma_21158 (h0 : topological_space (generalized_boolean_algebra (has_nndist name))) : irreducible_space (generalized_boolean_algebra (has_nndist name)) := sorry --non-trivial
lemma new_lemma_21159 (h0 : functor.add_const (topological_space (simple_graph linarith.comp)) (has_Inf linarith.comp)) : @totally_separated_space.{0} (simple_graph.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (simple_graph.{0} linarith.comp)) (has_Inf.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_21160 (h0 : functor.add_const (semiring (has_Inf Type)) name) : @is_noetherian_ring.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 0} (semiring.{1} (has_Inf.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_21161 (h0 : functor.add_const (function.extfun Type group) pos) : @group.fg.{0} (boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) pos h0) (boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_21162 (h0 : ring (simple_graph (has_neg name))) : is_domain (simple_graph (has_neg name)) := sorry --non-trivial
lemma new_lemma_21163 (h0 : complete_lattice (add_cancel_monoid unsigned)) : is_atomistic (add_cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_21164 (h0 : topological_space (normed_comm_ring (has_add (has_to_string unsigned)))) : totally_separated_space (normed_comm_ring (has_add (has_to_string unsigned))) := sorry --non-trivial
lemma new_lemma_21165 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_inter.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_inter.{0} empty))  := sorry --non-trivial
lemma new_lemma_21166 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (has_to_string.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_to_string.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_21167 (h0 : topological_space (denumerable reducibility_hints)) : path_connected_space (denumerable reducibility_hints) := sorry --non-trivial
lemma new_lemma_21168 (h0 : functor.add_const (uniform_space (ordered_comm_monoid linarith.comp)) pos) : @separated_space.{0} (ordered_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (ordered_comm_monoid.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_21169 (h0 : topological_space (ordered_comm_semiring (has_norm (has_norm congr_arg_kind)))) : irreducible_space (ordered_comm_semiring (has_norm (has_norm congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_21170 (h0 : group (has_nndist ennreal)) : is_simple_group (has_nndist ennreal) := sorry --non-trivial
lemma new_lemma_21171 (h0 : functor.add_const Prop (finset (has_add Type))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_21172 (h0 : function.extfun Type (functor.add_const (topological_space (left_cancel_monoid congr_arg_kind)))) : @path_connected_space.{0} (left_cancel_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} congr_arg_kind)) (semiring.{0} empty) (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (left_cancel_monoid.{0} congr_arg_kind))) h0 (semiring.{0} empty)))  := sorry --non-trivial
lemma new_lemma_21173 (h0 : functor.add_const (topological_space znum) num) : @irreducible_space.{0} znum (@functor.add_const.run.{0 0} (topological_space.{0} znum) num h0)  := sorry --non-trivial
lemma new_lemma_21174 (h0 : not (ring name -> false)) : @strong_rank_condition.{0} name (@classical.by_contradiction'.{1} (ring.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_21175 (h0 : topological_space (add_comm_monoid real)) : path_connected_space (add_comm_monoid real) := sorry --non-trivial
lemma new_lemma_21176 (h0 : function.extfun Type group) : @group.fg.{0} (encodable.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} h0 (encodable.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_21177 (h0 : ring (normed_group empty)) : rank_condition (normed_group empty) := sorry --non-trivial
lemma new_lemma_21178 (h0 : cancel_comm_monoid_with_zero (ordered_comm_monoid (has_neg (has_neg (has_neg name))))) : unique_factorization_monoid (ordered_comm_monoid (has_neg (has_neg (has_neg name)))) := sorry --non-trivial
lemma new_lemma_21179 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @discrete_topology.{0} (with_bot.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (with_bot.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_21180 (h0 : not (ring (has_append reducibility_hints) -> false)) : @strong_rank_condition.{0} (has_append.{0} reducibility_hints) (@classical.by_contradiction'.{1} (ring.{0} (has_append.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_21181 (h0 : functor.add_const (group (has_add pos)) (option (option (option (option unsigned))))) : @group.fg.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_add.{0} pos)) (option.{0} (option.{0} (option.{0} (option.{0} unsigned)))) h0)  := sorry --non-trivial
lemma new_lemma_21182 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_21183 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @totally_disconnected_space.{0} (add_comm_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (add_comm_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_21184 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (add_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_21185 (h0 : function.extfun (plift unsigned) (fun (x : plift unsigned), Prop)) (h1 : plift unsigned) : set.set_semiring.down (function.extfun_app h0) h1 := sorry --non-trivial
lemma new_lemma_21186 (h0 : functor.add_const (complete_lattice (complete_distrib_lattice linarith.comp)) (has_add linarith.comp)) : @complete_lattice.is_Sup_finite_compact.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (complete_distrib_lattice.{0} linarith.comp)) (has_add.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_21187 (h0 : monoid (random_gen (random_gen fun_info))) : monoid.fg (random_gen (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_21188 (h0 : topological_space (finset (has_add environment.implicit_infer_kind))) : loc_path_connected_space (finset (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_21189 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_add.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_add.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_21190 (h0 : functor.add_const (topological_space (has_nndist ennreal)) Type) : @loc_path_connected_space.{0} (has_nndist.{0} ennreal) (@functor.add_const.run.{0 1} (topological_space.{0} (has_nndist.{0} ennreal)) Type h0)  := sorry --non-trivial
lemma new_lemma_21191 (h0 : uniform_space (add_comm_monoid linarith.comp)) : separated_space (add_comm_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_21192 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_21193 (h0 : not (ring (complete_semilattice_Sup empty) -> false)) : @rank_condition.{0} (complete_semilattice_Sup.{0} empty) (@classical.by_contradiction'.{1} (ring.{0} (complete_semilattice_Sup.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_21194 (h1 : ring (topological_space to_additive.value_type)) : is_domain (topological_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_21195 (h0 : functor.add_const (fin has_zero.zero) Type) : @add_monoid.fg.{1} (generalized_boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (add_monoid.{1} (generalized_boolean_algebra.{1} Type)) (@functor.add_const.run.{0 1} (fin (@has_zero.zero.{0} nat nat.has_zero)) Type h0))  := sorry --non-trivial
lemma new_lemma_21196 (h0 : filter char) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_21197 (h0 : ring (has_top (has_top (has_top to_additive.value_type)))) : rank_condition (has_top (has_top (has_top to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_21198 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @regular_space.{0} (has_zero.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (has_zero.{0} name))  := sorry --non-trivial
lemma new_lemma_21199 (h0 : ring (simple_graph (id (random_gen to_additive.value_type)))) : rank_condition (simple_graph (id (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_21200 (h0 : topological_space (comm_group (has_neg_part Type))) : t1_space (comm_group (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_21201 (h0 : functor.add_const (function.extfun Type topological_space) (has_add pos)) : @topological_space.separable_space.{0} (has_neg.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (has_add.{0} pos) h0) (has_neg.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_21202 (h0 : topological_space (ring (has_Inf (has_add (finset (has_pos_part (has_add pos))))))) : locally_compact_space (ring (has_Inf (has_add (finset (has_pos_part (has_add pos)))))) := sorry --non-trivial
lemma new_lemma_21203 (h0 : monoid (with_bot (dlist linarith.ineq))) : monoid.fg (with_bot (dlist linarith.ineq)) := sorry --non-trivial
lemma new_lemma_21204 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_21205 (h0 : functor.add_const (add_monoid Type) linarith.comp) : @add_monoid.fg.{1} Type (@functor.add_const.run.{1 0} (add_monoid.{1} Type) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_21206 (h0 : functor.add_const (topological_space (canonically_linear_ordered_monoid pos)) name) : @totally_disconnected_space.{0} (canonically_linear_ordered_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_linear_ordered_monoid.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_21207 (h0 : functor.add_const (list (plift num)) (semiring (semiring (semiring (semiring (semiring (semiring num))))))) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_21208 (h0 : cancel_comm_monoid_with_zero (ordered_comm_monoid (ring name))) : unique_factorization_monoid (ordered_comm_monoid (ring name)) := sorry --non-trivial
lemma new_lemma_21209 (h0 : function.extfun Type group) : @is_cyclic.{0} (partial_order.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (partial_order.{0} num))  := sorry --non-trivial
lemma new_lemma_21210 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} real (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) real)  := sorry --non-trivial
lemma new_lemma_21211 (h2 : complete_lattice (random_gen linarith.ineq)) : complete_lattice.is_Sup_finite_compact (random_gen linarith.ineq) := sorry --non-trivial
lemma new_lemma_21212 (h0 : complete_lattice (canonically_linear_ordered_monoid (option (option num)))) : is_compactly_generated (canonically_linear_ordered_monoid (option (option num))) := sorry --non-trivial
lemma new_lemma_21213 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @totally_separated_space.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_21214 (h0 : function.extfun (Type 1) list) : palindrome (function.extfun_app h0 (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_21215 (h0 : functor.add_const (group (normed_comm_ring pos)) linarith.comp) : @is_simple_group.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (normed_comm_ring.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_21216 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (semiring.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_21217 (h0 : functor.add_const (group (has_to_string Type)) pos) : @normalizer_condition.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (has_to_string.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_21218 (h0 : fin has_zero.zero) : @preirreducible_space.{0} pos (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) pos)  := sorry --non-trivial
lemma new_lemma_21219 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (option.{0} pos) (@function.extfun_app.{2 1} Type semiring.{0} h0 (option.{0} pos))  := sorry --non-trivial
lemma new_lemma_21220 (h0 : functor.add_const (complete_lattice (simple_graph Type)) (ring name)) : @complete_lattice.is_Sup_finite_compact.{1} (simple_graph.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (simple_graph.{1} Type)) (ring.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_21221 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (add_right_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} h0 (add_right_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_21222 (h0 : functor.add_const (topological_space (bin_tree num)) unsigned) : @t1_space.{0} (bin_tree.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (bin_tree.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_21223 (h0 : functor.add_const (topological_space (has_add name)) name) : @totally_disconnected_space.{0} (has_add.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_21224 (h0 : group (has_zero (has_pos_part (finset pos)))) : is_cyclic (has_zero (has_pos_part (finset pos))) := sorry --non-trivial
lemma new_lemma_21225 (h0 : add_group (has_inter unsigned)) : is_add_cyclic (has_inter unsigned) := sorry --non-trivial
lemma new_lemma_21226 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (canonically_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_21227 (h0 : option Type) (h1 : ring (option.lhoare char h0)) : is_domain (option.lhoare char h0) := sorry --non-trivial
lemma new_lemma_21228 (h0 : add_group (distrib_lattice linarith.ineq)) : is_add_cyclic (distrib_lattice linarith.ineq) := sorry --non-trivial
lemma new_lemma_21229 (h0 : has_mem.mem (with_one fun_info) has_emptyc.emptyc) : @strong_rank_condition.{0} (with_one.{0} fun_info) (@finset.pi.empty.{1 0} Type ring.{0} (with_one.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_21230 (h0 : topological_space (comm_group (has_neg environment.implicit_infer_kind))) : totally_separated_space (comm_group (has_neg environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_21231 (h0 : functor.add_const (complete_lattice (canonically_ordered_add_monoid empty)) empty) : @is_compactly_generated.{0} (canonically_ordered_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (canonically_ordered_add_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_21232 (h0 : group (encodable (has_nnnorm char))) : group.fg (encodable (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_21233 (h0 : functor.add_const (group (has_nndist environment.implicit_infer_kind)) linarith.comp) : @is_simple_group.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (has_nndist.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_21234 (h0 : ring (boolean_algebra.core (option unsigned))) : rank_condition (boolean_algebra.core (option unsigned)) := sorry --non-trivial
lemma new_lemma_21235 (h0 : complete_lattice (with_one (semiring (semiring (semiring (semiring empty)))))) : is_compactly_generated (with_one (semiring (semiring (semiring (semiring empty))))) := sorry --non-trivial
lemma new_lemma_21236 (h2 : group (topological_space to_additive.value_type)) : is_cyclic (topological_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_21237 (h0 : finset (has_add (normed_comm_ring environment.implicit_infer_kind))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_21238 (h0 : not (ring (div_inv_monoid char) -> false)) : @is_domain.{0} (div_inv_monoid.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (div_inv_monoid.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_21239 (h0 : topological_space (finset (normed_comm_ring name))) : discrete_topology (finset (normed_comm_ring name)) := sorry --non-trivial
lemma new_lemma_21240 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @regular_space.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_21241 (h0 : function.extfun Type ring) : @is_domain.{0} (add_cancel_monoid.{0} (option.{0} unsigned)) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_cancel_monoid.{0} (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_21242 (h1 : topological_space (has_append (random_gen (random_gen (random_gen (random_gen char)))))) : totally_disconnected_space (has_append (random_gen (random_gen (random_gen (random_gen char))))) := sorry --non-trivial
lemma new_lemma_21243 (h0 : not (function.extfun Type ring -> false)) : @rank_condition.{0} (complete_semilattice_Sup.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (complete_semilattice_Sup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_21244 (h0 : list (has_norm (random_gen (random_gen (random_gen linarith.ineq))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_21245 (h0 : functor.add_const (topological_space (has_star congr_arg_kind)) congr_arg_kind) : @locally_compact_space.{0} (has_star.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_21246 (h0 : functor.add_const (finset (complete_semilattice_Sup num)) empty) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_21247 (h0 : add_monoid (add_group linarith.comp)) : add_monoid.fg (add_group linarith.comp) := sorry --non-trivial
lemma new_lemma_21248 (h0 : complete_lattice (has_bot unsigned)) : complete_lattice.is_Sup_finite_compact (has_bot unsigned) := sorry --non-trivial
lemma new_lemma_21249 (h0 : topological_space (add_group num)) : locally_compact_space (add_group num) := sorry --non-trivial
lemma new_lemma_21250 (h0 : not (ring (has_sub linarith.comp) -> false)) : @strong_rank_condition.{0} (has_sub.{0} linarith.comp) (@classical.by_contradiction'.{1} (ring.{0} (has_sub.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_21251 (h0 : function.extfun (finset Type) (has_mem.mem (linear_ordered_semiring empty))) : @locally_compact_space.{0} (linear_ordered_semiring.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (linear_ordered_semiring.{0} empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (linear_ordered_semiring.{0} empty)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_21252 (h0 : functor.add_const (function.extfun (Type 1) uniform_space) (has_neg environment.implicit_infer_kind)) : @complete_space.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) uniform_space.{1}) (has_neg.{0} environment.implicit_infer_kind) h0) (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_21253 (h1 : function.extfun Type group) : @is_cyclic.{0} linarith.comp (@function.extfun_app.{2 1} Type group.{0} h1 linarith.comp)  := sorry --non-trivial
lemma new_lemma_21254 (h0 : functor.add_const (topological_space (semigroup name)) linarith.comp) : @preirreducible_space.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_21255 (h0 : function.extfun (Type 1) ring) : @is_principal_ideal_ring.{1} Type (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 Type)  := sorry --non-trivial
lemma new_lemma_21256 (h0 : ring (has_nndist (has_nndist (has_add name)))) : strong_rank_condition (has_nndist (has_nndist (has_add name))) := sorry --non-trivial
lemma new_lemma_21257 (h0 : monoid (add_cancel_monoid (has_add name))) : monoid.fg (add_cancel_monoid (has_add name)) := sorry --non-trivial
lemma new_lemma_21258 (h0 : not (complete_lattice (option empty) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (option.{0} empty) (@classical.by_contradiction'.{1} (complete_lattice.{0} (option.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_21259 (h0 : functor.add_const (topological_space (has_add pos)) Type) : @irreducible_space.{0} (has_add.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_add.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_21260 (h0 : list (generalized_boolean_algebra (has_add Type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_21261 (h1 : uniform_space (random_gen (has_top (has_top (has_top congr_arg_kind))))) : complete_space (random_gen (has_top (has_top (has_top congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_21262 (h0 : topological_space (boolean_algebra.core (has_neg linarith.comp))) : normal_space (boolean_algebra.core (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_21263 (h0 : functor.add_const (topological_space (has_neg pos)) name) : @path_connected_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_21264 (h0 : functor.add_const (topological_space (ordered_comm_ring linarith.comp)) (ring linarith.comp)) : @sequential_space.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} linarith.comp)) (ring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_21265 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_bot.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_bot.{0} real))  := sorry --non-trivial
lemma new_lemma_21266 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_21267 (h0 : complete_lattice (has_pos_part (ring Type))) : complete_lattice.is_Sup_finite_compact (has_pos_part (ring Type)) := sorry --non-trivial
lemma new_lemma_21268 (h0 : semiring (generalized_boolean_algebra real)) : is_noetherian_ring (generalized_boolean_algebra real) := sorry --non-trivial
lemma new_lemma_21269 (h0 : functor.add_const (uniform_space (left_cancel_monoid unsigned)) congr_arg_kind) : @separated_space.{0} (left_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (uniform_space.{0} (left_cancel_monoid.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_21270 (h0 : group (boolean_algebra (cancel_monoid name))) : is_simple_group (boolean_algebra (cancel_monoid name)) := sorry --non-trivial
lemma new_lemma_21271 (h0 : filter (cancel_monoid (option (option ennreal)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_21272 (h0 : ring (with_one (has_top empty))) : rank_condition (with_one (has_top empty)) := sorry --non-trivial
lemma new_lemma_21273 (h0 : not (monoid (partial_order num) -> false)) : @monoid.fg.{0} (partial_order.{0} num) (@classical.by_contradiction'.{1} (monoid.{0} (partial_order.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_21274 (h0 : functor.comp topological_space semigroup environment.implicit_infer_kind) : @locally_compact_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} environment.implicit_infer_kind (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} environment.implicit_infer_kind (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} environment.implicit_infer_kind (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} environment.implicit_infer_kind (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} environment.implicit_infer_kind (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} environment.implicit_infer_kind (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} environment.implicit_infer_kind (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} environment.implicit_infer_kind (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} environment.implicit_infer_kind (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} environment.implicit_infer_kind (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} environment.implicit_infer_kind (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} environment.implicit_infer_kind (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} environment.implicit_infer_kind (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} environment.implicit_infer_kind (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} environment.implicit_infer_kind (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} environment.implicit_infer_kind (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} environment.implicit_infer_kind (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} environment.implicit_infer_kind (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} environment.implicit_infer_kind (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} environment.implicit_infer_kind (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} environment.implicit_infer_kind (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} environment.implicit_infer_kind (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} environment.implicit_infer_kind (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} environment.implicit_infer_kind (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} environment.implicit_infer_kind (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} environment.implicit_infer_kind (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} environment.implicit_infer_kind (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} environment.implicit_infer_kind (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} environment.implicit_infer_kind (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} environment.implicit_infer_kind (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} environment.implicit_infer_kind (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} environment.implicit_infer_kind (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} environment.implicit_infer_kind (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} environment.implicit_infer_kind (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} environment.implicit_infer_kind (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} environment.implicit_infer_kind (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} environment.implicit_infer_kind (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} environment.implicit_infer_kind h0))))))))))))))))))))))))))))))))))))))  := sorry --non-trivial
lemma new_lemma_21275 (h1 : complete_lattice (has_top (has_nnnorm string_imp))) : is_compactly_generated (has_top (has_nnnorm string_imp)) := sorry --non-trivial
lemma new_lemma_21276 (h1 : has_mem.mem (random_gen linarith.comp) has_emptyc.emptyc) : @is_add_cyclic.{0} (random_gen.{0} linarith.comp) (@finset.pi.empty.{1 0} Type add_group.{0} (random_gen.{0} linarith.comp) h1)  := sorry --non-trivial
lemma new_lemma_21277 (h0 : has_lt (semi_normed_comm_ring (mul_one_class environment.projection_info))) : no_max_order (semi_normed_comm_ring (mul_one_class environment.projection_info)) := sorry --non-trivial
lemma new_lemma_21278 (h2 : ring (fintype fun_info)) : is_domain (fintype fun_info) := sorry --non-trivial
lemma new_lemma_21279 (h0 : uniform_space (has_to_string (has_Inf (has_nndist (has_nndist Type))))) : complete_space (has_to_string (has_Inf (has_nndist (has_nndist Type)))) := sorry --non-trivial
lemma new_lemma_21280 (h0 : topological_space (comm_group (add_cancel_monoid (option (option pos))))) : totally_disconnected_space (comm_group (add_cancel_monoid (option (option pos)))) := sorry --non-trivial
lemma new_lemma_21281 (h0 : topological_space (bin_tree unsigned)) : path_connected_space (bin_tree unsigned) := sorry --non-trivial
lemma new_lemma_21282 (h0 : functor.add_const (monoid (boolean_algebra environment.implicit_infer_kind)) environment.implicit_infer_kind) : @monoid.fg.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (monoid.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_21283 (h0 : topological_space (filter (semiring (semiring empty)))) : totally_separated_space (filter (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_21284 (h0 : group (has_dist empty)) : is_cyclic (has_dist empty) := sorry --non-trivial
lemma new_lemma_21285 (h0 : functor.add_const (ordered_comm_monoid (add_cancel_monoid Type)) pos) : @has_exists_mul_of_le.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (ordered_comm_monoid.{1} (add_cancel_monoid.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_21286 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (complete_semilattice_Sup.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 complete_lattice.{0}) (complete_semilattice_Sup.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_21287 (h0 : topological_space (has_add (has_add (boolean_algebra.core Type)))) : path_connected_space (has_add (has_add (boolean_algebra.core Type))) := sorry --non-trivial
lemma new_lemma_21288 (h0 : functor.comp topological_space has_neg pos) : @totally_separated_space.{0} (has_neg.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_21289 (h0 : functor.add_const (list (has_to_string name)) (has_neg name)) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_21290 (h0 : not (topological_space (id unsigned) -> false)) : @topological_space.separable_space.{0} (@id.{2} Type unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (@id.{2} Type unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_21291 (h0 : measurable_space fun_info) (h2 : filter fun_info) : filter.is_measurably_generated h2 := sorry --non-trivial
lemma new_lemma_21292 (h0 : monoid (generalized_boolean_algebra (has_bot real))) : monoid.fg (generalized_boolean_algebra (has_bot real)) := sorry --non-trivial
lemma new_lemma_21293 : punit := sorry --non-trivial
lemma new_lemma_21294 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_dist.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_dist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_21295 (h0 : topological_space (option empty)) : totally_disconnected_space (option empty) := sorry --non-trivial
lemma new_lemma_21296 (h1 : not (topological_space (has_ssubset linarith.comp_source) -> false)) : @t0_space.{0} (has_ssubset.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (has_ssubset.{0} linarith.comp_source)) h1)  := sorry --non-trivial
lemma new_lemma_21297 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_21298 (h4 : ring (has_compl (has_ssubset char))) : is_domain (has_compl (has_ssubset char)) := sorry --non-trivial
lemma new_lemma_21299 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @preirreducible_space.{0} (measurable_space.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (measurable_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_21300 (h0 : uniform_space (pseudo_metric_space (option (ordered_cancel_add_comm_monoid unsigned)))) : complete_space (pseudo_metric_space (option (ordered_cancel_add_comm_monoid unsigned))) := sorry --non-trivial
lemma new_lemma_21301 (h0 : functor.add_const (monoid (has_pos_part pos)) name) : @monoid.fg.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 0} (monoid.{0} (has_pos_part.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_21302 (h0 : function.extfun Type group) : @group.fg.{0} (has_inv.{0} string_imp) (@function.extfun_app.{2 1} Type group.{0} h0 (has_inv.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_21303 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_21304 (h0 : functor.add_const (filter (has_neg linarith.comp)) (ring Type)) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_21305 (h1 : function.extfun Type list) : list.nodup (function.extfun_app h1 string_imp) := sorry --non-trivial
lemma new_lemma_21306 (h0 : measurable_space (measurable_space string_imp) -> Prop) : Exists h0 := sorry --non-trivial
lemma new_lemma_21307 (h0 : topological_space (finset (has_pos_part (finset linarith.comp)))) : locally_compact_space (finset (has_pos_part (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_21308 (h0 : topological_space (boolean_algebra (has_add environment.implicit_infer_kind))) : t0_space (boolean_algebra (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_21309 (h0 : functor.add_const (finset (add_cancel_monoid linarith.comp)) linarith.comp) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_21310 (h0 : functor.add_const (ring (has_to_string Type)) Type) : @is_domain.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 1} (ring.{1} (has_to_string.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_21311 (h0 : topological_space (ordered_cancel_add_comm_monoid (option (option (option empty))))) : t1_space (ordered_cancel_add_comm_monoid (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_21312 (h0 : topological_space (has_norm to_additive.value_type)) : locally_compact_space (has_norm to_additive.value_type) := sorry --non-trivial
lemma new_lemma_21313 (h0 : filter (has_nndist (has_nndist pos))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_21314 (h0 : finset (finset (finset pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_21315 (h1 : not (topological_space (semi_normed_ring linarith.comp_source) -> false)) : @totally_disconnected_space.{0} (semi_normed_ring.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (semi_normed_ring.{0} linarith.comp_source)) h1)  := sorry --non-trivial
lemma new_lemma_21316 (h0 : complete_lattice (has_Inf real)) : complete_lattice.is_Sup_finite_compact (has_Inf real) := sorry --non-trivial
lemma new_lemma_21317 (h0 : topological_space (ring Type)) : totally_disconnected_space (ring Type) := sorry --non-trivial
lemma new_lemma_21318 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (simple_graph.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (simple_graph.{0} name))  := sorry --non-trivial
lemma new_lemma_21319 (h0 : functor.add_const (function.extfun Type list) name) : palindrome (function.extfun_app (functor.add_const.run h0) (add_cancel_monoid name)) := sorry --non-trivial
lemma new_lemma_21320 (h0 : fin has_zero.zero) : @sequential_space.{0} (has_Inf.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (has_Inf.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_21321 (h0 : functor.add_const (complete_lattice (finset congr_arg_kind)) (option empty)) : @is_compactly_generated.{0} (finset.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (finset.{0} congr_arg_kind)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_21322 (h0 : ring (boolean_algebra (has_to_string (has_to_string (has_to_string (has_to_string pos)))))) : rank_condition (boolean_algebra (has_to_string (has_to_string (has_to_string (has_to_string pos))))) := sorry --non-trivial
lemma new_lemma_21323 (h0 : not (list (has_emptyc fun_info) -> false)) : list.nodup (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_21324 (h0 : functor.add_const (topological_space (bin_tree congr_arg_kind)) congr_arg_kind) : @totally_separated_space.{0} (bin_tree.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (bin_tree.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_21325 (h0 : complete_lattice (canonically_ordered_add_monoid empty)) : complete_lattice.is_Sup_finite_compact (canonically_ordered_add_monoid empty) := sorry --non-trivial
lemma new_lemma_21326 (h0 : set (has_compl (simple_graph linarith.comp_source))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_21327 (h0 : functor.add_const (topological_space (ring unsigned)) name) : @normal_space.{0} (ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_21328 (h0 : functor.add_const (topological_space (add_comm_monoid environment.implicit_infer_kind)) Type) : @regular_space.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (add_comm_monoid.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_21329 (h0 : topological_space (with_one (semiring (has_top unsigned)))) : totally_disconnected_space (with_one (semiring (has_top unsigned))) := sorry --non-trivial
lemma new_lemma_21330 (h0 : topological_space (normed_field std_gen)) (h1 : add_group (normed_field std_gen)) : topological_add_group (normed_field std_gen) := sorry --non-trivial
lemma new_lemma_21331 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_inv.{0} (has_top.{0} to_additive.value_type)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inv.{0} (has_top.{0} to_additive.value_type)))  := sorry --non-trivial
lemma new_lemma_21332 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_neg_part.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_neg_part.{0} name))  := sorry --non-trivial
lemma new_lemma_21333 (h0 : complete_lattice (simple_graph char)) : complete_lattice.is_Sup_finite_compact (simple_graph char) := sorry --non-trivial
lemma new_lemma_21334 (h0 : topological_space (ordered_comm_group unsigned)) : path_connected_space (ordered_comm_group unsigned) := sorry --non-trivial
lemma new_lemma_21335 (h0 : uniform_space (non_unital_non_assoc_semiring (mul_one_class string_imp))) : complete_space (non_unital_non_assoc_semiring (mul_one_class string_imp)) := sorry --non-trivial
lemma new_lemma_21336 (h0 : fin has_zero.zero) : @complete_space.{1} (add_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (uniform_space.{1} (add_comm_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_21337 (h0 : topological_space (has_nnnorm string_imp)) : totally_disconnected_space (has_nnnorm string_imp) := sorry --non-trivial
lemma new_lemma_21338 (h0 : topological_space (add_cancel_monoid (finset Type))) : loc_path_connected_space (add_cancel_monoid (finset Type)) := sorry --non-trivial
lemma new_lemma_21339 (h0 : group (ordered_cancel_add_comm_monoid empty)) : normalizer_condition (ordered_cancel_add_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_21340 (h0 : topological_space (semigroup (has_neg_part unsigned))) : t0_space (semigroup (has_neg_part unsigned)) := sorry --non-trivial
lemma new_lemma_21341 (h0 : has_lift linarith.ineq Prop) (h1 : linarith.ineq) : @lift.{1 1} linarith.ineq Prop h0 h1  := sorry --non-trivial
lemma new_lemma_21342 (h0 : monoid (has_neg (option num))) : monoid.fg (has_neg (option num)) := sorry --non-trivial
lemma new_lemma_21343 (h0 : has_mem.mem (with_bot (has_norm to_additive.value_type)) has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} (with_bot.{0} (has_norm.{0} to_additive.value_type)) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (with_bot.{0} (has_norm.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_21344 (h0 : monoid (ring (ring pos))) : monoid.fg (ring (ring pos)) := sorry --non-trivial
lemma new_lemma_21345 (h0 : topological_space (random_gen linarith.comp)) (h1 : set (random_gen linarith.comp)) : is_preirreducible h1 := sorry --non-trivial
lemma new_lemma_21346 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (sub_neg_monoid.{0} name) (@function.extfun_app.{2 1} Type add_group.{0} h0 (sub_neg_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_21347 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (canonically_ordered_comm_semiring.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (canonically_ordered_comm_semiring.{0} pos))  := sorry --non-trivial
lemma new_lemma_21348 (h0 : complete_lattice (linear_order (option (option empty)))) : complete_lattice.is_Sup_finite_compact (linear_order (option (option empty))) := sorry --non-trivial
lemma new_lemma_21349 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (complete_distrib_lattice.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} pos))  := sorry --non-trivial
lemma new_lemma_21350 (h0 : topological_space (comm_semigroup Type)) : totally_separated_space (comm_semigroup Type) := sorry --non-trivial
lemma new_lemma_21351 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring pos)) name) : @sequential_space.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_21352 (h0 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} (linear_ordered_add_comm_group.{0} linarith.ineq) (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h0) (linear_ordered_add_comm_group.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_21353 (h1 : ring (dlist string_imp)) : is_domain (dlist string_imp) := sorry --non-trivial
lemma new_lemma_21354 (h0 : topological_space (has_nndist (mul_zero_class unsigned))) : locally_compact_space (has_nndist (mul_zero_class unsigned)) := sorry --non-trivial
lemma new_lemma_21355 (h0 : topological_space (mul_zero_class (has_add (boolean_algebra.core (comm_group name))))) : normal_space (mul_zero_class (has_add (boolean_algebra.core (comm_group name)))) := sorry --non-trivial
lemma new_lemma_21356 (h0 : functor.add_const (complete_lattice (add_group num)) num) : @complete_lattice.is_Sup_finite_compact.{0} (add_group.{0} num) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_group.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_21357 (h0 : group (ordered_comm_ring (has_add pos))) : is_cyclic (ordered_comm_ring (has_add pos)) := sorry --non-trivial
lemma new_lemma_21358 (h0 : not (group (add_cancel_comm_monoid char) -> false)) : @is_cyclic.{0} (add_cancel_comm_monoid.{0} char) (@classical.by_contradiction'.{1} (group.{0} (add_cancel_comm_monoid.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_21359 (h0 : topological_space (normed_comm_ring (ring linarith.comp))) : totally_separated_space (normed_comm_ring (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_21360 (h0 : functor.add_const (add_monoid (ring environment.implicit_infer_kind)) Type) : @add_monoid.fg.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (add_monoid.{0} (ring.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_21361 (h0 : functor.add_const (functor.add_const (topological_space pos) linarith.comp) environment.implicit_infer_kind) : @loc_path_connected_space.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) linarith.comp (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (topological_space.{0} pos) linarith.comp) environment.implicit_infer_kind h0))  := sorry --non-trivial
lemma new_lemma_21362 (h0 : topological_space (semigroup (finset (finset pos)))) : regular_space (semigroup (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_21363 (h0 : monoid (complete_semilattice_Sup (semiring unsigned))) : monoid.fg (complete_semilattice_Sup (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_21364 (h0 : ring (canonically_linear_ordered_monoid (has_pos_part Type))) : rank_condition (canonically_linear_ordered_monoid (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_21365 (h0 : functor.add_const (uniform_space (has_nndist empty)) empty) : @separated_space.{0} (has_nndist.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_nndist.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_21366 (h0 : topological_space (has_lt (random_gen (random_gen string_imp)))) : t0_space (has_lt (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_21367 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (partial_order.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (partial_order.{0} num))  := sorry --non-trivial
lemma new_lemma_21368 (h0 : functor.add_const (group (ring linarith.comp)) Type) : @is_cyclic.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (group.{0} (ring.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_21369 (h1 : topological_space (mul_one_class (add_comm_semigroup ereal))) : path_connected_space (mul_one_class (add_comm_semigroup ereal)) := sorry --non-trivial
lemma new_lemma_21370 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @locally_compact_space.{0} (has_Inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (has_Inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_21371 (h0 : functor.add_const (ring (has_Inf name)) (has_neg (ring name))) : @is_principal_ideal_ring.{0} (has_Inf.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (has_Inf.{0} name)) (has_neg.{0} (ring.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_21372 (h0 : ring (comm_ring (random_gen (has_ssubset fun_info)))) : is_domain (comm_ring (random_gen (has_ssubset fun_info))) := sorry --non-trivial
lemma new_lemma_21373 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_sub.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (has_sub.{0} empty))  := sorry --non-trivial
lemma new_lemma_21374 (h0 : function.extfun (finset Type) (has_mem.mem (with_bot fun_info))) : @path_connected_space.{0} (with_bot.{0} fun_info) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_bot.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_bot.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_21375 (h0 : not (add_group (has_ssubset char) -> false)) : @is_add_cyclic.{0} (has_ssubset.{0} char) (@classical.by_contradiction'.{1} (add_group.{0} (has_ssubset.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_21376 (h0 : ring (has_lt (distrib (mul_one_class enat)))) : rank_condition (has_lt (distrib (mul_one_class enat))) := sorry --non-trivial
lemma new_lemma_21377 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (add_semigroup.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (add_semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_21378 (h0 : group (has_union (semiring (semiring unsigned)))) : normalizer_condition (has_union (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_21379 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_top.{0} char) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_top.{0} char))  := sorry --non-trivial
lemma new_lemma_21380 (h0 : semiring (has_to_string (finset name))) : is_noetherian_ring (has_to_string (finset name)) := sorry --non-trivial
lemma new_lemma_21381 (h0 : topological_space (comm_group environment.implicit_infer_kind)) : preconnected_space (comm_group environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_21382 (h0 : group (has_nndist (option name))) : is_simple_group (has_nndist (option name)) := sorry --non-trivial
lemma new_lemma_21383 (h0 : random_gen fun_info -> linarith.comp_source -> Prop) : relator.right_total h0 := sorry --non-trivial
lemma new_lemma_21384 (h0 : filter (ring (has_add linarith.comp))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_21385 (h0 : measurable_space (add_comm_semigroup linarith.ineq)) (h1 : set (add_comm_semigroup linarith.ineq)) : measurable_set h1 := sorry --non-trivial
lemma new_lemma_21386 (h0 : not (function.extfun Type group -> false)) : @group.fg.{0} (semiring.{0} empty) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_21387 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (option.{0} (semiring.{0} unsigned)) (@function.extfun_app.{2 1} Type semiring.{0} h0 (option.{0} (semiring.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_21388 (h0 : functor.add_const (complete_lattice (complete_distrib_lattice environment.implicit_infer_kind)) pos) : @is_atomistic.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_21389 (h0 : ring fun_info) : strong_rank_condition fun_info := sorry --non-trivial
lemma new_lemma_21390 (h0 : ordered_comm_monoid (linear_ordered_field (option (option (option (has_to_string pos)))))) : has_exists_mul_of_le (linear_ordered_field (option (option (option (has_to_string pos))))) := sorry --non-trivial
lemma new_lemma_21391 (h0 : monoid (linear_ordered_comm_group congr_arg_kind)) : monoid.fg (linear_ordered_comm_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_21392 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (has_top.{0} string_imp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_top.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_21393 (h0 : topological_space (add_comm_monoid (option (option (option (option (option ennreal))))))) : irreducible_space (add_comm_monoid (option (option (option (option (option ennreal)))))) := sorry --non-trivial
lemma new_lemma_21394 (h0 : function.extfun (Type 1) (functor.add_const (filter environment.implicit_infer_kind))) : countable_Inter_filter (functor.add_const.run (function.extfun_app h0 Type)) := sorry --non-trivial
lemma new_lemma_21395 (h0 : preorder (add_comm_semigroup enat)) (h1 : set (add_comm_semigroup enat)) : set.is_pwo h1 := sorry --non-trivial
lemma new_lemma_21396 (h0 : functor.add_const (function.extfun Type add_group) (mul_one_class (mul_one_class (has_add pos)))) : @is_add_cyclic.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_group.{0}) (mul_one_class.{0} (mul_one_class.{0} (has_add.{0} pos))) h0) (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_21397 (h0 : finset (comm_group (has_neg environment.implicit_infer_kind))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_21398 (h0 : functor.add_const (ring (boolean_algebra unsigned)) name) : @strong_rank_condition.{0} (boolean_algebra.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_21399 (h0 : not (function.extfun Type topological_space -> false)) : @discrete_topology.{0} (with_bot.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (with_bot.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_21400 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (complete_semilattice_Sup.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (complete_semilattice_Sup.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_21401 (h0 : group (semi_normed_comm_ring (has_top (has_nnnorm linarith.comp_source)))) : group.fg (semi_normed_comm_ring (has_top (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_21402 (h0 : not (function.extfun Type topological_space -> false)) : @totally_separated_space.{0} (linear_ordered_semiring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (linear_ordered_semiring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_21403 (h0 : semiring (semigroup (has_pos_part pos))) : is_noetherian_ring (semigroup (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_21404 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (simple_graph.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} h0 (simple_graph.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_21405 (h1 : filter (fintype (has_nnnorm (random_gen char)))) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_21406 (h0 : uniform_space (ordered_comm_monoid (has_nndist (has_nndist Type)))) : complete_space (ordered_comm_monoid (has_nndist (has_nndist Type))) := sorry --non-trivial
lemma new_lemma_21407 (h0 : functor.add_const (functor.add_const (add_monoid Type) pos) linarith.comp) : @add_monoid.fg.{1} Type (@functor.add_const.run.{1 0} (add_monoid.{1} Type) pos (@functor.add_const.run.{1 0} (functor.add_const.{1 0} (add_monoid.{1} Type) pos) linarith.comp h0))  := sorry --non-trivial
lemma new_lemma_21408 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @sequential_space.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_21409 (h0 : functor.add_const (filter (add_cancel_comm_monoid empty)) empty) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_21410 (h0 : add_group (has_one (semiring unsigned))) : is_add_cyclic (has_one (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_21411 (h0 : uniform_space (ring (ring linarith.comp))) : complete_space (ring (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_21412 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @locally_compact_space.{0} (random_gen.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) topological_space.{0}) (random_gen.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_21413 (h0 : function.extfun Type topological_space) : @sequential_space.{0} environment.implicit_infer_kind (@function.extfun_app.{2 1} Type topological_space.{0} h0 environment.implicit_infer_kind)  := sorry --non-trivial
lemma new_lemma_21414 (h0 : group (complete_distrib_lattice (finset pos))) : normalizer_condition (complete_distrib_lattice (finset pos)) := sorry --non-trivial
lemma new_lemma_21415 (h1 : not (add_group (has_lt string_imp) -> false)) : @is_add_cyclic.{0} (has_lt.{0} string_imp) (@classical.by_contradiction'.{1} (add_group.{0} (has_lt.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_21416 (h0 : ring (partial_order (semiring (semiring (semiring num))))) : is_principal_ideal_ring (partial_order (semiring (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_21417 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (with_one.{0} (has_top.{0} num)) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (with_one.{0} (has_top.{0} num)))  := sorry --non-trivial
lemma new_lemma_21418 (h0 : group (generalized_boolean_algebra (has_neg name))) : is_simple_group (generalized_boolean_algebra (has_neg name)) := sorry --non-trivial
lemma new_lemma_21419 (h0 : not (ring (distrib to_additive.value_type) -> false)) : @strong_rank_condition.{0} (distrib.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (distrib.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_21420 (h0 : function.extfun (Type 1) topological_space) : @preconnected_space.{1} (comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_21421 (h0 : topological_space (has_pos_part (has_neg (has_neg name)))) : totally_disconnected_space (has_pos_part (has_neg (has_neg name))) := sorry --non-trivial
lemma new_lemma_21422 (h0 : function.extfun Type (prod (option num))) : id_rel (function.extfun_app h0 (option num)) := sorry --non-trivial
lemma new_lemma_21423 (h0 : functor.add_const (complete_lattice (has_nndist environment.implicit_infer_kind)) environment.implicit_infer_kind) : @is_atomistic.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_nndist.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_21424 (h0 : topological_space (normed_lattice_add_comm_group (has_Inf (has_neg Type)))) : t1_space (normed_lattice_add_comm_group (has_Inf (has_neg Type))) := sorry --non-trivial
lemma new_lemma_21425 (h0 : add_group (is_R_or_C unsigned)) : is_add_cyclic (is_R_or_C unsigned) := sorry --non-trivial
lemma new_lemma_21426 (h0 : monoid (has_to_string (normed_comm_ring name))) : monoid.fg (has_to_string (normed_comm_ring name)) := sorry --non-trivial
lemma new_lemma_21427 (h0 : ring (has_neg (has_to_string Type))) : is_domain (has_neg (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_21428 (h0 : monoid (has_star (ordered_ring empty))) : monoid.fg (has_star (ordered_ring empty)) := sorry --non-trivial
lemma new_lemma_21429 (h0 : list (has_neg_part (boolean_algebra.core Type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_21430 (h0 : topological_space (has_union (semiring (semiring (semiring (semiring (semiring empty))))))) : irreducible_space (has_union (semiring (semiring (semiring (semiring (semiring empty)))))) := sorry --non-trivial
lemma new_lemma_21431 (h0 : measurable_space (linear_ordered_comm_group_with_zero to_additive.value_type)) (h1 : filter (linear_ordered_comm_group_with_zero to_additive.value_type)) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_21432 (h0 : ring (has_compl linarith.ineq)) : is_domain (has_compl linarith.ineq) := sorry --non-trivial
lemma new_lemma_21433 (h0 : has_lt (has_le enat)) : no_max_order (has_le enat) := sorry --non-trivial
lemma new_lemma_21434 (h0 : monoid (linear_ordered_semiring num)) : monoid.fg (linear_ordered_semiring num) := sorry --non-trivial
lemma new_lemma_21435 (h0 : function.extfun Type ring) : @is_domain.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (canonically_ordered_comm_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_21436 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (has_add name)) := sorry --non-trivial
lemma new_lemma_21437 (h0 : functor.add_const (group (add_cancel_monoid name)) Type) : @group.fg.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 1} (group.{0} (add_cancel_monoid.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_21438 (h0 : topological_space (normed_field (has_nnnorm (has_nnnorm string.iterator_imp)))) : totally_disconnected_space (normed_field (has_nnnorm (has_nnnorm string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_21439 (h0 : functor.add_const (function.extfun Type topological_space) name) : @totally_disconnected_space.{0} (has_to_string.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (has_to_string.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_21440 (h0 : semiring (left_cancel_monoid (option (option empty)))) : is_noetherian_ring (left_cancel_monoid (option (option empty))) := sorry --non-trivial
lemma new_lemma_21441 (h0 : functor.add_const (functor.add_const (monoid pos) (has_to_string unsigned)) Type) : @monoid.fg.{0} pos (@functor.add_const.run.{0 0} (monoid.{0} pos) (has_to_string.{0} unsigned) (@functor.add_const.run.{0 1} (functor.add_const.{0 0} (monoid.{0} pos) (has_to_string.{0} unsigned)) Type h0))  := sorry --non-trivial
lemma new_lemma_21442 (h0 : ring (has_add (has_add (boolean_algebra linarith.comp)))) : is_principal_ideal_ring (has_add (has_add (boolean_algebra linarith.comp))) := sorry --non-trivial
lemma new_lemma_21443 (h0 : not (function.extfun Type topological_space -> false)) : @totally_separated_space.{0} (add_group.{0} (semiring.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (add_group.{0} (semiring.{0} empty)))  := sorry --non-trivial
lemma new_lemma_21444 (h0 : functor.add_const (function.extfun (Type 1) topological_space) linarith.comp) : @normal_space.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) linarith.comp h0) (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_21445 (h0 : topological_space (has_nnnorm char) -> Prop) (h1 : Exists (fun (x : topological_space (has_nnnorm char)), h0 x)) : @path_connected_space.{0} (has_nnnorm.{0} char) (@classical.some.{1} (topological_space.{0} (has_nnnorm.{0} char)) h0 h1)  := sorry --non-trivial
lemma new_lemma_21446 (h0 : functor.add_const (topological_space (generalized_boolean_algebra pos)) (has_Inf Type)) : @discrete_topology.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (generalized_boolean_algebra.{0} pos)) (has_Inf.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_21447 (h0 : topological_space (linear_ordered_comm_ring unsigned)) : totally_disconnected_space (linear_ordered_comm_ring unsigned) := sorry --non-trivial
lemma new_lemma_21448 (h0 : not (topological_space (plift num) -> false)) : @locally_compact_space.{1} (plift.{1} num) (@classical.by_contradiction'.{2} (topological_space.{1} (plift.{1} num)) h0)  := sorry --non-trivial
lemma new_lemma_21449 (h0 : functor.add_const (ordered_comm_monoid (ordered_comm_ring linarith.comp)) pos) : @has_exists_mul_of_le.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (ordered_comm_ring.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_21450 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (add_right_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (add_right_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_21451 (h0 : uniform_space (has_Inf (boolean_algebra (ring Type)))) : complete_space (has_Inf (boolean_algebra (ring Type))) := sorry --non-trivial
lemma new_lemma_21452 (h0 : uniform_space (has_add linarith.comp_source)) : complete_space (has_add linarith.comp_source) := sorry --non-trivial
lemma new_lemma_21453 (h0 : has_lt (simple_graph reducibility_hints)) : no_max_order (simple_graph reducibility_hints) := sorry --non-trivial
lemma new_lemma_21454 (h0 : topological_space (add_monoid linarith.comp_source)) : t0_space (add_monoid linarith.comp_source) := sorry --non-trivial
lemma new_lemma_21455 (h0 : function.extfun Type group) : @is_cyclic.{0} (@id.{2} Type string_imp) (@function.extfun_app.{2 1} Type group.{0} h0 (@id.{2} Type string_imp))  := sorry --non-trivial
lemma new_lemma_21456 (h0 : ring (random_gen to_additive.value_type)) : is_domain (random_gen to_additive.value_type) := sorry --non-trivial
lemma new_lemma_21457 (h0 : functor.add_const (complete_lattice (measurable_space.dynkin_system empty)) empty) : @is_compactly_generated.{0} (measurable_space.dynkin_system.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (measurable_space.dynkin_system.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_21458 (h0 : complete_lattice (has_sub (semiring num))) : is_compactly_generated (has_sub (semiring num)) := sorry --non-trivial
lemma new_lemma_21459 (h0 : complete_lattice (complete_semilattice_Sup linarith.comp)) : complete_lattice.is_Sup_finite_compact (complete_semilattice_Sup linarith.comp) := sorry --non-trivial
lemma new_lemma_21460 (h0 : monoid (has_Inf (has_add linarith.comp))) : monoid.fg (has_Inf (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_21461 (h0 : ring (semigroup (finset (complete_semilattice_Sup (ring linarith.comp))))) : rank_condition (semigroup (finset (complete_semilattice_Sup (ring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_21462 (h0 : complete_lattice (has_to_string (cancel_monoid Type))) : is_atomistic (has_to_string (cancel_monoid Type)) := sorry --non-trivial
lemma new_lemma_21463 (h0 : complete_lattice (has_nnnorm (random_gen to_additive.value_type))) : is_compactly_generated (has_nnnorm (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_21464 (h0 : not (group (comm_ring fun_info) -> false)) : @group.fg.{0} (comm_ring.{0} fun_info) (@classical.by_contradiction'.{1} (group.{0} (comm_ring.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_21465 (h1 : uniform_space (non_unital_non_assoc_semiring (has_lt linarith.comp_source))) : complete_space (non_unital_non_assoc_semiring (has_lt linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_21466 (h1 : not (topological_space (dlist linarith.ineq) -> false)) : @t0_space.{0} (dlist.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (dlist.{0} linarith.ineq)) h1)  := sorry --non-trivial
lemma new_lemma_21467 (h0 : functor.add_const (add_group (boolean_algebra environment.implicit_infer_kind)) Type) : @is_add_cyclic.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (add_group.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_21468 (h0 : functor.add_const (ring (ring linarith.comp)) environment.implicit_infer_kind) : @rank_condition.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (ring.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_21469 (h1 : add_group (comm_ring char)) : is_add_cyclic (comm_ring char) := sorry --non-trivial
lemma new_lemma_21470 (h0 : functor.add_const (add_monoid (omega_complete_partial_order empty)) (option empty)) : @add_monoid.fg.{0} (omega_complete_partial_order.{0} empty) (@functor.add_const.run.{0 0} (add_monoid.{0} (omega_complete_partial_order.{0} empty)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_21471 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (linear_ordered_comm_ring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_ring.{0} num))  := sorry --non-trivial
lemma new_lemma_21472 (h0 : functor.add_const (topological_space (boolean_algebra unsigned)) Type) : @irreducible_space.{0} (boolean_algebra.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_21473 (h0 : functor.add_const (topological_space (finset Type)) linarith.comp) : @normal_space.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (finset.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_21474 (h0 : filter (ordered_ring (option congr_arg_kind))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_21475 (h0 : uniform_space (has_star (semiring congr_arg_kind))) : separated_space (has_star (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_21476 (h2 : ring (has_compl linarith.ineq)) : is_domain (has_compl linarith.ineq) := sorry --non-trivial
lemma new_lemma_21477 (h0 : topological_space (has_Inf (has_add (has_pos_part linarith.comp)))) : locally_compact_space (has_Inf (has_add (has_pos_part linarith.comp))) := sorry --non-trivial
lemma new_lemma_21478 (h0 : topological_space (option (option unsigned))) : preirreducible_space (option (option unsigned)) := sorry --non-trivial
lemma new_lemma_21479 (h0 : functor.add_const (function.extfun Type add_monoid) pos) : @add_monoid.fg.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type add_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_monoid.{0}) pos h0) (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_21480 (h1 : topological_space (normed_field linarith.ineq)) (h2 : add_group (normed_field linarith.ineq)) : topological_add_group (normed_field linarith.ineq) := sorry --non-trivial
lemma new_lemma_21481 (h0 : topological_space (has_neg (has_pos_part (finset linarith.comp)))) : locally_compact_space (has_neg (has_pos_part (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_21482 (h0 : functor.add_const (semiring (add_left_cancel_semigroup empty)) (option unsigned)) : @is_noetherian_ring.{0} (add_left_cancel_semigroup.{0} empty) (@functor.add_const.run.{0 0} (semiring.{0} (add_left_cancel_semigroup.{0} empty)) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_21483 (h0 : functor.comp topological_space normed_comm_ring name) : @sequential_space.{0} (normed_comm_ring.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} normed_comm_ring.{0} name h0)  := sorry --non-trivial
lemma new_lemma_21484 (h0 : ring (has_to_string (finset pos))) : is_principal_ideal_ring (has_to_string (finset pos)) := sorry --non-trivial
lemma new_lemma_21485 (h0 : filter (has_zero (has_add linarith.comp))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_21486 (h0 : functor.add_const (function.extfun Type complete_lattice) name) : @is_compactly_generated.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) name h0) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_21487 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_add_cyclic.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_group.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 add_group.{1}) (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_21488 (h1 : not (topological_space (id empty) -> false)) : @totally_disconnected_space.{0} (@id.{2} Type empty) (@classical.by_contradiction'.{1} (topological_space.{0} (@id.{2} Type empty)) h1)  := sorry --non-trivial
lemma new_lemma_21489 (h0 : functor.add_const (topological_space (bin_tree congr_arg_kind)) (semiring empty)) : @topological_space.separable_space.{0} (bin_tree.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (bin_tree.{0} congr_arg_kind)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_21490 (h0 : topological_space (finset pos)) : t1_space (finset pos) := sorry --non-trivial
lemma new_lemma_21491 (h0 : semiring (canonically_ordered_monoid (has_pos_part linarith.comp))) : is_noetherian_ring (canonically_ordered_monoid (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_21492 (h0 : topological_space (ordered_comm_ring (finset linarith.comp))) : preirreducible_space (ordered_comm_ring (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_21493 (h0 : ring (ring linarith.comp)) : is_domain (ring linarith.comp) := sorry --non-trivial
lemma new_lemma_21494 (h0 : ordered_add_comm_monoid (measurable_space.dynkin_system (semiring unsigned))) : archimedean (measurable_space.dynkin_system (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_21495 (h0 : ring (has_add (add_comm_monoid pos))) : rank_condition (has_add (add_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_21496 (h0 : functor.add_const (function.extfun Type ordered_comm_monoid) pos) : @has_exists_mul_of_le.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) pos h0) (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_21497 (h0 : cancel_comm_monoid_with_zero (generalized_boolean_algebra (ring Type))) : unique_factorization_monoid (generalized_boolean_algebra (ring Type)) := sorry --non-trivial
lemma new_lemma_21498 (h0 : has_mem.mem (with_bot linarith.ineq) has_emptyc.emptyc) : @path_connected_space.{0} (with_bot.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_bot.{0} linarith.ineq) h0)  := sorry --non-trivial
lemma new_lemma_21499 (h0 : not (group unsigned -> false)) : @normalizer_condition.{0} unsigned (@classical.by_contradiction'.{1} (group.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_21500 (h0 : topological_space (ordered_comm_ring (has_nndist Type))) : t1_space (ordered_comm_ring (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_21501 (h1 : group linarith.comp) : normalizer_condition linarith.comp := sorry --non-trivial
lemma new_lemma_21502 (h1 : not (topological_space (denumerable char) -> false)) : @path_connected_space.{0} (denumerable.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (denumerable.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_21503 (h0 : functor.add_const (group (has_Inf name)) (has_neg name)) : @group.fg.{0} (has_Inf.{0} name) (@functor.add_const.run.{0 0} (group.{0} (has_Inf.{0} name)) (has_neg.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_21504 (h0 : group (has_neg ennreal)) : normalizer_condition (has_neg ennreal) := sorry --non-trivial
lemma new_lemma_21505 (h0 : group (complete_distrib_lattice (has_Inf (has_to_string Type)))) : is_cyclic (complete_distrib_lattice (has_Inf (has_to_string Type))) := sorry --non-trivial
lemma new_lemma_21506 (h0 : topological_space (has_top string_imp)) : irreducible_space (has_top string_imp) := sorry --non-trivial
lemma new_lemma_21507 (h0 : ring (uniform_space (uniform_space string.iterator_imp))) : rank_condition (uniform_space (uniform_space string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_21508 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (non_assoc_semiring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (non_assoc_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_21509 (h0 : group (id (random_gen string_imp))) : group.fg (id (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_21510 (h0 : semiring (complete_semilattice_Sup (semiring num))) : is_noetherian_ring (complete_semilattice_Sup (semiring num)) := sorry --non-trivial
lemma new_lemma_21511 (h0 : function.extfun nat fin) : @is_noetherian_ring.{0} (generalized_boolean_algebra.{0} real) (@matrix.vec_empty.{0} (semiring.{0} (generalized_boolean_algebra.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_21512 (h0 : cancel_comm_monoid_with_zero (normed_lattice_add_comm_group (has_Inf Type))) : unique_factorization_monoid (normed_lattice_add_comm_group (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_21513 (h0 : topological_space (id empty)) : normal_space (id empty) := sorry --non-trivial
lemma new_lemma_21514 (h0 : ring (add_cancel_monoid (option num))) : rank_condition (add_cancel_monoid (option num)) := sorry --non-trivial
lemma new_lemma_21515 (h0 : uniform_space (add_comm_monoid (comm_monoid unsigned))) : complete_space (add_comm_monoid (comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_21516 (h0 : Prop) : list.ilast (list.ret h0) := sorry --non-trivial
lemma new_lemma_21517 (h0 : topological_space (mul_one_class (normed_field string.iterator_imp))) : path_connected_space (mul_one_class (normed_field string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_21518 (h0 : list (cancel_monoid (boolean_algebra name))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_21519 (h0 : complete_lattice (with_bot (semiring num))) : is_atomistic (with_bot (semiring num)) := sorry --non-trivial
lemma new_lemma_21520 (h0 : list (has_norm (comm_ring to_additive.value_type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_21521 (h0 : semiring (pseudo_metric_space (has_to_string pos))) : is_noetherian_ring (pseudo_metric_space (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_21522 (h0 : topological_space (comm_group unsigned)) : loc_path_connected_space (comm_group unsigned) := sorry --non-trivial
lemma new_lemma_21523 (h1 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h1 (with_bot to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_21524 (h0 : topological_space (monoid (option (option (option (option (option ennreal))))))) : discrete_topology (monoid (option (option (option (option (option ennreal)))))) := sorry --non-trivial
lemma new_lemma_21525 (h0 : functor.add_const (topological_space (linear_ordered_field name)) pos) : @discrete_topology.{0} (linear_ordered_field.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_field.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_21526 (h0 : topological_space (boolean_algebra (has_pos_part environment.implicit_infer_kind))) : path_connected_space (boolean_algebra (has_pos_part environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_21527 (h0 : uniform_space (has_neg (comm_group name))) : separated_space (has_neg (comm_group name)) := sorry --non-trivial
lemma new_lemma_21528 (h0 : ordered_add_comm_monoid (generalized_boolean_algebra (has_add pos))) : archimedean (generalized_boolean_algebra (has_add pos)) := sorry --non-trivial
lemma new_lemma_21529 (h0 : functor.add_const (topological_space (ordered_comm_monoid linarith.comp)) pos) : @locally_compact_space.{0} (ordered_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_monoid.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_21530 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @totally_disconnected_space.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_21531 (h0 : not (has_mem.mem (semiring fun_info) has_emptyc.emptyc -> false)) : @discrete_topology.{0} (semiring.{0} fun_info) (@finset.pi.empty.{1 0} Type topological_space.{0} (semiring.{0} fun_info) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} fun_info) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_21532 (h0 : not (topological_space (id linarith.ineq) -> false)) : @totally_disconnected_space.{0} (@id.{2} Type linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (@id.{2} Type linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_21533 (h0 : topological_space (measure_theory.measure_space (semiring num))) : t0_space (measure_theory.measure_space (semiring num)) := sorry --non-trivial
lemma new_lemma_21534 (h2 : ring (distrib string.iterator_imp)) : rank_condition (distrib string.iterator_imp) := sorry --non-trivial
lemma new_lemma_21535 (h0 : function.extfun Type (functor.add_const (topological_space (linear_order empty)))) : @normal_space.{0} (linear_order.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_order.{0} empty)) congr_arg_kind (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (linear_order.{0} empty))) h0 congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_21536 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (normed_linear_ordered_group.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_linear_ordered_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_21537 (h0 : ring (comm_ring reducibility_hints)) : rank_condition (comm_ring reducibility_hints) := sorry --non-trivial
lemma new_lemma_21538 (h0 : functor.add_const (function.extfun Type topological_space) name) : @irreducible_space.{0} (has_Inf.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (has_Inf.{0} name))  := sorry --non-trivial
lemma new_lemma_21539 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (ordered_cancel_add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_cancel_add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_21540 (h0 : functor.add_const (monoid (add_comm_monoid linarith.comp)) (has_neg (has_neg (has_neg pos)))) : @monoid.fg.{0} (add_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (monoid.{0} (add_comm_monoid.{0} linarith.comp)) (has_neg.{0} (has_neg.{0} (has_neg.{0} pos))) h0)  := sorry --non-trivial
lemma new_lemma_21541 (h0 : not (ring (complete_semilattice_Sup linarith.comp_source) -> false)) : @rank_condition.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (complete_semilattice_Sup.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_21542 (h0 : ring (generalized_boolean_algebra (finset (has_neg (has_neg pos))))) : is_domain (generalized_boolean_algebra (finset (has_neg (has_neg pos)))) := sorry --non-trivial
lemma new_lemma_21543 (h0 : topological_space (add_cancel_comm_monoid (semiring unsigned))) : totally_disconnected_space (add_cancel_comm_monoid (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_21544 (h2 : has_neg (has_lt enat)) (h3 : measurable_space (has_lt enat)) : has_measurable_neg (has_lt enat) := sorry --non-trivial
lemma new_lemma_21545 (h0 : functor.add_const (group (semigroup name)) name) : @normalizer_condition.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (group.{0} (semigroup.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_21546 (h0 : multiset (semi_normed_ring to_additive.value_type)) (h1 : not (multiset (semi_normed_ring to_additive.value_type) -> false)) : multiset.disjoint h0 (classical.by_contradiction' h1) := sorry --non-trivial
lemma new_lemma_21547 (h0 : functor.add_const (function.extfun Type topological_space) environment.implicit_infer_kind) : @irreducible_space.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) environment.implicit_infer_kind h0) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_21548 (h0 : list (boolean_algebra (has_Inf linarith.comp))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_21549 (h0 : generalized_boolean_algebra (sub_neg_monoid real) -> generalized_boolean_algebra (sub_neg_monoid real) -> Prop) : is_antisymm (generalized_boolean_algebra (sub_neg_monoid real)) h0 := sorry --non-trivial
lemma new_lemma_21550 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (add_semigroup unsigned)) := sorry --non-trivial
lemma new_lemma_21551 (h0 : list (free_add_monoid unsigned)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_21552 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (sub_neg_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (sub_neg_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_21553 (h0 : add_group (ordered_comm_ring (ring name))) : is_add_cyclic (ordered_comm_ring (ring name)) := sorry --non-trivial
lemma new_lemma_21554 (h0 : function.extfun (Type 1) list) : palindrome (function.extfun_app h0 (plift unsigned)) := sorry --non-trivial
lemma new_lemma_21555 (h0 : uniform_space (ordered_comm_group (option (option (option empty))))) : complete_space (ordered_comm_group (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_21556 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_21557 (h1 : not (topological_space (metric_space linarith.comp) -> false)) : @irreducible_space.{0} (metric_space.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (metric_space.{0} linarith.comp)) h1)  := sorry --non-trivial
lemma new_lemma_21558 (h0 : functor.add_const (function.extfun Type complete_lattice) linarith.comp) : @is_compactly_generated.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) linarith.comp h0) (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_21559 (h0 : set (has_le to_additive.value_type)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_21560 (h1 : function.extfun (finset Type) (has_mem.mem (with_bot linarith.ineq))) : @totally_separated_space.{0} (with_bot.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_bot.{0} linarith.ineq) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_bot.{0} linarith.ineq)) h1 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_21561 (h0 : functor.add_const (filter (has_add pos)) name) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_21562 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @is_noetherian_ring.{0} (has_union.{0} linarith.comp) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) semiring.{0}) (has_union.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_21563 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (add_cancel_monoid.{0} (option.{0} ennreal)) (@function.extfun_app.{2 1} Type monoid.{0} h0 (add_cancel_monoid.{0} (option.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_21564 (h0 : functor.add_const (function.extfun (Type 1) semiring) pos) : @is_noetherian_ring.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) semiring.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) semiring.{1}) pos h0) (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_21565 (h0 : complete_lattice (has_pos_part (finset linarith.comp))) : complete_lattice.is_Sup_finite_compact (has_pos_part (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_21566 (h0 : functor.add_const (topological_space (has_to_string name)) linarith.comp) : @t0_space.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_21567 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (finset.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_21568 (h0 : complete_lattice (monoid_with_zero (option (option unsigned)))) : complete_lattice.is_Sup_finite_compact (monoid_with_zero (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_21569 (h0 : has_norm (measurable_space (has_inv (has_inv (has_inv fun_info)))) -> Prop) : @infi.{0 1} Prop (@conditionally_complete_lattice.to_has_Inf.{0} Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice)) (has_norm.{0} (measurable_space.{0} (has_inv.{0} (has_inv.{0} (has_inv.{0} fun_info))))) h0  := sorry --non-trivial
lemma new_lemma_21570 (h0 : functor.comp uniform_space add_comm_monoid environment.implicit_infer_kind) : @complete_space.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} uniform_space.{0} add_comm_monoid.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_21571 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (complete_distrib_lattice.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (complete_distrib_lattice.{0} pos))  := sorry --non-trivial
lemma new_lemma_21572 (h0 : uniform_space (random_gen (random_gen (random_gen (random_gen (random_gen linarith.comp_source)))))) : complete_space (random_gen (random_gen (random_gen (random_gen (random_gen linarith.comp_source))))) := sorry --non-trivial
lemma new_lemma_21573 (h0 : topological_space (has_pos_part (has_add (finset pos)))) : preconnected_space (has_pos_part (has_add (finset pos))) := sorry --non-trivial
lemma new_lemma_21574 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @totally_disconnected_space.{0} (has_zero.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (has_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_21575 (h0 : topological_space (cancel_monoid (add_comm_monoid environment.implicit_infer_kind))) : irreducible_space (cancel_monoid (add_comm_monoid environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_21576 (h0 : functor.add_const (complete_lattice (complete_distrib_lattice Type)) pos) : @is_compactly_generated.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (complete_distrib_lattice.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_21577 (h0 : functor.comp topological_space semigroup Type) : @totally_disconnected_space.{1} (semigroup.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} semigroup.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_21578 (h0 : function.extfun (Type 1) filter) : filter.ne_bot (function.extfun_app h0 (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_21579 (h0 : semiring (has_edist (option (option (option (option (option empty))))))) : is_noetherian_ring (has_edist (option (option (option (option (option empty)))))) := sorry --non-trivial
lemma new_lemma_21580 (h0 : group (has_ssubset (has_nnnorm (has_nnnorm char)))) : group.fg (has_ssubset (has_nnnorm (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_21581 (h0 : functor.add_const (function.extfun Type finset) linarith.comp) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (add_cancel_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_21582 (h0 : complete_lattice (has_append (comm_ring (mul_one_class fun_info)))) : complete_lattice.is_Sup_finite_compact (has_append (comm_ring (mul_one_class fun_info))) := sorry --non-trivial
lemma new_lemma_21583 (h1 : uniform_space (random_gen (has_nnnorm string_imp))) : complete_space (random_gen (has_nnnorm string_imp)) := sorry --non-trivial
lemma new_lemma_21584 (h0 : complete_lattice (complete_linear_order (semiring empty))) : is_atomistic (complete_linear_order (semiring empty)) := sorry --non-trivial
lemma new_lemma_21585 (h0 : has_mem.mem fun_info has_emptyc.emptyc) : @path_connected_space.{0} fun_info (@finset.pi.empty.{1 0} Type topological_space.{0} fun_info h0)  := sorry --non-trivial
lemma new_lemma_21586 (h0 : not (ring (with_bot congr_arg_kind) -> false)) : @is_domain.{0} (with_bot.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (ring.{0} (with_bot.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_21587 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_21588 (h0 : functor.add_const (semiring (comm_group name)) name) : @is_noetherian_ring.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (semiring.{0} (comm_group.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_21589 (h0 : topological_space (has_nndist (finset (has_add pos)))) : totally_disconnected_space (has_nndist (finset (has_add pos))) := sorry --non-trivial
lemma new_lemma_21590 (h0 : add_monoid (ordered_cancel_add_comm_monoid (option (option unsigned)))) : add_monoid.fg (ordered_cancel_add_comm_monoid (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_21591 (h0 : ring (ring (finset linarith.comp))) : strong_rank_condition (ring (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_21592 (h0 : topological_space (has_Inf (has_neg (has_add (has_add name))))) : sequential_space (has_Inf (has_neg (has_add (has_add name)))) := sorry --non-trivial
lemma new_lemma_21593 (h0 : functor.add_const (function.extfun (Type 1) topological_space) Type) : @preirreducible_space.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) Type h0) (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_21594 (h0 : fin has_zero.zero) : @is_compactly_generated.{1} (simple_graph.{1} Type) (@matrix.vec_empty.{1} (complete_lattice.{1} (simple_graph.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_21595 (h0 : function.extfun nat fin) : @totally_separated_space.{0} (normed_lattice_add_comm_group.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (normed_lattice_add_comm_group.{0} real))  := sorry --non-trivial
lemma new_lemma_21596 (h0 : group (with_one (random_gen (random_gen linarith.comp_source)))) : normalizer_condition (with_one (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_21597 (h0 : uniform_space (with_one linarith.comp)) : separated_space (with_one linarith.comp) := sorry --non-trivial
lemma new_lemma_21598 (h0 : functor.comp topological_space has_zero name) : @totally_separated_space.{0} (has_zero.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} has_zero.{0} name h0)  := sorry --non-trivial
lemma new_lemma_21599 (h0 : function.extfun (Type 1) topological_space) : @totally_separated_space.{1} (comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_21600 (h0 : topological_space (semigroup (semigroup Type))) : discrete_topology (semigroup (semigroup Type)) := sorry --non-trivial
lemma new_lemma_21601 (h0 : topological_space (has_Inf (ring name))) : topological_space.separable_space (has_Inf (ring name)) := sorry --non-trivial
lemma new_lemma_21602 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (complete_semilattice_Sup string_imp)) := sorry --non-trivial
lemma new_lemma_21603 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} num (@function.extfun_app.{2 1} Type ring.{0} h0 num)  := sorry --non-trivial
lemma new_lemma_21604 (h0 : topological_space (id (linear_ordered_semiring unsigned))) : discrete_topology (id (linear_ordered_semiring unsigned)) := sorry --non-trivial
lemma new_lemma_21605 (h0 : list (has_add (has_to_string name))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_21606 (h0 : function.extfun Type topological_space) : @t1_space.{0} (canonically_linear_ordered_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_linear_ordered_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_21607 (h2 : measurable_space (nondiscrete_normed_field enat)) (h3 : measure_theory.measure (nondiscrete_normed_field enat)) : measure_theory.is_finite_measure h3 := sorry --non-trivial
lemma new_lemma_21608 (h0 : cancel_comm_monoid_with_zero (boolean_algebra (comm_group Type))) : unique_factorization_monoid (boolean_algebra (comm_group Type)) := sorry --non-trivial
lemma new_lemma_21609 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} (has_norm.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (has_norm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_21610 (h0 : functor.add_const (topological_space (finset unsigned)) (ring environment.implicit_infer_kind)) : @totally_disconnected_space.{0} (finset.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} unsigned)) (ring.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_21611 (h0 : function.extfun Type ring) : @is_domain.{0} (has_norm.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_norm.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_21612 (h0 : topological_space (ordered_cancel_add_comm_monoid ennreal)) : totally_disconnected_space (ordered_cancel_add_comm_monoid ennreal) := sorry --non-trivial
lemma new_lemma_21613 (h0 : topological_space (option num)) : discrete_topology (option num) := sorry --non-trivial
lemma new_lemma_21614 (h0 : topological_space (cancel_monoid (option empty))) : normal_space (cancel_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_21615 (h0 : functor.add_const (function.extfun (Type 1) add_monoid) linarith.comp) : @add_monoid.fg.{1} (add_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) add_monoid.{1}) linarith.comp h0) (add_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_21616 (h0 : topological_space (has_nndist unsigned)) : t0_space (has_nndist unsigned) := sorry --non-trivial
lemma new_lemma_21617 (h0 : functor.add_const (ordered_comm_monoid (comm_group unsigned)) (has_add Type)) : @has_exists_mul_of_le.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (comm_group.{0} unsigned)) (has_add.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_21618 (h0 : topological_space (has_le std_gen)) : t0_space (has_le std_gen) := sorry --non-trivial
lemma new_lemma_21619 (h0 : complete_lattice (has_zero (mul_zero_class unsigned))) : is_atomistic (has_zero (mul_zero_class unsigned)) := sorry --non-trivial
lemma new_lemma_21620 (h1 : filter (id fun_info)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_21621 (h1 : topological_space (has_emptyc congr_arg_kind)) : t0_space (has_emptyc congr_arg_kind) := sorry --non-trivial
lemma new_lemma_21622 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (boolean_algebra.core.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_21623 (h0 : filter (has_top linarith.ineq)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_21624 (h1 : ring (linear_ordered_add_comm_group (topological_space fun_info))) : rank_condition (linear_ordered_add_comm_group (topological_space fun_info)) := sorry --non-trivial
lemma new_lemma_21625 (h0 : finset (has_add (has_add environment.implicit_infer_kind))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_21626 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem ring)) : @rank_condition.{0} (random_gen.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) ring.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (random_gen.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_21627 (h0 : complete_lattice (has_norm (has_top (has_top (semiring unsigned))))) : is_atomistic (has_norm (has_top (has_top (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_21628 (h0 : functor.add_const (topological_space (has_nndist environment.implicit_infer_kind)) linarith.comp) : @t1_space.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_21629 (h0 : group (generalized_boolean_algebra (has_add (has_add pos)))) : group.fg (generalized_boolean_algebra (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_21630 (h0 : topological_space (boolean_algebra (has_Inf (has_add real)))) : t0_space (boolean_algebra (has_Inf (has_add real))) := sorry --non-trivial
lemma new_lemma_21631 (h0 : functor.add_const (monoid (add_comm_monoid unsigned)) linarith.comp) : @monoid.fg.{0} (add_comm_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (monoid.{0} (add_comm_monoid.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_21632 (h0 : function.extfun Type topological_space) : @normal_space.{0} (add_left_cancel_semigroup.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_left_cancel_semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_21633 (h0 : group (has_dist unsigned)) : normalizer_condition (has_dist unsigned) := sorry --non-trivial
lemma new_lemma_21634 (h0 : ring (with_bot (semiring empty))) : is_domain (with_bot (semiring empty)) := sorry --non-trivial
lemma new_lemma_21635 (h0 : ring (is_R_or_C empty)) : is_domain (is_R_or_C empty) := sorry --non-trivial
lemma new_lemma_21636 (h1 : function.extfun Type group) : @group.fg.{0} (normed_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h1 (normed_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_21637 (h0 : functor.add_const (topological_space (pseudo_metric_space unsigned)) (option ennreal)) : @preconnected_space.{0} (pseudo_metric_space.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (pseudo_metric_space.{0} unsigned)) (option.{0} ennreal) h0)  := sorry --non-trivial
lemma new_lemma_21638 (h0 : functor.add_const (topological_space (boolean_algebra.core Type)) Type) : @topological_space.separable_space.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (boolean_algebra.core.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_21639 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @regular_space.{0} (canonically_linear_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_linear_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_21640 (h0 : functor.add_const (add_monoid (generalized_boolean_algebra linarith.comp)) Type) : @add_monoid.fg.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 1} (add_monoid.{0} (generalized_boolean_algebra.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_21641 (h0 : add_group (finset (boolean_algebra.core name))) : is_add_cyclic (finset (boolean_algebra.core name)) := sorry --non-trivial
lemma new_lemma_21642 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (simple_graph.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (simple_graph.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_21643 (h0 : has_mem.mem (has_emptyc empty) has_emptyc.emptyc) : @is_compactly_generated.{0} (has_emptyc.{0} empty) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (has_emptyc.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_21644 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (has_Inf.{0} name) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (has_Inf.{0} name))  := sorry --non-trivial
lemma new_lemma_21645 (h1 : has_lt (linear_ordered_comm_group_with_zero linarith.comp_source)) : no_max_order (linear_ordered_comm_group_with_zero linarith.comp_source) := sorry --non-trivial
lemma new_lemma_21646 (h0 : filter (cancel_monoid pos)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_21647 (h0 : list (has_top fun_info)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_21648 (h0 : monoid string_imp) (h1 : topological_space (star_monoid string_imp)) (h2 : preorder (star_monoid string_imp)) : order_closed_topology (star_monoid string_imp) := sorry --non-trivial
lemma new_lemma_21649 (h0 : topological_space (random_gen unsigned)) : discrete_topology (random_gen unsigned) := sorry --non-trivial
lemma new_lemma_21650 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (add_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (add_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_21651 (h0 : topological_space (mul_zero_class (has_add (has_add ennreal)))) : sequential_space (mul_zero_class (has_add (has_add ennreal))) := sorry --non-trivial
lemma new_lemma_21652 (h0 : function.extfun Type group) : @is_cyclic.{0} (ordered_cancel_add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (ordered_cancel_add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_21653 (h0 : function.extfun Type (functor.comp ring cancel_monoid)) : @is_principal_ideal_ring.{0} (cancel_monoid.{0} name) (@functor.comp.run.{0 0 0} ring.{0} cancel_monoid.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} ring.{0} cancel_monoid.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_21654 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_to_string.{0} (has_nndist.{0} pos)) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_to_string.{0} (has_nndist.{0} pos)))  := sorry --non-trivial
lemma new_lemma_21655 (h0 : ring (has_pos_part (has_add (has_Inf (has_Inf pos))))) : strong_rank_condition (has_pos_part (has_add (has_Inf (has_Inf pos)))) := sorry --non-trivial
lemma new_lemma_21656 (h0 : topological_space (has_to_string (has_Inf Type))) : irreducible_space (has_to_string (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_21657 (h0 : functor.add_const (function.extfun Type add_group) Type) : @is_add_cyclic.{0} (has_neg.{0} name) (@function.extfun_app.{2 1} Type add_group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type add_group.{0}) Type h0) (has_neg.{0} name))  := sorry --non-trivial
lemma new_lemma_21658 (h0 : group (has_add (option (option ennreal)))) : normalizer_condition (has_add (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_21659 (h0 : int) : int.nonneg h0 := sorry --non-trivial
lemma new_lemma_21660 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_21661 (h0 : add_cancel_monoid (option ennreal) -> add_cancel_monoid (option ennreal) -> Prop) : is_symm (add_cancel_monoid (option ennreal)) h0 := sorry --non-trivial
lemma new_lemma_21662 (h0 : ordered_comm_monoid (has_Inf (ring (ring (has_Inf (has_neg (add_cancel_monoid Type))))))) : has_exists_mul_of_le (has_Inf (ring (ring (has_Inf (has_neg (add_cancel_monoid Type)))))) := sorry --non-trivial
lemma new_lemma_21663 (h1 : not (function.extfun Type group -> false)) : @group.fg.{0} (measurable_space.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h1) (measurable_space.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_21664 (h0 : topological_space (has_neg (has_nndist Type))) : totally_disconnected_space (has_neg (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_21665 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (omega_complete_partial_order.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (omega_complete_partial_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_21666 (h0 : functor.add_const (topological_space (complete_distrib_lattice unsigned)) empty) : @preirreducible_space.{0} (complete_distrib_lattice.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_21667 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (denumerable.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (denumerable.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_21668 (h0 : topological_space (metric_space (has_le char))) : totally_disconnected_space (metric_space (has_le char)) := sorry --non-trivial
lemma new_lemma_21669 (h0 : filter (comm_group (finset environment.implicit_infer_kind))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_21670 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @strong_rank_condition.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ring.{1}) (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_21671 (h0 : not (complete_lattice (non_unital_non_assoc_semiring (has_ssubset enat)) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (non_unital_non_assoc_semiring.{0} (has_ssubset.{0} enat)) (@classical.by_contradiction'.{1} (complete_lattice.{0} (non_unital_non_assoc_semiring.{0} (has_ssubset.{0} enat))) h0)  := sorry --non-trivial
lemma new_lemma_21672 (h0 : functor.add_const (complete_lattice (linear_ordered_comm_ring unsigned)) congr_arg_kind) : @is_atomistic.{0} (linear_ordered_comm_ring.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (linear_ordered_comm_ring.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_21673 (h0 : semiring (has_neg_part (has_add (add_comm_monoid (mul_zero_class unsigned))))) : is_noetherian_ring (has_neg_part (has_add (add_comm_monoid (mul_zero_class unsigned)))) := sorry --non-trivial
lemma new_lemma_21674 (h0 : group (semi_normed_comm_ring (has_nnnorm (has_nnnorm linarith.comp_source)))) : group.fg (semi_normed_comm_ring (has_nnnorm (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_21675 (h0 : topological_space (normed_group (random_gen (random_gen linarith.comp_source)))) : irreducible_space (normed_group (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_21676 (h0 : fin has_zero.zero) : @sequential_space.{0} (has_bot.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (has_bot.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_21677 (h0 : functor.add_const (semiring (boolean_algebra.core Type)) environment.implicit_infer_kind) : @is_noetherian_ring.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (semiring.{1} (boolean_algebra.core.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_21678 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (ring.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_21679 (h0 : list (finset (ordered_ring pos))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_21680 (h0 : ring (has_Inf (ring (has_neg Type)))) : rank_condition (has_Inf (ring (has_neg Type))) := sorry --non-trivial
lemma new_lemma_21681 (h0 : complete_lattice (topological_space (random_gen char))) : complete_lattice.is_Sup_finite_compact (topological_space (random_gen char)) := sorry --non-trivial
lemma new_lemma_21682 (h0 : topological_space (add_cancel_monoid (has_Inf (has_Inf (ring (ring (has_pos_part Type))))))) : normal_space (add_cancel_monoid (has_Inf (has_Inf (ring (ring (has_pos_part Type)))))) := sorry --non-trivial
lemma new_lemma_21683 (h0 : semiring (has_add (ring pos))) : is_noetherian_ring (has_add (ring pos)) := sorry --non-trivial
lemma new_lemma_21684 (h0 : list (has_ssubset (has_inv string_imp))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_21685 (h0 : group (semi_normed_comm_ring (has_nnnorm fun_info))) : is_cyclic (semi_normed_comm_ring (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_21686 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (group_with_zero.{0} (option.{0} (option.{0} num))) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (group_with_zero.{0} (option.{0} (option.{0} num))))  := sorry --non-trivial
lemma new_lemma_21687 (h0 : group (has_add (canonically_linear_ordered_monoid pos))) : normalizer_condition (has_add (canonically_linear_ordered_monoid pos)) := sorry --non-trivial
lemma new_lemma_21688 (h0 : filter (has_neg_part (option pos))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_21689 (h0 : topological_space (has_top (semiring empty))) : discrete_topology (has_top (semiring empty)) := sorry --non-trivial
lemma new_lemma_21690 (h0 : cancel_comm_monoid_with_zero (has_add environment.implicit_infer_kind)) : unique_factorization_monoid (has_add environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_21691 (h0 : not (group (measurable_space.dynkin_system congr_arg_kind) -> false)) : @is_cyclic.{0} (measurable_space.dynkin_system.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (group.{0} (measurable_space.dynkin_system.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_21692 (h0 : uniform_space (normed_group (has_top (semiring (measurable_space linarith.comp))))) : separated_space (normed_group (has_top (semiring (measurable_space linarith.comp)))) := sorry --non-trivial
lemma new_lemma_21693 (h0 : topological_space (linear_ordered_field ennreal)) : totally_separated_space (linear_ordered_field ennreal) := sorry --non-trivial
lemma new_lemma_21694 (h0 : not (ring (simple_graph string_imp) -> false)) : @is_domain.{0} (simple_graph.{0} string_imp) (@classical.by_contradiction'.{1} (ring.{0} (simple_graph.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_21695 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem group)) : @is_cyclic.{0} (semiring.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) group.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (semiring.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_21696 (h0 : complete_lattice (normed_lattice_add_comm_group (has_neg pos))) : is_compactly_generated (normed_lattice_add_comm_group (has_neg pos)) := sorry --non-trivial
lemma new_lemma_21697 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (linear_ordered_semiring.{0} num) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (linear_ordered_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_21698 (h0 : topological_space (semiring (semiring (semiring (semiring (semiring linarith.comp)))))) : t0_space (semiring (semiring (semiring (semiring (semiring linarith.comp))))) := sorry --non-trivial
lemma new_lemma_21699 (h0 : topological_space (ordered_comm_monoid name)) : path_connected_space (ordered_comm_monoid name) := sorry --non-trivial
lemma new_lemma_21700 (h0 : filter (ring Type)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_21701 (h0 : ring (denumerable fun_info)) : rank_condition (denumerable fun_info) := sorry --non-trivial
lemma new_lemma_21702 (h0 : functor.add_const (function.extfun (Type 1) add_monoid) name) : @add_monoid.fg.{1} (ordered_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) add_monoid.{1}) name h0) (ordered_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_21703 (h0 : group (has_add (has_neg (has_neg (has_neg Type))))) : group.fg (has_add (has_neg (has_neg (has_neg Type)))) := sorry --non-trivial
lemma new_lemma_21704 (h0 : topological_space (as_linear_order (option unsigned))) : preirreducible_space (as_linear_order (option unsigned)) := sorry --non-trivial
lemma new_lemma_21705 (h0 : group (left_cancel_monoid (semiring (semiring empty)))) : is_cyclic (left_cancel_monoid (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_21706 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_21707 (h0 : functor.add_const (ordered_comm_monoid (ring Type)) name) : @has_exists_mul_of_le.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (ordered_comm_monoid.{1} (ring.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_21708 (h0 : topological_space (linear_ordered_semiring (random_gen num))) : discrete_topology (linear_ordered_semiring (random_gen num)) := sorry --non-trivial
lemma new_lemma_21709 (h0 : functor.add_const (topological_space (ring environment.implicit_infer_kind)) name) : @regular_space.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_21710 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (free_add_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (free_add_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_21711 (h0 : functor.add_const (group (has_zero Type)) (finset (finset (finset linarith.comp)))) : @group.fg.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (has_zero.{1} Type)) (finset.{0} (finset.{0} (finset.{0} linarith.comp))) h0)  := sorry --non-trivial
lemma new_lemma_21712 (h0 : fin has_zero.zero) : @locally_compact_space.{1} (generalized_boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (generalized_boolean_algebra.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_21713 (h0 : topological_space (has_add to_additive.value_type)) : discrete_topology (has_add to_additive.value_type) := sorry --non-trivial
lemma new_lemma_21714 (h0 : group (has_to_string name)) : group.fg (has_to_string name) := sorry --non-trivial
lemma new_lemma_21715 (h0 : functor.add_const (group (has_edist empty)) empty) : @is_cyclic.{0} (has_edist.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (has_edist.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_21716 (h0 : functor.add_const (function.extfun (Type 1) group) Type) : @is_cyclic.{1} (has_neg.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) group.{1}) Type h0) (has_neg.{1} Type))  := sorry --non-trivial
lemma new_lemma_21717 (h0 : functor.add_const (function.extfun Type semiring) environment.implicit_infer_kind) : @is_noetherian_ring.{0} (has_zero.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type semiring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type semiring.{0}) environment.implicit_infer_kind h0) (has_zero.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_21718 (h0 : topological_space (generalized_boolean_algebra (has_add (has_add (has_Inf pos))))) : t0_space (generalized_boolean_algebra (has_add (has_add (has_Inf pos)))) := sorry --non-trivial
lemma new_lemma_21719 (h0 : topological_space (lattice num)) : t1_space (lattice num) := sorry --non-trivial
lemma new_lemma_21720 (h0 : functor.comp uniform_space complete_distrib_lattice environment.implicit_infer_kind) : @separated_space.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} uniform_space.{0} complete_distrib_lattice.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_21721 (h0 : not (group (has_one linarith.comp) -> false)) : @group.fg.{0} (has_one.{0} linarith.comp) (@classical.by_contradiction'.{1} (group.{0} (has_one.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_21722 (h0 : filter (complete_linear_order (semiring empty))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_21723 (h1 : topological_space std_gen) : totally_disconnected_space std_gen := sorry --non-trivial
lemma new_lemma_21724 (h0 : uniform_space (left_cancel_monoid congr_arg_kind)) : separated_space (left_cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_21725 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_21726 (h0 : ordered_add_comm_monoid (has_to_string (ring (has_neg Type)))) : archimedean (has_to_string (ring (has_neg Type))) := sorry --non-trivial
lemma new_lemma_21727 (h2 : topological_space linarith.comp_source) : path_connected_space linarith.comp_source := sorry --non-trivial
lemma new_lemma_21728 (h3 : not (ring (distrib_lattice fun_info) -> false)) : @rank_condition.{0} (distrib_lattice.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (distrib_lattice.{0} fun_info)) h3)  := sorry --non-trivial
lemma new_lemma_21729 (h0 : topological_space (measurable_space linarith.ineq)) : totally_separated_space (measurable_space linarith.ineq) := sorry --non-trivial
lemma new_lemma_21730 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (linear_ordered_comm_group.{0} pos) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (linear_ordered_comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_21731 (h1 : set reducibility_hints) : set.finite h1 := sorry --non-trivial
lemma new_lemma_21732 (h0 : complete_lattice (normed_comm_ring linarith.comp)) : complete_lattice.is_Sup_finite_compact (normed_comm_ring linarith.comp) := sorry --non-trivial
lemma new_lemma_21733 (h0 : monoid (measurable_space (random_gen (random_gen (random_gen (random_gen string_imp)))))) : monoid.fg (measurable_space (random_gen (random_gen (random_gen (random_gen string_imp))))) := sorry --non-trivial
lemma new_lemma_21734 (h0 : ring (id empty)) : is_principal_ideal_ring (id empty) := sorry --non-trivial
lemma new_lemma_21735 (h0 : topological_space (measurable_space (semiring (has_top congr_arg_kind)))) : t0_space (measurable_space (semiring (has_top congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_21736 (h0 : has_lt (linear_order std_gen)) : no_max_order (linear_order std_gen) := sorry --non-trivial
lemma new_lemma_21737 (h0 : uniform_space (has_lt (metric_space reducibility_hints))) : complete_space (has_lt (metric_space reducibility_hints)) := sorry --non-trivial
lemma new_lemma_21738 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (random_gen.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (random_gen.{0} num))  := sorry --non-trivial
lemma new_lemma_21739 (h0 : complete_lattice (add_comm_monoid environment.implicit_infer_kind)) : is_compactly_generated (add_comm_monoid environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_21740 (h0 : group (has_to_string (has_neg_part pos))) : normalizer_condition (has_to_string (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_21741 (h0 : with_bot (ulower (ulower Prop))) (h1 : ne h0 has_bot.bot) : @ulower.up.{0} Prop encodable.Prop (@ulower.up.{0} (@ulower.{0} Prop encodable.Prop) (@ulower.encodable.{0} Prop encodable.Prop) (@with_bot.unbot.{0} (@ulower.{0} (@ulower.{0} Prop encodable.Prop) (@ulower.encodable.{0} Prop encodable.Prop)) h0 h1))  := sorry --non-trivial
lemma new_lemma_21742 (h0 : complete_lattice (with_one (has_norm congr_arg_kind))) : complete_lattice.is_Sup_finite_compact (with_one (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_21743 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (finset.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (finset.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_21744 (h0 : group (normed_group linarith.comp)) : group.fg (normed_group linarith.comp) := sorry --non-trivial
lemma new_lemma_21745 (h0 : functor.add_const (group environment.implicit_infer_kind) unsigned) : @normalizer_condition.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 0} (group.{0} environment.implicit_infer_kind) unsigned h0)  := sorry --non-trivial
lemma new_lemma_21746 (h0 : add_group (simple_graph (has_neg (has_neg linarith.comp)))) : is_add_cyclic (simple_graph (has_neg (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_21747 (h0 : functor.add_const (finset (left_cancel_monoid num)) (semiring (semiring unsigned))) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_21748 (h0 : functor.add_const (add_group (boolean_algebra linarith.comp)) (has_neg_part (has_neg_part Type))) : @is_add_cyclic.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 1} (add_group.{0} (boolean_algebra.{0} linarith.comp)) (has_neg_part.{1} (has_neg_part.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_21749 (h0 : ring (linear_ordered_field congr_arg_kind)) : is_principal_ideal_ring (linear_ordered_field congr_arg_kind) := sorry --non-trivial
lemma new_lemma_21750 (h0 : topological_space (normed_comm_ring (option (option unsigned)))) : preconnected_space (normed_comm_ring (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_21751 (h0 : function.extfun Type (functor.add_const Prop)) : functor.add_const.run (function.extfun_app h0 unsigned) := sorry --non-trivial
lemma new_lemma_21752 (h0 : function.extfun Type group) : @group.fg.{0} name (@function.extfun_app.{2 1} Type group.{0} h0 name)  := sorry --non-trivial
lemma new_lemma_21753 (h0 : add_group (boolean_algebra.core (add_comm_monoid Type))) : is_add_cyclic (boolean_algebra.core (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_21754 (h0 : functor.add_const (add_group (semigroup empty)) empty) : @is_add_cyclic.{0} (semigroup.{0} empty) (@functor.add_const.run.{0 0} (add_group.{0} (semigroup.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_21755 (h0 : functor.add_const (ring (generalized_boolean_algebra name)) linarith.comp) : @is_principal_ideal_ring.{0} (generalized_boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (generalized_boolean_algebra.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_21756 (h0 : topological_space (metric_space (semiring unsigned))) : discrete_topology (metric_space (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_21757 (h0 : functor.add_const (complete_lattice (mul_zero_class congr_arg_kind)) congr_arg_kind) : @complete_lattice.is_Sup_finite_compact.{0} (mul_zero_class.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (mul_zero_class.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_21758 (h0 : complete_lattice (add_cancel_comm_monoid linarith.comp_source)) : complete_lattice.is_Sup_finite_compact (add_cancel_comm_monoid linarith.comp_source) := sorry --non-trivial
lemma new_lemma_21759 (h0 : list (has_emptyc (has_inv linarith.comp_source))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_21760 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (ordered_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_21761 (h0 : not (monoid (has_norm num) -> false)) : @monoid.fg.{0} (has_norm.{0} num) (@classical.by_contradiction'.{1} (monoid.{0} (has_norm.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_21762 (h0 : functor.add_const (topological_space (normed_linear_ordered_group congr_arg_kind)) unsigned) : @totally_separated_space.{0} (normed_linear_ordered_group.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_linear_ordered_group.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_21763 (h0 : ring (add_monoid (has_nnnorm (has_nnnorm (has_add fun_info))))) : rank_condition (add_monoid (has_nnnorm (has_nnnorm (has_add fun_info)))) := sorry --non-trivial
lemma new_lemma_21764 (h0 : functor.add_const (topological_space (ring name)) linarith.comp) : @irreducible_space.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_21765 (h0 : functor.comp topological_space has_add Type) : @regular_space.{1} (has_add.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} has_add.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_21766 (h0 : topological_space (has_lt (mul_one_class (mul_one_class to_additive.value_type)))) : t0_space (has_lt (mul_one_class (mul_one_class to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_21767 (h0 : functor.add_const (group (finset pos)) linarith.comp) : @group.fg.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (finset.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_21768 (h0 : list (linear_ordered_field (option (option unsigned)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_21769 (h0 : add_group (semiring (measurable_space (has_norm fun_info)))) : is_add_cyclic (semiring (measurable_space (has_norm fun_info))) := sorry --non-trivial
lemma new_lemma_21770 (h0 : uniform_space (measurable_space.dynkin_system (semiring unsigned))) : separated_space (measurable_space.dynkin_system (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_21771 (h0 : list (mul_zero_class (has_neg Type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_21772 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (normed_comm_ring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_21773 (h0 : field (with_bot linarith.ineq)) : is_alg_closed (with_bot linarith.ineq) := sorry --non-trivial
lemma new_lemma_21774 (h2 : topological_space (mul_one_class linarith.ineq)) (h3 : add_group (mul_one_class linarith.ineq)) : topological_add_group (mul_one_class linarith.ineq) := sorry --non-trivial
lemma new_lemma_21775 (h0 : complete_lattice (generalized_boolean_algebra Type)) : is_atomistic (generalized_boolean_algebra Type) := sorry --non-trivial
lemma new_lemma_21776 (h0 : functor.add_const (filter (canonically_ordered_comm_semiring Type)) (ring pos)) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_21777 (h0 : topological_space (has_to_string (finset (has_add name)))) : discrete_topology (has_to_string (finset (has_add name))) := sorry --non-trivial
lemma new_lemma_21778 (h1 : group (normed_group (bin_tree (random_gen congr_arg_kind)))) : is_cyclic (normed_group (bin_tree (random_gen congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_21779 (h0 : complete_lattice (nondiscrete_normed_field environment.projection_info)) : is_coatomistic (nondiscrete_normed_field environment.projection_info) := sorry --non-trivial
lemma new_lemma_21780 (h0 : topological_space (measurable_space ennreal)) : totally_separated_space (measurable_space ennreal) := sorry --non-trivial
lemma new_lemma_21781 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (has_add name)) := sorry --non-trivial
lemma new_lemma_21782 (h0 : ring (complete_linear_order (has_top (has_top empty)))) : rank_condition (complete_linear_order (has_top (has_top empty))) := sorry --non-trivial
lemma new_lemma_21783 (h2 : topological_space empty) : discrete_topology empty := sorry --non-trivial
lemma new_lemma_21784 (h0 : function.extfun (finset ((Type -> Type) -> Type 1)) (has_mem.mem (function.extfun Type))) : @is_atomistic.{0} fun_info (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@finset.pi.empty.{2 1} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) (function.extfun.{2 1} Type) (@function.extfun_app.{3 0} (finset.{2} ((Type → Type) → Type 1)) (@has_mem.mem.{2 2} ((Type → Type) → Type 1) (finset.{2} ((Type → Type) → Type 1)) (@finset.has_mem.{2} ((Type → Type) → Type 1)) (function.extfun.{2 1} Type)) h0 (@has_emptyc.emptyc.{2} (finset.{2} ((Type → Type) → Type 1)) (@finset.has_emptyc.{2} ((Type → Type) → Type 1))))) complete_lattice.{0}) fun_info)  := sorry --non-trivial
lemma new_lemma_21785 (h0 : complete_lattice (comm_group (option name))) : complete_lattice.is_Sup_finite_compact (comm_group (option name)) := sorry --non-trivial
lemma new_lemma_21786 (h0 : ulower pnat) (h1 : thunk pnat) : pnat.coprime (@id.{1} pnat (@ulower.up.{0} pnat encodable.pnat h0)) (@id.{1} pnat (@trace_call_stack.{0} pnat h1))  := sorry --non-trivial
lemma new_lemma_21787 (h0 : topological_space (simple_graph (ring (has_add (has_add pos))))) : topological_space.separable_space (simple_graph (ring (has_add (has_add pos)))) := sorry --non-trivial
lemma new_lemma_21788 (h0 : topological_space (complete_distrib_lattice (ordered_cancel_comm_monoid Type))) : loc_path_connected_space (complete_distrib_lattice (ordered_cancel_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_21789 (h0 : not (add_monoid (metric_space (semiring (semiring (semiring (semiring (has_top congr_arg_kind)))))) -> false)) : @add_monoid.fg.{0} (metric_space.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} (has_top.{0} congr_arg_kind)))))) (@classical.by_contradiction'.{1} (add_monoid.{0} (metric_space.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} (has_top.{0} congr_arg_kind))))))) h0)  := sorry --non-trivial
lemma new_lemma_21790 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (cancel_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_21791 (h0 : ring (has_Inf (has_Inf (has_neg name)))) : rank_condition (has_Inf (has_Inf (has_neg name))) := sorry --non-trivial
lemma new_lemma_21792 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (has_add to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_21793 (h0 : list (add_cancel_comm_monoid unsigned)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_21794 (h0 : group (boolean_algebra.core pos)) : is_cyclic (boolean_algebra.core pos) := sorry --non-trivial
lemma new_lemma_21795 (h0 : topological_space (linear_ordered_add_comm_group (has_top linarith.ineq))) : totally_separated_space (linear_ordered_add_comm_group (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_21796 (h0 : complete_lattice string_imp) : complete_lattice.is_Sup_finite_compact string_imp := sorry --non-trivial
lemma new_lemma_21797 (h1 : filter (has_top (has_inv (distrib_lattice to_additive.value_type)))) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_21798 (h0 : function.extfun nat fin) : @separated_space.{0} (normed_lattice_add_comm_group.{0} pos) (@matrix.vec_empty.{0} (uniform_space.{0} (normed_lattice_add_comm_group.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_21799 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_21800 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (@id.{2} Type unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (@id.{2} Type unsigned))  := sorry --non-trivial
lemma new_lemma_21801 (h0 : finset (add_comm_monoid (finset linarith.comp))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_21802 (h0 : topological_space (complete_distrib_lattice congr_arg_kind)) : t0_space (complete_distrib_lattice congr_arg_kind) := sorry --non-trivial
lemma new_lemma_21803 (h0 : group (has_inter (option (option unsigned)))) : group.fg (has_inter (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_21804 (h0 : functor.add_const (ring (complete_distrib_lattice linarith.comp)) Type) : @is_principal_ideal_ring.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.add_const.run.{0 1} (ring.{0} (complete_distrib_lattice.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_21805 (h0 : complete_lattice (comm_ring fun_info)) : complete_lattice.is_Sup_finite_compact (comm_ring fun_info) := sorry --non-trivial
lemma new_lemma_21806 (h0 : functor.add_const (list (add_left_cancel_semigroup unsigned)) unsigned) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_21807 (h0 : functor.add_const (filter (has_zero Type)) linarith.comp) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_21808 (h2 : Prop) : set.separates_points (id (fun (h1 : enat -> char), h2)) := sorry --non-trivial
lemma new_lemma_21809 (h0 : ordered_add_comm_monoid (has_bot (sub_neg_monoid real))) : archimedean (has_bot (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_21810 (h0 : functor.add_const (functor.add_const (topological_space pos) linarith.comp) (has_neg_part (has_add Type))) : @regular_space.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) linarith.comp (@functor.add_const.run.{0 1} (functor.add_const.{0 0} (topological_space.{0} pos) linarith.comp) (has_neg_part.{1} (has_add.{1} Type)) h0))  := sorry --non-trivial
lemma new_lemma_21811 (h0 : not (topological_space (has_emptyc (measurable_space linarith.comp_source)) -> false)) : @irreducible_space.{0} (has_emptyc.{0} (measurable_space.{0} linarith.comp_source)) (@classical.by_contradiction'.{1} (topological_space.{0} (has_emptyc.{0} (measurable_space.{0} linarith.comp_source))) h0)  := sorry --non-trivial
lemma new_lemma_21812 (h0 : functor.add_const Prop (comm_group unsigned)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_21813 (h0 : topological_space (boolean_algebra (has_pos_part (has_add (has_nndist pos))))) : irreducible_space (boolean_algebra (has_pos_part (has_add (has_nndist pos)))) := sorry --non-trivial
lemma new_lemma_21814 (h0 : functor.add_const (add_monoid (has_add environment.implicit_infer_kind)) pos) : @add_monoid.fg.{0} (has_add.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_add.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_21815 (h0 : group (add_left_cancel_monoid (has_nnnorm to_additive.value_type))) : is_cyclic (add_left_cancel_monoid (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_21816 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @is_compactly_generated.{0} (has_bot.{0} real) (@matrix.vec_empty.{0} (complete_lattice.{0} (has_bot.{0} real)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_21817 (h0 : cancel_comm_monoid_with_zero (mul_zero_class unsigned)) : unique_factorization_monoid (mul_zero_class unsigned) := sorry --non-trivial
lemma new_lemma_21818 (h1 : uniform_space (has_lt std_gen)) : complete_space (has_lt std_gen) := sorry --non-trivial
lemma new_lemma_21819 (h0 : topological_space (comm_ring linarith.ineq)) : path_connected_space (comm_ring linarith.ineq) := sorry --non-trivial
lemma new_lemma_21820 (h0 : topological_space (canonically_linear_ordered_monoid unsigned)) : irreducible_space (canonically_linear_ordered_monoid unsigned) := sorry --non-trivial
lemma new_lemma_21821 (h0 : topological_space (linear_ordered_comm_ring congr_arg_kind)) : t1_space (linear_ordered_comm_ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_21822 (h0 : function.extfun nat fin) : @monoid.fg.{0} (simple_graph.{0} pos) (@function.extfun_app.{2 1} Type monoid.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type monoid.{0}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (simple_graph.{0} pos))  := sorry --non-trivial
lemma new_lemma_21823 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (has_pos_part.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_pos_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_21824 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) (h1 : function.extfun (semigroup linarith.comp) (fun (x : semigroup linarith.comp), Prop)) : @is_totally_separated.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (semigroup.{0} linarith.comp)) (@function.extfun_app.{1 1} (semigroup.{0} linarith.comp) (λ (x : semigroup.{0} linarith.comp), Prop) h1)  := sorry --non-trivial
lemma new_lemma_21825 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (has_Inf.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_Inf.{0} name))  := sorry --non-trivial
lemma new_lemma_21826 (h0 : functor.add_const (ordered_add_comm_monoid (non_assoc_semiring congr_arg_kind)) unsigned) : @archimedean.{0} (non_assoc_semiring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (non_assoc_semiring.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_21827 (h0 : function.extfun (finset Type) (has_mem.mem (with_bot linarith.comp_source))) : @rank_condition.{0} (with_bot.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type ring.{0} (with_bot.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_bot.{0} linarith.comp_source)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_21828 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (group_with_zero.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (group_with_zero.{0} num))  := sorry --non-trivial
lemma new_lemma_21829 (h0 : topological_space (has_neg (finset (finset pos)))) : totally_disconnected_space (has_neg (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_21830 (h0 : filter (comm_semigroup real)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_21831 (h0 : ring (has_pos_part (ring (has_add Type)))) : is_domain (has_pos_part (ring (has_add Type))) := sorry --non-trivial
lemma new_lemma_21832 (h0 : ring (linear_ordered_field pos)) : is_principal_ideal_ring (linear_ordered_field pos) := sorry --non-trivial
lemma new_lemma_21833 (h0 : functor.add_const (topological_space (has_nndist name)) pos) : @normal_space.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_21834 (h0 : prod (complete_distrib_lattice empty) (complete_distrib_lattice empty)) : set.diagonal (complete_distrib_lattice empty) h0 := sorry --non-trivial
lemma new_lemma_21835 (h0 : topological_space (generalized_boolean_algebra (has_Inf linarith.comp))) : normal_space (generalized_boolean_algebra (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_21836 (h0 : complete_lattice (has_compl (has_nnnorm (semi_normed_comm_ring reducibility_hints)))) : is_compactly_generated (has_compl (has_nnnorm (semi_normed_comm_ring reducibility_hints))) := sorry --non-trivial
lemma new_lemma_21837 (h0 : functor.add_const (function.extfun Type topological_space) (has_add linarith.comp)) : @preirreducible_space.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (has_add.{0} linarith.comp) h0) (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_21838 (h0 : finset (add_cancel_monoid (has_neg name))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_21839 (h0 : function.extfun (Type 1) topological_space) : @totally_separated_space.{1} (mul_zero_class.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (mul_zero_class.{1} Type))  := sorry --non-trivial
lemma new_lemma_21840 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_21841 (h0 : ordered_comm_monoid (boolean_algebra.core name)) : has_exists_mul_of_le (boolean_algebra.core name) := sorry --non-trivial
lemma new_lemma_21842 (h0 : not (function.extfun Type ring -> false)) : @strong_rank_condition.{0} (@id.{2} Type empty) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (@id.{2} Type empty))  := sorry --non-trivial
lemma new_lemma_21843 (h0 : topological_space (simple_graph (has_nndist linarith.comp))) : locally_compact_space (simple_graph (has_nndist linarith.comp)) := sorry --non-trivial
lemma new_lemma_21844 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (has_add.{0} real) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (has_add.{0} real))  := sorry --non-trivial
lemma new_lemma_21845 (h0 : functor.add_const (topological_space (has_star empty)) empty) : @irreducible_space.{0} (has_star.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_21846 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_21847 (h0 : finset (option (semiring (semiring unsigned)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_21848 (h0 : topological_space (sub_neg_monoid (has_neg pos))) : locally_compact_space (sub_neg_monoid (has_neg pos)) := sorry --non-trivial
lemma new_lemma_21849 (h0 : ring (canonically_ordered_monoid (has_Inf (has_Inf pos)))) : is_principal_ideal_ring (canonically_ordered_monoid (has_Inf (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_21850 (h0 : topological_space (bin_tree unsigned)) : irreducible_space (bin_tree unsigned) := sorry --non-trivial
lemma new_lemma_21851 (h0 : finset (linear_ordered_comm_group unsigned)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_21852 (h1 : has_lt (normed_field (normed_field linarith.ineq))) : no_max_order (normed_field (normed_field linarith.ineq)) := sorry --non-trivial
lemma new_lemma_21853 (h0 : functor.add_const (filter (has_nndist unsigned)) pos) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_21854 (h0 : complete_lattice (normed_group (semiring congr_arg_kind))) : is_atomistic (normed_group (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_21855 (h0 : has_mem.mem (linear_ordered_semiring empty) has_emptyc.emptyc) : @normalizer_condition.{0} (linear_ordered_semiring.{0} empty) (@finset.pi.empty.{1 0} Type group.{0} (linear_ordered_semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_21856 (h0 : add_group (non_unital_non_assoc_semiring (metric_space char))) : is_add_cyclic (non_unital_non_assoc_semiring (metric_space char)) := sorry --non-trivial
lemma new_lemma_21857 (h0 : topological_space (mul_one_class (add_comm_semigroup fun_info))) : totally_disconnected_space (mul_one_class (add_comm_semigroup fun_info)) := sorry --non-trivial
lemma new_lemma_21858 (h0 : cancel_comm_monoid_with_zero (ring (ring (has_add pos)))) : unique_factorization_monoid (ring (ring (has_add pos))) := sorry --non-trivial
lemma new_lemma_21859 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (has_norm.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_norm.{0} num))  := sorry --non-trivial
lemma new_lemma_21860 (h0 : group (semigroup (has_Inf (finset (has_Inf (has_Inf linarith.comp)))))) : is_cyclic (semigroup (has_Inf (finset (has_Inf (has_Inf linarith.comp))))) := sorry --non-trivial
lemma new_lemma_21861 (h0 : function.extfun Type (functor.comp group complete_distrib_lattice)) : @is_simple_group.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} group.{0} complete_distrib_lattice.{0} environment.implicit_infer_kind (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} group.{0} complete_distrib_lattice.{0}) h0 environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_21862 (h2 : topological_space (denumerable to_additive.value_type)) : t0_space (denumerable to_additive.value_type) := sorry --non-trivial
lemma new_lemma_21863 (h0 : function.extfun (Type 1) uniform_space) : @separated_space.{1} (simple_graph.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} h0 (simple_graph.{1} Type))  := sorry --non-trivial
lemma new_lemma_21864 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_pos_part real)) real) : @unique_factorization_monoid.{0} (has_pos_part.{0} real) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_pos_part.{0} real)) real h0)  := sorry --non-trivial
lemma new_lemma_21865 (h0 : functor.add_const (topological_space (semiring congr_arg_kind)) congr_arg_kind) : @locally_compact_space.{0} (semiring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (semiring.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_21866 (h0 : functor.add_const (monoid (add_cancel_monoid pos)) (finset linarith.comp)) : @monoid.fg.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (monoid.{0} (add_cancel_monoid.{0} pos)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_21867 (h0 : functor.add_const (function.extfun (Type 1) ring) Type) : @is_domain.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) ring.{1}) Type h0) (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_21868 (h0 : function.extfun (Type 1) topological_space) : @regular_space.{1} (canonically_ordered_comm_semiring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (canonically_ordered_comm_semiring.{1} Type))  := sorry --non-trivial
lemma new_lemma_21869 (h0 : functor.add_const (topological_space (semigroup unsigned)) Type) : @t1_space.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (semigroup.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_21870 (h0 : not (topological_space (has_union unsigned) -> false)) : @normal_space.{0} (has_union.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (has_union.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_21871 (h1 : group (id Type)) : normalizer_condition (id Type) := sorry --non-trivial
lemma new_lemma_21872 (h0 : functor.add_const (list (has_neg_part Type)) Type) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_21873 (h0 : functor.add_const (ordered_add_comm_monoid (linear_order empty)) empty) : @archimedean.{0} (linear_order.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (linear_order.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_21874 (h0 : ring (is_R_or_C (semiring (option (option (semiring (semiring empty))))))) : strong_rank_condition (is_R_or_C (semiring (option (option (semiring (semiring empty)))))) := sorry --non-trivial
lemma new_lemma_21875 (h0 : ring (semiring (random_gen linarith.comp_source))) : strong_rank_condition (semiring (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_21876 (h0 : functor.add_const (uniform_space (normed_linear_ordered_group empty)) empty) : @complete_space.{0} (normed_linear_ordered_group.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (normed_linear_ordered_group.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_21877 (h0 : functor.add_const (topological_space (has_pos_part linarith.comp)) pos) : @preirreducible_space.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_21878 (h0 : topological_space (complete_distrib_lattice linarith.comp)) : irreducible_space (complete_distrib_lattice linarith.comp) := sorry --non-trivial
lemma new_lemma_21879 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (boolean_algebra.core.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} h0 (boolean_algebra.core.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_21880 (h0 : function.extfun nat fin) : @regular_space.{0} (canonically_linear_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (canonically_linear_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_21881 (h0 : add_group (with_one (has_inv (has_inv (has_inv linarith.ineq))))) : is_add_cyclic (with_one (has_inv (has_inv (has_inv linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_21882 (h0 : ring (normed_lattice_add_comm_group (sub_neg_monoid pos))) : rank_condition (normed_lattice_add_comm_group (sub_neg_monoid pos)) := sorry --non-trivial
lemma new_lemma_21883 (h0 : topological_space (add_group (semiring (semiring congr_arg_kind)))) : irreducible_space (add_group (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_21884 (h0 : group (as_linear_order congr_arg_kind)) : normalizer_condition (as_linear_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_21885 (h0 : finset (comm_monoid num)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_21886 (h0 : topological_space (fintype (with_zero linarith.ineq))) : path_connected_space (fintype (with_zero linarith.ineq)) := sorry --non-trivial
lemma new_lemma_21887 (h0 : functor.add_const (topological_space (has_Inf Type)) pos) : @irreducible_space.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_Inf.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_21888 (h0 : add_group (has_append (metric_space (metric_space char)))) : is_add_cyclic (has_append (metric_space (metric_space char))) := sorry --non-trivial
lemma new_lemma_21889 (h0 : functor.comp list has_neg_part name) : list.nodup (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_21890 (h0 : function.extfun (finset Type) (has_mem.mem (has_emptyc fun_info))) : @monoid.fg.{0} (has_emptyc.{0} fun_info) (@finset.pi.empty.{1 0} Type monoid.{0} (has_emptyc.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_emptyc.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_21891 (h0 : functor.add_const (function.extfun Type topological_space) (ring Type)) : @irreducible_space.{0} (ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) (ring.{1} Type) h0) (ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_21892 (h0 : topological_space (semiring empty)) : totally_disconnected_space (semiring empty) := sorry --non-trivial
lemma new_lemma_21893 (h0 : functor.add_const (group (boolean_algebra name)) pos) : @is_simple_group.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_21894 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (has_inter.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_inter.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_21895 (h1 : filter (dlist (has_norm string_imp))) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_21896 (h0 : complete_lattice (ordered_comm_ring real)) : is_atomistic (ordered_comm_ring real) := sorry --non-trivial
lemma new_lemma_21897 (h0 : group (has_neg ennreal)) : is_simple_group (has_neg ennreal) := sorry --non-trivial
lemma new_lemma_21898 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (has_add pos)) := sorry --non-trivial
lemma new_lemma_21899 (h0 : topological_space (has_neg (semigroup name))) : locally_compact_space (has_neg (semigroup name)) := sorry --non-trivial
lemma new_lemma_21900 (h0 : topological_space (partial_order num)) : totally_disconnected_space (partial_order num) := sorry --non-trivial
lemma new_lemma_21901 (h0 : not (topological_space (add_right_cancel_monoid num) -> false)) : @path_connected_space.{0} (add_right_cancel_monoid.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (add_right_cancel_monoid.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_21902 (h0 : ordered_add_comm_monoid (mul_zero_class Type)) : archimedean (mul_zero_class Type) := sorry --non-trivial
lemma new_lemma_21903 (h0 : group (has_zero (has_add (has_add linarith.comp)))) : is_simple_group (has_zero (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_21904 (h0 : group (monoid_with_zero string_imp)) : is_cyclic (monoid_with_zero string_imp) := sorry --non-trivial
lemma new_lemma_21905 (h0 : functor.add_const (function.extfun Type monoid) name) : @monoid.fg.{0} (has_zero.{0} name) (@function.extfun_app.{2 1} Type monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type monoid.{0}) name h0) (has_zero.{0} name))  := sorry --non-trivial
lemma new_lemma_21906 (h0 : uniform_space (sub_neg_monoid Type)) : separated_space (sub_neg_monoid Type) := sorry --non-trivial
lemma new_lemma_21907 (h0 : ring (filter unsigned)) : is_principal_ideal_ring (filter unsigned) := sorry --non-trivial
lemma new_lemma_21908 (h1 : list (with_bot (with_bot to_additive.value_type))) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_21909 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_emptyc.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_emptyc.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_21910 (h0 : topological_space (normed_group (has_top (has_top linarith.comp_source)))) : totally_separated_space (normed_group (has_top (has_top linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_21911 (h0 : set (has_nnnorm linarith.ineq)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_21912 (h0 : functor.add_const (topological_space (finset linarith.comp)) (finset pos)) : @t1_space.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} linarith.comp)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_21913 (h0 : uniform_space (topological_space (random_gen (random_gen char)))) : complete_space (topological_space (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_21914 (h0 : function.extfun nat fin) : @path_connected_space.{0} (add_comm_monoid.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (add_comm_monoid.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_21915 (h0 : functor.add_const (topological_space (bin_tree num)) congr_arg_kind) : @preirreducible_space.{0} (bin_tree.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (bin_tree.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_21916 (h0 : add_group (add_comm_monoid real)) : is_add_cyclic (add_comm_monoid real) := sorry --non-trivial
lemma new_lemma_21917 (h0 : functor.add_const (topological_space (measurable_space.dynkin_system num)) congr_arg_kind) : @locally_compact_space.{0} (measurable_space.dynkin_system.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (measurable_space.dynkin_system.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_21918 (h0 : functor.comp topological_space uniform_space unsigned) : @locally_compact_space.{0} (uniform_space.{0} unsigned) (@functor.comp.run.{0 0 0} topological_space.{0} uniform_space.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_21919 (h1 : group (id to_additive.value_type)) : group.fg (id to_additive.value_type) := sorry --non-trivial
lemma new_lemma_21920 (h0 : topological_space (canonically_ordered_monoid (has_Inf (finset (has_Inf real))))) : t0_space (canonically_ordered_monoid (has_Inf (finset (has_Inf real)))) := sorry --non-trivial
lemma new_lemma_21921 (h0 : add_group (metric_space (semiring num))) : is_add_cyclic (metric_space (semiring num)) := sorry --non-trivial
lemma new_lemma_21922 (h0 : group (has_to_string ennreal)) : normalizer_condition (has_to_string ennreal) := sorry --non-trivial
lemma new_lemma_21923 (h0 : semiring (monoid_with_zero congr_arg_kind)) : is_noetherian_ring (monoid_with_zero congr_arg_kind) := sorry --non-trivial
lemma new_lemma_21924 (h0 : functor.add_const (topological_space (comm_group Type)) linarith.comp) : @loc_path_connected_space.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (comm_group.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_21925 (h0 : has_mem.mem (random_gen num) has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} (random_gen.{0} num) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (random_gen.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_21926 (h0 : functor.add_const (add_monoid (comm_group name)) pos) : @add_monoid.fg.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (add_monoid.{0} (comm_group.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_21927 (h0 : group (add_left_cancel_semigroup (semiring (semiring empty)))) : normalizer_condition (add_left_cancel_semigroup (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_21928 (h0 : functor.add_const (group (ring environment.implicit_infer_kind)) name) : @is_cyclic.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (ring.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_21929 (h0 : functor.add_const (group (has_to_string unsigned)) (ring Type)) : @is_simple_group.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 1} (group.{0} (has_to_string.{0} unsigned)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_21930 (h0 : topological_space (has_lt (mul_one_class fun_info))) : t0_space (has_lt (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_21931 (h0 : functor.add_const (semiring (has_neg pos)) environment.implicit_infer_kind) : @is_noetherian_ring.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (semiring.{0} (has_neg.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_21932 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @normal_space.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_21933 (h0 : topological_space (boolean_algebra.core (has_add name))) : preirreducible_space (boolean_algebra.core (has_add name)) := sorry --non-trivial
lemma new_lemma_21934 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (has_to_string.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (has_to_string.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_21935 (h0 : functor.add_const (ordered_comm_monoid (ring Type)) (finset Type)) : @has_exists_mul_of_le.{1} (ring.{1} Type) (@functor.add_const.run.{1 1} (ordered_comm_monoid.{1} (ring.{1} Type)) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_21936 (h0 : functor.add_const (topological_space (boolean_algebra environment.implicit_infer_kind)) (ring linarith.comp)) : @totally_separated_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) (ring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_21937 (h0 : complete_lattice (comm_group (has_add (option name)))) : complete_lattice.is_Sup_finite_compact (comm_group (has_add (option name))) := sorry --non-trivial
lemma new_lemma_21938 (h0 : ring (canonically_ordered_comm_semiring (has_pos_part pos))) : is_domain (canonically_ordered_comm_semiring (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_21939 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (add_cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (add_cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_21940 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (linear_ordered_comm_group.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_group.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_21941 (h1 : ring (simple_graph to_additive.value_type)) : rank_condition (simple_graph to_additive.value_type) := sorry --non-trivial
lemma new_lemma_21942 (h0 : topological_space (has_emptyc to_additive.value_type)) : irreducible_space (has_emptyc to_additive.value_type) := sorry --non-trivial
lemma new_lemma_21943 (h0 : monoid (normed_group to_additive.value_type)) : monoid.fg (normed_group to_additive.value_type) := sorry --non-trivial
lemma new_lemma_21944 (h0 : not (monoid (complete_linear_order unsigned) -> false)) : @monoid.fg.{0} (complete_linear_order.{0} unsigned) (@classical.by_contradiction'.{1} (monoid.{0} (complete_linear_order.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_21945 (h0 : topological_space (complete_distrib_lattice (normed_comm_ring environment.implicit_infer_kind))) : preconnected_space (complete_distrib_lattice (normed_comm_ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_21946 (h0 : topological_space (normed_lattice_add_comm_group linarith.comp)) : loc_path_connected_space (normed_lattice_add_comm_group linarith.comp) := sorry --non-trivial
lemma new_lemma_21947 (h0 : complete_lattice (has_zero (ring (finset linarith.comp)))) : is_compactly_generated (has_zero (ring (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_21948 (h0 : group (has_edist (option unsigned))) : is_cyclic (has_edist (option unsigned)) := sorry --non-trivial
lemma new_lemma_21949 (h0 : finset (has_neg_part ennreal)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_21950 (h0 : semiring (nondiscrete_normed_field fun_info)) (h2 : nondiscrete_normed_field fun_info) : even h2 := sorry --non-trivial
lemma new_lemma_21951 (h0 : semiring (has_top (semiring congr_arg_kind))) : is_noetherian_ring (has_top (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_21952 (h0 : ring (comm_ring (denumerable to_additive.value_type))) : is_domain (comm_ring (denumerable to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_21953 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @regular_space.{0} (option.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (option.{0} pos))  := sorry --non-trivial
lemma new_lemma_21954 (h0 : ring (has_dist (option (option (option num))))) : is_domain (has_dist (option (option (option num)))) := sorry --non-trivial
lemma new_lemma_21955 (h0 : monoid (has_union (has_top (semiring unsigned)))) : monoid.fg (has_union (has_top (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_21956 (h0 : function.extfun Type group) : @is_simple_group.{0} (canonically_ordered_comm_semiring.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (canonically_ordered_comm_semiring.{0} pos))  := sorry --non-trivial
lemma new_lemma_21957 (h0 : topological_space (canonically_linear_ordered_monoid name)) : discrete_topology (canonically_linear_ordered_monoid name) := sorry --non-trivial
lemma new_lemma_21958 (h0 : add_group (measurable_space.dynkin_system congr_arg_kind)) : is_add_cyclic (measurable_space.dynkin_system congr_arg_kind) := sorry --non-trivial
lemma new_lemma_21959 (h0 : complete_lattice (linear_ordered_field empty)) : complete_lattice.is_Sup_finite_compact (linear_ordered_field empty) := sorry --non-trivial
lemma new_lemma_21960 (h0 : ring (has_norm (random_gen num))) : is_domain (has_norm (random_gen num)) := sorry --non-trivial
lemma new_lemma_21961 (h0 : function.extfun (Type 1) complete_lattice) : @complete_lattice.is_Sup_finite_compact.{1} (plift.{1} empty) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} h0 (plift.{1} empty))  := sorry --non-trivial
lemma new_lemma_21962 (h0 : not (has_mem.mem group has_emptyc.emptyc -> false)) : @is_cyclic.{0} (@id.{2} Type congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) group.{0} (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type)))) h0)) (@id.{2} Type congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_21963 (h0 : group (complete_semilattice_Sup congr_arg_kind)) : normalizer_condition (complete_semilattice_Sup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_21964 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (normed_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (normed_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_21965 (h0 : complete_lattice (ordered_cancel_add_comm_monoid (option (option empty)))) : is_atomistic (ordered_cancel_add_comm_monoid (option (option empty))) := sorry --non-trivial
lemma new_lemma_21966 (h0 : uniform_space (cancel_monoid (semigroup linarith.comp))) : separated_space (cancel_monoid (semigroup linarith.comp)) := sorry --non-trivial
lemma new_lemma_21967 (h2 : topological_space (has_nnnorm ereal)) : path_connected_space (has_nnnorm ereal) := sorry --non-trivial
lemma new_lemma_21968 (h0 : function.extfun Type group) : @normalizer_condition.{0} (@id.{2} Type unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (@id.{2} Type unsigned))  := sorry --non-trivial
lemma new_lemma_21969 (h0 : not (group (with_bot congr_arg_kind) -> false)) : @is_cyclic.{0} (with_bot.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (group.{0} (with_bot.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_21970 (h0 : topological_space (has_bot (has_add real))) : regular_space (has_bot (has_add real)) := sorry --non-trivial
lemma new_lemma_21971 (h0 : group (has_pos_part real)) : is_cyclic (has_pos_part real) := sorry --non-trivial
lemma new_lemma_21972 (h0 : ordered_add_comm_monoid (complete_distrib_lattice (finset linarith.comp))) : archimedean (complete_distrib_lattice (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_21973 (h0 : topological_space (random_gen (has_inv (random_gen string_imp)))) : t0_space (random_gen (has_inv (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_21974 (h0 : list (has_zero (boolean_algebra linarith.comp))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_21975 (h1 : set (mul_one_class environment.projection_info)) : set.subsingleton h1 := sorry --non-trivial
lemma new_lemma_21976 (h0 : functor.add_const (cancel_comm_monoid_with_zero (option empty)) congr_arg_kind) : @unique_factorization_monoid.{0} (option.{0} empty) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (option.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_21977 (h0 : not (has_mem.mem (semiring linarith.comp_source) has_emptyc.emptyc -> false)) : @strong_rank_condition.{0} (semiring.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type ring.{0} (semiring.{0} linarith.comp_source) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} linarith.comp_source) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_21978 (h0 : topological_space (canonically_ordered_monoid (option empty))) : topological_space.separable_space (canonically_ordered_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_21979 (h0 : ring occurrences) : strong_rank_condition occurrences := sorry --non-trivial
lemma new_lemma_21980 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @complete_space.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 uniform_space.{1}) (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_21981 (h0 : ordered_add_comm_monoid (has_add (has_add (finset pos)))) : archimedean (has_add (has_add (finset pos))) := sorry --non-trivial
lemma new_lemma_21982 (h0 : topological_space (add_cancel_monoid (boolean_algebra.core (boolean_algebra.core Type)))) : t0_space (add_cancel_monoid (boolean_algebra.core (boolean_algebra.core Type))) := sorry --non-trivial
lemma new_lemma_21983 (h0 : not (group (linear_ordered_semiring empty) -> false)) : @is_cyclic.{0} (linear_ordered_semiring.{0} empty) (@classical.by_contradiction'.{1} (group.{0} (linear_ordered_semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_21984 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (left_cancel_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (left_cancel_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_21985 (h0 : not (complete_lattice (has_nnnorm to_additive.value_type) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_nnnorm.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_nnnorm.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_21986 (h0 : topological_space (semi_normed_ring (comm_ring char))) : t0_space (semi_normed_ring (comm_ring char)) := sorry --non-trivial
lemma new_lemma_21987 (h0 : topological_space (ordered_comm_ring (has_neg linarith.comp))) : t1_space (ordered_comm_ring (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_21988 (h0 : has_mem.mem (metric_space linarith.comp) has_emptyc.emptyc) : @totally_separated_space.{0} (metric_space.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (metric_space.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_21989 (h0 : cancel_comm_monoid_with_zero (cancel_monoid (has_add pos))) : unique_factorization_monoid (cancel_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_21990 (h0 : function.extfun nat fin) : @is_domain.{0} (sub_neg_monoid.{0} real) (@matrix.vec_empty.{0} (ring.{0} (sub_neg_monoid.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_21991 (h1 : ring (has_append (random_gen char))) : rank_condition (has_append (random_gen char)) := sorry --non-trivial
lemma new_lemma_21992 (h0 : ordered_add_comm_monoid (add_semigroup unsigned)) : archimedean (add_semigroup unsigned) := sorry --non-trivial
lemma new_lemma_21993 (h0 : topological_space (canonically_ordered_comm_semiring (has_neg_part name))) : preirreducible_space (canonically_ordered_comm_semiring (has_neg_part name)) := sorry --non-trivial
lemma new_lemma_21994 (h0 : filter (semigroup (canonically_linear_ordered_monoid (comm_group pos)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_21995 (h0 : functor.add_const (ordered_add_comm_monoid (ring pos)) Type) : @archimedean.{0} (ring.{0} pos) (@functor.add_const.run.{0 1} (ordered_add_comm_monoid.{0} (ring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_21996 (h0 : uniform_space (add_right_cancel_monoid empty)) : separated_space (add_right_cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_21997 (h1 : not (has_mem.mem (with_one num) has_emptyc.emptyc -> false)) : @path_connected_space.{0} (with_one.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_one.{0} num) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_one.{0} num) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h1))  := sorry --non-trivial
lemma new_lemma_21998 (h0 : functor.add_const (ordered_comm_monoid (canonically_ordered_comm_semiring name)) name) : @has_exists_mul_of_le.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (canonically_ordered_comm_semiring.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_21999 (h0 : uniform_space (measurable_space.dynkin_system unsigned)) : separated_space (measurable_space.dynkin_system unsigned) := sorry --non-trivial
lemma new_lemma_22000 (h0 : topological_space (has_compl (has_nnnorm (with_zero char)))) : totally_disconnected_space (has_compl (has_nnnorm (with_zero char))) := sorry --non-trivial
lemma new_lemma_22001 (h0 : ring (metric_space (random_gen (has_one (metric_space num))))) : rank_condition (metric_space (random_gen (has_one (metric_space num)))) := sorry --non-trivial
lemma new_lemma_22002 (h0 : not (function.extfun Type topological_space -> false)) : @discrete_topology.{0} (metric_space.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (metric_space.{0} num))  := sorry --non-trivial
lemma new_lemma_22003 (h0 : uniform_space (with_bot (has_top (semiring unsigned)))) : separated_space (with_bot (has_top (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_22004 (h0 : ring (uniform_space (has_lt linarith.comp_source))) : strong_rank_condition (uniform_space (has_lt linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_22005 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_22006 (h0 : topological_space (has_add (has_add (normed_comm_ring environment.implicit_infer_kind)))) : normal_space (has_add (has_add (normed_comm_ring environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_22007 (h1 : add_group (has_append linarith.comp_source)) : is_add_cyclic (has_append linarith.comp_source) := sorry --non-trivial
lemma new_lemma_22008 (h0 : functor.add_const (group (ordered_comm_ring pos)) linarith.comp) : @normalizer_condition.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (ordered_comm_ring.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_22009 (h0 : ordered_add_comm_monoid (ordered_comm_monoid (has_Inf linarith.comp))) : archimedean (ordered_comm_monoid (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_22010 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem group)) : @is_cyclic.{0} (with_bot.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) group.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (with_bot.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_22011 (h0 : functor.add_const (group (add_cancel_monoid Type)) unsigned) : @normalizer_condition.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (add_cancel_monoid.{1} Type)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_22012 (h0 : topological_space (cancel_monoid (finset (finset (finset pos))))) : totally_separated_space (cancel_monoid (finset (finset (finset pos)))) := sorry --non-trivial
lemma new_lemma_22013 (h1 : group (id num)) : is_cyclic (id num) := sorry --non-trivial
lemma new_lemma_22014 (h0 : topological_space (complete_distrib_lattice (has_neg name))) : locally_compact_space (complete_distrib_lattice (has_neg name)) := sorry --non-trivial
lemma new_lemma_22015 (h0 : topological_space (has_neg (option unsigned))) : preirreducible_space (has_neg (option unsigned)) := sorry --non-trivial
lemma new_lemma_22016 (h0 : topological_space (add_group (has_one congr_arg_kind))) : irreducible_space (add_group (has_one congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_22017 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (has_zero.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_zero.{0} name))  := sorry --non-trivial
lemma new_lemma_22018 (h0 : complete_lattice (add_monoid fun_info)) : complete_lattice.is_Sup_finite_compact (add_monoid fun_info) := sorry --non-trivial
lemma new_lemma_22019 (h0 : functor.add_const (function.extfun Type ring) (finset pos)) : @rank_condition.{0} (has_add.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) (finset.{0} pos) h0) (has_add.{0} name))  := sorry --non-trivial
lemma new_lemma_22020 (h0 : topological_space (sub_neg_monoid (has_Inf name))) : totally_disconnected_space (sub_neg_monoid (has_Inf name)) := sorry --non-trivial
lemma new_lemma_22021 (h0 : topological_space (distrib (topological_space (has_nnnorm (has_nnnorm linarith.ineq))))) : path_connected_space (distrib (topological_space (has_nnnorm (has_nnnorm linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_22022 (h0 : function.extfun (finset Type) (has_mem.mem (semiring linarith.comp_source))) : @complete_lattice.is_Sup_finite_compact.{0} (semiring.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (semiring.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} linarith.comp_source)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_22023 (h0 : uniform_space (has_bot unsigned)) : separated_space (has_bot unsigned) := sorry --non-trivial
lemma new_lemma_22024 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (normed_group.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (normed_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_22025 (h0 : topological_space (random_gen (has_norm (has_norm linarith.ineq)))) : irreducible_space (random_gen (has_norm (has_norm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_22026 (h0 : topological_space (has_neg name)) : loc_path_connected_space (has_neg name) := sorry --non-trivial
lemma new_lemma_22027 (h0 : group (generalized_boolean_algebra (ring pos))) : is_cyclic (generalized_boolean_algebra (ring pos)) := sorry --non-trivial
lemma new_lemma_22028 (h0 : topological_space (mul_zero_class (ring Type))) : sequential_space (mul_zero_class (ring Type)) := sorry --non-trivial
lemma new_lemma_22029 (h0 : topological_space (metric_space (metric_space string_imp))) : totally_disconnected_space (metric_space (metric_space string_imp)) := sorry --non-trivial
lemma new_lemma_22030 (h0 : functor.add_const (group (has_to_string Type)) (has_add (has_add linarith.comp))) : @normalizer_condition.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (has_to_string.{1} Type)) (has_add.{0} (has_add.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_22031 (h0 : ring (has_zero (has_add Type))) : strong_rank_condition (has_zero (has_add Type)) := sorry --non-trivial
lemma new_lemma_22032 (h0 : function.extfun (Type 1) ring) : @rank_condition.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_22033 (h0 : topological_space (complete_distrib_lattice (option (option (option empty))))) : normal_space (complete_distrib_lattice (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_22034 (h0 : functor.comp filter semigroup pos) : filter.ne_bot (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_22035 (h0 : complete_lattice (group_with_zero (option congr_arg_kind))) : complete_lattice.is_Sup_finite_compact (group_with_zero (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_22036 (h0 : functor.add_const (topological_space (boolean_algebra unsigned)) name) : @preirreducible_space.{0} (boolean_algebra.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_22037 (h0 : functor.add_const (topological_space (finset Type)) name) : @totally_disconnected_space.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (finset.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_22038 (h0 : has_mem.mem (has_one empty) has_emptyc.emptyc) : @strong_rank_condition.{0} (has_one.{0} empty) (@finset.pi.empty.{1 0} Type ring.{0} (has_one.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_22039 (h0 : functor.add_const (ring (has_pos_part pos)) pos) : @is_domain.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_pos_part.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_22040 (h0 : functor.add_const (cancel_comm_monoid_with_zero (boolean_algebra.core name)) ennreal) : @unique_factorization_monoid.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (boolean_algebra.core.{0} name)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_22041 (h1 : complete_lattice (normed_group (has_top linarith.comp_source))) : is_atomistic (normed_group (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_22042 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_atomistic.{0} (with_one.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (with_one.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_22043 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (sub_neg_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (sub_neg_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_22044 (h0 : not (complete_lattice (normed_group congr_arg_kind) -> false)) : @is_compactly_generated.{0} (normed_group.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (complete_lattice.{0} (normed_group.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_22045 (h0 : functor.add_const (topological_space (free_add_monoid empty)) empty) : @normal_space.{0} (free_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_22046 (h0 : topological_space (monoid (option empty))) : t1_space (monoid (option empty)) := sorry --non-trivial
lemma new_lemma_22047 (h0 : topological_space (has_add (add_cancel_monoid (has_add name)))) : regular_space (has_add (add_cancel_monoid (has_add name))) := sorry --non-trivial
lemma new_lemma_22048 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (has_one.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_one.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_22049 (h0 : group (canonically_ordered_comm_semiring (option name))) : is_cyclic (canonically_ordered_comm_semiring (option name)) := sorry --non-trivial
lemma new_lemma_22050 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (complete_distrib_lattice.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_22051 (h0 : functor.add_const (group (preorder num)) congr_arg_kind) : @normalizer_condition.{0} (preorder.{0} num) (@functor.add_const.run.{0 0} (group.{0} (preorder.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_22052 (h0 : functor.add_const (topological_space (has_zero name)) linarith.comp) : @preirreducible_space.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_22053 (h0 : topological_space (semigroup unsigned)) : path_connected_space (semigroup unsigned) := sorry --non-trivial
lemma new_lemma_22054 (h0 : uniform_space (ordered_cancel_add_comm_monoid (option (option (option (option pos)))))) : separated_space (ordered_cancel_add_comm_monoid (option (option (option (option pos))))) := sorry --non-trivial
lemma new_lemma_22055 (h0 : complete_lattice (add_comm_monoid (add_comm_monoid (option unsigned)))) : complete_lattice.is_Sup_finite_compact (add_comm_monoid (add_comm_monoid (option unsigned))) := sorry --non-trivial
lemma new_lemma_22056 (h0 : mul_one_class (non_unital_non_assoc_semiring char) -> mul_one_class (non_unital_non_assoc_semiring char) -> Prop) : is_extensional (mul_one_class (non_unital_non_assoc_semiring char)) h0 := sorry --non-trivial
lemma new_lemma_22057 (h0 : ring (has_pos_part (has_add pos))) : strong_rank_condition (has_pos_part (has_add pos)) := sorry --non-trivial
lemma new_lemma_22058 (h0 : topological_space (comm_ring (random_gen linarith.ineq))) : t0_space (comm_ring (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_22059 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_domain.{1} (has_pos_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ring.{1}) (has_pos_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_22060 (h0 : add_group (finset (semigroup Type))) : is_add_cyclic (finset (semigroup Type)) := sorry --non-trivial
lemma new_lemma_22061 (h0 : functor.comp group boolean_algebra.core Type) : @normalizer_condition.{1} (boolean_algebra.core.{1} Type) (@functor.comp.run.{1 1 1} group.{1} boolean_algebra.core.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_22062 (h0 : cancel_comm_monoid_with_zero (add_comm_monoid (add_comm_monoid (has_add Type)))) : unique_factorization_monoid (add_comm_monoid (add_comm_monoid (has_add Type))) := sorry --non-trivial
lemma new_lemma_22063 (h0 : monoid (ordered_comm_monoid (finset linarith.comp))) : monoid.fg (ordered_comm_monoid (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_22064 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (canonically_ordered_monoid name)) := sorry --non-trivial
lemma new_lemma_22065 (h0 : list (with_one (has_norm (has_emptyc linarith.comp_source)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_22066 (h0 : omega_complete_partial_order empty -> omega_complete_partial_order empty -> Prop) (h1 : add_monoid (add_group (quot h0))) (h2 : has_one (add_group (quot h0))) : char_zero (add_group (quot h0)) := sorry --non-trivial
lemma new_lemma_22067 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_pos_part.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_pos_part.{0} real))  := sorry --non-trivial
lemma new_lemma_22068 (h0 : not (add_group (has_inv char) -> false)) : @is_add_cyclic.{0} (has_inv.{0} char) (@classical.by_contradiction'.{1} (add_group.{0} (has_inv.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_22069 (h0 : topological_space (semiring (has_top linarith.ineq))) : totally_separated_space (semiring (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_22070 (h0 : functor.add_const (topological_space (boolean_algebra pos)) (finset (finset (finset pos)))) : @path_connected_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} pos)) (finset.{0} (finset.{0} (finset.{0} pos))) h0)  := sorry --non-trivial
lemma new_lemma_22071 (h0 : measurable_space (add_comm_semigroup (add_comm_semigroup (add_comm_semigroup (add_comm_semigroup char))))) (h1 : set (add_comm_semigroup (add_comm_semigroup (add_comm_semigroup (add_comm_semigroup char))))) : measurable_set h1 := sorry --non-trivial
lemma new_lemma_22072 (h1 : topological_space (has_lt fun_info)) : t0_space (has_lt fun_info) := sorry --non-trivial
lemma new_lemma_22073 (h0 : functor.add_const (add_monoid auto.case_option) unsigned) : @add_monoid.fg.{0} auto.case_option (@functor.add_const.run.{0 0} (add_monoid.{0} auto.case_option) unsigned h0)  := sorry --non-trivial
lemma new_lemma_22074 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (has_dist.{0} num) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (has_dist.{0} num))  := sorry --non-trivial
lemma new_lemma_22075 (h0 : group (has_to_string unsigned)) : is_cyclic (has_to_string unsigned) := sorry --non-trivial
lemma new_lemma_22076 (h0 : functor.add_const (topological_space (has_to_string Type)) name) : @t0_space.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_to_string.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_22077 (h0 : complete_lattice (with_bot (has_top linarith.comp))) : complete_lattice.is_Sup_finite_compact (with_bot (has_top linarith.comp)) := sorry --non-trivial
lemma new_lemma_22078 (h0 : function.extfun Type ring) : @rank_condition.{0} (add_left_cancel_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_left_cancel_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_22079 (h0 : functor.add_const (function.extfun (Type 1) group) pos) : @normalizer_condition.{1} Type (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) group.{1}) pos h0) Type)  := sorry --non-trivial
lemma new_lemma_22080 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (linear_ordered_cancel_comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_22081 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_sub.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_sub.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_22082 (h0 : group (comm_monoid (semiring empty))) : normalizer_condition (comm_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_22083 (h0 : complete_lattice (semigroup (has_neg_part Type))) : is_atomistic (semigroup (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_22084 (h0 : uniform_space (normed_comm_ring (option empty))) : complete_space (normed_comm_ring (option empty)) := sorry --non-trivial
lemma new_lemma_22085 (h0 : group (ordered_comm_ring name)) : is_cyclic (ordered_comm_ring name) := sorry --non-trivial
lemma new_lemma_22086 (h0 : group (has_inter unsigned)) : normalizer_condition (has_inter unsigned) := sorry --non-trivial
lemma new_lemma_22087 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (canonically_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_22088 (h0 : function.extfun Type group) : @group.fg.{0} (ring.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} h0 (ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_22089 (h0 : not (topological_space (plift num) -> false)) : @preirreducible_space.{1} (plift.{1} num) (@classical.by_contradiction'.{2} (topological_space.{1} (plift.{1} num)) h0)  := sorry --non-trivial
lemma new_lemma_22090 (h0 : add_group (finset (has_pos_part Type))) : is_add_cyclic (finset (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_22091 (h0 : functor.add_const (uniform_space (has_zero Type)) (add_cancel_monoid linarith.comp)) : @complete_space.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (has_zero.{1} Type)) (add_cancel_monoid.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_22092 (h0 : functor.add_const (complete_lattice (normed_comm_ring environment.implicit_infer_kind)) pos) : @complete_lattice.is_Sup_finite_compact.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (normed_comm_ring.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_22093 (h0 : measurable_space char) (h1 : topological_space char) (h2 : measure_theory.measure char) : measure_theory.is_locally_finite_measure h2 := sorry --non-trivial
lemma new_lemma_22094 (h0 : add_group (has_neg_part (option ennreal))) : is_add_cyclic (has_neg_part (option ennreal)) := sorry --non-trivial
lemma new_lemma_22095 (h0 : functor.add_const (complete_lattice (ring environment.implicit_infer_kind)) (has_zero pos)) : @is_compactly_generated.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ring.{0} environment.implicit_infer_kind)) (has_zero.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_22096 (h0 : topological_space (has_nndist (finset environment.implicit_infer_kind))) : totally_disconnected_space (has_nndist (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_22097 (h0 : functor.add_const (function.extfun Type topological_space) name) : @preconnected_space.{0} (has_to_string.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (has_to_string.{0} name))  := sorry --non-trivial
lemma new_lemma_22098 (h0 : ordered_comm_monoid (boolean_algebra.core (cancel_monoid (option pos)))) : has_exists_mul_of_le (boolean_algebra.core (cancel_monoid (option pos))) := sorry --non-trivial
lemma new_lemma_22099 (h0 : topological_space (with_one (semiring fun_info))) : normal_space (with_one (semiring fun_info)) := sorry --non-trivial
lemma new_lemma_22100 (h0 : functor.add_const (monoid linarith.comp) (finset (finset pos))) : @monoid.fg.{0} linarith.comp (@functor.add_const.run.{0 0} (monoid.{0} linarith.comp) (finset.{0} (finset.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_22101 (h0 : functor.add_const (function.extfun Type topological_space) environment.implicit_infer_kind) : @totally_disconnected_space.{0} (has_nndist.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) environment.implicit_infer_kind h0) (has_nndist.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_22102 (h0 : filter ereal) (h1 : ring (mul_one_class (filter.germ h0 ereal))) : rank_condition (mul_one_class (filter.germ h0 ereal)) := sorry --non-trivial
lemma new_lemma_22103 (h0 : uniform_space (has_nnnorm (has_nnnorm fun_info))) : complete_space (has_nnnorm (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_22104 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (@id.{2} Type to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (@id.{2} Type to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_22105 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (mul_zero_class.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type monoid.{0} h0 (mul_zero_class.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_22106 (h0 : measurable_space.dynkin_system (has_sub empty) -> measurable_space.dynkin_system (has_sub empty) -> Prop) : is_per (measurable_space.dynkin_system (has_sub empty)) h0 := sorry --non-trivial
lemma new_lemma_22107 (h0 : topological_space (pseudo_metric_space (has_neg_part (finset name)))) : preconnected_space (pseudo_metric_space (has_neg_part (finset name))) := sorry --non-trivial
lemma new_lemma_22108 (h0 : topological_space (has_neg (add_cancel_monoid (has_neg Type)))) : preconnected_space (has_neg (add_cancel_monoid (has_neg Type))) := sorry --non-trivial
lemma new_lemma_22109 (h0 : functor.add_const (topological_space (preorder num)) num) : @t1_space.{0} (preorder.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (preorder.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_22110 (h1 : add_group (has_append (random_gen fun_info))) : is_add_cyclic (has_append (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_22111 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} linarith.comp (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) linarith.comp)  := sorry --non-trivial
lemma new_lemma_22112 (h0 : function.extfun Type (functor.comp topological_space add_cancel_monoid)) : @t1_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} add_cancel_monoid.{0} environment.implicit_infer_kind (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} add_cancel_monoid.{0}) h0 environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_22113 (h0 : functor.add_const (group (semigroup unsigned)) name) : @is_simple_group.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (semigroup.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_22114 (h0 : add_monoid (left_cancel_monoid (semiring num))) : add_monoid.fg (left_cancel_monoid (semiring num)) := sorry --non-trivial
lemma new_lemma_22115 (h0 : topological_space (canonically_ordered_comm_semiring (finset ennreal))) : regular_space (canonically_ordered_comm_semiring (finset ennreal)) := sorry --non-trivial
lemma new_lemma_22116 (h0 : ordered_comm_monoid (has_pos_part (has_Inf pos))) : has_exists_mul_of_le (has_pos_part (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_22117 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (canonically_ordered_add_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (canonically_ordered_add_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_22118 (h0 : group (has_edist (semiring (semiring unsigned)))) : is_cyclic (has_edist (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_22119 (h1 : set (set (has_inv (has_ssubset (has_inv (has_inv (has_inv string_imp))))))) (h2 : set (has_inv (has_ssubset (has_inv (has_inv (has_inv string_imp)))))) : measurable_space.dynkin_system.generate_has h1 h2 := sorry --non-trivial
lemma new_lemma_22120 (h0 : functor.add_const (ring (normed_comm_ring Type)) pos) : @rank_condition.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (normed_comm_ring.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_22121 (h0 : topological_space (ordered_comm_monoid (has_bot real))) : path_connected_space (ordered_comm_monoid (has_bot real)) := sorry --non-trivial
lemma new_lemma_22122 (h0 : topological_space (finset (ordered_cancel_add_comm_monoid congr_arg_kind))) : preconnected_space (finset (ordered_cancel_add_comm_monoid congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_22123 (h1 : not (group (semi_normed_ring to_additive.value_type) -> false)) : @is_cyclic.{0} (semi_normed_ring.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (group.{0} (semi_normed_ring.{0} to_additive.value_type)) h1)  := sorry --non-trivial
lemma new_lemma_22124 (h0 : uniform_space (has_neg (has_add (semigroup (finset pos))))) : complete_space (has_neg (has_add (semigroup (finset pos)))) := sorry --non-trivial
lemma new_lemma_22125 (h0 : complete_lattice (has_neg_part (cancel_monoid name))) : complete_lattice.is_Sup_finite_compact (has_neg_part (cancel_monoid name)) := sorry --non-trivial
lemma new_lemma_22126 (h0 : functor.add_const (ring (cancel_monoid ennreal)) Type) : @is_principal_ideal_ring.{0} (cancel_monoid.{0} ennreal) (@functor.add_const.run.{0 1} (ring.{0} (cancel_monoid.{0} ennreal)) Type h0)  := sorry --non-trivial
lemma new_lemma_22127 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (complete_distrib_lattice.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (complete_distrib_lattice.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_22128 (h0 : function.extfun Type (functor.comp group cancel_monoid)) : @is_cyclic.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} group.{0} cancel_monoid.{0} environment.implicit_infer_kind (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} group.{0} cancel_monoid.{0}) h0 environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_22129 (h0 : not (ring (comm_ring (has_nnnorm fun_info)) -> false)) : @strong_rank_condition.{0} (comm_ring.{0} (has_nnnorm.{0} fun_info)) (@classical.by_contradiction'.{1} (ring.{0} (comm_ring.{0} (has_nnnorm.{0} fun_info))) h0)  := sorry --non-trivial
lemma new_lemma_22130 (h0 : not (topological_space (add_monoid linarith.ineq) -> false)) : @t0_space.{0} (add_monoid.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (add_monoid.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_22131 (h0 : topological_space (boolean_algebra (boolean_algebra linarith.comp))) : sequential_space (boolean_algebra (boolean_algebra linarith.comp)) := sorry --non-trivial
lemma new_lemma_22132 (h0 : fin has_zero.zero) : @is_atomistic.{1} (normed_lattice_add_comm_group.{1} Type) (@matrix.vec_empty.{1} (complete_lattice.{1} (normed_lattice_add_comm_group.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_22133 (h0 h1 : multiset (nondiscrete_normed_field linarith.ineq)) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_22134 (h0 : complete_lattice (has_union (has_union (has_union (has_union (has_union linarith.comp)))))) : is_atomistic (has_union (has_union (has_union (has_union (has_union linarith.comp))))) := sorry --non-trivial
lemma new_lemma_22135 (h0 : topological_space (partial_order (semiring empty))) : loc_path_connected_space (partial_order (semiring empty)) := sorry --non-trivial
lemma new_lemma_22136 (h0 : ring (with_one linarith.ineq)) : strong_rank_condition (with_one linarith.ineq) := sorry --non-trivial
lemma new_lemma_22137 (h0 : list (boolean_algebra.core ennreal)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_22138 (h0 : group (has_nnnorm linarith.ineq)) : is_cyclic (has_nnnorm linarith.ineq) := sorry --non-trivial
lemma new_lemma_22139 (h0 : functor.add_const (topological_space (finset environment.implicit_infer_kind)) Type) : @totally_disconnected_space.{0} (finset.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (finset.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_22140 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_neg.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_neg.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_22141 (h0 : topological_space (finset (boolean_algebra (finset (ring Type))))) : preirreducible_space (finset (boolean_algebra (finset (ring Type)))) := sorry --non-trivial
lemma new_lemma_22142 (h0 : topological_space (has_compl (has_inv (has_ssubset linarith.ineq)))) : totally_disconnected_space (has_compl (has_inv (has_ssubset linarith.ineq))) := sorry --non-trivial
lemma new_lemma_22143 (h0 : add_group (has_norm (comm_ring to_additive.value_type))) : is_add_cyclic (has_norm (comm_ring to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_22144 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_22145 (h0 : filter (has_append (random_gen linarith.comp_source))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_22146 (h0 : not (uniform_space (has_emptyc linarith.ineq) -> false)) : @separated_space.{0} (has_emptyc.{0} linarith.ineq) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_emptyc.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_22147 (h0 : monoid (has_one (has_top num))) : monoid.fg (has_one (has_top num)) := sorry --non-trivial
lemma new_lemma_22148 (h0 : topological_space (has_neg_part (normed_comm_ring environment.implicit_infer_kind))) : t1_space (has_neg_part (normed_comm_ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_22149 (h8 : not (add_group (non_unital_non_assoc_semiring linarith.ineq) -> false)) : @is_add_cyclic.{0} (non_unital_non_assoc_semiring.{0} linarith.ineq) (@classical.by_contradiction'.{1} (add_group.{0} (non_unital_non_assoc_semiring.{0} linarith.ineq)) h8)  := sorry --non-trivial
lemma new_lemma_22150 (h0 : topological_space (add_comm_monoid (has_neg_part Type))) : regular_space (add_comm_monoid (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_22151 (h0 : function.extfun nat fin) : @t1_space.{0} (simple_graph.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (simple_graph.{0} name))  := sorry --non-trivial
lemma new_lemma_22152 (h0 : topological_space (has_add (sub_neg_monoid (has_Inf (ordered_comm_monoid (has_Inf Type)))))) : regular_space (has_add (sub_neg_monoid (has_Inf (ordered_comm_monoid (has_Inf Type))))) := sorry --non-trivial
lemma new_lemma_22153 (h0 : functor.add_const (function.extfun Type uniform_space) unsigned) : @separated_space.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) unsigned h0) (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_22154 (h0 : topological_space (linear_ordered_comm_group_with_zero fun_info)) : path_connected_space (linear_ordered_comm_group_with_zero fun_info) := sorry --non-trivial
lemma new_lemma_22155 (h0 : topological_space (plift num)) : discrete_topology (plift num) := sorry --non-trivial
lemma new_lemma_22156 (h0 : functor.add_const (filter (linear_ordered_field ennreal)) (option empty)) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_22157 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (has_to_string empty)) := sorry --non-trivial
lemma new_lemma_22158 (h6 : set (add_comm_semigroup ereal -> ereal)) : set.separates_points h6 := sorry --non-trivial
lemma new_lemma_22159 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_neg.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_22160 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (complete_distrib_lattice pos)) := sorry --non-trivial
lemma new_lemma_22161 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (linear_ordered_comm_group num)) := sorry --non-trivial
lemma new_lemma_22162 (h0 : functor.add_const (topological_space (has_Inf pos)) (ring linarith.comp)) : @irreducible_space.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} pos)) (ring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_22163 (h0 : topological_space (mul_zero_class (semiring (semiring num)))) : totally_disconnected_space (mul_zero_class (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_22164 (h0 : function.extfun (Type 1) group) : @group.fg.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} h0 (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_22165 (h0 : topological_space (has_Inf (has_neg Type))) : topological_space.separable_space (has_Inf (has_neg Type)) := sorry --non-trivial
lemma new_lemma_22166 (h0 : list (distrib_lattice fun_info)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_22167 (h0 : uniform_space (finset (mul_zero_class (mul_zero_class pos)))) : complete_space (finset (mul_zero_class (mul_zero_class pos))) := sorry --non-trivial
lemma new_lemma_22168 (h1 : list (has_top to_additive.value_type)) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_22169 (h0 : functor.add_const (ring (linear_ordered_cancel_comm_monoid num)) empty) : @is_principal_ideal_ring.{0} (linear_ordered_cancel_comm_monoid.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (linear_ordered_cancel_comm_monoid.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_22170 (h2 : uniform_space (has_inv (random_gen string_imp))) : complete_space (has_inv (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_22171 (h0 : ring (semigroup (ring Type))) : rank_condition (semigroup (ring Type)) := sorry --non-trivial
lemma new_lemma_22172 (h0 : topological_space (has_well_founded (option unsigned))) : topological_space.separable_space (has_well_founded (option unsigned)) := sorry --non-trivial
lemma new_lemma_22173 (h0 : functor.add_const (topological_space pos) Type) : @regular_space.{0} pos (@functor.add_const.run.{0 1} (topological_space.{0} pos) Type h0)  := sorry --non-trivial
lemma new_lemma_22174 (h0 : topological_space (cancel_monoid (has_add linarith.comp))) : normal_space (cancel_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_22175 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring pos)) linarith.comp) : @t1_space.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_22176 (h0 : topological_space (ordered_comm_ring (ring (ring Type)))) : irreducible_space (ordered_comm_ring (ring (ring Type))) := sorry --non-trivial
lemma new_lemma_22177 (h0 : not (uniform_space (has_sub congr_arg_kind) -> false)) : @complete_space.{0} (has_sub.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_sub.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_22178 (h0 : group (has_emptyc congr_arg_kind)) : normalizer_condition (has_emptyc congr_arg_kind) := sorry --non-trivial
lemma new_lemma_22179 (h0 : complete_lattice (linear_ordered_comm_ring unsigned)) : complete_lattice.is_Sup_finite_compact (linear_ordered_comm_ring unsigned) := sorry --non-trivial
lemma new_lemma_22180 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (comm_group.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} h0 (comm_group.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_22181 (h0 : add_group (canonically_ordered_comm_semiring (ring (option pos)))) : is_add_cyclic (canonically_ordered_comm_semiring (ring (option pos))) := sorry --non-trivial
lemma new_lemma_22182 (h0 : ring (random_gen (random_gen (random_gen string_imp)))) : is_domain (random_gen (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_22183 (h0 : functor.add_const (complete_lattice (has_dist unsigned)) unsigned) : @is_atomistic.{0} (has_dist.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_dist.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_22184 (h0 : pnat) (h1 : fin has_zero.zero) : pnat.coprime h0 (matrix.vec_empty (id (id h1))) := sorry --non-trivial
lemma new_lemma_22185 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (ordered_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_22186 (h0 : semiring (nondiscrete_normed_field enat)) (h1 : ideal (nondiscrete_normed_field enat)) : ideal.is_prime h1 := sorry --non-trivial
lemma new_lemma_22187 (h0 : complete_lattice (complete_distrib_lattice (option ennreal))) : complete_lattice.is_Sup_finite_compact (complete_distrib_lattice (option ennreal)) := sorry --non-trivial
lemma new_lemma_22188 (h0 : topological_space (ordered_comm_ring (has_pos_part (has_pos_part (has_pos_part linarith.comp))))) : discrete_topology (ordered_comm_ring (has_pos_part (has_pos_part (has_pos_part linarith.comp)))) := sorry --non-trivial
lemma new_lemma_22189 (h0 : functor.add_const (prod ennreal ennreal) unsigned) : id_rel (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_22190 (h0 : cancel_comm_monoid_with_zero (complete_distrib_lattice (option pos))) : unique_factorization_monoid (complete_distrib_lattice (option pos)) := sorry --non-trivial
lemma new_lemma_22191 (h0 : ring (semigroup (ring (ring (finset (has_nndist Type)))))) : is_domain (semigroup (ring (ring (finset (has_nndist Type))))) := sorry --non-trivial
lemma new_lemma_22192 (h0 : topological_space (uniform_space (distrib linarith.comp_source))) (h1 : preorder (uniform_space (distrib linarith.comp_source))) : order_topology (uniform_space (distrib linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_22193 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (boolean_algebra.core.{0} ennreal) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (boolean_algebra.core.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_22194 (h0 : add_group (encodable (random_gen (comm_ring linarith.ineq)))) : is_add_cyclic (encodable (random_gen (comm_ring linarith.ineq))) := sorry --non-trivial
lemma new_lemma_22195 (h0 : group (canonically_ordered_monoid real)) : normalizer_condition (canonically_ordered_monoid real) := sorry --non-trivial
lemma new_lemma_22196 (h0 : set (set to_additive.value_type)) (h1 : set to_additive.value_type) : measurable_space.dynkin_system.generate_has h0 h1 := sorry --non-trivial
lemma new_lemma_22197 (h0 : not (group (has_norm num) -> false)) : @is_cyclic.{0} (has_norm.{0} num) (@classical.by_contradiction'.{1} (group.{0} (has_norm.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_22198 (h0 : filter (complete_distrib_lattice (has_add unsigned))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_22199 (h0 : uniform_space (with_bot (has_top (has_inv linarith.ineq)))) : complete_space (with_bot (has_top (has_inv linarith.ineq))) := sorry --non-trivial
lemma new_lemma_22200 (h0 : ordered_comm_monoid (semigroup (ring (ring Type)))) : has_exists_mul_of_le (semigroup (ring (ring Type))) := sorry --non-trivial
lemma new_lemma_22201 (h0 : filter (has_ssubset (random_gen (random_gen (random_gen (random_gen to_additive.value_type)))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_22202 (h0 : ring (sub_neg_monoid (option empty))) : rank_condition (sub_neg_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_22203 (h0 : topological_space (boolean_algebra (boolean_algebra.core Type))) : discrete_topology (boolean_algebra (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_22204 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (complete_distrib_lattice.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_distrib_lattice.{0} empty))  := sorry --non-trivial
lemma new_lemma_22205 (h0 : measurable_space (normed_field (mul_one_class to_additive.value_type))) (h1 : filter (normed_field (mul_one_class to_additive.value_type))) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_22206 (h0 : topological_space (has_zero name)) : preconnected_space (has_zero name) := sorry --non-trivial
lemma new_lemma_22207 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_22208 (h0 : ring (canonically_ordered_monoid (has_add Type))) : strong_rank_condition (canonically_ordered_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_22209 (h0 : filter (has_neg name)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_22210 (h0 : filter (comm_group (finset (has_to_string pos)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_22211 (h0 : uniform_space (has_zero (finset linarith.comp))) : complete_space (has_zero (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_22212 (h0 : functor.comp group canonically_ordered_comm_semiring Type) : @is_simple_group.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.comp.run.{1 1 1} group.{1} canonically_ordered_comm_semiring.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_22213 (h0 : functor.add_const (ring (comm_group Type)) (has_add pos)) : @is_domain.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (comm_group.{1} Type)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_22214 (h0 : topological_space (add_cancel_monoid (has_neg (has_to_string (finset Type))))) : t0_space (add_cancel_monoid (has_neg (has_to_string (finset Type)))) := sorry --non-trivial
lemma new_lemma_22215 (h0 : functor.add_const (filter (finset environment.implicit_infer_kind)) pos) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_22216 (h0 : add_monoid (id (semiring unsigned))) : add_monoid.fg (id (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_22217 (h0 : ordered_add_comm_monoid (linear_order (semiring (semiring empty)))) : archimedean (linear_order (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_22218 (h0 : group (has_append (has_nnnorm (has_nnnorm (random_gen char))))) : is_cyclic (has_append (has_nnnorm (has_nnnorm (random_gen char)))) := sorry --non-trivial
lemma new_lemma_22219 (h0 : list (ring name)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_22220 (h1 : ring (distrib fun_info)) : rank_condition (distrib fun_info) := sorry --non-trivial
lemma new_lemma_22221 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (normed_group.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_group.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_22222 (h0 : functor.add_const (function.extfun (Type 1) finset) pos) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (finset Type)) := sorry --non-trivial
lemma new_lemma_22223 (h0 : ordered_comm_monoid (add_comm_monoid (has_add pos))) : has_exists_mul_of_le (add_comm_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_22224 (h0 : ring (random_gen (mul_one_class linarith.ineq))) : rank_condition (random_gen (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_22225 (h0 : uniform_space (linear_ordered_add_comm_group (has_nnnorm linarith.ineq))) : complete_space (linear_ordered_add_comm_group (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_22226 (h0 : monoid (has_neg (finset environment.implicit_infer_kind))) : monoid.fg (has_neg (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_22227 (h0 : functor.add_const (topological_space (complete_distrib_lattice name)) name) : @t1_space.{0} (complete_distrib_lattice.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_22228 (h1 : not (complete_lattice (has_ssubset string_imp) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_ssubset.{0} string_imp) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_ssubset.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_22229 (h0 : functor.add_const (ring (left_cancel_monoid empty)) congr_arg_kind) : @is_domain.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (left_cancel_monoid.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_22230 (h0 : functor.add_const (list (boolean_algebra.core environment.implicit_infer_kind)) environment.implicit_infer_kind) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_22231 (h0 : topological_space (comm_semigroup pos)) : preconnected_space (comm_semigroup pos) := sorry --non-trivial
lemma new_lemma_22232 (h0 : functor.add_const (topological_space (cancel_monoid Type)) name) : @discrete_topology.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (cancel_monoid.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_22233 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_top.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_top.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_22234 (h0 : functor.add_const (ring (boolean_algebra linarith.comp)) environment.implicit_infer_kind) : @strong_rank_condition.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_22235 (h0 : set (uniform_space linarith.comp_source)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_22236 (h0 : functor.add_const (topological_space (has_to_string unsigned)) linarith.comp) : @regular_space.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_22237 (h0 : topological_space (normed_comm_ring (ordered_ring (has_add (ring Type))))) : topological_space.separable_space (normed_comm_ring (ordered_ring (has_add (ring Type)))) := sorry --non-trivial
lemma new_lemma_22238 (h0 : topological_space (measurable_space (random_gen (has_top linarith.comp_source)))) : t0_space (measurable_space (random_gen (has_top linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_22239 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_inter.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_inter.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_22240 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem group)) : @is_cyclic.{0} (semiring.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) group.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_22241 (h0 : ordered_comm_monoid (has_nndist (comm_group environment.implicit_infer_kind))) : has_exists_mul_of_le (has_nndist (comm_group environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_22242 (h0 : has_neg (has_div fun_info)) (h1 : measurable_space (has_div fun_info)) : has_measurable_neg (has_div fun_info) := sorry --non-trivial
lemma new_lemma_22243 (h0 : ring (sub_neg_monoid (has_neg linarith.comp))) : is_principal_ideal_ring (sub_neg_monoid (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_22244 (h1 : topological_space (distrib linarith.comp_source)) : t0_space (distrib linarith.comp_source) := sorry --non-trivial
lemma new_lemma_22245 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring name)) linarith.comp) : @totally_disconnected_space.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_22246 (h0 : uniform_space (boolean_algebra (ring linarith.comp))) : complete_space (boolean_algebra (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_22247 (h0 : functor.add_const (topological_space (add_cancel_monoid ennreal)) pos) : @irreducible_space.{0} (add_cancel_monoid.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} ennreal)) pos h0)  := sorry --non-trivial
lemma new_lemma_22248 (h0 : topological_space (boolean_algebra (finset linarith.comp))) : normal_space (boolean_algebra (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_22249 (h0 : functor.add_const (function.extfun (Type 1) group) pos) : @is_simple_group.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) group.{1}) pos h0) (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_22250 (h1 : topological_space (with_one (random_gen (has_nnnorm fun_info)))) : t0_space (with_one (random_gen (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_22251 (h0 h1 : multiset string.iterator_imp) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_22252 (h0 : topological_space (complete_distrib_lattice (has_add (ring linarith.comp)))) : topological_space.separable_space (complete_distrib_lattice (has_add (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_22253 (h0 : ring (normed_group (has_norm (has_norm empty)))) : rank_condition (normed_group (has_norm (has_norm empty))) := sorry --non-trivial
lemma new_lemma_22254 (h0 : uniform_space (semiring (has_top (has_top linarith.comp_source)))) : complete_space (semiring (has_top (has_top linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_22255 (h0 : functor.add_const (group Type) Type) : @is_simple_group.{1} Type (@functor.add_const.run.{1 1} (group.{1} Type) Type h0)  := sorry --non-trivial
lemma new_lemma_22256 (h0 : functor.add_const (ordered_add_comm_monoid (has_Sup empty)) (semiring (semiring (semiring empty)))) : @archimedean.{0} (has_Sup.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_Sup.{0} empty)) (semiring.{0} (semiring.{0} (semiring.{0} empty))) h0)  := sorry --non-trivial
lemma new_lemma_22257 (h0 : functor.add_const (topological_space (has_inter empty)) unsigned) : @path_connected_space.{0} (has_inter.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_inter.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_22258 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_22259 (h0 : function.extfun Type topological_space) : @t0_space.{0} (monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_22260 (h0 : filter (boolean_algebra.core (comm_group (comm_group (semigroup (finset unsigned)))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_22261 (h0 : functor.comp filter complete_distrib_lattice (comm_group unsigned)) : filter.ne_bot (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_22262 (h0 : topological_space (has_top (has_ssubset (has_ssubset (has_ssubset linarith.ineq))))) : path_connected_space (has_top (has_ssubset (has_ssubset (has_ssubset linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_22263 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (has_top.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 uniform_space.{0}) (has_top.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_22264 (h0 : functor.add_const (topological_space (linear_ordered_comm_group empty)) num) : @locally_compact_space.{0} (linear_ordered_comm_group.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_comm_group.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_22265 (h1 : ring (topological_space (has_nnnorm string_imp))) : rank_condition (topological_space (has_nnnorm string_imp)) := sorry --non-trivial
lemma new_lemma_22266 (h0 : not (monoid (random_gen congr_arg_kind) -> false)) : @monoid.fg.{0} (random_gen.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (monoid.{0} (random_gen.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_22267 (h0 : ring (boolean_algebra.core unsigned)) : is_domain (boolean_algebra.core unsigned) := sorry --non-trivial
lemma new_lemma_22268 (h0 : topological_space (with_zero fun_info)) : totally_disconnected_space (with_zero fun_info) := sorry --non-trivial
lemma new_lemma_22269 (h0 : group (boolean_algebra (has_pos_part (has_pos_part (finset linarith.comp))))) : group.fg (boolean_algebra (has_pos_part (has_pos_part (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_22270 (h0 : complete_lattice (ordered_ring num)) : is_atomistic (ordered_ring num) := sorry --non-trivial
lemma new_lemma_22271 (h1 : topological_space (distrib_lattice string_imp)) : totally_disconnected_space (distrib_lattice string_imp) := sorry --non-trivial
lemma new_lemma_22272 (h0 : semiring (canonically_ordered_comm_semiring (boolean_algebra.core linarith.comp))) : is_noetherian_ring (canonically_ordered_comm_semiring (boolean_algebra.core linarith.comp)) := sorry --non-trivial
lemma new_lemma_22273 (h0 : functor.add_const (topological_space (add_cancel_monoid ennreal)) (option (option (option (option ennreal))))) : @preconnected_space.{0} (add_cancel_monoid.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} ennreal)) (option.{0} (option.{0} (option.{0} (option.{0} ennreal)))) h0)  := sorry --non-trivial
lemma new_lemma_22274 (h0 : uniform_space (has_emptyc (random_gen to_additive.value_type))) : complete_space (has_emptyc (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_22275 (h0 : group (has_pos_part (has_add (has_Inf real)))) : normalizer_condition (has_pos_part (has_add (has_Inf real))) := sorry --non-trivial
lemma new_lemma_22276 (h0 : functor.add_const (group (pseudo_metric_space ennreal)) ennreal) : @is_simple_group.{0} (pseudo_metric_space.{0} ennreal) (@functor.add_const.run.{0 0} (group.{0} (pseudo_metric_space.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_22277 (h0 : filter (finset Type)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_22278 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (ordered_comm_group.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (ordered_comm_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_22279 (h2 h3 : multiset (has_ssubset linarith.ineq)) : multiset.disjoint h2 h3 := sorry --non-trivial
lemma new_lemma_22280 (h0 : add_group (denumerable (has_nnnorm (has_nnnorm fun_info)))) : is_add_cyclic (denumerable (has_nnnorm (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_22281 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @sequential_space.{0} (finset.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (finset.{0} name))  := sorry --non-trivial
lemma new_lemma_22282 (h0 : has_top (semiring linarith.comp) -> has_top (semiring linarith.comp) -> Prop) : is_antisymm (has_top (semiring linarith.comp)) h0 := sorry --non-trivial
lemma new_lemma_22283 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (add_right_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_group.{0} h0 (add_right_cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_22284 (h0 : ordered_comm_monoid (finset (option (monoid (option pos))))) : has_exists_mul_of_le (finset (option (monoid (option pos)))) := sorry --non-trivial
lemma new_lemma_22285 (h0 : set (add_comm_semigroup enat -> add_comm_semigroup ereal)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_22286 (h0 : functor.add_const (topological_space (ring pos)) Type) : @topological_space.separable_space.{0} (ring.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (ring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_22287 (h0 : functor.add_const (functor.add_const Prop (ring linarith.comp)) linarith.comp) : functor.add_const.run (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_22288 (h0 : functor.add_const (topological_space (cancel_monoid name)) pos) : @regular_space.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_22289 (h0 : topological_space (add_comm_monoid (comm_group (comm_group (comm_group Type))))) : preconnected_space (add_comm_monoid (comm_group (comm_group (comm_group Type)))) := sorry --non-trivial
lemma new_lemma_22290 (h0 : topological_space (mul_zero_class (has_add (finset pos)))) : locally_compact_space (mul_zero_class (has_add (finset pos))) := sorry --non-trivial
lemma new_lemma_22291 (h0 : uniform_space (filter empty)) : complete_space (filter empty) := sorry --non-trivial
lemma new_lemma_22292 (h0 : group (has_to_string (add_comm_monoid num))) : is_simple_group (has_to_string (add_comm_monoid num)) := sorry --non-trivial
lemma new_lemma_22293 (h0 : functor.add_const (topological_space environment.implicit_infer_kind) Type) : @sequential_space.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 1} (topological_space.{0} environment.implicit_infer_kind) Type h0)  := sorry --non-trivial
lemma new_lemma_22294 (h0 : fin has_zero.zero) : @locally_compact_space.{0} (sub_neg_monoid.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (sub_neg_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_22295 (h0 : add_group (has_lt char)) : is_add_cyclic (has_lt char) := sorry --non-trivial
lemma new_lemma_22296 (h0 : function.extfun nat fin) : @t0_space.{0} (canonically_linear_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (canonically_linear_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_22297 (h0 : topological_space (measurable_space (has_norm linarith.comp))) : path_connected_space (measurable_space (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_22298 (h0 : ring (semiring (has_norm (random_gen fun_info)))) : is_domain (semiring (has_norm (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_22299 (h0 : function.extfun nat fin) : @is_principal_ideal_ring.{1} (generalized_boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (generalized_boolean_algebra.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_22300 (h0 : topological_space (comm_group (cancel_monoid pos))) : regular_space (comm_group (cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_22301 (h0 : function.extfun (finset Type) (has_mem.mem (semiring num))) : @locally_compact_space.{0} (semiring.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (semiring.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_22302 (h0 : functor.add_const (group (has_add Type)) Type) : @is_simple_group.{1} (has_add.{1} Type) (@functor.add_const.run.{1 1} (group.{1} (has_add.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_22303 (h0 : functor.add_const (ring (semigroup environment.implicit_infer_kind)) name) : @strong_rank_condition.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (semigroup.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_22304 (h0 : topological_space (linear_ordered_comm_group unsigned)) : topological_space.separable_space (linear_ordered_comm_group unsigned) := sorry --non-trivial
lemma new_lemma_22305 (h0 : ordered_add_comm_monoid (canonically_linear_ordered_monoid (option ennreal))) : archimedean (canonically_linear_ordered_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_22306 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (add_comm_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (add_comm_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_22307 (h0 : ordered_add_comm_monoid (linear_ordered_cancel_comm_monoid congr_arg_kind)) : archimedean (linear_ordered_cancel_comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_22308 (h0 : set (has_div linarith.comp_source)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_22309 (h0 : topological_space (partial_order (semiring congr_arg_kind))) : topological_space.separable_space (partial_order (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_22310 (h0 : functor.add_const (topological_space (has_to_string name)) (has_neg (has_neg linarith.comp))) : @normal_space.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} name)) (has_neg.{0} (has_neg.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_22311 (h0 : group (has_nndist (boolean_algebra.core (has_add pos)))) : is_simple_group (has_nndist (boolean_algebra.core (has_add pos))) := sorry --non-trivial
lemma new_lemma_22312 (h0 : functor.add_const (ring (ring linarith.comp)) Type) : @strong_rank_condition.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (ring.{0} (ring.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_22313 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (pseudo_metric_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (pseudo_metric_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_22314 (h0 : functor.add_const (uniform_space (linear_ordered_field empty)) (option unsigned)) : @complete_space.{0} (linear_ordered_field.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (linear_ordered_field.{0} empty)) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_22315 (h0 : not (ring (id num) -> false)) : @is_domain.{0} (@id.{2} Type num) (@classical.by_contradiction'.{1} (ring.{0} (@id.{2} Type num)) h0)  := sorry --non-trivial
lemma new_lemma_22316 (h0 : monoid (has_bot (has_Inf (has_Inf pos)))) : monoid.fg (has_bot (has_Inf (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_22317 (h0 : topological_space (has_one (semiring (semiring unsigned)))) : normal_space (has_one (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_22318 (h0 : cancel_comm_monoid_with_zero (has_star (semiring empty))) : unique_factorization_monoid (has_star (semiring empty)) := sorry --non-trivial
lemma new_lemma_22319 (h0 : topological_space (ring (has_neg_part pos))) : sequential_space (ring (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_22320 (h0 : set (set (comm_ring to_additive.value_type))) : is_countably_spanning h0 := sorry --non-trivial
lemma new_lemma_22321 (h0 : topological_space (add_comm_monoid name)) : topological_space.separable_space (add_comm_monoid name) := sorry --non-trivial
lemma new_lemma_22322 (h0 : add_monoid (has_star (semiring empty))) : add_monoid.fg (has_star (semiring empty)) := sorry --non-trivial
lemma new_lemma_22323 (h0 : topological_space (ordered_cancel_add_comm_monoid (option (option unsigned)))) : loc_path_connected_space (ordered_cancel_add_comm_monoid (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_22324 (h0 : functor.add_const (topological_space (cancel_monoid pos)) linarith.comp) : @normal_space.{0} (cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_22325 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @group.fg.{0} (comm_semigroup.{0} pos) (@matrix.vec_empty.{0} (group.{0} (comm_semigroup.{0} pos)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_22326 (h1 : ring (denumerable reducibility_hints)) : is_domain (denumerable reducibility_hints) := sorry --non-trivial
lemma new_lemma_22327 (h0 : complete_lattice (boolean_algebra.core (ring Type))) : complete_lattice.is_Sup_finite_compact (boolean_algebra.core (ring Type)) := sorry --non-trivial
lemma new_lemma_22328 (h0 : topological_space (plift (option num))) : preirreducible_space (plift (option num)) := sorry --non-trivial
lemma new_lemma_22329 (h0 : add_cancel_monoid (monoid ennreal) -> add_cancel_monoid (monoid ennreal) -> Prop) : is_symm (add_cancel_monoid (monoid ennreal)) h0 := sorry --non-trivial
lemma new_lemma_22330 (h0 : topological_space (ring Type)) : t1_space (ring Type) := sorry --non-trivial
lemma new_lemma_22331 (h0 : topological_space (canonically_ordered_monoid (has_Inf (sub_neg_monoid (has_Inf pos))))) : loc_path_connected_space (canonically_ordered_monoid (has_Inf (sub_neg_monoid (has_Inf pos)))) := sorry --non-trivial
lemma new_lemma_22332 (h0 : topological_space (generalized_boolean_algebra name)) : irreducible_space (generalized_boolean_algebra name) := sorry --non-trivial
lemma new_lemma_22333 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (complete_distrib_lattice empty)) := sorry --non-trivial
lemma new_lemma_22334 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (add_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (add_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_22335 (h0 : functor.add_const (topological_space (generalized_boolean_algebra pos)) (has_neg linarith.comp)) : @totally_separated_space.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} pos)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_22336 (h0 : topological_space (id string_imp)) : totally_disconnected_space (id string_imp) := sorry --non-trivial
lemma new_lemma_22337 (h0 : functor.add_const (filter (finset environment.implicit_infer_kind)) Type) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_22338 (h0 : functor.add_const (uniform_space (comm_group linarith.comp)) linarith.comp) : @separated_space.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (comm_group.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_22339 (h0 : function.extfun (Type 1) topological_space) : @locally_compact_space.{1} (plift.{1} empty) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (plift.{1} empty))  := sorry --non-trivial
lemma new_lemma_22340 (h0 : group (id empty)) : is_cyclic (id empty) := sorry --non-trivial
lemma new_lemma_22341 (h0 : cancel_comm_monoid_with_zero (complete_distrib_lattice (has_Inf real))) : unique_factorization_monoid (complete_distrib_lattice (has_Inf real)) := sorry --non-trivial
lemma new_lemma_22342 (h0 : not (ring (metric_space congr_arg_kind) -> false)) : @is_domain.{0} (metric_space.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (ring.{0} (metric_space.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_22343 (h0 : functor.add_const (group (semigroup name)) pos) : @group.fg.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (group.{0} (semigroup.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_22344 (h0 : filter (with_bot (semiring linarith.comp))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_22345 (h0 : complete_lattice (pseudo_metric_space (option (option ennreal)))) : is_atomistic (pseudo_metric_space (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_22346 (h0 : mul_one_class char) (h1 : measurable_space (submonoid char)) (h2 : measure_theory.measure (submonoid char)) : measure_theory.is_finite_measure h2 := sorry --non-trivial
lemma new_lemma_22347 (h0 : ring (linear_ordered_comm_group_with_zero (mul_one_class linarith.comp_source))) : rank_condition (linear_ordered_comm_group_with_zero (mul_one_class linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_22348 (h0 : with_bot pnat) (h1 : ne h0 has_bot.bot) (h2 : pnat) : pnat.coprime (with_bot.unbot h0 h1) h2 := sorry --non-trivial
lemma new_lemma_22349 (h0 : function.extfun Type ring) : @rank_condition.{0} (cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_22350 (h0 : filter (topological_space (random_gen string_imp))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_22351 (h0 : functor.add_const (topological_space (mul_zero_class name)) Type) : @normal_space.{0} (mul_zero_class.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (mul_zero_class.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_22352 (h0 h1 : function.extfun unsigned (fun (x : unsigned), Prop)) (h2 : unsigned) : set.sep (function.extfun_app h0) (function.extfun_app h1) h2 := sorry --non-trivial
lemma new_lemma_22353 (h0 : topological_space (cancel_monoid (comm_group name))) : sequential_space (cancel_monoid (comm_group name)) := sorry --non-trivial
lemma new_lemma_22354 (h1 : topological_space (linear_ordered_add_comm_group to_additive.value_type)) : t0_space (linear_ordered_add_comm_group to_additive.value_type) := sorry --non-trivial
lemma new_lemma_22355 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (linear_order.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (linear_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_22356 (h0 : topological_space (add_comm_monoid (ring name))) : t0_space (add_comm_monoid (ring name)) := sorry --non-trivial
lemma new_lemma_22357 (h0 : topological_space (simple_graph (option unsigned))) : totally_disconnected_space (simple_graph (option unsigned)) := sorry --non-trivial
lemma new_lemma_22358 (h0 : group (semiring (semiring unsigned))) : group.fg (semiring (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_22359 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (add_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_22360 (h0 : add_group (has_div reducibility_hints)) : is_add_cyclic (has_div reducibility_hints) := sorry --non-trivial
lemma new_lemma_22361 (h0 : group (monoid congr_arg_kind)) : is_cyclic (monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_22362 (h0 : has_mem.mem complete_lattice has_emptyc.emptyc) : @is_compactly_generated.{0} (has_norm.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} h0) (has_norm.{0} num))  := sorry --non-trivial
lemma new_lemma_22363 (h0 : functor.add_const (complete_lattice (has_nndist ennreal)) (finset pos)) : @complete_lattice.is_Sup_finite_compact.{0} (has_nndist.{0} ennreal) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_nndist.{0} ennreal)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_22364 (h0 : functor.add_const (topological_space (generalized_boolean_algebra Type)) (has_neg Type)) : @preirreducible_space.{1} (generalized_boolean_algebra.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (generalized_boolean_algebra.{1} Type)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_22365 (h0 : filter (has_inv (random_gen (random_gen (random_gen (random_gen (random_gen fun_info))))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_22366 (h0 : group (omega_complete_partial_order congr_arg_kind)) : group.fg (omega_complete_partial_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_22367 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (has_to_string.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_to_string.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_22368 (h0 : ring (has_div string_imp)) : is_domain (has_div string_imp) := sorry --non-trivial
lemma new_lemma_22369 (h0 : function.extfun (Type 1) topological_space) : @loc_path_connected_space.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_22370 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @normal_space.{1} (canonically_linear_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (canonically_linear_ordered_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_22371 (h2 : complete_lattice (has_ssubset (has_add to_additive.value_type))) : is_compactly_generated (has_ssubset (has_add to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_22372 (h0 : complete_lattice (finset (finset pos))) : is_compactly_generated (finset (finset pos)) := sorry --non-trivial
lemma new_lemma_22373 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (boolean_algebra.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_22374 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (boolean_algebra.core.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} name))  := sorry --non-trivial
lemma new_lemma_22375 (h0 : semiring (semigroup (finset linarith.comp))) : is_noetherian_ring (semigroup (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_22376 (h0 : functor.add_const (topological_space (boolean_algebra pos)) pos) : @normal_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_22377 (h0 : functor.add_const (uniform_space (has_star unsigned)) empty) : @complete_space.{0} (has_star.{0} unsigned) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_star.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_22378 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (encodable.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (encodable.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_22379 (h0 : topological_space (boolean_algebra.core (has_add unsigned))) : totally_separated_space (boolean_algebra.core (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_22380 (h0 : pnat) (h1 : ulower pnat) (h2 : Prop) (h3 : not h2) (h4 : h2) : pnat.coprime h0 (ulower.up (list.ilast' h1 (not.elim h3 h4))) := sorry --trivial
lemma new_lemma_22381 (h0 : group (canonically_linear_ordered_monoid (has_bot pos))) : is_cyclic (canonically_linear_ordered_monoid (has_bot pos)) := sorry --non-trivial
lemma new_lemma_22382 (h0 : functor.add_const (ring (left_cancel_semigroup unsigned)) num) : @is_principal_ideal_ring.{0} (left_cancel_semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (left_cancel_semigroup.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_22383 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_22384 (h0 : topological_space (comm_ring (has_nnnorm char))) : path_connected_space (comm_ring (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_22385 (h0 : ring (has_bot (has_add (sub_neg_monoid (sub_neg_monoid real))))) : is_domain (has_bot (has_add (sub_neg_monoid (sub_neg_monoid real)))) := sorry --non-trivial
lemma new_lemma_22386 (h0 : functor.add_const (ring (cancel_monoid Type)) Type) : @rank_condition.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 1} (ring.{1} (cancel_monoid.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_22387 (h0 : function.extfun Type group) : @is_cyclic.{0} (comm_ring.{0} char) (@function.extfun_app.{2 1} Type group.{0} h0 (comm_ring.{0} char))  := sorry --non-trivial
lemma new_lemma_22388 (h0 : functor.add_const (group (add_group num)) (semiring (semiring (ordered_ring num)))) : @group.fg.{0} (add_group.{0} num) (@functor.add_const.run.{0 0} (group.{0} (add_group.{0} num)) (semiring.{0} (semiring.{0} (ordered_ring.{0} num))) h0)  := sorry --non-trivial
lemma new_lemma_22389 (h0 : functor.add_const (complete_lattice (has_neg_part ennreal)) Type) : @is_compactly_generated.{0} (has_neg_part.{0} ennreal) (@functor.add_const.run.{0 1} (complete_lattice.{0} (has_neg_part.{0} ennreal)) Type h0)  := sorry --non-trivial
lemma new_lemma_22390 (h0 : uniform_space (partial_order (partial_order congr_arg_kind))) : complete_space (partial_order (partial_order congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_22391 (h0 : monoid (non_assoc_semiring (option (option empty)))) : monoid.fg (non_assoc_semiring (option (option empty))) := sorry --non-trivial
lemma new_lemma_22392 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} char (@function.extfun_app.{2 1} Type topological_space.{0} h0 char)  := sorry --non-trivial
lemma new_lemma_22393 (h0 : uniform_space (nondiscrete_normed_field (mul_one_class linarith.ineq))) : complete_space (nondiscrete_normed_field (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_22394 (h0 : group (measurable_space.dynkin_system name)) : normalizer_condition (measurable_space.dynkin_system name) := sorry --non-trivial
lemma new_lemma_22395 (h1 : group (div_inv_monoid (has_nnnorm string_imp))) : is_cyclic (div_inv_monoid (has_nnnorm string_imp)) := sorry --non-trivial
lemma new_lemma_22396 (h1 : not (uniform_space (uniform_space linarith.comp_source) -> false)) : @complete_space.{0} (uniform_space.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (uniform_space.{0} (uniform_space.{0} linarith.comp_source)) h1)  := sorry --non-trivial
lemma new_lemma_22397 (h1 : has_mem.mem ring has_emptyc.emptyc) : @strong_rank_condition.{0} (random_gen.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} h1) (random_gen.{0} empty))  := sorry --non-trivial
lemma new_lemma_22398 (h0 : ring (has_compl (distrib reducibility_hints))) : strong_rank_condition (has_compl (distrib reducibility_hints)) := sorry --non-trivial
lemma new_lemma_22399 (h0 : functor.add_const (topological_space (partial_order congr_arg_kind)) unsigned) : @discrete_topology.{0} (partial_order.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (partial_order.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_22400 (h0 : topological_space (canonically_ordered_monoid (has_neg name))) : irreducible_space (canonically_ordered_monoid (has_neg name)) := sorry --non-trivial
lemma new_lemma_22401 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (has_pos_part.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_pos_part.{0} name))  := sorry --non-trivial
lemma new_lemma_22402 (h0 : functor.add_const (group (add_comm_monoid Type)) (ring Type)) : @is_simple_group.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 1} (group.{1} (add_comm_monoid.{1} Type)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_22403 (h0 : function.extfun Type group) : @group.fg.{0} (is_R_or_C.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (is_R_or_C.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_22404 (h0 : ring (complete_semilattice_Sup (comm_ring (has_top to_additive.value_type)))) : is_domain (complete_semilattice_Sup (comm_ring (has_top to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_22405 (h0 : topological_space (has_top (has_top (has_top fun_info)))) : irreducible_space (has_top (has_top (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_22406 (h0 : filter (boolean_algebra (semigroup (has_zero linarith.comp)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_22407 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_22408 (h0 : group (has_neg name)) : is_cyclic (has_neg name) := sorry --non-trivial
lemma new_lemma_22409 (h0 : topological_space (normed_lattice_add_comm_group (has_add (finset (has_Inf pos))))) : regular_space (normed_lattice_add_comm_group (has_add (finset (has_Inf pos)))) := sorry --non-trivial
lemma new_lemma_22410 (h0 : filter (finset (boolean_algebra (ring (has_add pos))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_22411 (h0 : topological_space (denumerable (random_gen char))) : path_connected_space (denumerable (random_gen char)) := sorry --non-trivial
lemma new_lemma_22412 (h0 : group (has_pos_part (has_pos_part (has_add (has_neg name))))) : is_simple_group (has_pos_part (has_pos_part (has_add (has_neg name)))) := sorry --non-trivial
lemma new_lemma_22413 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (linear_ordered_cancel_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} h0 (linear_ordered_cancel_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_22414 (h0 : ring (has_add (option (option (option (option ennreal)))))) : strong_rank_condition (has_add (option (option (option (option ennreal))))) := sorry --non-trivial
lemma new_lemma_22415 (h0 : not (ring (option num) -> false)) : @is_domain.{0} (option.{0} num) (@classical.by_contradiction'.{1} (ring.{0} (option.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_22416 (h0 : group (linear_ordered_semiring (random_gen fun_info))) : is_cyclic (linear_ordered_semiring (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_22417 (h0 : topological_space (is_R_or_C (option (option unsigned)))) : path_connected_space (is_R_or_C (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_22418 (h0 : functor.add_const (function.extfun Type filter) pos) : countable_Inter_filter (function.extfun_app (functor.add_const.run h0) (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_22419 (h0 : function.extfun (finset Type) (has_mem.mem (has_one fun_info))) : @path_connected_space.{0} (has_one.{0} fun_info) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_one.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_one.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_22420 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (canonically_linear_ordered_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (canonically_linear_ordered_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_22421 (h0 : topological_space (uniform_space (mul_one_class (mul_one_class string.iterator_imp)))) : path_connected_space (uniform_space (mul_one_class (mul_one_class string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_22422 (h0 : topological_space (normed_comm_ring (ring pos))) : totally_disconnected_space (normed_comm_ring (ring pos)) := sorry --non-trivial
lemma new_lemma_22423 (h0 : ordered_comm_monoid (has_bot (sub_neg_monoid linarith.comp))) : has_exists_mul_of_le (has_bot (sub_neg_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_22424 (h0 : list (simple_graph (has_pos_part Type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_22425 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (has_Sup (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_22426 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (measure_theory.measure_space.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} h0 (measure_theory.measure_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_22427 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @locally_compact_space.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_22428 (h0 : functor.add_const (topological_space (plift congr_arg_kind)) unsigned) : @locally_compact_space.{1} (plift.{1} congr_arg_kind) (@functor.add_const.run.{1 0} (topological_space.{1} (plift.{1} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_22429 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_22430 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} linarith.comp_source (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_22431 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (canonically_ordered_comm_semiring.{0} name) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (canonically_ordered_comm_semiring.{0} name))  := sorry --non-trivial
lemma new_lemma_22432 (h0 : topological_space (ordered_comm_monoid (has_add (has_nndist linarith.comp)))) : normal_space (ordered_comm_monoid (has_add (has_nndist linarith.comp))) := sorry --non-trivial
lemma new_lemma_22433 (h0 : not (ring (random_gen (random_gen linarith.comp_source)) -> false)) : @rank_condition.{0} (random_gen.{0} (random_gen.{0} linarith.comp_source)) (@classical.by_contradiction'.{1} (ring.{0} (random_gen.{0} (random_gen.{0} linarith.comp_source))) h0)  := sorry --non-trivial
lemma new_lemma_22434 (h1 : has_lt (nondiscrete_normed_field (mul_one_class fun_info))) : no_max_order (nondiscrete_normed_field (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_22435 (h0 : functor.add_const (monoid (semigroup linarith.comp)) name) : @monoid.fg.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (monoid.{0} (semigroup.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_22436 (h0 : functor.add_const (finset (semigroup Type)) environment.implicit_infer_kind) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_22437 (h0 : topological_space (has_neg (finset (has_nndist Type)))) : totally_disconnected_space (has_neg (finset (has_nndist Type))) := sorry --non-trivial
lemma new_lemma_22438 (h0 : topological_space (semigroup (has_nndist (has_neg (has_neg Type))))) : totally_disconnected_space (semigroup (has_nndist (has_neg (has_neg Type)))) := sorry --non-trivial
lemma new_lemma_22439 (h0 : functor.add_const Prop (cancel_monoid (option unsigned))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_22440 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (has_pos_part name)) := sorry --non-trivial
lemma new_lemma_22441 (h0 : cancel_comm_monoid_with_zero (ordered_comm_monoid (ring linarith.comp))) : unique_factorization_monoid (ordered_comm_monoid (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_22442 (h1 : ring (has_norm congr_arg_kind)) : is_domain (has_norm congr_arg_kind) := sorry --non-trivial
lemma new_lemma_22443 (h0 : functor.add_const (cancel_comm_monoid_with_zero (boolean_algebra pos)) Type) : @unique_factorization_monoid.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 1} (cancel_comm_monoid_with_zero.{0} (boolean_algebra.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_22444 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_zero Type)) Type) : @unique_factorization_monoid.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 1} (cancel_comm_monoid_with_zero.{1} (has_zero.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_22445 (h0 : topological_space (canonically_ordered_monoid (has_pos_part (has_Inf linarith.comp)))) : preirreducible_space (canonically_ordered_monoid (has_pos_part (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_22446 (h0 : group (add_cancel_monoid (finset (has_add linarith.comp)))) : is_simple_group (add_cancel_monoid (finset (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_22447 (h0 : not (topological_space (has_inv char) -> false)) : @totally_disconnected_space.{0} (has_inv.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (has_inv.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_22448 (h0 : functor.add_const (add_monoid (measurable_space.dynkin_system num)) unsigned) : @add_monoid.fg.{0} (measurable_space.dynkin_system.{0} num) (@functor.add_const.run.{0 0} (add_monoid.{0} (measurable_space.dynkin_system.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_22449 (h0 : group (linear_ordered_comm_monoid_with_zero (option unsigned))) : normalizer_condition (linear_ordered_comm_monoid_with_zero (option unsigned)) := sorry --non-trivial
lemma new_lemma_22450 (h0 : topological_space (canonically_ordered_comm_semiring (has_to_string (has_neg_part ennreal)))) : t1_space (canonically_ordered_comm_semiring (has_to_string (has_neg_part ennreal))) := sorry --non-trivial
lemma new_lemma_22451 (h0 : complete_lattice (has_top unsigned)) : is_compactly_generated (has_top unsigned) := sorry --non-trivial
lemma new_lemma_22452 (h0 : not (has_mem.mem linarith.comp_source has_emptyc.emptyc -> false)) : @rank_condition.{0} linarith.comp_source (@finset.pi.empty.{1 0} Type ring.{0} linarith.comp_source (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) linarith.comp_source (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_22453 (h1 : topological_space (normed_field (mul_one_class ereal))) (h2 : add_group (normed_field (mul_one_class ereal))) : topological_add_group (normed_field (mul_one_class ereal)) := sorry --non-trivial
lemma new_lemma_22454 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem add_group)) : @is_add_cyclic.{0} (random_gen.{0} fun_info) (@function.extfun_app.{2 1} Type add_group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) add_group.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) add_group.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (random_gen.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_22455 (h0 : group (comm_group (boolean_algebra.core (has_nndist (has_add name))))) : group.fg (comm_group (boolean_algebra.core (has_nndist (has_add name)))) := sorry --non-trivial
lemma new_lemma_22456 (h0 : ring (has_to_string (finset (finset pos)))) : rank_condition (has_to_string (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_22457 (h0 : add_monoid (has_nndist (boolean_algebra Type))) : add_monoid.fg (has_nndist (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_22458 (h0 : uniform_space (has_norm (random_gen linarith.comp))) : separated_space (has_norm (random_gen linarith.comp)) := sorry --non-trivial
lemma new_lemma_22459 (h0 : topological_space (linear_ordered_field (option (option ennreal)))) : path_connected_space (linear_ordered_field (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_22460 (h1 : semiring (denumerable linarith.ineq) -> semiring (denumerable linarith.ineq) -> Prop) : is_antisymm (semiring (denumerable linarith.ineq)) h1 := sorry --non-trivial
lemma new_lemma_22461 (h0 : not (list (preorder empty) -> false)) : list.nodup (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_22462 (h0 : set (linarith.ineq -> fun_info)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_22463 (h0 : topological_space (has_nnnorm (mul_one_class linarith.comp_source))) : path_connected_space (has_nnnorm (mul_one_class linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_22464 (h0 : list (complete_semilattice_Sup (dlist (has_inv (has_nnnorm string_imp))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_22465 (h0 : topological_space (group_with_zero ennreal)) : path_connected_space (group_with_zero ennreal) := sorry --non-trivial
lemma new_lemma_22466 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_neg linarith.comp)) (add_cancel_monoid pos)) : @unique_factorization_monoid.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_neg.{0} linarith.comp)) (add_cancel_monoid.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_22467 (h0 : functor.add_const (topological_space (ring linarith.comp)) pos) : @loc_path_connected_space.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_22468 (h0 : functor.add_const (monoid (has_pos_part linarith.comp)) pos) : @monoid.fg.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (monoid.{0} (has_pos_part.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_22469 (h0 : function.extfun Type group) : @is_cyclic.{0} (monoid.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_22470 (h0 : functor.add_const (finset (canonically_ordered_comm_semiring environment.implicit_infer_kind)) name) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_22471 (h0 : uniform_space (left_cancel_semigroup (semiring (semiring (semiring (semiring num)))))) : complete_space (left_cancel_semigroup (semiring (semiring (semiring (semiring num))))) := sorry --non-trivial
lemma new_lemma_22472 (h0 : topological_space (uniform_space (uniform_space (uniform_space enat)))) : totally_disconnected_space (uniform_space (uniform_space (uniform_space enat))) := sorry --non-trivial
lemma new_lemma_22473 (h0 : set (has_le (simple_graph (simple_graph linarith.comp_source)))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_22474 (h0 : ring (add_cancel_comm_monoid (metric_space linarith.comp_source))) : rank_condition (add_cancel_comm_monoid (metric_space linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_22475 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (add_left_cancel_semigroup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_left_cancel_semigroup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_22476 (h0 : functor.add_const (ring (generalized_boolean_algebra pos)) pos) : @is_principal_ideal_ring.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (generalized_boolean_algebra.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_22477 (h0 : add_monoid (normed_group (has_norm (has_norm (random_gen (semiring num)))))) : add_monoid.fg (normed_group (has_norm (has_norm (random_gen (semiring num))))) := sorry --non-trivial
lemma new_lemma_22478 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @normal_space.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_22479 (h0 : ordered_comm_monoid (ring (finset (has_Inf pos)))) : has_exists_mul_of_le (ring (finset (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_22480 (h1 : not (function.extfun Type uniform_space -> false)) : @separated_space.{0} (random_gen.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h1) (random_gen.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_22481 (h0 : not (topological_space (left_cancel_semigroup unsigned) -> false)) : @irreducible_space.{0} (left_cancel_semigroup.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (left_cancel_semigroup.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_22482 (h0 : complete_lattice (has_zero (has_nndist environment.implicit_infer_kind))) : is_atomistic (has_zero (has_nndist environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_22483 (h0 : not (ring (has_star congr_arg_kind) -> false)) : @strong_rank_condition.{0} (has_star.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (ring.{0} (has_star.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_22484 (h0 : topological_space (has_add (ring (ring (ring Type))))) : sequential_space (has_add (ring (ring (ring Type)))) := sorry --non-trivial
lemma new_lemma_22485 (h0 : topological_space (cancel_monoid ennreal)) : t1_space (cancel_monoid ennreal) := sorry --non-trivial
lemma new_lemma_22486 (h0 : functor.add_const (topological_space (cancel_monoid name)) linarith.comp) : @t0_space.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_22487 (h0 : not (group (has_compl fun_info) -> false)) : @group.fg.{0} (has_compl.{0} fun_info) (@classical.by_contradiction'.{1} (group.{0} (has_compl.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_22488 (h0 : topological_space (with_one (random_gen linarith.comp_source))) : t0_space (with_one (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_22489 (h0 : functor.add_const (group environment.implicit_infer_kind) Type) : @group.fg.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 1} (group.{0} environment.implicit_infer_kind) Type h0)  := sorry --non-trivial
lemma new_lemma_22490 (h0 : complete_lattice (comm_ring (random_gen reducibility_hints))) : complete_lattice.is_Sup_finite_compact (comm_ring (random_gen reducibility_hints)) := sorry --non-trivial
lemma new_lemma_22491 (h0 : topological_space (add_cancel_comm_monoid (comm_ring char))) : t0_space (add_cancel_comm_monoid (comm_ring char)) := sorry --non-trivial
lemma new_lemma_22492 (h0 : topological_space (has_bot unsigned)) : path_connected_space (has_bot unsigned) := sorry --non-trivial
lemma new_lemma_22493 (h0 : topological_space (simple_graph (has_add pos))) : totally_disconnected_space (simple_graph (has_add pos)) := sorry --non-trivial
lemma new_lemma_22494 (h0 : functor.add_const (topological_space (boolean_algebra Type)) (has_to_string pos)) : @irreducible_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.{1} Type)) (has_to_string.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_22495 (h0 : ring (has_neg_part (boolean_algebra.core Type))) : is_principal_ideal_ring (has_neg_part (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_22496 (h0 : not (ring (denumerable to_additive.value_type) -> false)) : @is_domain.{0} (denumerable.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (denumerable.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_22497 (h0 : measurable_space (mul_one_class (add_comm_semigroup enat))) (h1 : set (mul_one_class (add_comm_semigroup enat))) : measurable_set h1 := sorry --non-trivial
lemma new_lemma_22498 (h0 : filter (add_left_cancel_semigroup (option (option (option unsigned))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_22499 (h0 : group (normed_group (has_inv to_additive.value_type))) : is_cyclic (normed_group (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_22500 (h0 : list (add_comm_monoid (ring Type))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_22501 (h0 : topological_space (boolean_algebra (boolean_algebra.core pos))) : discrete_topology (boolean_algebra (boolean_algebra.core pos)) := sorry --non-trivial
lemma new_lemma_22502 (h0 : monoid (has_nndist pos)) : monoid.fg (has_nndist pos) := sorry --non-trivial
lemma new_lemma_22503 (h0 : ordered_comm_monoid (monoid (option (monoid_with_zero pos)))) : has_exists_mul_of_le (monoid (option (monoid_with_zero pos))) := sorry --non-trivial
lemma new_lemma_22504 (h0 : topological_space (add_cancel_monoid (ordered_ring Type))) : loc_path_connected_space (add_cancel_monoid (ordered_ring Type)) := sorry --non-trivial
lemma new_lemma_22505 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (metric_space.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (metric_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_22506 (h0 : functor.add_const (monoid (cancel_monoid unsigned)) pos) : @monoid.fg.{0} (cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (monoid.{0} (cancel_monoid.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_22507 (h0 : functor.add_const (uniform_space (semigroup pos)) (finset (finset linarith.comp))) : @complete_space.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (semigroup.{0} pos)) (finset.{0} (finset.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_22508 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (has_zero.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_zero.{0} name))  := sorry --non-trivial
lemma new_lemma_22509 (h0 : functor.add_const (topological_space (has_Inf linarith.comp)) name) : @totally_separated_space.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_22510 (h0 : topological_space (boolean_algebra.core pos)) : preconnected_space (boolean_algebra.core pos) := sorry --non-trivial
lemma new_lemma_22511 (h0 : function.extfun (with_bot num -> Type) (function.extfun (with_bot num))) : set.nonempty (function.extfun_app (function.extfun_app h0 (fun (x : with_bot num), Prop))) := sorry --non-trivial
lemma new_lemma_22512 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (has_union linarith.comp)) := sorry --non-trivial
lemma new_lemma_22513 (h0 : functor.comp topological_space mul_zero_class pos) : @regular_space.{0} (mul_zero_class.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} mul_zero_class.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_22514 (h0 : function.extfun Type topological_space) : @t1_space.{0} (finset.{0} (option.{0} unsigned)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_22515 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (@id.{2} Type string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (@id.{2} Type string_imp))  := sorry --non-trivial
lemma new_lemma_22516 (h0 : topological_space (add_comm_monoid (ring (ring environment.implicit_infer_kind)))) : irreducible_space (add_comm_monoid (ring (ring environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_22517 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (ring.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (ring.{0} num))  := sorry --non-trivial
lemma new_lemma_22518 (h0 : add_group (with_bot (has_norm (random_gen (random_gen linarith.ineq))))) : is_add_cyclic (with_bot (has_norm (random_gen (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_22519 (h0 : not (function.extfun Type topological_space -> false)) : @irreducible_space.{0} (with_bot.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (with_bot.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_22520 (h0 : complete_lattice (linear_ordered_field unsigned)) : is_atomistic (linear_ordered_field unsigned) := sorry --non-trivial
lemma new_lemma_22521 (h1 : topological_space (add_left_cancel_monoid (has_ssubset char))) : path_connected_space (add_left_cancel_monoid (has_ssubset char)) := sorry --non-trivial
lemma new_lemma_22522 (h0 : ordered_add_comm_monoid (has_Inf (has_add (has_add pos)))) : archimedean (has_Inf (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_22523 (h0 : functor.add_const (topological_space (normed_comm_ring Type)) (has_add Type)) : @t1_space.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (normed_comm_ring.{1} Type)) (has_add.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_22524 (h0 : function.extfun Type group) : @normalizer_condition.{0} (@id.{2} Type to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} h0 (@id.{2} Type to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_22525 (h0 : function.extfun (Type 1) topological_space) : @regular_space.{1} (complete_distrib_lattice.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (complete_distrib_lattice.{1} Type))  := sorry --non-trivial
lemma new_lemma_22526 (h0 : functor.add_const (add_group (has_to_string Type)) (has_add name)) : @is_add_cyclic.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (add_group.{1} (has_to_string.{1} Type)) (has_add.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_22527 (h0 : group (ring (normed_comm_ring pos))) : is_simple_group (ring (normed_comm_ring pos)) := sorry --non-trivial
lemma new_lemma_22528 (h0 : ring (has_add (finset (finset (finset linarith.comp))))) : is_principal_ideal_ring (has_add (finset (finset (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_22529 (h0 : topological_space (ring name)) : regular_space (ring name) := sorry --non-trivial
lemma new_lemma_22530 (h0 : complete_lattice (non_unital_semiring linarith.ineq)) : complete_lattice.is_Sup_finite_compact (non_unital_semiring linarith.ineq) := sorry --non-trivial
lemma new_lemma_22531 (h0 : complete_lattice (normed_linear_ordered_group empty)) : is_compactly_generated (normed_linear_ordered_group empty) := sorry --non-trivial
lemma new_lemma_22532 (h0 : functor.add_const (complete_lattice (add_semigroup empty)) empty) : @complete_lattice.is_Sup_finite_compact.{0} (add_semigroup.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_semigroup.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_22533 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (normed_comm_ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type semiring.{0} h0 (normed_comm_ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_22534 (h0 : group (ordered_comm_monoid (ring pos))) : normalizer_condition (ordered_comm_monoid (ring pos)) := sorry --non-trivial
lemma new_lemma_22535 (h0 : topological_space (has_ssubset (mul_one_class ereal))) : totally_disconnected_space (has_ssubset (mul_one_class ereal)) := sorry --non-trivial
lemma new_lemma_22536 (h0 : function.extfun Type (functor.add_const (functor.add_const (ring linarith.comp) pos))) : @strong_rank_condition.{0} linarith.comp (@functor.add_const.run.{0 0} (ring.{0} linarith.comp) pos (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (ring.{0} linarith.comp) pos) pos (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (functor.add_const.{0 0} (ring.{0} linarith.comp) pos)) h0 pos)))  := sorry --non-trivial
lemma new_lemma_22537 (h0 : functor.add_const (semiring (has_add linarith.comp)) linarith.comp) : @is_noetherian_ring.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (semiring.{0} (has_add.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_22538 (h0 : function.extfun Type topological_space) : @regular_space.{0} (comm_group.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_22539 (h0 : function.extfun (Type 1) monoid) : @monoid.fg.{1} (plift.{1} congr_arg_kind) (@function.extfun_app.{3 2} (Type 1) monoid.{1} h0 (plift.{1} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_22540 (h0 : functor.add_const (topological_space (has_zero Type)) name) : @discrete_topology.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_zero.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_22541 (h0 : add_monoid (has_union (semiring (semiring unsigned)))) : add_monoid.fg (has_union (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_22542 (h0 : functor.add_const (uniform_space (has_to_string pos)) (ring Type)) : @separated_space.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 1} (uniform_space.{0} (has_to_string.{0} pos)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_22543 (h1 : complete_lattice (uniform_space linarith.comp_source)) : is_compactly_generated (uniform_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_22544 (h0 : functor.add_const (topological_space (boolean_algebra unsigned)) name) : @t1_space.{0} (boolean_algebra.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_22545 (h0 : topological_space (finset (normed_comm_ring name))) : loc_path_connected_space (finset (normed_comm_ring name)) := sorry --non-trivial
lemma new_lemma_22546 (h0 : group (cancel_monoid Type)) : group.fg (cancel_monoid Type) := sorry --non-trivial
lemma new_lemma_22547 (h0 : functor.add_const (semiring (has_bot pos)) real) : @is_noetherian_ring.{0} (has_bot.{0} pos) (@functor.add_const.run.{0 0} (semiring.{0} (has_bot.{0} pos)) real h0)  := sorry --non-trivial
lemma new_lemma_22548 (h0 : linear_ordered_semiring (uniform_space num) -> linear_ordered_semiring (uniform_space num) -> Prop) : is_strict_order (linear_ordered_semiring (uniform_space num)) h0 := sorry --non-trivial
lemma new_lemma_22549 (h0 : functor.comp topological_space complete_distrib_lattice linarith.comp) : @preirreducible_space.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.comp.run.{0 0 0} topological_space.{0} complete_distrib_lattice.{0} linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_22550 (h0 : topological_space (linear_ordered_field unsigned)) : totally_separated_space (linear_ordered_field unsigned) := sorry --non-trivial
lemma new_lemma_22551 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (finset.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (finset.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_22552 (h0 : function.extfun (Type 1) ring) : @rank_condition.{1} (has_zero.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (has_zero.{1} Type))  := sorry --non-trivial
lemma new_lemma_22553 (h0 : ring (linear_ordered_add_comm_group (random_gen linarith.comp_source))) : is_domain (linear_ordered_add_comm_group (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_22554 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} (measurable_space.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (measurable_space.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_22555 (h0 : topological_space (has_to_string (has_to_string (has_to_string unsigned)))) : t1_space (has_to_string (has_to_string (has_to_string unsigned))) := sorry --non-trivial
lemma new_lemma_22556 (h0 : topological_space (sub_neg_monoid Type)) : loc_path_connected_space (sub_neg_monoid Type) := sorry --non-trivial
lemma new_lemma_22557 (h0 : function.extfun Type group) : @is_cyclic.{0} (normed_group.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} h0 (normed_group.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_22558 (h0 : functor.comp add_monoid mul_zero_class pos) : @add_monoid.fg.{0} (mul_zero_class.{0} pos) (@functor.comp.run.{0 0 0} add_monoid.{0} mul_zero_class.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_22559 (h0 : uniform_space (has_union (id num))) : separated_space (has_union (id num)) := sorry --non-trivial
lemma new_lemma_22560 (h0 : not (semiring (option num) -> false)) : @is_noetherian_ring.{0} (option.{0} num) (@classical.by_contradiction'.{1} (semiring.{0} (option.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_22561 (h0 : ordered_comm_monoid (sub_neg_monoid (ordered_comm_monoid pos))) : has_exists_mul_of_le (sub_neg_monoid (ordered_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_22562 (h1 : not (uniform_space nnreal -> false)) : complete_space nnreal := sorry --non-trivial
lemma new_lemma_22563 (h0 : ring (cancel_monoid (has_add (boolean_algebra.core unsigned)))) : strong_rank_condition (cancel_monoid (has_add (boolean_algebra.core unsigned))) := sorry --non-trivial
lemma new_lemma_22564 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (has_zero.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_22565 (h1 : ring (has_neg_part reducibility_hints)) : is_domain (has_neg_part reducibility_hints) := sorry --non-trivial
lemma new_lemma_22566 (h0 : has_mem.mem (has_top fun_info) has_emptyc.emptyc) : @is_atomistic.{0} (has_top.{0} fun_info) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (has_top.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_22567 (h0 : topological_space (has_to_string (has_zero (comm_group Type)))) : sequential_space (has_to_string (has_zero (comm_group Type))) := sorry --non-trivial
lemma new_lemma_22568 (h0 : functor.add_const (finset (ordered_comm_group unsigned)) unsigned) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_22569 (h0 : uniform_space (has_union (semiring (semiring congr_arg_kind)))) : complete_space (has_union (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_22570 (h0 : monoid (with_one (random_gen (random_gen linarith.ineq)))) : monoid.fg (with_one (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_22571 (h0 : topological_space (mul_zero_class (option empty))) : path_connected_space (mul_zero_class (option empty)) := sorry --non-trivial
lemma new_lemma_22572 (h1 : ring (random_gen (random_gen to_additive.value_type))) : rank_condition (random_gen (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_22573 (h0 : function.extfun (Type 1) topological_space) : @totally_disconnected_space.{1} (canonically_ordered_comm_semiring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (canonically_ordered_comm_semiring.{1} Type))  := sorry --non-trivial
lemma new_lemma_22574 (h0 : topological_space (boolean_algebra (has_neg Type))) : sequential_space (boolean_algebra (has_neg Type)) := sorry --non-trivial
lemma new_lemma_22575 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (linear_ordered_field.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (linear_ordered_field.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_22576 (h0 : topological_space (has_neg (boolean_algebra.core pos))) : t0_space (has_neg (boolean_algebra.core pos)) := sorry --non-trivial
lemma new_lemma_22577 (h0 : topological_space (ordered_comm_monoid (has_add (has_Inf pos)))) : irreducible_space (ordered_comm_monoid (has_add (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_22578 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring pos)) pos) : @irreducible_space.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_22579 (h0 : functor.add_const (topological_space (has_top congr_arg_kind)) num) : @totally_separated_space.{0} (has_top.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_top.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_22580 (h0 : filter (comm_group (boolean_algebra.core pos))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_22581 (h3 : topological_space ereal) (h4 : set ereal) : is_path_connected h4 := sorry --non-trivial
lemma new_lemma_22582 (h0 : function.extfun (finset Type) (has_mem.mem (has_emptyc linarith.comp_source))) : @totally_separated_space.{0} (has_emptyc.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_emptyc.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_emptyc.{0} linarith.comp_source)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_22583 (h2 : complete_lattice (nondiscrete_normed_field (add_comm_semigroup linarith.ineq))) : complete_lattice.is_Sup_finite_compact (nondiscrete_normed_field (add_comm_semigroup linarith.ineq)) := sorry --non-trivial
lemma new_lemma_22584 (h0 : topological_space (canonically_ordered_comm_semiring (option num))) : normal_space (canonically_ordered_comm_semiring (option num)) := sorry --non-trivial
lemma new_lemma_22585 (h0 : topological_space (complete_distrib_lattice empty)) : irreducible_space (complete_distrib_lattice empty) := sorry --non-trivial
lemma new_lemma_22586 (h0 : functor.add_const (topological_space (preorder num)) num) : @path_connected_space.{0} (preorder.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (preorder.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_22587 (h1 : ring (comm_ring (has_ssubset (random_gen string_imp)))) : strong_rank_condition (comm_ring (has_ssubset (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_22588 (h0 : ring (has_zero linarith.comp)) : is_principal_ideal_ring (has_zero linarith.comp) := sorry --non-trivial
lemma new_lemma_22589 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (linear_order.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (linear_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_22590 (h0 : topological_space (finset num)) : loc_path_connected_space (finset num) := sorry --non-trivial
lemma new_lemma_22591 (h0 : not (complete_lattice (normed_group num) -> false)) : @is_atomistic.{0} (normed_group.{0} num) (@classical.by_contradiction'.{1} (complete_lattice.{0} (normed_group.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_22592 (h0 : ring (linear_ordered_add_comm_group (has_top linarith.ineq))) : is_domain (linear_ordered_add_comm_group (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_22593 (h0 : functor.add_const (topological_space (has_add environment.implicit_infer_kind)) linarith.comp) : @topological_space.separable_space.{0} (has_add.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_22594 (h0 : add_group (has_nndist (option empty))) : is_add_cyclic (has_nndist (option empty)) := sorry --non-trivial
lemma new_lemma_22595 (h0 : prod (semigroup ennreal) (semigroup ennreal)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_22596 (h0 : ring (add_cancel_monoid (option (option empty)))) : is_domain (add_cancel_monoid (option (option empty))) := sorry --non-trivial
lemma new_lemma_22597 (h0 : ring (has_add (finset (has_Inf linarith.comp)))) : is_principal_ideal_ring (has_add (finset (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_22598 (h2 : ring (random_gen (has_nnnorm (has_nnnorm (has_nnnorm fun_info))))) : is_domain (random_gen (has_nnnorm (has_nnnorm (has_nnnorm fun_info)))) := sorry --non-trivial
lemma new_lemma_22599 (h0 : functor.add_const (group (add_cancel_monoid name)) unsigned) : @is_cyclic.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (group.{0} (add_cancel_monoid.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_22600 (h0 : add_monoid (simple_graph name)) : add_monoid.fg (simple_graph name) := sorry --non-trivial
lemma new_lemma_22601 (h0 : group (semigroup linarith.comp)) : is_simple_group (semigroup linarith.comp) := sorry --non-trivial
lemma new_lemma_22602 (h0 : ordered_comm_monoid (finset (boolean_algebra.core linarith.comp))) : has_exists_mul_of_le (finset (boolean_algebra.core linarith.comp)) := sorry --non-trivial
lemma new_lemma_22603 (h0 : functor.add_const (topological_space (complete_distrib_lattice empty)) empty) : @normal_space.{0} (complete_distrib_lattice.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_22604 (h0 : topological_space (ordered_comm_ring (has_add (has_neg name)))) : t0_space (ordered_comm_ring (has_add (has_neg name))) := sorry --non-trivial
lemma new_lemma_22605 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @sequential_space.{0} (ordered_comm_ring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_22606 (h0 : set (uniform_space to_additive.value_type)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_22607 (h0 : functor.add_const (ordered_add_comm_monoid (normed_comm_ring unsigned)) pos) : @archimedean.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (normed_comm_ring.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_22608 (h0 : functor.add_const (function.extfun (Type 1) complete_lattice) pos) : @complete_lattice.is_Sup_finite_compact.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) complete_lattice.{1}) pos h0) (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_22609 (h0 : complete_lattice (boolean_algebra (has_to_string unsigned))) : is_compactly_generated (boolean_algebra (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_22610 (h0 : functor.add_const (topological_space (has_neg name)) environment.implicit_infer_kind) : @sequential_space.{0} (has_neg.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_22611 (h0 : ring (left_cancel_semigroup num)) : is_principal_ideal_ring (left_cancel_semigroup num) := sorry --non-trivial
lemma new_lemma_22612 (h0 : finset (has_to_string (has_neg (boolean_algebra (has_neg linarith.comp))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_22613 (h0 : add_group (sub_neg_monoid Type)) : is_add_cyclic (sub_neg_monoid Type) := sorry --non-trivial
lemma new_lemma_22614 (h2 : group (random_gen fun_info)) : is_cyclic (random_gen fun_info) := sorry --non-trivial
lemma new_lemma_22615 (h0 : functor.add_const (group (linear_ordered_field name)) pos) : @group.fg.{0} (linear_ordered_field.{0} name) (@functor.add_const.run.{0 0} (group.{0} (linear_ordered_field.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_22616 (h0 : group (complete_distrib_lattice empty)) : normalizer_condition (complete_distrib_lattice empty) := sorry --non-trivial
lemma new_lemma_22617 (h0 : fin has_zero.zero) : @monoid.fg.{0} (simple_graph.{0} (has_Inf.{0} linarith.comp)) (@matrix.vec_empty.{0} (monoid.{0} (simple_graph.{0} (has_Inf.{0} linarith.comp))) h0)  := sorry --non-trivial
lemma new_lemma_22618 (h0 : functor.add_const (group (has_pos_part real)) real) : @group.fg.{0} (has_pos_part.{0} real) (@functor.add_const.run.{0 0} (group.{0} (has_pos_part.{0} real)) real h0)  := sorry --non-trivial
lemma new_lemma_22619 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (is_R_or_C.{0} (option.{0} unsigned)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (is_R_or_C.{0} (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_22620 (h0 : group (as_linear_order (option empty))) : is_cyclic (as_linear_order (option empty)) := sorry --non-trivial
lemma new_lemma_22621 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (id string_imp)) := sorry --non-trivial
lemma new_lemma_22622 (h0 : set (string.iterator_imp -> nondiscrete_normed_field environment.implicit_infer_kind)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_22623 (h0 : complete_lattice (pseudo_metric_space (option ennreal))) : is_compactly_generated (pseudo_metric_space (option ennreal)) := sorry --non-trivial
lemma new_lemma_22624 (h0 : topological_space (has_nndist (has_add name))) : path_connected_space (has_nndist (has_add name)) := sorry --non-trivial
lemma new_lemma_22625 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (ring.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_22626 (h0 : not (topological_space (add_left_cancel_monoid linarith.ineq) -> false)) : @t0_space.{0} (add_left_cancel_monoid.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (add_left_cancel_monoid.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_22627 (h0 : cancel_comm_monoid_with_zero (has_to_string (finset name))) : unique_factorization_monoid (has_to_string (finset name)) := sorry --non-trivial
lemma new_lemma_22628 (h0 : topological_space (ring (has_neg name))) : irreducible_space (ring (has_neg name)) := sorry --non-trivial
lemma new_lemma_22629 (h0 : complete_lattice (semigroup (comm_group Type))) : is_compactly_generated (semigroup (comm_group Type)) := sorry --non-trivial
lemma new_lemma_22630 (h0 : not (complete_lattice (comm_ring linarith.ineq) -> false)) : @is_compactly_generated.{0} (comm_ring.{0} linarith.ineq) (@classical.by_contradiction'.{1} (complete_lattice.{0} (comm_ring.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_22631 (h0 : uniform_space (partial_order congr_arg_kind)) : complete_space (partial_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_22632 (h0 : uniform_space (semi_normed_comm_ring environment.projection_info)) : complete_space (semi_normed_comm_ring environment.projection_info) := sorry --non-trivial
lemma new_lemma_22633 (h0 : not (function.extfun Type topological_space -> false)) : @irreducible_space.{0} (random_gen.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (random_gen.{0} empty))  := sorry --non-trivial
lemma new_lemma_22634 (h0 : add_monoid (boolean_algebra (add_group (finset linarith.comp)))) : add_monoid.fg (boolean_algebra (add_group (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_22635 (h0 : function.extfun Type ring) : @rank_condition.{0} (metric_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (metric_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_22636 (h0 : uniform_space (canonically_ordered_comm_semiring (option (option unsigned)))) : separated_space (canonically_ordered_comm_semiring (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_22637 (h4 : ring (mul_one_class enat)) : strong_rank_condition (mul_one_class enat) := sorry --non-trivial
lemma new_lemma_22638 (h0 : function.extfun (Type 1) filter) : countable_Inter_filter (function.extfun_app h0 (has_bot Type)) := sorry --non-trivial
lemma new_lemma_22639 (h0 : topological_space (has_neg (has_add (has_pos_part (has_nndist (has_pos_part pos)))))) : preirreducible_space (has_neg (has_add (has_pos_part (has_nndist (has_pos_part pos))))) := sorry --non-trivial
lemma new_lemma_22640 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_22641 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (comm_ring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (comm_ring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_22642 (h0 : ring (complete_semilattice_Sup (random_gen to_additive.value_type))) : rank_condition (complete_semilattice_Sup (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_22643 (h0 : ordered_add_comm_monoid (normed_lattice_add_comm_group (has_nndist (has_neg Type)))) : archimedean (normed_lattice_add_comm_group (has_nndist (has_neg Type))) := sorry --non-trivial
lemma new_lemma_22644 (h0 : topological_space (ring (ring linarith.comp))) : preconnected_space (ring (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_22645 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (complete_distrib_lattice.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (complete_distrib_lattice.{0} num))  := sorry --non-trivial
lemma new_lemma_22646 (h0 : complete_lattice (uniform_space char)) : is_compactly_generated (uniform_space char) := sorry --non-trivial
lemma new_lemma_22647 (h0 : ring (uniform_space (random_gen reducibility_hints))) : rank_condition (uniform_space (random_gen reducibility_hints)) := sorry --non-trivial
lemma new_lemma_22648 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} (random_gen.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (random_gen.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_22649 (h0 : topological_space (cancel_monoid (has_add ennreal))) : preirreducible_space (cancel_monoid (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_22650 (h1 : topological_space (nondiscrete_normed_field string.iterator_imp)) (h2 : add_group (nondiscrete_normed_field string.iterator_imp)) : topological_add_group (nondiscrete_normed_field string.iterator_imp) := sorry --non-trivial
lemma new_lemma_22651 (h0 : complete_lattice (has_top linarith.comp_source)) : is_compactly_generated (has_top linarith.comp_source) := sorry --non-trivial
lemma new_lemma_22652 (h0 : functor.add_const (function.extfun Type complete_lattice) linarith.comp) : @is_compactly_generated.{0} environment.implicit_infer_kind (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) linarith.comp h0) environment.implicit_infer_kind)  := sorry --non-trivial
lemma new_lemma_22653 (h0 : functor.add_const (complete_lattice (add_cancel_monoid name)) environment.implicit_infer_kind) : @is_atomistic.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_cancel_monoid.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_22654 (h1 : function.extfun Type topological_space) : @t0_space.{0} (complete_semilattice_Sup.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (complete_semilattice_Sup.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_22655 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (sub_neg_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (sub_neg_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_22656 (h0 : functor.add_const (complete_lattice (canonically_ordered_monoid real)) (sub_neg_monoid real)) : @is_compactly_generated.{0} (canonically_ordered_monoid.{0} real) (@functor.add_const.run.{0 0} (complete_lattice.{0} (canonically_ordered_monoid.{0} real)) (sub_neg_monoid.{0} real) h0)  := sorry --non-trivial
lemma new_lemma_22657 (h0 : not (topological_space (partial_order congr_arg_kind) -> false)) : @normal_space.{0} (partial_order.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (partial_order.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_22658 (h0 : ring (uniform_space (has_to_string char))) : strong_rank_condition (uniform_space (has_to_string char)) := sorry --non-trivial
lemma new_lemma_22659 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (normed_group.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} unsigned)))))) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (normed_group.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} unsigned)))))))  := sorry --non-trivial
lemma new_lemma_22660 (h0 : group (distrib_lattice (has_nnnorm (has_nnnorm (has_top to_additive.value_type))))) : group.fg (distrib_lattice (has_nnnorm (has_nnnorm (has_top to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_22661 (h0 : uniform_space (boolean_algebra (has_add linarith.comp))) : separated_space (boolean_algebra (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_22662 (h1 : complete_lattice (fintype (encodable (fintype char)))) : complete_lattice.is_Sup_finite_compact (fintype (encodable (fintype char))) := sorry --non-trivial
lemma new_lemma_22663 (h0 : topological_space (has_Inf Type)) : normal_space (has_Inf Type) := sorry --non-trivial
lemma new_lemma_22664 (h0 : ring (measurable_space.dynkin_system empty)) : strong_rank_condition (measurable_space.dynkin_system empty) := sorry --non-trivial
lemma new_lemma_22665 (h0 : ring (has_zero (has_add linarith.comp))) : is_domain (has_zero (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_22666 (h0 : ring (semigroup (has_Inf linarith.comp))) : is_domain (semigroup (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_22667 (h0 : topological_space (boolean_algebra (ring (has_Inf (has_add linarith.comp))))) : t1_space (boolean_algebra (ring (has_Inf (has_add linarith.comp)))) := sorry --non-trivial
lemma new_lemma_22668 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (has_to_string.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_to_string.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_22669 (h0 : functor.add_const (topological_space (ordered_ring unsigned)) (option unsigned)) : @discrete_topology.{0} (ordered_ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} unsigned)) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_22670 (h0 : add_group (partial_order num)) : is_add_cyclic (partial_order num) := sorry --non-trivial
lemma new_lemma_22671 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (ordered_cancel_add_comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_cancel_add_comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_22672 (h1 : functor.add_const (topological_space (has_emptyc string_imp)) num) : @t0_space.{0} (has_emptyc.{0} string_imp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_emptyc.{0} string_imp)) num h1)  := sorry --non-trivial
lemma new_lemma_22673 (h0 : cancel_comm_monoid_with_zero (preorder (option empty))) : unique_factorization_monoid (preorder (option empty)) := sorry --non-trivial
lemma new_lemma_22674 (h0 : filter (has_one (has_norm linarith.comp))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_22675 (h0 : functor.add_const (topological_space (has_add pos)) name) : @totally_separated_space.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_22676 (h0 : semiring (with_one (has_norm (has_norm (has_norm empty))))) : is_noetherian_ring (with_one (has_norm (has_norm (has_norm empty)))) := sorry --non-trivial
lemma new_lemma_22677 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_nndist.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_nndist.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_22678 (h0 : list (add_semigroup unsigned)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_22679 (h0 : topological_space (has_bot (normed_comm_ring (ring pos)))) : topological_space.separable_space (has_bot (normed_comm_ring (ring pos))) := sorry --non-trivial
lemma new_lemma_22680 (h0 : functor.add_const (uniform_space (bin_tree unsigned)) (semiring num)) : @complete_space.{0} (bin_tree.{0} unsigned) (@functor.add_const.run.{0 0} (uniform_space.{0} (bin_tree.{0} unsigned)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_22681 (h0 : topological_space (has_neg pos)) : t1_space (has_neg pos) := sorry --non-trivial
lemma new_lemma_22682 (h0 : ordered_add_comm_monoid (simple_graph (has_neg (has_add pos)))) : archimedean (simple_graph (has_neg (has_add pos))) := sorry --non-trivial
lemma new_lemma_22683 (h0 : uniform_space (semigroup (normed_comm_ring (normed_comm_ring environment.implicit_infer_kind)))) : complete_space (semigroup (normed_comm_ring (normed_comm_ring environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_22684 (h0 : ring (add_comm_semigroup (normed_field char))) : is_domain (add_comm_semigroup (normed_field char)) := sorry --non-trivial
lemma new_lemma_22685 (h0 : group (has_norm (semiring unsigned))) : group.fg (has_norm (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_22686 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (linear_ordered_field.{0} num) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (linear_ordered_field.{0} num))  := sorry --non-trivial
lemma new_lemma_22687 (h1 : group (has_compl (has_ssubset char))) : is_cyclic (has_compl (has_ssubset char)) := sorry --non-trivial
lemma new_lemma_22688 (h0 : list (boolean_algebra.core (comm_group name))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_22689 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (linear_ordered_field.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_field.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_22690 (h0 : ring (random_gen (random_gen char))) : is_domain (random_gen (random_gen char)) := sorry --non-trivial
lemma new_lemma_22691 (h0 : finset (option (option unsigned))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_22692 (h0 : has_mem.mem (metric_space linarith.comp) has_emptyc.emptyc) : @add_monoid.fg.{0} (metric_space.{0} linarith.comp) (@finset.pi.empty.{1 0} Type add_monoid.{0} (metric_space.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_22693 (h0 : uniform_space (has_edist (option (option (option empty))))) : complete_space (has_edist (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_22694 (h0 : not (function.extfun Type complete_lattice -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (distrib.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (distrib.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_22695 (h0 : complete_lattice (has_neg (boolean_algebra Type))) : complete_lattice.is_Sup_finite_compact (has_neg (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_22696 (h0 : topological_space (finset (finset pos))) : t0_space (finset (finset pos)) := sorry --non-trivial
lemma new_lemma_22697 (h0 : not (function.extfun Type topological_space -> false)) : @normal_space.{0} (has_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_22698 (h1 : complete_lattice (encodable (has_inv linarith.comp_source))) : complete_lattice.is_Sup_finite_compact (encodable (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_22699 (h0 : topological_space (complete_distrib_lattice (sub_neg_monoid (has_Inf Type)))) : preirreducible_space (complete_distrib_lattice (sub_neg_monoid (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_22700 (h0 : prod (add_cancel_comm_monoid empty) (add_cancel_comm_monoid empty)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_22701 (h0 : group (linear_ordered_semiring (has_norm (has_norm (has_norm empty))))) : normalizer_condition (linear_ordered_semiring (has_norm (has_norm (has_norm empty)))) := sorry --non-trivial
lemma new_lemma_22702 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (has_dist.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_dist.{0} empty))  := sorry --non-trivial
lemma new_lemma_22703 (h0 : topological_space (finset (has_add linarith.comp))) : locally_compact_space (finset (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_22704 (h0 : topological_space (boolean_algebra (ring (comm_group Type)))) : path_connected_space (boolean_algebra (ring (comm_group Type))) := sorry --non-trivial
lemma new_lemma_22705 (h0 : not (uniform_space (measurable_space linarith.comp) -> false)) : @complete_space.{0} (measurable_space.{0} linarith.comp) (@classical.by_contradiction'.{1} (uniform_space.{0} (measurable_space.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_22706 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (linear_ordered_field.{0} ennreal) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (linear_ordered_field.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_22707 (h0 : complete_lattice (mul_zero_class name)) : complete_lattice.is_Sup_finite_compact (mul_zero_class name) := sorry --non-trivial
lemma new_lemma_22708 (h0 : ring (generalized_boolean_algebra (has_neg (has_neg Type)))) : is_principal_ideal_ring (generalized_boolean_algebra (has_neg (has_neg Type))) := sorry --non-trivial
lemma new_lemma_22709 (h0 : functor.add_const (function.extfun Type group) linarith.comp) : @is_simple_group.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) linarith.comp h0) (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_22710 (h0 : not (complete_lattice (add_right_cancel_monoid congr_arg_kind) -> false)) : @is_atomistic.{0} (add_right_cancel_monoid.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (complete_lattice.{0} (add_right_cancel_monoid.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_22711 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (has_sub.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_sub.{0} empty))  := sorry --non-trivial
lemma new_lemma_22712 (h0 : linear_ordered_comm_group ennreal -> linear_ordered_comm_group ennreal -> Prop) : reflexive h0 := sorry --non-trivial
lemma new_lemma_22713 (h0 : ordered_comm_monoid (ordered_comm_ring (ring Type))) : has_exists_mul_of_le (ordered_comm_ring (ring Type)) := sorry --non-trivial
lemma new_lemma_22714 (h0 : Prop) (h1 : sym2 Prop) (h2 : has_mem.mem h0 h1) : @sym2.mem.other'.{0} Prop (λ (a b : Prop), @eq.decidable.{0} Prop Prop.linear_order a b) h0 h1 h2  := sorry --non-trivial
lemma new_lemma_22715 (h0 : topological_space (semigroup (finset (finset (finset pos))))) : topological_space.separable_space (semigroup (finset (finset (finset pos)))) := sorry --non-trivial
lemma new_lemma_22716 (h0 : topological_space (ring (has_add pos))) : normal_space (ring (has_add pos)) := sorry --non-trivial
lemma new_lemma_22717 (h0 : ring (normed_group (semiring num))) : is_domain (normed_group (semiring num)) := sorry --non-trivial
lemma new_lemma_22718 (h2 : ring (distrib char)) : rank_condition (distrib char) := sorry --non-trivial
lemma new_lemma_22719 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (with_bot.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} h0 (with_bot.{0} empty))  := sorry --non-trivial
lemma new_lemma_22720 (h0 : function.extfun Type topological_space) : @regular_space.{0} (simple_graph.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (simple_graph.{0} name))  := sorry --non-trivial
lemma new_lemma_22721 (h0 : not (topological_space (with_bot congr_arg_kind) -> false)) : @totally_disconnected_space.{0} (with_bot.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (with_bot.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_22722 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_22723 (h0 : ring (has_neg num)) : rank_condition (has_neg num) := sorry --non-trivial
lemma new_lemma_22724 (h0 : ordered_comm_monoid (normed_comm_ring (finset Type))) : has_exists_mul_of_le (normed_comm_ring (finset Type)) := sorry --non-trivial
lemma new_lemma_22725 (h0 : functor.add_const (topological_space (has_neg pos)) pos) : @totally_separated_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_22726 (h0 : multiset (has_compl to_additive.value_type)) : multiset.nodup h0 := sorry --non-trivial
lemma new_lemma_22727 (h0 : group (linear_ordered_add_comm_group (has_nnnorm (has_nnnorm fun_info)))) : is_cyclic (linear_ordered_add_comm_group (has_nnnorm (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_22728 (h0 : ring (boolean_algebra (has_to_string name))) : is_principal_ideal_ring (boolean_algebra (has_to_string name)) := sorry --non-trivial
lemma new_lemma_22729 (h0 : ring (semiring empty)) : rank_condition (semiring empty) := sorry --non-trivial
lemma new_lemma_22730 (h0 : function.extfun Type (functor.comp topological_space comm_group)) : @locally_compact_space.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} comm_group.{0} environment.implicit_infer_kind (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} comm_group.{0}) h0 environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_22731 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_22732 (h3 : topological_space fun_info) : path_connected_space fun_info := sorry --non-trivial
lemma new_lemma_22733 (h0 : function.extfun (Type 1) ordered_add_comm_monoid) : @archimedean.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_add_comm_monoid.{1} h0 (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_22734 (h0 : topological_space (preorder (semiring (semiring unsigned)))) : topological_space.separable_space (preorder (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_22735 (h1 : not (ring (has_div string_imp) -> false)) : @rank_condition.{0} (has_div.{0} string_imp) (@classical.by_contradiction'.{1} (ring.{0} (has_div.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_22736 (h0 : monoid (has_bot name)) : monoid.fg (has_bot name) := sorry --non-trivial
lemma new_lemma_22737 (h0 : filter (has_nndist empty)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_22738 (h0 : complete_lattice (div_inv_monoid (linear_ordered_field linarith.ineq))) : is_compactly_generated (div_inv_monoid (linear_ordered_field linarith.ineq)) := sorry --non-trivial
lemma new_lemma_22739 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (simple_graph.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (simple_graph.{0} pos))  := sorry --non-trivial
lemma new_lemma_22740 (h0 : functor.add_const (topological_space (has_Sup num)) (semiring num)) : @topological_space.separable_space.{0} (has_Sup.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Sup.{0} num)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_22741 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (ordered_cancel_add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_cancel_add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_22742 (h0 : functor.add_const (add_monoid (monoid num)) unsigned) : @add_monoid.fg.{0} (monoid.{0} num) (@functor.add_const.run.{0 0} (add_monoid.{0} (monoid.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_22743 (h0 : fin has_zero.zero) : @preirreducible_space.{0} (ordered_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (ordered_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_22744 (h0 : filter (linear_ordered_field (option (option unsigned)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_22745 (h0 : topological_space (normed_linear_ordered_group (option empty))) : irreducible_space (normed_linear_ordered_group (option empty)) := sorry --non-trivial
lemma new_lemma_22746 (h1 : ring (semiring (has_norm (has_norm (has_norm fun_info))))) : is_domain (semiring (has_norm (has_norm (has_norm fun_info)))) := sorry --non-trivial
lemma new_lemma_22747 (h0 : topological_space (ring (has_add (has_add (has_pos_part pos))))) : totally_disconnected_space (ring (has_add (has_add (has_pos_part pos)))) := sorry --non-trivial
lemma new_lemma_22748 (h0 : functor.add_const (complete_lattice (has_zero name)) linarith.comp) : @is_compactly_generated.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_zero.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_22749 (h0 : functor.add_const (ordered_comm_monoid linarith.comp) pos) : @has_exists_mul_of_le.{0} linarith.comp (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} linarith.comp) pos h0)  := sorry --non-trivial
lemma new_lemma_22750 (h0 : finset (has_neg ennreal)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_22751 (h0 : complete_lattice (has_div (mul_one_class to_additive.value_type))) : complete_lattice.is_Sup_finite_compact (has_div (mul_one_class to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_22752 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (left_cancel_semigroup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (left_cancel_semigroup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_22753 (h2 : add_group (has_emptyc (has_norm linarith.ineq))) : is_add_cyclic (has_emptyc (has_norm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_22754 (h0 : topological_space (has_add (option (option ennreal)))) : discrete_topology (has_add (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_22755 (h0 : ordered_comm_monoid (comm_group (finset linarith.comp))) : has_exists_mul_of_le (comm_group (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_22756 (h0 : function.extfun Type topological_space) : @t1_space.{0} (has_nndist.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_22757 (h0 : functor.add_const (monoid (boolean_algebra Type)) (has_add pos)) : @monoid.fg.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (monoid.{1} (boolean_algebra.{1} Type)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_22758 (h0 : finset (normed_comm_ring (ring Type))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_22759 (h0 : not (group (has_norm congr_arg_kind) -> false)) : @normalizer_condition.{0} (has_norm.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (group.{0} (has_norm.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_22760 (h0 : function.extfun (Type 1) topological_space) : @normal_space.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_22761 (h0 : functor.add_const (group (ring linarith.comp)) (ring Type)) : @is_simple_group.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (group.{0} (ring.{0} linarith.comp)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_22762 (h0 : has_le (normed_field (add_comm_semigroup fun_info))) (h1 : normed_field (add_comm_semigroup fun_info)) : is_max h1 := sorry --non-trivial
lemma new_lemma_22763 (h1 : topological_space (measurable_space Type)) : totally_disconnected_space (measurable_space Type) := sorry --non-trivial
lemma new_lemma_22764 (h0 : functor.add_const (topological_space (normed_comm_ring name)) environment.implicit_infer_kind) : @preconnected_space.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_22765 (h0 : topological_space (measure_theory.measure_space (semiring unsigned))) : t0_space (measure_theory.measure_space (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_22766 (h0 : topological_space (canonically_linear_ordered_monoid (has_Inf real))) : totally_disconnected_space (canonically_linear_ordered_monoid (has_Inf real)) := sorry --non-trivial
lemma new_lemma_22767 (h0 : ordered_comm_monoid (ring (has_add (has_to_string (finset (has_to_string pos)))))) : has_exists_mul_of_le (ring (has_add (has_to_string (finset (has_to_string pos))))) := sorry --non-trivial
lemma new_lemma_22768 (h0 : ring (has_dist unsigned)) : is_domain (has_dist unsigned) := sorry --non-trivial
lemma new_lemma_22769 (h0 : functor.add_const (topological_space (semigroup unsigned)) (normed_comm_ring Type)) : @preirreducible_space.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (semigroup.{0} unsigned)) (normed_comm_ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_22770 (h0 : function.extfun (finset Type) (has_mem.mem (random_gen linarith.comp_source))) : @monoid.fg.{0} (random_gen.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type monoid.{0} (random_gen.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} linarith.comp_source)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_22771 (h0 : not (topological_space (random_gen linarith.comp) -> false)) : @totally_separated_space.{0} (random_gen.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (random_gen.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_22772 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (canonically_ordered_comm_semiring.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (canonically_ordered_comm_semiring.{0} name))  := sorry --non-trivial
lemma new_lemma_22773 (h0 : functor.add_const (add_monoid (boolean_algebra Type)) pos) : @add_monoid.fg.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (add_monoid.{1} (boolean_algebra.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_22774 (h2 : ring (add_monoid to_additive.value_type)) : strong_rank_condition (add_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_22775 (h0 : functor.add_const (topological_space (free_add_monoid num)) num) : @totally_separated_space.{0} (free_add_monoid.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_22776 (h0 : group (complete_semilattice_Sup (random_gen (has_top (has_top fun_info))))) : normalizer_condition (complete_semilattice_Sup (random_gen (has_top (has_top fun_info)))) := sorry --non-trivial
lemma new_lemma_22777 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (ordered_comm_ring name)) := sorry --non-trivial
lemma new_lemma_22778 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} name (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) name)  := sorry --non-trivial
lemma new_lemma_22779 (h0 : add_group (has_top unsigned)) : is_add_cyclic (has_top unsigned) := sorry --non-trivial
lemma new_lemma_22780 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (@id.{2} Type linarith.ineq) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (@id.{2} Type linarith.ineq))  := sorry --non-trivial
lemma new_lemma_22781 (h0 : topological_space (has_dist (option (option (option empty))))) : t1_space (has_dist (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_22782 (h0 : topological_space (add_cancel_monoid (has_to_string (finset pos)))) : normal_space (add_cancel_monoid (has_to_string (finset pos))) := sorry --non-trivial
lemma new_lemma_22783 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_22784 (h0 : functor.add_const (topological_space (ring environment.implicit_infer_kind)) environment.implicit_infer_kind) : @preirreducible_space.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_22785 (h1 : complete_lattice (id string_imp)) : complete_lattice.is_Sup_finite_compact (id string_imp) := sorry --non-trivial
lemma new_lemma_22786 (h0 : add_group (add_monoid (has_nnnorm (has_nnnorm (has_nnnorm linarith.ineq))))) : is_add_cyclic (add_monoid (has_nnnorm (has_nnnorm (has_nnnorm linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_22787 (h0 : functor.comp topological_space add_comm_monoid environment.implicit_infer_kind) : @topological_space.separable_space.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} add_comm_monoid.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_22788 (h0 : functor.add_const (semiring (boolean_algebra.core pos)) Type) : @is_noetherian_ring.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 1} (semiring.{0} (boolean_algebra.core.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_22789 (h0 : group (left_cancel_semigroup (semiring (semiring (semiring empty))))) : is_cyclic (left_cancel_semigroup (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_22790 (h0 : ring (denumerable linarith.comp_source)) : strong_rank_condition (denumerable linarith.comp_source) := sorry --non-trivial
lemma new_lemma_22791 (h0 : function.extfun Type (functor.comp group semigroup)) : @is_simple_group.{0} (semigroup.{0} name) (@functor.comp.run.{0 0 0} group.{0} semigroup.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} group.{0} semigroup.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_22792 (h0 : nat) (h1 : set (string.iterator_imp -> array h0 fun_info)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_22793 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (comm_ring.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 topological_space.{0}) (comm_ring.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_22794 (h0 : ring (has_norm (has_nnnorm (random_gen to_additive.value_type)))) : rank_condition (has_norm (has_nnnorm (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_22795 (h0 : ring (fintype (ordered_comm_monoid char))) : strong_rank_condition (fintype (ordered_comm_monoid char)) := sorry --non-trivial
lemma new_lemma_22796 (h0 : functor.add_const (function.extfun Type add_group) name) : @is_add_cyclic.{0} (cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type add_group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_group.{0}) name h0) (cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_22797 (h0 : topological_space (normed_comm_ring (has_add name))) : sequential_space (normed_comm_ring (has_add name)) := sorry --non-trivial
lemma new_lemma_22798 (h0 : functor.add_const (functor.add_const (complete_lattice Type) Type) pos) : @complete_lattice.is_Sup_finite_compact.{1} Type (@functor.add_const.run.{1 1} (complete_lattice.{1} Type) Type (@functor.add_const.run.{1 0} (functor.add_const.{1 1} (complete_lattice.{1} Type) Type) pos h0))  := sorry --non-trivial
lemma new_lemma_22799 (h0 : topological_space (complete_linear_order (semiring unsigned))) : path_connected_space (complete_linear_order (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_22800 (h0 : functor.add_const (topological_space (finset Type)) pos) : @t0_space.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (finset.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_22801 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @t1_space.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_22802 (h0 : topological_space (finset (has_nndist environment.implicit_infer_kind))) : t1_space (finset (has_nndist environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_22803 (h0 : functor.comp semiring finset name) : @is_noetherian_ring.{0} (finset.{0} name) (@functor.comp.run.{0 0 0} semiring.{0} finset.{0} name h0)  := sorry --non-trivial
lemma new_lemma_22804 (h0 : topological_space (has_neg_part (comm_group (has_neg_part Type)))) : path_connected_space (has_neg_part (comm_group (has_neg_part Type))) := sorry --non-trivial
lemma new_lemma_22805 (h0 : functor.add_const (topological_space (has_pos_part pos)) (ring (has_nndist (finset pos)))) : @sequential_space.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} pos)) (ring.{0} (has_nndist.{0} (finset.{0} pos))) h0)  := sorry --non-trivial
lemma new_lemma_22806 (h0 : topological_space (add_comm_monoid congr_arg_kind)) : path_connected_space (add_comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_22807 (h0 : group (with_bot (semiring fun_info))) : group.fg (with_bot (semiring fun_info)) := sorry --non-trivial
lemma new_lemma_22808 (h0 : complete_lattice (option (semiring num))) : is_compactly_generated (option (semiring num)) := sorry --non-trivial
lemma new_lemma_22809 (h0 : functor.add_const (topological_space (ordered_ring congr_arg_kind)) (semiring empty)) : @totally_disconnected_space.{0} (ordered_ring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} congr_arg_kind)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_22810 (h0 : topological_space (dlist (has_ssubset char))) : t0_space (dlist (has_ssubset char)) := sorry --non-trivial
lemma new_lemma_22811 (h0 : topological_space (linear_ordered_semiring (has_top num))) : irreducible_space (linear_ordered_semiring (has_top num)) := sorry --non-trivial
lemma new_lemma_22812 (h0 : topological_space (ordered_comm_monoid (has_neg linarith.comp))) : t0_space (ordered_comm_monoid (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_22813 (h0 : topological_space (mul_one_class string_imp)) : path_connected_space (mul_one_class string_imp) := sorry --non-trivial
lemma new_lemma_22814 (h0 : topological_space (complete_distrib_lattice (boolean_algebra Type))) : locally_compact_space (complete_distrib_lattice (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_22815 (h0 : not (complete_lattice (add_zero_class linarith.ineq) -> false)) : @is_compactly_generated.{0} (add_zero_class.{0} linarith.ineq) (@classical.by_contradiction'.{1} (complete_lattice.{0} (add_zero_class.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_22816 (h0 : group (has_bot empty)) : normalizer_condition (has_bot empty) := sorry --non-trivial
lemma new_lemma_22817 (h0 : not (topological_space (plift num) -> false)) : @path_connected_space.{1} (plift.{1} num) (@classical.by_contradiction'.{2} (topological_space.{1} (plift.{1} num)) h0)  := sorry --non-trivial
lemma new_lemma_22818 (h0 : function.extfun Type (functor.add_const (complete_lattice (semigroup empty)))) : @is_compactly_generated.{0} (semigroup.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (semigroup.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (complete_lattice.{0} (semigroup.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_22819 (h0 : ring (has_neg (ring linarith.comp))) : is_domain (has_neg (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_22820 (h0 : topological_space (semigroup (has_add Type))) : preconnected_space (semigroup (has_add Type)) := sorry --non-trivial
lemma new_lemma_22821 (h0 : topological_space (has_zero (comm_group unsigned))) : discrete_topology (has_zero (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_22822 (h0 : functor.add_const (topological_space (has_add linarith.comp)) (has_neg linarith.comp)) : @regular_space.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} linarith.comp)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_22823 (h1 : topological_space (encodable (random_gen to_additive.value_type))) : irreducible_space (encodable (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_22824 (h0 : topological_space (finset (has_add linarith.comp))) : t1_space (finset (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_22825 (h0 : add_group (has_compl (random_gen (random_gen (random_gen linarith.comp_source))))) : is_add_cyclic (has_compl (random_gen (random_gen (random_gen linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_22826 (h0 : topological_space (generalized_boolean_algebra (has_bot real))) : discrete_topology (generalized_boolean_algebra (has_bot real)) := sorry --non-trivial
lemma new_lemma_22827 (h0 : functor.add_const (group (mul_zero_class environment.implicit_infer_kind)) name) : @group.fg.{0} (mul_zero_class.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (mul_zero_class.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_22828 (h0 : uniform_space (has_Inf (has_Inf (has_Inf pos)))) : complete_space (has_Inf (has_Inf (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_22829 (h0 : not (topological_space (has_union congr_arg_kind) -> false)) : @locally_compact_space.{0} (has_union.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (has_union.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_22830 (h0 : add_cancel_monoid (ring pos) -> add_cancel_monoid (ring pos) -> Prop) : is_symm (add_cancel_monoid (ring pos)) h0 := sorry --non-trivial
lemma new_lemma_22831 (h0 : ring (has_star empty)) : rank_condition (has_star empty) := sorry --non-trivial
lemma new_lemma_22832 (h0 : functor.add_const (topological_space (semigroup environment.implicit_infer_kind)) name) : @path_connected_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_22833 (h0 : functor.add_const (topological_space (add_cancel_monoid environment.implicit_infer_kind)) name) : @preirreducible_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_22834 (h0 : add_group (complete_semilattice_Sup (with_bot string_imp))) : is_add_cyclic (complete_semilattice_Sup (with_bot string_imp)) := sorry --non-trivial
lemma new_lemma_22835 (h1 : topological_space pos) : path_connected_space pos := sorry --non-trivial
lemma new_lemma_22836 (h0 : functor.add_const (topological_space (linear_ordered_cancel_comm_monoid unsigned)) unsigned) : @t0_space.{0} (linear_ordered_cancel_comm_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_cancel_comm_monoid.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_22837 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (normed_linear_ordered_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_linear_ordered_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_22838 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type semiring.{0} h0 (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_22839 (h0 : filter (comm_group (ordered_cancel_add_comm_monoid name))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_22840 (h0 : functor.add_const (topological_space (comm_group linarith.comp)) linarith.comp) : @irreducible_space.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_22841 (h0 : not (function.extfun Type topological_space -> false)) : @totally_disconnected_space.{0} (has_top.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_top.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_22842 (h0 : topological_space (normed_group (with_zero fun_info))) : path_connected_space (normed_group (with_zero fun_info)) := sorry --non-trivial
lemma new_lemma_22843 (h0 : fin has_zero.zero) : @is_cyclic.{1} (ordered_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (group.{1} (ordered_comm_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_22844 (h0 : uniform_space environment.implicit_infer_kind) : complete_space environment.implicit_infer_kind := sorry --non-trivial
lemma new_lemma_22845 (h0 : topological_space string.iterator_imp) (h1 : set string.iterator_imp) : is_seq_compact h1 := sorry --non-trivial
lemma new_lemma_22846 (h0 : group (sub_neg_monoid (has_neg Type))) : is_simple_group (sub_neg_monoid (has_neg Type)) := sorry --non-trivial
lemma new_lemma_22847 (h0 : function.extfun (Type 1) uniform_space) : @separated_space.{1} (add_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} h0 (add_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_22848 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (ordered_cancel_add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (ordered_cancel_add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_22849 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (has_dist.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_dist.{0} empty))  := sorry --non-trivial
lemma new_lemma_22850 (h1 : random_gen to_additive.value_type -> to_additive.value_type -> Prop) : relator.right_total h1 := sorry --non-trivial
lemma new_lemma_22851 (h0 : topological_space (has_neg_part (has_add pos))) : sequential_space (has_neg_part (has_add pos)) := sorry --non-trivial
lemma new_lemma_22852 (h0 : functor.add_const (topological_space (has_neg_part environment.implicit_infer_kind)) Type) : @loc_path_connected_space.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg_part.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_22853 (h0 : functor.add_const (topological_space (has_nndist environment.implicit_infer_kind)) linarith.comp) : @t0_space.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_22854 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (preorder.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (preorder.{0} empty))  := sorry --non-trivial
lemma new_lemma_22855 (h0 : functor.add_const (group (semigroup Type)) Type) : @is_cyclic.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 1} (group.{1} (semigroup.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_22856 (h0 : topological_space (mul_one_class name)) : path_connected_space (mul_one_class name) := sorry --non-trivial
lemma new_lemma_22857 (h0 : topological_space (option (semiring (semiring (semiring (semiring unsigned)))))) : t0_space (option (semiring (semiring (semiring (semiring unsigned))))) := sorry --non-trivial
lemma new_lemma_22858 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (bin_tree.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} h0 (bin_tree.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_22859 (h0 : topological_space (metric_space num)) : irreducible_space (metric_space num) := sorry --non-trivial
lemma new_lemma_22860 (h0 : functor.comp ring div_inv_monoid fun_info) : @rank_condition.{0} (div_inv_monoid.{0} fun_info) (@functor.comp.run.{0 0 0} ring.{0} div_inv_monoid.{0} fun_info h0)  := sorry --non-trivial
lemma new_lemma_22861 (h0 : filter (non_assoc_semiring unsigned)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_22862 (h0 : uniform_space (ring (option (option ennreal)))) : separated_space (ring (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_22863 (h0 : not (ring (has_lt linarith.ineq) -> false)) : @rank_condition.{0} (has_lt.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (has_lt.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_22864 (h0 : group (ordered_comm_ring real)) : normalizer_condition (ordered_comm_ring real) := sorry --non-trivial
lemma new_lemma_22865 (h0 : filter (semi_normed_comm_ring (random_gen to_additive.value_type))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_22866 (h0 : ring (boolean_algebra.core (comm_group (comm_group Type)))) : strong_rank_condition (boolean_algebra.core (comm_group (comm_group Type))) := sorry --non-trivial
lemma new_lemma_22867 (h0 : function.extfun Type multiset) : multiset.nodup (function.extfun_app h0 (canonically_ordered_comm_semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_22868 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (ring.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_22869 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (ring.{0} unsigned) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_22870 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (boolean_algebra.core.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.core.{0} pos))  := sorry --non-trivial
lemma new_lemma_22871 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_atomistic.{0} empty (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) empty)  := sorry --non-trivial
lemma new_lemma_22872 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} (linear_ordered_comm_ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (linear_ordered_comm_ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_22873 (h0 : complete_lattice (has_zero (has_pos_part (has_zero linarith.comp)))) : complete_lattice.is_Sup_finite_compact (has_zero (has_pos_part (has_zero linarith.comp))) := sorry --non-trivial
lemma new_lemma_22874 (h0 : topological_space (finset linarith.comp)) : discrete_topology (finset linarith.comp) := sorry --non-trivial
lemma new_lemma_22875 (h2 : measurable_space (mul_one_class reducibility_hints)) (h3 : measure_theory.measure (mul_one_class reducibility_hints)) : measure_theory.is_finite_measure h3 := sorry --non-trivial
lemma new_lemma_22876 (h0 : ring (has_add (has_to_string pos))) : rank_condition (has_add (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_22877 (h0 : list (measurable_space linarith.ineq)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_22878 (h0 : uniform_space (has_nndist (ring (option pos)))) : complete_space (has_nndist (ring (option pos))) := sorry --non-trivial
lemma new_lemma_22879 (h0 : functor.add_const (function.extfun (Type 1) semiring) pos) : @is_noetherian_ring.{1} (normed_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) semiring.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) semiring.{1}) pos h0) (normed_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_22880 (h0 : group (has_union (has_norm unsigned))) : normalizer_condition (has_union (has_norm unsigned)) := sorry --non-trivial
lemma new_lemma_22881 (h0 : list (has_zero ennreal)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_22882 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_atomistic.{0} linarith.comp (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) linarith.comp)  := sorry --non-trivial
lemma new_lemma_22883 (h0 : topological_space (semi_normed_comm_ring (has_nnnorm (has_nnnorm char)))) : locally_compact_space (semi_normed_comm_ring (has_nnnorm (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_22884 (h0 : group (semigroup Type)) : is_cyclic (semigroup Type) := sorry --non-trivial
lemma new_lemma_22885 (h0 : topological_space (random_gen (semiring linarith.comp))) : preirreducible_space (random_gen (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_22886 (h0 : functor.add_const (topological_space (linear_ordered_field empty)) unsigned) : @topological_space.separable_space.{0} (linear_ordered_field.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_field.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_22887 (h0 : topological_space (has_inter (option empty))) : loc_path_connected_space (has_inter (option empty)) := sorry --non-trivial
lemma new_lemma_22888 (h0 : list (canonically_ordered_comm_semiring (finset name))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_22889 (h0 : uniform_space (has_union (semiring (semiring unsigned)))) : separated_space (has_union (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_22890 (h0 : list (ordered_cancel_add_comm_monoid num)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_22891 (h0 : function.extfun Type topological_space) : @t0_space.{0} (complete_semilattice_Sup.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_semilattice_Sup.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_22892 (h0 : functor.comp topological_space semigroup pos) : @preirreducible_space.{0} (semigroup.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_22893 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (with_bot.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (with_bot.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_22894 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (linear_ordered_comm_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (linear_ordered_comm_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_22895 (h0 : ring (canonically_ordered_comm_semiring pos)) : strong_rank_condition (canonically_ordered_comm_semiring pos) := sorry --non-trivial
lemma new_lemma_22896 (h0 : complete_lattice (with_one (linear_ordered_add_comm_group char))) : complete_lattice.is_Sup_finite_compact (with_one (linear_ordered_add_comm_group char)) := sorry --non-trivial
lemma new_lemma_22897 (h0 : multiset (semi_normed_comm_ring reducibility_hints)) (h1 : not (multiset (semi_normed_comm_ring reducibility_hints) -> false)) : multiset.disjoint h0 (classical.by_contradiction' h1) := sorry --non-trivial
lemma new_lemma_22898 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (complete_semilattice_Sup.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_semilattice_Sup.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_22899 (h0 : functor.add_const (function.extfun (Type 1) filter) name) : countable_Inter_filter (function.extfun_app (functor.add_const.run h0) (has_zero Type)) := sorry --non-trivial
lemma new_lemma_22900 (h0 : add_monoid (boolean_algebra.core (finset Type))) : add_monoid.fg (boolean_algebra.core (finset Type)) := sorry --non-trivial
lemma new_lemma_22901 (h0 : functor.add_const (uniform_space (linear_order unsigned)) unsigned) : @separated_space.{0} (linear_order.{0} unsigned) (@functor.add_const.run.{0 0} (uniform_space.{0} (linear_order.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_22902 (h0 : list (has_to_string linarith.comp)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_22903 (h0 : complete_lattice (has_well_founded linarith.comp_source)) : is_compactly_generated (has_well_founded linarith.comp_source) := sorry --non-trivial
lemma new_lemma_22904 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring pos)) (finset Type)) : @locally_compact_space.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (canonically_ordered_comm_semiring.{0} pos)) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_22905 (h0 : topological_space (has_append (metric_space linarith.comp_source))) : t0_space (has_append (metric_space linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_22906 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (normed_comm_ring.{0} num) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (normed_comm_ring.{0} num))  := sorry --non-trivial
lemma new_lemma_22907 (h0 : functor.add_const (group (linear_ordered_comm_monoid_with_zero empty)) empty) : @normalizer_condition.{0} (linear_ordered_comm_monoid_with_zero.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (linear_ordered_comm_monoid_with_zero.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_22908 (h0 : filter (linear_ordered_field (option (option (option (option (option ennreal))))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_22909 (h0 : functor.add_const (monoid (has_edist unsigned)) congr_arg_kind) : @monoid.fg.{0} (has_edist.{0} unsigned) (@functor.add_const.run.{0 0} (monoid.{0} (has_edist.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_22910 (h0 : complete_lattice (semigroup (has_add (has_add (finset pos))))) : is_compactly_generated (semigroup (has_add (has_add (finset pos)))) := sorry --non-trivial
lemma new_lemma_22911 (h0 : function.extfun Type (fun (x : Type), Prop)) : zzz_forall (function.extfun_app h0) := sorry --non-trivial
lemma new_lemma_22912 (h0 : topological_space (linear_ordered_comm_ring congr_arg_kind)) : normal_space (linear_ordered_comm_ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_22913 (h0 : prod (with_bot congr_arg_kind) (with_bot congr_arg_kind)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_22914 (h0 : ordered_add_comm_monoid (metric_space empty)) : archimedean (metric_space empty) := sorry --non-trivial
lemma new_lemma_22915 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (simple_graph.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (simple_graph.{0} pos))  := sorry --non-trivial
lemma new_lemma_22916 (h0 : topological_space (has_nndist (has_add (ring (has_add (finset pos)))))) : normal_space (has_nndist (has_add (ring (has_add (finset pos))))) := sorry --non-trivial
lemma new_lemma_22917 (h0 : not (uniform_space (semi_normed_ring fun_info) -> false)) : @complete_space.{0} (semi_normed_ring.{0} fun_info) (@classical.by_contradiction'.{1} (uniform_space.{0} (semi_normed_ring.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_22918 (h0 : topological_space (has_neg (comm_group unsigned))) : sequential_space (has_neg (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_22919 (h1 : not (topological_space (has_union empty) -> false)) : @t0_space.{0} (has_union.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (has_union.{0} empty)) h1)  := sorry --non-trivial
lemma new_lemma_22920 (h0 : topological_space (ordered_comm_monoid (finset (finset (has_pos_part Type))))) : irreducible_space (ordered_comm_monoid (finset (finset (has_pos_part Type)))) := sorry --non-trivial
lemma new_lemma_22921 (h0 : semiring fun_info) (h2 : fun_info) (h3 : part fun_info) (h4 : decidable (part.dom h3)) : even (part.get_or_else h3 h2) := sorry --non-trivial
lemma new_lemma_22922 (h0 : group (option congr_arg_kind)) : is_simple_group (option congr_arg_kind) := sorry --non-trivial
lemma new_lemma_22923 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (canonically_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type ring.{0} h0 (canonically_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_22924 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (dlist.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (dlist.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_22925 (h0 : function.extfun (finset (Type -> Type) -> Prop) (function.extfun (finset (Type -> Type)))) : @is_add_cyclic.{0} (has_top.{0} num) (@function.extfun_app.{2 1} Type add_group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) add_group.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) add_group.{0}) (@function.extfun_app.{2 0} (finset.{1} (Type → Type) → Prop) (function.extfun.{2 0} (finset.{1} (Type → Type))) h0 (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) add_group.{0})) (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_top.{0} num))  := sorry --non-trivial
lemma new_lemma_22926 (h0 : functor.add_const (function.extfun Type group) (finset pos)) : @normalizer_condition.{0} (has_Inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) (finset.{0} pos) h0) (has_Inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_22927 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (@id.{2} Type unsigned) (@function.extfun_app.{2 1} Type add_group.{0} h0 (@id.{2} Type unsigned))  := sorry --non-trivial
lemma new_lemma_22928 (h0 : functor.add_const (function.extfun Type ring) pos) : @strong_rank_condition.{0} (has_nndist.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) pos h0) (has_nndist.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_22929 (h3 : add_group (has_div to_additive.value_type)) : is_add_cyclic (has_div to_additive.value_type) := sorry --non-trivial
lemma new_lemma_22930 (h0 : functor.add_const (monoid (normed_comm_ring linarith.comp)) (finset environment.implicit_infer_kind)) : @monoid.fg.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (monoid.{0} (normed_comm_ring.{0} linarith.comp)) (finset.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_22931 (h0 : function.extfun Type group) : @group.fg.{0} (has_nnnorm.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} h0 (has_nnnorm.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_22932 (h0 : topological_space (comm_group (has_neg linarith.comp))) : t1_space (comm_group (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_22933 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (generalized_boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (generalized_boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_22934 (h0 : complete_lattice (linear_ordered_field char)) : is_compactly_generated (linear_ordered_field char) := sorry --non-trivial
lemma new_lemma_22935 (h1 : complete_lattice (has_nnnorm (random_gen string_imp))) : complete_lattice.is_Sup_finite_compact (has_nnnorm (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_22936 (h0 : uniform_space fun_info) (h1 : group fun_info) : uniform_group fun_info := sorry --non-trivial
lemma new_lemma_22937 (h0 : function.extfun nat fin) : @preirreducible_space.{0} (ordered_comm_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_monoid.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_22938 (h0 : functor.comp topological_space has_add pos) : @regular_space.{0} (has_add.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} has_add.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_22939 (h0 : list (finset (option pos))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_22940 (h0 : not (function.extfun Type topological_space -> false)) : @totally_disconnected_space.{0} (semiring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_22941 (h1 : semiring (mul_one_class linarith.ineq)) (h2 : ideal (mul_one_class linarith.ineq)) : ideal.is_prime h2 := sorry --non-trivial
lemma new_lemma_22942 (h0 : topological_space (add_cancel_monoid ennreal)) : topological_space.separable_space (add_cancel_monoid ennreal) := sorry --non-trivial
lemma new_lemma_22943 (h0 : not (function.extfun Type topological_space -> false)) : @preirreducible_space.{0} (add_right_cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (add_right_cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_22944 (h0 : topological_space (has_sub (semiring congr_arg_kind))) : preirreducible_space (has_sub (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_22945 (h0 : function.extfun (finset Type) (has_mem.mem (has_one empty))) : @normalizer_condition.{0} (has_one.{0} empty) (@finset.pi.empty.{1 0} Type group.{0} (has_one.{0} empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_one.{0} empty)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_22946 (h0 : set (string.iterator_imp -> enat)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_22947 (h0 : functor.add_const (function.extfun Type ordered_add_comm_monoid) linarith.comp) : @archimedean.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_add_comm_monoid.{0}) linarith.comp h0) (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_22948 (h0 : functor.add_const (topological_space (ordered_cancel_add_comm_monoid empty)) unsigned) : @totally_disconnected_space.{0} (ordered_cancel_add_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_cancel_add_comm_monoid.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_22949 (h0 : functor.add_const (ring pos) name) : @is_principal_ideal_ring.{0} pos (@functor.add_const.run.{0 0} (ring.{0} pos) name h0)  := sorry --non-trivial
lemma new_lemma_22950 (h0 : functor.add_const (topological_space (complete_distrib_lattice pos)) linarith.comp) : @totally_disconnected_space.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_22951 (h0 : functor.add_const (ring (add_cancel_monoid Type)) (mul_one_class linarith.comp)) : @rank_condition.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (add_cancel_monoid.{1} Type)) (mul_one_class.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_22952 (h0 : functor.add_const (topological_space (normed_comm_ring unsigned)) Type) : @topological_space.separable_space.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (normed_comm_ring.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_22953 (h0 : functor.add_const (topological_space (finset linarith.comp)) Type) : @totally_separated_space.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (finset.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_22954 (h0 : uniform_space (semi_normed_comm_ring (has_ssubset (has_ssubset enat)))) : complete_space (semi_normed_comm_ring (has_ssubset (has_ssubset enat))) := sorry --non-trivial
lemma new_lemma_22955 (h0 : has_mem.mem num has_emptyc.emptyc) : @irreducible_space.{0} num (@finset.pi.empty.{1 0} Type topological_space.{0} num h0)  := sorry --non-trivial
lemma new_lemma_22956 (h0 : set (prod (option ennreal) (option ennreal))) (h1 : prod (option ennreal) (option ennreal)) : symmetrize_rel h0 h1 := sorry --non-trivial
lemma new_lemma_22957 (h0 : add_group (add_cancel_monoid ennreal)) : is_add_cyclic (add_cancel_monoid ennreal) := sorry --non-trivial
lemma new_lemma_22958 (h0 : functor.add_const (function.extfun Type ring) pos) : @is_principal_ideal_ring.{0} (canonically_ordered_comm_semiring.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) pos h0) (canonically_ordered_comm_semiring.{0} pos))  := sorry --non-trivial
lemma new_lemma_22959 (h0 : not (add_group (comm_ring reducibility_hints) -> false)) : @is_add_cyclic.{0} (comm_ring.{0} reducibility_hints) (@classical.by_contradiction'.{1} (add_group.{0} (comm_ring.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_22960 (h0 : functor.add_const (function.extfun Type filter) unsigned) : filter.ne_bot (function.extfun_app (functor.add_const.run h0) (option num)) := sorry --non-trivial
lemma new_lemma_22961 (h0 : not (topological_space (dlist to_additive.value_type) -> false)) : @totally_disconnected_space.{0} (dlist.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (dlist.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_22962 (h0 : filter (uniform_space (semiring unsigned))) : @complete_space.{0} (semiring.{0} unsigned) (@filter.Limsup.{0} (uniform_space.{0} (semiring.{0} unsigned)) (@complete_lattice.to_conditionally_complete_lattice.{0} (uniform_space.{0} (semiring.{0} unsigned)) (@uniform_space.complete_lattice.{0} (semiring.{0} unsigned))) h0)  := sorry --non-trivial
lemma new_lemma_22963 (h0 : ring (has_neg (boolean_algebra.core name))) : is_principal_ideal_ring (has_neg (boolean_algebra.core name)) := sorry --non-trivial
lemma new_lemma_22964 (h0 : has_mem.mem (id empty) has_emptyc.emptyc) : @totally_disconnected_space.{0} (@id.{2} Type empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (@id.{2} Type empty) h0)  := sorry --non-trivial
lemma new_lemma_22965 (h0 : not (add_group (has_emptyc linarith.comp_source) -> false)) : @is_add_cyclic.{0} (has_emptyc.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (add_group.{0} (has_emptyc.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_22966 (h0 : topological_space (add_comm_monoid (add_comm_monoid Type))) : totally_disconnected_space (add_comm_monoid (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_22967 (h0 : functor.add_const (complete_lattice (comm_group pos)) linarith.comp) : @complete_lattice.is_Sup_finite_compact.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (comm_group.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_22968 (h0 : group (canonically_ordered_monoid Type)) : is_simple_group (canonically_ordered_monoid Type) := sorry --non-trivial
lemma new_lemma_22969 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (complete_distrib_lattice.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_22970 (h0 : function.extfun Type (functor.add_const Prop)) : functor.add_const.run (function.extfun_app h0 (has_neg_part unsigned)) := sorry --non-trivial
lemma new_lemma_22971 (h0 : filter (has_to_string (option pos))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_22972 (h0 : monoid (id linarith.comp_source)) : monoid.fg (id linarith.comp_source) := sorry --non-trivial
lemma new_lemma_22973 (h0 : topological_space (canonically_linear_ordered_monoid (has_Inf real))) : preirreducible_space (canonically_linear_ordered_monoid (has_Inf real)) := sorry --non-trivial
lemma new_lemma_22974 (h1 : topological_space (has_inv (has_inv (has_inv linarith.comp_source)))) : totally_disconnected_space (has_inv (has_inv (has_inv linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_22975 (h0 : function.extfun Type ring) : @rank_condition.{0} (non_assoc_semiring.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (non_assoc_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_22976 (h0 : topological_space (linear_ordered_comm_group num)) : t1_space (linear_ordered_comm_group num) := sorry --non-trivial
lemma new_lemma_22977 (h0 : ring (ring (has_neg_part name))) : is_domain (ring (has_neg_part name)) := sorry --non-trivial
lemma new_lemma_22978 (h0 : list (semi_normed_comm_ring (has_top (random_gen (random_gen linarith.ineq))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_22979 (h0 : topological_space (has_add unsigned)) : sequential_space (has_add unsigned) := sorry --non-trivial
lemma new_lemma_22980 (h0 : group (simple_graph (has_neg Type))) : normalizer_condition (simple_graph (has_neg Type)) := sorry --non-trivial
lemma new_lemma_22981 (h0 : not (function.extfun (finset (Type -> Type)) (has_mem.mem complete_lattice) -> false)) : @is_compactly_generated.{0} (has_norm.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) complete_lattice.{0}) (@classical.by_contradiction'.{0} (function.extfun.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) complete_lattice.{0})) h0) (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_norm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_22982 (h0 : topological_space (has_inv (has_ssubset string_imp))) : t0_space (has_inv (has_ssubset string_imp)) := sorry --non-trivial
lemma new_lemma_22983 (h0 : uniform_space (add_comm_monoid (option (option name)))) : complete_space (add_comm_monoid (option (option name))) := sorry --non-trivial
lemma new_lemma_22984 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} num (@function.extfun_app.{2 1} Type topological_space.{0} h0 num)  := sorry --non-trivial
lemma new_lemma_22985 (h0 : complete_lattice (has_to_string (has_to_string pos))) : is_compactly_generated (has_to_string (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_22986 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (normed_lattice_add_comm_group.{0} real) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (normed_lattice_add_comm_group.{0} real))  := sorry --non-trivial
lemma new_lemma_22987 (h0 : complete_lattice (as_linear_order empty)) : complete_lattice.is_Sup_finite_compact (as_linear_order empty) := sorry --non-trivial
lemma new_lemma_22988 (h0 : topological_space (group_with_zero (has_to_string (has_to_string congr_arg_kind)))) : totally_separated_space (group_with_zero (has_to_string (has_to_string congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_22989 (h0 : function.extfun nat fin) : @is_compactly_generated.{0} (has_bot.{0} linarith.comp) (@matrix.vec_empty.{0} (complete_lattice.{0} (has_bot.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_22990 (h0 : semiring (add_cancel_monoid (option empty))) : is_noetherian_ring (add_cancel_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_22991 (h0 : complete_lattice (has_bot (has_Inf real))) : is_compactly_generated (has_bot (has_Inf real)) := sorry --non-trivial
lemma new_lemma_22992 (h1 : set (linarith.ineq -> enat)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_22993 (h0 : functor.add_const (ring (canonically_ordered_comm_semiring Type)) (has_neg (ring Type))) : @is_domain.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.add_const.run.{1 1} (ring.{1} (canonically_ordered_comm_semiring.{1} Type)) (has_neg.{1} (ring.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_22994 (h0 : ordered_add_comm_monoid (ordered_comm_ring Type)) : archimedean (ordered_comm_ring Type) := sorry --non-trivial
lemma new_lemma_22995 (h0 : list (linear_ordered_add_comm_group (normed_group (has_top (has_norm (has_ssubset to_additive.value_type)))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_22996 (h0 : function.extfun nat fin) : @monoid.fg.{0} (ordered_comm_ring.{0} real) (@function.extfun_app.{2 1} Type monoid.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type monoid.{0}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (ordered_comm_ring.{0} real))  := sorry --non-trivial
lemma new_lemma_22997 (h0 : functor.add_const (uniform_space (has_add linarith.comp)) (has_add name)) : @separated_space.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_add.{0} linarith.comp)) (has_add.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_22998 (h0 : complete_lattice (linear_ordered_semiring (semiring fun_info))) : complete_lattice.is_Sup_finite_compact (linear_ordered_semiring (semiring fun_info)) := sorry --non-trivial
lemma new_lemma_22999 (h0 : topological_space (sub_neg_monoid (finset (has_Inf (has_nndist linarith.comp))))) : loc_path_connected_space (sub_neg_monoid (finset (has_Inf (has_nndist linarith.comp)))) := sorry --non-trivial
lemma new_lemma_23000 (h0 : functor.add_const (finset (preorder empty)) (option empty)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_23001 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_top.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (has_top.{0} empty))  := sorry --non-trivial
lemma new_lemma_23002 (h0 : topological_space (topological_space (has_compl (has_nnnorm reducibility_hints)))) : t0_space (topological_space (has_compl (has_nnnorm reducibility_hints))) := sorry --non-trivial
lemma new_lemma_23003 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (canonically_ordered_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (canonically_ordered_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_23004 (h0 h1 : Prop) : iff h0 h1 := sorry --non-trivial
lemma new_lemma_23005 (h0 : topological_space (encodable (comm_ring fun_info))) : totally_disconnected_space (encodable (comm_ring fun_info)) := sorry --non-trivial
lemma new_lemma_23006 (h0 : topological_space (linear_ordered_comm_ring (has_norm (semiring num)))) : discrete_topology (linear_ordered_comm_ring (has_norm (semiring num))) := sorry --non-trivial
lemma new_lemma_23007 (h0 : complete_lattice (ring (option (option unsigned)))) : is_atomistic (ring (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_23008 (h0 : topological_space (cancel_monoid (add_comm_monoid (has_add environment.implicit_infer_kind)))) : normal_space (cancel_monoid (add_comm_monoid (has_add environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_23009 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_23010 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_nndist.{0} ennreal) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_nndist.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_23011 (h0 : ring (boolean_algebra (add_comm_monoid (add_comm_monoid Type)))) : strong_rank_condition (boolean_algebra (add_comm_monoid (add_comm_monoid Type))) := sorry --non-trivial
lemma new_lemma_23012 (h0 : not (ring (add_cancel_comm_monoid linarith.ineq) -> false)) : @strong_rank_condition.{0} (add_cancel_comm_monoid.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (add_cancel_comm_monoid.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_23013 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (complete_semilattice_Sup.{0} char) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_semilattice_Sup.{0} char))  := sorry --non-trivial
lemma new_lemma_23014 (h1 : ring (denumerable (random_gen char))) : strong_rank_condition (denumerable (random_gen char)) := sorry --non-trivial
lemma new_lemma_23015 (h0 : add_monoid (semigroup congr_arg_kind)) : add_monoid.fg (semigroup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_23016 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (measurable_space.{0} num) (@function.extfun_app.{2 1} Type add_group.{0} h0 (measurable_space.{0} num))  := sorry --non-trivial
lemma new_lemma_23017 (h0 : functor.add_const (uniform_space (has_bot pos)) Type) : @complete_space.{0} (has_bot.{0} pos) (@functor.add_const.run.{0 1} (uniform_space.{0} (has_bot.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_23018 (h0 : filter (finset (finset pos))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_23019 (h0 : cancel_comm_monoid_with_zero (has_one num)) : unique_factorization_monoid (has_one num) := sorry --non-trivial
lemma new_lemma_23020 (h0 : topological_space (has_nndist (has_neg environment.implicit_infer_kind))) : preconnected_space (has_nndist (has_neg environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_23021 (h0 : functor.comp topological_space option pos) : @path_connected_space.{0} (option.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} option.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_23022 (h0 : linear_ordered_comm_group num -> linear_ordered_comm_group num -> Prop) : well_founded h0 := sorry --non-trivial
lemma new_lemma_23023 (h0 : functor.add_const (topological_space (finset name)) (ring (ring pos))) : @totally_separated_space.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} name)) (ring.{0} (ring.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_23024 (h0 : not (add_group (has_compl to_additive.value_type) -> false)) : @is_add_cyclic.{0} (has_compl.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (add_group.{0} (has_compl.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_23025 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (add_cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (add_cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_23026 (h0 : complete_lattice (add_group (semiring empty))) : is_atomistic (add_group (semiring empty)) := sorry --non-trivial
lemma new_lemma_23027 (h0 : has_star ereal) : nonempty (has_trivial_star ereal) := sorry --non-trivial
lemma new_lemma_23028 (h0 : topological_space (finset unsigned)) : normal_space (finset unsigned) := sorry --non-trivial
lemma new_lemma_23029 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @totally_disconnected_space.{1} (has_neg_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (has_neg_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_23030 (h0 : function.extfun (Type 1) topological_space) : @t0_space.{1} (has_pos_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_pos_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_23031 (h0 : add_group (add_left_cancel_monoid linarith.ineq)) : is_add_cyclic (add_left_cancel_monoid linarith.ineq) := sorry --non-trivial
lemma new_lemma_23032 (h0 : functor.add_const (topological_space (add_cancel_monoid name)) pos) : @irreducible_space.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_23033 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (has_pos_part.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_pos_part.{0} name))  := sorry --non-trivial
lemma new_lemma_23034 (h0 : topological_space (cancel_monoid (comm_group name))) : regular_space (cancel_monoid (comm_group name)) := sorry --non-trivial
lemma new_lemma_23035 (h0 : functor.add_const (topological_space (normed_comm_ring linarith.comp)) linarith.comp) : @preconnected_space.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_23036 (h0 : topological_space (id (has_inv fun_info))) : totally_separated_space (id (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_23037 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_nndist.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} empty))  := sorry --non-trivial
lemma new_lemma_23038 (h0 : set (environment.projection_info -> char)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_23039 (h0 : topological_space (normed_group (has_norm linarith.ineq))) : irreducible_space (normed_group (has_norm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_23040 (h0 : group (has_norm (has_norm (has_norm (has_norm (has_norm linarith.comp_source)))))) : is_cyclic (has_norm (has_norm (has_norm (has_norm (has_norm linarith.comp_source))))) := sorry --non-trivial
lemma new_lemma_23041 (h0 : topological_space (is_R_or_C unsigned)) : normal_space (is_R_or_C unsigned) := sorry --non-trivial
lemma new_lemma_23042 (h0 : functor.add_const (ring (normed_comm_ring linarith.comp)) linarith.comp) : @is_principal_ideal_ring.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (normed_comm_ring.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_23043 (h0 : functor.add_const (add_monoid (has_neg Type)) linarith.comp) : @add_monoid.fg.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (add_monoid.{1} (has_neg.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_23044 (h0 : topological_space (left_cancel_semigroup congr_arg_kind)) : t0_space (left_cancel_semigroup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_23045 (h0 : not (topological_space (comm_ring fun_info) -> false)) : @t0_space.{0} (comm_ring.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (comm_ring.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_23046 (h1 : ring (non_unital_non_assoc_semiring string_imp)) : strong_rank_condition (non_unital_non_assoc_semiring string_imp) := sorry --non-trivial
lemma new_lemma_23047 (h1 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_emptyc.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} h1 (has_emptyc.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_23048 (h0 : functor.add_const (ring (has_Sup congr_arg_kind)) unsigned) : @is_principal_ideal_ring.{0} (has_Sup.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ring.{0} (has_Sup.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_23049 (h0 : topological_space (has_to_string char)) : path_connected_space (has_to_string char) := sorry --non-trivial
lemma new_lemma_23050 (h0 : functor.add_const (topological_space (add_cancel_monoid unsigned)) unsigned) : @t0_space.{0} (add_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_23051 (h0 : complete_lattice (mul_zero_class (semiring (semiring congr_arg_kind)))) : is_atomistic (mul_zero_class (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_23052 (h0 : not (function.extfun Type uniform_space -> false)) : @separated_space.{0} (random_gen.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (random_gen.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_23053 (h0 : prod (linear_order empty) (linear_order empty)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_23054 (h0 : topological_space (complete_distrib_lattice (finset linarith.comp))) : t0_space (complete_distrib_lattice (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_23055 (h1 : has_lt (has_compl linarith.comp_source)) : no_max_order (has_compl linarith.comp_source) := sorry --non-trivial
lemma new_lemma_23056 (h0 : has_mem.mem (has_top num) has_emptyc.emptyc) : @group.fg.{0} (has_top.{0} num) (@finset.pi.empty.{1 0} Type group.{0} (has_top.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_23057 (h0 : functor.add_const (ordered_comm_monoid (boolean_algebra.core name)) Type) : @has_exists_mul_of_le.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (boolean_algebra.core.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_23058 (h0 : function.extfun (Type 1) topological_space) : @preconnected_space.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_23059 (h0 : not (uniform_space (topological_space linarith.ineq) -> false)) : @complete_space.{0} (topological_space.{0} linarith.ineq) (@classical.by_contradiction'.{1} (uniform_space.{0} (topological_space.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_23060 (h0 : group (finset pos)) : is_simple_group (finset pos) := sorry --non-trivial
lemma new_lemma_23061 (h0 : add_group (has_add (has_nnnorm fun_info))) : is_add_cyclic (has_add (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_23062 (h0 : group (has_nndist empty)) : normalizer_condition (has_nndist empty) := sorry --non-trivial
lemma new_lemma_23063 (h0 : topological_space (generalized_boolean_algebra Type)) : normal_space (generalized_boolean_algebra Type) := sorry --non-trivial
lemma new_lemma_23064 (h0 : functor.add_const (add_group (add_comm_monoid Type)) Type) : @is_add_cyclic.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 1} (add_group.{1} (add_comm_monoid.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_23065 (h0 : uniform_space (has_bot congr_arg_kind)) : separated_space (has_bot congr_arg_kind) := sorry --non-trivial
lemma new_lemma_23066 (h0 : functor.add_const (function.extfun Type group) name) : @group.fg.{0} (cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) name h0) (cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_23067 (h0 : ring (cancel_monoid (option (option unsigned)))) : is_principal_ideal_ring (cancel_monoid (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_23068 (h0 : topological_space (cancel_monoid (option pos))) : discrete_topology (cancel_monoid (option pos)) := sorry --non-trivial
lemma new_lemma_23069 (h0 : group (option (semiring (semiring (semiring num))))) : group.fg (option (semiring (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_23070 (h0 : not (group (linear_ordered_semiring empty) -> false)) : @group.fg.{0} (linear_ordered_semiring.{0} empty) (@classical.by_contradiction'.{1} (group.{0} (linear_ordered_semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_23071 (h0 : functor.add_const (function.extfun Type semiring) environment.implicit_infer_kind) : @is_noetherian_ring.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type semiring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type semiring.{0}) environment.implicit_infer_kind h0) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_23072 (h0 : complete_lattice (denumerable (has_nnnorm (random_gen fun_info)))) : is_compactly_generated (denumerable (has_nnnorm (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_23073 (h0 : functor.add_const Prop (semiring (semiring num))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_23074 (h0 : topological_space (finset (has_Inf Type))) : sequential_space (finset (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_23075 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_Sup.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (has_Sup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_23076 (h0 : topological_space (normed_group linarith.ineq)) : irreducible_space (normed_group linarith.ineq) := sorry --non-trivial
lemma new_lemma_23077 (h0 : functor.add_const (topological_space (normed_comm_ring linarith.comp)) Type) : @totally_separated_space.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (normed_comm_ring.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_23078 (h2 : ring (mul_one_class reducibility_hints)) : is_domain (mul_one_class reducibility_hints) := sorry --non-trivial
lemma new_lemma_23079 (h0 : complete_lattice (semi_normed_comm_ring (random_gen linarith.comp_source))) : complete_lattice.is_Sup_finite_compact (semi_normed_comm_ring (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_23080 (h0 : filter (with_bot (random_gen (random_gen linarith.ineq)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_23081 (h0 : complete_lattice (has_append (has_nnnorm (has_nnnorm char)))) : complete_lattice.is_Sup_finite_compact (has_append (has_nnnorm (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_23082 (h0 : topological_space (canonically_ordered_add_monoid unsigned)) : t0_space (canonically_ordered_add_monoid unsigned) := sorry --non-trivial
lemma new_lemma_23083 (h0 : functor.add_const (finset (linear_order empty)) empty) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_23084 (h0 : fin has_zero.zero) : @is_atomistic.{0} (ordered_comm_ring.{0} pos) (@matrix.vec_empty.{0} (complete_lattice.{0} (ordered_comm_ring.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_23085 (h1 : topological_space (simple_graph linarith.ineq)) : path_connected_space (simple_graph linarith.ineq) := sorry --non-trivial
lemma new_lemma_23086 (h0 : group (ordered_comm_monoid (finset pos))) : is_cyclic (ordered_comm_monoid (finset pos)) := sorry --non-trivial
lemma new_lemma_23087 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (pseudo_emetric_space.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (pseudo_emetric_space.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_23088 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (has_neg_part.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (has_neg_part.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_23089 (h0 : topological_space (id (has_norm (has_norm empty)))) : locally_compact_space (id (has_norm (has_norm empty))) := sorry --non-trivial
lemma new_lemma_23090 (h2 : ring (has_norm congr_arg_kind)) : is_domain (has_norm congr_arg_kind) := sorry --non-trivial
lemma new_lemma_23091 (h0 : functor.add_const (ordered_comm_monoid (has_Inf pos)) (has_add pos)) : @has_exists_mul_of_le.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_Inf.{0} pos)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_23092 (h0 : group (ordered_comm_monoid (has_neg Type))) : is_cyclic (ordered_comm_monoid (has_neg Type)) := sorry --non-trivial
lemma new_lemma_23093 (h0 : not (topological_space (normed_group to_additive.value_type) -> false)) : @totally_separated_space.{0} (normed_group.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_group.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_23094 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (cancel_monoid (option pos))) := sorry --non-trivial
lemma new_lemma_23095 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} (complete_semilattice_Sup.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (complete_semilattice_Sup.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_23096 (h0 : measurable_space (random_gen (has_norm num))) (h1 : measure_theory.measure (random_gen (has_norm num))) : measure_theory.is_probability_measure h1 := sorry --non-trivial
lemma new_lemma_23097 (h0 : functor.comp uniform_space finset environment.implicit_infer_kind) : @separated_space.{0} (finset.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} uniform_space.{0} finset.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_23098 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} (ordered_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) (ordered_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_23099 (h0 : add_group (finset (option pos))) : is_add_cyclic (finset (option pos)) := sorry --non-trivial
lemma new_lemma_23100 (h0 : function.extfun (finset Type) (has_mem.mem (has_top linarith.comp))) : @totally_disconnected_space.{0} (has_top.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_top.{0} linarith.comp) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_top.{0} linarith.comp)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_23101 (h0 : topological_space (has_inter unsigned)) : preirreducible_space (has_inter unsigned) := sorry --non-trivial
lemma new_lemma_23102 (h0 : group (has_nnnorm (random_gen (has_nnnorm linarith.comp_source)))) : is_cyclic (has_nnnorm (random_gen (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_23103 (h0 : add_group (mul_one_class (has_ssubset (mul_one_class reducibility_hints)))) : is_add_cyclic (mul_one_class (has_ssubset (mul_one_class reducibility_hints))) := sorry --non-trivial
lemma new_lemma_23104 (h0 : fin has_zero.zero) : @rank_condition.{0} (add_comm_monoid.{0} pos) (@matrix.vec_empty.{0} (ring.{0} (add_comm_monoid.{0} pos)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)))  := sorry --non-trivial
lemma new_lemma_23105 (h0 : not (uniform_space (non_unital_non_assoc_semiring string.iterator_imp) -> false)) : @complete_space.{0} (non_unital_non_assoc_semiring.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (uniform_space.{0} (non_unital_non_assoc_semiring.{0} string.iterator_imp)) h0)  := sorry --non-trivial
lemma new_lemma_23106 (h0 : functor.add_const (topological_space (has_nndist name)) pos) : @preirreducible_space.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_23107 (h0 : ring (with_bot (random_gen (has_norm (has_norm (has_norm linarith.comp)))))) : is_domain (with_bot (random_gen (has_norm (has_norm (has_norm linarith.comp))))) := sorry --non-trivial
lemma new_lemma_23108 (h0 : topological_space (has_zero (finset name))) : locally_compact_space (has_zero (finset name)) := sorry --non-trivial
lemma new_lemma_23109 (h0 : complete_lattice (has_top (option num))) : is_compactly_generated (has_top (option num)) := sorry --non-trivial
lemma new_lemma_23110 (h0 : list (has_nndist (has_add Type))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_23111 (h0 : functor.add_const (topological_space (has_zero name)) name) : @regular_space.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_23112 (h0 : complete_lattice (has_bot Type)) : is_atomistic (has_bot Type) := sorry --non-trivial
lemma new_lemma_23113 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_23114 (h0 : not (filter (non_assoc_semiring (semiring (semiring (semiring (semiring congr_arg_kind))))) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_23115 (h0 : topological_space (has_Inf linarith.comp)) : locally_compact_space (has_Inf linarith.comp) := sorry --non-trivial
lemma new_lemma_23116 (h0 : not (function.extfun Type topological_space -> false)) : @totally_disconnected_space.{0} (with_bot.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (with_bot.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_23117 (h0 : functor.comp topological_space comm_group name) : @totally_separated_space.{0} (comm_group.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} comm_group.{0} name h0)  := sorry --non-trivial
lemma new_lemma_23118 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (add_group.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_23119 (h1 : not (group (has_nnnorm char) -> false)) : @is_cyclic.{0} (has_nnnorm.{0} char) (@classical.by_contradiction'.{1} (group.{0} (has_nnnorm.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_23120 (h0 : group (uniform_space reducibility_hints)) : is_cyclic (uniform_space reducibility_hints) := sorry --non-trivial
lemma new_lemma_23121 (h2 : topological_space (semi_normed_ring linarith.comp_source)) : totally_disconnected_space (semi_normed_ring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_23122 (h0 h3 : rat) : rat.le h0 h3 := sorry --non-trivial
lemma new_lemma_23123 (h0 : topological_space (has_neg_part (option (comm_group (option ennreal))))) : preconnected_space (has_neg_part (option (comm_group (option ennreal)))) := sorry --non-trivial
lemma new_lemma_23124 (h0 : filter (has_pos_part (ring Type))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_23125 (h0 : functor.add_const (function.extfun (Type 1) uniform_space) pos) : @separated_space.{1} (comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) uniform_space.{1}) pos h0) (comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_23126 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} auto.case_option (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) auto.case_option)  := sorry --non-trivial
lemma new_lemma_23127 (h0 : functor.add_const (topological_space (comm_group Type)) (has_neg name)) : @preconnected_space.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (comm_group.{1} Type)) (has_neg.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_23128 (h0 : functor.comp topological_space has_to_string environment.implicit_infer_kind) : @totally_separated_space.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} has_to_string.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_23129 (h0 : complete_lattice (comm_semigroup num)) : is_atomistic (comm_semigroup num) := sorry --non-trivial
lemma new_lemma_23130 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (dlist.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (dlist.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_23131 (h0 : measurable_space char) (h1 : has_inf char) : nonempty (has_measurable_inf₂ char) := sorry --non-trivial
lemma new_lemma_23132 (h0 : not (complete_lattice (topological_space linarith.ineq) -> false)) : is_compactly_generated (topological_space linarith.ineq) := sorry --non-trivial
lemma new_lemma_23133 (h1 : has_mem.mem (with_one linarith.comp_source) has_emptyc.emptyc) : @irreducible_space.{0} (with_one.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_one.{0} linarith.comp_source) h1)  := sorry --non-trivial
lemma new_lemma_23134 (h0 : complete_lattice (add_monoid string_imp)) : is_compactly_generated (add_monoid string_imp) := sorry --non-trivial
lemma new_lemma_23135 (h0 : finset (as_linear_order (option num))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_23136 (h0 : ring (has_nndist (finset (finset (has_Inf (finset Type)))))) : is_domain (has_nndist (finset (finset (has_Inf (finset Type))))) := sorry --non-trivial
lemma new_lemma_23137 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (linear_ordered_semiring.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (linear_ordered_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_23138 (h0 : functor.add_const (function.extfun Type ordered_comm_monoid) (finset pos)) : @has_exists_mul_of_le.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) (finset.{0} pos) h0) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_23139 (h0 : functor.add_const (ring (has_pos_part pos)) Type) : @strong_rank_condition.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (has_pos_part.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_23140 (h0 : ring (boolean_algebra pos)) : is_domain (boolean_algebra pos) := sorry --non-trivial
lemma new_lemma_23141 (h0 : functor.add_const (functor.add_const (ring znum) unsigned) (option (option num))) : @rank_condition.{0} znum (@functor.add_const.run.{0 0} (ring.{0} znum) unsigned (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (ring.{0} znum) unsigned) (option.{0} (option.{0} num)) h0))  := sorry --non-trivial
lemma new_lemma_23142 (h0 : ring (generalized_boolean_algebra real)) : rank_condition (generalized_boolean_algebra real) := sorry --non-trivial
lemma new_lemma_23143 (h0 : functor.add_const (complete_lattice ennreal) num) : complete_lattice.is_Sup_finite_compact ennreal := sorry --non-trivial
lemma new_lemma_23144 (h0 : functor.add_const (functor.add_const (filter pos) (has_add pos)) linarith.comp) : filter.ne_bot (functor.add_const.run (functor.add_const.run h0)) := sorry --non-trivial
lemma new_lemma_23145 (h0 : ring (comm_group ennreal)) : is_domain (comm_group ennreal) := sorry --non-trivial
lemma new_lemma_23146 (h1 : add_group (uniform_space string_imp)) : is_add_cyclic (uniform_space string_imp) := sorry --non-trivial
lemma new_lemma_23147 (h0 : has_mem.mem (has_norm linarith.comp_source) has_emptyc.emptyc) : @is_add_cyclic.{0} (has_norm.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type add_group.{0} (has_norm.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_23148 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (comm_group.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_group.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_23149 (h0 : functor.add_const (filter (has_neg unsigned)) linarith.comp) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_23150 (h0 : topological_space (ordered_comm_monoid (has_Inf real))) : locally_compact_space (ordered_comm_monoid (has_Inf real)) := sorry --non-trivial
lemma new_lemma_23151 (h1 : ring (fintype (random_gen char))) : rank_condition (fintype (random_gen char)) := sorry --non-trivial
lemma new_lemma_23152 (h0 : uniform_space (has_nndist (has_neg linarith.comp))) : complete_space (has_nndist (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_23153 (h0 : list (has_to_string Type)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_23154 (h0 : not (function.extfun Type group -> false)) : @normalizer_condition.{0} (@id.{2} Type linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (@id.{2} Type linarith.comp))  := sorry --non-trivial
lemma new_lemma_23155 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_23156 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (has_zero.{0} name) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (has_zero.{0} name))  := sorry --non-trivial
lemma new_lemma_23157 (h0 : functor.add_const (functor.comp semiring has_to_string Type) environment.implicit_infer_kind) : @is_noetherian_ring.{1} (has_to_string.{1} Type) (@functor.comp.run.{1 1 1} semiring.{1} has_to_string.{1} Type (@functor.add_const.run.{1 0} (functor.comp.{1 1 1} semiring.{1} has_to_string.{1} Type) environment.implicit_infer_kind h0))  := sorry --non-trivial
lemma new_lemma_23158 (h0 : function.extfun nat fin) : @t0_space.{0} (semiring.{0} (semiring.{0} num)) (@matrix.vec_empty.{0} (topological_space.{0} (semiring.{0} (semiring.{0} num))) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_23159 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (has_star.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_star.{0} empty))  := sorry --non-trivial
lemma new_lemma_23160 (h0 : group (with_one (random_gen (has_inv to_additive.value_type)))) : is_cyclic (with_one (random_gen (has_inv to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_23161 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (option.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (option.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_23162 (h0 : complete_lattice (boolean_algebra linarith.comp)) : is_atomistic (boolean_algebra linarith.comp) := sorry --non-trivial
lemma new_lemma_23163 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_23164 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @regular_space.{0} (comm_group.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_23165 (h0 : semiring (has_Inf linarith.comp)) : is_noetherian_ring (has_Inf linarith.comp) := sorry --non-trivial
lemma new_lemma_23166 (h0 : complete_lattice (add_comm_monoid environment.implicit_infer_kind)) : complete_lattice.is_Sup_finite_compact (add_comm_monoid environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_23167 (h0 : topological_space (bin_tree empty)) : t0_space (bin_tree empty) := sorry --non-trivial
lemma new_lemma_23168 (h0 : topological_space (has_to_string (has_to_string Type))) : topological_space.separable_space (has_to_string (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_23169 (h0 : topological_space (add_comm_semigroup ereal)) (h1 : preorder (add_comm_semigroup ereal)) : compact_Icc_space (add_comm_semigroup ereal) := sorry --non-trivial
lemma new_lemma_23170 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @totally_disconnected_space.{0} (normed_lattice_add_comm_group.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (normed_lattice_add_comm_group.{0} pos)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_23171 (h0 : cancel_comm_monoid_with_zero (has_inter (option empty))) : unique_factorization_monoid (has_inter (option empty)) := sorry --non-trivial
lemma new_lemma_23172 (h0 : add_group (add_comm_semigroup (mul_one_class string.iterator_imp))) : is_add_cyclic (add_comm_semigroup (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_23173 (h0 : functor.add_const (topological_space (comm_group environment.implicit_infer_kind)) name) : @normal_space.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_23174 (h0 : functor.add_const (ring (non_assoc_semiring empty)) (option unsigned)) : @is_domain.{0} (non_assoc_semiring.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (non_assoc_semiring.{0} empty)) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_23175 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (zmod std.prec.arrow) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (zmod std.prec.arrow))  := sorry --non-trivial
lemma new_lemma_23176 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_emptyc.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_emptyc.{0} empty))  := sorry --non-trivial
lemma new_lemma_23177 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @path_connected_space.{0} (complete_distrib_lattice.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (complete_distrib_lattice.{0} real)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_23178 (h0 : add_monoid empty) (h1 : not (topological_space (add_units empty) -> false)) : @discrete_topology.{0} (@add_units.{0} empty h0) (@classical.by_contradiction'.{1} (topological_space.{0} (@add_units.{0} empty h0)) h1)  := sorry --non-trivial
lemma new_lemma_23179 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (with_one.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (with_one.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_23180 (h0 : fin has_zero.zero) : @t1_space.{1} (complete_distrib_lattice.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (complete_distrib_lattice.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_23181 (h0 : has_mem.mem (id linarith.comp) has_emptyc.emptyc) : @rank_condition.{0} (@id.{2} Type linarith.comp) (@finset.pi.empty.{1 0} Type ring.{0} (@id.{2} Type linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_23182 (h0 : not (add_monoid (linear_ordered_comm_ring empty) -> false)) : @add_monoid.fg.{0} (linear_ordered_comm_ring.{0} empty) (@classical.by_contradiction'.{1} (add_monoid.{0} (linear_ordered_comm_ring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_23183 (h0 : functor.add_const (function.extfun Type uniform_space) name) : @separated_space.{0} (comm_group.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) name h0) (comm_group.{0} name))  := sorry --non-trivial
lemma new_lemma_23184 (h0 : functor.add_const (functor.add_const (add_monoid Type) environment.implicit_infer_kind) Type) : @add_monoid.fg.{1} Type (@functor.add_const.run.{1 0} (add_monoid.{1} Type) environment.implicit_infer_kind (@functor.add_const.run.{1 1} (functor.add_const.{1 0} (add_monoid.{1} Type) environment.implicit_infer_kind) Type h0))  := sorry --non-trivial
lemma new_lemma_23185 (h0 : group (generalized_boolean_algebra (has_Inf real))) : normalizer_condition (generalized_boolean_algebra (has_Inf real)) := sorry --non-trivial
lemma new_lemma_23186 (h0 : not (complete_lattice (plift empty) -> false)) : @is_atomistic.{1} (plift.{1} empty) (@classical.by_contradiction'.{2} (complete_lattice.{1} (plift.{1} empty)) h0)  := sorry --non-trivial
lemma new_lemma_23187 (h0 : add_monoid (add_group empty)) : add_monoid.fg (add_group empty) := sorry --non-trivial
lemma new_lemma_23188 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (comm_group.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (comm_group.{0} name))  := sorry --non-trivial
lemma new_lemma_23189 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (normed_comm_ring.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (normed_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_23190 (h1 : filter (has_inner fun_info fun_info)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_23191 (h1 : ring (uniform_space linarith.ineq)) : strong_rank_condition (uniform_space linarith.ineq) := sorry --non-trivial
lemma new_lemma_23192 (h0 : topological_space (boolean_algebra.core (has_to_string pos))) : t1_space (boolean_algebra.core (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_23193 (h0 : add_monoid (complete_distrib_lattice real)) : add_monoid.fg (complete_distrib_lattice real) := sorry --non-trivial
lemma new_lemma_23194 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (semigroup.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_23195 (h0 : group (ring (has_neg_part (has_neg_part (has_neg Type))))) : is_cyclic (ring (has_neg_part (has_neg_part (has_neg Type)))) := sorry --non-trivial
lemma new_lemma_23196 (h0 : functor.add_const (topological_space (normed_comm_ring unsigned)) pos) : @locally_compact_space.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_23197 (h0 : functor.add_const (topological_space (ring pos)) name) : @regular_space.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_23198 (h0 : list (has_top string_imp)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_23199 (h0 : topological_space (has_zero enat)) : totally_disconnected_space (has_zero enat) := sorry --non-trivial
lemma new_lemma_23200 (h0 : ring (has_pos_part (sub_neg_monoid (has_add (has_pos_part (has_Inf real)))))) : is_domain (has_pos_part (sub_neg_monoid (has_add (has_pos_part (has_Inf real))))) := sorry --non-trivial
lemma new_lemma_23201 (h0 : complete_lattice (has_norm (has_top num))) : complete_lattice.is_Sup_finite_compact (has_norm (has_top num)) := sorry --non-trivial
lemma new_lemma_23202 (h0 : group char) : group.fg char := sorry --non-trivial
lemma new_lemma_23203 (h0 : ring (boolean_algebra Type)) : is_principal_ideal_ring (boolean_algebra Type) := sorry --non-trivial
lemma new_lemma_23204 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_emptyc.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_emptyc.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_23205 (h0 : complete_lattice (has_ssubset (mul_one_class linarith.comp_source))) : is_compactly_generated (has_ssubset (mul_one_class linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_23206 (h0 : functor.add_const Prop (has_one unsigned)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_23207 (h0 : group (linear_ordered_semiring (has_norm congr_arg_kind))) : normalizer_condition (linear_ordered_semiring (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_23208 (h0 : functor.comp ring has_append (random_gen (has_nnnorm (has_nnnorm (has_nnnorm linarith.comp_source))))) : @rank_condition.{0} (has_append.{0} (random_gen.{0} (has_nnnorm.{0} (has_nnnorm.{0} (has_nnnorm.{0} linarith.comp_source))))) (@functor.comp.run.{0 0 0} ring.{0} has_append.{0} (random_gen.{0} (has_nnnorm.{0} (has_nnnorm.{0} (has_nnnorm.{0} linarith.comp_source)))) h0)  := sorry --non-trivial
lemma new_lemma_23209 (h0 : functor.add_const (function.extfun Type uniform_space) name) : @separated_space.{0} (has_pos_part.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) name h0) (has_pos_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_23210 (h0 : function.extfun Type group) : @group.fg.{0} (complete_semilattice_Sup.{0} char) (@function.extfun_app.{2 1} Type group.{0} h0 (complete_semilattice_Sup.{0} char))  := sorry --non-trivial
lemma new_lemma_23211 (h0 : functor.add_const (ordered_add_comm_monoid (filter empty)) empty) : @archimedean.{0} (filter.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (filter.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_23212 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @add_monoid.fg.{1} (has_pos_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_monoid.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 add_monoid.{1}) (has_pos_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_23213 (h0 : ring (boolean_algebra.core (ring (has_to_string name)))) : is_principal_ideal_ring (boolean_algebra.core (ring (has_to_string name))) := sorry --non-trivial
lemma new_lemma_23214 (h0 : topological_space (simple_graph (ring (has_add name)))) : locally_compact_space (simple_graph (ring (has_add name))) := sorry --non-trivial
lemma new_lemma_23215 (h0 : topological_space (non_assoc_semiring (option empty))) : locally_compact_space (non_assoc_semiring (option empty)) := sorry --non-trivial
lemma new_lemma_23216 (h0 : group (has_add num)) : is_simple_group (has_add num) := sorry --non-trivial
lemma new_lemma_23217 (h0 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} (has_top.{0} num) (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h0) (has_top.{0} num))  := sorry --non-trivial
lemma new_lemma_23218 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (finset.{0} (has_neg_part.{0} name)) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (finset.{0} (has_neg_part.{0} name)))  := sorry --non-trivial
lemma new_lemma_23219 (h0 : nnreal -> nnreal -> Prop) : is_trans nnreal h0 := sorry --non-trivial
lemma new_lemma_23220 (h0 : ring (preorder num)) : strong_rank_condition (preorder num) := sorry --non-trivial
lemma new_lemma_23221 (h0 : add_group (monoid (option empty))) : is_add_cyclic (monoid (option empty)) := sorry --non-trivial
lemma new_lemma_23222 (h1 : ring (denumerable (has_ssubset (has_ssubset (random_gen linarith.comp_source))))) : is_domain (denumerable (has_ssubset (has_ssubset (random_gen linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_23223 (h0 : topological_space (cancel_monoid (boolean_algebra.core environment.implicit_infer_kind))) : normal_space (cancel_monoid (boolean_algebra.core environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_23224 (h0 : fin has_zero.zero) : @add_monoid.fg.{0} (canonically_ordered_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (add_monoid.{0} (canonically_ordered_monoid.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_23225 (h0 : topological_space (has_Inf (finset linarith.comp))) : discrete_topology (has_Inf (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_23226 (h0 : functor.add_const (topological_space (add_comm_monoid pos)) Type) : @topological_space.separable_space.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (add_comm_monoid.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_23227 (h0 : group (has_emptyc (with_bot linarith.comp_source))) : group.fg (has_emptyc (with_bot linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_23228 (h0 : semiring (has_to_string (ring (has_Inf (has_neg name))))) : is_noetherian_ring (has_to_string (ring (has_Inf (has_neg name)))) := sorry --non-trivial
lemma new_lemma_23229 (h1 : ring (nondiscrete_normed_field std_gen)) : is_domain (nondiscrete_normed_field std_gen) := sorry --non-trivial
lemma new_lemma_23230 (h0 : add_group (comm_semigroup (has_Inf real))) : is_add_cyclic (comm_semigroup (has_Inf real)) := sorry --non-trivial
lemma new_lemma_23231 (h0 : complete_lattice (has_compl (normed_field std_gen))) : is_compactly_generated (has_compl (normed_field std_gen)) := sorry --non-trivial
lemma new_lemma_23232 (h0 : group (semiring (has_inv to_additive.value_type))) : normalizer_condition (semiring (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_23233 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_pos_part.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_pos_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_23234 (h0 : ring (distrib (has_nnnorm char))) : is_domain (distrib (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_23235 (h0 h1 : char -> char) : function.commute h0 h1 := sorry --non-trivial
lemma new_lemma_23236 (h0 : functor.add_const (topological_space (boolean_algebra pos)) linarith.comp) : @regular_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_23237 (h0 : ring (cancel_monoid environment.implicit_infer_kind)) : is_principal_ideal_ring (cancel_monoid environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_23238 (h0 : not (topological_space (id num) -> false)) : @totally_disconnected_space.{0} (@id.{2} Type num) (@classical.by_contradiction'.{1} (topological_space.{0} (@id.{2} Type num)) h0)  := sorry --non-trivial
lemma new_lemma_23239 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (comm_group.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_23240 (h0 : fin has_zero.zero) : @separated_space.{0} (has_pos_part.{0} pos) (@matrix.vec_empty.{0} (uniform_space.{0} (has_pos_part.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_23241 (h0 : functor.add_const (group (add_comm_monoid Type)) pos) : @group.fg.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (add_comm_monoid.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_23242 (h0 : functor.add_const (ring (boolean_algebra Type)) name) : @is_principal_ideal_ring.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (boolean_algebra.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_23243 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (add_cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_23244 (h0 : group (semigroup (option (option (option pos))))) : normalizer_condition (semigroup (option (option (option pos)))) := sorry --non-trivial
lemma new_lemma_23245 (h0 : functor.add_const (function.extfun Type group) (ring Type)) : @group.fg.{0} (has_pos_part.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type group.{0}) (ring.{1} Type) h0) (has_pos_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_23246 (h0 : complete_lattice (with_bot (semiring congr_arg_kind))) : complete_lattice.is_Sup_finite_compact (with_bot (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_23247 (h0 : fin has_zero.zero) : @discrete_topology.{0} (boolean_algebra.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (boolean_algebra.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_23248 (h0 : topological_space (add_cancel_monoid ennreal)) : normal_space (add_cancel_monoid ennreal) := sorry --non-trivial
lemma new_lemma_23249 (h0 : monoid (filter (option unsigned))) : monoid.fg (filter (option unsigned)) := sorry --non-trivial
lemma new_lemma_23250 (h0 : function.extfun (Type 1) topological_space) : @path_connected_space.{1} (boolean_algebra.core.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (boolean_algebra.core.{1} Type))  := sorry --non-trivial
lemma new_lemma_23251 (h0 : ring (has_to_string (finset environment.implicit_infer_kind))) : is_domain (has_to_string (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_23252 (h2 : function.extfun Type topological_space) : @irreducible_space.{0} congr_arg_kind (@function.extfun_app.{2 1} Type topological_space.{0} h2 congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_23253 (h1 : ring (id (random_gen (random_gen to_additive.value_type)))) : rank_condition (id (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_23254 (h0 : topological_space (ring (has_zero (has_neg_part (has_neg_part pos))))) : totally_disconnected_space (ring (has_zero (has_neg_part (has_neg_part pos)))) := sorry --non-trivial
lemma new_lemma_23255 (h0 : function.extfun Type topological_space) : @normal_space.{0} (left_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (left_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_23256 (h0 : functor.add_const (ordered_add_comm_monoid (canonically_ordered_add_monoid empty)) empty) : @archimedean.{0} (canonically_ordered_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (canonically_ordered_add_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_23257 (h0 : linarith.comp -> id linarith.comp) (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (@id.{2} Type linarith.comp) (@topological_space.coinduced.{0 0} linarith.comp (@id.{2} Type linarith.comp) h0 (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 topological_space.{0}) linarith.comp))  := sorry --non-trivial
lemma new_lemma_23258 (h0 : semiring (ring (ring linarith.comp))) : is_noetherian_ring (ring (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_23259 (h1 : set (normed_field (mul_one_class string.iterator_imp))) : set.finite h1 := sorry --non-trivial
lemma new_lemma_23260 (h0 : uniform_space (add_left_cancel_semigroup (add_left_cancel_semigroup unsigned))) : complete_space (add_left_cancel_semigroup (add_left_cancel_semigroup unsigned)) := sorry --non-trivial
lemma new_lemma_23261 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @sequential_space.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_23262 (h0 : filter (normed_group (measurable_space (has_norm (normed_group string_imp))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_23263 (h0 : uniform_space (has_pos_part (boolean_algebra.core (has_Inf linarith.comp)))) : separated_space (has_pos_part (boolean_algebra.core (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_23264 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (metric_space.{0} empty) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (metric_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_23265 (h0 : uniform_space (has_nnnorm reducibility_hints)) : complete_space (has_nnnorm reducibility_hints) := sorry --non-trivial
lemma new_lemma_23266 (h0 : group (boolean_algebra.core (has_add (has_add unsigned)))) : is_simple_group (boolean_algebra.core (has_add (has_add unsigned))) := sorry --non-trivial
lemma new_lemma_23267 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (complete_distrib_lattice.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_distrib_lattice.{0} name))  := sorry --non-trivial
lemma new_lemma_23268 (h0 : has_lt occurrences) : no_max_order occurrences := sorry --non-trivial
lemma new_lemma_23269 (h0 : not (ring (complete_semilattice_Sup linarith.ineq) -> false)) : @is_domain.{0} (complete_semilattice_Sup.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (complete_semilattice_Sup.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_23270 (h0 : filter (linear_ordered_add_comm_group (has_norm (has_norm to_additive.value_type)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_23271 (h0 : has_mem.mem (random_gen unsigned) has_emptyc.emptyc) : @is_atomistic.{0} (random_gen.{0} unsigned) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (random_gen.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_23272 (h0 : functor.add_const (topological_space (ordered_comm_monoid Type)) linarith.comp) : @preirreducible_space.{1} (ordered_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ordered_comm_monoid.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_23273 (h0 : char -> char -> Prop) : is_trichotomous char h0 := sorry --non-trivial
lemma new_lemma_23274 (h0 : uniform_space (random_gen (semiring congr_arg_kind))) : complete_space (random_gen (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_23275 (h0 : uniform_space (non_assoc_semiring num)) : separated_space (non_assoc_semiring num) := sorry --non-trivial
lemma new_lemma_23276 (h0 : ring (has_Inf (has_pos_part (has_Inf (has_add pos))))) : is_principal_ideal_ring (has_Inf (has_pos_part (has_Inf (has_add pos)))) := sorry --non-trivial
lemma new_lemma_23277 (h0 : set (set (normed_field reducibility_hints))) (h1 : set (normed_field reducibility_hints)) : measurable_space.dynkin_system.generate_has h0 h1 := sorry --non-trivial
lemma new_lemma_23278 (h0 : functor.add_const (finset (monoid empty)) empty) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_23279 (h0 : functor.add_const (filter (canonically_ordered_comm_semiring ennreal)) ennreal) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_23280 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (has_nndist.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_23281 (h0 : topological_space (distrib_lattice (random_gen string_imp))) : path_connected_space (distrib_lattice (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_23282 (h0 : cancel_comm_monoid_with_zero (has_neg unsigned)) : unique_factorization_monoid (has_neg unsigned) := sorry --non-trivial
lemma new_lemma_23283 (h0 : finset (normed_comm_ring (finset (lex ennreal)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_23284 (h0 : functor.add_const (topological_space (ring linarith.comp)) linarith.comp) : @t0_space.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_23285 (h0 : filter (semigroup (option name))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_23286 (h0 : functor.add_const (complete_lattice (semiring congr_arg_kind)) empty) : @is_compactly_generated.{0} (semiring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (semiring.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_23287 (h0 : group (option (option (option (option (option (option (option ennreal)))))))) : normalizer_condition (option (option (option (option (option (option (option ennreal))))))) := sorry --non-trivial
lemma new_lemma_23288 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (omega_complete_partial_order.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (omega_complete_partial_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_23289 (h0 : group (add_comm_monoid unsigned)) : group.fg (add_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_23290 (h0 : ring (semi_normed_ring (add_cancel_comm_monoid (has_append reducibility_hints)))) : rank_condition (semi_normed_ring (add_cancel_comm_monoid (has_append reducibility_hints))) := sorry --non-trivial
lemma new_lemma_23291 (h0 : topological_space linarith.comp) : preirreducible_space linarith.comp := sorry --non-trivial
lemma new_lemma_23292 (h0 : not (ring (has_compl fun_info) -> false)) : @is_domain.{0} (has_compl.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (has_compl.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_23293 (h0 : filter (monoid pos)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_23294 (h0 : functor.add_const (topological_space (has_neg pos)) pos) : @path_connected_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_23295 (h0 : functor.add_const (complete_lattice (has_inter ennreal)) ennreal) : @is_atomistic.{0} (has_inter.{0} ennreal) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_inter.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_23296 (h0 : group (metric_space congr_arg_kind)) : is_cyclic (metric_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_23297 (h1 : topological_space (measurable_space string_imp)) : totally_separated_space (measurable_space string_imp) := sorry --non-trivial
lemma new_lemma_23298 (h0 : functor.add_const (complete_lattice (boolean_algebra.core unsigned)) (option (option empty))) : @is_atomistic.{0} (boolean_algebra.core.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (boolean_algebra.core.{0} unsigned)) (option.{0} (option.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_23299 (h0 : uniform_space (pseudo_metric_space (has_neg num))) : complete_space (pseudo_metric_space (has_neg num)) := sorry --non-trivial
lemma new_lemma_23300 (h0 : topological_space (boolean_algebra.core (option pos))) : normal_space (boolean_algebra.core (option pos)) := sorry --non-trivial
lemma new_lemma_23301 (h1 : group (with_one (with_bot (with_bot (has_top linarith.comp_source))))) : normalizer_condition (with_one (with_bot (with_bot (has_top linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_23302 (h0 : has_mem.mem (semiring congr_arg_kind) has_emptyc.emptyc) : @complete_space.{0} (semiring.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type uniform_space.{0} (semiring.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_23303 (h0 : topological_space (canonically_ordered_add_monoid unsigned)) : totally_disconnected_space (canonically_ordered_add_monoid unsigned) := sorry --non-trivial
lemma new_lemma_23304 (h0 : functor.add_const (group (finset linarith.comp)) Type) : @is_simple_group.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 1} (group.{0} (finset.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_23305 (h0 : functor.add_const (topological_space (has_nndist environment.implicit_infer_kind)) linarith.comp) : @sequential_space.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_23306 (h0 : topological_space (has_norm (semiring (has_one (semiring (semiring linarith.comp)))))) : totally_disconnected_space (has_norm (semiring (has_one (semiring (semiring linarith.comp))))) := sorry --non-trivial
lemma new_lemma_23307 (h0 : ring (normed_group (semiring (has_norm fun_info)))) : rank_condition (normed_group (semiring (has_norm fun_info))) := sorry --non-trivial
lemma new_lemma_23308 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (pseudo_metric_space.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (pseudo_metric_space.{0} pos))  := sorry --non-trivial
lemma new_lemma_23309 (h0 : add_group (omega_complete_partial_order unsigned)) : is_add_cyclic (omega_complete_partial_order unsigned) := sorry --non-trivial
lemma new_lemma_23310 (h0 : functor.add_const (complete_lattice (linear_ordered_comm_ring empty)) unsigned) : @is_atomistic.{0} (linear_ordered_comm_ring.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (linear_ordered_comm_ring.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_23311 (h0 : filter (complete_distrib_lattice pos)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_23312 (h0 : functor.add_const (topological_space (preorder empty)) empty) : @normal_space.{0} (preorder.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (preorder.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_23313 (h0 : topological_space (has_Inf name)) : loc_path_connected_space (has_Inf name) := sorry --non-trivial
lemma new_lemma_23314 (h0 : function.extfun (finset Type) (has_mem.mem fun_info)) : @strong_rank_condition.{0} fun_info (@finset.pi.empty.{1 0} Type ring.{0} fun_info (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) fun_info) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_23315 (h0 : ring (boolean_algebra (finset (has_pos_part pos)))) : is_principal_ideal_ring (boolean_algebra (finset (has_pos_part pos))) := sorry --non-trivial
lemma new_lemma_23316 (h0 : list (topological_space (random_gen to_additive.value_type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_23317 (h0 : functor.add_const (ring (complete_linear_order unsigned)) unsigned) : @is_principal_ideal_ring.{0} (complete_linear_order.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (complete_linear_order.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_23318 (h0 : ordered_add_comm_monoid (canonically_ordered_comm_semiring (option (option name)))) : archimedean (canonically_ordered_comm_semiring (option (option name))) := sorry --non-trivial
lemma new_lemma_23319 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (ordered_comm_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_23320 (h1 : function.extfun Type topological_space) : @locally_compact_space.{0} (measurable_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (measurable_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_23321 (h0 : add_monoid (measure_theory.measure_space (semiring (semiring congr_arg_kind)))) : add_monoid.fg (measure_theory.measure_space (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_23322 (h1 : ring (has_inv string_imp)) : is_domain (has_inv string_imp) := sorry --non-trivial
lemma new_lemma_23323 (h1 : monoid (has_inv string_imp)) : monoid.fg (has_inv string_imp) := sorry --non-trivial
lemma new_lemma_23324 (h0 : topological_space (uniform_space (mul_one_class (mul_one_class fun_info)))) (h1 : preorder (uniform_space (mul_one_class (mul_one_class fun_info)))) : order_topology (uniform_space (mul_one_class (mul_one_class fun_info))) := sorry --non-trivial
lemma new_lemma_23325 (h0 : group (denumerable (has_top fun_info))) : is_cyclic (denumerable (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_23326 (h0 : functor.add_const (topological_space (normed_comm_ring Type)) Type) : @sequential_space.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (normed_comm_ring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_23327 (h0 : functor.add_const (complete_lattice (normed_comm_ring Type)) (ring Type)) : @complete_lattice.is_Sup_finite_compact.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 1} (complete_lattice.{1} (normed_comm_ring.{1} Type)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_23328 (h0 : functor.add_const (uniform_space (boolean_algebra.core pos)) linarith.comp) : @complete_space.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (boolean_algebra.core.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_23329 (h0 : functor.add_const (group (has_to_string linarith.comp)) environment.implicit_infer_kind) : @is_simple_group.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (has_to_string.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_23330 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (mul_zero_class.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (mul_zero_class.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_23331 (h0 : functor.add_const (semiring (boolean_algebra linarith.comp)) environment.implicit_infer_kind) : @is_noetherian_ring.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (semiring.{0} (boolean_algebra.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_23332 (h0 : topological_space (normed_comm_ring (has_zero pos))) : loc_path_connected_space (normed_comm_ring (has_zero pos)) := sorry --non-trivial
lemma new_lemma_23333 (h0 : function.extfun Type topological_space) : @regular_space.{0} (cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_23334 (h0 : not (topological_space (random_gen (has_ssubset reducibility_hints)) -> false)) : @path_connected_space.{0} (random_gen.{0} (has_ssubset.{0} reducibility_hints)) (@classical.by_contradiction'.{1} (topological_space.{0} (random_gen.{0} (has_ssubset.{0} reducibility_hints))) h0)  := sorry --non-trivial
lemma new_lemma_23335 (h0 : topological_space (cancel_monoid (has_neg_part (has_add Type)))) : preconnected_space (cancel_monoid (has_neg_part (has_add Type))) := sorry --non-trivial
lemma new_lemma_23336 (h0 : topological_space (metric_space (semiring congr_arg_kind))) : totally_disconnected_space (metric_space (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_23337 (h1 : not (ring (distrib char) -> false)) : @rank_condition.{0} (distrib.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (distrib.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_23338 (h0 : ring (comm_ring (metric_space char))) : is_domain (comm_ring (metric_space char)) := sorry --non-trivial
lemma new_lemma_23339 (h0 : functor.add_const (function.extfun (Type 1) filter) pos) : countable_Inter_filter (function.extfun_app (functor.add_const.run h0) (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_23340 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (partial_order.{0} empty) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (partial_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_23341 (h0 : functor.add_const (list (boolean_algebra.core unsigned)) Type) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_23342 (h0 : monoid (is_R_or_C (option (option empty)))) : monoid.fg (is_R_or_C (option (option empty))) := sorry --non-trivial
lemma new_lemma_23343 (h0 : group (partial_order unsigned)) : group.fg (partial_order unsigned) := sorry --non-trivial
lemma new_lemma_23344 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} (random_gen.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (random_gen.{0} num))  := sorry --non-trivial
lemma new_lemma_23345 (h0 : topological_space (complete_semilattice_Sup congr_arg_kind)) : totally_separated_space (complete_semilattice_Sup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_23346 (h0 : monoid_with_zero (option ennreal) -> monoid_with_zero (option ennreal) -> Prop) : is_symm (monoid_with_zero (option ennreal)) h0 := sorry --non-trivial
lemma new_lemma_23347 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (add_right_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (add_right_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_23348 (h0 : topological_space (cancel_monoid unsigned)) : irreducible_space (cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_23349 (h0 : topological_space (normed_comm_ring (option empty))) : t1_space (normed_comm_ring (option empty)) := sorry --non-trivial
lemma new_lemma_23350 (h0 : not (topological_space (has_one num) -> false)) : @discrete_topology.{0} (has_one.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (has_one.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_23351 (h1 : set (set linarith.comp_source)) : is_countably_spanning h1 := sorry --non-trivial
lemma new_lemma_23352 (h1 : topological_space (normed_field (normed_field linarith.ineq))) : t0_space (normed_field (normed_field linarith.ineq)) := sorry --non-trivial
lemma new_lemma_23353 (h0 : functor.add_const (list (finset pos)) pos) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_23354 (h0 : uniform_space (linear_ordered_comm_ring congr_arg_kind)) : separated_space (linear_ordered_comm_ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_23355 (h1 : decidable_eq (mul_one_class std_gen)) (h2 : equiv.perm (mul_one_class std_gen)) : equiv.perm.is_swap h2 := sorry --non-trivial
lemma new_lemma_23356 (h0 : topological_space (ring (has_add name))) : normal_space (ring (has_add name)) := sorry --non-trivial
lemma new_lemma_23357 (h0 : group (has_pos_part (finset linarith.comp))) : normalizer_condition (has_pos_part (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_23358 (h0 : complete_linear_order (has_top empty) -> complete_linear_order (has_top empty) -> Prop) : is_strict_order (complete_linear_order (has_top empty)) h0 := sorry --non-trivial
lemma new_lemma_23359 (h0 : group (has_sub empty)) : normalizer_condition (has_sub empty) := sorry --non-trivial
lemma new_lemma_23360 (h0 : topological_space (normed_lattice_add_comm_group real)) : regular_space (normed_lattice_add_comm_group real) := sorry --non-trivial
lemma new_lemma_23361 (h0 : topological_space (boolean_algebra (boolean_algebra.core (has_add pos)))) : preconnected_space (boolean_algebra (boolean_algebra.core (has_add pos))) := sorry --non-trivial
lemma new_lemma_23362 (h0 : not (ring (topological_space string_imp) -> false)) : @is_domain.{0} (topological_space.{0} string_imp) (@classical.by_contradiction'.{1} (ring.{0} (topological_space.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_23363 (h0 : function.extfun Type topological_space) : @t0_space.{0} (with_bot.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_bot.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_23364 (h0 : preorder (finset ennreal)) (h1 : topological_space (finset ennreal)) : Inf_convergence_class (finset ennreal) := sorry --non-trivial
lemma new_lemma_23365 (h0 : has_Inf real -> has_Inf real -> Prop) : is_refl (has_Inf real) h0 := sorry --non-trivial
lemma new_lemma_23366 (h0 : ring (has_to_string (has_to_string pos))) : is_principal_ideal_ring (has_to_string (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_23367 (h0 : group (normed_group (random_gen (has_norm fun_info)))) : is_cyclic (normed_group (random_gen (has_norm fun_info))) := sorry --non-trivial
lemma new_lemma_23368 (h0 : functor.add_const (topological_space (normed_comm_ring pos)) environment.implicit_infer_kind) : @loc_path_connected_space.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_23369 (h0 : functor.add_const (topological_space (comm_group name)) name) : @path_connected_space.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_23370 (h1 : add_group (has_compl (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm char)))))) : is_add_cyclic (has_compl (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm char))))) := sorry --non-trivial
lemma new_lemma_23371 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (with_bot.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_bot.{0} num))  := sorry --non-trivial
lemma new_lemma_23372 (h0 : functor.add_const (add_monoid (normed_comm_ring Type)) pos) : @add_monoid.fg.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (add_monoid.{1} (normed_comm_ring.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_23373 (h0 : functor.add_const (topological_space (finset linarith.comp)) Type) : @totally_disconnected_space.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (finset.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_23374 (h0 : complete_lattice (semigroup (semiring (semiring empty)))) : is_compactly_generated (semigroup (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_23375 (h0 : topological_space (has_to_string environment.implicit_infer_kind)) : sequential_space (has_to_string environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_23376 (h0 : function.extfun Type group) : @group.fg.{0} (has_emptyc.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} h0 (has_emptyc.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_23377 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (ordered_comm_group.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (ordered_comm_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_23378 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (bin_tree.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (bin_tree.{0} empty))  := sorry --non-trivial
lemma new_lemma_23379 (h0 : topological_space (has_neg (option (option unsigned)))) : loc_path_connected_space (has_neg (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_23380 (h0 : ring (with_one string_imp)) : is_domain (with_one string_imp) := sorry --non-trivial
lemma new_lemma_23381 (h0 : function.extfun Type group) : @normalizer_condition.{0} (normed_comm_ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (normed_comm_ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_23382 (h0 : ordered_add_comm_monoid (add_comm_monoid (add_comm_monoid (cancel_monoid environment.implicit_infer_kind)))) : archimedean (add_comm_monoid (add_comm_monoid (cancel_monoid environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_23383 (h0 : topological_space (ring (ring Type))) : totally_disconnected_space (ring (ring Type)) := sorry --non-trivial
lemma new_lemma_23384 (h0 : cancel_comm_monoid_with_zero (add_comm_monoid pos)) : unique_factorization_monoid (add_comm_monoid pos) := sorry --non-trivial
lemma new_lemma_23385 (h0 : not (topological_space (has_norm to_additive.value_type) -> false)) : @discrete_topology.{0} (has_norm.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (has_norm.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_23386 (h0 : not (topological_space (add_left_cancel_monoid to_additive.value_type) -> false)) : @totally_disconnected_space.{0} (add_left_cancel_monoid.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (add_left_cancel_monoid.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_23387 (h0 : list (finset (has_neg Type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_23388 (h0 : ring (has_neg (has_add pos))) : is_principal_ideal_ring (has_neg (has_add pos)) := sorry --non-trivial
lemma new_lemma_23389 (h0 : functor.add_const (function.extfun Type ring) Type) : @rank_condition.{0} (comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ring.{0}) Type h0) (comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_23390 (h0 : functor.add_const (ring (ring unsigned)) ennreal) : @is_domain.{0} (ring.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (ring.{0} unsigned)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_23391 (h0 : group (has_add (finset Type))) : group.fg (has_add (finset Type)) := sorry --non-trivial
lemma new_lemma_23392 (h0 : complete_lattice (finset ennreal)) : complete_lattice.is_Sup_finite_compact (finset ennreal) := sorry --non-trivial
lemma new_lemma_23393 (h0 : uniform_space (has_norm (semiring (semiring empty)))) : complete_space (has_norm (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_23394 (h0 : function.extfun (Type 1) list) : list.nodup (function.extfun_app h0 (ordered_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_23395 (h0 : add_group (canonically_ordered_comm_semiring (boolean_algebra.core Type))) : is_add_cyclic (canonically_ordered_comm_semiring (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_23396 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @preconnected_space.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_23397 (h0 : ring (has_top string_imp)) : is_domain (has_top string_imp) := sorry --non-trivial
lemma new_lemma_23398 (h0 : functor.add_const (group (normed_comm_ring Type)) (finset Type)) : @is_simple_group.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 1} (group.{1} (normed_comm_ring.{1} Type)) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_23399 (h0 : topological_space (option (has_top (has_norm (has_norm empty))))) : preirreducible_space (option (has_top (has_norm (has_norm empty)))) := sorry --non-trivial
lemma new_lemma_23400 (h0 : ring (omega_complete_partial_order (option empty))) : is_principal_ideal_ring (omega_complete_partial_order (option empty)) := sorry --non-trivial
lemma new_lemma_23401 (h0 : mul_one_class ereal -> mul_one_class ereal -> Prop) (h1 : set (mul_one_class ereal)) : zorn.chain h0 h1 := sorry --non-trivial
lemma new_lemma_23402 (h0 : has_mem.mem (functor.add_const (topological_space (has_Sup empty))) has_zero.zero) : @normal_space.{0} (has_Sup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Sup.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (has_Sup.{0} empty))) (@multiset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) (functor.add_const.{0 0} (topological_space.{0} (has_Sup.{0} empty))) h0) empty))  := sorry --non-trivial
lemma new_lemma_23403 (h0 : pseudo_metric_space (has_compl (has_lt (mul_one_class char)))) (h1 : monoid (has_compl (has_lt (mul_one_class char)))) : has_lipschitz_mul (has_compl (has_lt (mul_one_class char))) := sorry --non-trivial
lemma new_lemma_23404 (h0 : topological_space (complete_semilattice_Sup (random_gen to_additive.value_type))) : t0_space (complete_semilattice_Sup (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_23405 (h0 : pnat) (h1 : nat) (h2 : fin (nat.succ h1) -> fin has_zero.zero) (h3 : fin h1) : pnat.coprime h0 (id (matrix.vec_empty (matrix.vec_tail h2 h3))) := sorry --non-trivial
lemma new_lemma_23406 (h0 : ring (measurable_space (semiring (semiring num)))) : strong_rank_condition (measurable_space (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_23407 (h0 : group (has_norm fun_info)) : normalizer_condition (has_norm fun_info) := sorry --non-trivial
lemma new_lemma_23408 (h0 : topological_space (ordered_comm_monoid (sub_neg_monoid Type))) : t0_space (ordered_comm_monoid (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_23409 (h0 : functor.add_const (topological_space (option unsigned)) unsigned) : @t1_space.{0} (option.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_23410 (h0 : function.extfun Type (functor.comp add_monoid has_nndist)) : @add_monoid.fg.{0} (has_nndist.{0} ennreal) (@functor.comp.run.{0 0 0} add_monoid.{0} has_nndist.{0} ennreal (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} add_monoid.{0} has_nndist.{0}) h0 ennreal))  := sorry --non-trivial
lemma new_lemma_23411 (h0 : topological_space (id (semiring linarith.comp))) : normal_space (id (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_23412 (h0 : topological_space (linear_ordered_semiring (has_norm congr_arg_kind))) : discrete_topology (linear_ordered_semiring (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_23413 (h0 : filter (has_nndist (option (option empty)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_23414 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (has_top.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_top.{0} empty))  := sorry --non-trivial
lemma new_lemma_23415 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (sub_neg_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (sub_neg_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_23416 (h0 : topological_space (id (random_gen (random_gen linarith.comp_source)))) : locally_compact_space (id (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_23417 (h0 : topological_space (normed_comm_ring empty)) : totally_disconnected_space (normed_comm_ring empty) := sorry --non-trivial
lemma new_lemma_23418 (h0 : complete_lattice (semigroup (has_pos_part pos))) : is_compactly_generated (semigroup (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_23419 (h0 : not (function.extfun Type topological_space -> false)) : @irreducible_space.{0} (has_top.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_top.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_23420 (h0 : topological_space (has_star (semiring (semiring unsigned)))) : locally_compact_space (has_star (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_23421 (h0 : ring (normed_group (semiring linarith.comp))) : strong_rank_condition (normed_group (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_23422 (h0 : monoid (boolean_algebra.core (has_nndist (has_pos_part Type)))) : monoid.fg (boolean_algebra.core (has_nndist (has_pos_part Type))) := sorry --non-trivial
lemma new_lemma_23423 (h0 : ring (semi_normed_ring (mul_one_class to_additive.value_type))) : strong_rank_condition (semi_normed_ring (mul_one_class to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_23424 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (with_bot.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (with_bot.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_23425 (h0 : list (linear_ordered_comm_group Type)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_23426 (h0 : complete_lattice (has_add (ring Type))) : is_compactly_generated (has_add (ring Type)) := sorry --non-trivial
lemma new_lemma_23427 (h0 : topological_space (canonically_ordered_monoid Type)) : regular_space (canonically_ordered_monoid Type) := sorry --non-trivial
lemma new_lemma_23428 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_compactly_generated.{0} (normed_group.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (normed_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_23429 (h1 : has_coe string.iterator_imp Prop) (h2 : string.iterator_imp) : @coe_b.{1 1} string.iterator_imp Prop h1 h2  := sorry --non-trivial
lemma new_lemma_23430 (h0 : functor.add_const (topological_space (comm_group Type)) (boolean_algebra environment.implicit_infer_kind)) : @path_connected_space.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (comm_group.{1} Type)) (boolean_algebra.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_23431 (h0 : functor.add_const (filter (has_neg pos)) pos) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_23432 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (measurable_space.{0} linarith.ineq) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 ring.{0}) (measurable_space.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_23433 (h0 : has_lt (semi_normed_comm_ring (simple_graph (nondiscrete_normed_field string.iterator_imp)))) : no_max_order (semi_normed_comm_ring (simple_graph (nondiscrete_normed_field string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_23434 (h0 : functor.add_const (topological_space (cancel_monoid unsigned)) linarith.comp) : @topological_space.separable_space.{0} (cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_23435 (h0 : monoid (metric_space (semiring congr_arg_kind))) : monoid.fg (metric_space (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_23436 (h0 : functor.add_const (topological_space (has_to_string pos)) Type) : @path_connected_space.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_to_string.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_23437 (h0 : topological_space (has_to_string (has_add (has_add pos)))) : preirreducible_space (has_to_string (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_23438 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} num (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) complete_lattice.{0}) num)  := sorry --non-trivial
lemma new_lemma_23439 (h0 : functor.add_const (finset (finset linarith.comp)) (has_add linarith.comp)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_23440 (h0 : functor.add_const (topological_space (comm_group unsigned)) environment.implicit_infer_kind) : @preirreducible_space.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_23441 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @preirreducible_space.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_23442 (h2 : ring (semi_normed_ring to_additive.value_type)) : is_domain (semi_normed_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_23443 (h0 : topological_space (has_add (has_bot real))) : locally_compact_space (has_add (has_bot real)) := sorry --non-trivial
lemma new_lemma_23444 (h0 : set (non_unital_non_assoc_semiring (mul_one_class enat))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_23445 (h0 : function.extfun Type (functor.add_const (group znum))) : @is_cyclic.{0} znum (@functor.add_const.run.{0 0} (group.{0} znum) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (group.{0} znum)) h0 num))  := sorry --non-trivial
lemma new_lemma_23446 (h0 : group ennreal) : group.fg ennreal := sorry --non-trivial
lemma new_lemma_23447 (h0 : functor.add_const (group (has_bot name)) name) : @group.fg.{0} (has_bot.{0} name) (@functor.add_const.run.{0 0} (group.{0} (has_bot.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_23448 (h0 : monoid (has_neg (normed_comm_ring name))) : monoid.fg (has_neg (normed_comm_ring name)) := sorry --non-trivial
lemma new_lemma_23449 (h0 : functor.add_const (topological_space (has_to_string pos)) (finset (has_neg Type))) : @sequential_space.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_to_string.{0} pos)) (finset.{1} (has_neg.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_23450 (h0 : functor.add_const (uniform_space (non_assoc_semiring empty)) unsigned) : @separated_space.{0} (non_assoc_semiring.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (non_assoc_semiring.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_23451 (h0 : group (add_group (has_union (has_norm linarith.comp)))) : is_cyclic (add_group (has_union (has_norm linarith.comp))) := sorry --non-trivial
lemma new_lemma_23452 (h0 : topological_space (measurable_space.dynkin_system (semiring (semiring empty)))) : totally_disconnected_space (measurable_space.dynkin_system (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_23453 (h0 : filter (canonically_ordered_comm_semiring (has_add pos))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_23454 (h1 : topological_space (add_monoid to_additive.value_type)) : path_connected_space (add_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_23455 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (complete_distrib_lattice real)) := sorry --non-trivial
lemma new_lemma_23456 (h0 : topological_space (canonically_linear_ordered_monoid (has_neg real))) : irreducible_space (canonically_linear_ordered_monoid (has_neg real)) := sorry --non-trivial
lemma new_lemma_23457 (h0 : ring (normed_field (mul_one_class (metric_space char)))) : rank_condition (normed_field (mul_one_class (metric_space char))) := sorry --non-trivial
lemma new_lemma_23458 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (linear_ordered_comm_ring empty)) := sorry --non-trivial
lemma new_lemma_23459 (h1 : has_coe (add_comm_semigroup (mul_one_class enat)) Prop) (h2 : add_comm_semigroup (mul_one_class enat)) : @coe_b.{1 1} (add_comm_semigroup.{0} (mul_one_class.{0} enat)) Prop h1 h2  := sorry --non-trivial
lemma new_lemma_23460 (h0 : ring (with_bot (has_norm unsigned))) : is_domain (with_bot (has_norm unsigned)) := sorry --non-trivial
lemma new_lemma_23461 (h0 : function.extfun (finset Type) (has_mem.mem to_additive.value_type)) : @is_domain.{0} to_additive.value_type (@finset.pi.empty.{1 0} Type ring.{0} to_additive.value_type (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) to_additive.value_type) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_23462 (h0 : functor.add_const (ring (has_Inf Type)) Type) : @is_principal_ideal_ring.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 1} (ring.{1} (has_Inf.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_23463 (h0 : not (function.extfun Type topological_space -> false)) : @irreducible_space.{0} (with_one.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (with_one.{0} num))  := sorry --non-trivial
lemma new_lemma_23464 (h0 : add_group (semigroup (has_neg (has_neg (ring (ring pos)))))) : is_add_cyclic (semigroup (has_neg (has_neg (ring (ring pos))))) := sorry --non-trivial
lemma new_lemma_23465 (h0 : functor.add_const (topological_space (bin_tree unsigned)) congr_arg_kind) : @t1_space.{0} (bin_tree.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (bin_tree.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_23466 (h0 : topological_space (has_norm congr_arg_kind)) : t0_space (has_norm congr_arg_kind) := sorry --non-trivial
lemma new_lemma_23467 (h0 : topological_space (has_append (has_nnnorm char))) : t0_space (has_append (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_23468 (h0 : complete_lattice (add_cancel_monoid linarith.comp)) : is_atomistic (add_cancel_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_23469 (h0 : complete_lattice (finset (finset (finset Type)))) : complete_lattice.is_Sup_finite_compact (finset (finset (finset Type))) := sorry --non-trivial
lemma new_lemma_23470 (h0 : topological_space (measurable_space (has_top linarith.comp_source))) : totally_separated_space (measurable_space (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_23471 (h0 : ordered_add_comm_monoid (has_to_string (option pos))) : archimedean (has_to_string (option pos)) := sorry --non-trivial
lemma new_lemma_23472 (h0 : topological_space (has_norm (has_norm (has_norm (has_norm linarith.comp_source))))) : irreducible_space (has_norm (has_norm (has_norm (has_norm linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_23473 (h0 : topological_space (sub_neg_monoid (has_neg (has_neg (has_neg (has_neg name)))))) : totally_separated_space (sub_neg_monoid (has_neg (has_neg (has_neg (has_neg name))))) := sorry --non-trivial
lemma new_lemma_23474 (h0 : cancel_comm_monoid_with_zero (group_with_zero (has_neg ennreal))) : unique_factorization_monoid (group_with_zero (has_neg ennreal)) := sorry --non-trivial
lemma new_lemma_23475 (h0 : partial_order (add_monoid linarith.comp)) (h1 : order_top (add_monoid linarith.comp)) : is_coatomic (add_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_23476 (h1 : uniform_space (with_zero char)) : complete_space (with_zero char) := sorry --non-trivial
lemma new_lemma_23477 (h0 : uniform_space (with_one (random_gen (random_gen (has_inv (has_inv fun_info)))))) : complete_space (with_one (random_gen (random_gen (has_inv (has_inv fun_info))))) := sorry --non-trivial
lemma new_lemma_23478 (h0 : functor.add_const (topological_space (mul_zero_class Type)) pos) : @locally_compact_space.{1} (mul_zero_class.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (mul_zero_class.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_23479 (h0 : functor.add_const (filter (linear_ordered_comm_ring empty)) num) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_23480 (h0 : topological_space (canonically_ordered_comm_semiring (finset ennreal))) : loc_path_connected_space (canonically_ordered_comm_semiring (finset ennreal)) := sorry --non-trivial
lemma new_lemma_23481 (h0 : topological_space (normed_comm_ring (option unsigned))) : discrete_topology (normed_comm_ring (option unsigned)) := sorry --non-trivial
lemma new_lemma_23482 (h0 : functor.add_const (topological_space (non_assoc_semiring empty)) unsigned) : @normal_space.{0} (non_assoc_semiring.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (non_assoc_semiring.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_23483 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_add.{0} (option.{0} (option.{0} pos))) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} (option.{0} (option.{0} pos))))  := sorry --non-trivial
lemma new_lemma_23484 (h0 : group (option unsigned)) : group.fg (option unsigned) := sorry --non-trivial
lemma new_lemma_23485 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_23486 (h0 : group (has_top (semiring (has_norm empty)))) : normalizer_condition (has_top (semiring (has_norm empty))) := sorry --non-trivial
lemma new_lemma_23487 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (ordered_ring empty)) := sorry --non-trivial
lemma new_lemma_23488 (h0 : topological_space (has_to_string (has_nndist environment.implicit_infer_kind))) : topological_space.separable_space (has_to_string (has_nndist environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_23489 (h0 : not (group (comm_ring linarith.ineq) -> false)) : @is_cyclic.{0} (comm_ring.{0} linarith.ineq) (@classical.by_contradiction'.{1} (group.{0} (comm_ring.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_23490 (h0 : semiring (is_R_or_C (option empty))) : is_noetherian_ring (is_R_or_C (option empty)) := sorry --non-trivial
lemma new_lemma_23491 (h0 : function.extfun Type (functor.add_const (add_monoid (has_star empty)))) : @add_monoid.fg.{0} (has_star.{0} empty) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_star.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (add_monoid.{0} (has_star.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_23492 (h1 : not (add_group (denumerable linarith.ineq) -> false)) : @is_add_cyclic.{0} (denumerable.{0} linarith.ineq) (@classical.by_contradiction'.{1} (add_group.{0} (denumerable.{0} linarith.ineq)) h1)  := sorry --non-trivial
lemma new_lemma_23493 (h0 : semiring (has_nndist (has_add Type))) : is_noetherian_ring (has_nndist (has_add Type)) := sorry --non-trivial
lemma new_lemma_23494 (h0 : functor.add_const (topological_space (finset pos)) (has_pos_part pos)) : @totally_separated_space.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} pos)) (has_pos_part.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_23495 (h0 : uniform_space (measurable_space (has_top fun_info))) : complete_space (measurable_space (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_23496 (h0 : group (has_emptyc (has_top fun_info))) : group.fg (has_emptyc (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_23497 (h0 : filter (ordered_comm_monoid (has_add linarith.comp))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_23498 (h0 : group (complete_semilattice_Sup congr_arg_kind)) : group.fg (complete_semilattice_Sup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_23499 (h0 : topological_space (has_union (has_norm (has_norm empty)))) : locally_compact_space (has_union (has_norm (has_norm empty))) := sorry --non-trivial
lemma new_lemma_23500 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (has_add.{0} real) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_add.{0} real))  := sorry --non-trivial
lemma new_lemma_23501 (h0 : complete_lattice (has_compl (has_ssubset char))) : is_compactly_generated (has_compl (has_ssubset char)) := sorry --non-trivial
lemma new_lemma_23502 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @preirreducible_space.{0} (linear_ordered_comm_ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) topological_space.{0}) (linear_ordered_comm_ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_23503 (h0 : function.extfun nat fin) : @totally_separated_space.{0} (canonically_ordered_monoid.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (canonically_ordered_monoid.{0} pos)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))))  := sorry --non-trivial
lemma new_lemma_23504 (h0 : group (with_bot (semiring (semiring empty)))) : group.fg (with_bot (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_23505 (h0 : uniform_space (has_norm (has_norm (has_norm (has_norm (has_norm num)))))) : separated_space (has_norm (has_norm (has_norm (has_norm (has_norm num))))) := sorry --non-trivial
lemma new_lemma_23506 (h0 h1 : multiset (semi_normed_ring linarith.ineq)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_23507 (h0 : fin has_zero.zero) : @preconnected_space.{0} (ordered_comm_ring.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_ring.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_23508 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (with_bot.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_bot.{0} num))  := sorry --non-trivial
lemma new_lemma_23509 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_inter.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inter.{0} num))  := sorry --non-trivial
lemma new_lemma_23510 (h0 : functor.add_const (topological_space (boolean_algebra.core pos)) pos) : @normal_space.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_23511 (h0 : topological_space (comm_monoid (option (comm_monoid (option unsigned))))) : discrete_topology (comm_monoid (option (comm_monoid (option unsigned)))) := sorry --non-trivial
lemma new_lemma_23512 (h0 : add_group (measurable_space.dynkin_system (has_norm linarith.comp))) : is_add_cyclic (measurable_space.dynkin_system (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_23513 (h0 : group (has_nndist (has_add (has_add pos)))) : normalizer_condition (has_nndist (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_23514 (h1 : set (string.iterator_imp -> add_comm_semigroup linarith.ineq)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_23515 (h0 : add_monoid (has_top linarith.ineq)) (h1 : monoid (add_units (has_top linarith.ineq))) : monoid.fg (add_units (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_23516 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (complete_distrib_lattice num)) := sorry --non-trivial
lemma new_lemma_23517 (h0 : complete_lattice (complete_distrib_lattice (has_add environment.implicit_infer_kind))) : is_atomistic (complete_distrib_lattice (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_23518 (h0 : add_group (has_nndist (option (cancel_monoid (option name))))) : is_add_cyclic (has_nndist (option (cancel_monoid (option name)))) := sorry --non-trivial
lemma new_lemma_23519 (h0 : functor.add_const (topological_space (has_to_string pos)) unsigned) : @path_connected_space.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_23520 (h0 : topological_space (plift num)) : t1_space (plift num) := sorry --non-trivial
lemma new_lemma_23521 (h0 : functor.add_const (topological_space (add_comm_monoid linarith.comp)) Type) : @preirreducible_space.{0} (add_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (add_comm_monoid.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_23522 (h0 : add_group (normed_comm_ring (has_add ennreal))) : is_add_cyclic (normed_comm_ring (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_23523 (h0 : functor.add_const (filter (ring pos)) (comm_group Type)) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_23524 (h5 : Prop) : set.separates_points (id (fun (h1 : fun_info -> std_gen), h5)) := sorry --non-trivial
lemma new_lemma_23525 (h0 : group (has_nndist (finset name))) : normalizer_condition (has_nndist (finset name)) := sorry --non-trivial
lemma new_lemma_23526 (h0 : not (function.extfun Type monoid -> false)) : @monoid.fg.{0} (add_group.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type monoid.{0}) h0) (add_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_23527 (h1 : ring (normed_field char)) : is_domain (normed_field char) := sorry --non-trivial
lemma new_lemma_23528 (h0 : add_group (complete_semilattice_Sup (semiring (add_group congr_arg_kind)))) : is_add_cyclic (complete_semilattice_Sup (semiring (add_group congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_23529 (h0 : topological_space (has_norm num)) : totally_separated_space (has_norm num) := sorry --non-trivial
lemma new_lemma_23530 (h0 : topological_space (complete_distrib_lattice (ring Type))) : path_connected_space (complete_distrib_lattice (ring Type)) := sorry --non-trivial
lemma new_lemma_23531 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_bot.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_bot.{0} pos))  := sorry --non-trivial
lemma new_lemma_23532 (h0 : functor.add_const (cancel_comm_monoid_with_zero (complete_distrib_lattice name)) linarith.comp) : @unique_factorization_monoid.{0} (complete_distrib_lattice.{0} name) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (complete_distrib_lattice.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_23533 (h0 : filter (ring (semigroup linarith.comp))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_23534 (h0 : function.extfun Type group) : @group.fg.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_23535 (h0 : functor.add_const (ring (has_Inf linarith.comp)) pos) : @is_principal_ideal_ring.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_Inf.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_23536 (h0 : list (semigroup (option name))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_23537 (h0 : ring (monoid_with_zero ennreal)) : is_domain (monoid_with_zero ennreal) := sorry --non-trivial
lemma new_lemma_23538 (h0 : functor.comp monoid boolean_algebra environment.implicit_infer_kind) : @monoid.fg.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} monoid.{0} boolean_algebra.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_23539 (h0 : add_group (has_to_string (option name))) : is_add_cyclic (has_to_string (option name)) := sorry --non-trivial
lemma new_lemma_23540 (h0 : function.extfun (Type 1) monoid) : @monoid.fg.{1} (has_neg_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) monoid.{1} h0 (has_neg_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_23541 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (finset.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (finset.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_23542 (h0 : topological_space (simple_graph pos)) : locally_compact_space (simple_graph pos) := sorry --non-trivial
lemma new_lemma_23543 (h0 : complete_lattice (has_top (semiring num))) : is_compactly_generated (has_top (semiring num)) := sorry --non-trivial
lemma new_lemma_23544 (h0 : filter (linear_ordered_add_comm_group (has_norm to_additive.value_type))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_23545 (h3 : topological_space (comm_ring fun_info)) : t0_space (comm_ring fun_info) := sorry --non-trivial
lemma new_lemma_23546 (h0 : monoid (with_one empty)) : monoid.fg (with_one empty) := sorry --non-trivial
lemma new_lemma_23547 (h0 : functor.add_const (filter pos) num) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_23548 (h0 : list (semigroup (finset pos))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_23549 (h0 : ereal -> ereal -> ereal) (h1 : ereal) : right_identity h0 h1 := sorry --non-trivial
lemma new_lemma_23550 (h0 : finset (finset (option ennreal))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_23551 (h0 : functor.add_const (group (normed_linear_ordered_group unsigned)) (has_bot unsigned)) : @is_cyclic.{0} (normed_linear_ordered_group.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (normed_linear_ordered_group.{0} unsigned)) (has_bot.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_23552 (h1 : topological_space (denumerable (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm fun_info)))))) : t0_space (denumerable (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm fun_info))))) := sorry --non-trivial
lemma new_lemma_23553 (h0 : topological_space (cancel_monoid (option empty))) : totally_separated_space (cancel_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_23554 (h0 : topological_space (canonically_ordered_comm_semiring linarith.comp)) : t1_space (canonically_ordered_comm_semiring linarith.comp) := sorry --non-trivial
lemma new_lemma_23555 (h0 : ordered_add_comm_monoid (canonically_ordered_monoid (has_Inf (has_Inf (has_Inf pos))))) : archimedean (canonically_ordered_monoid (has_Inf (has_Inf (has_Inf pos)))) := sorry --non-trivial
lemma new_lemma_23556 (h0 : topological_space (has_norm (semiring fun_info))) : normal_space (has_norm (semiring fun_info)) := sorry --non-trivial
lemma new_lemma_23557 (h0 : add_group (ring (option num))) : is_add_cyclic (ring (option num)) := sorry --non-trivial
lemma new_lemma_23558 (h0 : functor.add_const (group (comm_group Type)) name) : @is_simple_group.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (comm_group.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_23559 (h0 : complete_lattice (random_gen (random_gen (random_gen string_imp)))) : is_atomistic (random_gen (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_23560 (h0 : group (has_nnnorm (has_nnnorm (linear_ordered_add_comm_group linarith.ineq)))) : is_cyclic (has_nnnorm (has_nnnorm (linear_ordered_add_comm_group linarith.ineq))) := sorry --non-trivial
lemma new_lemma_23561 (h0 : functor.add_const (cancel_comm_monoid_with_zero (semigroup empty)) empty) : @unique_factorization_monoid.{0} (semigroup.{0} empty) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (semigroup.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_23562 (h0 : functor.add_const (topological_space (boolean_algebra.core name)) pos) : @loc_path_connected_space.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_23563 (h0 : functor.add_const (complete_lattice (comm_group pos)) unsigned) : @complete_lattice.is_Sup_finite_compact.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (comm_group.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_23564 (h0 : add_group (denumerable linarith.comp_source)) : is_add_cyclic (denumerable linarith.comp_source) := sorry --non-trivial
lemma new_lemma_23565 (h0 : group (add_cancel_comm_monoid reducibility_hints)) : is_cyclic (add_cancel_comm_monoid reducibility_hints) := sorry --non-trivial
lemma new_lemma_23566 (h0 : ring (ring (has_neg_part environment.implicit_infer_kind))) : strong_rank_condition (ring (has_neg_part environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_23567 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (add_comm_monoid.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_23568 (h1 : semiring enat) (h3 : enat) : even h3 := sorry --non-trivial
lemma new_lemma_23569 (h0 : ordered_comm_monoid (boolean_algebra.core (has_nndist pos))) : has_exists_mul_of_le (boolean_algebra.core (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_23570 (h0 : add_monoid (add_right_cancel_monoid (has_top (semiring (has_top (has_top unsigned)))))) : add_monoid.fg (add_right_cancel_monoid (has_top (semiring (has_top (has_top unsigned))))) := sorry --non-trivial
lemma new_lemma_23571 (h1 : uniform_space (complete_semilattice_Sup (with_bot (with_bot linarith.comp_source)))) : complete_space (complete_semilattice_Sup (with_bot (with_bot linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_23572 (h0 : filter (complete_linear_order (semiring (semiring (semiring num))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_23573 (h0 : not (ring (fintype char) -> false)) : @is_domain.{0} (fintype.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (fintype.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_23574 (h0 : uniform_space (with_one (semiring (semiring (semiring (semiring (semiring (semiring empty)))))))) : separated_space (with_one (semiring (semiring (semiring (semiring (semiring (semiring empty))))))) := sorry --non-trivial
lemma new_lemma_23575 (h0 : functor.add_const (topological_space (ring name)) pos) : @t0_space.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_23576 (h0 : ring (as_linear_order unsigned)) : is_principal_ideal_ring (as_linear_order unsigned) := sorry --non-trivial
lemma new_lemma_23577 (h0 : ring (has_neg (add_comm_monoid (has_add (semigroup environment.implicit_infer_kind))))) : is_domain (has_neg (add_comm_monoid (has_add (semigroup environment.implicit_infer_kind)))) := sorry --non-trivial
lemma new_lemma_23578 (h0 : topological_space (linear_ordered_add_comm_group (with_zero fun_info))) : t0_space (linear_ordered_add_comm_group (with_zero fun_info)) := sorry --non-trivial
lemma new_lemma_23579 (h0 : topological_space (sub_neg_monoid linarith.comp)) : preconnected_space (sub_neg_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_23580 (h0 : cancel_comm_monoid_with_zero (has_neg_part Type)) : unique_factorization_monoid (has_neg_part Type) := sorry --non-trivial
lemma new_lemma_23581 (h0 : ring (add_comm_monoid (comm_group Type))) : rank_condition (add_comm_monoid (comm_group Type)) := sorry --non-trivial
lemma new_lemma_23582 (h0 : not (add_group (simple_graph reducibility_hints) -> false)) : @is_add_cyclic.{0} (simple_graph.{0} reducibility_hints) (@classical.by_contradiction'.{1} (add_group.{0} (simple_graph.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_23583 (h0 : topological_space (measurable_space (random_gen (has_top num)))) : totally_disconnected_space (measurable_space (random_gen (has_top num))) := sorry --non-trivial
lemma new_lemma_23584 (h0 : function.extfun Type topological_space) : @t0_space.{0} (ordered_comm_ring.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_ring.{0} real))  := sorry --non-trivial
lemma new_lemma_23585 (h0 : filter (denumerable string_imp)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_23586 (h0 : complete_lattice (complete_linear_order (has_norm unsigned))) : is_compactly_generated (complete_linear_order (has_norm unsigned)) := sorry --non-trivial
lemma new_lemma_23587 (h0 : functor.add_const (filter (has_neg_part name)) linarith.comp) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_23588 (h0 : functor.add_const (list (has_neg_part pos)) pos) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_23589 (h0 : list (bin_tree num)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_23590 (h0 : filter (has_to_string (has_nndist environment.implicit_infer_kind))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_23591 (h0 : function.extfun Type ring) : @rank_condition.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_ordered_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_23592 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (has_zero.{0} name) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (has_zero.{0} name))  := sorry --non-trivial
lemma new_lemma_23593 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_top.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_top.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_23594 (h0 : topological_space (id (semiring congr_arg_kind))) : discrete_topology (id (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_23595 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (encodable.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (encodable.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_23596 (h0 : function.extfun Type group) : @normalizer_condition.{0} (linear_ordered_field.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} h0 (linear_ordered_field.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_23597 (h0 : ordered_add_comm_monoid (has_zero (semigroup linarith.comp))) : archimedean (has_zero (semigroup linarith.comp)) := sorry --non-trivial
lemma new_lemma_23598 (h0 : semiring (has_neg_part (has_neg_part (has_add Type)))) : is_noetherian_ring (has_neg_part (has_neg_part (has_add Type))) := sorry --non-trivial
lemma new_lemma_23599 (h1 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_norm.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h1 (has_norm.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_23600 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (boolean_algebra.core.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (boolean_algebra.core.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_23601 (h0 : functor.add_const (ring (boolean_algebra Type)) (ring (ring (ordered_comm_ring (has_nndist linarith.comp))))) : @is_domain.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (boolean_algebra.{1} Type)) (ring.{0} (ring.{0} (ordered_comm_ring.{0} (has_nndist.{0} linarith.comp)))) h0)  := sorry --non-trivial
lemma new_lemma_23602 (h0 : ring (has_add (has_add (mul_one_class Type)))) : strong_rank_condition (has_add (has_add (mul_one_class Type))) := sorry --non-trivial
lemma new_lemma_23603 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (mul_zero_class.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (mul_zero_class.{0} num))  := sorry --non-trivial
lemma new_lemma_23604 (h0 : functor.add_const (group (ring linarith.comp)) (finset (has_neg Type))) : @group.fg.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (group.{0} (ring.{0} linarith.comp)) (finset.{1} (has_neg.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_23605 (h0 : topological_space (normed_lattice_add_comm_group real)) : loc_path_connected_space (normed_lattice_add_comm_group real) := sorry --non-trivial
lemma new_lemma_23606 (h0 : functor.add_const (topological_space (finset environment.implicit_infer_kind)) environment.implicit_infer_kind) : @t1_space.{0} (finset.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_23607 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (random_gen.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (random_gen.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_23608 (h0 : functor.add_const (uniform_space (linear_ordered_cancel_comm_monoid empty)) num) : @separated_space.{0} (linear_ordered_cancel_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (linear_ordered_cancel_comm_monoid.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_23609 (h0 : functor.add_const (topological_space (finset unsigned)) (option unsigned)) : @path_connected_space.{0} (finset.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} unsigned)) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_23610 (h1 : complete_lattice (measurable_space (random_gen (random_gen string_imp)))) : is_atomistic (measurable_space (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_23611 (h0 : cancel_comm_monoid_with_zero (bin_tree (semiring unsigned))) : unique_factorization_monoid (bin_tree (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_23612 (h0 : topological_space (has_norm (semiring (semiring (semiring unsigned))))) : locally_compact_space (has_norm (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_23613 (h1 : topological_space (comm_ring (has_nnnorm linarith.comp_source))) : path_connected_space (comm_ring (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_23614 (h0 : function.extfun Type group) : @group.fg.{0} (measurable_space.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} h0 (measurable_space.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_23615 (h5 : ring (has_append linarith.comp_source)) : rank_condition (has_append linarith.comp_source) := sorry --non-trivial
lemma new_lemma_23616 (h0 : set (has_compl linarith.comp_source)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_23617 (h0 : topological_space (metric_space (add_group empty))) : irreducible_space (metric_space (add_group empty)) := sorry --non-trivial
lemma new_lemma_23618 (h0 : topological_space (semiring (has_top (has_norm to_additive.value_type)))) : path_connected_space (semiring (has_top (has_norm to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_23619 (h0 : functor.add_const (add_group (has_neg linarith.comp)) Type) : @is_add_cyclic.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 1} (add_group.{0} (has_neg.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_23620 (h0 : not (group (with_one empty) -> false)) : @group.fg.{0} (with_one.{0} empty) (@classical.by_contradiction'.{1} (group.{0} (with_one.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_23621 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_23622 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (linear_ordered_comm_monoid_with_zero.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_monoid_with_zero.{0} empty))  := sorry --non-trivial
lemma new_lemma_23623 (h0 : functor.add_const (group (is_R_or_C empty)) congr_arg_kind) : @is_cyclic.{0} (is_R_or_C.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (is_R_or_C.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_23624 (h0 : topological_space (has_add (semigroup Type))) : totally_disconnected_space (has_add (semigroup Type)) := sorry --non-trivial
lemma new_lemma_23625 (h0 : topological_space (has_Inf Type)) : preirreducible_space (has_Inf Type) := sorry --non-trivial
lemma new_lemma_23626 (h0 : group (measurable_space fun_info)) : is_cyclic (measurable_space fun_info) := sorry --non-trivial
lemma new_lemma_23627 (h0 : cancel_comm_monoid_with_zero (monoid_with_zero pos)) : unique_factorization_monoid (monoid_with_zero pos) := sorry --non-trivial
lemma new_lemma_23628 (h0 : topological_space (simple_graph unsigned)) : discrete_topology (simple_graph unsigned) := sorry --non-trivial
lemma new_lemma_23629 (h0 : cancel_comm_monoid_with_zero (cancel_monoid unsigned)) : unique_factorization_monoid (cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_23630 (h0 : group (has_star (semiring empty))) : is_cyclic (has_star (semiring empty)) := sorry --non-trivial
lemma new_lemma_23631 (h0 : functor.add_const (complete_lattice (free_add_monoid empty)) congr_arg_kind) : @is_atomistic.{0} (free_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (free_add_monoid.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_23632 (h0 : topological_space (mul_zero_class (semiring (semiring congr_arg_kind)))) : preirreducible_space (mul_zero_class (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_23633 (h0 : complete_lattice (non_assoc_semiring (semiring (semiring unsigned)))) : is_compactly_generated (non_assoc_semiring (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_23634 (h0 : ring (has_neg (comm_group name))) : rank_condition (has_neg (comm_group name)) := sorry --non-trivial
lemma new_lemma_23635 (h0 : functor.add_const (complete_lattice (has_zero environment.implicit_infer_kind)) (has_neg Type)) : @is_compactly_generated.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (complete_lattice.{0} (has_zero.{0} environment.implicit_infer_kind)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_23636 (h0 : group (semi_normed_comm_ring (random_gen (random_gen char)))) : group.fg (semi_normed_comm_ring (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_23637 (h0 : group (has_top (has_ssubset fun_info))) : is_cyclic (has_top (has_ssubset fun_info)) := sorry --non-trivial
lemma new_lemma_23638 (h0 : filter (has_sub congr_arg_kind)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_23639 (h0 : ring (has_nnnorm (comm_ring linarith.comp_source))) : rank_condition (has_nnnorm (comm_ring linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_23640 (h0 : uniform_space (has_to_string (add_comm_monoid (add_comm_monoid name)))) : separated_space (has_to_string (add_comm_monoid (add_comm_monoid name))) := sorry --non-trivial
lemma new_lemma_23641 (h0 : group (cancel_monoid (sub_neg_monoid num))) : normalizer_condition (cancel_monoid (sub_neg_monoid num)) := sorry --non-trivial
lemma new_lemma_23642 (h0 : not (topological_space (measurable_space empty) -> false)) : @normal_space.{0} (measurable_space.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (measurable_space.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_23643 (h0 : complex -> linarith.comp -> linarith.comp) (h1 : linarith.comp -> linarith.comp -> Prop) : contravariant_class complex linarith.comp h0 h1 := sorry --non-trivial
lemma new_lemma_23644 (h0 : topological_space (has_edist (option unsigned))) : normal_space (has_edist (option unsigned)) := sorry --non-trivial
lemma new_lemma_23645 (h0 : topological_space (has_zero (comm_group (add_comm_monoid environment.implicit_infer_kind)))) : sequential_space (has_zero (comm_group (add_comm_monoid environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_23646 (h0 : uniform_space (ordered_comm_ring (has_neg linarith.comp))) : separated_space (ordered_comm_ring (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_23647 (h0 : not (uniform_space (monoid linarith.ineq) -> false)) : @complete_space.{0} (monoid.{0} linarith.ineq) (@classical.by_contradiction'.{1} (uniform_space.{0} (monoid.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_23648 (h0 : topological_space (has_Inf (has_Inf Type))) : locally_compact_space (has_Inf (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_23649 (h0 : topological_space (rel empty congr_arg_kind)) : discrete_topology (rel empty congr_arg_kind) := sorry --non-trivial
lemma new_lemma_23650 (h0 : set (uniform_space (mul_one_class reducibility_hints))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_23651 (h0 : add_group (cancel_monoid congr_arg_kind)) : is_add_cyclic (cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_23652 (h0 : functor.add_const (ring (add_cancel_monoid empty)) empty) : @strong_rank_condition.{0} (add_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (add_cancel_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_23653 (h0 : topological_space (has_add (finset pos))) : t1_space (has_add (finset pos)) := sorry --non-trivial
lemma new_lemma_23654 (h0 : ring (has_one (with_bot (has_top unsigned)))) : strong_rank_condition (has_one (with_bot (has_top unsigned))) := sorry --non-trivial
lemma new_lemma_23655 (h0 : uniform_space (has_one congr_arg_kind)) : separated_space (has_one congr_arg_kind) := sorry --non-trivial
lemma new_lemma_23656 (h0 : function.extfun Type (functor.add_const (complete_lattice ennreal))) : is_atomistic ennreal := sorry --non-trivial
lemma new_lemma_23657 (h0 : group (mul_zero_class (finset environment.implicit_infer_kind))) : is_simple_group (mul_zero_class (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_23658 (h0 : group (has_neg (option unsigned))) : is_cyclic (has_neg (option unsigned)) := sorry --non-trivial
lemma new_lemma_23659 (h0 : has_mem.mem (complete_semilattice_Sup linarith.comp_source) has_emptyc.emptyc) : @totally_separated_space.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (complete_semilattice_Sup.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_23660 (h0 : fin has_zero.zero) : @normal_space.{1} (ordered_comm_ring.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (ordered_comm_ring.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_23661 (h0 : functor.add_const (uniform_space (comm_group Type)) Type) : @separated_space.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 1} (uniform_space.{1} (comm_group.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_23662 (h0 : function.extfun nat fin) : @path_connected_space.{0} (has_bot.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (has_bot.{0} pos))  := sorry --non-trivial
lemma new_lemma_23663 (h0 : topological_space (measurable_space.dynkin_system (semiring empty))) : normal_space (measurable_space.dynkin_system (semiring empty)) := sorry --non-trivial
lemma new_lemma_23664 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) linarith.ineq) := sorry --non-trivial
lemma new_lemma_23665 (h0 : fin has_zero.zero) : @normal_space.{0} (has_add.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (has_add.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_23666 (h0 : topological_space (has_add (boolean_algebra.core name))) : preirreducible_space (has_add (boolean_algebra.core name)) := sorry --non-trivial
lemma new_lemma_23667 (h0 : finset (normed_linear_ordered_group (option unsigned))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_23668 (h0 : complete_lattice (with_one unsigned)) : is_atomistic (with_one unsigned) := sorry --non-trivial
lemma new_lemma_23669 (h0 : semiring (simple_graph (has_add (has_to_string pos)))) : is_noetherian_ring (simple_graph (has_add (has_to_string pos))) := sorry --non-trivial
lemma new_lemma_23670 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (mul_zero_class.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (mul_zero_class.{0} pos))  := sorry --non-trivial
lemma new_lemma_23671 (h0 : topological_space (add_cancel_comm_monoid (option (add_cancel_comm_monoid unsigned)))) : loc_path_connected_space (add_cancel_comm_monoid (option (add_cancel_comm_monoid unsigned))) := sorry --non-trivial
lemma new_lemma_23672 (h0 : functor.add_const (uniform_space (ordered_comm_monoid name)) Type) : @complete_space.{0} (ordered_comm_monoid.{0} name) (@functor.add_const.run.{0 1} (uniform_space.{0} (ordered_comm_monoid.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_23673 (h0 : not (topological_space (normed_group num) -> false)) : @totally_separated_space.{0} (normed_group.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_group.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_23674 (h0 h1 : multiset (has_nnnorm (mul_one_class (mul_one_class linarith.comp_source)))) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_23675 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @regular_space.{0} (has_pos_part.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (has_pos_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_23676 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_bot.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_bot.{0} pos))  := sorry --non-trivial
lemma new_lemma_23677 (h0 : topological_space (normed_group (has_top (has_top linarith.comp_source)))) : path_connected_space (normed_group (has_top (has_top linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_23678 (h0 : functor.add_const (function.extfun Type topological_space) (has_neg (has_neg Type))) : @irreducible_space.{0} (normed_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) (has_neg.{1} (has_neg.{1} Type)) h0) (normed_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_23679 (h0 : fin has_zero.zero) : @irreducible_space.{1} (sub_neg_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (sub_neg_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_23680 (h0 : functor.add_const (topological_space (add_cancel_monoid unsigned)) Type) : @preconnected_space.{0} (add_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (add_cancel_monoid.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_23681 (h1 : ring (complete_semilattice_Sup to_additive.value_type)) : rank_condition (complete_semilattice_Sup to_additive.value_type) := sorry --non-trivial
lemma new_lemma_23682 (h0 : functor.add_const (topological_space (ordered_comm_ring linarith.comp)) pos) : @loc_path_connected_space.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_23683 (h0 : functor.add_const (monoid (option empty)) congr_arg_kind) : @monoid.fg.{0} (option.{0} empty) (@functor.add_const.run.{0 0} (monoid.{0} (option.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_23684 (h0 : topological_space (has_dist unsigned)) : path_connected_space (has_dist unsigned) := sorry --non-trivial
lemma new_lemma_23685 (h0 : ring (comm_ring fun_info)) : strong_rank_condition (comm_ring fun_info) := sorry --non-trivial
lemma new_lemma_23686 (h0 : uniform_space (has_zero (has_add (has_add name)))) : complete_space (has_zero (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_23687 (h0 : metric_space (random_gen num)) (h1 : set (random_gen num)) : euclidean_geometry.cospherical h1 := sorry --non-trivial
lemma new_lemma_23688 (h0 : functor.add_const (group (has_neg unsigned)) linarith.comp) : @group.fg.{0} (has_neg.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (has_neg.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_23689 (h0 : topological_space (complete_semilattice_Sup unsigned)) : topological_space.separable_space (complete_semilattice_Sup unsigned) := sorry --non-trivial
lemma new_lemma_23690 (h0 : topological_space (comm_group (boolean_algebra.core unsigned))) : preirreducible_space (comm_group (boolean_algebra.core unsigned)) := sorry --non-trivial
lemma new_lemma_23691 (h0 : functor.add_const (ring (has_edist empty)) empty) : @strong_rank_condition.{0} (has_edist.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (has_edist.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_23692 (h0 : ring (add_cancel_monoid (finset pos))) : is_domain (add_cancel_monoid (finset pos)) := sorry --non-trivial
lemma new_lemma_23693 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_top.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_top.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_23694 (h0 : functor.add_const (filter (add_cancel_monoid empty)) empty) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_23695 (h1 : add_group (fintype linarith.ineq)) : is_simple_add_group (fintype linarith.ineq) := sorry --non-trivial
lemma new_lemma_23696 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (mul_zero_class.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (mul_zero_class.{0} name))  := sorry --non-trivial
lemma new_lemma_23697 (h0 : filter (has_nndist unsigned)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_23698 (h0 : topological_space (add_cancel_monoid (finset (ring environment.implicit_infer_kind)))) : locally_compact_space (add_cancel_monoid (finset (ring environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_23699 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_compactly_generated.{0} (complete_semilattice_Sup.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (complete_semilattice_Sup.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_23700 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (finset.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type add_group.{0} h0 (finset.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_23701 (h0 : topological_space (has_inter (option ennreal))) : totally_separated_space (has_inter (option ennreal)) := sorry --non-trivial
lemma new_lemma_23702 (h0 : fin has_zero.zero) : @path_connected_space.{1} (normed_lattice_add_comm_group.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (normed_lattice_add_comm_group.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_23703 (h0 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} (complete_semilattice_Sup.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (complete_semilattice_Sup.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_23704 (h0 : topological_space (complete_semilattice_Sup (has_norm num))) : totally_disconnected_space (complete_semilattice_Sup (has_norm num)) := sorry --non-trivial
lemma new_lemma_23705 (h0 : group (metric_space linarith.comp)) : normalizer_condition (metric_space linarith.comp) := sorry --non-trivial
lemma new_lemma_23706 (h0 : ring (normed_comm_ring (comm_group unsigned))) : strong_rank_condition (normed_comm_ring (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_23707 (h0 : group (normed_comm_ring (comm_group pos))) : group.fg (normed_comm_ring (comm_group pos)) := sorry --non-trivial
lemma new_lemma_23708 (h0 : not (ring (has_lt (has_lt (metric_space reducibility_hints))) -> false)) : @strong_rank_condition.{0} (has_lt.{0} (has_lt.{0} (metric_space.{0} reducibility_hints))) (@classical.by_contradiction'.{1} (ring.{0} (has_lt.{0} (has_lt.{0} (metric_space.{0} reducibility_hints)))) h0)  := sorry --non-trivial
lemma new_lemma_23709 (h1 : group (topological_space (random_gen char))) : is_cyclic (topological_space (random_gen char)) := sorry --non-trivial
lemma new_lemma_23710 (h0 : topological_space (linear_ordered_comm_ring (semiring empty))) : totally_disconnected_space (linear_ordered_comm_ring (semiring empty)) := sorry --non-trivial
lemma new_lemma_23711 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (@id.{2} Type linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (@id.{2} Type linarith.comp))  := sorry --non-trivial
lemma new_lemma_23712 (h0 : monoid (has_Inf (ring (ring linarith.comp)))) : monoid.fg (has_Inf (ring (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_23713 (h0 : topological_space (has_to_string (comm_group Type))) : normal_space (has_to_string (comm_group Type)) := sorry --non-trivial
lemma new_lemma_23714 (h0 : functor.add_const (topological_space (comm_group pos)) (has_to_string pos)) : @loc_path_connected_space.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} pos)) (has_to_string.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_23715 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (linear_order.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_23716 (h0 : cancel_comm_monoid_with_zero (simple_graph (finset (ring Type)))) : unique_factorization_monoid (simple_graph (finset (ring Type))) := sorry --non-trivial
lemma new_lemma_23717 (h0 : uniform_space (has_zero (has_add pos))) : complete_space (has_zero (has_add pos)) := sorry --non-trivial
lemma new_lemma_23718 (h0 : functor.add_const (ordered_add_comm_monoid (ordered_comm_ring pos)) linarith.comp) : @archimedean.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (ordered_comm_ring.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_23719 (h0 : fin has_zero.zero) : @is_cyclic.{1} (has_pos_part.{1} Type) (@matrix.vec_empty.{1} (group.{1} (has_pos_part.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_23720 (h0 : cancel_comm_monoid_with_zero (has_bot name)) : unique_factorization_monoid (has_bot name) := sorry --non-trivial
lemma new_lemma_23721 (h0 : group (mul_zero_class (mul_zero_class (has_add pos)))) : is_simple_group (mul_zero_class (mul_zero_class (has_add pos))) := sorry --non-trivial
lemma new_lemma_23722 (h0 : topological_space (canonically_ordered_comm_semiring Type)) : topological_space.separable_space (canonically_ordered_comm_semiring Type) := sorry --non-trivial
lemma new_lemma_23723 (h0 : topological_space (add_comm_monoid (sub_neg_monoid (sub_neg_monoid real)))) : t1_space (add_comm_monoid (sub_neg_monoid (sub_neg_monoid real))) := sorry --non-trivial
lemma new_lemma_23724 (h0 : topological_space (has_Inf (ring Type))) : normal_space (has_Inf (ring Type)) := sorry --non-trivial
lemma new_lemma_23725 (h0 : functor.add_const (ring num) num) : @strong_rank_condition.{0} num (@functor.add_const.run.{0 0} (ring.{0} num) num h0)  := sorry --non-trivial
lemma new_lemma_23726 (h0 : add_group (normed_linear_ordered_group unsigned)) : is_add_cyclic (normed_linear_ordered_group unsigned) := sorry --non-trivial
lemma new_lemma_23727 (h0 : not (multiset (has_neg string_imp) -> false)) (h1 : multiset (has_neg string_imp)) : multiset.disjoint (classical.by_contradiction' h0) h1 := sorry --non-trivial
lemma new_lemma_23728 (h0 : semiring (has_inter num)) : is_noetherian_ring (has_inter num) := sorry --non-trivial
lemma new_lemma_23729 (h0 : topological_space (ordered_comm_ring (ring Type))) : preconnected_space (ordered_comm_ring (ring Type)) := sorry --non-trivial
lemma new_lemma_23730 (h0 : topological_space (pseudo_metric_space (option ennreal))) : totally_disconnected_space (pseudo_metric_space (option ennreal)) := sorry --non-trivial
lemma new_lemma_23731 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (random_gen.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (random_gen.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_23732 (h0 : functor.add_const (function.extfun (Type 1) cancel_comm_monoid_with_zero) linarith.comp) : @unique_factorization_monoid.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1}) linarith.comp h0) (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_23733 (h0 : topological_space (comm_group (has_add name))) : preirreducible_space (comm_group (has_add name)) := sorry --non-trivial
lemma new_lemma_23734 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (add_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_23735 (h0 : topological_space (add_cancel_monoid (has_to_string linarith.comp))) : preconnected_space (add_cancel_monoid (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_23736 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (add_right_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_right_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_23737 (h0 : list (boolean_algebra (has_pos_part Type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_23738 (h0 : group (option (option (option (option pos))))) : normalizer_condition (option (option (option (option pos)))) := sorry --non-trivial
lemma new_lemma_23739 (h0 : topological_space (finset environment.implicit_infer_kind)) : path_connected_space (finset environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_23740 (h0 : functor.add_const (ring (has_nndist unsigned)) (finset pos)) : @is_principal_ideal_ring.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (has_nndist.{0} unsigned)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_23741 (h0 : functor.add_const (semiring pos) (option pos)) : @is_noetherian_ring.{0} pos (@functor.add_const.run.{0 0} (semiring.{0} pos) (option.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_23742 (h0 : finset (mul_one_class environment.projection_info)) (h1 : mul_one_class environment.projection_info -> topological_space linarith.comp_source) : @path_connected_space.{0} linarith.comp_source (@finset.sup.{0 0} (topological_space.{0} linarith.comp_source) (mul_one_class.{0} environment.projection_info) (@lattice.to_semilattice_sup.{0} (topological_space.{0} linarith.comp_source) (@conditionally_complete_lattice.to_lattice.{0} (topological_space.{0} linarith.comp_source) (@complete_lattice.to_conditionally_complete_lattice.{0} (topological_space.{0} linarith.comp_source) (@topological_space.complete_lattice.{0} linarith.comp_source)))) (@bounded_order.to_order_bot.{0} (topological_space.{0} linarith.comp_source) (@preorder.to_has_le.{0} (topological_space.{0} linarith.comp_source) (@partial_order.to_preorder.{0} (topological_space.{0} linarith.comp_source) (@semilattice_sup.to_partial_order.{0} (topological_space.{0} linarith.comp_source) (@lattice.to_semilattice_sup.{0} (topological_space.{0} linarith.comp_source) (@conditionally_complete_lattice.to_lattice.{0} (topological_space.{0} linarith.comp_source) (@complete_lattice.to_conditionally_complete_lattice.{0} (topological_space.{0} linarith.comp_source) (@topological_space.complete_lattice.{0} linarith.comp_source))))))) (@complete_lattice.to_bounded_order.{0} (topological_space.{0} linarith.comp_source) (@topological_space.complete_lattice.{0} linarith.comp_source))) h0 h1)  := sorry --non-trivial
lemma new_lemma_23743 (h0 : functor.add_const (topological_space (ordered_ring empty)) num) : @preirreducible_space.{0} (ordered_ring.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_23744 (h0 : functor.add_const (group (ring Type)) name) : @normalizer_condition.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (ring.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_23745 (h0 : fin has_zero.zero) : @is_principal_ideal_ring.{1} Type (@function.extfun_app.{3 2} (Type 1) ring.{1} (@matrix.vec_empty.{2} (function.extfun.{3 2} (Type 1) ring.{1}) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)) Type)  := sorry --non-trivial
lemma new_lemma_23746 (h0 : list (has_neg (has_neg (has_neg linarith.comp)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_23747 (h0 : function.extfun Type topological_space) : @t0_space.{0} (non_assoc_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (non_assoc_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_23748 (h0 : functor.add_const (topological_space (has_pos_part linarith.comp)) (has_add (ring (has_nndist linarith.comp)))) : @normal_space.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} linarith.comp)) (has_add.{0} (ring.{0} (has_nndist.{0} linarith.comp))) h0)  := sorry --non-trivial
lemma new_lemma_23749 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_23750 (h0 : ordered_comm_monoid (ordered_comm_ring (has_nndist Type))) : has_exists_mul_of_le (ordered_comm_ring (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_23751 (h0 : function.extfun Type group) : @group.fg.{0} (ordered_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (ordered_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_23752 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (complete_distrib_lattice unsigned)) := sorry --non-trivial
lemma new_lemma_23753 (h0 : functor.add_const (group (boolean_algebra.core name)) Type) : @normalizer_condition.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 1} (group.{0} (boolean_algebra.core.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_23754 (h0 : group (boolean_algebra (has_pos_part (normed_comm_ring Type)))) : normalizer_condition (boolean_algebra (has_pos_part (normed_comm_ring Type))) := sorry --non-trivial
lemma new_lemma_23755 (h0 : topological_space (boolean_algebra (finset environment.implicit_infer_kind))) : path_connected_space (boolean_algebra (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_23756 (h0 : add_group (with_one char)) : is_add_cyclic (with_one char) := sorry --non-trivial
lemma new_lemma_23757 (h0 : functor.add_const (uniform_space (add_comm_monoid name)) name) : @separated_space.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (add_comm_monoid.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_23758 (h0 : complete_lattice (metric_space congr_arg_kind)) : complete_lattice.is_Sup_finite_compact (metric_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_23759 (h0 : functor.add_const (monoid (cancel_monoid environment.implicit_infer_kind)) pos) : @monoid.fg.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (monoid.{0} (cancel_monoid.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_23760 (h0 : group (normed_group (has_norm fun_info))) : group.fg (normed_group (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_23761 (h0 : add_group (has_add (has_Inf (has_Inf name)))) : is_add_cyclic (has_add (has_Inf (has_Inf name))) := sorry --non-trivial
lemma new_lemma_23762 (h0 : functor.add_const (function.extfun Type ring) Type) : @rank_condition.{0} (has_add.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ring.{0}) Type h0) (has_add.{0} name))  := sorry --non-trivial
lemma new_lemma_23763 (h0 : functor.add_const (list (semigroup pos)) unsigned) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_23764 (h0 : complete_lattice (add_cancel_monoid pos)) : complete_lattice.is_Sup_finite_compact (add_cancel_monoid pos) := sorry --non-trivial
lemma new_lemma_23765 (h2 : topological_space enat) (h3 : preorder enat) : order_topology enat := sorry --non-trivial
lemma new_lemma_23766 (h0 : functor.add_const (add_group (has_nndist unsigned)) linarith.comp) : @is_add_cyclic.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 0} (add_group.{0} (has_nndist.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_23767 (h0 : functor.add_const (group (ordered_comm_monoid pos)) (finset Type)) : @group.fg.{0} (ordered_comm_monoid.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (ordered_comm_monoid.{0} pos)) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_23768 (h0 : ring (topological_space (with_one fun_info))) : rank_condition (topological_space (with_one fun_info)) := sorry --non-trivial
lemma new_lemma_23769 (h0 : topological_space (comm_group (has_to_string (has_to_string (comm_group unsigned))))) : irreducible_space (comm_group (has_to_string (has_to_string (comm_group unsigned)))) := sorry --non-trivial
lemma new_lemma_23770 (h0 : filter (finset (finset environment.implicit_infer_kind))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_23771 (h0 : functor.add_const (topological_space (is_R_or_C empty)) empty) : @totally_separated_space.{0} (is_R_or_C.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (is_R_or_C.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_23772 (h0 : functor.add_const (topological_space (complete_distrib_lattice Type)) Type) : @preconnected_space.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (complete_distrib_lattice.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_23773 (h0 : functor.add_const (complete_lattice (boolean_algebra linarith.comp)) linarith.comp) : @complete_lattice.is_Sup_finite_compact.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (boolean_algebra.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_23774 (h0 : topological_space (semigroup (has_neg_part Type))) : topological_space.separable_space (semigroup (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_23775 (h0 : ring (measurable_space.dynkin_system (has_norm (has_norm empty)))) : is_domain (measurable_space.dynkin_system (has_norm (has_norm empty))) := sorry --non-trivial
lemma new_lemma_23776 (h0 : topological_space (has_norm (has_norm empty))) : irreducible_space (has_norm (has_norm empty)) := sorry --non-trivial
lemma new_lemma_23777 (h0 : functor.add_const (function.extfun Type uniform_space) (finset Type)) : @complete_space.{0} (normed_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type uniform_space.{0}) (finset.{1} Type) h0) (normed_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_23778 (h0 : filter (topological_space (fintype fun_info))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_23779 (h0 : topological_space (ring (has_add Type))) : sequential_space (ring (has_add Type)) := sorry --non-trivial
lemma new_lemma_23780 (h0 : group (has_nndist (option (option unsigned)))) : group.fg (has_nndist (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_23781 (h0 : not (topological_space (has_nnnorm (has_nnnorm (metric_space char))) -> false)) : @t0_space.{0} (has_nnnorm.{0} (has_nnnorm.{0} (metric_space.{0} char))) (@classical.by_contradiction'.{1} (topological_space.{0} (has_nnnorm.{0} (has_nnnorm.{0} (metric_space.{0} char)))) h0)  := sorry --non-trivial
lemma new_lemma_23782 (h0 : complete_lattice (has_norm congr_arg_kind)) : complete_lattice.is_Sup_finite_compact (has_norm congr_arg_kind) := sorry --non-trivial
lemma new_lemma_23783 (h0 : functor.add_const (list (has_neg Type)) pos) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_23784 (h1 : uniform_space (with_zero (has_nnnorm to_additive.value_type))) : complete_space (with_zero (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_23785 (h0 : uniform_space (with_bot (has_norm empty))) : complete_space (with_bot (has_norm empty)) := sorry --non-trivial
lemma new_lemma_23786 (h0 : ring (has_top (random_gen fun_info))) : strong_rank_condition (has_top (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_23787 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (finset.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (finset.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_23788 (h0 : functor.add_const Prop (has_to_string (finset (ring (ring linarith.comp))))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_23789 (h0 : functor.comp topological_space pseudo_metric_space pos) : @regular_space.{0} (pseudo_metric_space.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} pseudo_metric_space.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_23790 (h0 : group (has_bot (has_Inf linarith.comp))) : group.fg (has_bot (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_23791 (h0 : group (distrib_lattice (has_top (random_gen string_imp)))) : group.fg (distrib_lattice (has_top (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_23792 (h0 : topological_space (comm_group (finset name))) : loc_path_connected_space (comm_group (finset name)) := sorry --non-trivial
lemma new_lemma_23793 (h0 : function.extfun Type group) : @is_simple_group.{0} (semigroup.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (semigroup.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_23794 (h2 : not (topological_space (has_top string_imp) -> false)) : @totally_separated_space.{0} (has_top.{0} string_imp) (@classical.by_contradiction'.{1} (topological_space.{0} (has_top.{0} string_imp)) h2)  := sorry --non-trivial
lemma new_lemma_23795 (h0 : ring (add_monoid (has_ssubset (random_gen (fintype linarith.ineq))))) : is_domain (add_monoid (has_ssubset (random_gen (fintype linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_23796 (h0 : topological_space (ordered_cancel_add_comm_monoid ennreal)) : path_connected_space (ordered_cancel_add_comm_monoid ennreal) := sorry --non-trivial
lemma new_lemma_23797 (h0 : uniform_space (canonically_ordered_comm_semiring (option name))) : separated_space (canonically_ordered_comm_semiring (option name)) := sorry --non-trivial
lemma new_lemma_23798 (h0 : ring (has_lt char)) : rank_condition (has_lt char) := sorry --non-trivial
lemma new_lemma_23799 (h0 : functor.add_const (function.extfun Type add_monoid) (finset Type)) : @add_monoid.fg.{0} subsingleton_info (@function.extfun_app.{2 1} Type add_monoid.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type add_monoid.{0}) (finset.{1} Type) h0) subsingleton_info)  := sorry --non-trivial
lemma new_lemma_23800 (h0 : functor.add_const (list (ring pos)) linarith.comp) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_23801 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @preirreducible_space.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_23802 (h0 : complete_lattice (has_norm (has_inv (has_inv linarith.comp_source)))) : is_atomistic (has_norm (has_inv (has_inv linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_23803 (h0 : monoid (has_sub (semiring (semiring num)))) : monoid.fg (has_sub (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_23804 (h0 : uniform_space (complete_semilattice_Sup (semiring (semiring (semiring unsigned))))) : separated_space (complete_semilattice_Sup (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_23805 (h0 : add_group (non_unital_non_assoc_semiring reducibility_hints)) : is_add_cyclic (non_unital_non_assoc_semiring reducibility_hints) := sorry --non-trivial
lemma new_lemma_23806 (h0 : semiring (has_zero (finset (has_to_string pos)))) : is_noetherian_ring (has_zero (finset (has_to_string pos))) := sorry --non-trivial
lemma new_lemma_23807 (h0 : functor.add_const (topological_space (ring linarith.comp)) name) : @totally_separated_space.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_23808 (h0 : topological_space (has_one unsigned)) : normal_space (has_one unsigned) := sorry --non-trivial
lemma new_lemma_23809 (h0 : topological_space (has_zero linarith.comp)) : t1_space (has_zero linarith.comp) := sorry --non-trivial
lemma new_lemma_23810 (h0 : topological_space (linear_ordered_semiring (semiring congr_arg_kind))) : locally_compact_space (linear_ordered_semiring (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_23811 (h0 : topological_space (ordered_cancel_add_comm_monoid (option (option empty)))) : normal_space (ordered_cancel_add_comm_monoid (option (option empty))) := sorry --non-trivial
lemma new_lemma_23812 (h0 : functor.add_const (add_group (semigroup pos)) (has_neg_part (boolean_algebra Type))) : @is_add_cyclic.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 1} (add_group.{0} (semigroup.{0} pos)) (has_neg_part.{1} (boolean_algebra.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_23813 (h0 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} (add_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (add_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_23814 (h2 : uniform_space (has_nnnorm (random_gen char))) : complete_space (has_nnnorm (random_gen char)) := sorry --non-trivial
lemma new_lemma_23815 (h0 : ring (ring (option_t normed_comm_ring linarith.comp))) : rank_condition (ring (option_t normed_comm_ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_23816 (h0 : not (complete_lattice (denumerable fun_info) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (denumerable.{0} fun_info) (@classical.by_contradiction'.{1} (complete_lattice.{0} (denumerable.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_23817 (h0 : ring (comm_group (has_to_string name))) : is_principal_ideal_ring (comm_group (has_to_string name)) := sorry --non-trivial
lemma new_lemma_23818 (h0 : function.extfun Type ring) : @rank_condition.{0} (boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type ring.{0} h0 (boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_23819 (h0 : fin has_zero.zero) (h1 : ne (id (matrix.vec_empty h0)) has_bot.bot) : with_bot.unbot (id (matrix.vec_empty h0)) h1 := sorry --non-trivial
lemma new_lemma_23820 (h0 : complete_lattice (metric_space (metric_space char))) : complete_lattice.is_Sup_finite_compact (metric_space (metric_space char)) := sorry --non-trivial
lemma new_lemma_23821 (h0 : complete_lattice (boolean_algebra (has_Inf Type))) : complete_lattice.is_Sup_finite_compact (boolean_algebra (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_23822 (h0 : functor.add_const (ring (has_sub num)) (semiring (semiring num))) : @is_principal_ideal_ring.{0} (has_sub.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (has_sub.{0} num)) (semiring.{0} (semiring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_23823 (h3 : topological_space char) (h4 : set char) : is_path_connected h4 := sorry --non-trivial
lemma new_lemma_23824 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_simple_group.{0} (add_cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (add_cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_23825 (h0 : ring (has_neg_part environment.implicit_infer_kind)) : rank_condition (has_neg_part environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_23826 (h0 : ordered_comm_monoid (monoid (ring unsigned))) : has_exists_mul_of_le (monoid (ring unsigned)) := sorry --non-trivial
lemma new_lemma_23827 (h0 : add_group (complete_semilattice_Sup (random_gen fun_info))) : is_add_cyclic (complete_semilattice_Sup (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_23828 (h0 : ring (has_union (semiring congr_arg_kind))) : strong_rank_condition (has_union (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_23829 (h0 : ring (finset (has_add linarith.comp))) : is_principal_ideal_ring (finset (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_23830 (h0 : topological_space (with_one (has_top empty))) : totally_separated_space (with_one (has_top empty)) := sorry --non-trivial
lemma new_lemma_23831 (h0 : set (has_le environment.projection_info)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_23832 (h1 : ring (fintype string_imp)) : is_domain (fintype string_imp) := sorry --non-trivial
lemma new_lemma_23833 (h0 : filter (has_ssubset (comm_ring (has_top (comm_ring (has_norm (has_ssubset linarith.ineq))))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_23834 (h0 : option (has_top unsigned) -> option (has_top unsigned) -> Prop) : is_strict_order (option (has_top unsigned)) h0 := sorry --non-trivial
lemma new_lemma_23835 (h0 : topological_space (with_one (has_inv linarith.comp_source))) : irreducible_space (with_one (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_23836 (h0 : topological_space (has_neg (has_neg_part linarith.comp))) : preconnected_space (has_neg (has_neg_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_23837 (h0 : functor.add_const (function.extfun Type topological_space) real) : @preirreducible_space.{0} (canonically_linear_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) real h0) (canonically_linear_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_23838 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_domain.{1} (boolean_algebra.core.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ring.{1}) (boolean_algebra.core.{1} Type))  := sorry --non-trivial
lemma new_lemma_23839 (h0 : ring (has_nndist pos)) : strong_rank_condition (has_nndist pos) := sorry --non-trivial
lemma new_lemma_23840 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (has_add.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_add.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_23841 (h0 : functor.add_const (ring (has_Inf linarith.comp)) linarith.comp) : @is_principal_ideal_ring.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_Inf.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_23842 (h0 : group (normed_field (has_compl char))) : is_cyclic (normed_field (has_compl char)) := sorry --non-trivial
lemma new_lemma_23843 (h0 : group (topological_space (has_ssubset reducibility_hints))) : is_cyclic (topological_space (has_ssubset reducibility_hints)) := sorry --non-trivial
lemma new_lemma_23844 (h1 : list (measurable_space (random_gen (random_gen string_imp)))) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_23845 (h0 : functor.add_const (group (option ennreal)) ennreal) : @is_simple_group.{0} (option.{0} ennreal) (@functor.add_const.run.{0 0} (group.{0} (option.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_23846 (h1 : not (add_group (comm_ring reducibility_hints) -> false)) : @is_add_cyclic.{0} (comm_ring.{0} reducibility_hints) (@classical.by_contradiction'.{1} (add_group.{0} (comm_ring.{0} reducibility_hints)) h1)  := sorry --non-trivial
lemma new_lemma_23847 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (has_emptyc.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_emptyc.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_23848 (h0 : topological_space (sub_neg_monoid pos)) : totally_disconnected_space (sub_neg_monoid pos) := sorry --non-trivial
lemma new_lemma_23849 (h0 : functor.add_const (group (has_neg_part Type)) pos) : @group.fg.{1} (has_neg_part.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (has_neg_part.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_23850 (h0 : ring (semi_normed_comm_ring enat)) : strong_rank_condition (semi_normed_comm_ring enat) := sorry --non-trivial
lemma new_lemma_23851 (h0 : has_mem.mem (linear_ordered_add_comm_group num) has_emptyc.emptyc) : @irreducible_space.{0} (linear_ordered_add_comm_group.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (linear_ordered_add_comm_group.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_23852 (h0 h1 : multiset (uniform_space (mul_one_class (mul_one_class reducibility_hints)))) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_23853 (h0 : group (id (semiring empty))) : is_cyclic (id (semiring empty)) := sorry --non-trivial
lemma new_lemma_23854 (h0 : functor.add_const (topological_space (ordered_comm_monoid linarith.comp)) (finset name)) : @path_connected_space.{0} (ordered_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_monoid.{0} linarith.comp)) (finset.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_23855 (h1 h2 : multiset (simple_graph (add_comm_semigroup enat))) : multiset.subset h1 h2 := sorry --non-trivial
lemma new_lemma_23856 (h0 : topological_space (canonically_ordered_monoid (has_add Type))) : discrete_topology (canonically_ordered_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_23857 (h0 : functor.add_const (function.extfun Type add_monoid) linarith.comp) : @add_monoid.fg.{0} (boolean_algebra.core.{0} pos) (@function.extfun_app.{2 1} Type add_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_monoid.{0}) linarith.comp h0) (boolean_algebra.core.{0} pos))  := sorry --non-trivial
lemma new_lemma_23858 (h1 : group (add_left_cancel_monoid (has_nnnorm to_additive.value_type))) : is_cyclic (add_left_cancel_monoid (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_23859 (h0 : ring (generalized_boolean_algebra (has_neg (has_neg name)))) : is_domain (generalized_boolean_algebra (has_neg (has_neg name))) := sorry --non-trivial
lemma new_lemma_23860 (h0 : topological_space (canonically_ordered_comm_semiring (option (option (option unsigned))))) : preconnected_space (canonically_ordered_comm_semiring (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_23861 (h0 : functor.add_const (list (normed_comm_ring Type)) Type) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_23862 (h0 : uniform_space (has_edist (option (semiring empty)))) : separated_space (has_edist (option (semiring empty))) := sorry --non-trivial
lemma new_lemma_23863 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @discrete_topology.{0} (has_Inf.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (has_Inf.{0} pos)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_23864 (h1 : monoid (with_bot (has_inv to_additive.value_type))) : monoid.fg (with_bot (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_23865 (h0 : function.extfun Type topological_space) : @t1_space.{0} (cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_23866 (h0 : topological_space (encodable linarith.comp_source)) : path_connected_space (encodable linarith.comp_source) := sorry --non-trivial
lemma new_lemma_23867 (h0 : topological_space (has_to_string (boolean_algebra.core environment.implicit_infer_kind))) : totally_separated_space (has_to_string (boolean_algebra.core environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_23868 (h0 : topological_space (has_bot (has_bot pos))) : t1_space (has_bot (has_bot pos)) := sorry --non-trivial
lemma new_lemma_23869 (h0 : functor.add_const (topological_space (left_cancel_monoid unsigned)) unsigned) : @t0_space.{0} (left_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_23870 (h0 : topological_space (add_monoid linarith.comp_source)) : totally_disconnected_space (add_monoid linarith.comp_source) := sorry --non-trivial
lemma new_lemma_23871 (h0 : not (function.extfun Type ring -> false)) : @strong_rank_condition.{0} (complete_semilattice_Sup.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (complete_semilattice_Sup.{0} num))  := sorry --non-trivial
lemma new_lemma_23872 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (distrib_lattice.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 group.{0}) (distrib_lattice.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_23873 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (dlist.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (dlist.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_23874 (h0 : topological_space (add_comm_monoid (has_neg (finset (has_add Type))))) : totally_disconnected_space (add_comm_monoid (has_neg (finset (has_add Type)))) := sorry --non-trivial
lemma new_lemma_23875 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (linear_ordered_comm_group.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_23876 (h0 : functor.comp uniform_space mul_zero_class environment.implicit_infer_kind) : @complete_space.{0} (mul_zero_class.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} uniform_space.{0} mul_zero_class.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_23877 (h0 : topological_space (has_Inf (has_neg (has_neg real)))) : totally_disconnected_space (has_Inf (has_neg (has_neg real))) := sorry --non-trivial
lemma new_lemma_23878 (h0 : not (ring (with_zero fun_info) -> false)) : @rank_condition.{0} (with_zero.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (with_zero.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_23879 (h0 : group (ordered_cancel_add_comm_monoid unsigned)) : group.fg (ordered_cancel_add_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_23880 (h0 : topological_space (monoid_with_zero linarith.comp)) : normal_space (monoid_with_zero linarith.comp) := sorry --non-trivial
lemma new_lemma_23881 (h0 : not (ring (has_lt to_additive.value_type) -> false)) : @is_domain.{0} (has_lt.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (has_lt.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_23882 (h0 : complete_lattice (has_one (semiring unsigned))) : is_compactly_generated (has_one (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_23883 (h0 : not (topological_space (dlist linarith.comp_source) -> false)) : @path_connected_space.{0} (dlist.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (dlist.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_23884 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (random_gen.{0} fun_info) (@function.extfun_app.{2 1} Type monoid.{0} h0 (random_gen.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_23885 (h0 : ring (add_cancel_comm_monoid (has_nnnorm char))) : strong_rank_condition (add_cancel_comm_monoid (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_23886 (h0 : topological_space (comm_group (finset (finset environment.implicit_infer_kind)))) : t0_space (comm_group (finset (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_23887 (h0 : ring (nondiscrete_normed_field enat)) : strong_rank_condition (nondiscrete_normed_field enat) := sorry --non-trivial
lemma new_lemma_23888 (h0 : fin has_zero.zero) : @preconnected_space.{0} (canonically_linear_ordered_monoid.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (canonically_linear_ordered_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_23889 (h0 : functor.add_const (add_group (ordered_comm_monoid Type)) (ring (ring (ring (has_pos_part (ring Type)))))) : @is_add_cyclic.{1} (ordered_comm_monoid.{1} Type) (@functor.add_const.run.{1 1} (add_group.{1} (ordered_comm_monoid.{1} Type)) (ring.{1} (ring.{1} (ring.{1} (has_pos_part.{1} (ring.{1} Type))))) h0)  := sorry --non-trivial
lemma new_lemma_23890 (h0 : semiring (ordered_ring empty)) : is_noetherian_ring (ordered_ring empty) := sorry --non-trivial
lemma new_lemma_23891 (h0 : functor.add_const (group (non_assoc_semiring empty)) unsigned) : @is_simple_group.{0} (non_assoc_semiring.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (non_assoc_semiring.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_23892 (h0 : topological_space (add_comm_semigroup (add_comm_semigroup (add_comm_semigroup ereal)))) : path_connected_space (add_comm_semigroup (add_comm_semigroup (add_comm_semigroup ereal))) := sorry --non-trivial
lemma new_lemma_23893 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_inv.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inv.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_23894 (h0 : group (add_comm_monoid (finset (has_nndist (finset (finset Type)))))) : is_simple_group (add_comm_monoid (finset (has_nndist (finset (finset Type))))) := sorry --non-trivial
lemma new_lemma_23895 (h0 : semiring (finset (ring linarith.comp))) : is_noetherian_ring (finset (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_23896 (h0 : cancel_comm_monoid_with_zero (has_to_string (option pos))) : unique_factorization_monoid (has_to_string (option pos)) := sorry --non-trivial
lemma new_lemma_23897 (h0 : fin has_zero.zero) : @sequential_space.{1} (boolean_algebra.core.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (boolean_algebra.core.{1} Type)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_23898 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (add_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_23899 (h0 : functor.add_const (cancel_comm_monoid_with_zero (ordered_comm_ring real)) (has_Inf real)) : @unique_factorization_monoid.{0} (ordered_comm_ring.{0} real) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (ordered_comm_ring.{0} real)) (has_Inf.{0} real) h0)  := sorry --non-trivial
lemma new_lemma_23900 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (normed_lattice_add_comm_group.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_lattice_add_comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_23901 (h0 : add_monoid (canonically_ordered_comm_semiring (option (option unsigned)))) : add_monoid.fg (canonically_ordered_comm_semiring (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_23902 (h0 : semiring (has_Sup empty)) : is_noetherian_ring (has_Sup empty) := sorry --non-trivial
lemma new_lemma_23903 (h0 : topological_space (boolean_algebra (has_add pos))) : loc_path_connected_space (boolean_algebra (has_add pos)) := sorry --non-trivial
lemma new_lemma_23904 (h0 : functor.add_const (topological_space (ordered_comm_ring name)) Type) : @discrete_topology.{0} (ordered_comm_ring.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (ordered_comm_ring.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_23905 (h0 : functor.add_const (cancel_comm_monoid_with_zero (linear_ordered_field unsigned)) (option unsigned)) : @unique_factorization_monoid.{0} (linear_ordered_field.{0} unsigned) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (linear_ordered_field.{0} unsigned)) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_23906 (h0 : functor.add_const (function.extfun (Type 1) topological_space) pos) : @locally_compact_space.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) pos h0) (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_23907 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @preconnected_space.{0} (sub_neg_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero))) (sub_neg_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_23908 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (boolean_algebra.core.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_23909 (h0 : group (linear_ordered_add_comm_group (has_top linarith.ineq))) : group.fg (linear_ordered_add_comm_group (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_23910 (h0 : ordered_comm_monoid (ring (has_to_string unsigned))) : has_exists_mul_of_le (ring (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_23911 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (semigroup.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} h0 (semigroup.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_23912 (h0 : function.extfun (finset Type) (has_mem.mem (random_gen congr_arg_kind))) : @is_compactly_generated.{0} (random_gen.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (random_gen.{0} congr_arg_kind) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} congr_arg_kind)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_23913 (h0 : group (has_add string_imp)) : group.fg (has_add string_imp) := sorry --non-trivial
lemma new_lemma_23914 (h0 : not (has_mem.mem (linear_ordered_semiring linarith.ineq) has_emptyc.emptyc -> false)) : @path_connected_space.{0} (linear_ordered_semiring.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type topological_space.{0} (linear_ordered_semiring.{0} linarith.ineq) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (linear_ordered_semiring.{0} linarith.ineq) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_23915 (h0 : functor.add_const (ordered_add_comm_monoid (has_pos_part linarith.comp)) linarith.comp) : @archimedean.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_pos_part.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_23916 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (add_left_cancel_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_left_cancel_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_23917 (h0 : finset (has_nndist (finset unsigned))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_23918 (h0 : ordered_comm_monoid (complete_distrib_lattice (finset (has_Inf (ring linarith.comp))))) : has_exists_mul_of_le (complete_distrib_lattice (finset (has_Inf (ring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_23919 (h0 : topological_space (partial_order empty)) : loc_path_connected_space (partial_order empty) := sorry --non-trivial
lemma new_lemma_23920 (h0 : fin has_zero.zero) : @group.fg.{0} (canonically_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type group.{0}) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))) (canonically_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_23921 (h0 : not (complete_lattice (ordered_comm_ring to_additive.value_type) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (ordered_comm_ring.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (complete_lattice.{0} (ordered_comm_ring.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_23922 (h0 : set (has_div (mul_one_class (mul_one_class (mul_one_class string.iterator_imp))))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_23923 (h0 : functor.add_const (add_group (has_to_string linarith.comp)) (normed_comm_ring linarith.comp)) : @is_add_cyclic.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_group.{0} (has_to_string.{0} linarith.comp)) (normed_comm_ring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_23924 (h0 : not (complete_lattice (uniform_space to_additive.value_type) -> false)) : is_compactly_generated (uniform_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_23925 (h0 : function.extfun Type topological_space) : @regular_space.{0} (option.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (option.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_23926 (h0 : ring (random_gen (has_norm (random_gen (measurable_space fun_info))))) : strong_rank_condition (random_gen (has_norm (random_gen (measurable_space fun_info)))) := sorry --non-trivial
lemma new_lemma_23927 (h0 : topological_space (has_one congr_arg_kind)) : preirreducible_space (has_one congr_arg_kind) := sorry --non-trivial
lemma new_lemma_23928 (h0 : semiring (has_zero (ring (finset linarith.comp)))) : is_noetherian_ring (has_zero (ring (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_23929 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (as_linear_order.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (as_linear_order.{0} num))  := sorry --non-trivial
lemma new_lemma_23930 (h0 : not (topological_space (linear_ordered_semiring empty) -> false)) : @locally_compact_space.{0} (linear_ordered_semiring.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_23931 (h0 : topological_space (ordered_comm_monoid (boolean_algebra.core linarith.comp))) : loc_path_connected_space (ordered_comm_monoid (boolean_algebra.core linarith.comp)) := sorry --non-trivial
lemma new_lemma_23932 (h0 : uniform_space (cancel_monoid (has_neg_part Type))) : complete_space (cancel_monoid (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_23933 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (pseudo_metric_space.{0} (has_nndist.{0} name)) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (pseudo_metric_space.{0} (has_nndist.{0} name)))  := sorry --non-trivial
lemma new_lemma_23934 (h0 : cancel_comm_monoid_with_zero (has_zero (has_to_string (add_cancel_monoid name)))) : unique_factorization_monoid (has_zero (has_to_string (add_cancel_monoid name))) := sorry --non-trivial
lemma new_lemma_23935 (h0 : topological_space (topological_space (comm_ring char))) (h1 : group (topological_space.opens (topological_space (comm_ring char)))) : is_cyclic (topological_space.opens (topological_space (comm_ring char))) := sorry --non-trivial
lemma new_lemma_23936 (h0 : topological_space (comm_semigroup (has_pos_part real))) : locally_compact_space (comm_semigroup (has_pos_part real)) := sorry --non-trivial
lemma new_lemma_23937 (h0 : finset (linear_ordered_comm_ring (semiring num))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_23938 (h0 : functor.add_const (semiring (has_nndist Type)) Type) : @is_noetherian_ring.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 1} (semiring.{1} (has_nndist.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_23939 (h0 : function.extfun (Type 1) finset) : finset.nonempty (function.extfun_app h0 (has_add Type)) := sorry --non-trivial
lemma new_lemma_23940 (h0 : topological_space (add_cancel_comm_monoid (has_nnnorm linarith.comp_source))) : t0_space (add_cancel_comm_monoid (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_23941 (h0 : group (linear_ordered_field (has_to_string (pseudo_metric_space pos)))) : is_simple_group (linear_ordered_field (has_to_string (pseudo_metric_space pos))) := sorry --non-trivial
lemma new_lemma_23942 (h0 : topological_space (linear_ordered_semiring (semiring empty))) : preirreducible_space (linear_ordered_semiring (semiring empty)) := sorry --non-trivial
lemma new_lemma_23943 (h0 : group (has_to_string (has_add pos))) : group.fg (has_to_string (has_add pos)) := sorry --non-trivial
lemma new_lemma_23944 (h0 : complete_lattice (div_inv_monoid char)) : is_compactly_generated (div_inv_monoid char) := sorry --non-trivial
lemma new_lemma_23945 (h0 : ordered_add_comm_monoid (boolean_algebra (boolean_algebra name))) : archimedean (boolean_algebra (boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_23946 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @is_domain.{0} (complete_semilattice_Sup.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) ring.{0}) (complete_semilattice_Sup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_23947 (h0 : functor.add_const (complete_lattice (boolean_algebra pos)) environment.implicit_infer_kind) : @complete_lattice.is_Sup_finite_compact.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (boolean_algebra.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_23948 (h0 : functor.add_const (function.extfun Type complete_lattice) linarith.comp) : @complete_lattice.is_Sup_finite_compact.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) linarith.comp h0) (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_23949 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (ring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ring.{0} name))  := sorry --non-trivial
lemma new_lemma_23950 (h0 : functor.add_const (semiring (ordered_comm_ring Type)) name) : @is_noetherian_ring.{1} (ordered_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (semiring.{1} (ordered_comm_ring.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_23951 (h0 : functor.add_const (topological_space (mul_zero_class name)) name) : @normal_space.{0} (mul_zero_class.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_23952 (h0 : monoid (mul_zero_class (has_add name))) : monoid.fg (mul_zero_class (has_add name)) := sorry --non-trivial
lemma new_lemma_23953 (h0 : not (ring (normed_group unsigned) -> false)) : @is_principal_ideal_ring.{0} (normed_group.{0} unsigned) (@classical.by_contradiction'.{1} (ring.{0} (normed_group.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_23954 (h0 : function.extfun nat fin) : @is_add_cyclic.{0} (simple_graph.{0} name) (@matrix.vec_empty.{0} (add_group.{0} (simple_graph.{0} name)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_23955 (h0 : functor.add_const (topological_space (normed_comm_ring linarith.comp)) pos) : @totally_disconnected_space.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_23956 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_star num)) num) : @unique_factorization_monoid.{0} (has_star.{0} num) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_star.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_23957 (h0 : topological_space (topological_space (conditionally_complete_linear_order char))) : path_connected_space (topological_space (conditionally_complete_linear_order char)) := sorry --non-trivial
lemma new_lemma_23958 (h0 : filter (random_gen (semiring congr_arg_kind))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_23959 (h0 : complete_lattice (add_cancel_monoid (has_zero linarith.comp))) : complete_lattice.is_Sup_finite_compact (add_cancel_monoid (has_zero linarith.comp)) := sorry --non-trivial
lemma new_lemma_23960 (h0 : functor.add_const (topological_space (mul_zero_class empty)) congr_arg_kind) : @irreducible_space.{0} (mul_zero_class.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_23961 (h0 : topological_space (sub_neg_monoid (has_neg pos))) : discrete_topology (sub_neg_monoid (has_neg pos)) := sorry --non-trivial
lemma new_lemma_23962 (h0 : uniform_space (mul_one_class (add_comm_semigroup linarith.ineq))) : complete_space (mul_one_class (add_comm_semigroup linarith.ineq)) := sorry --non-trivial
lemma new_lemma_23963 (h0 : finset (metric_space (option (option unsigned)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_23964 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_neg.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_23965 (h0 : not (topological_space (id unsigned) -> false)) : @t0_space.{0} (@id.{2} Type unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (@id.{2} Type unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_23966 (h0 : functor.add_const (ordered_add_comm_monoid (cancel_monoid Type)) (has_neg_part Type)) : @archimedean.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 1} (ordered_add_comm_monoid.{1} (cancel_monoid.{1} Type)) (has_neg_part.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_23967 (h0 : functor.add_const (group (has_zero Type)) (has_to_string Type)) : @group.fg.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 1} (group.{1} (has_zero.{1} Type)) (has_to_string.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_23968 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (add_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_23969 (h0 : add_group (left_cancel_semigroup (semiring (semiring unsigned)))) : is_add_cyclic (left_cancel_semigroup (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_23970 (h0 : group (boolean_algebra (boolean_algebra name))) : group.fg (boolean_algebra (boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_23971 (h0 : semiring (normed_lattice_add_comm_group (has_add (has_add (has_Inf (has_add real)))))) : is_noetherian_ring (normed_lattice_add_comm_group (has_add (has_add (has_Inf (has_add real))))) := sorry --non-trivial
lemma new_lemma_23972 (h0 : list Prop) (h1 : ne h0 list.nil) : list.last h0 h1 := sorry --non-trivial
lemma new_lemma_23973 (h0 : ring (has_neg (finset (semigroup pos)))) : is_domain (has_neg (finset (semigroup pos))) := sorry --non-trivial
lemma new_lemma_23974 (h0 : topological_space (ordered_comm_ring (has_pos_part real))) : normal_space (ordered_comm_ring (has_pos_part real)) := sorry --non-trivial
lemma new_lemma_23975 (h1 : ring (has_inv to_additive.value_type)) : strong_rank_condition (has_inv to_additive.value_type) := sorry --non-trivial
lemma new_lemma_23976 (h0 : has_le (has_pos_part (has_pos_part (has_pos_part linarith.comp)))) (h1 : bounded_order (has_pos_part (has_pos_part (has_pos_part linarith.comp)))) : is_simple_order (has_pos_part (has_pos_part (has_pos_part linarith.comp))) := sorry --non-trivial
lemma new_lemma_23977 (h0 : complete_lattice (uniform_space linarith.comp_source)) : complete_lattice.is_Sup_finite_compact (uniform_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_23978 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} (normed_lattice_add_comm_group.{0} (normed_lattice_add_comm_group.{0} real)) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) (normed_lattice_add_comm_group.{0} (normed_lattice_add_comm_group.{0} real)))  := sorry --non-trivial
lemma new_lemma_23979 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (generalized_boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (generalized_boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_23980 (h3 : add_group (nondiscrete_normed_field enat)) : is_add_cyclic (nondiscrete_normed_field enat) := sorry --non-trivial
lemma new_lemma_23981 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @preconnected_space.{0} (generalized_boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (generalized_boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_23982 (h0 : functor.add_const (topological_space (complete_distrib_lattice unsigned)) name) : @locally_compact_space.{0} (complete_distrib_lattice.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_23983 (h0 : not (add_monoid (semiring empty) -> false)) : @add_monoid.fg.{0} (semiring.{0} empty) (@classical.by_contradiction'.{1} (add_monoid.{0} (semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_23984 (h0 : topological_space (has_top (has_top empty))) : irreducible_space (has_top (has_top empty)) := sorry --non-trivial
lemma new_lemma_23985 (h0 : functor.add_const (functor.comp group comm_group Type) Type) : @is_simple_group.{1} (comm_group.{1} Type) (@functor.comp.run.{1 1 1} group.{1} comm_group.{1} Type (@functor.add_const.run.{1 1} (functor.comp.{1 1 1} group.{1} comm_group.{1} Type) Type h0))  := sorry --non-trivial
lemma new_lemma_23986 (h0 : functor.add_const (ring (normed_comm_ring linarith.comp)) Type) : @is_domain.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (ring.{0} (normed_comm_ring.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_23987 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (linear_order.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} h0 (linear_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_23988 (h1 : not (add_group (with_zero char) -> false)) : @is_add_cyclic.{0} (with_zero.{0} char) (@classical.by_contradiction'.{1} (add_group.{0} (with_zero.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_23989 (h0 : uniform_space (semiring (random_gen (random_gen fun_info)))) : complete_space (semiring (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_23990 (h0 : complete_lattice (complete_distrib_lattice (add_comm_monoid Type))) : complete_lattice.is_Sup_finite_compact (complete_distrib_lattice (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_23991 (h0 : filter (option unsigned)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_23992 (h1 : group (semi_normed_ring to_additive.value_type)) : is_cyclic (semi_normed_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_23993 (h0 : group (has_edist (semiring empty))) : normalizer_condition (has_edist (semiring empty)) := sorry --non-trivial
lemma new_lemma_23994 (h1 : ring (division_ring string_imp)) : is_domain (division_ring string_imp) := sorry --non-trivial
lemma new_lemma_23995 (h0 : topological_space (has_edist unsigned)) : totally_separated_space (has_edist unsigned) := sorry --non-trivial
lemma new_lemma_23996 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @sequential_space.{0} (simple_graph.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (simple_graph.{0} pos))  := sorry --non-trivial
lemma new_lemma_23997 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_top.{0} (has_ssubset.{0} to_additive.value_type)) (@function.extfun_app.{2 1} Type group.{0} h0 (has_top.{0} (has_ssubset.{0} to_additive.value_type)))  := sorry --non-trivial
lemma new_lemma_23998 (h0 : group (denumerable (has_inv linarith.ineq))) : normalizer_condition (denumerable (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_23999 (h0 : not (function.extfun Type topological_space -> false)) : @totally_disconnected_space.{0} (has_compl.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_compl.{0} linarith.ineq))  := sorry --non-trivial
