import imports
lemma new_lemma_40000 (h0 : functor.add_const (ordered_add_comm_monoid (complete_linear_order empty)) congr_arg_kind) : @archimedean.{0} (complete_linear_order.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (complete_linear_order.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_40001 (h0 : functor.add_const (semiring (add_cancel_monoid Type)) pos) : @is_noetherian_ring.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (semiring.{1} (add_cancel_monoid.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_40002 (h0 : functor.add_const (add_group (ordered_comm_ring Type)) linarith.comp) : @is_add_cyclic.{1} (ordered_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (add_group.{1} (ordered_comm_ring.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_40003 (h2 : list (random_gen (random_gen (random_gen to_additive.value_type)))) : list.nodup h2 := sorry --non-trivial
lemma new_lemma_40004 (h0 : add_monoid (mul_zero_class (semiring (semiring unsigned)))) : add_monoid.fg (mul_zero_class (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_40005 (h0 : topological_space (ring (comm_group (boolean_algebra name)))) : discrete_topology (ring (comm_group (boolean_algebra name))) := sorry --non-trivial
lemma new_lemma_40006 (h0 : uniform_space (has_to_string name)) : separated_space (has_to_string name) := sorry --non-trivial
lemma new_lemma_40007 (h0 : functor.add_const (function.extfun Type topological_space) environment.implicit_infer_kind) : @sequential_space.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) environment.implicit_infer_kind h0) (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_40008 (h0 : topological_space (random_gen (has_inv (random_gen to_additive.value_type)))) : path_connected_space (random_gen (has_inv (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_40009 (h2 : ring to_additive.value_type) : rank_condition to_additive.value_type := sorry --non-trivial
lemma new_lemma_40010 (h1 : uniform_space (has_nnnorm (random_gen char))) : complete_space (has_nnnorm (random_gen char)) := sorry --non-trivial
lemma new_lemma_40011 (h0 : monoid (has_zero unsigned)) : monoid.fg (has_zero unsigned) := sorry --non-trivial
lemma new_lemma_40012 (h0 : functor.add_const (add_monoid (left_cancel_monoid unsigned)) empty) : @add_monoid.fg.{0} (left_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (add_monoid.{0} (left_cancel_monoid.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_40013 (h0 : add_group (measurable_space empty)) : is_add_cyclic (measurable_space empty) := sorry --non-trivial
lemma new_lemma_40014 (h0 : functor.add_const (ring (has_zero pos)) (has_neg environment.implicit_infer_kind)) : @is_domain.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_zero.{0} pos)) (has_neg.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_40015 (h0 : ordered_add_comm_monoid (monoid pos)) : archimedean (monoid pos) := sorry --non-trivial
lemma new_lemma_40016 (h0 : topological_space (ordered_cancel_add_comm_monoid (option (option (option ennreal))))) : t1_space (ordered_cancel_add_comm_monoid (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_40017 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (has_one.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_40018 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (canonically_linear_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type ring.{0} h0 (canonically_linear_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_40019 (h0 : topological_space (cancel_monoid (has_nndist ennreal))) : normal_space (cancel_monoid (has_nndist ennreal)) := sorry --non-trivial
lemma new_lemma_40020 (h0 : list (ordered_comm_monoid linarith.comp)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_40021 (h0 : heq (mul_zero_one_class string_imp) (dlist to_additive.value_type)) (h1 : not (topological_space (mul_zero_one_class string_imp) -> false)) : @locally_compact_space.{0} (dlist.{0} to_additive.value_type) (@heq.elim.{2 1} Type (mul_zero_one_class.{0} string_imp) topological_space.{0} (dlist.{0} to_additive.value_type) h0 (@classical.by_contradiction'.{1} (topological_space.{0} (mul_zero_one_class.{0} string_imp)) h1))  := sorry --non-trivial
lemma new_lemma_40022 (h0 : not (topological_space (normed_group unsigned) -> false)) : @t1_space.{0} (normed_group.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_group.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_40023 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (ordered_comm_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_40024 (h0 : prod ereal ereal) : set.diagonal ereal h0 := sorry --non-trivial
lemma new_lemma_40025 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_Inf pos)) (has_neg name)) : @unique_factorization_monoid.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_Inf.{0} pos)) (has_neg.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_40026 (h0 : complete_lattice (has_to_string (option ennreal))) : is_atomistic (has_to_string (option ennreal)) := sorry --non-trivial
lemma new_lemma_40027 (h0 : filter (random_gen (semiring (has_norm congr_arg_kind)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_40028 (h0 : topological_space (has_to_string (has_to_string Type))) : loc_path_connected_space (has_to_string (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_40029 (h0 : cancel_comm_monoid_with_zero (add_comm_monoid linarith.comp)) : unique_factorization_monoid (add_comm_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_40030 (h0 : topological_space (add_cancel_monoid (ring linarith.comp))) : t1_space (add_cancel_monoid (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_40031 (h0 : complete_lattice (uniform_space string_imp)) : complete_lattice.is_Sup_finite_compact (uniform_space string_imp) := sorry --non-trivial
lemma new_lemma_40032 (h0 : complete_lattice (sub_neg_monoid (has_bot (has_Inf real)))) : is_compactly_generated (sub_neg_monoid (has_bot (has_Inf real))) := sorry --non-trivial
lemma new_lemma_40033 (h0 : topological_space (mul_zero_class (has_add (has_add (has_to_string name))))) : discrete_topology (mul_zero_class (has_add (has_add (has_to_string name)))) := sorry --non-trivial
lemma new_lemma_40034 (h1 : add_group (denumerable string_imp)) : is_add_cyclic (denumerable string_imp) := sorry --non-trivial
lemma new_lemma_40035 (h0 : functor.add_const (list (has_neg_part name)) Type) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_40036 (h0 : complete_lattice (ordered_comm_monoid real)) : complete_lattice.is_Sup_finite_compact (ordered_comm_monoid real) := sorry --non-trivial
lemma new_lemma_40037 (h0 : topological_space (has_Inf (has_neg name))) : preconnected_space (has_Inf (has_neg name)) := sorry --non-trivial
lemma new_lemma_40038 (h0 : topological_space (has_neg_part (cancel_monoid pos))) : locally_compact_space (has_neg_part (cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_40039 (h0 : topological_space (distrib_lattice string_imp)) : t0_space (distrib_lattice string_imp) := sorry --non-trivial
lemma new_lemma_40040 (h0 : functor.add_const (list (has_pos_part name)) linarith.comp) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_40041 (h0 : uniform_space (pseudo_metric_space empty)) : separated_space (pseudo_metric_space empty) := sorry --non-trivial
lemma new_lemma_40042 (h0 : has_add Type) : palindrome (list.ret h0) := sorry --non-trivial
lemma new_lemma_40043 (h0 : function.extfun (finset ((Type -> Type) -> Type 1)) (has_mem.mem (function.extfun Type))) : @locally_compact_space.{0} (normed_group.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@finset.pi.empty.{2 1} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) (function.extfun.{2 1} Type) (@function.extfun_app.{3 0} (finset.{2} ((Type → Type) → Type 1)) (@has_mem.mem.{2 2} ((Type → Type) → Type 1) (finset.{2} ((Type → Type) → Type 1)) (@finset.has_mem.{2} ((Type → Type) → Type 1)) (function.extfun.{2 1} Type)) h0 (@has_emptyc.emptyc.{2} (finset.{2} ((Type → Type) → Type 1)) (@finset.has_emptyc.{2} ((Type → Type) → Type 1))))) topological_space.{0}) (normed_group.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_40044 (h0 : ring (has_append (non_assoc_semiring char))) : rank_condition (has_append (non_assoc_semiring char)) := sorry --non-trivial
lemma new_lemma_40045 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @discrete_topology.{0} (ordered_comm_ring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (ordered_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_40046 (h0 : has_mem.mem (with_bot fun_info) has_emptyc.emptyc) : @group.fg.{0} (with_bot.{0} fun_info) (@finset.pi.empty.{1 0} Type group.{0} (with_bot.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_40047 (h0 : group (semi_normed_comm_ring (random_gen complex))) : group.fg (semi_normed_comm_ring (random_gen complex)) := sorry --non-trivial
lemma new_lemma_40048 (h0 : group (has_neg_part (finset pos))) : normalizer_condition (has_neg_part (finset pos)) := sorry --non-trivial
lemma new_lemma_40049 (h1 : measurable_space (linear_ordered_comm_group_with_zero linarith.comp_source)) (h2 : filter (linear_ordered_comm_group_with_zero linarith.comp_source)) : filter.is_measurably_generated h2 := sorry --non-trivial
lemma new_lemma_40050 (h0 : topological_space (topological_space (random_gen (random_gen string_imp)))) : locally_compact_space (topological_space (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_40051 (h0 : functor.add_const (topological_space (add_cancel_monoid Type)) pos) : @totally_separated_space.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_cancel_monoid.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_40052 (h0 : ordered_add_comm_monoid (add_right_cancel_monoid empty)) : archimedean (add_right_cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_40053 (h0 : ring (complete_semilattice_Sup (random_gen fun_info))) : strong_rank_condition (complete_semilattice_Sup (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_40054 (h0 : has_coe (mul_one_class (mul_one_class (add_comm_semigroup linarith.ineq))) Prop) (h1 : mul_one_class (mul_one_class (add_comm_semigroup linarith.ineq))) : @coe_b.{1 1} (mul_one_class.{0} (mul_one_class.{0} (add_comm_semigroup.{0} linarith.ineq))) Prop h0 h1  := sorry --non-trivial
lemma new_lemma_40055 (h0 : ordered_comm_monoid (has_neg_part (comm_group unsigned))) : has_exists_mul_of_le (has_neg_part (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_40056 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem complete_lattice)) : @is_atomistic.{0} empty (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) complete_lattice.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) empty)  := sorry --non-trivial
lemma new_lemma_40057 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_40058 (h0 : topological_space (canonically_linear_ordered_monoid name)) : locally_compact_space (canonically_linear_ordered_monoid name) := sorry --non-trivial
lemma new_lemma_40059 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (linear_ordered_add_comm_group.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (linear_ordered_add_comm_group.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_40060 (h0 : functor.add_const (ring (has_neg Type)) (ring pos)) : @strong_rank_condition.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_neg.{1} Type)) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_40061 (h0 : ordered_comm_monoid (has_neg_part (option (option (option (option pos)))))) : has_exists_mul_of_le (has_neg_part (option (option (option (option pos))))) := sorry --non-trivial
lemma new_lemma_40062 (h0 : ring (bin_tree (has_top empty))) : rank_condition (bin_tree (has_top empty)) := sorry --non-trivial
lemma new_lemma_40063 (h0 : semiring (has_zero (ring environment.implicit_infer_kind))) : is_noetherian_ring (has_zero (ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_40064 (h0 : group (add_cancel_monoid (option (option (semiring empty))))) : is_cyclic (add_cancel_monoid (option (option (semiring empty)))) := sorry --non-trivial
lemma new_lemma_40065 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (non_assoc_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (non_assoc_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_40066 (h0 : topological_space (canonically_ordered_comm_semiring (has_to_string unsigned))) : normal_space (canonically_ordered_comm_semiring (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_40067 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (canonically_ordered_comm_semiring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_ordered_comm_semiring.{0} pos))  := sorry --non-trivial
lemma new_lemma_40068 (h0 : group (has_zero (option pos))) : is_simple_group (has_zero (option pos)) := sorry --non-trivial
lemma new_lemma_40069 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_emptyc.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_emptyc.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_40070 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_40071 (h0 : complete_lattice (plift (option (option (option unsigned))))) : is_atomistic (plift (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_40072 (h1 : not (has_mem.mem (with_one num) has_emptyc.emptyc -> false)) : @irreducible_space.{0} (with_one.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_one.{0} num) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_one.{0} num) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h1))  := sorry --non-trivial
lemma new_lemma_40073 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_union.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_union.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_40074 (h0 : set (semi_normed_comm_ring string_imp)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_40075 (h0 : complete_lattice (linear_ordered_field pos)) : is_compactly_generated (linear_ordered_field pos) := sorry --non-trivial
lemma new_lemma_40076 (h0 : topological_space (boolean_algebra.core (boolean_algebra name))) : preirreducible_space (boolean_algebra.core (boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_40077 (h0 : topological_space (mul_zero_class environment.implicit_infer_kind)) : sequential_space (mul_zero_class environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_40078 (h0 : topological_space (ordered_comm_ring (sub_neg_monoid name))) : preconnected_space (ordered_comm_ring (sub_neg_monoid name)) := sorry --non-trivial
lemma new_lemma_40079 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (ordered_comm_ring.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_ring.{0} real))  := sorry --non-trivial
lemma new_lemma_40080 (h1 : complete_lattice (comm_ring (random_gen (random_gen string_imp)))) : complete_lattice.is_Sup_finite_compact (comm_ring (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_40081 (h0 : function.extfun Type group) : @is_cyclic.{0} (normed_group.{0} string_imp) (@function.extfun_app.{2 1} Type group.{0} h0 (normed_group.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_40082 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (normed_linear_ordered_group.{0} (semiring.{0} congr_arg_kind)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_linear_ordered_group.{0} (semiring.{0} congr_arg_kind)))  := sorry --non-trivial
lemma new_lemma_40083 (h0 : complete_lattice (add_comm_monoid (has_add linarith.comp))) : complete_lattice.is_Sup_finite_compact (add_comm_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_40084 (h0 : not (semiring (has_sub empty) -> false)) : @is_noetherian_ring.{0} (has_sub.{0} empty) (@classical.by_contradiction'.{1} (semiring.{0} (has_sub.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_40085 (h0 : set (mul_one_class reducibility_hints)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_40086 (h0 : group real) : is_cyclic real := sorry --non-trivial
lemma new_lemma_40087 (h0 : topological_space (semigroup (comm_group ennreal))) : totally_separated_space (semigroup (comm_group ennreal)) := sorry --non-trivial
lemma new_lemma_40088 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @complete_lattice.is_Sup_finite_compact.{0} (with_one.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) complete_lattice.{0}) (with_one.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_40089 (h0 : fin has_zero.zero) : @loc_path_connected_space.{0} (boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_40090 (h1 : ring (div_inv_monoid (random_gen string_imp))) : strong_rank_condition (div_inv_monoid (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_40091 (h0 : monoid (with_bot (random_gen (has_inv (random_gen linarith.ineq))))) : monoid.fg (with_bot (random_gen (has_inv (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_40092 (h1 : filter (normed_group (has_top linarith.comp_source))) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_40093 (h0 : finset (has_to_string (has_neg (has_neg name)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_40094 (h0 : ring (has_top (has_norm (has_norm num)))) : is_domain (has_top (has_norm (has_norm num))) := sorry --non-trivial
lemma new_lemma_40095 (h0 : topological_space (comm_group ennreal)) : preconnected_space (comm_group ennreal) := sorry --non-trivial
lemma new_lemma_40096 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (has_pos_part.{0} real) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_pos_part.{0} real))  := sorry --non-trivial
lemma new_lemma_40097 (h0 : functor.add_const (filter (comm_group Type)) name) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_40098 (h0 : topological_space (as_linear_order congr_arg_kind)) : t0_space (as_linear_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_40099 (h0 : topological_space (has_top (semiring congr_arg_kind))) : discrete_topology (has_top (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_40100 (h1 : function.extfun Type group) : @normalizer_condition.{0} (measurable_space.{0} string_imp) (@function.extfun_app.{2 1} Type group.{0} h1 (measurable_space.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_40101 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h1 list) (normed_group string_imp)) := sorry --non-trivial
lemma new_lemma_40102 (h1 : ring (topological_space (random_gen char))) : rank_condition (topological_space (random_gen char)) := sorry --non-trivial
lemma new_lemma_40103 (h0 : topological_space (option (option pos))) : regular_space (option (option pos)) := sorry --non-trivial
lemma new_lemma_40104 (h0 : functor.add_const (ring (normed_comm_ring linarith.comp)) Type) : @is_principal_ideal_ring.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (ring.{0} (normed_comm_ring.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_40105 (h0 : ring (ordered_comm_monoid congr_arg_kind)) : rank_condition (ordered_comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_40106 (h0 : group (has_nndist (has_add pos))) : is_cyclic (has_nndist (has_add pos)) := sorry --non-trivial
lemma new_lemma_40107 (h0 : add_monoid (cancel_monoid environment.implicit_infer_kind)) : add_monoid.fg (cancel_monoid environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_40108 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (is_R_or_C.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (is_R_or_C.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_40109 (h0 : functor.add_const (cancel_comm_monoid_with_zero (generalized_boolean_algebra Type)) Type) : @unique_factorization_monoid.{1} (generalized_boolean_algebra.{1} Type) (@functor.add_const.run.{1 1} (cancel_comm_monoid_with_zero.{1} (generalized_boolean_algebra.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_40110 (h0 : topological_space (semiring empty)) : totally_separated_space (semiring empty) := sorry --non-trivial
lemma new_lemma_40111 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (complete_linear_order congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_40112 (h0 : topological_space (add_cancel_monoid (has_nndist (has_pos_part pos)))) : locally_compact_space (add_cancel_monoid (has_nndist (has_pos_part pos))) := sorry --non-trivial
lemma new_lemma_40113 (h0 : function.extfun Type topological_space) : @t0_space.{0} (finset.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} num))  := sorry --non-trivial
lemma new_lemma_40114 (h0 : topological_space (has_neg_part (normed_comm_ring Type))) : path_connected_space (has_neg_part (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_40115 (h0 : topological_space (finset (has_Inf (finset (has_neg Type))))) : preirreducible_space (finset (has_Inf (finset (has_neg Type)))) := sorry --non-trivial
lemma new_lemma_40116 (h0 : functor.add_const (ordered_add_comm_monoid (add_cancel_monoid pos)) name) : @archimedean.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (add_cancel_monoid.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_40117 (h0 : topological_space (with_bot string_imp)) : totally_separated_space (with_bot string_imp) := sorry --non-trivial
lemma new_lemma_40118 (h0 : fin has_zero.zero) : @preirreducible_space.{0} (simple_graph.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (simple_graph.{0} name))  := sorry --non-trivial
lemma new_lemma_40119 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @strong_rank_condition.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ring.{1}) (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_40120 (h0 : not (function.extfun Type ring -> false)) : @is_principal_ideal_ring.{0} (complete_semilattice_Sup.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (complete_semilattice_Sup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_40121 (h0 : not (topological_space (has_star num) -> false)) : @path_connected_space.{0} (has_star.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (has_star.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_40122 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (normed_group.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_group.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_40123 (h0 : ring (has_neg (has_pos_part pos))) : is_principal_ideal_ring (has_neg (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_40124 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_add_cyclic.{1} (has_pos_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_group.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 add_group.{1}) (has_pos_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_40125 (h0 : ring (has_abs (random_gen char))) : rank_condition (has_abs (random_gen char)) := sorry --non-trivial
lemma new_lemma_40126 (h0 : function.extfun Type group) : @group.fg.{0} (has_top.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (has_top.{0} empty))  := sorry --non-trivial
lemma new_lemma_40127 (h0 : ring (fintype string_imp)) : strong_rank_condition (fintype string_imp) := sorry --non-trivial
lemma new_lemma_40128 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_edist.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_edist.{0} empty))  := sorry --non-trivial
lemma new_lemma_40129 (h0 : group (comm_ring (has_nnnorm (random_gen (random_gen (has_nnnorm fun_info)))))) : group.fg (comm_ring (has_nnnorm (random_gen (random_gen (has_nnnorm fun_info))))) := sorry --non-trivial
lemma new_lemma_40130 (h0 : functor.add_const (ordered_add_comm_monoid (canonically_ordered_comm_semiring ennreal)) Type) : @archimedean.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@functor.add_const.run.{0 1} (ordered_add_comm_monoid.{0} (canonically_ordered_comm_semiring.{0} ennreal)) Type h0)  := sorry --non-trivial
lemma new_lemma_40131 (h0 : ring (semigroup (has_to_string (has_to_string (has_neg_part name))))) : is_domain (semigroup (has_to_string (has_to_string (has_neg_part name)))) := sorry --non-trivial
lemma new_lemma_40132 (h0 : group (topological_space (mul_one_class fun_info))) : is_cyclic (topological_space (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_40133 (h0 : group (comm_ring (normed_field reducibility_hints))) : is_cyclic (comm_ring (normed_field reducibility_hints)) := sorry --non-trivial
lemma new_lemma_40134 (h0 : topological_space (add_comm_monoid (normed_comm_ring name))) : path_connected_space (add_comm_monoid (normed_comm_ring name)) := sorry --non-trivial
lemma new_lemma_40135 (h0 : topological_space (linear_ordered_add_comm_group string_imp)) : irreducible_space (linear_ordered_add_comm_group string_imp) := sorry --non-trivial
lemma new_lemma_40136 (h0 : topological_space (has_norm (has_top num))) : path_connected_space (has_norm (has_top num)) := sorry --non-trivial
lemma new_lemma_40137 (h0 : add_monoid (boolean_algebra.core Type)) : add_monoid.fg (boolean_algebra.core Type) := sorry --non-trivial
lemma new_lemma_40138 (h0 : has_mem.mem (measurable_space linarith.comp) has_emptyc.emptyc) : @totally_disconnected_space.{0} (measurable_space.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (measurable_space.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_40139 (h0 : list (ordered_comm_monoid pos)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_40140 (h0 : complete_lattice (fintype (has_ssubset (random_gen (denumerable linarith.ineq))))) : is_compactly_generated (fintype (has_ssubset (random_gen (denumerable linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_40141 (h0 : list (has_nndist (has_nndist Type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_40142 (h0 : function.extfun nat fin) : @normal_space.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@matrix.vec_empty.{2} (function.extfun.{3 2} (Type 1) topological_space.{1}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_40143 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_40144 (h0 : topological_space (has_compl (random_gen (random_gen linarith.ineq)))) : totally_disconnected_space (has_compl (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_40145 (h1 : uniform_space (with_zero (has_nnnorm (has_nnnorm (has_nnnorm to_additive.value_type))))) : complete_space (with_zero (has_nnnorm (has_nnnorm (has_nnnorm to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_40146 (h0 : has_mem.mem (complete_semilattice_Sup (has_top num)) has_emptyc.emptyc) : @path_connected_space.{0} (complete_semilattice_Sup.{0} (has_top.{0} num)) (@finset.pi.empty.{1 0} Type topological_space.{0} (complete_semilattice_Sup.{0} (has_top.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_40147 (h0 : ring (normed_comm_ring (has_to_string pos))) : rank_condition (normed_comm_ring (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_40148 (h0 : functor.add_const (prod (option num) (option num)) congr_arg_kind) : id_rel (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_40149 (h1 : not (topological_space (metric_space linarith.comp) -> false)) : @discrete_topology.{0} (metric_space.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (metric_space.{0} linarith.comp)) h1)  := sorry --non-trivial
lemma new_lemma_40150 (h0 : uniform_space (encodable (random_gen linarith.ineq))) : complete_space (encodable (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_40151 (h0 : not (add_group (monoid char) -> false)) : @is_add_cyclic.{0} (monoid.{0} char) (@classical.by_contradiction'.{1} (add_group.{0} (monoid.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_40152 (h0 : functor.add_const (topological_space (boolean_algebra.core linarith.comp)) linarith.comp) : @regular_space.{0} (boolean_algebra.core.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_40153 (h1 : not (complete_lattice linarith.comp_source -> false)) : @is_compactly_generated.{0} linarith.comp_source (@classical.by_contradiction'.{1} (complete_lattice.{0} linarith.comp_source) h1)  := sorry --non-trivial
lemma new_lemma_40154 (h0 : functor.add_const (monoid (canonically_ordered_comm_semiring empty)) (option (option (option empty)))) : @monoid.fg.{0} (canonically_ordered_comm_semiring.{0} empty) (@functor.add_const.run.{0 0} (monoid.{0} (canonically_ordered_comm_semiring.{0} empty)) (option.{0} (option.{0} (option.{0} empty))) h0)  := sorry --non-trivial
lemma new_lemma_40155 (h0 : not (topological_space (non_unital_non_assoc_semiring reducibility_hints) -> false)) : @totally_disconnected_space.{0} (non_unital_non_assoc_semiring.{0} reducibility_hints) (@classical.by_contradiction'.{1} (topological_space.{0} (non_unital_non_assoc_semiring.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_40156 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (linear_ordered_comm_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (linear_ordered_comm_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_40157 (h0 : filter (has_to_string environment.implicit_infer_kind)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_40158 (h0 : list (distrib_lattice (has_ssubset fun_info))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_40159 (h0 : function.extfun Type topological_space) : @t0_space.{0} (pseudo_metric_space.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (pseudo_metric_space.{0} num))  := sorry --non-trivial
lemma new_lemma_40160 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (has_bot.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_bot.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_40161 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (bin_tree.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (bin_tree.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_40162 (h0 : uniform_space (generalized_boolean_algebra (finset (has_add linarith.comp)))) : complete_space (generalized_boolean_algebra (finset (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_40163 (h0 : functor.add_const (function.extfun Type ring) pos) : @is_principal_ideal_ring.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) pos h0) (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_40164 (h0 : functor.add_const (topological_space (has_nndist linarith.comp)) linarith.comp) : @locally_compact_space.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_40165 (h0 : topological_space (semi_normed_comm_ring (has_nnnorm (has_nnnorm char)))) : t0_space (semi_normed_comm_ring (has_nnnorm (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_40166 (h0 : topological_space (canonically_ordered_monoid pos)) : sequential_space (canonically_ordered_monoid pos) := sorry --non-trivial
lemma new_lemma_40167 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_Sup.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_Sup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_40168 (h0 : functor.add_const (monoid (cancel_monoid pos)) name) : @monoid.fg.{0} (cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (monoid.{0} (cancel_monoid.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_40169 (h0 : functor.add_const (complete_lattice (boolean_algebra linarith.comp)) name) : @complete_lattice.is_Sup_finite_compact.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (boolean_algebra.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_40170 (h0 : topological_space (preorder (option empty))) : path_connected_space (preorder (option empty)) := sorry --non-trivial
lemma new_lemma_40171 (h0 : complete_lattice (has_append char)) : complete_lattice.is_Sup_finite_compact (has_append char) := sorry --non-trivial
lemma new_lemma_40172 (h0 : complete_lattice (has_pos_part (has_pos_part (has_Inf real)))) : is_compactly_generated (has_pos_part (has_pos_part (has_Inf real))) := sorry --non-trivial
lemma new_lemma_40173 (h0 : functor.add_const (topological_space (add_comm_monoid name)) linarith.comp) : @preirreducible_space.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_40174 (h0 : not (function.extfun Type group -> false)) : @group.fg.{0} (add_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (add_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_40175 (h0 : finset (monoid_with_zero (option pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_40176 (h1 : has_lt (mul_one_class string.iterator_imp)) : no_max_order (mul_one_class string.iterator_imp) := sorry --non-trivial
lemma new_lemma_40177 (h0 : group (mul_zero_class (semiring (semiring unsigned)))) : normalizer_condition (mul_zero_class (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_40178 (h0 : topological_space (sub_neg_monoid (has_neg pos))) : preirreducible_space (sub_neg_monoid (has_neg pos)) := sorry --non-trivial
lemma new_lemma_40179 (h0 : not (complete_lattice (normed_group empty) -> false)) : @is_atomistic.{0} (normed_group.{0} empty) (@classical.by_contradiction'.{1} (complete_lattice.{0} (normed_group.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_40180 (h0 : list (ordered_comm_monoid (has_Inf real))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_40181 (h0 : add_monoid (add_cancel_monoid (finset pos))) : add_monoid.fg (add_cancel_monoid (finset pos)) := sorry --non-trivial
lemma new_lemma_40182 (h0 : ring (denumerable (random_gen (random_gen (comm_ring char))))) : rank_condition (denumerable (random_gen (random_gen (comm_ring char)))) := sorry --non-trivial
lemma new_lemma_40183 (h0 : topological_space (has_div linarith.ineq)) : t0_space (has_div linarith.ineq) := sorry --non-trivial
lemma new_lemma_40184 (h0 : finset (has_sub num)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_40185 (h0 : list (has_to_string (has_neg (has_to_string Type)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_40186 (h0 : topological_space (encodable (has_nnnorm (has_nnnorm linarith.comp_source)))) : path_connected_space (encodable (has_nnnorm (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_40187 (h0 : functor.add_const (topological_space (plift unsigned)) congr_arg_kind) : @locally_compact_space.{1} (plift.{1} unsigned) (@functor.add_const.run.{1 0} (topological_space.{1} (plift.{1} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_40188 (h0 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} (complete_semilattice_Sup.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h0) (complete_semilattice_Sup.{0} empty))  := sorry --non-trivial
lemma new_lemma_40189 (h0 : topological_space (has_one (random_gen reducibility_hints))) : totally_disconnected_space (has_one (random_gen reducibility_hints)) := sorry --non-trivial
lemma new_lemma_40190 (h0 : group (ring (has_nndist pos))) : group.fg (ring (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_40191 (h0 : fin has_zero.zero) : @locally_compact_space.{0} (has_pos_part.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_pos_part.{0} real))  := sorry --non-trivial
lemma new_lemma_40192 (h1 : not (add_group (semi_normed_ring string_imp) -> false)) : @is_add_cyclic.{0} (semi_normed_ring.{0} string_imp) (@classical.by_contradiction'.{1} (add_group.{0} (semi_normed_ring.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_40193 (h0 : not (ring (semi_normed_comm_ring to_additive.value_type) -> false)) : @strong_rank_condition.{0} (semi_normed_comm_ring.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (semi_normed_comm_ring.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_40194 (h0 : functor.add_const (cancel_comm_monoid_with_zero (ring unsigned)) pos) : @unique_factorization_monoid.{0} (ring.{0} unsigned) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (ring.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_40195 (h0 : group (id (semiring (semiring empty)))) : is_cyclic (id (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_40196 (h6 : topological_space (topological_space fun_info)) : t0_space (topological_space fun_info) := sorry --non-trivial
lemma new_lemma_40197 (h0 : topological_space (has_neg_part Type)) : sequential_space (has_neg_part Type) := sorry --non-trivial
lemma new_lemma_40198 (h0 : topological_space (add_cancel_monoid unsigned)) : totally_disconnected_space (add_cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_40199 (h1 : add_group (has_add (has_nnnorm (has_nnnorm char)))) : is_add_cyclic (has_add (has_nnnorm (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_40200 (h0 : functor.add_const (function.extfun (Type 1) complete_lattice) Type) : @is_atomistic.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) complete_lattice.{1}) Type h0) (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_40201 (h0 : list (ring (has_add (has_nndist name)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_40202 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_40203 (h0 : filter (omega_complete_partial_order (option (semiring (option unsigned))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_40204 (h0 : complete_lattice (has_compl (mul_one_class (mul_one_class enat)))) : is_compactly_generated (has_compl (mul_one_class (mul_one_class enat))) := sorry --non-trivial
lemma new_lemma_40205 (h0 : uniform_space (semi_normed_ring linarith.comp_source)) : complete_space (semi_normed_ring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_40206 (h0 : list (has_add (finset Type))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_40207 (h0 : topological_space (with_one (has_top (has_top linarith.ineq)))) : irreducible_space (with_one (has_top (has_top linarith.ineq))) := sorry --non-trivial
lemma new_lemma_40208 (h0 : functor.add_const (topological_space (normed_comm_ring linarith.comp)) environment.implicit_infer_kind) : @topological_space.separable_space.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_40209 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem uniform_space)) : @complete_space.{0} real.angle (@function.extfun_app.{2 1} Type uniform_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) uniform_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) uniform_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) real.angle)  := sorry --non-trivial
lemma new_lemma_40210 (h0 : functor.add_const (ordered_add_comm_monoid (ordered_comm_group empty)) empty) : @archimedean.{0} (ordered_comm_group.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (ordered_comm_group.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_40211 (h0 h1 : multiset (nondiscrete_normed_field fun_info)) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_40212 (h0 : functor.add_const (ordered_comm_monoid (complete_distrib_lattice name)) Type) : @has_exists_mul_of_le.{0} (complete_distrib_lattice.{0} name) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (complete_distrib_lattice.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_40213 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (measurable_space.dynkin_system.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measurable_space.dynkin_system.{0} num))  := sorry --non-trivial
lemma new_lemma_40214 (h0 : monoid (has_add Type)) : monoid.fg (has_add Type) := sorry --non-trivial
lemma new_lemma_40215 (h0 : not (group (linear_ordered_semiring linarith.ineq) -> false)) : @is_cyclic.{0} (linear_ordered_semiring.{0} linarith.ineq) (@classical.by_contradiction'.{1} (group.{0} (linear_ordered_semiring.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_40216 (h0 : group (normed_group linarith.comp_source)) : group.fg (normed_group linarith.comp_source) := sorry --non-trivial
lemma new_lemma_40217 (h0 : topological_space (non_assoc_semiring (semiring congr_arg_kind))) : t1_space (non_assoc_semiring (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_40218 (h0 : functor.add_const (fin has_zero.zero) pos) : @preirreducible_space.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@matrix.vec_empty.{2} (function.extfun.{3 2} (Type 1) topological_space.{1}) (@functor.add_const.run.{0 0} (fin (@has_zero.zero.{0} nat nat.has_zero)) pos h0)) (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_40219 (h0 : function.extfun Type topological_space) : @t1_space.{0} (ordered_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_40220 (h0 : topological_space (has_nndist (has_Inf (has_Inf (ring Type))))) : totally_separated_space (has_nndist (has_Inf (has_Inf (ring Type)))) := sorry --non-trivial
lemma new_lemma_40221 (h0 : functor.add_const (finset (has_Inf name)) name) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_40222 (h0 : ordered_add_comm_monoid (ring (option (option ennreal)))) : archimedean (ring (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_40223 (h0 : finset (preorder (option unsigned))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_40224 (h0 : function.extfun Type topological_space) : @t0_space.{0} (measurable_space.dynkin_system.{0} (semiring.{0} (semiring.{0} (semiring.{0} num)))) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measurable_space.dynkin_system.{0} (semiring.{0} (semiring.{0} (semiring.{0} num)))))  := sorry --non-trivial
lemma new_lemma_40225 (h1 : monoid (id (has_top linarith.ineq))) : monoid.fg (id (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_40226 (h0 : add_group (linear_ordered_semiring (has_top (random_gen fun_info)))) : is_add_cyclic (linear_ordered_semiring (has_top (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_40227 (h0 : functor.comp group add_cancel_monoid Type) : @is_cyclic.{1} (add_cancel_monoid.{1} Type) (@functor.comp.run.{1 1 1} group.{1} add_cancel_monoid.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_40228 (h1 : list (group (topological_space (random_gen string_imp)))) (h2 : nat) (h3 : not (has_lt.lt h2 (list.length h1) -> false)) : @is_cyclic.{0} (topological_space.{0} (random_gen.{0} string_imp)) (@list.nth_le.{0} (group.{0} (topological_space.{0} (random_gen.{0} string_imp))) h1 h2 (@classical.by_contradiction'.{0} (@has_lt.lt.{0} nat nat.has_lt h2 (@list.length.{0} (group.{0} (topological_space.{0} (random_gen.{0} string_imp))) h1)) h3))  := sorry --non-trivial
lemma new_lemma_40229 (h0 : ordered_comm_monoid (normed_comm_ring (has_to_string pos))) : has_exists_mul_of_le (normed_comm_ring (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_40230 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @totally_disconnected_space.{0} (div_inv_monoid.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (div_inv_monoid.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_40231 (h0 h1 : multiset (add_comm_semigroup string.iterator_imp)) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_40232 (h0 : not (function.extfun Type topological_space -> false)) : @totally_disconnected_space.{0} (linear_ordered_semiring.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (linear_ordered_semiring.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_40233 (h0 : functor.add_const (group (add_comm_monoid linarith.comp)) (has_to_string Type)) : @group.fg.{0} (add_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (group.{0} (add_comm_monoid.{0} linarith.comp)) (has_to_string.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_40234 (h0 : uniform_space (add_cancel_monoid (has_nndist Type))) : complete_space (add_cancel_monoid (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_40235 (h0 : fin has_zero.zero) : @normalizer_condition.{0} (sub_neg_monoid.{0} real) (@function.extfun_app.{2 1} Type group.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type group.{0}) h0) (sub_neg_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_40236 (h0 : topological_space (has_emptyc (semiring empty))) : irreducible_space (has_emptyc (semiring empty)) := sorry --non-trivial
lemma new_lemma_40237 (h0 : group (has_Inf (has_add pos))) : group.fg (has_Inf (has_add pos)) := sorry --non-trivial
lemma new_lemma_40238 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (measurable_space.dynkin_system congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_40239 (h1 : topological_space (linear_ordered_comm_group_with_zero (normed_field reducibility_hints))) : path_connected_space (linear_ordered_comm_group_with_zero (normed_field reducibility_hints)) := sorry --non-trivial
lemma new_lemma_40240 (h0 : functor.add_const (topological_space (comm_group pos)) pos) : @t1_space.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_40241 (h0 : ring (random_gen to_additive.value_type)) : strong_rank_condition (random_gen to_additive.value_type) := sorry --non-trivial
lemma new_lemma_40242 (h0 : topological_space (cancel_monoid (option (option (option (option unsigned)))))) : normal_space (cancel_monoid (option (option (option (option unsigned))))) := sorry --non-trivial
lemma new_lemma_40243 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (complete_semilattice_Sup.{0} empty) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (complete_semilattice_Sup.{0} empty))  := sorry --non-trivial
lemma new_lemma_40244 (h0 : group (has_inv (has_nnnorm (has_nnnorm (random_gen fun_info))))) : is_cyclic (has_inv (has_nnnorm (has_nnnorm (random_gen fun_info)))) := sorry --non-trivial
lemma new_lemma_40245 (h0 : topological_space (has_ssubset fun_info)) : t0_space (has_ssubset fun_info) := sorry --non-trivial
lemma new_lemma_40246 (h3 : not (complete_lattice (topological_space linarith.ineq) -> false)) : complete_lattice.is_Sup_finite_compact (topological_space linarith.ineq) := sorry --non-trivial
lemma new_lemma_40247 (h0 : complete_lattice (measurable_space.dynkin_system (semiring (semiring empty)))) : is_compactly_generated (measurable_space.dynkin_system (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_40248 (h0 : topological_space (filter (option num))) : t1_space (filter (option num)) := sorry --non-trivial
lemma new_lemma_40249 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (add_cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type monoid.{0} h0 (add_cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_40250 (h0 : topological_space (group_with_zero congr_arg_kind)) : loc_path_connected_space (group_with_zero congr_arg_kind) := sorry --non-trivial
lemma new_lemma_40251 (h0 : functor.comp topological_space has_add environment.implicit_infer_kind) : @regular_space.{0} (has_add.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} has_add.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_40252 (h0 : topological_space (add_comm_monoid (has_add name))) : sequential_space (add_comm_monoid (has_add name)) := sorry --non-trivial
lemma new_lemma_40253 (h0 : prod (random_gen (random_gen linarith.ineq)) (random_gen (random_gen linarith.ineq))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_40254 (h0 : topological_space (add_comm_monoid (has_add (has_neg Type)))) : preirreducible_space (add_comm_monoid (has_add (has_neg Type))) := sorry --non-trivial
lemma new_lemma_40255 (h0 : group (simple_graph (ring (has_add Type)))) : is_cyclic (simple_graph (ring (has_add Type))) := sorry --non-trivial
lemma new_lemma_40256 (h0 : topological_space (boolean_algebra (has_neg_part Type))) : topological_space.separable_space (boolean_algebra (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_40257 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @is_cyclic.{0} (normed_group.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) group.{0}) (normed_group.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_40258 (h0 : topological_space (has_nndist (finset (has_neg (has_neg (has_to_string (ring linarith.comp))))))) : preconnected_space (has_nndist (finset (has_neg (has_neg (has_to_string (ring linarith.comp)))))) := sorry --non-trivial
lemma new_lemma_40259 (h2 : topological_space ereal) (h3 : preorder ereal) : order_closed_topology ereal := sorry --non-trivial
lemma new_lemma_40260 (h0 : functor.add_const (topological_space (complete_linear_order unsigned)) congr_arg_kind) : @preirreducible_space.{0} (complete_linear_order.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_linear_order.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_40261 (h0 : prod (has_nndist empty) (has_nndist empty)) : set.diagonal (has_nndist empty) h0 := sorry --non-trivial
lemma new_lemma_40262 (h0 : uniform_space (monoid (option unsigned))) : separated_space (monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_40263 (h0 : group (add_comm_monoid (has_neg environment.implicit_infer_kind))) : group.fg (add_comm_monoid (has_neg environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_40264 (h0 : not (topological_space (comm_monoid empty) -> false)) (h1 : set (comm_monoid empty)) : @is_totally_separated.{0} (comm_monoid.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (comm_monoid.{0} empty)) h0) h1  := sorry --non-trivial
lemma new_lemma_40265 (h0 : functor.add_const (uniform_space (has_bot linarith.comp)) Type) : @separated_space.{0} (has_bot.{0} linarith.comp) (@functor.add_const.run.{0 1} (uniform_space.{0} (has_bot.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_40266 (h2 : not (complete_lattice (with_one num) -> false)) : @is_compactly_generated.{0} (with_one.{0} num) (@classical.by_contradiction'.{1} (complete_lattice.{0} (with_one.{0} num)) h2)  := sorry --non-trivial
lemma new_lemma_40267 (h0 : functor.add_const (group (canonically_ordered_comm_semiring name)) (has_nndist name)) : @is_simple_group.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.add_const.run.{0 0} (group.{0} (canonically_ordered_comm_semiring.{0} name)) (has_nndist.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_40268 (h0 : ring (semigroup ennreal)) : is_principal_ideal_ring (semigroup ennreal) := sorry --non-trivial
lemma new_lemma_40269 (h0 : topological_space (has_top (random_gen (random_gen (random_gen (random_gen char)))))) : t0_space (has_top (random_gen (random_gen (random_gen (random_gen char))))) := sorry --non-trivial
lemma new_lemma_40270 (h0 : list (has_nnnorm (has_nnnorm (random_gen fun_info)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_40271 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} (with_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (with_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_40272 (h0 : topological_space (random_gen linarith.comp)) : irreducible_space (random_gen linarith.comp) := sorry --non-trivial
lemma new_lemma_40273 (h0 : list (ordered_comm_ring (has_pos_part linarith.comp))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_40274 (h0 : group (normed_lattice_add_comm_group linarith.comp)) : is_cyclic (normed_lattice_add_comm_group linarith.comp) := sorry --non-trivial
lemma new_lemma_40275 (h0 : group (group_with_zero ennreal)) : is_cyclic (group_with_zero ennreal) := sorry --non-trivial
lemma new_lemma_40276 (h0 : has_mem.mem (has_top congr_arg_kind) has_emptyc.emptyc) : @rank_condition.{0} (has_top.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type ring.{0} (has_top.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_40277 (h0 : topological_space (sub_neg_monoid Type)) : regular_space (sub_neg_monoid Type) := sorry --non-trivial
lemma new_lemma_40278 (h0 : topological_space (comm_ring (comm_ring char))) : t0_space (comm_ring (comm_ring char)) := sorry --non-trivial
lemma new_lemma_40279 (h0 : not (topological_space (add_right_cancel_monoid unsigned) -> false)) : @t1_space.{0} (add_right_cancel_monoid.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (add_right_cancel_monoid.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_40280 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_Inf.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_Inf.{0} name))  := sorry --non-trivial
lemma new_lemma_40281 (h0 : topological_space (add_cancel_monoid (has_pos_part (has_add (has_neg (has_neg pos)))))) : locally_compact_space (add_cancel_monoid (has_pos_part (has_add (has_neg (has_neg pos))))) := sorry --non-trivial
lemma new_lemma_40282 (h0 : topological_space (normed_comm_ring (comm_group Type))) : loc_path_connected_space (normed_comm_ring (comm_group Type)) := sorry --non-trivial
lemma new_lemma_40283 (h0 : function.extfun Type topological_space) : @t1_space.{0} (canonically_ordered_comm_semiring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_40284 (h0 : topological_space (add_cancel_monoid (has_neg_part pos))) : regular_space (add_cancel_monoid (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_40285 (h0 : topological_space (has_bot (option (option empty)))) : totally_disconnected_space (has_bot (option (option empty))) := sorry --non-trivial
lemma new_lemma_40286 (h0 : ordered_comm_monoid (has_nndist pos)) : has_exists_mul_of_le (has_nndist pos) := sorry --non-trivial
lemma new_lemma_40287 (h0 : functor.add_const (semiring (has_Sup empty)) empty) : @is_noetherian_ring.{0} (has_Sup.{0} empty) (@functor.add_const.run.{0 0} (semiring.{0} (has_Sup.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_40288 (h0 : topological_space (has_append string.iterator_imp)) : totally_disconnected_space (has_append string.iterator_imp) := sorry --non-trivial
lemma new_lemma_40289 (h0 : add_group (metric_space (semiring empty))) : is_add_cyclic (metric_space (semiring empty)) := sorry --non-trivial
lemma new_lemma_40290 (h0 : topological_space (has_nndist (has_neg_part Type))) : locally_compact_space (has_nndist (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_40291 (h0 : functor.add_const (topological_space (sub_neg_monoid real)) real) : @irreducible_space.{0} (sub_neg_monoid.{0} real) (@functor.add_const.run.{0 0} (topological_space.{0} (sub_neg_monoid.{0} real)) real h0)  := sorry --non-trivial
lemma new_lemma_40292 (h0 : function.extfun (finset Type) (has_mem.mem (with_bot linarith.comp_source))) : @complete_lattice.is_Sup_finite_compact.{0} (with_bot.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (with_bot.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_bot.{0} linarith.comp_source)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_40293 (h0 : topological_space (comm_group (cancel_monoid (ring (has_neg_part unsigned))))) : totally_separated_space (comm_group (cancel_monoid (ring (has_neg_part unsigned)))) := sorry --non-trivial
lemma new_lemma_40294 (h0 : functor.add_const (ring (mul_zero_class congr_arg_kind)) unsigned) : @is_principal_ideal_ring.{0} (mul_zero_class.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ring.{0} (mul_zero_class.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_40295 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (distrib_lattice.{0} string_imp) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (distrib_lattice.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_40296 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (has_norm.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_norm.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_40297 (h0 : complete_lattice (semi_normed_comm_ring to_additive.value_type) -> Prop) (h1 : Exists (fun (x : complete_lattice (semi_normed_comm_ring to_additive.value_type)), h0 x)) : @complete_lattice.is_Sup_finite_compact.{0} (semi_normed_comm_ring.{0} to_additive.value_type) (@classical.some.{1} (complete_lattice.{0} (semi_normed_comm_ring.{0} to_additive.value_type)) h0 h1)  := sorry --non-trivial
lemma new_lemma_40298 (h0 : function.extfun nat fin) : @add_monoid.fg.{0} (canonically_ordered_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (add_monoid.{0} (canonically_ordered_monoid.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_40299 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @locally_compact_space.{0} (has_pos_part.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (has_pos_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_40300 (h0 : cancel_comm_monoid_with_zero (has_top (semiring empty))) : unique_factorization_monoid (has_top (semiring empty)) := sorry --non-trivial
lemma new_lemma_40301 (h0 : fin has_zero.zero) : @complete_space.{0} (ring.{0} name) (@matrix.vec_empty.{0} (uniform_space.{0} (ring.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_40302 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (linear_ordered_field.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_field.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_40303 (h0 : ring (with_bot linarith.comp)) : strong_rank_condition (with_bot linarith.comp) := sorry --non-trivial
lemma new_lemma_40304 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (mul_zero_class.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (mul_zero_class.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_40305 (h0 : group (linear_ordered_semiring (has_norm linarith.comp_source))) : normalizer_condition (linear_ordered_semiring (has_norm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_40306 (h0 : add_monoid (has_nndist (has_add Type))) : add_monoid.fg (has_nndist (has_add Type)) := sorry --non-trivial
lemma new_lemma_40307 (h0 : topological_space (partial_order (semiring (semiring num)))) : irreducible_space (partial_order (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_40308 (h0 : uniform_space (has_pos_part (has_Inf (has_neg pos)))) : separated_space (has_pos_part (has_Inf (has_neg pos))) := sorry --non-trivial
lemma new_lemma_40309 (h0 : topological_space (has_Sup (boolean_algebra.core unsigned))) : totally_disconnected_space (has_Sup (boolean_algebra.core unsigned)) := sorry --non-trivial
lemma new_lemma_40310 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_inner.{0 0} empty unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inner.{0 0} empty unsigned))  := sorry --non-trivial
lemma new_lemma_40311 (h0 : functor.add_const (function.extfun Type group) unsigned) : @group.fg.{0} (has_neg_part.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) unsigned h0) (has_neg_part.{0} name))  := sorry --non-trivial
lemma new_lemma_40312 (h2 : add_group num) : is_add_cyclic num := sorry --non-trivial
lemma new_lemma_40313 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_40314 (h0 : group (finset environment.implicit_infer_kind)) : is_simple_group (finset environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_40315 (h0 : topological_space (random_gen num)) : irreducible_space (random_gen num) := sorry --non-trivial
lemma new_lemma_40316 (h0 : topological_space (linear_ordered_semiring (semiring (has_top unsigned)))) : path_connected_space (linear_ordered_semiring (semiring (has_top unsigned))) := sorry --non-trivial
lemma new_lemma_40317 (h0 : add_monoid (complete_linear_order (has_top num))) : add_monoid.fg (complete_linear_order (has_top num)) := sorry --non-trivial
lemma new_lemma_40318 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (generalized_boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (generalized_boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_40319 (h0 : ring (has_nndist (has_to_string environment.implicit_infer_kind))) : is_principal_ideal_ring (has_nndist (has_to_string environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_40320 (h0 : ordered_add_comm_monoid (add_cancel_monoid (option empty))) : archimedean (add_cancel_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_40321 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_40322 (h0 : has_mem.mem (has_top congr_arg_kind) has_emptyc.emptyc) : @complete_space.{0} (has_top.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type uniform_space.{0} (has_top.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_40323 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (filter congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_40324 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @sequential_space.{1} (has_neg_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (has_neg_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_40325 (h0 : topological_space (has_add real)) : normal_space (has_add real) := sorry --non-trivial
lemma new_lemma_40326 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (linear_order.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (linear_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_40327 (h2 : ring (has_ssubset char)) : is_domain (has_ssubset char) := sorry --non-trivial
lemma new_lemma_40328 (h3 : ring (semi_normed_comm_ring (semi_normed_comm_ring char))) : is_domain (semi_normed_comm_ring (semi_normed_comm_ring char)) := sorry --non-trivial
lemma new_lemma_40329 (h0 : ring (add_semigroup (comm_monoid (comm_monoid (comm_monoid (comm_monoid unsigned)))))) : is_domain (add_semigroup (comm_monoid (comm_monoid (comm_monoid (comm_monoid unsigned))))) := sorry --non-trivial
lemma new_lemma_40330 (h0 : function.extfun nat fin) : @is_add_cyclic.{1} (has_Inf.{1} Type) (@matrix.vec_empty.{1} (add_group.{1} (has_Inf.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_40331 (h0 : function.extfun Type (functor.add_const (complete_lattice ennreal))) : complete_lattice.is_Sup_finite_compact ennreal := sorry --non-trivial
lemma new_lemma_40332 (h0 : complete_lattice (has_edist empty)) : complete_lattice.is_Sup_finite_compact (has_edist empty) := sorry --non-trivial
lemma new_lemma_40333 (h0 : not (ring (with_one linarith.comp_source) -> false)) : @rank_condition.{0} (with_one.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (with_one.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_40334 (h0 : monoid (cancel_monoid (has_add (normed_comm_ring environment.implicit_infer_kind)))) : monoid.fg (cancel_monoid (has_add (normed_comm_ring environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_40335 (h0 : ring (has_union unsigned)) : rank_condition (has_union unsigned) := sorry --non-trivial
lemma new_lemma_40336 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_40337 (h0 : complete_lattice (normed_group (random_gen (random_gen (random_gen linarith.comp_source))))) : is_atomistic (normed_group (random_gen (random_gen (random_gen linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_40338 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @add_monoid.fg.{0} (option.{0} ennreal) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) add_monoid.{0}) (option.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_40339 (h0 : not (ring (has_div linarith.ineq) -> false)) : @strong_rank_condition.{0} (has_div.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (has_div.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_40340 (h0 : add_group (semiring (random_gen (random_gen linarith.comp_source)))) : is_add_cyclic (semiring (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_40341 (h0 : ring (cancel_monoid Type)) : strong_rank_condition (cancel_monoid Type) := sorry --non-trivial
lemma new_lemma_40342 (h0 : finset (monoid_with_zero (option (option ennreal)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_40343 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (canonically_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (canonically_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_40344 (h0 : topological_space (canonically_ordered_comm_semiring (option name))) : sequential_space (canonically_ordered_comm_semiring (option name)) := sorry --non-trivial
lemma new_lemma_40345 (h0 : topological_space (simple_graph Type)) : preirreducible_space (simple_graph Type) := sorry --non-trivial
lemma new_lemma_40346 (h0 : complete_lattice (complete_semilattice_Sup (has_norm linarith.comp_source))) : complete_lattice.is_Sup_finite_compact (complete_semilattice_Sup (has_norm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_40347 (h0 : topological_space (topological_space reducibility_hints)) : path_connected_space (topological_space reducibility_hints) := sorry --non-trivial
lemma new_lemma_40348 (h0 : group (metric_space (has_norm empty))) : group.fg (metric_space (has_norm empty)) := sorry --non-trivial
lemma new_lemma_40349 (h0 : not (function.extfun Type topological_space -> false)) : @topological_space.separable_space.{0} (complete_semilattice_Sup.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (complete_semilattice_Sup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_40350 (h0 : topological_space (with_one (random_gen (random_gen string_imp)))) : t0_space (with_one (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_40351 (h0 : functor.add_const (topological_space (finset pos)) pos) : @loc_path_connected_space.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_40352 (h0 : topological_space (boolean_algebra.core (has_zero name))) : topological_space.separable_space (boolean_algebra.core (has_zero name)) := sorry --non-trivial
lemma new_lemma_40353 (h0 : functor.add_const (finset (boolean_algebra Type)) pos) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_40354 (h0 : topological_space (has_emptyc fun_info)) : path_connected_space (has_emptyc fun_info) := sorry --non-trivial
lemma new_lemma_40355 (h1 : complete_lattice string_imp) : complete_lattice.is_Sup_finite_compact string_imp := sorry --non-trivial
lemma new_lemma_40356 (h0 : functor.comp topological_space semigroup pos) : @topological_space.separable_space.{0} (semigroup.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_40357 (h0 : add_group (measurable_space.dynkin_system (semiring empty))) : is_add_cyclic (measurable_space.dynkin_system (semiring empty)) := sorry --non-trivial
lemma new_lemma_40358 (h0 : functor.add_const (monoid (has_to_string unsigned)) Type) : @monoid.fg.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 1} (monoid.{0} (has_to_string.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_40359 (h0 h1 : multiset (has_compl linarith.comp_source)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_40360 (h0 : uniform_space (monoid (option (option (option unsigned))))) : complete_space (monoid (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_40361 (h2 : topological_space (rel linarith.ineq linarith.ineq)) : totally_disconnected_space (rel linarith.ineq linarith.ineq) := sorry --non-trivial
lemma new_lemma_40362 (h0 : topological_space (ordered_comm_ring (comm_ring char))) : totally_disconnected_space (ordered_comm_ring (comm_ring char)) := sorry --non-trivial
lemma new_lemma_40363 (h0 : complete_lattice (linear_order (option unsigned))) : complete_lattice.is_Sup_finite_compact (linear_order (option unsigned)) := sorry --non-trivial
lemma new_lemma_40364 (h0 : ring (has_pos_part (has_add pos))) : is_principal_ideal_ring (has_pos_part (has_add pos)) := sorry --non-trivial
lemma new_lemma_40365 (h0 : topological_space (canonically_ordered_comm_semiring (cancel_monoid ennreal))) : irreducible_space (canonically_ordered_comm_semiring (cancel_monoid ennreal)) := sorry --non-trivial
lemma new_lemma_40366 (h0 : not (topological_space (id empty) -> false)) : @preirreducible_space.{0} (@id.{2} Type empty) (@classical.by_contradiction'.{1} (topological_space.{0} (@id.{2} Type empty)) h0)  := sorry --non-trivial
lemma new_lemma_40367 (h0 : topological_space (add_group unsigned)) (h1 : set (add_group unsigned)) : is_seq_compact h1 := sorry --non-trivial
lemma new_lemma_40368 (h0 : semiring (monoid_with_zero (option (option pos)))) : is_noetherian_ring (monoid_with_zero (option (option pos))) := sorry --non-trivial
lemma new_lemma_40369 (h0 : function.extfun Type group) : @is_cyclic.{0} (pseudo_metric_space.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} h0 (pseudo_metric_space.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_40370 (h0 : functor.add_const (uniform_space empty) (option empty)) : separated_space empty := sorry --non-trivial
lemma new_lemma_40371 (h1 : add_group (has_div linarith.ineq)) : is_add_cyclic (has_div linarith.ineq) := sorry --non-trivial
lemma new_lemma_40372 (h0 : function.extfun (finset Type -> Prop) (function.extfun (finset Type))) : @strong_rank_condition.{0} (linear_ordered_semiring.{0} fun_info) (@finset.pi.empty.{1 0} Type ring.{0} (linear_ordered_semiring.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (linear_ordered_semiring.{0} fun_info)) (@function.extfun_app.{2 0} (finset.{1} Type → Prop) (function.extfun.{2 0} (finset.{1} Type)) h0 (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (linear_ordered_semiring.{0} fun_info))) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_40373 (h0 : comm_semiring (has_union unsigned)) (h1 : filter (has_union (mv_polynomial (has_union empty) (has_union unsigned)))) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_40374 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (normed_group.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (normed_group.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_40375 (h0 : not (complete_lattice (comm_ring linarith.ineq) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (comm_ring.{0} linarith.ineq) (@classical.by_contradiction'.{1} (complete_lattice.{0} (comm_ring.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_40376 (h0 : functor.add_const (topological_space (cancel_monoid name)) Type) : @preirreducible_space.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (cancel_monoid.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_40377 (h0 : semiring char) (h2 : ideal char) : ideal.is_prime h2 := sorry --non-trivial
lemma new_lemma_40378 (h0 : topological_space (mul_zero_class (canonically_ordered_comm_semiring ennreal))) : path_connected_space (mul_zero_class (canonically_ordered_comm_semiring ennreal)) := sorry --non-trivial
lemma new_lemma_40379 (h0 : topological_space (semi_normed_comm_ring (random_gen (has_nnnorm linarith.comp_source)))) : totally_disconnected_space (semi_normed_comm_ring (random_gen (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_40380 (h0 : uniform_space (simple_graph (has_neg (has_neg (has_neg (has_neg linarith.comp)))))) : separated_space (simple_graph (has_neg (has_neg (has_neg (has_neg linarith.comp))))) := sorry --non-trivial
lemma new_lemma_40381 (h0 : functor.add_const (function.extfun (Type 1) topological_space) Type) : @path_connected_space.{1} (simple_graph.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) Type h0) (simple_graph.{1} Type))  := sorry --non-trivial
lemma new_lemma_40382 (h0 : topological_space (ring (has_neg_part environment.implicit_infer_kind))) : t0_space (ring (has_neg_part environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_40383 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_star.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_star.{0} empty))  := sorry --non-trivial
lemma new_lemma_40384 (h0 : topological_space (generalized_boolean_algebra (finset real))) : irreducible_space (generalized_boolean_algebra (finset real)) := sorry --non-trivial
lemma new_lemma_40385 (h0 : functor.comp add_monoid boolean_algebra name) : @add_monoid.fg.{0} (boolean_algebra.{0} name) (@functor.comp.run.{0 0 0} add_monoid.{0} boolean_algebra.{0} name h0)  := sorry --non-trivial
lemma new_lemma_40386 (h0 : filter (add_group congr_arg_kind)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_40387 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (group_with_zero.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (group_with_zero.{0} num))  := sorry --non-trivial
lemma new_lemma_40388 (h0 : functor.add_const (topological_space (has_Inf pos)) (has_add pos)) : @t1_space.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} pos)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_40389 (h0 : ring (comm_group (add_comm_monoid pos))) : rank_condition (comm_group (add_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_40390 (h0 : topological_space (finset (finset (finset (finset (finset (finset pos))))))) : normal_space (finset (finset (finset (finset (finset (finset pos)))))) := sorry --non-trivial
lemma new_lemma_40391 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (has_Sup.{0} (add_group.{0} empty)) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_Sup.{0} (add_group.{0} empty)))  := sorry --non-trivial
lemma new_lemma_40392 (h0 : fin has_zero.zero) : @is_principal_ideal_ring.{1} (ordered_comm_ring.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (ordered_comm_ring.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_40393 (h0 : complete_lattice (filter (option empty))) : is_atomistic (filter (option empty)) := sorry --non-trivial
lemma new_lemma_40394 (h0 : function.extfun Type topological_space) : @t1_space.{0} (has_dist.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_dist.{0} empty))  := sorry --non-trivial
lemma new_lemma_40395 (h0 : functor.add_const (topological_space (normed_linear_ordered_group num)) unsigned) : @t1_space.{0} (normed_linear_ordered_group.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_linear_ordered_group.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_40396 (h0 : functor.add_const (topological_space (boolean_algebra unsigned)) name) : @path_connected_space.{0} (boolean_algebra.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_40397 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_to_string.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} name))  := sorry --non-trivial
lemma new_lemma_40398 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (has_norm.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_norm.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_40399 (h0 : functor.add_const (topological_space (normed_comm_ring pos)) pos) : @loc_path_connected_space.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_40400 (h0 : functor.add_const (topological_space (has_zero pos)) name) : @regular_space.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_40401 (h0 : complete_lattice (boolean_algebra.core (measurable_space pos))) : is_compactly_generated (boolean_algebra.core (measurable_space pos)) := sorry --non-trivial
lemma new_lemma_40402 (h0 : topological_space (pseudo_metric_space unsigned)) : locally_compact_space (pseudo_metric_space unsigned) := sorry --non-trivial
lemma new_lemma_40403 (h0 : topological_space (finset (has_pos_part linarith.comp))) : preconnected_space (finset (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_40404 (h0 : monoid (complete_distrib_lattice ennreal)) : monoid.fg (complete_distrib_lattice ennreal) := sorry --non-trivial
lemma new_lemma_40405 (h0 : list (uniform_space (with_bot (random_gen (has_inv (has_inv (has_inv linarith.comp_source))))))) : @complete_space.{0} (with_bot.{0} (random_gen.{0} (has_inv.{0} (has_inv.{0} (has_inv.{0} linarith.comp_source))))) (@list.head.{0} (uniform_space.{0} (with_bot.{0} (random_gen.{0} (has_inv.{0} (has_inv.{0} (has_inv.{0} linarith.comp_source)))))) (@inhabited_uniform_space.{0} (with_bot.{0} (random_gen.{0} (has_inv.{0} (has_inv.{0} (has_inv.{0} linarith.comp_source)))))) h0)  := sorry --non-trivial
lemma new_lemma_40406 (h0 : complete_lattice (distrib string_imp)) : is_compactly_generated (distrib string_imp) := sorry --non-trivial
lemma new_lemma_40407 (h0 : functor.comp (prod (normed_comm_ring name)) normed_comm_ring name) : id_rel (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_40408 (h0 : uniform_space (add_cancel_monoid (boolean_algebra.core (add_cancel_monoid Type)))) : complete_space (add_cancel_monoid (boolean_algebra.core (add_cancel_monoid Type))) := sorry --non-trivial
lemma new_lemma_40409 (h0 : functor.add_const (topological_space (cancel_monoid Type)) name) : @preirreducible_space.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (cancel_monoid.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_40410 (h0 : ring (add_cancel_monoid (has_pos_part pos))) : strong_rank_condition (add_cancel_monoid (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_40411 (h1 : complete_lattice (normed_group string_imp)) : complete_lattice.is_Sup_finite_compact (normed_group string_imp) := sorry --non-trivial
lemma new_lemma_40412 (h0 : functor.add_const (function.extfun Type filter) pos) : countable_Inter_filter (function.extfun_app (functor.add_const.run h0) (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_40413 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (ordered_cancel_add_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_cancel_add_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_40414 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_zero.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_zero.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_40415 (h0 : functor.add_const (topological_space (boolean_algebra environment.implicit_infer_kind)) linarith.comp) : @sequential_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_40416 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (boolean_algebra.core.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (boolean_algebra.core.{0} pos))  := sorry --non-trivial
lemma new_lemma_40417 (h1 : not (complete_lattice (random_gen to_additive.value_type) -> false)) : @is_compactly_generated.{0} (random_gen.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (complete_lattice.{0} (random_gen.{0} to_additive.value_type)) h1)  := sorry --non-trivial
lemma new_lemma_40418 (h0 : functor.add_const (group (cancel_monoid Type)) (has_neg_part pos)) : @is_simple_group.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (cancel_monoid.{1} Type)) (has_neg_part.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_40419 (h0 : ring (has_nndist (finset name))) : is_principal_ideal_ring (has_nndist (finset name)) := sorry --non-trivial
lemma new_lemma_40420 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_40421 (h0 : group (random_gen (has_norm (has_norm linarith.ineq)))) : normalizer_condition (random_gen (has_norm (has_norm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_40422 (h0 : not (function.extfun Type topological_space -> false)) : @totally_separated_space.{0} (@id.{2} Type unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (@id.{2} Type unsigned))  := sorry --non-trivial
lemma new_lemma_40423 (h0 : complete_lattice (normed_group (random_gen to_additive.value_type))) : complete_lattice.is_Sup_finite_compact (normed_group (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_40424 (h0 : topological_space (add_cancel_monoid (option (option ennreal)))) : topological_space.separable_space (add_cancel_monoid (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_40425 (h0 : has_mem.mem complete_lattice has_emptyc.emptyc) : @is_compactly_generated.{0} (with_bot.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} h0) (with_bot.{0} num))  := sorry --non-trivial
lemma new_lemma_40426 (h0 : complete_lattice (semigroup (has_add environment.implicit_infer_kind))) : is_compactly_generated (semigroup (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_40427 (h0 : functor.add_const (complete_lattice (ring pos)) Type) : @is_atomistic.{0} (ring.{0} pos) (@functor.add_const.run.{0 1} (complete_lattice.{0} (ring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_40428 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} (with_bot.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (with_bot.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_40429 (h0 : has_mem.mem (complete_semilattice_Sup linarith.comp_source) has_emptyc.emptyc) : @complete_space.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type uniform_space.{0} (complete_semilattice_Sup.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_40430 (h0 : list (canonically_ordered_comm_semiring (option empty))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_40431 (h0 : functor.add_const (topological_space (normed_comm_ring pos)) environment.implicit_infer_kind) : @totally_separated_space.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_40432 (h0 : topological_space (finset (finset linarith.comp))) : locally_compact_space (finset (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_40433 (h0 : function.extfun (Type 1) topological_space) : @irreducible_space.{1} (simple_graph.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (simple_graph.{1} Type))  := sorry --non-trivial
lemma new_lemma_40434 (h0 : group (has_nndist (option (boolean_algebra.core name)))) : is_simple_group (has_nndist (option (boolean_algebra.core name))) := sorry --non-trivial
lemma new_lemma_40435 (h0 : function.extfun Type (functor.add_const (ring (canonically_ordered_comm_semiring ennreal)))) : @strong_rank_condition.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@functor.add_const.run.{0 0} (ring.{0} (canonically_ordered_comm_semiring.{0} ennreal)) name (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} (canonically_ordered_comm_semiring.{0} ennreal))) h0 name))  := sorry --non-trivial
lemma new_lemma_40436 (h0 : topological_space (canonically_linear_ordered_monoid (has_neg Type))) : locally_compact_space (canonically_linear_ordered_monoid (has_neg Type)) := sorry --non-trivial
lemma new_lemma_40437 (h0 : topological_space (canonically_ordered_add_monoid (option congr_arg_kind))) : preirreducible_space (canonically_ordered_add_monoid (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_40438 (h0 : function.extfun Type topological_space) : @normal_space.{0} (complete_distrib_lattice.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_40439 (h1 : function.extfun (finset Type) (has_mem.mem string_imp)) : @irreducible_space.{0} string_imp (@finset.pi.empty.{1 0} Type topological_space.{0} string_imp (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) string_imp) h1 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_40440 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (order_dual.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (order_dual.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_40441 (h0 : functor.add_const (topological_space (mul_zero_class empty)) congr_arg_kind) : @discrete_topology.{0} (mul_zero_class.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_40442 (h0 : uniform_space (has_add (has_neg (mul_one_class (ring environment.implicit_infer_kind))))) : separated_space (has_add (has_neg (mul_one_class (ring environment.implicit_infer_kind)))) := sorry --non-trivial
lemma new_lemma_40443 (h0 : monoid nnreal) : monoid.fg nnreal := sorry --non-trivial
lemma new_lemma_40444 (h0 : functor.add_const (complete_lattice ennreal) unsigned) : complete_lattice.is_Sup_finite_compact ennreal := sorry --non-trivial
lemma new_lemma_40445 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (has_Sup.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (has_Sup.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_40446 (h0 : functor.comp filter normed_comm_ring ennreal) : countable_Inter_filter (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_40447 (h0 : topological_space (has_union (has_norm (has_union linarith.comp)))) : normal_space (has_union (has_norm (has_union linarith.comp))) := sorry --non-trivial
lemma new_lemma_40448 (h0 : topological_space (has_nndist (has_add (has_neg_part (finset (add_comm_monoid pos)))))) : irreducible_space (has_nndist (has_add (has_neg_part (finset (add_comm_monoid pos))))) := sorry --non-trivial
lemma new_lemma_40449 (h0 : semiring (linear_ordered_semiring (semiring (semiring congr_arg_kind)))) : is_noetherian_ring (linear_ordered_semiring (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_40450 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (monoid unsigned)) := sorry --non-trivial
lemma new_lemma_40451 (h0 : filter (has_nndist (option congr_arg_kind))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_40452 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (finset empty)) := sorry --non-trivial
lemma new_lemma_40453 (h0 : group (has_neg (finset Type))) : is_simple_group (has_neg (finset Type)) := sorry --non-trivial
lemma new_lemma_40454 (h0 : function.extfun Type ring) : @rank_condition.{0} (sub_neg_monoid.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (sub_neg_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_40455 (h0 : complete_lattice (has_div fun_info)) : complete_lattice.is_Sup_finite_compact (has_div fun_info) := sorry --non-trivial
lemma new_lemma_40456 (h0 : ordered_comm_monoid (has_to_string (comm_group pos))) : has_exists_mul_of_le (has_to_string (comm_group pos)) := sorry --non-trivial
lemma new_lemma_40457 (h0 : ring (div_inv_monoid (has_nnnorm (has_nnnorm linarith.comp_source)))) : strong_rank_condition (div_inv_monoid (has_nnnorm (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_40458 (h0 : functor.add_const (ring (normed_linear_ordered_group congr_arg_kind)) unsigned) : @rank_condition.{0} (normed_linear_ordered_group.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ring.{0} (normed_linear_ordered_group.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_40459 (h0 : topological_space (boolean_algebra.core (comm_group Type))) : t0_space (boolean_algebra.core (comm_group Type)) := sorry --non-trivial
lemma new_lemma_40460 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (preorder.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (preorder.{0} num))  := sorry --non-trivial
lemma new_lemma_40461 (h0 : fin has_zero.zero) : @has_exists_mul_of_le.{0} (has_add.{0} name) (@matrix.vec_empty.{0} (ordered_comm_monoid.{0} (has_add.{0} name)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_40462 (h0 : ordered_comm_monoid (canonically_linear_ordered_monoid (ring pos))) : has_exists_mul_of_le (canonically_linear_ordered_monoid (ring pos)) := sorry --non-trivial
lemma new_lemma_40463 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem ring)) : @is_domain.{0} (semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) ring.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_40464 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_40465 (h0 : group (has_ssubset (random_gen (random_gen (has_inv (random_gen fun_info)))))) : group.fg (has_ssubset (random_gen (random_gen (has_inv (random_gen fun_info))))) := sorry --non-trivial
lemma new_lemma_40466 (h0 : complete_lattice (linear_ordered_comm_monoid_with_zero congr_arg_kind)) : is_compactly_generated (linear_ordered_comm_monoid_with_zero congr_arg_kind) := sorry --non-trivial
lemma new_lemma_40467 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (is_R_or_C.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (is_R_or_C.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_40468 (h0 : topological_space (has_Inf Type)) : topological_space.separable_space (has_Inf Type) := sorry --non-trivial
lemma new_lemma_40469 (h1 : complete_lattice (has_ssubset (has_ssubset reducibility_hints))) : complete_lattice.is_Sup_finite_compact (has_ssubset (has_ssubset reducibility_hints)) := sorry --non-trivial
lemma new_lemma_40470 (h0 : uniform_space (semi_normed_comm_ring linarith.comp_source)) : complete_space (semi_normed_comm_ring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_40471 (h0 : ordered_add_comm_monoid (semigroup (finset (finset linarith.comp)))) : archimedean (semigroup (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_40472 (h0 : functor.add_const (complete_lattice (add_cancel_monoid linarith.comp)) name) : @is_compactly_generated.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_cancel_monoid.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_40473 (h0 : group (has_zero (has_add Type))) : is_cyclic (has_zero (has_add Type)) := sorry --non-trivial
lemma new_lemma_40474 (h0 : topological_space (mul_one_class (mul_one_class fun_info))) (h1 : preorder (mul_one_class (mul_one_class fun_info))) : order_closed_topology (mul_one_class (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_40475 (h0 : functor.add_const (group (linear_ordered_field name)) pos) : @normalizer_condition.{0} (linear_ordered_field.{0} name) (@functor.add_const.run.{0 0} (group.{0} (linear_ordered_field.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_40476 (h0 : topological_space (has_pos_part (has_add (has_add linarith.comp)))) : sequential_space (has_pos_part (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_40477 (h0 : topological_space (normed_group unsigned)) : topological_space.separable_space (normed_group unsigned) := sorry --non-trivial
lemma new_lemma_40478 (h0 : has_coe (mul_one_class (normed_field char)) Prop) (h1 : mul_one_class (normed_field char)) : @coe_b.{1 1} (mul_one_class.{0} (normed_field.{0} char)) Prop h0 h1  := sorry --non-trivial
lemma new_lemma_40479 (h1 : topological_space (add_left_cancel_monoid char)) : totally_disconnected_space (add_left_cancel_monoid char) := sorry --non-trivial
lemma new_lemma_40480 (h0 : group (measurable_space linarith.comp)) : normalizer_condition (measurable_space linarith.comp) := sorry --non-trivial
lemma new_lemma_40481 (h0 : topological_space (normed_lattice_add_comm_group (has_add (has_add (has_Inf Type))))) : loc_path_connected_space (normed_lattice_add_comm_group (has_add (has_add (has_Inf Type)))) := sorry --non-trivial
lemma new_lemma_40482 (h0 : functor.add_const (topological_space (sub_neg_monoid name)) Type) : @totally_separated_space.{0} (sub_neg_monoid.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (sub_neg_monoid.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_40483 (h0 : topological_space (linear_ordered_field name)) : discrete_topology (linear_ordered_field name) := sorry --non-trivial
lemma new_lemma_40484 (h0 : complete_lattice (linear_ordered_comm_group_with_zero linarith.comp_source)) : is_compactly_generated (linear_ordered_comm_group_with_zero linarith.comp_source) := sorry --non-trivial
lemma new_lemma_40485 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @normal_space.{0} (comm_group.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_40486 (h0 : functor.add_const (topological_space (sub_neg_monoid pos)) linarith.comp) : @totally_separated_space.{0} (sub_neg_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (sub_neg_monoid.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_40487 (h0 : not (filter (comm_ring linarith.ineq) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_40488 (h0 : group (non_assoc_semiring (has_top (has_top empty)))) : is_cyclic (non_assoc_semiring (has_top (has_top empty))) := sorry --non-trivial
lemma new_lemma_40489 (h0 : functor.add_const (ordered_add_comm_monoid (has_zero pos)) Type) : @archimedean.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 1} (ordered_add_comm_monoid.{0} (has_zero.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_40490 (h0 : complete_lattice (has_star (semiring (semiring (semiring num))))) : complete_lattice.is_Sup_finite_compact (has_star (semiring (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_40491 (h0 : not (ring (distrib char) -> false)) : @is_domain.{0} (distrib.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (distrib.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_40492 (h0 : filter (linear_ordered_field (option congr_arg_kind))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_40493 (h0 : ring (add_comm_monoid num)) : is_domain (add_comm_monoid num) := sorry --non-trivial
lemma new_lemma_40494 (h0 : topological_space (comm_group (has_add name))) : totally_separated_space (comm_group (has_add name)) := sorry --non-trivial
lemma new_lemma_40495 (h0 : group (with_one string_imp)) : is_cyclic (with_one string_imp) := sorry --non-trivial
lemma new_lemma_40496 (h0 h1 : not (multiset (simple_graph linarith.comp_source) -> false)) : multiset.disjoint (classical.by_contradiction' h0) (classical.by_contradiction' h1) := sorry --non-trivial
lemma new_lemma_40497 (h0 : functor.add_const (ring (ordered_ring unsigned)) (semiring unsigned)) : @strong_rank_condition.{0} (ordered_ring.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (ordered_ring.{0} unsigned)) (semiring.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_40498 (h0 : functor.add_const (list (linear_ordered_comm_monoid_with_zero unsigned)) empty) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_40499 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (has_star.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_star.{0} empty))  := sorry --non-trivial
lemma new_lemma_40500 (h0 : functor.add_const (filter (has_Inf pos)) (has_neg Type)) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_40501 (h0 : topological_space (canonically_ordered_monoid real)) : normal_space (canonically_ordered_monoid real) := sorry --non-trivial
lemma new_lemma_40502 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (ordered_cancel_add_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (ordered_cancel_add_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_40503 (h0 : functor.comp topological_space semigroup name) : @regular_space.{0} (semigroup.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} name h0)  := sorry --non-trivial
lemma new_lemma_40504 (h0 : topological_space (has_nndist unsigned)) : sequential_space (has_nndist unsigned) := sorry --non-trivial
lemma new_lemma_40505 (h0 : topological_space (has_top (has_norm string_imp))) : path_connected_space (has_top (has_norm string_imp)) := sorry --non-trivial
lemma new_lemma_40506 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (add_right_cancel_monoid empty)) := sorry --non-trivial
lemma new_lemma_40507 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (option.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (option.{0} num))  := sorry --non-trivial
lemma new_lemma_40508 (h0 : ring (generalized_boolean_algebra (ring pos))) : strong_rank_condition (generalized_boolean_algebra (ring pos)) := sorry --non-trivial
lemma new_lemma_40509 (h0 : topological_space (normed_field to_additive.value_type)) : path_connected_space (normed_field to_additive.value_type) := sorry --non-trivial
lemma new_lemma_40510 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (add_cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_40511 (h0 : functor.add_const (topological_space (has_Inf pos)) linarith.comp) : @path_connected_space.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_40512 (h0 : uniform_space (add_left_cancel_monoid (fintype (comm_ring linarith.comp_source)))) : complete_space (add_left_cancel_monoid (fintype (comm_ring linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_40513 (h0 : complete_lattice (boolean_algebra.core name)) : is_compactly_generated (boolean_algebra.core name) := sorry --non-trivial
lemma new_lemma_40514 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (add_cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (add_cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_40515 (h3 : set fun_info) : set.finite h3 := sorry --non-trivial
lemma new_lemma_40516 (h0 : cancel_comm_monoid_with_zero (boolean_algebra.core (has_add pos))) : unique_factorization_monoid (boolean_algebra.core (has_add pos)) := sorry --non-trivial
lemma new_lemma_40517 (h0 : not (group (denumerable linarith.comp_source) -> false)) : @is_cyclic.{0} (denumerable.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (group.{0} (denumerable.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_40518 (h0 : topological_space (normed_lattice_add_comm_group name)) : loc_path_connected_space (normed_lattice_add_comm_group name) := sorry --non-trivial
lemma new_lemma_40519 (h0 : semiring (boolean_algebra.core (ring linarith.comp))) : is_noetherian_ring (boolean_algebra.core (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_40520 (h0 : functor.add_const (topological_space (has_neg linarith.comp)) (comm_group ennreal)) : @preconnected_space.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} linarith.comp)) (comm_group.{0} ennreal) h0)  := sorry --non-trivial
lemma new_lemma_40521 (h0 : function.extfun Type (prod (add_cancel_comm_monoid empty))) : id_rel (function.extfun_app h0 (add_cancel_comm_monoid empty)) := sorry --non-trivial
lemma new_lemma_40522 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (has_bot.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_bot.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_40523 (h0 : functor.add_const (semiring (add_left_cancel_semigroup empty)) (option empty)) : @is_noetherian_ring.{0} (add_left_cancel_semigroup.{0} empty) (@functor.add_const.run.{0 0} (semiring.{0} (add_left_cancel_semigroup.{0} empty)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_40524 (h0 : topological_space (semiring (has_top (random_gen linarith.comp_source)))) : totally_separated_space (semiring (has_top (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_40525 (h0 : topological_space (metric_space to_additive.value_type)) : totally_disconnected_space (metric_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_40526 (h0 : ring (bin_tree (has_top unsigned))) : strong_rank_condition (bin_tree (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_40527 (h0 : prod (with_bot unsigned) (with_bot unsigned)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_40528 (h0 : uniform_space (plift congr_arg_kind)) : separated_space (plift congr_arg_kind) := sorry --non-trivial
lemma new_lemma_40529 (h0 : function.extfun Type ring) : @is_domain.{0} (has_nndist.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_nndist.{0} num))  := sorry --non-trivial
lemma new_lemma_40530 (h0 : ordered_add_comm_monoid (comm_semigroup (has_bot real))) : archimedean (comm_semigroup (has_bot real)) := sorry --non-trivial
lemma new_lemma_40531 (h0 : lattice (dlist linarith.comp_source)) : is_modular_lattice (dlist linarith.comp_source) := sorry --non-trivial
lemma new_lemma_40532 (h1 : set (add_comm_semigroup std_gen -> string.iterator_imp)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_40533 (h0 : topological_space (linear_ordered_comm_ring (semiring (has_norm empty)))) : discrete_topology (linear_ordered_comm_ring (semiring (has_norm empty))) := sorry --non-trivial
lemma new_lemma_40534 (h0 : not (function.extfun (finset Type) (has_mem.mem congr_arg_kind) -> false)) : @monoid.fg.{0} congr_arg_kind (@finset.pi.empty.{1 0} Type monoid.{0} congr_arg_kind (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) congr_arg_kind) (@classical.by_contradiction'.{0} (function.extfun.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) congr_arg_kind)) h0) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_40535 (h1 : filter (has_ssubset char)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_40536 (h0 : group (normed_comm_ring name)) : normalizer_condition (normed_comm_ring name) := sorry --non-trivial
lemma new_lemma_40537 (h0 : ring (has_top (random_gen linarith.comp_source))) : is_domain (has_top (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_40538 (h0 : topological_space (ordered_comm_ring (has_neg name))) : sequential_space (ordered_comm_ring (has_neg name)) := sorry --non-trivial
lemma new_lemma_40539 (h0 : cancel_comm_monoid_with_zero (has_add (has_add (has_Inf (ring Type))))) : unique_factorization_monoid (has_add (has_add (has_Inf (ring Type)))) := sorry --non-trivial
lemma new_lemma_40540 (h0 : function.extfun (Type 1) (functor.comp semiring has_neg_part)) : @is_noetherian_ring.{1} (has_neg_part.{1} Type) (@functor.comp.run.{1 1 1} semiring.{1} has_neg_part.{1} Type (@function.extfun_app.{3 2} (Type 1) (functor.comp.{1 1 1} semiring.{1} has_neg_part.{1}) h0 Type))  := sorry --non-trivial
lemma new_lemma_40541 (h0 : finset (ordered_comm_ring linarith.comp)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_40542 (h0 : plift (add_right_cancel_monoid unsigned) -> plift (add_right_cancel_monoid unsigned) -> Prop) : is_symm (plift (add_right_cancel_monoid unsigned)) h0 := sorry --non-trivial
lemma new_lemma_40543 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (measurable_space.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (measurable_space.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_40544 (h0 : ring (add_left_cancel_semigroup environment.projection_info)) : is_domain (add_left_cancel_semigroup environment.projection_info) := sorry --non-trivial
lemma new_lemma_40545 (h0 : functor.add_const (ring (free_add_monoid empty)) num) : @is_domain.{0} (free_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (free_add_monoid.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_40546 (h1 : topological_space (denumerable string_imp)) : path_connected_space (denumerable string_imp) := sorry --non-trivial
lemma new_lemma_40547 (h0 : function.extfun Type (functor.comp topological_space comm_group)) : @t0_space.{0} (comm_group.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} comm_group.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} comm_group.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_40548 (h0 : topological_space (has_bot (semiring empty))) : totally_disconnected_space (has_bot (semiring empty)) := sorry --non-trivial
lemma new_lemma_40549 (h2 : ring (add_left_cancel_monoid (has_nnnorm linarith.comp_source))) : strong_rank_condition (add_left_cancel_monoid (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_40550 (h0 : function.extfun Type topological_space) : @normal_space.{0} (normed_lattice_add_comm_group.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_lattice_add_comm_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_40551 (h0 : set (prod (mul_one_class fun_info) (mul_one_class fun_info))) : symmetric_rel h0 := sorry --non-trivial
lemma new_lemma_40552 (h0 : functor.add_const (topological_space (boolean_algebra Type)) linarith.comp) : @loc_path_connected_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_40553 (h0 : complete_lattice (random_gen (has_ssubset fun_info))) : is_compactly_generated (random_gen (has_ssubset fun_info)) := sorry --non-trivial
lemma new_lemma_40554 (h0 : group (linear_ordered_add_comm_group (has_nnnorm linarith.ineq))) : is_cyclic (linear_ordered_add_comm_group (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_40555 (h0 : functor.add_const (list (has_neg_part pos)) name) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_40556 (h3 : ring (topological_space linarith.comp_source)) : is_domain (topological_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_40557 (h0 : topological_space (comm_ring (with_one (linear_ordered_add_comm_group string_imp)))) : locally_compact_space (comm_ring (with_one (linear_ordered_add_comm_group string_imp))) := sorry --non-trivial
lemma new_lemma_40558 (h0 : functor.add_const (topological_space (boolean_algebra name)) Type) : @locally_compact_space.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_40559 (h0 : function.extfun Type group) : @normalizer_condition.{0} (add_left_cancel_semigroup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (add_left_cancel_semigroup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_40560 (h0 : not (topological_space (has_union num) -> false)) : @path_connected_space.{0} (has_union.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (has_union.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_40561 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @is_domain.{0} (complete_semilattice_Sup.{0} linarith.ineq) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) ring.{0}) (complete_semilattice_Sup.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_40562 (h0 : ring (has_union (semiring linarith.comp))) : strong_rank_condition (has_union (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_40563 (h0 : topological_space (linear_ordered_add_comm_group string_imp)) : totally_disconnected_space (linear_ordered_add_comm_group string_imp) := sorry --non-trivial
lemma new_lemma_40564 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (add_semigroup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (add_semigroup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_40565 (h0 : topological_space (has_nndist (has_nndist (has_neg pos)))) : loc_path_connected_space (has_nndist (has_nndist (has_neg pos))) := sorry --non-trivial
lemma new_lemma_40566 (h0 : functor.add_const (filter (add_cancel_monoid environment.implicit_infer_kind)) (ring Type)) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_40567 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (boolean_algebra.core.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (boolean_algebra.core.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_40568 (h0 : not (ring (uniform_space linarith.comp_source) -> false)) : @rank_condition.{0} (uniform_space.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (uniform_space.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_40569 (h0 : not (cancel_comm_monoid_with_zero (add_right_cancel_monoid empty) -> false)) : @unique_factorization_monoid.{0} (add_right_cancel_monoid.{0} empty) (@classical.by_contradiction'.{1} (cancel_comm_monoid_with_zero.{0} (add_right_cancel_monoid.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_40570 (h0 : ring (measurable_space.dynkin_system (has_norm unsigned))) : strong_rank_condition (measurable_space.dynkin_system (has_norm unsigned)) := sorry --non-trivial
lemma new_lemma_40571 (h0 : ring (has_inter num)) : is_domain (has_inter num) := sorry --non-trivial
lemma new_lemma_40572 (h0 : group (has_zero (has_add (finset (finset Type))))) : group.fg (has_zero (has_add (finset (finset Type)))) := sorry --non-trivial
lemma new_lemma_40573 (h0 : topological_space (has_zero (option (option ennreal)))) : normal_space (has_zero (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_40574 (h0 : prod (has_to_string (has_nndist Type)) (has_to_string (has_nndist Type))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_40575 (h3 : complete_lattice (fintype fun_info)) : complete_lattice.is_Sup_finite_compact (fintype fun_info) := sorry --non-trivial
lemma new_lemma_40576 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_simple_group.{0} (sub_neg_monoid.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (sub_neg_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_40577 (h0 : prod (boolean_algebra.core (has_add (has_add pos))) (boolean_algebra.core (has_add (has_add pos)))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_40578 (h0 : uniform_space (measurable_space (random_gen (random_gen (random_gen string_imp))))) : complete_space (measurable_space (random_gen (random_gen (random_gen string_imp)))) := sorry --non-trivial
lemma new_lemma_40579 (h0 : uniform_space (comm_group (parser (finset ennreal)))) : complete_space (comm_group (parser (finset ennreal))) := sorry --non-trivial
lemma new_lemma_40580 (h0 : fin has_zero.zero) : @group.fg.{1} (has_pos_part.{1} Type) (@matrix.vec_empty.{1} (group.{1} (has_pos_part.{1} Type)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)))  := sorry --non-trivial
lemma new_lemma_40581 (h0 : function.extfun Type group) : @group.fg.{0} (with_bot.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (with_bot.{0} num))  := sorry --non-trivial
lemma new_lemma_40582 (h0 : functor.add_const (ring (finset name)) (ring environment.implicit_infer_kind)) : @strong_rank_condition.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (finset.{0} name)) (ring.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_40583 (h0 : has_mem.mem (semiring linarith.comp_source) has_emptyc.emptyc) : @path_connected_space.{0} (semiring.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (semiring.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_40584 (h0 h1 : multiset (normed_field environment.projection_info)) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_40585 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem uniform_space)) : @complete_space.{0} (has_norm.{0} fun_info) (@function.extfun_app.{2 1} Type uniform_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) uniform_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) uniform_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_norm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_40586 (h0 : function.extfun (Type 1) topological_space) : @t1_space.{1} (ordered_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (ordered_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_40587 (h0 : functor.add_const (topological_space (ring linarith.comp)) environment.implicit_infer_kind) : @locally_compact_space.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_40588 (h0 : measurable_space (has_div (mul_one_class linarith.ineq))) (h1 : has_inf (has_div (mul_one_class linarith.ineq))) : has_measurable_inf (has_div (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_40589 (h0 : uniform_space (monoid_with_zero pos)) : separated_space (monoid_with_zero pos) := sorry --non-trivial
lemma new_lemma_40590 (h0 : functor.add_const (add_monoid (generalized_boolean_algebra pos)) name) : @add_monoid.fg.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (add_monoid.{0} (generalized_boolean_algebra.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_40591 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (normed_comm_ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_40592 (h0 : not (function.extfun Type complete_lattice -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (with_bot.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (with_bot.{0} num))  := sorry --non-trivial
lemma new_lemma_40593 (h3 : not (add_group (encodable to_additive.value_type) -> false)) : @is_add_cyclic.{0} (encodable.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (add_group.{0} (encodable.{0} to_additive.value_type)) h3)  := sorry --non-trivial
lemma new_lemma_40594 (h0 : functor.add_const (function.extfun (Type 1) group) Type) : @group.fg.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) group.{1}) Type h0) (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_40595 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (ordered_comm_group.{0} (option.{0} unsigned)) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (ordered_comm_group.{0} (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_40596 (h0 : complete_lattice (add_semigroup (option (option empty)))) : is_compactly_generated (add_semigroup (option (option empty))) := sorry --non-trivial
lemma new_lemma_40597 (h0 : fin has_zero.zero) : @t1_space.{0} (has_Inf.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (has_Inf.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_40598 (h0 : topological_space (has_neg (has_add Type))) : regular_space (has_neg (has_add Type)) := sorry --non-trivial
lemma new_lemma_40599 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_40600 (h5 : topological_space (nondiscrete_normed_field linarith.ineq)) : totally_disconnected_space (nondiscrete_normed_field linarith.ineq) := sorry --non-trivial
lemma new_lemma_40601 (h0 : topological_space (semigroup (boolean_algebra.core environment.implicit_infer_kind))) : t1_space (semigroup (boolean_algebra.core environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_40602 (h0 : topological_space (has_add (has_Inf (has_neg (has_neg name))))) : loc_path_connected_space (has_add (has_Inf (has_neg (has_neg name)))) := sorry --non-trivial
lemma new_lemma_40603 (h3 : group (id linarith.comp_source)) : normalizer_condition (id linarith.comp_source) := sorry --non-trivial
lemma new_lemma_40604 (h0 : group (has_inv (has_inv to_additive.value_type))) : normalizer_condition (has_inv (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_40605 (h0 : functor.add_const (ring (comm_group Type)) Type) : @strong_rank_condition.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 1} (ring.{1} (comm_group.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_40606 (h0 : ring (normed_group (has_top congr_arg_kind))) : is_domain (normed_group (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_40607 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (mul_zero_class.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (mul_zero_class.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_40608 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem ring)) : @is_domain.{0} (semiring.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) ring.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_40609 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) congr_arg_kind) := sorry --non-trivial
lemma new_lemma_40610 (h0 : set (std_gen -> mul_one_class enat)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_40611 (h0 : functor.add_const (topological_space (semigroup unsigned)) environment.implicit_infer_kind) : @loc_path_connected_space.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_40612 (h0 : filter (has_zero (has_to_string (has_neg_part (has_to_string unsigned))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_40613 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_bot.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_bot.{0} name))  := sorry --non-trivial
lemma new_lemma_40614 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (generalized_boolean_algebra pos)) := sorry --non-trivial
lemma new_lemma_40615 (h0 : functor.add_const (topological_space (has_zero linarith.comp)) linarith.comp) : @sequential_space.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_40616 (h0 : topological_space (has_norm (has_top fun_info))) : discrete_topology (has_norm (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_40617 (h0 : functor.add_const (topological_space (generalized_boolean_algebra Type)) (ring pos)) : @discrete_topology.{1} (generalized_boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (generalized_boolean_algebra.{1} Type)) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_40618 (h0 : topological_space (add_group (has_norm (has_norm (semiring linarith.comp))))) : totally_separated_space (add_group (has_norm (has_norm (semiring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_40619 (h0 : functor.add_const (group (semigroup pos)) Type) : @is_simple_group.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (semigroup.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_40620 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (ordered_comm_ring.{0} real) (@function.extfun_app.{2 1} Type ring.{0} h0 (ordered_comm_ring.{0} real))  := sorry --non-trivial
lemma new_lemma_40621 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (linear_ordered_field.{0} pos) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (linear_ordered_field.{0} pos))  := sorry --non-trivial
lemma new_lemma_40622 (h0 : filter (add_comm_monoid (add_comm_monoid Type))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_40623 (h0 : functor.add_const (filter (monoid ennreal)) ennreal) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_40624 (h0 : complete_lattice (has_sub (has_top (has_top (has_top empty))))) : complete_lattice.is_Sup_finite_compact (has_sub (has_top (has_top (has_top empty)))) := sorry --non-trivial
lemma new_lemma_40625 (h0 : not (topological_space (bin_tree unsigned) -> false)) : @totally_disconnected_space.{0} (bin_tree.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (bin_tree.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_40626 (h0 : uniform_space (id (semiring (has_union (semiring linarith.comp))))) : separated_space (id (semiring (has_union (semiring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_40627 (h0 : topological_space (id fun_info)) : totally_disconnected_space (id fun_info) := sorry --non-trivial
lemma new_lemma_40628 (h0 : functor.add_const (monoid (has_zero environment.implicit_infer_kind)) linarith.comp) : @monoid.fg.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (monoid.{0} (has_zero.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_40629 (h0 : group (semigroup (has_add (has_add (has_add pos))))) : group.fg (semigroup (has_add (has_add (has_add pos)))) := sorry --non-trivial
lemma new_lemma_40630 (h0 : functor.add_const (topological_space (has_add environment.implicit_infer_kind)) pos) : @preirreducible_space.{0} (has_add.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_40631 (h0 : uniform_space (canonically_ordered_add_monoid congr_arg_kind)) : separated_space (canonically_ordered_add_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_40632 (h1 : add_group (add_left_cancel_monoid linarith.comp_source)) : is_add_cyclic (add_left_cancel_monoid linarith.comp_source) := sorry --non-trivial
lemma new_lemma_40633 (h0 : topological_space (add_comm_semigroup (add_comm_semigroup char))) : t0_space (add_comm_semigroup (add_comm_semigroup char)) := sorry --non-trivial
lemma new_lemma_40634 (h0 : topological_space (linear_order (semiring (semiring empty)))) : topological_space.separable_space (linear_order (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_40635 (h0 : topological_space (normed_comm_ring (finset linarith.comp))) : totally_separated_space (normed_comm_ring (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_40636 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (normed_linear_ordered_group.{0} (semiring.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_linear_ordered_group.{0} (semiring.{0} empty)))  := sorry --non-trivial
lemma new_lemma_40637 (h0 : uniform_space (with_one (has_top (has_top to_additive.value_type)))) : complete_space (with_one (has_top (has_top to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_40638 (h0 : not (function.extfun Type uniform_space -> false)) : @separated_space.{0} (has_emptyc.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (has_emptyc.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_40639 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (has_nndist.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_nndist.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_40640 (h0 : cancel_comm_monoid_with_zero (has_add (ring ennreal))) : unique_factorization_monoid (has_add (ring ennreal)) := sorry --non-trivial
lemma new_lemma_40641 (h0 : filter (add_left_cancel_monoid (has_nnnorm (has_nnnorm (has_nnnorm char))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_40642 (h0 : topological_space (add_comm_semigroup fun_info)) (h1 : preorder (add_comm_semigroup fun_info) -> char) (h2 : coe_sort (set.range h1)) : @order_topology.{0} (add_comm_semigroup.{0} fun_info) h0 (@set.range_splitting.{0 0} (preorder.{0} (add_comm_semigroup.{0} fun_info)) char h1 h2)  := sorry --non-trivial
lemma new_lemma_40643 (h0 : complete_lattice (has_norm linarith.ineq)) : complete_lattice.is_Sup_finite_compact (has_norm linarith.ineq) := sorry --non-trivial
lemma new_lemma_40644 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (mul_zero_class.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (mul_zero_class.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_40645 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (option.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (option.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_40646 (h0 : environment.projection_info -> environment.projection_info) : set.finite (function.periodic_pts h0) := sorry --non-trivial
lemma new_lemma_40647 (h0 : topological_space (has_union (semiring unsigned))) : totally_separated_space (has_union (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_40648 (h0 : uniform_space (normed_group (semiring linarith.comp))) : complete_space (normed_group (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_40649 (h0 : function.extfun Type group) : @normalizer_condition.{0} (linear_order.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (linear_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_40650 (h0 : functor.add_const (list (semigroup Type)) Type) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_40651 (h0 : functor.add_const (add_group (sub_neg_monoid pos)) name) : @is_add_cyclic.{0} (sub_neg_monoid.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (sub_neg_monoid.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_40652 (h0 : functor.add_const (monoid (normed_comm_ring pos)) name) : @monoid.fg.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (monoid.{0} (normed_comm_ring.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_40653 (h0 : semiring (has_to_string (has_neg (ring linarith.comp)))) : is_noetherian_ring (has_to_string (has_neg (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_40654 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} (distrib_lattice.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (distrib_lattice.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_40655 (h0 : ring (finset (option (ring (option (option pos)))))) : rank_condition (finset (option (ring (option (option pos))))) := sorry --non-trivial
lemma new_lemma_40656 (h0 : functor.add_const (topological_space (add_cancel_monoid Type)) pos) : @sequential_space.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_cancel_monoid.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_40657 (h0 : functor.add_const (ring (boolean_algebra name)) linarith.comp) : @is_principal_ideal_ring.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_40658 (h0 : functor.add_const (finset (has_nndist unsigned)) (finset (has_neg pos))) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_40659 (h0 : topological_space (omega_complete_partial_order congr_arg_kind)) : totally_disconnected_space (omega_complete_partial_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_40660 (h0 : group (ring (has_nndist (has_to_string Type)))) : is_simple_group (ring (has_nndist (has_to_string Type))) := sorry --non-trivial
lemma new_lemma_40661 (h0 : function.extfun (Type 1) complete_lattice) : @is_atomistic.{1} (has_pos_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} h0 (has_pos_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_40662 (h0 : topological_space (has_inv (has_top (has_ssubset to_additive.value_type)))) : irreducible_space (has_inv (has_top (has_ssubset to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_40663 (h0 : topological_space (sub_neg_monoid (has_Inf real))) : t1_space (sub_neg_monoid (has_Inf real)) := sorry --non-trivial
lemma new_lemma_40664 (h0 : functor.add_const (topological_space (add_comm_monoid name)) name) : @path_connected_space.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_40665 (h0 : ordered_comm_monoid (add_comm_monoid (has_add name))) : has_exists_mul_of_le (add_comm_monoid (has_add name)) := sorry --non-trivial
lemma new_lemma_40666 (h0 : cancel_comm_monoid_with_zero (has_neg_part (normed_comm_ring name))) : unique_factorization_monoid (has_neg_part (normed_comm_ring name)) := sorry --non-trivial
lemma new_lemma_40667 (h0 : ordered_add_comm_monoid (has_add (has_neg environment.implicit_infer_kind))) : archimedean (has_add (has_neg environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_40668 (h0 : semiring (has_nndist (has_to_string unsigned))) : is_noetherian_ring (has_nndist (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_40669 (h0 : functor.add_const (topological_space (cancel_monoid unsigned)) name) : @preconnected_space.{0} (cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_40670 (h0 : functor.add_const (topological_space (semiring num)) empty) : @normal_space.{0} (semiring.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (semiring.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_40671 (h0 : functor.comp topological_space has_to_string environment.implicit_infer_kind) : @totally_disconnected_space.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} has_to_string.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_40672 (h0 : complete_lattice (has_Sup empty)) : is_atomistic (has_Sup empty) := sorry --non-trivial
lemma new_lemma_40673 (h0 : complete_lattice (denumerable (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm char)))))) : is_compactly_generated (denumerable (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm char))))) := sorry --non-trivial
lemma new_lemma_40674 (h0 : set (nondiscrete_normed_field enat)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_40675 (h0 : functor.comp topological_space cancel_monoid pos) : @topological_space.separable_space.{0} (cancel_monoid.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} cancel_monoid.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_40676 (h0 : has_one (has_top linarith.comp) -> Prop) : @infi.{0 1} Prop (@conditionally_complete_lattice.to_has_Inf.{0} Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice)) (has_one.{0} (has_top.{0} linarith.comp)) h0  := sorry --non-trivial
lemma new_lemma_40677 (h0 : complete_lattice (group_with_zero ennreal)) : is_compactly_generated (group_with_zero ennreal) := sorry --non-trivial
lemma new_lemma_40678 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (simple_graph.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (simple_graph.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_40679 (h0 : topological_space (complete_semilattice_Sup (random_gen char))) : locally_compact_space (complete_semilattice_Sup (random_gen char)) := sorry --non-trivial
lemma new_lemma_40680 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (denumerable.{0} fun_info) (@function.extfun_app.{2 1} Type monoid.{0} h0 (denumerable.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_40681 (h0 : topological_space (canonically_linear_ordered_monoid (option pos))) : path_connected_space (canonically_linear_ordered_monoid (option pos)) := sorry --non-trivial
lemma new_lemma_40682 (h0 : list (complete_distrib_lattice linarith.comp)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_40683 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_40684 (h0 : order_hom nat (uniform_space (with_one fun_info))) : @complete_space.{0} (with_one.{0} fun_info) (@monotonic_sequence_limit.{0} (uniform_space.{0} (with_one.{0} fun_info)) (@uniform_space.partial_order.{0} (with_one.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_40685 (h0 : functor.add_const (group (boolean_algebra name)) pos) : @group.fg.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_40686 (h0 : not (function.extfun Type monoid -> false)) : @monoid.fg.{0} (random_gen.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type monoid.{0}) h0) (random_gen.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_40687 (h0 : ring (random_gen (semiring empty))) : rank_condition (random_gen (semiring empty)) := sorry --non-trivial
lemma new_lemma_40688 (h1 : group (div_inv_monoid linarith.ineq)) : is_cyclic (div_inv_monoid linarith.ineq) := sorry --non-trivial
lemma new_lemma_40689 (h0 : functor.add_const (list (has_neg linarith.comp)) (ring Type)) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_40690 (h0 : topological_space (has_nnnorm string.iterator_imp)) (h1 : preorder (has_nnnorm string.iterator_imp)) : order_topology (has_nnnorm string.iterator_imp) := sorry --non-trivial
lemma new_lemma_40691 (h0 : functor.add_const (group (measurable_space.dynkin_system unsigned)) unsigned) : @group.fg.{0} (measurable_space.dynkin_system.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (measurable_space.dynkin_system.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_40692 (h0 : topological_space (preorder congr_arg_kind)) : path_connected_space (preorder congr_arg_kind) := sorry --non-trivial
lemma new_lemma_40693 (h0 : group congr_arg_kind) : normalizer_condition congr_arg_kind := sorry --non-trivial
lemma new_lemma_40694 (h0 : monoid (bin_tree (semiring (semiring empty)))) : monoid.fg (bin_tree (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_40695 (h0 : complete_lattice (encodable (random_gen string_imp))) : complete_lattice.is_Sup_finite_compact (encodable (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_40696 (h0 : topological_space (left_cancel_monoid unsigned)) : locally_compact_space (left_cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_40697 (h0 : functor.add_const (add_monoid (ordered_comm_ring pos)) (ring name)) : @add_monoid.fg.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (add_monoid.{0} (ordered_comm_ring.{0} pos)) (ring.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_40698 (h0 : functor.add_const (topological_space (add_cancel_monoid environment.implicit_infer_kind)) pos) : @t1_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_40699 (h0 : functor.comp uniform_space mul_zero_class Type) : @complete_space.{1} (mul_zero_class.{1} Type) (@functor.comp.run.{1 1 1} uniform_space.{1} mul_zero_class.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_40700 (h0 : list (has_to_string (finset (has_pos_part pos)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_40701 (h0 : functor.add_const (topological_space (has_zero Type)) environment.implicit_infer_kind) : @locally_compact_space.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_zero.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_40702 (h0 : monoid (has_Inf name)) : monoid.fg (has_Inf name) := sorry --non-trivial
lemma new_lemma_40703 (h0 : ring (with_bot (random_gen (random_gen num)))) : is_domain (with_bot (random_gen (random_gen num))) := sorry --non-trivial
lemma new_lemma_40704 (h0 : ordered_add_comm_monoid (comm_group pos)) : archimedean (comm_group pos) := sorry --non-trivial
lemma new_lemma_40705 (h0 : functor.add_const (filter nnreal) num) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_40706 (h0 : functor.add_const (topological_space (finset unsigned)) unsigned) : @irreducible_space.{0} (finset.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_40707 (h0 : topological_space (complete_distrib_lattice (option empty))) : preconnected_space (complete_distrib_lattice (option empty)) := sorry --non-trivial
lemma new_lemma_40708 (h0 : finset auto.case_option) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_40709 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (pseudo_metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} h0 (pseudo_metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_40710 (h0 : fin has_zero.zero) : @is_cyclic.{0} (sub_neg_monoid.{0} real) (@matrix.vec_empty.{0} (group.{0} (sub_neg_monoid.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_40711 (h0 : uniform_space (sub_neg_monoid (has_add name))) : separated_space (sub_neg_monoid (has_add name)) := sorry --non-trivial
lemma new_lemma_40712 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_40713 (h0 : monoid (normed_group congr_arg_kind)) : monoid.fg (normed_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_40714 (h0 : ring (distrib_lattice linarith.comp_source)) : is_domain (distrib_lattice linarith.comp_source) := sorry --non-trivial
lemma new_lemma_40715 (h0 : topological_space (measurable_space (random_gen linarith.comp_source))) : discrete_topology (measurable_space (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_40716 (h0 : topological_space (has_add unsigned)) : t1_space (has_add unsigned) := sorry --non-trivial
lemma new_lemma_40717 (h0 : topological_space (has_Sup (semiring empty))) : totally_separated_space (has_Sup (semiring empty)) := sorry --non-trivial
lemma new_lemma_40718 (h0 : complete_lattice (complete_distrib_lattice (has_Inf linarith.comp))) : complete_lattice.is_Sup_finite_compact (complete_distrib_lattice (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_40719 (h0 : list (with_one (has_norm (random_gen fun_info)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_40720 (h0 : functor.add_const (group (has_Sup empty)) empty) : @is_cyclic.{0} (has_Sup.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (has_Sup.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_40721 (h0 : ring (normed_group (random_gen to_additive.value_type))) : strong_rank_condition (normed_group (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_40722 (h0 : ring (add_comm_monoid (comm_group unsigned))) : is_domain (add_comm_monoid (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_40723 (h0 : topological_space (measurable_space (semiring (semiring (semiring linarith.comp))))) : discrete_topology (measurable_space (semiring (semiring (semiring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_40724 (h0 : ring (comm_ring linarith.ineq)) : rank_condition (comm_ring linarith.ineq) := sorry --non-trivial
lemma new_lemma_40725 (h0 : has_mem.mem (linear_ordered_add_comm_group linarith.ineq) has_emptyc.emptyc) : @path_connected_space.{0} (linear_ordered_add_comm_group.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type topological_space.{0} (linear_ordered_add_comm_group.{0} linarith.ineq) h0)  := sorry --non-trivial
lemma new_lemma_40726 (h0 : filter linarith.comp_source) (h1 : linarith.comp_source -> Prop) : @filter.limsup.{0 0} Prop linarith.comp_source (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice) h0 h1  := sorry --non-trivial
lemma new_lemma_40727 (h0 : functor.add_const (list (has_neg name)) Type) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_40728 (h0 : complete_lattice (simple_graph fun_info)) : complete_lattice.is_Sup_finite_compact (simple_graph fun_info) := sorry --non-trivial
lemma new_lemma_40729 (h0 : ring (has_top (has_inv fun_info))) : rank_condition (has_top (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_40730 (h0 : uniform_space (has_nndist (option (option unsigned)))) : complete_space (has_nndist (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_40731 (h0 : complete_lattice (distrib string.iterator_imp)) : is_compactly_generated (distrib string.iterator_imp) := sorry --non-trivial
lemma new_lemma_40732 (h0 : functor.add_const (function.extfun Type topological_space) (finset pos)) : @preconnected_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (finset.{0} pos) h0) (boolean_algebra.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_40733 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (linear_ordered_semiring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type add_group.{0} h0 (linear_ordered_semiring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_40734 (h0 : filter (has_bot num)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_40735 (h0 : not (uniform_space (random_gen (mul_one_class to_additive.value_type)) -> false)) : @complete_space.{0} (random_gen.{0} (mul_one_class.{0} to_additive.value_type)) (@classical.by_contradiction'.{1} (uniform_space.{0} (random_gen.{0} (mul_one_class.{0} to_additive.value_type))) h0)  := sorry --non-trivial
lemma new_lemma_40736 (h0 : function.extfun Type group) : @normalizer_condition.{0} (random_gen.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} h0 (random_gen.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_40737 (h1 : measurable_space char) (h2 : set char) : measurable_set h2 := sorry --non-trivial
lemma new_lemma_40738 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (preorder.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (preorder.{0} num))  := sorry --non-trivial
lemma new_lemma_40739 (h0 : set (mul_one_class (add_comm_semigroup ereal) -> add_comm_semigroup fun_info)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_40740 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (add_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (add_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_40741 (h0 : functor.add_const (uniform_space (has_zero pos)) pos) : @separated_space.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_zero.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_40742 (h0 : topological_space (ring (has_neg (has_neg pos)))) : sequential_space (ring (has_neg (has_neg pos))) := sorry --non-trivial
lemma new_lemma_40743 (h0 : not (group (denumerable linarith.ineq) -> false)) : @group.fg.{0} (denumerable.{0} linarith.ineq) (@classical.by_contradiction'.{1} (group.{0} (denumerable.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_40744 (h0 : add_group (linear_ordered_semiring fun_info)) : is_add_cyclic (linear_ordered_semiring fun_info) := sorry --non-trivial
lemma new_lemma_40745 (h0 : ring (id (has_norm num))) : is_domain (id (has_norm num)) := sorry --non-trivial
lemma new_lemma_40746 (h0 : functor.add_const (group (add_cancel_monoid Type)) Type) : @group.fg.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 1} (group.{1} (add_cancel_monoid.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_40747 (h0 : topological_space (ring (has_add linarith.comp))) : preirreducible_space (ring (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_40748 (h0 : functor.add_const (group (normed_comm_ring empty)) unsigned) : @normalizer_condition.{0} (normed_comm_ring.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (normed_comm_ring.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_40749 (h0 : complete_lattice (has_add (has_to_string linarith.comp))) : complete_lattice.is_Sup_finite_compact (has_add (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_40750 (h0 : function.extfun Type group) : @is_simple_group.{0} (ordered_cancel_add_comm_monoid.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (ordered_cancel_add_comm_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_40751 (h0 : group (finset (ordered_ring (finset pos)))) : normalizer_condition (finset (ordered_ring (finset pos))) := sorry --non-trivial
lemma new_lemma_40752 (h0 : functor.add_const (ring (complete_distrib_lattice Type)) environment.implicit_infer_kind) : @is_principal_ideal_ring.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (complete_distrib_lattice.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_40753 (h0 : topological_space (has_pos_part (has_pos_part (has_neg (finset linarith.comp))))) : totally_separated_space (has_pos_part (has_pos_part (has_neg (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_40754 (h0 : not (filter (measurable_space.dynkin_system empty) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_40755 (h0 : function.extfun Type topological_space) : @t1_space.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_40756 (h0 : group (has_pos_part (has_Inf real))) : group.fg (has_pos_part (has_Inf real)) := sorry --non-trivial
lemma new_lemma_40757 (h0 : functor.add_const (function.extfun Type group) name) : @group.fg.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) name h0) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_40758 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (denumerable.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (denumerable.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_40759 (h0 : topological_space (ordered_comm_monoid (has_neg Type))) : discrete_topology (ordered_comm_monoid (has_neg Type)) := sorry --non-trivial
lemma new_lemma_40760 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (normed_linear_ordered_group.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_linear_ordered_group.{0} num))  := sorry --non-trivial
lemma new_lemma_40761 (h0 : function.extfun Type (functor.add_const (cancel_comm_monoid_with_zero (add_group empty)))) : @unique_factorization_monoid.{0} (add_group.{0} empty) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (add_group.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (cancel_comm_monoid_with_zero.{0} (add_group.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_40762 (h0 : complete_lattice (measurable_space empty)) : is_compactly_generated (measurable_space empty) := sorry --non-trivial
lemma new_lemma_40763 (h0 : functor.add_const (add_group (cancel_monoid ennreal)) unsigned) : @is_add_cyclic.{0} (cancel_monoid.{0} ennreal) (@functor.add_const.run.{0 0} (add_group.{0} (cancel_monoid.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_40764 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (complete_semilattice_Sup.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_semilattice_Sup.{0} empty))  := sorry --non-trivial
lemma new_lemma_40765 (h0 : add_monoid (simple_graph Type)) : add_monoid.fg (simple_graph Type) := sorry --non-trivial
lemma new_lemma_40766 (h0 : function.extfun nat fin) : @totally_disconnected_space.{0} (ordered_comm_ring.{0} name) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_ring.{0} name)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_40767 (h0 : topological_space (normed_comm_ring (has_add name))) : t1_space (normed_comm_ring (has_add name)) := sorry --non-trivial
lemma new_lemma_40768 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @preirreducible_space.{1} (ordered_comm_ring.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (ordered_comm_ring.{1} Type)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_40769 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (canonically_ordered_add_monoid.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (canonically_ordered_add_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_40770 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @discrete_topology.{0} (normed_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (normed_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_40771 (h0 : functor.add_const (filter (finset linarith.comp)) name) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_40772 (h0 : group (add_left_cancel_semigroup congr_arg_kind)) : normalizer_condition (add_left_cancel_semigroup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_40773 (h0 : cancel_comm_monoid_with_zero (ring ennreal)) : unique_factorization_monoid (ring ennreal) := sorry --non-trivial
lemma new_lemma_40774 (h0 : functor.add_const (ring (has_nndist ennreal)) (has_nndist (finset ennreal))) : @is_domain.{0} (has_nndist.{0} ennreal) (@functor.add_const.run.{0 0} (ring.{0} (has_nndist.{0} ennreal)) (has_nndist.{0} (finset.{0} ennreal)) h0)  := sorry --non-trivial
lemma new_lemma_40775 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (complete_distrib_lattice.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} real))  := sorry --non-trivial
lemma new_lemma_40776 (h0 : complete_lattice (has_add (has_add Type))) : is_atomistic (has_add (has_add Type)) := sorry --non-trivial
lemma new_lemma_40777 (h0 : topological_space (add_comm_semigroup (mul_one_class (add_comm_semigroup reducibility_hints)))) (h1 : add_group (add_comm_semigroup (mul_one_class (add_comm_semigroup reducibility_hints)))) : topological_add_group (add_comm_semigroup (mul_one_class (add_comm_semigroup reducibility_hints))) := sorry --non-trivial
lemma new_lemma_40778 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (normed_group.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_group.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_40779 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (add_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_40780 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (ordered_comm_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_40781 (h0 : topological_space (has_pos_part (ordered_comm_monoid Type))) : totally_disconnected_space (has_pos_part (ordered_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_40782 (h0 : topological_space (monoid (option (option (option empty))))) : locally_compact_space (monoid (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_40783 (h0 : ring (id (semiring unsigned))) : strong_rank_condition (id (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_40784 (h0 : ring (add_cancel_monoid (add_cancel_monoid Type))) : is_principal_ideal_ring (add_cancel_monoid (add_cancel_monoid Type)) := sorry --non-trivial
lemma new_lemma_40785 (h0 : functor.add_const (add_monoid (has_nndist Type)) (has_add pos)) : @add_monoid.fg.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (add_monoid.{1} (has_nndist.{1} Type)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_40786 (h0 : ordered_comm_monoid (option (has_to_string pos))) : has_exists_mul_of_le (option (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_40787 (h0 : uniform_space (denumerable (random_gen linarith.comp_source))) : complete_space (denumerable (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_40788 (h0 : fin has_zero.zero) : @preirreducible_space.{1} (ordered_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (ordered_comm_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_40789 (h0 : topological_space (has_add (has_add (has_to_string pos)))) : path_connected_space (has_add (has_add (has_to_string pos))) := sorry --non-trivial
lemma new_lemma_40790 (h0 : topological_space (linear_ordered_add_comm_group num)) : irreducible_space (linear_ordered_add_comm_group num) := sorry --non-trivial
lemma new_lemma_40791 (h0 : has_mem.mem (has_emptyc linarith.comp) has_emptyc.emptyc) : @t0_space.{0} (has_emptyc.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_emptyc.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_40792 (h0 : finset (has_neg_part (comm_group (boolean_algebra name)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_40793 (h0 : functor.add_const (filter (has_neg environment.implicit_infer_kind)) name) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_40794 (h0 : set (has_compl (mul_one_class linarith.ineq))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_40795 (h1 : not (topological_space (semi_normed_ring string_imp) -> false)) : @path_connected_space.{0} (semi_normed_ring.{0} string_imp) (@classical.by_contradiction'.{1} (topological_space.{0} (semi_normed_ring.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_40796 (h0 : false) : @Lim.{0} Prop sierpinski_space (@nonempty_of_inhabited.{1} Prop sort.inhabited.{0}) (@list.head.{0} (filter.{0} Prop) (@filter.inhabited.{0} Prop) (@false.elim.{1} (list.{0} (filter.{0} Prop)) (@id.{0} false h0)))  := sorry --trivial
lemma new_lemma_40797 (h0 : ring (has_add (has_nnnorm linarith.comp_source))) : rank_condition (has_add (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_40798 (h0 : topological_space (ordered_ring (semiring num))) : t1_space (ordered_ring (semiring num)) := sorry --non-trivial
lemma new_lemma_40799 (h0 : topological_space (add_right_cancel_monoid unsigned)) : loc_path_connected_space (add_right_cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_40800 (h0 : functor.add_const (ring (semigroup Type)) (ordered_comm_monoid (ring pos))) : @strong_rank_condition.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (semigroup.{1} Type)) (ordered_comm_monoid.{0} (ring.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_40801 (h0 : group (ordered_ring unsigned)) : is_cyclic (ordered_ring unsigned) := sorry --non-trivial
lemma new_lemma_40802 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_atomistic.{1} (generalized_boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 complete_lattice.{1}) (generalized_boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_40803 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (canonically_linear_ordered_monoid (option unsigned))) := sorry --non-trivial
lemma new_lemma_40804 (h0 : functor.add_const (group (has_Sup congr_arg_kind)) unsigned) : @normalizer_condition.{0} (has_Sup.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (group.{0} (has_Sup.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_40805 (h0 : ring (ordered_comm_ring (has_bot Type))) : rank_condition (ordered_comm_ring (has_bot Type)) := sorry --non-trivial
lemma new_lemma_40806 (h0 : topological_space (normed_linear_ordered_group name)) : preconnected_space (normed_linear_ordered_group name) := sorry --non-trivial
lemma new_lemma_40807 (h0 : function.extfun Type (functor.add_const (topological_space auto.case_option))) : @discrete_topology.{0} auto.case_option (@functor.add_const.run.{0 0} (topological_space.{0} auto.case_option) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} auto.case_option)) h0 num))  := sorry --non-trivial
lemma new_lemma_40808 (h0 : topological_space (has_to_string (finset Type))) : preirreducible_space (has_to_string (finset Type)) := sorry --non-trivial
lemma new_lemma_40809 (h0 : add_group (linear_ordered_semiring (has_top num))) : is_add_cyclic (linear_ordered_semiring (has_top num)) := sorry --non-trivial
lemma new_lemma_40810 (h0 : add_group (normed_field (has_nnnorm (has_nnnorm reducibility_hints)))) : is_add_cyclic (normed_field (has_nnnorm (has_nnnorm reducibility_hints))) := sorry --non-trivial
lemma new_lemma_40811 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_to_string.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} name))  := sorry --non-trivial
lemma new_lemma_40812 (h0 : function.extfun Type group) : @group.fg.{0} (add_comm_monoid.{0} real) (@function.extfun_app.{2 1} Type group.{0} h0 (add_comm_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_40813 (h0 : topological_space (canonically_ordered_comm_semiring (has_add Type))) : topological_space.separable_space (canonically_ordered_comm_semiring (has_add Type)) := sorry --non-trivial
lemma new_lemma_40814 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (distrib_lattice.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (distrib_lattice.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_40815 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (ring.{0} num) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (ring.{0} num))  := sorry --non-trivial
lemma new_lemma_40816 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (@id.{2} Type linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (@id.{2} Type linarith.comp))  := sorry --non-trivial
lemma new_lemma_40817 (h0 : ring (simple_graph environment.projection_info)) : is_domain (simple_graph environment.projection_info) := sorry --non-trivial
lemma new_lemma_40818 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (with_bot.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (with_bot.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_40819 (h0 : topological_space (option (semiring (semiring congr_arg_kind)))) : locally_compact_space (option (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_40820 (h0 : topological_space (ring (finset environment.implicit_infer_kind))) : path_connected_space (ring (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_40821 (h0 : uniform_space (complete_semilattice_Sup (random_gen to_additive.value_type))) : complete_space (complete_semilattice_Sup (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_40822 (h0 : functor.add_const (uniform_space (normed_comm_ring name)) name) : @separated_space.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (normed_comm_ring.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_40823 (h0 : topological_space (has_one (has_norm (has_norm empty)))) : path_connected_space (has_one (has_norm (has_norm empty))) := sorry --non-trivial
lemma new_lemma_40824 (h0 : fin has_zero.zero) : matrix.vec_empty (matrix.vec_empty (id (id (matrix.vec_empty h0)))) := sorry --non-trivial
lemma new_lemma_40825 (h0 : functor.add_const (function.extfun Type uniform_space) name) : @complete_space.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) name h0) (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_40826 (h0 : functor.add_const (ordered_add_comm_monoid (generalized_boolean_algebra name)) (ring (ring linarith.comp))) : @archimedean.{0} (generalized_boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (generalized_boolean_algebra.{0} name)) (ring.{0} (ring.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_40827 (h0 : functor.add_const (topological_space (normed_linear_ordered_group num)) empty) : @path_connected_space.{0} (normed_linear_ordered_group.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_linear_ordered_group.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_40828 (h0 : ordered_add_comm_monoid (has_neg (has_add pos))) : archimedean (has_neg (has_add pos)) := sorry --non-trivial
lemma new_lemma_40829 (h0 : function.extfun Type (functor.comp topological_space has_zero)) : @topological_space.separable_space.{0} (has_zero.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} has_zero.{0} ennreal (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} has_zero.{0}) h0 ennreal))  := sorry --non-trivial
lemma new_lemma_40830 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (add_right_cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (add_right_cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_40831 (h0 : functor.add_const (monoid (has_star empty)) congr_arg_kind) : @monoid.fg.{0} (has_star.{0} empty) (@functor.add_const.run.{0 0} (monoid.{0} (has_star.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_40832 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_40833 (h0 : has_mem.mem to_additive.value_type has_emptyc.emptyc) : @totally_disconnected_space.{0} to_additive.value_type (@finset.pi.empty.{1 0} Type topological_space.{0} to_additive.value_type h0)  := sorry --non-trivial
lemma new_lemma_40834 (h0 : std_gen -> std_gen -> std_gen) (h1 : std_gen -> std_gen) (h2 : std_gen) : right_inverse h0 h1 h2 := sorry --non-trivial
lemma new_lemma_40835 (h0 : functor.comp topological_space option (option num)) : @totally_separated_space.{0} (option.{0} (option.{0} num)) (@functor.comp.run.{0 0 0} topological_space.{0} option.{0} (option.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_40836 (h0 : complete_lattice (has_neg_part (boolean_algebra.core (finset (has_add name))))) : is_compactly_generated (has_neg_part (boolean_algebra.core (finset (has_add name)))) := sorry --non-trivial
lemma new_lemma_40837 (h0 : functor.add_const (function.extfun Type topological_space) (finset linarith.comp)) : @t0_space.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (finset.{0} linarith.comp) h0) (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_40838 (h0 : group (has_dist ennreal)) : normalizer_condition (has_dist ennreal) := sorry --non-trivial
lemma new_lemma_40839 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (comm_group.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_group.{0} name))  := sorry --non-trivial
lemma new_lemma_40840 (h0 : topological_space environment.implicit_infer_kind) : locally_compact_space environment.implicit_infer_kind := sorry --non-trivial
lemma new_lemma_40841 (h0 : list (normed_linear_ordered_group num)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_40842 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (normed_comm_ring.{0} (option.{0} (option.{0} ennreal))) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} (option.{0} (option.{0} ennreal))))  := sorry --non-trivial
lemma new_lemma_40843 (h0 : not (ring (linear_ordered_comm_ring empty) -> false)) : @is_domain.{0} (linear_ordered_comm_ring.{0} empty) (@classical.by_contradiction'.{1} (ring.{0} (linear_ordered_comm_ring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_40844 (h0 : functor.add_const (group (has_to_string pos)) (has_neg Type)) : @is_cyclic.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (has_to_string.{0} pos)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_40845 (h0 : ring (has_add (option congr_arg_kind))) : rank_condition (has_add (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_40846 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (measurable_space.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (measurable_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_40847 (h0 : not (ring (has_top unsigned) -> false)) : @is_domain.{0} (has_top.{0} unsigned) (@classical.by_contradiction'.{1} (ring.{0} (has_top.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_40848 (h0 : functor.add_const (ordered_comm_monoid (has_add name)) pos) : @has_exists_mul_of_le.{0} (has_add.{0} name) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_add.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_40849 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (has_zero Type)) := sorry --non-trivial
lemma new_lemma_40850 (h0 : group (comm_semigroup real)) : is_cyclic (comm_semigroup real) := sorry --non-trivial
lemma new_lemma_40851 (h0 : topological_space (has_pos_part (ordered_comm_ring (ordered_comm_ring name)))) : normal_space (has_pos_part (ordered_comm_ring (ordered_comm_ring name))) := sorry --non-trivial
lemma new_lemma_40852 (h0 : function.extfun Type (functor.add_const Prop)) : functor.add_const.run (function.extfun_app h0 (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_40853 (h0 : topological_space (add_cancel_monoid (has_neg (has_neg Type)))) : sequential_space (add_cancel_monoid (has_neg (has_neg Type))) := sorry --non-trivial
lemma new_lemma_40854 (h0 : topological_space (canonically_ordered_monoid (has_add pos))) : regular_space (canonically_ordered_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_40855 (h0 : function.extfun (finset Type) (has_mem.mem (has_norm linarith.comp_source))) : @complete_lattice.is_Sup_finite_compact.{0} (has_norm.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (has_norm.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_norm.{0} linarith.comp_source)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_40856 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (canonically_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (canonically_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_40857 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @preirreducible_space.{0} (ordered_comm_ring.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_ring.{0} real)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_40858 (h0 : uniform_space (normed_linear_ordered_group (option (option (option unsigned))))) : complete_space (normed_linear_ordered_group (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_40859 (h0 : uniform_space (finset environment.implicit_infer_kind)) : separated_space (finset environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_40860 (h0 : ring (left_cancel_semigroup num)) : rank_condition (left_cancel_semigroup num) := sorry --non-trivial
lemma new_lemma_40861 (h0 : complete_lattice (id (random_gen linarith.ineq))) : complete_lattice.is_Sup_finite_compact (id (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_40862 (h0 : functor.add_const (topological_space (mul_zero_class name)) name) : @totally_separated_space.{0} (mul_zero_class.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_40863 (h0 : function.extfun nat fin) : @is_domain.{0} (simple_graph.{0} name) (@matrix.vec_empty.{0} (ring.{0} (simple_graph.{0} name)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_40864 (h0 : ring (canonically_ordered_comm_semiring (finset name))) : is_principal_ideal_ring (canonically_ordered_comm_semiring (finset name)) := sorry --non-trivial
lemma new_lemma_40865 (h0 : function.extfun nat fin) : @loc_path_connected_space.{0} (has_bot.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (has_bot.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_40866 (h0 : ordered_comm_monoid (has_add (finset name))) : has_exists_mul_of_le (has_add (finset name)) := sorry --non-trivial
lemma new_lemma_40867 (h0 : function.extfun (finset Type) (has_mem.mem (random_gen to_additive.value_type))) : @is_atomistic.{0} (random_gen.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (random_gen.{0} to_additive.value_type) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} to_additive.value_type)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_40868 (h0 : fin has_zero.zero) : @complete_lattice.is_Sup_finite_compact.{0} (has_Inf.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (has_Inf.{0} name))  := sorry --non-trivial
lemma new_lemma_40869 (h0 : topological_space (has_Sup num)) : totally_disconnected_space (has_Sup num) := sorry --non-trivial
lemma new_lemma_40870 (h0 : topological_space (ring name)) : t0_space (ring name) := sorry --non-trivial
lemma new_lemma_40871 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (boolean_algebra.core.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} pos))  := sorry --non-trivial
lemma new_lemma_40872 (h0 : ordered_comm_monoid (has_to_string (option unsigned))) : has_exists_mul_of_le (has_to_string (option unsigned)) := sorry --non-trivial
lemma new_lemma_40873 (h0 : not (has_mem.mem (complete_semilattice_Sup linarith.comp_source) has_emptyc.emptyc -> false)) : @path_connected_space.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (complete_semilattice_Sup.{0} linarith.comp_source) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_40874 (h0 : functor.add_const (list (comm_group linarith.comp)) environment.implicit_infer_kind) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_40875 (h0 : functor.add_const (group (free_add_monoid unsigned)) congr_arg_kind) : @group.fg.{0} (free_add_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (free_add_monoid.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_40876 (h0 : functor.comp topological_space comm_group name) : @totally_disconnected_space.{0} (comm_group.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} comm_group.{0} name h0)  := sorry --non-trivial
lemma new_lemma_40877 (h0 : semiring (metric_space (has_norm congr_arg_kind))) : is_noetherian_ring (metric_space (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_40878 (h0 : topological_space (sub_neg_monoid (has_neg (has_bot (has_bot real))))) : path_connected_space (sub_neg_monoid (has_neg (has_bot (has_bot real)))) := sorry --non-trivial
lemma new_lemma_40879 (h0 : topological_space (add_semigroup (semiring (semiring empty)))) : totally_disconnected_space (add_semigroup (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_40880 (h0 : cancel_comm_monoid_with_zero (non_assoc_semiring unsigned)) : unique_factorization_monoid (non_assoc_semiring unsigned) := sorry --non-trivial
lemma new_lemma_40881 (h0 : cancel_comm_monoid_with_zero (has_Sup unsigned)) : unique_factorization_monoid (has_Sup unsigned) := sorry --non-trivial
lemma new_lemma_40882 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_top.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_top.{0} empty))  := sorry --non-trivial
lemma new_lemma_40883 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (partial_order.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (partial_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_40884 (h0 : topological_space (boolean_algebra (semigroup environment.implicit_infer_kind))) : locally_compact_space (boolean_algebra (semigroup environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_40885 (h1 : topological_space (mul_one_class (mul_one_class (add_comm_semigroup (add_comm_semigroup enat))))) : t0_space (mul_one_class (mul_one_class (add_comm_semigroup (add_comm_semigroup enat)))) := sorry --non-trivial
lemma new_lemma_40886 (h0 : complete_lattice (has_add (has_to_string congr_arg_kind))) : is_atomistic (has_add (has_to_string congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_40887 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (mul_zero_class.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (mul_zero_class.{0} name))  := sorry --non-trivial
lemma new_lemma_40888 (h0 : topological_space (measurable_space.dynkin_system unsigned)) : preirreducible_space (measurable_space.dynkin_system unsigned) := sorry --non-trivial
lemma new_lemma_40889 (h0 : functor.add_const (group (finset Type)) Type) : @is_cyclic.{1} (finset.{1} Type) (@functor.add_const.run.{1 1} (group.{1} (finset.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_40890 (h0 : fin has_zero.zero) : @t0_space.{1} (finset.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (finset.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_40891 (h0 : function.extfun (Type 1) list) : palindrome (function.extfun_app h0 (ordered_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_40892 (h0 : group (linear_order num)) : is_cyclic (linear_order num) := sorry --non-trivial
lemma new_lemma_40893 (h0 : not (complete_lattice (id empty) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (@id.{2} Type empty) (@classical.by_contradiction'.{1} (complete_lattice.{0} (@id.{2} Type empty)) h0)  := sorry --non-trivial
lemma new_lemma_40894 (h0 : has_lt (has_ssubset char)) : no_max_order (has_ssubset char) := sorry --non-trivial
lemma new_lemma_40895 (h0 : function.extfun (Type 1) ordered_comm_monoid) : @has_exists_mul_of_le.{1} (boolean_algebra.core.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_comm_monoid.{1} h0 (boolean_algebra.core.{1} Type))  := sorry --non-trivial
lemma new_lemma_40896 (h0 : filter (has_neg (has_to_string Type))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_40897 (h0 : topological_space (semiring (has_top fun_info))) : totally_separated_space (semiring (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_40898 (h0 : semiring (boolean_algebra.core (finset pos))) : is_noetherian_ring (boolean_algebra.core (finset pos)) := sorry --non-trivial
lemma new_lemma_40899 (h0 : ring (has_add (has_pos_part linarith.comp))) : rank_condition (has_add (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_40900 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 linarith.ineq) := sorry --non-trivial
lemma new_lemma_40901 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (pseudo_metric_space.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (pseudo_metric_space.{0} num))  := sorry --non-trivial
lemma new_lemma_40902 (h0 : topological_space Prop) (h1 : filter Prop) (h2 : filter.ne_bot h1) : @Lim'.{0} Prop h0 h1 h2  := sorry --non-trivial
lemma new_lemma_40903 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (linear_ordered_comm_group.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (linear_ordered_comm_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_40904 (h2 : uniform_space (distrib (has_ssubset (linear_ordered_cancel_comm_monoid (has_ssubset char))))) : complete_space (distrib (has_ssubset (linear_ordered_cancel_comm_monoid (has_ssubset char)))) := sorry --non-trivial
lemma new_lemma_40905 (h0 : topological_space (generalized_boolean_algebra (has_Inf Type))) : totally_separated_space (generalized_boolean_algebra (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_40906 (h0 : functor.add_const (ring (semigroup pos)) linarith.comp) : @is_domain.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (semigroup.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_40907 (h0 : topological_space (div_inv_monoid fun_info)) : t0_space (div_inv_monoid fun_info) := sorry --non-trivial
lemma new_lemma_40908 (h0 : finset (has_add (finset (finset (finset pos))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_40909 (h0 : ring (add_comm_monoid (has_neg_part Type))) : rank_condition (add_comm_monoid (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_40910 (h0 : ring (finset name)) : is_domain (finset name) := sorry --non-trivial
lemma new_lemma_40911 (h1 : ring (has_div linarith.comp_source)) : is_domain (has_div linarith.comp_source) := sorry --non-trivial
lemma new_lemma_40912 (h0 : ring (normed_group linarith.comp)) : is_domain (normed_group linarith.comp) := sorry --non-trivial
lemma new_lemma_40913 (h0 : topological_space nnreal) : discrete_topology nnreal := sorry --non-trivial
lemma new_lemma_40914 (h0 : functor.add_const (ordered_comm_monoid (ordered_comm_ring name)) pos) : @has_exists_mul_of_le.{0} (ordered_comm_ring.{0} name) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (ordered_comm_ring.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_40915 (h0 : filter (with_bot linarith.comp_source)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_40916 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_40917 (h0 : add_monoid (boolean_algebra.core (comm_group environment.implicit_infer_kind))) : add_monoid.fg (boolean_algebra.core (comm_group environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_40918 (h0 : semiring char) (h1 : char) : even h1 := sorry --non-trivial
lemma new_lemma_40919 (h0 : functor.add_const (complete_lattice (has_add real.angle)) pos) : @is_atomistic.{0} (has_add.{0} real.angle) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_add.{0} real.angle)) pos h0)  := sorry --non-trivial
lemma new_lemma_40920 (h1 : not (function.extfun Type ring -> false)) : @rank_condition.{0} (measurable_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h1) (measurable_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_40921 (h0 : semiring (ordered_cancel_add_comm_monoid (has_to_string congr_arg_kind))) : is_noetherian_ring (ordered_cancel_add_comm_monoid (has_to_string congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_40922 (h0 : filter (has_Sup unsigned)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_40923 (h0 : fin has_zero.zero) : @complete_space.{0} (complete_distrib_lattice.{0} real) (@matrix.vec_empty.{0} (uniform_space.{0} (complete_distrib_lattice.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_40924 (h0 : semiring (ring (mul_one_class pos))) : is_noetherian_ring (ring (mul_one_class pos)) := sorry --non-trivial
lemma new_lemma_40925 (h0 : fin has_zero.zero) : @t1_space.{0} (ordered_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (ordered_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_40926 (h0 : function.extfun (Type 1) group) : @is_cyclic.{1} (canonically_ordered_comm_semiring.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} h0 (canonically_ordered_comm_semiring.{1} Type))  := sorry --non-trivial
lemma new_lemma_40927 (h0 : functor.add_const (topological_space (has_neg unsigned)) Type) : @regular_space.{0} (has_neg.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_40928 (h0 : topological_space (mul_one_class (mul_one_class string.iterator_imp))) : topological_space.first_countable_topology (mul_one_class (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_40929 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem monoid)) : @monoid.fg.{0} (semiring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type monoid.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) monoid.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) monoid.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (semiring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_40930 (h0 : not (uniform_space (normed_group empty) -> false)) : @complete_space.{0} (normed_group.{0} empty) (@classical.by_contradiction'.{1} (uniform_space.{0} (normed_group.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_40931 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_40932 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (normed_group.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_40933 (h0 : function.extfun (Type 1) ring) : @rank_condition.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_40934 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_Sup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_Sup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_40935 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (linear_ordered_comm_group.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (linear_ordered_comm_group.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_40936 (h0 : topological_space (generalized_boolean_algebra (has_Inf real))) : irreducible_space (generalized_boolean_algebra (has_Inf real)) := sorry --non-trivial
lemma new_lemma_40937 (h0 : functor.add_const (function.extfun Type topological_space) name) : @irreducible_space.{0} (generalized_boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (generalized_boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_40938 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (cancel_monoid ennreal)) := sorry --non-trivial
lemma new_lemma_40939 (h0 : functor.add_const (topological_space (has_to_string Type)) name) : @t1_space.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_to_string.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_40940 (h0 : functor.add_const (topological_space (has_neg_part name)) pos) : @totally_separated_space.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_40941 (h0 : uniform_space (has_nndist (option (option (option (option ennreal)))))) : complete_space (has_nndist (option (option (option (option ennreal))))) := sorry --non-trivial
lemma new_lemma_40942 (h0 : ring (add_cancel_comm_monoid (comm_ring reducibility_hints))) : strong_rank_condition (add_cancel_comm_monoid (comm_ring reducibility_hints)) := sorry --non-trivial
lemma new_lemma_40943 (h0 : complete_lattice (canonically_linear_ordered_monoid (has_add real))) : is_compactly_generated (canonically_linear_ordered_monoid (has_add real)) := sorry --non-trivial
lemma new_lemma_40944 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (sub_neg_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (sub_neg_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_40945 (h0 : functor.add_const (add_group (add_cancel_monoid linarith.comp)) pos) : @is_add_cyclic.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_group.{0} (add_cancel_monoid.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_40946 (h0 : ring (simple_graph to_additive.value_type)) : strong_rank_condition (simple_graph to_additive.value_type) := sorry --non-trivial
lemma new_lemma_40947 (h1 : filter (with_one char)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_40948 (h0 : group (complete_distrib_lattice (complete_distrib_lattice num))) : is_cyclic (complete_distrib_lattice (complete_distrib_lattice num)) := sorry --non-trivial
lemma new_lemma_40949 (h0 : functor.add_const (cancel_comm_monoid_with_zero (preorder unsigned)) unsigned) : @unique_factorization_monoid.{0} (preorder.{0} unsigned) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (preorder.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_40950 (h0 : function.extfun (finset Type) (has_mem.mem (random_gen fun_info))) : @totally_disconnected_space.{0} (random_gen.{0} fun_info) (@finset.pi.empty.{1 0} Type topological_space.{0} (random_gen.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_40951 (h0 : functor.add_const (topological_space (has_zero pos)) linarith.comp) : @path_connected_space.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_40952 (h0 : filter (cancel_monoid num)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_40953 (h0 : functor.add_const (list (finset linarith.comp)) pos) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_40954 (h0 : topological_space (with_one linarith.comp_source)) : totally_separated_space (with_one linarith.comp_source) := sorry --non-trivial
lemma new_lemma_40955 (h0 : topological_space (normed_group (has_nnnorm string_imp))) : t0_space (normed_group (has_nnnorm string_imp)) := sorry --non-trivial
lemma new_lemma_40956 (h0 : filter (has_nndist (has_nndist (finset ennreal)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_40957 (h0 : ring (monoid (option empty))) : strong_rank_condition (monoid (option empty)) := sorry --non-trivial
lemma new_lemma_40958 (h0 : functor.add_const (add_monoid (has_add pos)) (ring (ring (ring environment.implicit_infer_kind)))) : @add_monoid.fg.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_add.{0} pos)) (ring.{0} (ring.{0} (ring.{0} environment.implicit_infer_kind))) h0)  := sorry --non-trivial
lemma new_lemma_40959 (h1 : not (topological_space (has_lt string_imp) -> false)) : @path_connected_space.{0} (has_lt.{0} string_imp) (@classical.by_contradiction'.{1} (topological_space.{0} (has_lt.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_40960 (h2 : complete_lattice linarith.comp_source) : is_compactly_generated linarith.comp_source := sorry --non-trivial
lemma new_lemma_40961 (h0 : not (topological_space (dlist fun_info) -> false)) : @locally_compact_space.{0} (dlist.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (dlist.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_40962 (h0 : topological_space (pseudo_emetric_space (generalized_boolean_algebra (has_add real)))) : t0_space (pseudo_emetric_space (generalized_boolean_algebra (has_add real))) := sorry --non-trivial
lemma new_lemma_40963 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_nndist.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_nndist.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_40964 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (with_one.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (with_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_40965 (h0 : not (has_mem.mem (has_top fun_info) has_emptyc.emptyc -> false)) : @is_atomistic.{0} (has_top.{0} fun_info) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (has_top.{0} fun_info) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_top.{0} fun_info) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_40966 (h0 : ordered_add_comm_monoid (monoid num)) : archimedean (monoid num) := sorry --non-trivial
lemma new_lemma_40967 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (has_neg.{0} (finset.{0} name)) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_neg.{0} (finset.{0} name)))  := sorry --non-trivial
lemma new_lemma_40968 (h0 : group (finset Type)) : is_cyclic (finset Type) := sorry --non-trivial
lemma new_lemma_40969 (h0 : functor.add_const (functor.add_const (cancel_comm_monoid_with_zero Type) pos) Type) : @unique_factorization_monoid.{1} Type (@functor.add_const.run.{1 0} (cancel_comm_monoid_with_zero.{1} Type) pos (@functor.add_const.run.{1 1} (functor.add_const.{1 0} (cancel_comm_monoid_with_zero.{1} Type) pos) Type h0))  := sorry --non-trivial
lemma new_lemma_40970 (h0 : not (topological_space (has_nnnorm to_additive.value_type) -> false)) : @totally_disconnected_space.{0} (has_nnnorm.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (has_nnnorm.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_40971 (h0 : has_mul (has_append char)) (h1 : has_zero (has_append char)) : no_zero_divisors (has_append char) := sorry --non-trivial
lemma new_lemma_40972 (h0 : complete_lattice (measurable_space empty)) : complete_lattice.is_Sup_finite_compact (measurable_space empty) := sorry --non-trivial
lemma new_lemma_40973 (h0 : functor.add_const (topological_space (normed_comm_ring (has_Inf (has_pos_part pos)))) Type) : @t0_space.{0} (normed_comm_ring.{0} (has_Inf.{0} (has_pos_part.{0} pos))) (@functor.add_const.run.{0 1} (topological_space.{0} (normed_comm_ring.{0} (has_Inf.{0} (has_pos_part.{0} pos)))) Type h0)  := sorry --non-trivial
lemma new_lemma_40974 (h0 : topological_space (finset ennreal)) : totally_disconnected_space (finset ennreal) := sorry --non-trivial
lemma new_lemma_40975 (h0 : topological_space (has_nndist (finset Type))) : loc_path_connected_space (has_nndist (finset Type)) := sorry --non-trivial
lemma new_lemma_40976 (h0 : topological_space (linear_ordered_semiring (semiring (semiring unsigned)))) : totally_separated_space (linear_ordered_semiring (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_40977 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (has_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_40978 (h0 : topological_space (has_Inf (has_Inf (has_Inf (has_Inf Type))))) : topological_space.separable_space (has_Inf (has_Inf (has_Inf (has_Inf Type)))) := sorry --non-trivial
lemma new_lemma_40979 (h0 : ring (fintype linarith.ineq)) : rank_condition (fintype linarith.ineq) := sorry --non-trivial
lemma new_lemma_40980 (h0 : functor.add_const (function.extfun Type list) (has_add linarith.comp)) : list.nodup (function.extfun_app (functor.add_const.run h0) (has_nndist linarith.comp)) := sorry --non-trivial
lemma new_lemma_40981 (h0 : functor.add_const (ordered_add_comm_monoid (has_Inf pos)) Type) : @archimedean.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 1} (ordered_add_comm_monoid.{0} (has_Inf.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_40982 (h0 : function.extfun Type (functor.add_const (topological_space (has_Sup unsigned)))) : @t0_space.{0} (has_Sup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Sup.{0} unsigned)) congr_arg_kind (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (has_Sup.{0} unsigned))) h0 congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_40983 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : countable_Inter_filter (function.extfun_app (function.extfun_app h0 filter) pos) := sorry --non-trivial
lemma new_lemma_40984 (h0 : function.extfun Type (functor.comp group has_neg)) : @is_cyclic.{0} (has_neg.{0} pos) (@functor.comp.run.{0 0 0} group.{0} has_neg.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} group.{0} has_neg.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_40985 (h0 : topological_space (random_gen (metric_space empty))) : irreducible_space (random_gen (metric_space empty)) := sorry --non-trivial
lemma new_lemma_40986 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_40987 (h0 : topological_space (has_pos_part (has_Inf (finset (ring pos))))) : regular_space (has_pos_part (has_Inf (finset (ring pos)))) := sorry --non-trivial
lemma new_lemma_40988 (h1 : ring (encodable fun_info)) : is_domain (encodable fun_info) := sorry --non-trivial
lemma new_lemma_40989 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (measure_theory.measure_space.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (measure_theory.measure_space.{0} num))  := sorry --non-trivial
lemma new_lemma_40990 (h0 : filter (finset environment.implicit_infer_kind)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_40991 (h0 : monoid (distrib_lattice (has_inv to_additive.value_type))) : monoid.fg (distrib_lattice (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_40992 (h1 : not (add_group (has_add char) -> false)) : @is_add_cyclic.{0} (has_add.{0} char) (@classical.by_contradiction'.{1} (add_group.{0} (has_add.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_40993 (h0 : topological_space (id (random_gen fun_info))) : totally_separated_space (id (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_40994 (h0 : monoid (with_bot (has_norm num))) : monoid.fg (with_bot (has_norm num)) := sorry --non-trivial
lemma new_lemma_40995 (h0 : functor.add_const (ring (has_zero linarith.comp)) Type) : @is_principal_ideal_ring.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 1} (ring.{0} (has_zero.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_40996 (h1 : complete_lattice (has_compl std_gen)) : is_compactly_generated (has_compl std_gen) := sorry --non-trivial
lemma new_lemma_40997 (h0 : topological_space (boolean_algebra (has_to_string (has_to_string (finset pos))))) : t1_space (boolean_algebra (has_to_string (has_to_string (finset pos)))) := sorry --non-trivial
lemma new_lemma_40998 (h0 : functor.add_const (list (has_pos_part name)) pos) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_40999 (h0 : filter (plift (semiring (semiring unsigned)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_41000 (h0 : add_comm_semigroup (add_comm_semigroup std_gen) -> add_comm_semigroup (add_comm_semigroup std_gen)) (h1 : add_comm_semigroup (add_comm_semigroup std_gen)) : function.is_fixed_pt h0 h1 := sorry --non-trivial
lemma new_lemma_41001 (h0 : not (topological_space (normed_field (random_gen reducibility_hints)) -> false)) : @totally_disconnected_space.{0} (normed_field.{0} (random_gen.{0} reducibility_hints)) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_field.{0} (random_gen.{0} reducibility_hints))) h0)  := sorry --non-trivial
lemma new_lemma_41002 (h0 : functor.add_const (function.extfun Type topological_space) (boolean_algebra name)) : @totally_separated_space.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (boolean_algebra.{0} name) h0) (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_41003 (h0 : functor.add_const (topological_space (add_left_cancel_semigroup (semiring unsigned))) empty) : @discrete_topology.{0} (add_left_cancel_semigroup.{0} (semiring.{0} unsigned)) (@functor.add_const.run.{0 0} (topological_space.{0} (add_left_cancel_semigroup.{0} (semiring.{0} unsigned))) empty h0)  := sorry --non-trivial
lemma new_lemma_41004 (h0 : topological_space (has_ssubset fun_info)) : path_connected_space (has_ssubset fun_info) := sorry --non-trivial
lemma new_lemma_41005 (h0 : functor.add_const (topological_space (has_neg_part unsigned)) name) : @totally_separated_space.{0} (has_neg_part.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_41006 (h0 : not (monoid (has_emptyc congr_arg_kind) -> false)) : @monoid.fg.{0} (has_emptyc.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (monoid.{0} (has_emptyc.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_41007 (h0 : group (normed_lattice_add_comm_group (has_Inf name))) : normalizer_condition (normed_lattice_add_comm_group (has_Inf name)) := sorry --non-trivial
lemma new_lemma_41008 (h0 : not (topological_space (has_ssubset linarith.comp_source) -> false)) : @path_connected_space.{0} (has_ssubset.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (has_ssubset.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_41009 (h0 : ordered_add_comm_monoid (comm_semigroup (comm_semigroup real))) : archimedean (comm_semigroup (comm_semigroup real)) := sorry --non-trivial
lemma new_lemma_41010 (h0 : topological_space (linear_ordered_comm_monoid_with_zero congr_arg_kind)) : normal_space (linear_ordered_comm_monoid_with_zero congr_arg_kind) := sorry --non-trivial
lemma new_lemma_41011 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (random_gen.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (random_gen.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_41012 (h0 : ring (has_compl (random_gen fun_info))) : is_domain (has_compl (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_41013 (h0 : functor.add_const (ring (add_cancel_monoid Type)) linarith.comp) : @rank_condition.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (add_cancel_monoid.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_41014 (h0 : functor.add_const (add_group (has_add pos)) linarith.comp) : @is_add_cyclic.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (has_add.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_41015 (h0 : prod (finset (finset (finset Type))) (finset (finset (finset Type)))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_41016 (h0 : topological_space (semiring num)) : totally_separated_space (semiring num) := sorry --non-trivial
lemma new_lemma_41017 (h0 : topological_space (boolean_algebra (has_add environment.implicit_infer_kind))) : totally_disconnected_space (boolean_algebra (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_41018 (h0 : functor.add_const Prop (has_zero (comm_group (has_to_string Type)))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_41019 (h0 : topological_space (complete_distrib_lattice (has_to_string unsigned))) : regular_space (complete_distrib_lattice (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_41020 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (has_nndist.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_nndist.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_41021 (h0 : functor.add_const (function.extfun (Type 1) list) Type) : palindrome (function.extfun_app (functor.add_const.run h0) (add_cancel_monoid Type)) := sorry --non-trivial
lemma new_lemma_41022 (h0 : group (distrib_lattice (has_nnnorm (boolean_algebra.core string_imp)))) : is_cyclic (distrib_lattice (has_nnnorm (boolean_algebra.core string_imp))) := sorry --non-trivial
lemma new_lemma_41023 (h0 : add_group (cancel_monoid (comm_group Type))) : is_add_cyclic (cancel_monoid (comm_group Type)) := sorry --non-trivial
lemma new_lemma_41024 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (boolean_algebra.core unsigned)) := sorry --non-trivial
lemma new_lemma_41025 (h0 : topological_space (has_top (complete_semilattice_Sup char))) : locally_compact_space (has_top (complete_semilattice_Sup char)) := sorry --non-trivial
lemma new_lemma_41026 (h0 : complete_lattice (has_lt (mul_one_class (mul_one_class fun_info)))) : is_compactly_generated (has_lt (mul_one_class (mul_one_class fun_info))) := sorry --non-trivial
lemma new_lemma_41027 (h0 : ring (linear_ordered_comm_ring (has_top empty))) : is_domain (linear_ordered_comm_ring (has_top empty)) := sorry --non-trivial
lemma new_lemma_41028 (h0 : function.extfun nat fin) : @normal_space.{0} (has_bot.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (has_bot.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_41029 (h0 : functor.add_const (complete_lattice (has_to_string pos)) (has_neg (ring pos))) : @is_compactly_generated.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_to_string.{0} pos)) (has_neg.{0} (ring.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_41030 (h0 : ring (option (semiring (semiring (semiring congr_arg_kind))))) : is_domain (option (semiring (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_41031 (h2 : uniform_space (non_unital_non_assoc_semiring string_imp)) : complete_space (non_unital_non_assoc_semiring string_imp) := sorry --non-trivial
lemma new_lemma_41032 (h0 : topological_space (with_bot string_imp)) : t0_space (with_bot string_imp) := sorry --non-trivial
lemma new_lemma_41033 (h0 : topological_space (comm_group (add_cancel_monoid name))) : normal_space (comm_group (add_cancel_monoid name)) := sorry --non-trivial
lemma new_lemma_41034 (h0 : functor.add_const (topological_space (is_R_or_C unsigned)) unsigned) : @t0_space.{0} (is_R_or_C.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (is_R_or_C.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_41035 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (add_cancel_comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_41036 (h0 : not (topological_space (semiring fun_info) -> false)) : @totally_disconnected_space.{0} (semiring.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (semiring.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_41037 (h0 : add_group (plift (semigroup empty))) : is_add_cyclic (plift (semigroup empty)) := sorry --non-trivial
lemma new_lemma_41038 (h0 : group (complete_semilattice_Sup (has_inv linarith.ineq))) : group.fg (complete_semilattice_Sup (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_41039 (h0 : functor.add_const (function.extfun (Type 1) uniform_space) (has_neg Type)) : @separated_space.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) uniform_space.{1}) (has_neg.{1} Type) h0) (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_41040 (h0 : functor.add_const (topological_space (boolean_algebra environment.implicit_infer_kind)) Type) : @loc_path_connected_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_41041 (h0 : cancel_comm_monoid_with_zero (has_bot unsigned)) : unique_factorization_monoid (has_bot unsigned) := sorry --non-trivial
lemma new_lemma_41042 (h0 : topological_space (has_one (semiring (semiring (has_norm (semiring (semiring linarith.comp))))))) : irreducible_space (has_one (semiring (semiring (has_norm (semiring (semiring linarith.comp)))))) := sorry --non-trivial
lemma new_lemma_41043 (h1 : topological_space (has_lt char)) (h2 : preorder (has_lt char)) : order_topology (has_lt char) := sorry --non-trivial
lemma new_lemma_41044 (h0 : function.extfun nat fin) : @is_compactly_generated.{0} (has_Inf.{0} real) (@matrix.vec_empty.{0} (complete_lattice.{0} (has_Inf.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_41045 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (encodable.{0} (has_nnnorm.{0} fun_info)) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (encodable.{0} (has_nnnorm.{0} fun_info)))  := sorry --non-trivial
lemma new_lemma_41046 (h1 : not (topological_space (with_one num) -> false)) : @totally_disconnected_space.{0} (with_one.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (with_one.{0} num)) h1)  := sorry --non-trivial
lemma new_lemma_41047 (h0 : fin has_zero.zero) : @preirreducible_space.{1} (sub_neg_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@matrix.vec_empty.{2} (function.extfun.{3 2} (Type 1) topological_space.{1}) h0) (sub_neg_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_41048 (h0 : finset (has_bot (has_neg real))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_41049 (h0 : ring (comm_group (has_nndist (add_comm_monoid (add_comm_monoid Type))))) : is_domain (comm_group (has_nndist (add_comm_monoid (add_comm_monoid Type)))) := sorry --non-trivial
lemma new_lemma_41050 (h0 : functor.add_const (ring (has_zero pos)) linarith.comp) : @is_domain.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_zero.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_41051 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_41052 (h0 : functor.add_const (monoid (bin_tree empty)) empty) : @monoid.fg.{0} (bin_tree.{0} empty) (@functor.add_const.run.{0 0} (monoid.{0} (bin_tree.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_41053 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (linear_ordered_semiring.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (linear_ordered_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_41054 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_41055 (h0 : function.extfun Type topological_space) : @t0_space.{0} (measurable_space.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measurable_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_41056 (h0 : functor.add_const (function.extfun (Type 1) (functor.add_const Prop)) environment.implicit_infer_kind) : functor.add_const.run (function.extfun_app (functor.add_const.run h0) Type) := sorry --non-trivial
lemma new_lemma_41057 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @regular_space.{0} (has_pos_part.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_pos_part.{0} real))  := sorry --non-trivial
lemma new_lemma_41058 (h0 : functor.add_const (ordered_comm_monoid (add_cancel_monoid Type)) name) : @has_exists_mul_of_le.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (ordered_comm_monoid.{1} (add_cancel_monoid.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_41059 (h1 : add_group (with_one (random_gen linarith.comp_source))) : is_add_cyclic (with_one (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_41060 (h0 : ring (semi_normed_ring char)) : strong_rank_condition (semi_normed_ring char) := sorry --non-trivial
lemma new_lemma_41061 (h0 : functor.add_const (ring (boolean_algebra.core environment.implicit_infer_kind)) environment.implicit_infer_kind) : @is_domain.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_41062 (h0 : ordered_comm_monoid (has_neg (has_add name))) : has_exists_mul_of_le (has_neg (has_add name)) := sorry --non-trivial
lemma new_lemma_41063 (h0 : ring (mul_one_class (has_repr ereal))) : strong_rank_condition (mul_one_class (has_repr ereal)) := sorry --non-trivial
lemma new_lemma_41064 (h0 : fin has_zero.zero) : @t0_space.{0} (comm_semigroup.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (comm_semigroup.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_41065 (h0 : not (ring (has_append (has_nnnorm fun_info)) -> false)) : @strong_rank_condition.{0} (has_append.{0} (has_nnnorm.{0} fun_info)) (@classical.by_contradiction'.{1} (ring.{0} (has_append.{0} (has_nnnorm.{0} fun_info))) h0)  := sorry --non-trivial
lemma new_lemma_41066 (h0 : topological_space (monoid_with_zero pos)) : discrete_topology (monoid_with_zero pos) := sorry --non-trivial
lemma new_lemma_41067 (h0 : functor.add_const (ring (comm_group Type)) environment.implicit_infer_kind) : @is_domain.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (comm_group.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_41068 (h0 : functor.add_const (topological_space (boolean_algebra.core environment.implicit_infer_kind)) name) : @t0_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_41069 (h0 : functor.add_const (cancel_comm_monoid_with_zero (complete_distrib_lattice Type)) (finset Type)) : @unique_factorization_monoid.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 1} (cancel_comm_monoid_with_zero.{1} (complete_distrib_lattice.{1} Type)) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_41070 (h0 : topological_space (topological_space (with_zero linarith.ineq))) : totally_disconnected_space (topological_space (with_zero linarith.ineq)) := sorry --non-trivial
lemma new_lemma_41071 (h0 : topological_space (add_group empty)) : totally_disconnected_space (add_group empty) := sorry --non-trivial
lemma new_lemma_41072 (h0 : complete_lattice (has_one (semiring num))) : is_compactly_generated (has_one (semiring num)) := sorry --non-trivial
lemma new_lemma_41073 (h0 : group (has_top (random_gen (has_inv (has_top linarith.comp_source))))) : normalizer_condition (has_top (random_gen (has_inv (has_top linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_41074 (h0 : function.extfun Type (functor.add_const (topological_space environment.implicit_infer_kind))) : @totally_separated_space.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 0} (topological_space.{0} environment.implicit_infer_kind) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} environment.implicit_infer_kind)) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_41075 (h0 : function.extfun Type group) : @normalizer_condition.{0} (cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_41076 (h0 : topological_space (linear_ordered_semiring congr_arg_kind)) : path_connected_space (linear_ordered_semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_41077 (h0 : topological_space (generalized_boolean_algebra (has_pos_part pos))) : loc_path_connected_space (generalized_boolean_algebra (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_41078 (h0 : complete_lattice (has_nndist (has_add pos))) : is_atomistic (has_nndist (has_add pos)) := sorry --non-trivial
lemma new_lemma_41079 (h0 : function.extfun Type topological_space) : @regular_space.{0} (has_Inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_Inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_41080 (h0 : has_mem.mem (has_norm fun_info) has_emptyc.emptyc) : countable_Inter_filter (finset.pi.empty filter (has_norm fun_info) h0) := sorry --non-trivial
lemma new_lemma_41081 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @irreducible_space.{0} (random_gen.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (random_gen.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_41082 (h0 : topological_space ereal) : nonempty (t1_space ereal) := sorry --non-trivial
lemma new_lemma_41083 (h0 : topological_space (add_group (semiring num))) : topological_space.separable_space (add_group (semiring num)) := sorry --non-trivial
lemma new_lemma_41084 (h0 : topological_space (comm_group (option unsigned))) : t0_space (comm_group (option unsigned)) := sorry --non-trivial
lemma new_lemma_41085 (h0 : add_monoid (generalized_boolean_algebra real)) : add_monoid.fg (generalized_boolean_algebra real) := sorry --non-trivial
lemma new_lemma_41086 (h0 : topological_space (ordered_cancel_add_comm_monoid congr_arg_kind)) : totally_separated_space (ordered_cancel_add_comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_41087 (h0 : has_lt (has_repr std_gen)) : no_max_order (has_repr std_gen) := sorry --non-trivial
lemma new_lemma_41088 (h0 : complete_lattice (linear_ordered_semiring (semiring (semiring num)))) : complete_lattice.is_Sup_finite_compact (linear_ordered_semiring (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_41089 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @t1_space.{0} (has_zero.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (has_zero.{0} name))  := sorry --non-trivial
lemma new_lemma_41090 (h0 : group (measurable_space (random_gen num))) : normalizer_condition (measurable_space (random_gen num)) := sorry --non-trivial
lemma new_lemma_41091 (h0 : topological_space (add_cancel_monoid (has_add name))) : t1_space (add_cancel_monoid (has_add name)) := sorry --non-trivial
lemma new_lemma_41092 (h0 : functor.add_const (group (has_zero Type)) linarith.comp) : @is_cyclic.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (has_zero.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_41093 (h0 : list (canonically_ordered_monoid (has_neg pos))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_41094 (h0 : ring (normed_field (has_nnnorm (comm_ring to_additive.value_type)))) : is_domain (normed_field (has_nnnorm (comm_ring to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_41095 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (pseudo_metric_space.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (pseudo_metric_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_41096 (h0 : topological_space subsingleton_info) : t1_space subsingleton_info := sorry --non-trivial
lemma new_lemma_41097 (h0 : group (has_to_string (has_pos_part (finset (finset pos))))) : is_cyclic (has_to_string (has_pos_part (finset (finset pos)))) := sorry --non-trivial
lemma new_lemma_41098 (h0 : filter (canonically_linear_ordered_monoid pos)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_41099 (h0 : uniform_space (with_bot (has_inv (has_inv (has_inv (has_inv linarith.ineq)))))) : complete_space (with_bot (has_inv (has_inv (has_inv (has_inv linarith.ineq))))) := sorry --non-trivial
lemma new_lemma_41100 (h0 : topological_space (has_norm (random_gen (has_top linarith.ineq)))) : irreducible_space (has_norm (random_gen (has_top linarith.ineq))) := sorry --non-trivial
lemma new_lemma_41101 (h0 : ordered_add_comm_monoid (boolean_algebra (mul_one_class (ring (has_add Type))))) : archimedean (boolean_algebra (mul_one_class (ring (has_add Type)))) := sorry --non-trivial
lemma new_lemma_41102 (h2 : ring (has_ssubset char)) : strong_rank_condition (has_ssubset char) := sorry --non-trivial
lemma new_lemma_41103 (h1 : not (complete_lattice (distrib string_imp) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (distrib.{0} string_imp) (@classical.by_contradiction'.{1} (complete_lattice.{0} (distrib.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_41104 (h0 : ordered_comm_monoid (has_Inf (has_bot name))) : has_exists_mul_of_le (has_Inf (has_bot name)) := sorry --non-trivial
lemma new_lemma_41105 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (metric_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (metric_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_41106 (h0 : complete_lattice (complete_linear_order empty)) : is_atomistic (complete_linear_order empty) := sorry --non-trivial
lemma new_lemma_41107 (h0 : semiring (has_zero (ring pos))) : is_noetherian_ring (has_zero (ring pos)) := sorry --non-trivial
lemma new_lemma_41108 (h0 : functor.add_const (topological_space (has_add Type)) environment.implicit_infer_kind) : @topological_space.separable_space.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_add.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_41109 (h0 : functor.add_const (list (has_nndist unsigned)) pos) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_41110 (h0 : function.extfun Type group) : @group.fg.{0} (non_assoc_semiring.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (non_assoc_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_41111 (h1 : ring (normed_field (semi_normed_ring reducibility_hints))) : is_domain (normed_field (semi_normed_ring reducibility_hints)) := sorry --non-trivial
lemma new_lemma_41112 (h0 : topological_space (semigroup (has_pos_part linarith.comp))) : loc_path_connected_space (semigroup (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_41113 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (normed_group.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (normed_group.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_41114 (h0 : ring (linear_ordered_add_comm_group (random_gen (random_gen (denumerable string_imp))))) : is_domain (linear_ordered_add_comm_group (random_gen (random_gen (denumerable string_imp)))) := sorry --non-trivial
lemma new_lemma_41115 (h0 : functor.add_const (topological_space (has_to_string Type)) linarith.comp) : @totally_separated_space.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_to_string.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_41116 (h0 : uniform_space (measurable_space to_additive.value_type)) : separated_space (measurable_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_41117 (h0 : ring (has_inv (random_gen fun_info))) : rank_condition (has_inv (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_41118 (h0 : ring (metric_space (semiring empty))) : rank_condition (metric_space (semiring empty)) := sorry --non-trivial
lemma new_lemma_41119 (h0 : functor.add_const Prop (linear_ordered_field (option pos))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_41120 (h0 : functor.add_const (functor.add_const (ring name) empty) congr_arg_kind) : @is_domain.{0} name (@functor.add_const.run.{0 0} (ring.{0} name) empty (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (ring.{0} name) empty) congr_arg_kind h0))  := sorry --non-trivial
lemma new_lemma_41121 (h0 : not (group (random_gen (mul_one_class (mul_one_class (has_compl fun_info)))) -> false)) : @is_cyclic.{0} (random_gen.{0} (mul_one_class.{0} (mul_one_class.{0} (has_compl.{0} fun_info)))) (@classical.by_contradiction'.{1} (group.{0} (random_gen.{0} (mul_one_class.{0} (mul_one_class.{0} (has_compl.{0} fun_info))))) h0)  := sorry --non-trivial
lemma new_lemma_41122 (h0 : monoid (has_norm (random_gen linarith.ineq))) : monoid.fg (has_norm (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_41123 (h0 : ring (monoid congr_arg_kind)) : rank_condition (monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_41124 (h0 : fin has_zero.zero) : @discrete_topology.{0} (canonically_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (canonically_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_41125 (h0 : not (topological_space (has_union empty) -> false)) : @irreducible_space.{0} (has_union.{0} empty) (@id.{1} (topological_space.{0} (has_union.{0} empty)) (@classical.by_contradiction'.{1} (topological_space.{0} (has_union.{0} empty)) h0))  := sorry --non-trivial
lemma new_lemma_41126 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (linear_ordered_cancel_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_cancel_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_41127 (h0 : not (function.extfun Type group -> false)) : @normalizer_condition.{0} (measurable_space.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (measurable_space.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_41128 (h0 : functor.add_const (function.extfun Type uniform_space) pos) : @complete_space.{0} (has_bot.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) pos h0) (has_bot.{0} pos))  := sorry --non-trivial
lemma new_lemma_41129 (h0 : uniform_space (canonically_ordered_monoid name)) : complete_space (canonically_ordered_monoid name) := sorry --non-trivial
lemma new_lemma_41130 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (with_bot.{0} empty) (@function.extfun_app.{2 1} Type semiring.{0} h0 (with_bot.{0} empty))  := sorry --non-trivial
lemma new_lemma_41131 (h0 : topological_space (semiring (random_gen (has_top fun_info)))) : totally_separated_space (semiring (random_gen (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_41132 (h0 : topological_space (dlist (comm_ring linarith.ineq))) : irreducible_space (dlist (comm_ring linarith.ineq)) := sorry --non-trivial
lemma new_lemma_41133 (h0 : topological_space (partial_order (add_comm_monoid (semiring unsigned)))) : t0_space (partial_order (add_comm_monoid (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_41134 (h0 : topological_space (cancel_monoid (ring environment.implicit_infer_kind))) : normal_space (cancel_monoid (ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_41135 (h0 : topological_space (ring (boolean_algebra name))) : locally_compact_space (ring (boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_41136 (h0 : has_norm linarith.comp_source -> has_top fun_info -> Prop) : relator.bi_total h0 := sorry --non-trivial
lemma new_lemma_41137 (h0 : ring (distrib_lattice to_additive.value_type)) : is_domain (distrib_lattice to_additive.value_type) := sorry --non-trivial
lemma new_lemma_41138 (h0 : group (mul_zero_class (finset environment.implicit_infer_kind))) : group.fg (mul_zero_class (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_41139 (h0 : topological_space (has_zero (option (option pos)))) : preirreducible_space (has_zero (option (option pos))) := sorry --non-trivial
lemma new_lemma_41140 (h0 : ring (topological_space (comm_ring to_additive.value_type))) : rank_condition (topological_space (comm_ring to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_41141 (h0 : complete_lattice (semiring fun_info)) : is_compactly_generated (semiring fun_info) := sorry --non-trivial
lemma new_lemma_41142 (h0 : list (finset (option pos))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_41143 (h0 : set (linear_ordered_comm_group_with_zero string.iterator_imp)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_41144 (h0 : functor.add_const (topological_space (boolean_algebra.core environment.implicit_infer_kind)) name) : @normal_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_41145 (h0 : complete_lattice (has_div (mul_one_class (has_compl (has_nnnorm string.iterator_imp))))) : is_compactly_generated (has_div (mul_one_class (has_compl (has_nnnorm string.iterator_imp)))) := sorry --non-trivial
lemma new_lemma_41146 (h0 : topological_space (has_neg (finset pos))) : t0_space (has_neg (finset pos)) := sorry --non-trivial
lemma new_lemma_41147 (h2 : uniform_space (semi_normed_comm_ring std_gen)) : complete_space (semi_normed_comm_ring std_gen) := sorry --non-trivial
lemma new_lemma_41148 (h0 : complete_lattice (add_cancel_monoid (has_to_string environment.implicit_infer_kind))) : is_atomistic (add_cancel_monoid (has_to_string environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_41149 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (denumerable.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (denumerable.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_41150 (h0 : topological_space (fintype (denumerable linarith.comp_source))) : t0_space (fintype (denumerable linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_41151 (h0 : complete_lattice (id (with_bot (with_bot (with_bot string_imp))))) : is_compactly_generated (id (with_bot (with_bot (with_bot string_imp)))) := sorry --non-trivial
lemma new_lemma_41152 (h0 : topological_space (has_add (ring linarith.comp))) : discrete_topology (has_add (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_41153 (h0 : not (ring (semi_normed_comm_ring linarith.comp_source) -> false)) : @is_domain.{0} (semi_normed_comm_ring.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (semi_normed_comm_ring.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_41154 (h0 : filter (monoid_with_zero (option unsigned))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_41155 (h0 : functor.add_const (function.extfun (Type 1) ordered_comm_monoid) pos) : @has_exists_mul_of_le.{1} Type (@function.extfun_app.{3 2} (Type 1) ordered_comm_monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ordered_comm_monoid.{1}) pos h0) Type)  := sorry --non-trivial
lemma new_lemma_41156 (h0 : complete_lattice (complete_distrib_lattice (option empty))) : is_compactly_generated (complete_distrib_lattice (option empty)) := sorry --non-trivial
lemma new_lemma_41157 (h0 : finset (ring (option ennreal))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_41158 (h1 : not (topological_space (has_union linarith.comp) -> false)) : @irreducible_space.{0} (has_union.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (has_union.{0} linarith.comp)) h1)  := sorry --non-trivial
lemma new_lemma_41159 (h0 : functor.add_const (uniform_space (finset name)) pos) : @separated_space.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (finset.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_41160 (h0 : has_zero (with_bot (random_gen num))) (h1 : not (function.extfun Type with_bot -> false)) : ne_zero (function.extfun_app (classical.by_contradiction' h1) (random_gen num)) := sorry --non-trivial
lemma new_lemma_41161 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (has_to_string.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_to_string.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_41162 (h0 : topological_space (comm_group (has_neg_part (cancel_monoid (has_nndist (semigroup Type)))))) : sequential_space (comm_group (has_neg_part (cancel_monoid (has_nndist (semigroup Type))))) := sorry --non-trivial
lemma new_lemma_41163 (h0 : ulower pnat) (h1 : pnat) : pnat.coprime (ulower.up h0) h1 := sorry --non-trivial
lemma new_lemma_41164 (h0 : has_mem.mem (with_one linarith.comp_source) has_emptyc.emptyc) : @totally_disconnected_space.{0} (with_one.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_one.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_41165 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (add_comm_monoid num)) := sorry --non-trivial
lemma new_lemma_41166 (h0 : functor.add_const (group (add_cancel_monoid pos)) pos) : @is_cyclic.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (add_cancel_monoid.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_41167 (h0 : measurable_space ereal) (h1 : measure_theory.measure ereal) : measure_theory.is_finite_measure h1 := sorry --non-trivial
lemma new_lemma_41168 (h1 : group (div_inv_monoid to_additive.value_type)) : is_cyclic (div_inv_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_41169 (h1 : ordered_cancel_comm_monoid std_gen) (h2 : function.surjective (fun (h0 : topological_space reducibility_hints), h1)) (h3 : ordered_cancel_comm_monoid std_gen) : @path_connected_space.{0} reducibility_hints (@function.surj_inv.{1 1} (topological_space.{0} reducibility_hints) (ordered_cancel_comm_monoid.{0} std_gen) (λ (h0 : topological_space.{0} reducibility_hints), h1) h2 h3)  := sorry --non-trivial
lemma new_lemma_41170 (h0 : monoid (boolean_algebra.core environment.implicit_infer_kind)) : monoid.fg (boolean_algebra.core environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_41171 (h0 : topological_space (has_bot (has_Inf linarith.comp))) : t1_space (has_bot (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_41172 (h0 : functor.add_const (function.extfun (Type 1) group) Type) : @is_cyclic.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) group.{1}) Type h0) (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_41173 (h0 : semiring (canonically_ordered_comm_semiring empty)) : is_noetherian_ring (canonically_ordered_comm_semiring empty) := sorry --non-trivial
lemma new_lemma_41174 (h0 : functor.add_const (topological_space (has_nndist pos)) Type) : @t1_space.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_nndist.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_41175 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (dlist.{0} (has_nnnorm.{0} fun_info)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (dlist.{0} (has_nnnorm.{0} fun_info)))  := sorry --non-trivial
lemma new_lemma_41176 (h0 : functor.add_const (list (add_cancel_monoid empty)) empty) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_41177 (h0 : topological_space (boolean_algebra (has_Inf (boolean_algebra (has_neg linarith.comp))))) : path_connected_space (boolean_algebra (has_Inf (boolean_algebra (has_neg linarith.comp)))) := sorry --non-trivial
lemma new_lemma_41178 (h0 : topological_space (has_neg_part (has_nndist environment.implicit_infer_kind))) : t1_space (has_neg_part (has_nndist environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_41179 (h0 : topological_space (has_add (complete_distrib_lattice name))) : sequential_space (has_add (complete_distrib_lattice name)) := sorry --non-trivial
lemma new_lemma_41180 (h0 : topological_space (canonically_ordered_monoid (has_neg real))) : normal_space (canonically_ordered_monoid (has_neg real)) := sorry --non-trivial
lemma new_lemma_41181 (h0 : functor.add_const (ordered_comm_monoid (normed_comm_ring Type)) (has_to_string name)) : @has_exists_mul_of_le.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (ordered_comm_monoid.{1} (normed_comm_ring.{1} Type)) (has_to_string.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_41182 (h0 : has_neg (mul_one_class enat)) (h1 : measurable_space (mul_one_class enat)) : has_measurable_neg (mul_one_class enat) := sorry --non-trivial
lemma new_lemma_41183 (h0 : topological_space (with_bot empty)) : totally_disconnected_space (with_bot empty) := sorry --non-trivial
lemma new_lemma_41184 (h0 : topological_space (metric_space (random_gen char))) : path_connected_space (metric_space (random_gen char)) := sorry --non-trivial
lemma new_lemma_41185 (h0 : ring (has_nndist (has_neg_part Type))) : rank_condition (has_nndist (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_41186 (h0 : ring (canonically_ordered_comm_semiring (option (option ennreal)))) : rank_condition (canonically_ordered_comm_semiring (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_41187 (h0 : uniform_space (has_nnnorm (denumerable (denumerable char)))) : complete_space (has_nnnorm (denumerable (denumerable char))) := sorry --non-trivial
lemma new_lemma_41188 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (has_one.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (has_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_41189 (h0 : functor.add_const (topological_space (complete_distrib_lattice real)) Type) : @totally_disconnected_space.{0} (complete_distrib_lattice.{0} real) (@functor.add_const.run.{0 1} (topological_space.{0} (complete_distrib_lattice.{0} real)) Type h0)  := sorry --non-trivial
lemma new_lemma_41190 (h0 : topological_space (boolean_algebra (has_bot (sub_neg_monoid pos)))) : totally_separated_space (boolean_algebra (has_bot (sub_neg_monoid pos))) := sorry --non-trivial
lemma new_lemma_41191 (h0 : semiring (complete_semilattice_Sup linarith.comp)) : is_noetherian_ring (complete_semilattice_Sup linarith.comp) := sorry --non-trivial
lemma new_lemma_41192 (h0 : add_group (linear_ordered_field (option pos))) : is_add_cyclic (linear_ordered_field (option pos)) := sorry --non-trivial
lemma new_lemma_41193 (h0 : functor.add_const (function.extfun Type uniform_space) pos) : @complete_space.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) pos h0) (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_41194 (h0 : functor.add_const (ring (comm_group environment.implicit_infer_kind)) (normed_comm_ring pos)) : @is_principal_ideal_ring.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (comm_group.{0} environment.implicit_infer_kind)) (normed_comm_ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_41195 (h0 : functor.add_const (topological_space (monoid congr_arg_kind)) congr_arg_kind) : @irreducible_space.{0} (monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (monoid.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_41196 (h0 : ring (comm_semigroup pos)) : strong_rank_condition (comm_semigroup pos) := sorry --non-trivial
lemma new_lemma_41197 (h0 : function.extfun Type topological_space) : @t1_space.{0} (normed_comm_ring.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_41198 (h0 : Prop -> add_comm_semigroup char) (h1 : coe_sort (set.range h0)) : set.range_splitting h0 h1 := sorry --non-trivial
lemma new_lemma_41199 (h0 : ring (has_Inf (has_Inf (has_Inf Type)))) : is_domain (has_Inf (has_Inf (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_41200 (h0 : complete_lattice (with_one empty)) : is_atomistic (with_one empty) := sorry --non-trivial
lemma new_lemma_41201 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @locally_compact_space.{0} (measurable_space.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (measurable_space.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_41202 (h0 : functor.add_const (function.extfun Type ring) (has_neg linarith.comp)) : @is_domain.{0} (has_zero.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) (has_neg.{0} linarith.comp) h0) (has_zero.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_41203 (h0 : functor.add_const (ring (canonically_ordered_comm_semiring name)) environment.implicit_infer_kind) : @rank_condition.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (canonically_ordered_comm_semiring.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_41204 (h0 : functor.add_const (add_monoid (semigroup name)) (finset name)) : @add_monoid.fg.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (add_monoid.{0} (semigroup.{0} name)) (finset.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_41205 (h0 : functor.comp (functor.comp topological_space has_zero) with_top nnreal) : @topological_space.separable_space.{0} (has_zero.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} has_zero.{0} ennreal (@functor.comp.run.{0 0 0} (functor.comp.{0 0 0} topological_space.{0} has_zero.{0}) with_top.{0} nnreal h0))  := sorry --non-trivial
lemma new_lemma_41206 (h0 : functor.add_const (group (boolean_algebra.core environment.implicit_infer_kind)) environment.implicit_infer_kind) : @is_cyclic.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_41207 (h0 : filter (normed_comm_ring (option empty))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_41208 (h0 : has_mem.mem (complete_semilattice_Sup linarith.comp_source) has_emptyc.emptyc) : @is_atomistic.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (complete_semilattice_Sup.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_41209 (h0 : ring (measurable_space (random_gen to_additive.value_type))) : rank_condition (measurable_space (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_41210 (h0 : list (id (random_gen (random_gen (has_top linarith.comp_source))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_41211 (h0 : finset (normed_comm_ring (normed_comm_ring (finset pos)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_41212 (h0 h4 : multiset ereal) : multiset.le h0 h4 := sorry --non-trivial
lemma new_lemma_41213 (h1 : ring (comm_ring (has_append (random_gen string_imp)))) : is_domain (comm_ring (has_append (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_41214 (h0 : functor.comp ring boolean_algebra.core Type) : @rank_condition.{1} (boolean_algebra.core.{1} Type) (@functor.comp.run.{1 1 1} ring.{1} boolean_algebra.core.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_41215 (h0 : complete_lattice (has_top (has_norm (has_norm (has_norm linarith.comp))))) : is_compactly_generated (has_top (has_norm (has_norm (has_norm linarith.comp)))) := sorry --non-trivial
lemma new_lemma_41216 (h0 : complete_lattice (partial_order (semiring (semiring unsigned)))) : is_atomistic (partial_order (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_41217 (h0 : topological_space (has_inv (random_gen (random_gen string_imp)))) : path_connected_space (has_inv (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_41218 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (non_assoc_semiring.{0} empty) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (non_assoc_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_41219 (h0 : ordered_add_comm_monoid (has_neg (has_neg Type))) : archimedean (has_neg (has_neg Type)) := sorry --non-trivial
lemma new_lemma_41220 (h0 : functor.add_const (function.extfun Type complete_lattice) environment.implicit_infer_kind) : @is_atomistic.{0} (has_zero.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) environment.implicit_infer_kind h0) (has_zero.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_41221 (h0 : functor.add_const (add_monoid (cancel_monoid name)) linarith.comp) : @add_monoid.fg.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (add_monoid.{0} (cancel_monoid.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_41222 (h1 : uniform_space (with_zero to_additive.value_type)) : complete_space (with_zero to_additive.value_type) := sorry --non-trivial
lemma new_lemma_41223 (h0 : add_monoid (add_group (has_union linarith.comp))) : add_monoid.fg (add_group (has_union linarith.comp)) := sorry --non-trivial
lemma new_lemma_41224 (h0 : ring (has_top (random_gen (has_emptyc to_additive.value_type)))) : strong_rank_condition (has_top (random_gen (has_emptyc to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_41225 (h0 : topological_space (with_one string_imp)) : totally_disconnected_space (with_one string_imp) := sorry --non-trivial
lemma new_lemma_41226 (h0 : ring (denumerable (comm_ring linarith.comp_source))) : rank_condition (denumerable (comm_ring linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_41227 (h1 : topological_space (topological_space fun_info)) : t0_space (topological_space fun_info) := sorry --non-trivial
lemma new_lemma_41228 (h0 : ordered_comm_monoid (has_to_string (option (option (option (option pos)))))) : has_exists_mul_of_le (has_to_string (option (option (option (option pos))))) := sorry --non-trivial
lemma new_lemma_41229 (h0 : list (ordered_ring (semiring empty))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_41230 (h0 : topological_space (ordered_cancel_add_comm_monoid (option (option empty)))) : totally_separated_space (ordered_cancel_add_comm_monoid (option (option empty))) := sorry --non-trivial
lemma new_lemma_41231 (h2 : set (simple_graph reducibility_hints)) : set.finite h2 := sorry --non-trivial
lemma new_lemma_41232 (h0 : filter (has_to_string pos)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_41233 (h0 : ring (linear_ordered_add_comm_group (complete_semilattice_Inf to_additive.value_type))) : rank_condition (linear_ordered_add_comm_group (complete_semilattice_Inf to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_41234 (h0 : add_group (random_gen (has_top linarith.comp_source))) : is_add_cyclic (random_gen (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_41235 (h0 : functor.add_const (finset (preorder empty)) congr_arg_kind) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_41236 (h0 : group (has_add (finset (finset (finset (finset (finset (finset linarith.comp)))))))) : group.fg (has_add (finset (finset (finset (finset (finset (finset linarith.comp))))))) := sorry --non-trivial
lemma new_lemma_41237 (h0 : group (linear_ordered_add_comm_group (random_gen linarith.ineq))) : normalizer_condition (linear_ordered_add_comm_group (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_41238 (h2 : uniform_space (topological_space (has_nnnorm to_additive.value_type))) : complete_space (topological_space (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_41239 (h0 : functor.add_const (topological_space (pseudo_metric_space pos)) pos) : @t0_space.{0} (pseudo_metric_space.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (pseudo_metric_space.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_41240 (h0 : topological_space (denumerable linarith.comp_source)) : totally_separated_space (denumerable linarith.comp_source) := sorry --non-trivial
lemma new_lemma_41241 (h0 : ring (has_nndist (has_neg name))) : rank_condition (has_nndist (has_neg name)) := sorry --non-trivial
lemma new_lemma_41242 (h0 : add_monoid (boolean_algebra (comm_group Type))) : add_monoid.fg (boolean_algebra (comm_group Type)) := sorry --non-trivial
lemma new_lemma_41243 (h1 : has_lt (normed_field (normed_field char))) : no_max_order (normed_field (normed_field char)) := sorry --non-trivial
lemma new_lemma_41244 (h0 : has_mem.mem add_group has_emptyc.emptyc) : @is_add_cyclic.{0} (random_gen.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type add_group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) add_group.{0} h0) (random_gen.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_41245 (h0 : ring (has_to_string (complete_distrib_lattice (has_to_string name)))) : is_principal_ideal_ring (has_to_string (complete_distrib_lattice (has_to_string name))) := sorry --non-trivial
lemma new_lemma_41246 (h0 : functor.add_const (topological_space (has_Inf environment.implicit_infer_kind)) Type) : @sequential_space.{0} (has_Inf.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (has_Inf.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_41247 (h0 : topological_space (add_cancel_comm_monoid unsigned)) : t1_space (add_cancel_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_41248 (h0 : group (linear_ordered_comm_group empty)) : group.fg (linear_ordered_comm_group empty) := sorry --non-trivial
lemma new_lemma_41249 (h0 : function.extfun nat fin) : @discrete_topology.{0} (add_comm_monoid.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (add_comm_monoid.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_41250 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (canonically_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (canonically_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_41251 (h0 : ring (left_cancel_semigroup (ordered_cancel_comm_monoid num))) : strong_rank_condition (left_cancel_semigroup (ordered_cancel_comm_monoid num)) := sorry --non-trivial
lemma new_lemma_41252 (h0 : not (topological_space (non_assoc_semiring congr_arg_kind) -> false)) : @irreducible_space.{0} (non_assoc_semiring.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (non_assoc_semiring.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_41253 (h1 : (char -> char) -> Prop) (h2 : unit) : set.separates_points (matrix.row h1 h2) := sorry --non-trivial
lemma new_lemma_41254 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (semigroup ennreal)) := sorry --non-trivial
lemma new_lemma_41255 (h0 : topological_space (canonically_ordered_comm_semiring (has_add linarith.comp))) : t1_space (canonically_ordered_comm_semiring (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_41256 (h0 : filter (add_cancel_monoid (comm_group (comm_group (comm_group name))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_41257 (h0 : ring (add_comm_semigroup (has_ssubset (has_neg (with_zero string.iterator_imp))))) : strong_rank_condition (add_comm_semigroup (has_ssubset (has_neg (with_zero string.iterator_imp)))) := sorry --non-trivial
lemma new_lemma_41258 (h0 : topological_space (has_emptyc congr_arg_kind)) : locally_compact_space (has_emptyc congr_arg_kind) := sorry --non-trivial
lemma new_lemma_41259 (h0 : uniform_space (cancel_monoid (cancel_monoid (has_to_string (has_to_string (has_to_string num)))))) : separated_space (cancel_monoid (cancel_monoid (has_to_string (has_to_string (has_to_string num))))) := sorry --non-trivial
lemma new_lemma_41260 (h0 : topological_space (boolean_algebra (boolean_algebra.core name))) : regular_space (boolean_algebra (boolean_algebra.core name)) := sorry --non-trivial
lemma new_lemma_41261 (h0 : complete_lattice (random_gen (random_gen (random_gen to_additive.value_type)))) : complete_lattice.is_Sup_finite_compact (random_gen (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_41262 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (add_cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (add_cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_41263 (h0 : topological_space (comm_ring (random_gen (random_gen reducibility_hints)))) : t0_space (comm_ring (random_gen (random_gen reducibility_hints))) := sorry --non-trivial
lemma new_lemma_41264 (h0 : topological_space (canonically_ordered_comm_semiring (option unsigned))) : loc_path_connected_space (canonically_ordered_comm_semiring (option unsigned)) := sorry --non-trivial
lemma new_lemma_41265 (h0 : nat) (h1 : fin (nat.succ h0) -> fin has_zero.zero) (h2 : fin h0) : matrix.vec_empty (matrix.vec_empty (matrix.vec_empty (id (matrix.vec_tail h1 h2)))) := sorry --non-trivial
lemma new_lemma_41266 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (ordered_comm_group.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_group.{0} num))  := sorry --non-trivial
lemma new_lemma_41267 (h0 : topological_space (canonically_linear_ordered_monoid (has_Inf (has_Inf Type)))) : locally_compact_space (canonically_linear_ordered_monoid (has_Inf (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_41268 (h0 : functor.add_const (filter (normed_comm_ring pos)) pos) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_41269 (h0 : measurable_space (canonically_ordered_comm_semiring (has_neg name))) (h1 : has_add (canonically_ordered_comm_semiring (has_neg name))) : has_measurable_add (canonically_ordered_comm_semiring (has_neg name)) := sorry --non-trivial
lemma new_lemma_41270 (h0 : functor.add_const (uniform_space (ring linarith.comp)) (has_neg_part environment.implicit_infer_kind)) : @complete_space.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (ring.{0} linarith.comp)) (has_neg_part.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_41271 (h0 : group (boolean_algebra real)) : group.fg (boolean_algebra real) := sorry --non-trivial
lemma new_lemma_41272 (h0 : complete_lattice (right_cancel_semigroup unsigned)) : is_atomistic (right_cancel_semigroup unsigned) := sorry --non-trivial
lemma new_lemma_41273 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (linear_ordered_comm_group.{0} pos) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (linear_ordered_comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_41274 (h0 : ordered_comm_monoid (has_pos_part (has_to_string pos))) : has_exists_mul_of_le (has_pos_part (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_41275 (h0 : topological_space (complete_semilattice_Sup num)) : normal_space (complete_semilattice_Sup num) := sorry --non-trivial
lemma new_lemma_41276 (h0 : filter (measure_theory.measure_space (semiring num))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_41277 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (bin_tree.{0} num) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (bin_tree.{0} num))  := sorry --non-trivial
lemma new_lemma_41278 (h0 : group (boolean_algebra.core environment.implicit_infer_kind)) : group.fg (boolean_algebra.core environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_41279 (h0 : ring (has_append (has_ssubset (has_ssubset (has_ssubset (has_ssubset linarith.comp_source)))))) : is_domain (has_append (has_ssubset (has_ssubset (has_ssubset (has_ssubset linarith.comp_source))))) := sorry --non-trivial
lemma new_lemma_41280 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (option.{0} unsigned) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (option.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_41281 (h0 : add_group (pseudo_emetric_space unsigned)) : is_add_cyclic (pseudo_emetric_space unsigned) := sorry --non-trivial
lemma new_lemma_41282 (h0 : functor.add_const (ordered_comm_monoid (ring Type)) (comm_group (comm_group pos))) : @has_exists_mul_of_le.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (ordered_comm_monoid.{1} (ring.{1} Type)) (comm_group.{0} (comm_group.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_41283 (h0 : fin has_zero.zero) : @archimedean.{0} (has_bot.{0} real) (@matrix.vec_empty.{0} (ordered_add_comm_monoid.{0} (has_bot.{0} real)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_41284 (h0 : uniform_space (canonically_ordered_monoid pos)) : separated_space (canonically_ordered_monoid pos) := sorry --non-trivial
lemma new_lemma_41285 (h2 : topological_space (nondiscrete_normed_field enat)) (h3 : add_group (nondiscrete_normed_field enat)) : topological_add_group (nondiscrete_normed_field enat) := sorry --non-trivial
lemma new_lemma_41286 (h0 : topological_space (linear_ordered_comm_monoid_with_zero (option (option unsigned)))) : preirreducible_space (linear_ordered_comm_monoid_with_zero (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_41287 (h0 : functor.add_const (add_monoid (plift num)) unsigned) : @add_monoid.fg.{1} (plift.{1} num) (@functor.add_const.run.{1 0} (add_monoid.{1} (plift.{1} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_41288 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (has_Sup.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_Sup.{0} empty))  := sorry --non-trivial
lemma new_lemma_41289 (h0 : topological_space (has_neg (has_neg (has_neg linarith.comp)))) : t1_space (has_neg (has_neg (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_41290 (h2 : topological_space (has_nnnorm to_additive.value_type)) : t0_space (has_nnnorm to_additive.value_type) := sorry --non-trivial
lemma new_lemma_41291 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (boolean_algebra.core.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_41292 (h0 : complete_lattice (with_one (has_norm linarith.comp))) : is_compactly_generated (with_one (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_41293 (h0 : functor.add_const (semiring (left_cancel_monoid congr_arg_kind)) unsigned) : @is_noetherian_ring.{0} (left_cancel_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (semiring.{0} (left_cancel_monoid.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_41294 (h0 : topological_space (left_cancel_semigroup (semiring num))) : totally_separated_space (left_cancel_semigroup (semiring num)) := sorry --non-trivial
lemma new_lemma_41295 (h0 : topological_space (random_gen (semiring (has_norm (has_norm linarith.comp))))) : normal_space (random_gen (semiring (has_norm (has_norm linarith.comp)))) := sorry --non-trivial
lemma new_lemma_41296 (h0 : topological_space (id (has_norm linarith.comp))) : path_connected_space (id (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_41297 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (ordered_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_41298 (h0 : group (has_nndist (has_to_string (comm_group (has_to_string pos))))) : normalizer_condition (has_nndist (has_to_string (comm_group (has_to_string pos)))) := sorry --non-trivial
lemma new_lemma_41299 (h0 : functor.add_const (topological_space (has_add unsigned)) Type) : @loc_path_connected_space.{0} (has_add.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (has_add.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_41300 (h0 : ring (linear_ordered_field (option (option (option (option (option empty))))))) : is_principal_ideal_ring (linear_ordered_field (option (option (option (option (option empty)))))) := sorry --non-trivial
lemma new_lemma_41301 (h0 : topological_space (denumerable (random_gen fun_info))) : locally_compact_space (denumerable (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_41302 (h3 : prod linarith.ineq linarith.ineq) : set.diagonal linarith.ineq h3 := sorry --non-trivial
lemma new_lemma_41303 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (normed_linear_ordered_group.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_linear_ordered_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_41304 (h0 : complete_lattice (semigroup (normed_comm_ring environment.implicit_infer_kind))) : is_compactly_generated (semigroup (normed_comm_ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_41305 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (boolean_algebra.core.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.core.{0} name))  := sorry --non-trivial
lemma new_lemma_41306 (h0 : topological_space (add_left_cancel_semigroup congr_arg_kind)) : irreducible_space (add_left_cancel_semigroup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_41307 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (has_zero.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_41308 (h0 : filter (has_dist (option num))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_41309 (h0 : topological_space (omega_complete_partial_order congr_arg_kind)) : totally_separated_space (omega_complete_partial_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_41310 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} environment.implicit_infer_kind (@function.extfun_app.{2 1} Type ring.{0} h0 environment.implicit_infer_kind)  := sorry --non-trivial
lemma new_lemma_41311 (h0 : functor.add_const (complete_lattice (cancel_monoid Type)) Type) : @is_atomistic.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 1} (complete_lattice.{1} (cancel_monoid.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_41312 (h0 : group (encodable (has_nnnorm (random_gen linarith.comp_source)))) : is_cyclic (encodable (has_nnnorm (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_41313 (h0 : add_group (semiring (semiring (semiring (has_top linarith.comp))))) : is_add_cyclic (semiring (semiring (semiring (has_top linarith.comp)))) := sorry --non-trivial
lemma new_lemma_41314 (h0 : complete_lattice (has_neg (finset pos))) : complete_lattice.is_Sup_finite_compact (has_neg (finset pos)) := sorry --non-trivial
lemma new_lemma_41315 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (random_gen.{0} fun_info) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (random_gen.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_41316 (h0 : functor.add_const (ordered_comm_monoid (has_Inf pos)) pos) : @has_exists_mul_of_le.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_Inf.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_41317 (h0 : topological_space (boolean_algebra (has_nndist (finset (finset pos))))) : totally_separated_space (boolean_algebra (has_nndist (finset (finset pos)))) := sorry --non-trivial
lemma new_lemma_41318 (h0 : topological_space (linear_ordered_field (option ennreal))) : discrete_topology (linear_ordered_field (option ennreal)) := sorry --non-trivial
lemma new_lemma_41319 (h0 : topological_space (has_norm (has_top to_additive.value_type))) : t0_space (has_norm (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_41320 (h0 : topological_space (comm_group (has_add Type))) : t1_space (comm_group (has_add Type)) := sorry --non-trivial
lemma new_lemma_41321 (h0 : functor.add_const (group (is_R_or_C empty)) (option unsigned)) : @is_cyclic.{0} (is_R_or_C.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (is_R_or_C.{0} empty)) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_41322 (h0 : topological_space (left_cancel_monoid (option empty))) : loc_path_connected_space (left_cancel_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_41323 (h0 : function.extfun (finset Type) (has_mem.mem (with_one (semiring (has_norm (semiring (semiring linarith.comp))))))) : @strong_rank_condition.{0} (with_one.{0} (semiring.{0} (has_norm.{0} (semiring.{0} (semiring.{0} linarith.comp))))) (@finset.pi.empty.{1 0} Type ring.{0} (with_one.{0} (semiring.{0} (has_norm.{0} (semiring.{0} (semiring.{0} linarith.comp))))) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_one.{0} (semiring.{0} (has_norm.{0} (semiring.{0} (semiring.{0} linarith.comp)))))) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_41324 (h0 : ordered_add_comm_monoid (filter num)) : archimedean (filter num) := sorry --non-trivial
lemma new_lemma_41325 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (add_comm_monoid.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_41326 (h0 : cancel_comm_monoid_with_zero (has_nndist (option pos))) : unique_factorization_monoid (has_nndist (option pos)) := sorry --non-trivial
lemma new_lemma_41327 (h0 : functor.add_const (group (boolean_algebra.core ennreal)) unsigned) : @is_cyclic.{0} (boolean_algebra.core.{0} ennreal) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.core.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_41328 (h0 : topological_space (with_one (random_gen num))) : discrete_topology (with_one (random_gen num)) := sorry --non-trivial
lemma new_lemma_41329 (h0 : uniform_space (comm_group (ring (ring Type)))) : separated_space (comm_group (ring (ring Type))) := sorry --non-trivial
lemma new_lemma_41330 (h0 : topological_space (pseudo_emetric_space congr_arg_kind)) : t1_space (pseudo_emetric_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_41331 (h0 : functor.add_const (function.extfun Type topological_space) real) : @locally_compact_space.{0} (generalized_boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) real h0) (generalized_boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_41332 (h0 : cancel_comm_monoid_with_zero (has_Inf (finset (has_Inf linarith.comp)))) : unique_factorization_monoid (has_Inf (finset (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_41333 (h1 : has_lt (add_comm_semigroup std_gen)) : no_max_order (add_comm_semigroup std_gen) := sorry --non-trivial
lemma new_lemma_41334 (h0 : uniform_space (with_zero (normed_group string_imp))) : complete_space (with_zero (normed_group string_imp)) := sorry --non-trivial
lemma new_lemma_41335 (h0 : has_vadd (has_ssubset string_imp) string_imp) : has_faithful_vadd (has_ssubset string_imp) string_imp := sorry --non-trivial
lemma new_lemma_41336 (h0 : topological_space (ordered_comm_group (option num))) : preirreducible_space (ordered_comm_group (option num)) := sorry --non-trivial
lemma new_lemma_41337 (h0 : cancel_comm_monoid_with_zero (finset unsigned)) : unique_factorization_monoid (finset unsigned) := sorry --non-trivial
lemma new_lemma_41338 (h0 : topological_space (normed_group (random_gen num))) : totally_disconnected_space (normed_group (random_gen num)) := sorry --non-trivial
lemma new_lemma_41339 (h0 : topological_space (add_cancel_monoid (has_to_string pos))) : preconnected_space (add_cancel_monoid (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_41340 (h0 : ordered_add_comm_monoid (ordered_comm_ring pos)) : archimedean (ordered_comm_ring pos) := sorry --non-trivial
lemma new_lemma_41341 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (semi_normed_comm_ring fun_info)) := sorry --non-trivial
lemma new_lemma_41342 (h0 : linarith.ineq -> linarith.ineq -> linarith.ineq) : is_right_cancel linarith.ineq h0 := sorry --non-trivial
lemma new_lemma_41343 (h0 : functor.add_const (group (has_to_string pos)) pos) : @is_simple_group.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_to_string.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_41344 (h0 : topological_space (has_nndist (has_to_string unsigned))) : topological_space.separable_space (has_nndist (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_41345 (h0 : functor.add_const (list (semigroup environment.implicit_infer_kind)) linarith.comp) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_41346 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (@id.{2} Type num) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (@id.{2} Type num))  := sorry --non-trivial
lemma new_lemma_41347 (h1 : ring (encodable (has_ssubset (has_ssubset (random_gen char))))) : rank_condition (encodable (has_ssubset (has_ssubset (random_gen char)))) := sorry --non-trivial
lemma new_lemma_41348 (h0 : functor.add_const (topological_space (add_cancel_monoid unsigned)) pos) : @topological_space.separable_space.{0} (add_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_41349 (h0 : functor.add_const (add_monoid (measurable_space.dynkin_system empty)) (semiring empty)) : @add_monoid.fg.{0} (measurable_space.dynkin_system.{0} empty) (@functor.add_const.run.{0 0} (add_monoid.{0} (measurable_space.dynkin_system.{0} empty)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_41350 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (has_pos_part.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_pos_part.{0} name))  := sorry --non-trivial
lemma new_lemma_41351 (h0 : not (has_mem.mem (has_emptyc linarith.comp_source) has_emptyc.emptyc -> false)) : @is_add_cyclic.{0} (has_emptyc.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type add_group.{0} (has_emptyc.{0} linarith.comp_source) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_emptyc.{0} linarith.comp_source) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_41352 (h0 : uniform_space (linear_ordered_field (option (option (option unsigned))))) : complete_space (linear_ordered_field (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_41353 (h0 : ring (measurable_space to_additive.value_type)) : rank_condition (measurable_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_41354 (h0 : functor.add_const (ordered_add_comm_monoid (has_Inf Type)) name) : @archimedean.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 0} (ordered_add_comm_monoid.{1} (has_Inf.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_41355 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (ordered_ring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_ring.{0} num))  := sorry --non-trivial
lemma new_lemma_41356 (h0 : ring (bin_tree (semiring unsigned))) : is_domain (bin_tree (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_41357 (h0 : monoid (has_nndist Type)) : monoid.fg (has_nndist Type) := sorry --non-trivial
lemma new_lemma_41358 (h0 : ordered_comm_monoid (has_nndist (finset linarith.comp))) : has_exists_mul_of_le (has_nndist (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_41359 (h0 : functor.add_const (ring (ring pos)) (has_Inf linarith.comp)) : @is_domain.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (ring.{0} pos)) (has_Inf.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_41360 (h0 : function.extfun nat fin) : @rank_condition.{1} (ordered_comm_ring.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (ordered_comm_ring.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_41361 (h1 : function.extfun Type topological_space) : t0_space empty := sorry --non-trivial
lemma new_lemma_41362 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (has_inv string_imp)) := sorry --non-trivial
lemma new_lemma_41363 (h0 : functor.add_const (topological_space (normed_comm_ring Type)) linarith.comp) : @preirreducible_space.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (normed_comm_ring.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_41364 (h0 : functor.add_const (topological_space (boolean_algebra Type)) name) : @irreducible_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_41365 (h0 : not (uniform_space (distrib_lattice to_additive.value_type) -> false)) : @complete_space.{0} (distrib_lattice.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (uniform_space.{0} (distrib_lattice.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_41366 (h0 : functor.add_const Prop (has_Inf linarith.comp)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_41367 (h0 : ring (div_inv_monoid (random_gen fun_info))) : strong_rank_condition (div_inv_monoid (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_41368 (h0 : group (has_emptyc (has_norm fun_info))) : normalizer_condition (has_emptyc (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_41369 (h0 : monoid (has_norm (has_top linarith.ineq))) : monoid.fg (has_norm (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_41370 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (random_gen.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (random_gen.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_41371 (h0 : functor.add_const (ordered_add_comm_monoid (has_add pos)) Type) : @archimedean.{0} (has_add.{0} pos) (@functor.add_const.run.{0 1} (ordered_add_comm_monoid.{0} (has_add.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_41372 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_41373 (h0 : topological_space (add_cancel_monoid (has_add linarith.comp))) : normal_space (add_cancel_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_41374 (h0 : functor.comp ring ring Type) : @is_domain.{1} (ring.{1} Type) (@functor.comp.run.{1 1 1} ring.{1} ring.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_41375 (h0 : uniform_space (ordered_cancel_add_comm_monoid congr_arg_kind)) : complete_space (ordered_cancel_add_comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_41376 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (finset.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (finset.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_41377 (h1 : function.extfun Type ring) : @is_domain.{0} (complete_distrib_lattice.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h1 (complete_distrib_lattice.{0} num))  := sorry --non-trivial
lemma new_lemma_41378 (h0 : finset (has_star (semiring empty))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_41379 (h0 : measurable_space (semi_normed_comm_ring string.iterator_imp)) (h1 : filter (semi_normed_comm_ring string.iterator_imp)) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_41380 (h0 : monoid (has_nndist (option empty))) : monoid.fg (has_nndist (option empty)) := sorry --non-trivial
lemma new_lemma_41381 (h0 : function.extfun Type (functor.add_const (topological_space pos))) : @loc_path_connected_space.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) linarith.comp (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} pos)) h0 linarith.comp))  := sorry --non-trivial
lemma new_lemma_41382 (h0 : ulower (list pnat)) (h1 : fin has_zero.zero) : pnat.coprime (list.head (ulower.up h0)) (matrix.vec_empty h1) := sorry --non-trivial
lemma new_lemma_41383 (h1 : uniform_space (with_one (random_gen linarith.comp_source))) : complete_space (with_one (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_41384 (h0 : num -> num -> Prop) : is_per num h0 := sorry --non-trivial
lemma new_lemma_41385 (h0 : topological_space (canonically_ordered_monoid (has_Inf Type))) : preconnected_space (canonically_ordered_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_41386 (h0 : topological_space (cancel_monoid environment.implicit_infer_kind)) : normal_space (cancel_monoid environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_41387 (h0 : function.extfun Type ring) : @is_domain.{0} (has_to_string.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_to_string.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_41388 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_domain.{1} (canonically_ordered_comm_semiring.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ring.{1}) (canonically_ordered_comm_semiring.{1} Type))  := sorry --non-trivial
lemma new_lemma_41389 (h0 : add_group (has_Inf (boolean_algebra.core (has_add Type)))) : is_add_cyclic (has_Inf (boolean_algebra.core (has_add Type))) := sorry --non-trivial
lemma new_lemma_41390 (h0 : topological_space (has_top (has_norm fun_info))) : totally_separated_space (has_top (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_41391 (h0 : ring (has_zero (has_add Type))) : is_principal_ideal_ring (has_zero (has_add Type)) := sorry --non-trivial
lemma new_lemma_41392 (h0 : functor.add_const (function.extfun Type add_group) pos) : @is_add_cyclic.{0} (generalized_boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_group.{0}) pos h0) (generalized_boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_41393 (h0 : cancel_comm_monoid_with_zero (has_neg (option (option pos)))) : unique_factorization_monoid (has_neg (option (option pos))) := sorry --non-trivial
lemma new_lemma_41394 (h0 : topological_space (mul_zero_class (mul_zero_class unsigned))) : preirreducible_space (mul_zero_class (mul_zero_class unsigned)) := sorry --non-trivial
lemma new_lemma_41395 (h0 : multiset (uniform_space (has_lt enat))) : @complete_space.{0} (has_lt.{0} enat) (@multiset.inf.{0} (uniform_space.{0} (has_lt.{0} enat)) (@lattice.to_semilattice_inf.{0} (uniform_space.{0} (has_lt.{0} enat)) (@conditionally_complete_lattice.to_lattice.{0} (uniform_space.{0} (has_lt.{0} enat)) (@complete_lattice.to_conditionally_complete_lattice.{0} (uniform_space.{0} (has_lt.{0} enat)) (@uniform_space.complete_lattice.{0} (has_lt.{0} enat))))) (@bounded_order.to_order_top.{0} (uniform_space.{0} (has_lt.{0} enat)) (@preorder.to_has_le.{0} (uniform_space.{0} (has_lt.{0} enat)) (@partial_order.to_preorder.{0} (uniform_space.{0} (has_lt.{0} enat)) (@semilattice_inf.to_partial_order.{0} (uniform_space.{0} (has_lt.{0} enat)) (@lattice.to_semilattice_inf.{0} (uniform_space.{0} (has_lt.{0} enat)) (@conditionally_complete_lattice.to_lattice.{0} (uniform_space.{0} (has_lt.{0} enat)) (@complete_lattice.to_conditionally_complete_lattice.{0} (uniform_space.{0} (has_lt.{0} enat)) (@uniform_space.complete_lattice.{0} (has_lt.{0} enat)))))))) (@complete_lattice.to_bounded_order.{0} (uniform_space.{0} (has_lt.{0} enat)) (@uniform_space.complete_lattice.{0} (has_lt.{0} enat)))) h0)  := sorry --non-trivial
lemma new_lemma_41396 (h0 : topological_space (has_neg_part (has_neg_part unsigned))) : regular_space (has_neg_part (has_neg_part unsigned)) := sorry --non-trivial
lemma new_lemma_41397 (h0 : topological_space (add_cancel_comm_monoid (random_gen (random_gen char)))) : t0_space (add_cancel_comm_monoid (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_41398 (h0 : functor.add_const (ordered_add_comm_monoid (has_Inf name)) name) : @archimedean.{0} (has_Inf.{0} name) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_Inf.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_41399 (h0 : group (has_to_string (option (monoid_with_zero (option (monoid_with_zero ennreal)))))) : group.fg (has_to_string (option (monoid_with_zero (option (monoid_with_zero ennreal))))) := sorry --non-trivial
lemma new_lemma_41400 (h0 : ring (add_cancel_monoid (has_nndist environment.implicit_infer_kind))) : rank_condition (add_cancel_monoid (has_nndist environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_41401 (h0 : add_monoid (sub_neg_monoid (finset (finset (finset linarith.comp))))) : add_monoid.fg (sub_neg_monoid (finset (finset (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_41402 (h0 : complete_lattice (boolean_algebra environment.implicit_infer_kind)) : is_atomistic (boolean_algebra environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_41403 (h0 : functor.add_const (topological_space (ring linarith.comp)) linarith.comp) : @preirreducible_space.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_41404 (h0 : function.extfun (Type 1) topological_space) : @totally_disconnected_space.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_41405 (h0 : function.extfun Type (functor.comp topological_space semigroup)) : @totally_disconnected_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} environment.implicit_infer_kind (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} semigroup.{0}) h0 environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_41406 (h0 : add_group (has_neg_part unsigned)) : is_add_cyclic (has_neg_part unsigned) := sorry --non-trivial
lemma new_lemma_41407 (h0 : complete_lattice (add_cancel_monoid (option pos))) : is_compactly_generated (add_cancel_monoid (option pos)) := sorry --non-trivial
lemma new_lemma_41408 (h0 : complete_lattice (distrib (mul_one_class (normed_field linarith.comp_source)))) : complete_lattice.is_Sup_finite_compact (distrib (mul_one_class (normed_field linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_41409 (h0 : not (group (linear_ordered_semiring num) -> false)) : @is_cyclic.{0} (linear_ordered_semiring.{0} num) (@classical.by_contradiction'.{1} (group.{0} (linear_ordered_semiring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_41410 (h0 : topological_space (sub_neg_monoid (has_Inf (has_add linarith.comp)))) : normal_space (sub_neg_monoid (has_Inf (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_41411 (h0 : ring (boolean_algebra (ring Type))) : strong_rank_condition (boolean_algebra (ring Type)) := sorry --non-trivial
lemma new_lemma_41412 (h0 : cancel_comm_monoid_with_zero (add_comm_monoid real)) : unique_factorization_monoid (add_comm_monoid real) := sorry --non-trivial
lemma new_lemma_41413 (h0 : group (normed_group (random_gen fun_info))) : normalizer_condition (normed_group (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_41414 (h3 : set (ereal -> char)) : set.separates_points h3 := sorry --non-trivial
lemma new_lemma_41415 (h0 : functor.add_const (function.extfun Type list) empty) : list.nodup (function.extfun_app (functor.add_const.run h0) (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_41416 (h0 : ordered_comm_monoid (ordered_comm_monoid (finset linarith.comp))) : has_exists_mul_of_le (ordered_comm_monoid (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_41417 (h0 : cancel_comm_monoid_with_zero (has_to_string (has_add (has_add linarith.comp)))) : unique_factorization_monoid (has_to_string (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_41418 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @locally_compact_space.{1} (has_neg_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (has_neg_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_41419 (h0 : functor.add_const (function.extfun (Type 1) list) pos) : palindrome (function.extfun_app (functor.add_const.run h0) (ring Type)) := sorry --non-trivial
lemma new_lemma_41420 (h0 : functor.add_const (finset (boolean_algebra linarith.comp)) (has_neg Type)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_41421 (h0 : functor.add_const (topological_space (finset environment.implicit_infer_kind)) pos) : @path_connected_space.{0} (finset.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_41422 (h0 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} (has_union.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_union.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_41423 (h1 : not (topological_space (denumerable linarith.comp_source) -> false)) : @t0_space.{0} (denumerable.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (denumerable.{0} linarith.comp_source)) h1)  := sorry --non-trivial
lemma new_lemma_41424 (h0 : functor.add_const (topological_space (semigroup environment.implicit_infer_kind)) name) : @sequential_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_41425 (h0 : topological_space (left_cancel_semigroup (semiring unsigned))) : discrete_topology (left_cancel_semigroup (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_41426 (h0 : functor.add_const (group (has_dist unsigned)) num) : @is_cyclic.{0} (has_dist.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (has_dist.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_41427 (h0 : functor.add_const (add_monoid Type) pos) : @add_monoid.fg.{1} Type (@functor.add_const.run.{1 0} (add_monoid.{1} Type) pos h0)  := sorry --non-trivial
lemma new_lemma_41428 (h0 : not (complete_lattice (preorder unsigned) -> false)) : @is_atomistic.{0} (preorder.{0} unsigned) (@classical.by_contradiction'.{1} (complete_lattice.{0} (preorder.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_41429 (h0 : topological_space (measurable_space.dynkin_system congr_arg_kind)) : discrete_topology (measurable_space.dynkin_system congr_arg_kind) := sorry --non-trivial
lemma new_lemma_41430 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem ring)) : @is_domain.{0} (random_gen.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) ring.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (random_gen.{0} empty))  := sorry --non-trivial
lemma new_lemma_41431 (h0 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} (has_emptyc.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_emptyc.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_41432 (h0 : canonically_ordered_monoid Type -> canonically_ordered_monoid Type -> Prop) : transitive h0 := sorry --non-trivial
lemma new_lemma_41433 (h0 : monoid (add_comm_monoid (ring Type))) : monoid.fg (add_comm_monoid (ring Type)) := sorry --non-trivial
lemma new_lemma_41434 (h0 : topological_space (boolean_algebra.core (has_neg_part (has_to_string (has_to_string Type))))) : loc_path_connected_space (boolean_algebra.core (has_neg_part (has_to_string (has_to_string Type)))) := sorry --non-trivial
lemma new_lemma_41435 (h0 : group (has_zero (finset ennreal))) : is_cyclic (has_zero (finset ennreal)) := sorry --non-trivial
lemma new_lemma_41436 (h0 : filter (linear_ordered_semiring (has_norm linarith.comp))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_41437 (h0 : group (linear_ordered_comm_ring (semiring (partial_order empty)))) : is_cyclic (linear_ordered_comm_ring (semiring (partial_order empty))) := sorry --non-trivial
lemma new_lemma_41438 (h3 : has_lt linarith.ineq) : no_max_order linarith.ineq := sorry --non-trivial
lemma new_lemma_41439 (h0 : function.extfun Type (functor.comp topological_space add_cancel_monoid)) : @discrete_topology.{0} (add_cancel_monoid.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} add_cancel_monoid.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} add_cancel_monoid.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_41440 (h0 : group fun_info) (h1 : subgroup fun_info) : subgroup.fg h1 := sorry --non-trivial
lemma new_lemma_41441 (h0 : function.extfun linarith.ineq (fun (x : linarith.ineq), Prop)) : zzz_forall (function.extfun_app h0) := sorry --non-trivial
lemma new_lemma_41442 (h0 : functor.add_const (ordered_add_comm_monoid (semigroup (has_add linarith.comp))) environment.implicit_infer_kind) : @archimedean.{0} (semigroup.{0} (has_add.{0} linarith.comp)) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (semigroup.{0} (has_add.{0} linarith.comp))) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_41443 (h0 : add_monoid (has_Sup empty)) : add_monoid.fg (has_Sup empty) := sorry --non-trivial
lemma new_lemma_41444 (h1 : uniform_space (measurable_space (has_one (semiring (semiring (semiring num)))))) : separated_space (measurable_space (has_one (semiring (semiring (semiring num))))) := sorry --non-trivial
lemma new_lemma_41445 (h0 : ring (boolean_algebra.core (comm_group Type))) : strong_rank_condition (boolean_algebra.core (comm_group Type)) := sorry --non-trivial
lemma new_lemma_41446 (h0 : group (ring (ring (has_Inf Type)))) : group.fg (ring (ring (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_41447 (h0 : group (semiring (has_norm linarith.comp_source))) : is_cyclic (semiring (has_norm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_41448 (h0 : topological_space (add_cancel_monoid (option num))) : t1_space (add_cancel_monoid (option num)) := sorry --non-trivial
lemma new_lemma_41449 (h0 : has_mem.mem (measurable_space linarith.comp) has_emptyc.emptyc) : @normalizer_condition.{0} (measurable_space.{0} linarith.comp) (@finset.pi.empty.{1 0} Type group.{0} (measurable_space.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_41450 (h0 : functor.add_const (topological_space (ring Type)) name) : @t0_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ring.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_41451 (h0 : complete_lattice (comm_semigroup name)) : is_atomistic (comm_semigroup name) := sorry --non-trivial
lemma new_lemma_41452 (h0 : function.extfun nat fin) : @has_exists_mul_of_le.{0} (canonically_ordered_comm_semiring.{0} pos) (@matrix.vec_empty.{0} (ordered_comm_monoid.{0} (canonically_ordered_comm_semiring.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_41453 (h0 : topological_space (linear_ordered_add_comm_group (has_norm linarith.ineq))) : locally_compact_space (linear_ordered_add_comm_group (has_norm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_41454 (h0 : function.extfun Type group) : @is_cyclic.{0} (with_bot.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} h0 (with_bot.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_41455 (h0 : uniform_space (add_cancel_monoid char)) : complete_space (add_cancel_monoid char) := sorry --non-trivial
lemma new_lemma_41456 (h0 : unsigned -> unsigned -> Prop) (h1 : functor.add_const (complete_lattice (quot h0)) unsigned) : @is_atomistic.{0} (@quot.{1} unsigned h0) (@functor.add_const.run.{0 0} (complete_lattice.{0} (@quot.{1} unsigned h0)) unsigned h1)  := sorry --non-trivial
lemma new_lemma_41457 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @loc_path_connected_space.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_41458 (h1 : ring (uniform_space (random_gen (has_sdiff reducibility_hints)))) : rank_condition (uniform_space (random_gen (has_sdiff reducibility_hints))) := sorry --non-trivial
lemma new_lemma_41459 (h0 : complete_lattice (semiring empty)) : is_atomistic (semiring empty) := sorry --non-trivial
lemma new_lemma_41460 (h0 : function.extfun Type group) : @is_cyclic.{0} (option.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (option.{0} pos))  := sorry --non-trivial
lemma new_lemma_41461 (h0 : topological_space (has_Inf (semigroup (ring Type)))) : preconnected_space (has_Inf (semigroup (ring Type))) := sorry --non-trivial
lemma new_lemma_41462 (h0 : not (topological_space (option unsigned) -> false)) : @preirreducible_space.{0} (option.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (option.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_41463 (h0 : group (has_neg (boolean_algebra linarith.comp))) : normalizer_condition (has_neg (boolean_algebra linarith.comp)) := sorry --non-trivial
lemma new_lemma_41464 (h0 : not (topological_space (left_cancel_monoid empty) -> false)) : @path_connected_space.{0} (left_cancel_monoid.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (left_cancel_monoid.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_41465 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @strong_rank_condition.{1} (ordered_comm_ring.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (ordered_comm_ring.{1} Type)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_41466 (h0 : fin has_zero.zero) : @is_atomistic.{0} (normed_lattice_add_comm_group.{0} real) (@matrix.vec_empty.{0} (complete_lattice.{0} (normed_lattice_add_comm_group.{0} real)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_41467 (h0 : functor.add_const (topological_space (has_pos_part Type)) pos) : @preirreducible_space.{1} (has_pos_part.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_pos_part.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_41468 (h0 : functor.add_const (complete_lattice (preorder empty)) empty) : @is_compactly_generated.{0} (preorder.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (preorder.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_41469 (h0 : fin has_zero.zero) : @normal_space.{1} (canonically_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (canonically_ordered_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_41470 (h0 : function.extfun Type (functor.add_const (topological_space (ring name)))) : @preconnected_space.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} name)) pos (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (ring.{0} name))) h0 pos))  := sorry --non-trivial
lemma new_lemma_41471 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (has_bot.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_bot.{0} pos))  := sorry --non-trivial
lemma new_lemma_41472 (h0 : topological_space (dlist (has_nnnorm linarith.ineq))) : totally_disconnected_space (dlist (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_41473 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (monoid.{0} unsigned) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_41474 (h0 : not (complete_lattice (normed_group to_additive.value_type) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (normed_group.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (complete_lattice.{0} (normed_group.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_41475 (h0 : functor.add_const (ring (add_comm_monoid pos)) linarith.comp) : @is_domain.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (add_comm_monoid.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_41476 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (has_to_string.{0} num) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (has_to_string.{0} num))  := sorry --non-trivial
lemma new_lemma_41477 (h0 : functor.add_const (uniform_space (left_cancel_semigroup unsigned)) unsigned) : @separated_space.{0} (left_cancel_semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (uniform_space.{0} (left_cancel_semigroup.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_41478 (h0 : functor.add_const (topological_space Type) Type) : @regular_space.{1} Type (@functor.add_const.run.{1 1} (topological_space.{1} Type) Type h0)  := sorry --non-trivial
lemma new_lemma_41479 (h0 : topological_space (add_cancel_monoid (has_Inf (ring name)))) : locally_compact_space (add_cancel_monoid (has_Inf (ring name))) := sorry --non-trivial
lemma new_lemma_41480 (h0 : group (sub_neg_monoid Type)) : is_simple_group (sub_neg_monoid Type) := sorry --non-trivial
lemma new_lemma_41481 (h0 : topological_space (with_bot (semiring (semiring congr_arg_kind)))) : irreducible_space (with_bot (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_41482 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (has_neg ennreal)) := sorry --non-trivial
lemma new_lemma_41483 (h0 : cancel_comm_monoid_with_zero (has_bot (has_neg Type))) : unique_factorization_monoid (has_bot (has_neg Type)) := sorry --non-trivial
lemma new_lemma_41484 (h0 : functor.add_const (complete_lattice (has_to_string name)) name) : @complete_lattice.is_Sup_finite_compact.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_to_string.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_41485 (h0 : topological_space (metric_space empty)) : irreducible_space (metric_space empty) := sorry --non-trivial
lemma new_lemma_41486 (h1 : topological_space (add_monoid (fintype linarith.ineq))) : t0_space (add_monoid (fintype linarith.ineq)) := sorry --non-trivial
lemma new_lemma_41487 (h0 : functor.comp topological_space canonically_ordered_comm_semiring Type) : @totally_separated_space.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} canonically_ordered_comm_semiring.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_41488 (h0 : function.extfun (Type 1) uniform_space) : @separated_space.{1} (comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} h0 (comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_41489 (h0 : ring (canonically_linear_ordered_monoid linarith.comp)) : is_principal_ideal_ring (canonically_linear_ordered_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_41490 (h0 : filter (ring (has_Inf (ring (has_add (has_add (has_add Type))))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_41491 (h0 : ring (normed_field (has_nnnorm char))) : is_domain (normed_field (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_41492 (h0 : topological_space (has_Inf (has_add (has_add (has_neg pos))))) : sequential_space (has_Inf (has_add (has_add (has_neg pos)))) := sorry --non-trivial
lemma new_lemma_41493 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (monoid_with_zero.{0} (option.{0} ennreal)) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (monoid_with_zero.{0} (option.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_41494 (h0 : has_mem.mem (with_one num) has_emptyc.emptyc) : @discrete_topology.{0} (with_one.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_one.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_41495 (h0 : not (monoid (left_cancel_semigroup empty) -> false)) : @monoid.fg.{0} (left_cancel_semigroup.{0} empty) (@classical.by_contradiction'.{1} (monoid.{0} (left_cancel_semigroup.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_41496 (h0 : topological_space (simple_graph (has_pos_part (finset (ring linarith.comp))))) : locally_compact_space (simple_graph (has_pos_part (finset (ring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_41497 (h0 : functor.add_const (function.extfun Type add_group) pos) : @is_add_cyclic.{0} (ordered_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type add_group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_group.{0}) pos h0) (ordered_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_41498 (h0 : topological_space (has_ssubset (mul_one_class (mul_one_class linarith.comp_source)))) : path_connected_space (has_ssubset (mul_one_class (mul_one_class linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_41499 (h0 : complete_lattice (denumerable (random_gen to_additive.value_type))) : complete_lattice.is_Sup_finite_compact (denumerable (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_41500 (h0 : functor.add_const (complete_lattice (comm_group Type)) linarith.comp) : @is_compactly_generated.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (comm_group.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_41501 (h0 : not (topological_space (comm_ring string.iterator_imp) -> false)) : @t0_space.{0} (comm_ring.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (topological_space.{0} (comm_ring.{0} string.iterator_imp)) h0)  := sorry --non-trivial
lemma new_lemma_41502 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (linear_ordered_cancel_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_cancel_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_41503 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (canonically_ordered_comm_semiring.{0} pos) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (canonically_ordered_comm_semiring.{0} pos))  := sorry --non-trivial
lemma new_lemma_41504 (h1 : not (ring (semi_normed_ring reducibility_hints) -> false)) : @is_domain.{0} (semi_normed_ring.{0} reducibility_hints) (@classical.by_contradiction'.{1} (ring.{0} (semi_normed_ring.{0} reducibility_hints)) h1)  := sorry --non-trivial
lemma new_lemma_41505 (h0 : add_group (has_ssubset (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm linarith.ineq)))))) : is_add_cyclic (has_ssubset (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm linarith.ineq))))) := sorry --non-trivial
lemma new_lemma_41506 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_41507 (h0 : topological_space (semigroup (has_add linarith.comp))) : sequential_space (semigroup (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_41508 (h0 : topological_space (has_ssubset (has_nnnorm (random_gen (random_gen fun_info))))) : t0_space (has_ssubset (has_nnnorm (random_gen (random_gen fun_info)))) := sorry --non-trivial
lemma new_lemma_41509 (h0 : functor.add_const (ring (ring empty)) unsigned) : @is_domain.{0} (ring.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (ring.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_41510 (h0 : topological_space (measurable_space.dynkin_system (semiring unsigned))) : topological_space.separable_space (measurable_space.dynkin_system (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_41511 (h0 : topological_space (linear_ordered_comm_monoid_with_zero congr_arg_kind)) : irreducible_space (linear_ordered_comm_monoid_with_zero congr_arg_kind) := sorry --non-trivial
lemma new_lemma_41512 (h0 : uniform_space (ordered_comm_monoid (has_Inf (has_Inf (has_Inf (has_Inf Type)))))) : separated_space (ordered_comm_monoid (has_Inf (has_Inf (has_Inf (has_Inf Type))))) := sorry --non-trivial
lemma new_lemma_41513 (h0 : add_group (complete_semilattice_Sup char)) : is_add_cyclic (complete_semilattice_Sup char) := sorry --non-trivial
lemma new_lemma_41514 (h0 : uniform_space (canonically_linear_ordered_monoid Type)) : complete_space (canonically_linear_ordered_monoid Type) := sorry --non-trivial
lemma new_lemma_41515 (h0 : add_group (generalized_boolean_algebra (has_Inf Type))) : is_add_cyclic (generalized_boolean_algebra (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_41516 (h0 : ring (has_compl (has_inv (random_gen linarith.ineq)))) : rank_condition (has_compl (has_inv (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_41517 (h0 : topological_space (has_add (comm_ring char))) : t0_space (has_add (comm_ring char)) := sorry --non-trivial
lemma new_lemma_41518 (h0 : has_mem.mem add_monoid has_emptyc.emptyc) : @add_monoid.fg.{0} (with_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_monoid.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) add_monoid.{0} h0) (with_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_41519 (h0 : ring (complete_semilattice_Sup fun_info)) : is_domain (complete_semilattice_Sup fun_info) := sorry --non-trivial
lemma new_lemma_41520 (h0 : ordered_comm_monoid (has_to_string (finset Type))) : has_exists_mul_of_le (has_to_string (finset Type)) := sorry --non-trivial
lemma new_lemma_41521 (h0 : filter (distrib_lattice (has_top string_imp))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_41522 (h0 : functor.add_const (group (normed_comm_ring Type)) name) : @is_simple_group.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (normed_comm_ring.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_41523 (h0 : functor.add_const pnat (complete_distrib_lattice congr_arg_kind)) : pnat.prime (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_41524 (h0 : group (ring (ring (has_Inf (has_Inf Type))))) : group.fg (ring (ring (has_Inf (has_Inf Type)))) := sorry --non-trivial
lemma new_lemma_41525 (h0 : function.extfun Type topological_space) : @t0_space.{0} (cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_41526 (h0 : not (group (has_emptyc num) -> false)) : @is_cyclic.{0} (has_emptyc.{0} num) (@classical.by_contradiction'.{1} (group.{0} (has_emptyc.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_41527 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (pseudo_metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (pseudo_metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_41528 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_41529 (h0 : topological_space (canonically_ordered_comm_semiring (has_pos_part (has_Inf (has_Inf pos))))) : irreducible_space (canonically_ordered_comm_semiring (has_pos_part (has_Inf (has_Inf pos)))) := sorry --non-trivial
lemma new_lemma_41530 (h0 : topological_space (add_comm_semigroup (mul_one_class fun_info))) : path_connected_space (add_comm_semigroup (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_41531 (h0 : topological_space (generalized_boolean_algebra (has_Inf real))) : totally_disconnected_space (generalized_boolean_algebra (has_Inf real)) := sorry --non-trivial
lemma new_lemma_41532 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (ordered_comm_semiring num)) := sorry --non-trivial
lemma new_lemma_41533 (h0 : not (complete_lattice (mul_one_class linarith.ineq) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (mul_one_class.{0} linarith.ineq) (@classical.by_contradiction'.{1} (complete_lattice.{0} (mul_one_class.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_41534 (h0 : complete_lattice (normed_group (semiring linarith.comp))) : is_atomistic (normed_group (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_41535 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_41536 (h0 : functor.add_const (topological_space (option ennreal)) unsigned) : @discrete_topology.{0} (option.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_41537 (h0 : topological_space (canonically_ordered_monoid (has_bot Type))) : preconnected_space (canonically_ordered_monoid (has_bot Type)) := sorry --non-trivial
lemma new_lemma_41538 (h0 : topological_space (measurable_space (has_top (random_gen linarith.comp_source)))) : t0_space (measurable_space (has_top (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_41539 (h0 : topological_space (monoid (option (option (option ennreal))))) : preconnected_space (monoid (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_41540 (h0 : complete_lattice (normed_group (semiring (semiring unsigned)))) : is_compactly_generated (normed_group (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_41541 (h0 : not (list (has_append linarith.ineq) -> false)) : list.nodup (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_41542 (h0 : group (normed_comm_ring name)) : is_simple_group (normed_comm_ring name) := sorry --non-trivial
lemma new_lemma_41543 (h0 : topological_space (has_nnnorm (mul_one_class (mul_one_class environment.projection_info)))) : path_connected_space (has_nnnorm (mul_one_class (mul_one_class environment.projection_info))) := sorry --non-trivial
lemma new_lemma_41544 (h0 : pnat) (h1 : fin has_zero.zero) : pnat.coprime h0 (matrix.vec_empty (matrix.vec_empty h1)) := sorry --non-trivial
lemma new_lemma_41545 (h0 : semiring (has_neg (option unsigned))) : is_noetherian_ring (has_neg (option unsigned)) := sorry --non-trivial
lemma new_lemma_41546 (h2 : group string_imp) : is_cyclic string_imp := sorry --non-trivial
lemma new_lemma_41547 (h0 : topological_space (option (option (option (option (partial_order (semiring num))))))) : discrete_topology (option (option (option (option (partial_order (semiring num)))))) := sorry --non-trivial
lemma new_lemma_41548 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (has_norm.{0} linarith.ineq) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_norm.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_41549 (h0 : not (uniform_space (non_assoc_semiring unsigned) -> false)) : @separated_space.{0} (non_assoc_semiring.{0} unsigned) (@classical.by_contradiction'.{1} (uniform_space.{0} (non_assoc_semiring.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_41550 (h0 : group (has_sub (semiring (semiring (semiring congr_arg_kind))))) : group.fg (has_sub (semiring (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_41551 (h0 : group (has_inter ennreal)) : is_simple_group (has_inter ennreal) := sorry --non-trivial
lemma new_lemma_41552 (h0 : functor.add_const (ring (complete_distrib_lattice Type)) name) : @is_domain.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (complete_distrib_lattice.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_41553 (h0 : set (simple_graph std_gen)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_41554 (h0 : functor.add_const (complete_lattice (has_pos_part pos)) linarith.comp) : @is_compactly_generated.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_pos_part.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_41555 (h0 : functor.add_const (ordered_add_comm_monoid (add_cancel_monoid pos)) (finset (has_add (has_pos_part pos)))) : @archimedean.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (add_cancel_monoid.{0} pos)) (finset.{0} (has_add.{0} (has_pos_part.{0} pos))) h0)  := sorry --non-trivial
lemma new_lemma_41556 (h0 : functor.add_const (add_group (has_neg_part name)) environment.implicit_infer_kind) : @is_add_cyclic.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (add_group.{0} (has_neg_part.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_41557 (h0 : ring (add_cancel_monoid (mul_one_class linarith.comp))) : is_domain (add_cancel_monoid (mul_one_class linarith.comp)) := sorry --non-trivial
lemma new_lemma_41558 (h0 : topological_space (boolean_algebra (comm_group Type))) : preconnected_space (boolean_algebra (comm_group Type)) := sorry --non-trivial
lemma new_lemma_41559 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (distrib_lattice.{0} linarith.ineq) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (distrib_lattice.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_41560 (h0 : functor.add_const (topological_space (free_add_monoid congr_arg_kind)) unsigned) : @t0_space.{0} (free_add_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_41561 (h0 : ordered_add_comm_monoid (has_zero (option (option pos)))) : archimedean (has_zero (option (option pos))) := sorry --non-trivial
lemma new_lemma_41562 (h0 : add_group (simple_graph (option (option (option (option unsigned)))))) : is_add_cyclic (simple_graph (option (option (option (option unsigned))))) := sorry --non-trivial
lemma new_lemma_41563 (h0 : ring (option (option unsigned))) : is_domain (option (option unsigned)) := sorry --non-trivial
lemma new_lemma_41564 (h0 : functor.add_const (finset (semigroup environment.implicit_infer_kind)) environment.implicit_infer_kind) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_41565 (h0 : add_monoid (omega_complete_partial_order empty)) : add_monoid.fg (omega_complete_partial_order empty) := sorry --non-trivial
lemma new_lemma_41566 (h0 : functor.comp topological_space has_add Type) : @loc_path_connected_space.{1} (has_add.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} has_add.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_41567 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_41568 (h0 : topological_space (ordered_comm_group (option empty))) : totally_separated_space (ordered_comm_group (option empty)) := sorry --non-trivial
lemma new_lemma_41569 (h0 : add_monoid (normed_group congr_arg_kind)) : add_monoid.fg (normed_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_41570 (h0 : topological_space (comm_semigroup real)) : irreducible_space (comm_semigroup real) := sorry --non-trivial
lemma new_lemma_41571 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (comm_ring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (comm_ring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_41572 (h0 : group (has_emptyc (has_norm (has_emptyc fun_info)))) : is_cyclic (has_emptyc (has_norm (has_emptyc fun_info))) := sorry --non-trivial
lemma new_lemma_41573 (h0 : mul_one_class char) (h1 : topological_space (submonoid char)) : preirreducible_space (submonoid char) := sorry --non-trivial
lemma new_lemma_41574 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (comm_group.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (comm_group.{0} name))  := sorry --non-trivial
lemma new_lemma_41575 (h0 : has_mem.mem complete_lattice has_emptyc.emptyc) : @is_compactly_generated.{0} (random_gen.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} h0) (random_gen.{0} num))  := sorry --non-trivial
lemma new_lemma_41576 (h0 : filter (has_nndist Type)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_41577 (h0 : topological_space (ring (has_neg linarith.comp))) : t0_space (ring (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_41578 (h0 : group (monoid (option (option (option ennreal))))) : normalizer_condition (monoid (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_41579 (h0 : group (denumerable (has_inv (random_gen fun_info)))) : normalizer_condition (denumerable (has_inv (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_41580 (h0 : finset (has_add (ring unsigned))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_41581 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @sequential_space.{0} (has_zero.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (has_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_41582 (h0 : ring (distrib linarith.comp_source)) : is_domain (distrib linarith.comp_source) := sorry --non-trivial
lemma new_lemma_41583 (h0 : function.extfun (Type 1) ring) : @rank_condition.{1} (has_pos_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (has_pos_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_41584 (h1 : function.extfun Type topological_space) : @path_connected_space.{0} (distrib_lattice.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (distrib_lattice.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_41585 (h0 : fin has_zero.zero) : @ulower.up.{0} Prop encodable.Prop (@matrix.vec_empty.{0} (@ulower.{0} Prop encodable.Prop) h0)  := sorry --non-trivial
lemma new_lemma_41586 (h0 : list (simple_graph (has_Inf (has_add (boolean_algebra.core pos))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_41587 (h0 : function.extfun nat fin) : @group.fg.{0} (sub_neg_monoid.{0} pos) (@matrix.vec_empty.{0} (group.{0} (sub_neg_monoid.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_41588 (h0 : functor.add_const (topological_space (has_neg linarith.comp)) environment.implicit_infer_kind) : @path_connected_space.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_41589 (h0 : topological_space (boolean_algebra.core linarith.comp)) : regular_space (boolean_algebra.core linarith.comp) := sorry --non-trivial
lemma new_lemma_41590 (h0 : functor.add_const (function.extfun Type ring) (finset name)) : @is_domain.{0} (complete_distrib_lattice.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) (finset.{0} name) h0) (complete_distrib_lattice.{0} pos))  := sorry --non-trivial
lemma new_lemma_41591 (h0 : ring (has_norm (has_inv (denumerable string_imp)))) : rank_condition (has_norm (has_inv (denumerable string_imp))) := sorry --non-trivial
lemma new_lemma_41592 (h0 : function.extfun Type group) : @group.fg.{0} (semigroup.{0} (semiring.{0} (semiring.{0} empty))) (@function.extfun_app.{2 1} Type group.{0} h0 (semigroup.{0} (semiring.{0} (semiring.{0} empty))))  := sorry --non-trivial
lemma new_lemma_41593 (h0 : not (has_mem.mem (with_bot num) has_emptyc.emptyc -> false)) : @rank_condition.{0} (with_bot.{0} num) (@finset.pi.empty.{1 0} Type ring.{0} (with_bot.{0} num) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_bot.{0} num) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_41594 (h0 : not (function.extfun Type monoid -> false)) : @monoid.fg.{0} num (@function.extfun_app.{2 1} Type monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type monoid.{0}) h0) num)  := sorry --non-trivial
lemma new_lemma_41595 (h0 : set (has_nnnorm (mul_one_class enat))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_41596 (h0 : ring (monoid_with_zero (option (option (option unsigned))))) : is_domain (monoid_with_zero (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_41597 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (has_neg.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_neg.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_41598 (h0 : add_group (ordered_cancel_comm_monoid empty)) : is_add_cyclic (ordered_cancel_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_41599 (h0 : ring (random_gen (id (with_bot (id (has_norm (has_norm congr_arg_kind))))))) : rank_condition (random_gen (id (with_bot (id (has_norm (has_norm congr_arg_kind)))))) := sorry --non-trivial
lemma new_lemma_41600 (h0 : uniform_space (add_comm_semigroup (normed_field ereal))) : complete_space (add_comm_semigroup (normed_field ereal)) := sorry --non-trivial
lemma new_lemma_41601 (h0 : function.extfun Type group) : @group.fg.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} h0 (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_41602 (h3 : topological_space (distrib (comm_ring (comm_ring to_additive.value_type)))) : totally_disconnected_space (distrib (comm_ring (comm_ring to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_41603 (h0 : topological_space (canonically_ordered_add_monoid unsigned)) : preirreducible_space (canonically_ordered_add_monoid unsigned) := sorry --non-trivial
lemma new_lemma_41604 (h0 : not (topological_space (measurable_space.dynkin_system congr_arg_kind) -> false)) : @topological_space.separable_space.{0} (measurable_space.dynkin_system.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (measurable_space.dynkin_system.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_41605 (h0 : functor.add_const (semiring (ordered_comm_monoid Type)) Type) : @is_noetherian_ring.{1} (ordered_comm_monoid.{1} Type) (@functor.add_const.run.{1 1} (semiring.{1} (ordered_comm_monoid.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_41606 (h0 : functor.add_const (topological_space (free_add_monoid empty)) (semiring num)) : @topological_space.separable_space.{0} (free_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} empty)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_41607 (h0 : functor.add_const (add_group (has_pos_part Type)) linarith.comp) : @is_add_cyclic.{1} (has_pos_part.{1} Type) (@functor.add_const.run.{1 0} (add_group.{1} (has_pos_part.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_41608 (h0 : filter (encodable (has_nnnorm linarith.ineq))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_41609 (h0 : group (normed_field (has_nnnorm (comm_ring reducibility_hints)))) : is_cyclic (normed_field (has_nnnorm (comm_ring reducibility_hints))) := sorry --non-trivial
lemma new_lemma_41610 (h0 : not (ring (add_right_cancel_monoid congr_arg_kind) -> false)) : @strong_rank_condition.{0} (add_right_cancel_monoid.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (ring.{0} (add_right_cancel_monoid.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_41611 (h0 : topological_space (canonically_ordered_monoid (has_bot Type))) : topological_space.separable_space (canonically_ordered_monoid (has_bot Type)) := sorry --non-trivial
lemma new_lemma_41612 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (has_zero.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_41613 (h0 : topological_space (has_Inf (finset (has_Inf linarith.comp)))) : t1_space (has_Inf (finset (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_41614 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (linear_ordered_field.{0} pos) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (linear_ordered_field.{0} pos))  := sorry --non-trivial
lemma new_lemma_41615 (h0 : add_monoid (has_Inf pos)) : add_monoid.fg (has_Inf pos) := sorry --non-trivial
lemma new_lemma_41616 (h0 : topological_space (ordered_comm_ring (has_neg linarith.comp))) : locally_compact_space (ordered_comm_ring (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_41617 (h0 : group (measurable_space (has_top linarith.comp_source))) : normalizer_condition (measurable_space (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_41618 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (has_edist.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (has_edist.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_41619 (h0 : topological_space (ordered_comm_monoid (has_nndist linarith.comp))) : loc_path_connected_space (ordered_comm_monoid (has_nndist linarith.comp)) := sorry --non-trivial
lemma new_lemma_41620 (h0 : Prop) (h1 : fin has_zero.zero) : implies h0 (matrix.vec_empty (id (id (id (id h1))))) := sorry --non-trivial
lemma new_lemma_41621 (h0 : topological_space (simple_graph congr_arg_kind)) : irreducible_space (simple_graph congr_arg_kind) := sorry --non-trivial
lemma new_lemma_41622 (h0 : function.extfun nat fin) : @complete_space.{0} (boolean_algebra.core.{0} pos) (@matrix.vec_empty.{0} (uniform_space.{0} (boolean_algebra.core.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_41623 (h0 : add_group (canonically_ordered_comm_semiring (ring linarith.comp))) : is_add_cyclic (canonically_ordered_comm_semiring (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_41624 (h0 : not (group (denumerable fun_info) -> false)) : @group.fg.{0} (denumerable.{0} fun_info) (@classical.by_contradiction'.{1} (group.{0} (denumerable.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_41625 (h0 : topological_space (boolean_algebra.core (add_comm_monoid pos))) : regular_space (boolean_algebra.core (add_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_41626 (h0 : not (complete_lattice (with_one char) -> false)) : @is_compactly_generated.{0} (with_one.{0} char) (@classical.by_contradiction'.{1} (complete_lattice.{0} (with_one.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_41627 (h0 : functor.add_const (topological_space (add_comm_monoid unsigned)) linarith.comp) : @regular_space.{0} (add_comm_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_41628 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (canonically_linear_ordered_monoid congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_41629 (h0 : fin has_zero.zero) : @is_cyclic.{0} (ordered_comm_ring.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type group.{0}) h0) (ordered_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_41630 (h0 : topological_space (with_one (has_top num))) : irreducible_space (with_one (has_top num)) := sorry --non-trivial
lemma new_lemma_41631 (h4 : ring (has_append (random_gen char))) : rank_condition (has_append (random_gen char)) := sorry --non-trivial
lemma new_lemma_41632 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (canonically_ordered_comm_semiring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_ordered_comm_semiring.{0} pos))  := sorry --non-trivial
lemma new_lemma_41633 (h0 : not (topological_space (complete_linear_order empty) -> false)) : @discrete_topology.{0} (complete_linear_order.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (complete_linear_order.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_41634 (h0 : ring (normed_group (random_gen (random_gen (random_gen linarith.ineq))))) : rank_condition (normed_group (random_gen (random_gen (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_41635 (h0 : functor.add_const (topological_space (add_cancel_monoid linarith.comp)) name) : @irreducible_space.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_41636 (h0 : filter (has_neg pos)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_41637 (h0 : topological_space (comm_group (finset pos))) : normal_space (comm_group (finset pos)) := sorry --non-trivial
lemma new_lemma_41638 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (group_with_zero ennreal)) := sorry --non-trivial
lemma new_lemma_41639 (h1 : ring (metric_space (random_gen to_additive.value_type))) : is_domain (metric_space (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_41640 (h0 : functor.add_const (ring (cancel_monoid name)) linarith.comp) : @strong_rank_condition.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (cancel_monoid.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_41641 (h0 : topological_space (plift (partial_order num))) : irreducible_space (plift (partial_order num)) := sorry --non-trivial
lemma new_lemma_41642 (h0 : ring (add_cancel_monoid Type)) : rank_condition (add_cancel_monoid Type) := sorry --non-trivial
lemma new_lemma_41643 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @totally_separated_space.{0} (has_nndist.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) topological_space.{0}) (has_nndist.{0} empty))  := sorry --non-trivial
lemma new_lemma_41644 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_41645 (h0 : ring (random_gen (with_bot string_imp))) : is_domain (random_gen (with_bot string_imp)) := sorry --non-trivial
lemma new_lemma_41646 (h0 : uniform_space (has_zero (option (option (option (option pos)))))) : separated_space (has_zero (option (option (option (option pos))))) := sorry --non-trivial
lemma new_lemma_41647 (h0 : topological_space (as_linear_order empty)) : locally_compact_space (as_linear_order empty) := sorry --non-trivial
lemma new_lemma_41648 (h0 : functor.add_const (ordered_comm_monoid (normed_comm_ring unsigned)) (finset Type)) : @has_exists_mul_of_le.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (normed_comm_ring.{0} unsigned)) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_41649 (h0 : functor.add_const (topological_space (ordered_ring num)) empty) : @irreducible_space.{0} (ordered_ring.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_41650 (h1 h2 : multiset (has_nnnorm linarith.comp_source)) : multiset.disjoint h1 h2 := sorry --non-trivial
lemma new_lemma_41651 (h0 : ring (has_top (random_gen linarith.comp_source))) : strong_rank_condition (has_top (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_41652 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (add_cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_41653 (h0 : has_mem.mem (with_one num) has_emptyc.emptyc) : @path_connected_space.{0} (with_one.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_one.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_41654 (h0 : group (measurable_space num)) : group.fg (measurable_space num) := sorry --non-trivial
lemma new_lemma_41655 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (complete_semilattice_Sup.{0} linarith.ineq) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (complete_semilattice_Sup.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_41656 (h0 : complete_lattice (has_pos_part (finset (ring Type)))) : complete_lattice.is_Sup_finite_compact (has_pos_part (finset (ring Type))) := sorry --non-trivial
lemma new_lemma_41657 (h0 : complete_lattice (id linarith.ineq)) : is_atomistic (id linarith.ineq) := sorry --non-trivial
lemma new_lemma_41658 (h0 : group (add_right_cancel_monoid (has_norm (semiring num)))) : is_cyclic (add_right_cancel_monoid (has_norm (semiring num))) := sorry --non-trivial
lemma new_lemma_41659 (h0 : has_neg (normed_field string.iterator_imp)) (h1 : measurable_space (normed_field string.iterator_imp)) : has_measurable_neg (normed_field string.iterator_imp) := sorry --non-trivial
lemma new_lemma_41660 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} (has_top.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (has_top.{0} empty))  := sorry --non-trivial
lemma new_lemma_41661 (h0 : topological_space (has_zero (has_add ennreal))) : totally_separated_space (has_zero (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_41662 (h0 : complete_lattice (metric_space (semiring (semiring (semiring empty))))) : is_compactly_generated (metric_space (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_41663 (h0 : function.extfun nat fin) : @totally_separated_space.{0} (boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))) (boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_41664 (h2 : add_group (nondiscrete_normed_field linarith.ineq)) : is_add_cyclic (nondiscrete_normed_field linarith.ineq) := sorry --non-trivial
lemma new_lemma_41665 (h0 : ereal -> ereal -> Prop) (h1 : list ereal) : list.sorted h0 h1 := sorry --non-trivial
lemma new_lemma_41666 (h0 : ring (has_star (semiring (semiring (semiring empty))))) : is_principal_ideal_ring (has_star (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_41667 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (measure_theory.measure_space unsigned)) := sorry --non-trivial
lemma new_lemma_41668 (h0 : complete_lattice (measurable_space.dynkin_system (semiring empty))) : is_compactly_generated (measurable_space.dynkin_system (semiring empty)) := sorry --non-trivial
lemma new_lemma_41669 (h0 : topological_space (has_nnnorm (mul_one_class ereal))) (h1 : preorder (has_nnnorm (mul_one_class ereal))) : order_closed_topology (has_nnnorm (mul_one_class ereal)) := sorry --non-trivial
lemma new_lemma_41670 (h0 : topological_space (add_comm_semigroup (add_comm_semigroup enat))) (h1 : preorder (add_comm_semigroup (add_comm_semigroup enat))) : order_closed_topology (add_comm_semigroup (add_comm_semigroup enat)) := sorry --non-trivial
lemma new_lemma_41671 (h1 : uniform_space (distrib_lattice to_additive.value_type)) : complete_space (distrib_lattice to_additive.value_type) := sorry --non-trivial
lemma new_lemma_41672 (h0 : function.extfun Type group) : @is_simple_group.{0} (complete_distrib_lattice.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (complete_distrib_lattice.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_41673 (h0 : ring (random_gen unsigned)) : rank_condition (random_gen unsigned) := sorry --non-trivial
lemma new_lemma_41674 (h0 : functor.add_const (group (has_neg environment.implicit_infer_kind)) name) : @is_simple_group.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (has_neg.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_41675 (h0 : functor.add_const (topological_space (preorder congr_arg_kind)) unsigned) : @totally_separated_space.{0} (preorder.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (preorder.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_41676 (h0 : topological_space (cancel_monoid (semigroup (has_add Type)))) : preconnected_space (cancel_monoid (semigroup (has_add Type))) := sorry --non-trivial
lemma new_lemma_41677 (h0 : complete_lattice (mul_zero_class (semiring empty))) : complete_lattice.is_Sup_finite_compact (mul_zero_class (semiring empty)) := sorry --non-trivial
lemma new_lemma_41678 (h0 : add_monoid (has_neg_part (has_add name))) : add_monoid.fg (has_neg_part (has_add name)) := sorry --non-trivial
lemma new_lemma_41679 (h0 : topological_space (distrib_lattice (has_ssubset fun_info))) : t0_space (distrib_lattice (has_ssubset fun_info)) := sorry --non-trivial
lemma new_lemma_41680 (h0 : not (semiring (linear_ordered_semiring unsigned) -> false)) : @is_noetherian_ring.{0} (linear_ordered_semiring.{0} unsigned) (@classical.by_contradiction'.{1} (semiring.{0} (linear_ordered_semiring.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_41681 (h0 : topological_space (ordered_comm_monoid Type)) : discrete_topology (ordered_comm_monoid Type) := sorry --non-trivial
lemma new_lemma_41682 (h0 : semigroup (has_zero (has_pos_part Type)) -> semigroup (has_zero (has_pos_part Type)) -> Prop) : is_refl (semigroup (has_zero (has_pos_part Type))) h0 := sorry --non-trivial
lemma new_lemma_41683 (h0 : topological_space (plift (semiring num))) : locally_compact_space (plift (semiring num)) := sorry --non-trivial
lemma new_lemma_41684 (h0 : uniform_space (has_neg (finset Type))) : complete_space (has_neg (finset Type)) := sorry --non-trivial
lemma new_lemma_41685 (h0 : topological_space (normed_group (with_bot to_additive.value_type))) : t0_space (normed_group (with_bot to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_41686 (h0 : not (function.extfun Type add_monoid -> false)) : @add_monoid.fg.{0} (has_union.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_monoid.{0}) h0) (has_union.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_41687 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (denumerable.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (denumerable.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_41688 (h0 : topological_space (complete_distrib_lattice name)) : t0_space (complete_distrib_lattice name) := sorry --non-trivial
lemma new_lemma_41689 (h0 : topological_space (random_gen linarith.comp_source)) : totally_separated_space (random_gen linarith.comp_source) := sorry --non-trivial
lemma new_lemma_41690 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : is_domain real := sorry --non-trivial
lemma new_lemma_41691 (h1 : topological_space (distrib_lattice to_additive.value_type)) : irreducible_space (distrib_lattice to_additive.value_type) := sorry --non-trivial
lemma new_lemma_41692 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (has_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_41693 (h0 : filter (with_zero (has_nnnorm linarith.comp_source))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_41694 (h0 : add_monoid (canonically_ordered_comm_semiring (option (option (option unsigned))))) : add_monoid.fg (canonically_ordered_comm_semiring (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_41695 (h0 : uniform_space (normed_comm_ring Type)) : complete_space (normed_comm_ring Type) := sorry --non-trivial
lemma new_lemma_41696 (h0 : topological_space (semi_normed_ring (mul_one_class (has_compl reducibility_hints)))) : t0_space (semi_normed_ring (mul_one_class (has_compl reducibility_hints))) := sorry --non-trivial
lemma new_lemma_41697 (h0 : functor.comp topological_space cancel_monoid Type) : @preirreducible_space.{1} (cancel_monoid.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} cancel_monoid.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_41698 (h0 : topological_space (ordered_comm_ring name)) : irreducible_space (ordered_comm_ring name) := sorry --non-trivial
lemma new_lemma_41699 (h0 : function.extfun (Type 1) (functor.add_const (topological_space (has_Inf linarith.comp)))) : @totally_separated_space.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_Inf.{0} linarith.comp)) Type (@function.extfun_app.{3 1} (Type 1) (functor.add_const.{0 1} (topological_space.{0} (has_Inf.{0} linarith.comp))) h0 Type))  := sorry --non-trivial
lemma new_lemma_41700 (h0 : add_monoid (with_bot (semiring (has_norm (semiring unsigned))))) : add_monoid.fg (with_bot (semiring (has_norm (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_41701 (h0 : topological_space (has_nndist (ring linarith.comp))) : locally_compact_space (has_nndist (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_41702 (h0 : function.extfun (Type 1) cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1} h0 (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_41703 (h0 : ring (add_comm_monoid (option num))) : rank_condition (add_comm_monoid (option num)) := sorry --non-trivial
lemma new_lemma_41704 (h0 : cancel_comm_monoid_with_zero (normed_group (semiring empty))) : unique_factorization_monoid (normed_group (semiring empty)) := sorry --non-trivial
lemma new_lemma_41705 (h2 : monoid num) : monoid.fg num := sorry --non-trivial
lemma new_lemma_41706 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (ordered_cancel_add_comm_monoid.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_cancel_add_comm_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_41707 (h0 : topological_space (pseudo_metric_space to_additive.value_type)) : totally_disconnected_space (pseudo_metric_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_41708 (h0 : topological_space (has_add Type)) : regular_space (has_add Type) := sorry --non-trivial
lemma new_lemma_41709 (h1 : topological_space enat) : totally_disconnected_space enat := sorry --non-trivial
lemma new_lemma_41710 (h0 : ring (normed_comm_ring (ring Type))) : is_principal_ideal_ring (normed_comm_ring (ring Type)) := sorry --non-trivial
lemma new_lemma_41711 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_to_string.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (has_to_string.{0} num))  := sorry --non-trivial
lemma new_lemma_41712 (h0 : function.extfun (Type 1) add_monoid) : @add_monoid.fg.{1} (mul_zero_class.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_monoid.{1} h0 (mul_zero_class.{1} Type))  := sorry --non-trivial
lemma new_lemma_41713 (h0 : not (complete_lattice (add_cancel_comm_monoid to_additive.value_type) -> false)) : @is_compactly_generated.{0} (add_cancel_comm_monoid.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (complete_lattice.{0} (add_cancel_comm_monoid.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_41714 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (non_assoc_semiring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (non_assoc_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_41715 (h0 : topological_space (distrib_lattice (has_inv (random_gen linarith.comp_source)))) : locally_compact_space (distrib_lattice (has_inv (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_41716 (h0 : ring (finset (finset Type))) : rank_condition (finset (finset Type)) := sorry --non-trivial
lemma new_lemma_41717 (h0 : fin has_zero.zero) : @separated_space.{0} (generalized_boolean_algebra.{0} name) (@matrix.vec_empty.{0} (uniform_space.{0} (generalized_boolean_algebra.{0} name)) (@function.extfun_app.{1 1} nat fin (@matrix.vec_empty.{0} (function.extfun.{1 1} nat fin) h0) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_41718 (h0 : functor.add_const (topological_space (has_nndist linarith.comp)) Type) : @irreducible_space.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_nndist.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_41719 (h0 : functor.add_const (ordered_comm_monoid (mul_zero_class Type)) Type) : @has_exists_mul_of_le.{1} (mul_zero_class.{1} Type) (@functor.add_const.run.{1 1} (ordered_comm_monoid.{1} (mul_zero_class.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_41720 (h0 : functor.add_const (topological_space (complete_distrib_lattice name)) Type) : @irreducible_space.{0} (complete_distrib_lattice.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (complete_distrib_lattice.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_41721 (h0 : topological_space (has_le linarith.ineq)) (h1 : add_group (has_le linarith.ineq)) : topological_add_group (has_le linarith.ineq) := sorry --non-trivial
lemma new_lemma_41722 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @discrete_topology.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) topological_space.{0}) (linear_ordered_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_41723 (h1 : topological_space (simple_graph reducibility_hints)) (h2 : preorder (simple_graph reducibility_hints)) : order_topology (simple_graph reducibility_hints) := sorry --non-trivial
lemma new_lemma_41724 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (finset.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (finset.{0} empty))  := sorry --non-trivial
lemma new_lemma_41725 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (complete_linear_order.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_linear_order.{0} num))  := sorry --non-trivial
lemma new_lemma_41726 (h0 : not (topological_space (with_zero fun_info) -> false)) : @totally_disconnected_space.{0} (with_zero.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (with_zero.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_41727 (h0 : function.extfun Type (functor.comp ring has_nndist)) : @rank_condition.{0} (has_nndist.{0} ennreal) (@functor.comp.run.{0 0 0} ring.{0} has_nndist.{0} ennreal (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} ring.{0} has_nndist.{0}) h0 ennreal))  := sorry --non-trivial
lemma new_lemma_41728 (h0 : prod (partial_order (semiring (semiring empty))) (partial_order (semiring (semiring empty)))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_41729 (h0 : functor.comp topological_space has_to_string unsigned) : @locally_compact_space.{0} (has_to_string.{0} unsigned) (@functor.comp.run.{0 0 0} topological_space.{0} has_to_string.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_41730 (h0 : group (has_Inf (has_pos_part pos))) : group.fg (has_Inf (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_41731 (h1 : complete_lattice (distrib_lattice fun_info)) : complete_lattice.is_Sup_finite_compact (distrib_lattice fun_info) := sorry --non-trivial
lemma new_lemma_41732 (h0 : functor.add_const (uniform_space (ring ennreal)) num) : @complete_space.{0} (ring.{0} ennreal) (@functor.add_const.run.{0 0} (uniform_space.{0} (ring.{0} ennreal)) num h0)  := sorry --non-trivial
lemma new_lemma_41733 (h0 : functor.add_const (uniform_space (has_neg_part pos)) name) : @complete_space.{0} (has_neg_part.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_neg_part.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_41734 (h0 : complete_lattice (add_cancel_monoid (comm_group unsigned))) : is_compactly_generated (add_cancel_monoid (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_41735 (h0 : topological_space (has_norm (semiring (metric_space (metric_space (has_top linarith.comp)))))) : normal_space (has_norm (semiring (metric_space (metric_space (has_top linarith.comp))))) := sorry --non-trivial
lemma new_lemma_41736 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (boolean_algebra.core.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (boolean_algebra.core.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_41737 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (monoid.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_41738 (h0 : functor.add_const (topological_space (boolean_algebra real)) real) : @normal_space.{0} (boolean_algebra.{0} real) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} real)) real h0)  := sorry --non-trivial
lemma new_lemma_41739 (h0 : topological_space (with_bot unsigned)) : normal_space (with_bot unsigned) := sorry --non-trivial
lemma new_lemma_41740 (h0 : topological_space (mul_one_class char)) : t0_space (mul_one_class char) := sorry --non-trivial
lemma new_lemma_41741 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_41742 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_to_string.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_to_string.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_41743 (h0 : group (ordered_comm_monoid (ring linarith.comp))) : normalizer_condition (ordered_comm_monoid (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_41744 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (random_gen.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (random_gen.{0} empty))  := sorry --non-trivial
lemma new_lemma_41745 (h0 : add_group (ring (comm_group (has_neg_part environment.implicit_infer_kind)))) : is_add_cyclic (ring (comm_group (has_neg_part environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_41746 (h0 : functor.add_const (topological_space (group_with_zero empty)) unsigned) : @locally_compact_space.{0} (group_with_zero.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (group_with_zero.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_41747 (h0 : function.extfun Type (prod (has_Sup empty))) : id_rel (function.extfun_app h0 (has_Sup empty)) := sorry --non-trivial
lemma new_lemma_41748 (h0 h4 : multiset enat) : multiset.le h0 h4 := sorry --non-trivial
lemma new_lemma_41749 (h0 : functor.add_const (topological_space (normed_comm_ring linarith.comp)) name) : @normal_space.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_41750 (h0 : functor.comp topological_space linear_ordered_field name) : @topological_space.separable_space.{0} (linear_ordered_field.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} linear_ordered_field.{0} name h0)  := sorry --non-trivial
lemma new_lemma_41751 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (has_pos_part.{0} real) (@function.extfun_app.{2 1} Type monoid.{0} h0 (has_pos_part.{0} real))  := sorry --non-trivial
lemma new_lemma_41752 (h3 : ring (distrib char)) : rank_condition (distrib char) := sorry --non-trivial
lemma new_lemma_41753 (h3 : set (nondiscrete_normed_field char)) : set.finite h3 := sorry --non-trivial
lemma new_lemma_41754 (h0 : topological_space (distrib (mul_one_class (mul_one_class (mul_one_class fun_info))))) : totally_disconnected_space (distrib (mul_one_class (mul_one_class (mul_one_class fun_info)))) := sorry --non-trivial
lemma new_lemma_41755 (h0 : uniform_space (plift (semiring (semiring num)))) : separated_space (plift (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_41756 (h0 : functor.add_const (topological_space (ordered_comm_ring pos)) name) : @preconnected_space.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_41757 (h0 : has_neg (add_group linarith.comp)) (h1 : not (measurable_space (add_group linarith.comp) -> false)) : @has_measurable_neg.{0} (add_group.{0} linarith.comp) h0 (@classical.by_contradiction'.{1} (measurable_space.{0} (add_group.{0} linarith.comp)) h1)  := sorry --non-trivial
lemma new_lemma_41758 (h0 h1 : list ereal) : list.subperm h0 h1 := sorry --non-trivial
lemma new_lemma_41759 (h0 : topological_space (boolean_algebra.core ennreal)) : discrete_topology (boolean_algebra.core ennreal) := sorry --non-trivial
lemma new_lemma_41760 (h1 : set (linarith.ineq -> mul_one_class fun_info)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_41761 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (has_Sup.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_Sup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_41762 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @separated_space.{1} (add_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 uniform_space.{1}) (add_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_41763 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (measurable_space.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (measurable_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_41764 (h0 : topological_space (add_left_cancel_monoid (random_gen fun_info))) : t0_space (add_left_cancel_monoid (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_41765 (h0 : function.extfun (Type 1) (functor.comp add_group complete_distrib_lattice)) : @is_add_cyclic.{1} (complete_distrib_lattice.{1} Type) (@functor.comp.run.{1 1 1} add_group.{1} complete_distrib_lattice.{1} Type (@function.extfun_app.{3 2} (Type 1) (functor.comp.{1 1 1} add_group.{1} complete_distrib_lattice.{1}) h0 Type))  := sorry --non-trivial
lemma new_lemma_41766 (h0 : functor.add_const (topological_space (has_zero name)) (comm_group Type)) : @t0_space.{0} (has_zero.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (has_zero.{0} name)) (comm_group.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_41767 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (@id.{2} Type string_imp) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (@id.{2} Type string_imp))  := sorry --non-trivial
lemma new_lemma_41768 (h0 : group (has_pos_part (sub_neg_monoid (has_Inf real)))) : is_simple_group (has_pos_part (sub_neg_monoid (has_Inf real))) := sorry --non-trivial
lemma new_lemma_41769 (h1 : monoid (with_bot fun_info)) : monoid.fg (with_bot fun_info) := sorry --non-trivial
lemma new_lemma_41770 (h0 : ring (has_add (has_ssubset linarith.ineq))) : rank_condition (has_add (has_ssubset linarith.ineq)) := sorry --non-trivial
lemma new_lemma_41771 (h0 : functor.add_const (topological_space (left_cancel_semigroup unsigned)) empty) : @normal_space.{0} (left_cancel_semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_semigroup.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_41772 (h0 : monoid (normed_group (has_norm (has_norm congr_arg_kind)))) : monoid.fg (normed_group (has_norm (has_norm congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_41773 (h0 : topological_space (has_nndist empty)) : t0_space (has_nndist empty) := sorry --non-trivial
lemma new_lemma_41774 (h0 : topological_space (linear_ordered_semiring congr_arg_kind)) : irreducible_space (linear_ordered_semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_41775 (h0 : functor.add_const (list (comm_group environment.implicit_infer_kind)) name) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_41776 (h0 : not (function.extfun Type cancel_comm_monoid_with_zero -> false)) : @unique_factorization_monoid.{0} (metric_space.{0} num) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type cancel_comm_monoid_with_zero.{0}) h0) (metric_space.{0} num))  := sorry --non-trivial
lemma new_lemma_41777 (h0 : topological_space (has_sub unsigned)) : discrete_topology (has_sub unsigned) := sorry --non-trivial
lemma new_lemma_41778 (h0 : functor.add_const (function.extfun (Type 1) topological_space) pos) : @preirreducible_space.{1} (simple_graph.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) pos h0) (simple_graph.{1} Type))  := sorry --non-trivial
lemma new_lemma_41779 (h0 : ordered_add_comm_monoid (comm_group (ring (has_nndist (finset linarith.comp))))) : archimedean (comm_group (ring (has_nndist (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_41780 (h0 : topological_space (dlist (has_ssubset (random_gen to_additive.value_type)))) : t0_space (dlist (has_ssubset (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_41781 (h0 : not (function.extfun Type topological_space -> false)) : @normal_space.{0} (random_gen.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (random_gen.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_41782 (h0 : not (complete_lattice (has_lt to_additive.value_type) -> false)) : @is_compactly_generated.{0} (has_lt.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_lt.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_41783 (h0 : functor.add_const (uniform_space (has_to_string pos)) name) : @complete_space.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_to_string.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_41784 (h0 : filter (measurable_space.dynkin_system empty)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_41785 (h0 : topological_space (boolean_algebra (has_neg (has_Inf pos)))) : sequential_space (boolean_algebra (has_neg (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_41786 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (dlist.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (dlist.{0} empty))  := sorry --non-trivial
lemma new_lemma_41787 (h0 : functor.add_const (topological_space (ring unsigned)) name) : @preconnected_space.{0} (ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_41788 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_edist.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_edist.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_41789 (h0 : topological_space (semiring (semiring num))) : t0_space (semiring (semiring num)) := sorry --non-trivial
lemma new_lemma_41790 (h2 : topological_space (topological_space char)) : totally_disconnected_space (topological_space char) := sorry --non-trivial
lemma new_lemma_41791 (h0 : monoid (has_zero (has_add pos))) : monoid.fg (has_zero (has_add pos)) := sorry --non-trivial
lemma new_lemma_41792 (h0 : topological_space (has_nndist (pseudo_metric_space pos))) : sequential_space (has_nndist (pseudo_metric_space pos)) := sorry --non-trivial
lemma new_lemma_41793 (h0 : group (has_to_string (ordered_ring (has_add Type)))) : is_cyclic (has_to_string (ordered_ring (has_add Type))) := sorry --non-trivial
lemma new_lemma_41794 (h0 : functor.add_const (ring (ordered_ring empty)) num) : @strong_rank_condition.{0} (ordered_ring.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (ordered_ring.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_41795 (h0 : topological_space (has_top congr_arg_kind)) : discrete_topology (has_top congr_arg_kind) := sorry --non-trivial
lemma new_lemma_41796 (h0 : complete_lattice (id num)) : is_atomistic (id num) := sorry --non-trivial
lemma new_lemma_41797 (h0 : function.extfun Type ring) : @is_domain.{0} (normed_group.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} h0 (normed_group.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_41798 (h0 : functor.add_const (function.extfun Type complete_lattice) name) : @is_compactly_generated.{0} (has_to_string.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) name h0) (has_to_string.{0} name))  := sorry --non-trivial
lemma new_lemma_41799 (h0 : not (uniform_space empty -> false)) : complete_space empty := sorry --non-trivial
lemma new_lemma_41800 (h0 : option (topological_space linarith.comp_source)) (h1 : function.extfun bool coe_sort) : @totally_disconnected_space.{0} linarith.comp_source (@option.get.{0} (topological_space.{0} linarith.comp_source) h0 (@function.extfun_app.{1 0} bool (@coe_sort.{1 1} bool Prop coe_sort_bool) h1 (@option.is_some.{0} (topological_space.{0} linarith.comp_source) h0)))  := sorry --non-trivial
lemma new_lemma_41801 (h0 : topological_space (ring (finset (finset pos)))) : regular_space (ring (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_41802 (h0 : group (mul_zero_class (finset (add_comm_monoid Type)))) : is_cyclic (mul_zero_class (finset (add_comm_monoid Type))) := sorry --non-trivial
lemma new_lemma_41803 (h0 : semiring (with_bot num)) : is_noetherian_ring (with_bot num) := sorry --non-trivial
lemma new_lemma_41804 (h0 : ring (ordered_cancel_add_comm_monoid (option ennreal))) : is_principal_ideal_ring (ordered_cancel_add_comm_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_41805 (h0 : complete_lattice (has_inter (option ennreal))) : is_atomistic (has_inter (option ennreal)) := sorry --non-trivial
lemma new_lemma_41806 (h0 : filter (has_neg_part (has_add (option environment.implicit_infer_kind)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_41807 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_Sup.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_Sup.{0} empty))  := sorry --non-trivial
lemma new_lemma_41808 (h0 : functor.add_const (add_group (complete_semilattice_Sup linarith.comp)) congr_arg_kind) : @is_add_cyclic.{0} (complete_semilattice_Sup.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_group.{0} (complete_semilattice_Sup.{0} linarith.comp)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_41809 (h0 : functor.add_const (add_group (simple_graph linarith.comp)) pos) : @is_add_cyclic.{0} (simple_graph.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_group.{0} (simple_graph.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_41810 (h0 : function.extfun Type ring) : @is_domain.{0} (canonically_linear_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type ring.{0} h0 (canonically_linear_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_41811 (h0 : functor.add_const (semiring (partial_order empty)) empty) : @is_noetherian_ring.{0} (partial_order.{0} empty) (@functor.add_const.run.{0 0} (semiring.{0} (partial_order.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_41812 (h0 : not (has_mem.mem (has_norm num) has_emptyc.emptyc -> false)) : @is_atomistic.{0} (has_norm.{0} num) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (has_norm.{0} num) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_norm.{0} num) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_41813 (h0 : functor.add_const (topological_space (ordered_comm_ring real)) real) : @normal_space.{0} (ordered_comm_ring.{0} real) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} real)) real h0)  := sorry --non-trivial
lemma new_lemma_41814 (h1 : not (ring to_additive.value_type -> false)) : @is_domain.{0} to_additive.value_type (@classical.by_contradiction'.{1} (ring.{0} to_additive.value_type) h1)  := sorry --non-trivial
lemma new_lemma_41815 (h0 : functor.add_const (finset (generalized_boolean_algebra name)) Type) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_41816 (h0 : prod (canonically_ordered_comm_semiring congr_arg_kind) (canonically_ordered_comm_semiring congr_arg_kind)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_41817 (h1 : not (topological_space (has_append linarith.comp_source) -> false)) : @t0_space.{0} (has_append.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (has_append.{0} linarith.comp_source)) h1)  := sorry --non-trivial
lemma new_lemma_41818 (h0 : topological_space (ordered_comm_ring (has_neg (add_comm_monoid name)))) : loc_path_connected_space (ordered_comm_ring (has_neg (add_comm_monoid name))) := sorry --non-trivial
lemma new_lemma_41819 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_41820 (h0 : topological_space linarith.comp_source) : t0_space linarith.comp_source := sorry --non-trivial
lemma new_lemma_41821 (h0 : ring (mul_one_class enat)) : is_domain (mul_one_class enat) := sorry --non-trivial
lemma new_lemma_41822 (h0 : ring (complete_distrib_lattice linarith.comp)) : is_principal_ideal_ring (complete_distrib_lattice linarith.comp) := sorry --non-trivial
lemma new_lemma_41823 (h0 : add_monoid (add_right_cancel_monoid (has_top empty))) : add_monoid.fg (add_right_cancel_monoid (has_top empty)) := sorry --non-trivial
lemma new_lemma_41824 (h0 : complete_lattice (left_cancel_monoid (semiring (semiring (semiring empty))))) : complete_lattice.is_Sup_finite_compact (left_cancel_monoid (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_41825 (h0 : topological_space (has_ssubset char)) (h1 : add_group (has_ssubset char)) : topological_add_group (has_ssubset char) := sorry --non-trivial
lemma new_lemma_41826 (h0 : filter (has_union (semiring unsigned))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_41827 (h0 : function.extfun Type group) : @is_cyclic.{0} (is_R_or_C.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (is_R_or_C.{0} empty))  := sorry --non-trivial
lemma new_lemma_41828 (h0 : topological_space (complete_distrib_lattice (ring (has_add Type)))) : totally_separated_space (complete_distrib_lattice (ring (has_add Type))) := sorry --non-trivial
lemma new_lemma_41829 (h0 : list (complete_semilattice_Sup (has_ssubset (has_ssubset (has_ssubset linarith.ineq))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_41830 (h0 : group (sub_neg_monoid pos)) : group.fg (sub_neg_monoid pos) := sorry --non-trivial
lemma new_lemma_41831 (h0 : has_norm (with_bot congr_arg_kind) -> has_norm (with_bot congr_arg_kind) -> bool) : is_dec_refl h0 := sorry --non-trivial
lemma new_lemma_41832 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (has_edist.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_edist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_41833 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (sub_neg_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (sub_neg_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_41834 (h0 : functor.add_const (topological_space (has_bot name)) (has_add (has_add Type))) : @preconnected_space.{0} (has_bot.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (has_bot.{0} name)) (has_add.{1} (has_add.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_41835 (h0 : ordered_comm_monoid (cancel_monoid (boolean_algebra (ring name)))) : has_exists_mul_of_le (cancel_monoid (boolean_algebra (ring name))) := sorry --non-trivial
lemma new_lemma_41836 (h0 : topological_space (complete_semilattice_Sup (semiring empty))) : discrete_topology (complete_semilattice_Sup (semiring empty)) := sorry --non-trivial
lemma new_lemma_41837 (h0 : group (has_one (semiring (semiring unsigned)))) : group.fg (has_one (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_41838 (h0 : not (ring empty -> false)) : @is_domain.{0} empty (@classical.by_contradiction'.{1} (ring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_41839 (h0 : complete_lattice (boolean_algebra (has_add pos))) : complete_lattice.is_Sup_finite_compact (boolean_algebra (has_add pos)) := sorry --non-trivial
lemma new_lemma_41840 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (ring.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_41841 (h0 : list (distrib_lattice (has_ssubset (has_ssubset (has_ssubset fun_info))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_41842 (h0 : ring (with_bot num)) : is_principal_ideal_ring (with_bot num) := sorry --non-trivial
lemma new_lemma_41843 (h2 : ring (has_add fun_info)) : rank_condition (has_add fun_info) := sorry --non-trivial
lemma new_lemma_41844 (h0 : topological_space (add_semigroup unsigned)) : loc_path_connected_space (add_semigroup unsigned) := sorry --non-trivial
lemma new_lemma_41845 (h0 : not (function.extfun (Type 1) complete_lattice -> false)) : @is_atomistic.{1} (plift.{1} num) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@classical.by_contradiction'.{3} (function.extfun.{3 2} (Type 1) complete_lattice.{1}) h0) (plift.{1} num))  := sorry --non-trivial
lemma new_lemma_41846 (h0 : topological_space (has_lt (mul_one_class linarith.ineq))) (h1 : preorder (has_lt (mul_one_class linarith.ineq))) : order_topology (has_lt (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_41847 (h0 : set (set linarith.ineq)) : is_countably_spanning h0 := sorry --non-trivial
lemma new_lemma_41848 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (has_top.{0} num) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_top.{0} num))  := sorry --non-trivial
lemma new_lemma_41849 (h0 : functor.add_const (topological_space (has_add environment.implicit_infer_kind)) linarith.comp) : @path_connected_space.{0} (has_add.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_41850 (h0 : uniform_space (has_ssubset (random_gen (random_gen reducibility_hints)))) : complete_space (has_ssubset (random_gen (random_gen reducibility_hints))) := sorry --non-trivial
lemma new_lemma_41851 (h0 : function.extfun nat fin) : @is_simple_group.{0} (has_pos_part.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type group.{0}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (has_pos_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_41852 (h0 : function.extfun nat fin) : @path_connected_space.{1} (canonically_linear_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (canonically_linear_ordered_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_41853 (h0 : complete_lattice (normed_comm_ring (mul_zero_class (mul_zero_class pos)))) : complete_lattice.is_Sup_finite_compact (normed_comm_ring (mul_zero_class (mul_zero_class pos))) := sorry --non-trivial
lemma new_lemma_41854 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (generalized_boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (generalized_boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_41855 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_compactly_generated.{0} fun_info (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) fun_info)  := sorry --non-trivial
lemma new_lemma_41856 (h0 : functor.add_const (ring (semigroup Type)) name) : @rank_condition.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (semigroup.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_41857 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_41858 (h0 : complete_lattice (has_nndist (boolean_algebra (has_neg (has_zero name))))) : is_compactly_generated (has_nndist (boolean_algebra (has_neg (has_zero name)))) := sorry --non-trivial
lemma new_lemma_41859 (h0 : functor.add_const (finset (canonically_ordered_comm_semiring environment.implicit_infer_kind)) linarith.comp) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_41860 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (add_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (add_cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_41861 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (group_with_zero.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (group_with_zero.{0} num))  := sorry --non-trivial
lemma new_lemma_41862 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (filter.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (filter.{0} empty))  := sorry --non-trivial
lemma new_lemma_41863 (h0 : group (has_one (semiring unsigned))) : normalizer_condition (has_one (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_41864 (h0 : functor.add_const (add_group (semigroup pos)) (has_add name)) : @is_add_cyclic.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (semigroup.{0} pos)) (has_add.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_41865 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (finset name)) := sorry --non-trivial
lemma new_lemma_41866 (h0 : function.extfun Type (functor.add_const (finset (semigroup empty)))) : finset.nonempty (functor.add_const.run (function.extfun_app h0 (option empty))) := sorry --non-trivial
lemma new_lemma_41867 (h1 : group (has_nnnorm (non_unital_non_assoc_semiring reducibility_hints))) : is_cyclic (has_nnnorm (non_unital_non_assoc_semiring reducibility_hints)) := sorry --non-trivial
lemma new_lemma_41868 (h0 : not (group (has_compl char) -> false)) : @group.fg.{0} (has_compl.{0} char) (@classical.by_contradiction'.{1} (group.{0} (has_compl.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_41869 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} (add_cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) (add_cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_41870 (h0 : group (has_sub unsigned)) : normalizer_condition (has_sub unsigned) := sorry --non-trivial
lemma new_lemma_41871 (h2 : has_mem.mem (id linarith.comp_source) has_zero.zero) : @complete_space.{0} (@id.{2} Type linarith.comp_source) (@multiset.pi.empty.{1 0} Type uniform_space.{0} (@id.{2} Type linarith.comp_source) h2)  := sorry --non-trivial
lemma new_lemma_41872 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (canonically_linear_ordered_monoid.{0} num) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (canonically_linear_ordered_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_41873 (h0 : not (function.extfun Type list -> false)) : list.nodup (function.extfun_app (classical.by_contradiction' h0) (distrib_lattice fun_info)) := sorry --non-trivial
lemma new_lemma_41874 (h1 : group (complete_semilattice_Sup congr_arg_kind)) : group.fg (complete_semilattice_Sup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_41875 (h0 : has_mem.mem (with_bot fun_info) has_emptyc.emptyc) : @discrete_topology.{0} (with_bot.{0} fun_info) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_bot.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_41876 (h0 : add_monoid (mul_zero_class (finset Type))) : add_monoid.fg (mul_zero_class (finset Type)) := sorry --non-trivial
lemma new_lemma_41877 (h0 : finset (has_add linarith.comp)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_41878 (h0 : function.extfun nat fin) : @loc_path_connected_space.{0} (has_pos_part.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (has_pos_part.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_41879 (h0 : monoid (complete_distrib_lattice (has_neg_part environment.implicit_infer_kind))) : monoid.fg (complete_distrib_lattice (has_neg_part environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_41880 (h0 : functor.add_const (topological_space (has_Sup empty)) congr_arg_kind) : @t0_space.{0} (has_Sup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Sup.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_41881 (h0 : topological_space (semigroup (has_neg_part (comm_group unsigned)))) : irreducible_space (semigroup (has_neg_part (comm_group unsigned))) := sorry --non-trivial
lemma new_lemma_41882 (h0 : functor.add_const (topological_space (ring linarith.comp)) Type) : @t0_space.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (ring.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_41883 (h0 : ring (add_left_cancel_monoid (has_ssubset to_additive.value_type))) : is_domain (add_left_cancel_monoid (has_ssubset to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_41884 (h0 : topological_space (normed_lattice_add_comm_group (has_add pos))) : discrete_topology (normed_lattice_add_comm_group (has_add pos)) := sorry --non-trivial
lemma new_lemma_41885 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (has_top.{0} string_imp) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (has_top.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_41886 (h0 : group (pseudo_metric_space ennreal)) : normalizer_condition (pseudo_metric_space ennreal) := sorry --non-trivial
lemma new_lemma_41887 (h0 : functor.add_const (group (preorder num)) num) : @group.fg.{0} (preorder.{0} num) (@functor.add_const.run.{0 0} (group.{0} (preorder.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_41888 (h1 : ring (add_comm_semigroup (add_comm_semigroup char))) : rank_condition (add_comm_semigroup (add_comm_semigroup char)) := sorry --non-trivial
lemma new_lemma_41889 (h0 : add_group (random_gen (has_nnnorm (distrib fun_info)))) : is_add_cyclic (random_gen (has_nnnorm (distrib fun_info))) := sorry --non-trivial
lemma new_lemma_41890 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (add_group.{0} unsigned) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (add_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_41891 (h0 : function.extfun (Type 1) ordered_comm_monoid) : @has_exists_mul_of_le.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_comm_monoid.{1} h0 (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_41892 (h0 : functor.add_const (group (ring Type)) Type) : @normalizer_condition.{1} (ring.{1} Type) (@functor.add_const.run.{1 1} (group.{1} (ring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_41893 (h0 : functor.add_const (topological_space (sub_neg_monoid pos)) linarith.comp) : @path_connected_space.{0} (sub_neg_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (sub_neg_monoid.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_41894 (h0 : group (has_norm unsigned)) : normalizer_condition (has_norm unsigned) := sorry --non-trivial
lemma new_lemma_41895 (h0 : topological_space (left_cancel_monoid empty)) : path_connected_space (left_cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_41896 (h0 : ring (non_assoc_semiring (comm_monoid (comm_monoid unsigned)))) : strong_rank_condition (non_assoc_semiring (comm_monoid (comm_monoid unsigned))) := sorry --non-trivial
lemma new_lemma_41897 (h1 : ring (mul_one_class (mul_one_class char))) : strong_rank_condition (mul_one_class (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_41898 (h0 : semiring (has_zero (has_nndist name))) : is_noetherian_ring (has_zero (has_nndist name)) := sorry --non-trivial
lemma new_lemma_41899 (h0 : group (add_semigroup unsigned)) : normalizer_condition (add_semigroup unsigned) := sorry --non-trivial
lemma new_lemma_41900 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (boolean_algebra.core.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.core.{0} name))  := sorry --non-trivial
lemma new_lemma_41901 (h0 : semiring (cancel_monoid (option unsigned))) : is_noetherian_ring (cancel_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_41902 (h0 : add_monoid (left_cancel_monoid num)) : add_monoid.fg (left_cancel_monoid num) := sorry --non-trivial
lemma new_lemma_41903 (h0 : complete_lattice (left_cancel_semigroup (semiring (semiring (semiring num))))) : complete_lattice.is_Sup_finite_compact (left_cancel_semigroup (semiring (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_41904 (h0 : functor.add_const (topological_space (normed_comm_ring unsigned)) name) : @t0_space.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_41905 (h0 : not (semiring (measure_theory.measure_space empty) -> false)) : @is_noetherian_ring.{0} (measure_theory.measure_space.{0} empty) (@classical.by_contradiction'.{1} (semiring.{0} (measure_theory.measure_space.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_41906 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} (has_union.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (has_union.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_41907 (h0 : monoid (has_neg (has_Inf (has_Inf linarith.comp)))) : monoid.fg (has_neg (has_Inf (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_41908 (h0 : not (group (with_one empty) -> false)) : @is_cyclic.{0} (with_one.{0} empty) (@classical.by_contradiction'.{1} (group.{0} (with_one.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_41909 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_41910 (h0 : list (normed_lattice_add_comm_group real)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_41911 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (has_star.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} h0 (has_star.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_41912 (h0 : not (topological_space (linear_ordered_comm_ring unsigned) -> false)) : @discrete_topology.{0} (linear_ordered_comm_ring.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_comm_ring.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_41913 (h0 : functor.add_const (topological_space (has_nndist Type)) environment.implicit_infer_kind) : @t0_space.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_nndist.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_41914 (h0 : topological_space (id num)) : loc_path_connected_space (id num) := sorry --non-trivial
lemma new_lemma_41915 (h0 : functor.add_const (ring (has_pos_part Type)) Type) : @rank_condition.{1} (has_pos_part.{1} Type) (@functor.add_const.run.{1 1} (ring.{1} (has_pos_part.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_41916 (h2 : function.extfun Type uniform_space) : @complete_space.{0} (measurable_space.{0} string_imp) (@function.extfun_app.{2 1} Type uniform_space.{0} h2 (measurable_space.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_41917 (h0 : group (add_comm_monoid (semigroup environment.implicit_infer_kind))) : normalizer_condition (add_comm_monoid (semigroup environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_41918 (h0 : group (has_neg (finset Type))) : is_cyclic (has_neg (finset Type)) := sorry --non-trivial
lemma new_lemma_41919 (h0 : functor.add_const (functor.add_const Prop (has_to_string linarith.comp)) (has_neg pos)) : functor.add_const.run (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_41920 (h0 : ring (free_add_monoid num)) : strong_rank_condition (free_add_monoid num) := sorry --non-trivial
lemma new_lemma_41921 (h0 : functor.add_const (topological_space (boolean_algebra linarith.comp)) linarith.comp) : @topological_space.separable_space.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_41922 (h0 : function.extfun Type topological_space) : @normal_space.{0} (monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_41923 (h0 : functor.add_const (topological_space (ring name)) linarith.comp) : @normal_space.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_41924 (h1 : ring (random_gen (has_ssubset fun_info))) : rank_condition (random_gen (has_ssubset fun_info)) := sorry --non-trivial
lemma new_lemma_41925 (h0 : topological_space (linear_ordered_comm_group_with_zero to_additive.value_type)) (h1 : add_group (linear_ordered_comm_group_with_zero to_additive.value_type)) : topological_add_group (linear_ordered_comm_group_with_zero to_additive.value_type) := sorry --non-trivial
lemma new_lemma_41926 (h0 : topological_space (denumerable string.iterator_imp)) : totally_disconnected_space (denumerable string.iterator_imp) := sorry --non-trivial
lemma new_lemma_41927 (h0 : ordered_add_comm_monoid (ordered_ring congr_arg_kind)) : archimedean (ordered_ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_41928 (h0 : topological_space (random_gen (has_inv to_additive.value_type))) : locally_compact_space (random_gen (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_41929 (h0 : ring (has_dist char)) : rank_condition (has_dist char) := sorry --non-trivial
lemma new_lemma_41930 (h0 : list (add_cancel_monoid (has_Inf (has_Inf Type)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_41931 (h0 : functor.add_const (monoid (add_comm_monoid name)) name) : @monoid.fg.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (monoid.{0} (add_comm_monoid.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_41932 (h0 : topological_space (left_cancel_monoid (semiring congr_arg_kind))) : path_connected_space (left_cancel_monoid (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_41933 (h0 : ring (linear_ordered_semiring (random_gen congr_arg_kind))) : is_domain (linear_ordered_semiring (random_gen congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_41934 (h0 : topological_space (boolean_algebra (has_add linarith.comp))) : t1_space (boolean_algebra (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_41935 (h0 : ring (has_to_string (option ennreal))) : strong_rank_condition (has_to_string (option ennreal)) := sorry --non-trivial
lemma new_lemma_41936 (h0 : ordered_add_comm_monoid (add_cancel_monoid (semigroup Type))) : archimedean (add_cancel_monoid (semigroup Type)) := sorry --non-trivial
lemma new_lemma_41937 (h1 : ring (add_monoid (has_nnnorm char))) : rank_condition (add_monoid (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_41938 (h0 : add_monoid (has_union (left_cancel_semigroup (left_cancel_semigroup num)))) (h1 : has_one (has_union (left_cancel_semigroup (left_cancel_semigroup num)))) : char_zero (has_union (left_cancel_semigroup (left_cancel_semigroup num))) := sorry --non-trivial
lemma new_lemma_41939 (h0 : linarith.comp_source -> linarith.comp_source -> Prop) (h1 : function.extfun linarith.comp_source (fun (x : linarith.comp_source), Prop)) : is_antichain h0 (function.extfun_app h1) := sorry --non-trivial
lemma new_lemma_41940 (h0 : not (topological_space (semiring to_additive.value_type) -> false)) : @irreducible_space.{0} (semiring.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (semiring.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_41941 (h0 : functor.add_const (topological_space (boolean_algebra unsigned)) pos) : @irreducible_space.{0} (boolean_algebra.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_41942 (h0 : monoid (has_Inf (has_add pos))) : monoid.fg (has_Inf (has_add pos)) := sorry --non-trivial
lemma new_lemma_41943 (h0 : ring (linear_order (option (option empty)))) : strong_rank_condition (linear_order (option (option empty))) := sorry --non-trivial
lemma new_lemma_41944 (h0 : group (canonically_ordered_comm_semiring congr_arg_kind)) : group.fg (canonically_ordered_comm_semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_41945 (h0 : functor.add_const (uniform_space (add_cancel_monoid environment.implicit_infer_kind)) name) : @separated_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (uniform_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_41946 (h0 : complete_lattice (complete_semilattice_Sup fun_info)) : is_atomistic (complete_semilattice_Sup fun_info) := sorry --non-trivial
lemma new_lemma_41947 : nonempty ereal := sorry --simp
lemma new_lemma_41948 (h0 : functor.add_const (group (complete_distrib_lattice empty)) empty) : @normalizer_condition.{0} (complete_distrib_lattice.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (complete_distrib_lattice.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_41949 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (has_star.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} h0 (has_star.{0} empty))  := sorry --non-trivial
lemma new_lemma_41950 (h0 : functor.add_const (ordered_add_comm_monoid (has_neg linarith.comp)) (has_to_string (has_neg_part Type))) : @archimedean.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 1} (ordered_add_comm_monoid.{0} (has_neg.{0} linarith.comp)) (has_to_string.{1} (has_neg_part.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_41951 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (simple_graph.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (simple_graph.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_41952 (h0 : topological_space (has_add (ring Type))) : topological_space.separable_space (has_add (ring Type)) := sorry --non-trivial
lemma new_lemma_41953 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (with_bot.{0} linarith.ineq) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (with_bot.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_41954 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_bot.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_bot.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_41955 (h0 : list (id (random_gen string_imp))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_41956 (h0 : ring (has_edist (semiring num))) : is_domain (has_edist (semiring num)) := sorry --non-trivial
lemma new_lemma_41957 (h0 : complete_lattice (with_one (has_norm (has_norm (has_norm (has_norm linarith.ineq)))))) : is_compactly_generated (with_one (has_norm (has_norm (has_norm (has_norm linarith.ineq))))) := sorry --non-trivial
lemma new_lemma_41958 (h1 : complete_lattice (nondiscrete_normed_field std_gen)) : complete_lattice.is_Sup_finite_compact (nondiscrete_normed_field std_gen) := sorry --non-trivial
lemma new_lemma_41959 (h0 : monoid (has_bot real)) : monoid.fg (has_bot real) := sorry --non-trivial
lemma new_lemma_41960 (h0 : has_mem.mem (with_bot empty) has_emptyc.emptyc) : @add_monoid.fg.{0} (with_bot.{0} empty) (@finset.pi.empty.{1 0} Type add_monoid.{0} (with_bot.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_41961 (h0 : functor.add_const (topological_space (cancel_monoid unsigned)) pos) : @t0_space.{0} (cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_41962 (h0 : topological_space (ordered_comm_monoid (has_Inf Type))) : sequential_space (ordered_comm_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_41963 (h0 : functor.add_const (add_group (has_neg Type)) (boolean_algebra pos)) : @is_add_cyclic.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (add_group.{1} (has_neg.{1} Type)) (boolean_algebra.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_41964 (h0 : list (has_Inf (has_Inf name))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_41965 (h0 : add_group (has_to_string (has_add Type))) : is_add_cyclic (has_to_string (has_add Type)) := sorry --non-trivial
lemma new_lemma_41966 (h0 : topological_space (canonically_ordered_add_monoid (option (option (option congr_arg_kind))))) : t1_space (canonically_ordered_add_monoid (option (option (option congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_41967 (h0 : complete_lattice (filter congr_arg_kind)) : is_atomistic (filter congr_arg_kind) := sorry --non-trivial
lemma new_lemma_41968 (h0 : functor.add_const (group (has_pos_part pos)) Type) : @is_cyclic.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (has_pos_part.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_41969 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (ordered_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (ordered_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_41970 (h0 : topological_space (has_to_string (finset linarith.comp))) : locally_compact_space (has_to_string (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_41971 (h0 : topological_space (add_cancel_monoid (option empty))) : totally_disconnected_space (add_cancel_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_41972 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (comm_semigroup.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (comm_semigroup.{0} real))  := sorry --non-trivial
lemma new_lemma_41973 (h0 : functor.add_const (monoid (has_Inf pos)) name) : @monoid.fg.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (monoid.{0} (has_Inf.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_41974 (h0 : topological_space (semiring (semiring linarith.comp))) : normal_space (semiring (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_41975 (h0 : add_group (linear_ordered_comm_ring (semiring num))) : is_add_cyclic (linear_ordered_comm_ring (semiring num)) := sorry --non-trivial
lemma new_lemma_41976 (h0 : topological_space (boolean_algebra (add_comm_monoid unsigned))) : t0_space (boolean_algebra (add_comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_41977 (h0 : functor.add_const (ring (add_cancel_monoid empty)) empty) : @rank_condition.{0} (add_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (add_cancel_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_41978 (h1 : topological_space (has_div string.iterator_imp)) : totally_disconnected_space (has_div string.iterator_imp) := sorry --non-trivial
lemma new_lemma_41979 (h0 : complete_lattice (add_left_cancel_monoid (has_nnnorm char))) : complete_lattice.is_Sup_finite_compact (add_left_cancel_monoid (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_41980 (h0 : not (function.extfun Type uniform_space -> false)) : @separated_space.{0} (measurable_space.{0} linarith.ineq) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (measurable_space.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_41981 (h0 : topological_space (add_comm_monoid (has_Inf Type))) : totally_separated_space (add_comm_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_41982 (h0 : topological_space (add_cancel_monoid (finset (finset name)))) : t0_space (add_cancel_monoid (finset (finset name))) := sorry --non-trivial
lemma new_lemma_41983 (h0 : ring (bin_tree (semiring (semiring num)))) : is_principal_ideal_ring (bin_tree (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_41984 (h0 : fin has_zero.zero) : @discrete_topology.{0} (has_add.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (has_add.{0} pos)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_41985 (h0 : functor.add_const (add_group (has_pos_part Type)) Type) : @is_add_cyclic.{1} (has_pos_part.{1} Type) (@functor.add_const.run.{1 1} (add_group.{1} (has_pos_part.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_41986 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (has_norm.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_norm.{0} num))  := sorry --non-trivial
lemma new_lemma_41987 (h0 : ring (semiring (semiring (semiring congr_arg_kind)))) : rank_condition (semiring (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_41988 (h0 : functor.add_const (cancel_comm_monoid_with_zero (mul_zero_class ennreal)) pos) : @unique_factorization_monoid.{0} (mul_zero_class.{0} ennreal) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (mul_zero_class.{0} ennreal)) pos h0)  := sorry --non-trivial
lemma new_lemma_41989 (h0 : topological_space (normed_linear_ordered_group unsigned)) : totally_separated_space (normed_linear_ordered_group unsigned) := sorry --non-trivial
lemma new_lemma_41990 (h0 : complete_lattice (has_dist (option unsigned))) : is_atomistic (has_dist (option unsigned)) := sorry --non-trivial
lemma new_lemma_41991 (h0 : functor.add_const (complete_lattice (cancel_monoid Type)) (comm_group ennreal)) : @is_atomistic.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (cancel_monoid.{1} Type)) (comm_group.{0} ennreal) h0)  := sorry --non-trivial
lemma new_lemma_41992 (h0 : ring (has_div (mul_one_class reducibility_hints))) : is_domain (has_div (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_41993 (h0 : generalized_boolean_algebra (has_pos_part name) -> generalized_boolean_algebra (has_pos_part name)) (h1 : function.extfun Type generalized_boolean_algebra) : function.periodic_pts h0 (function.extfun_app h1 (has_pos_part name)) := sorry --non-trivial
lemma new_lemma_41994 (h0 : functor.add_const (function.extfun Type topological_space) name) : @normal_space.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_41995 (h0 : ordered_comm_monoid (comm_group (has_add linarith.comp))) : has_exists_mul_of_le (comm_group (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_41996 (h0 : add_group (has_le reducibility_hints)) : is_add_cyclic (has_le reducibility_hints) := sorry --non-trivial
lemma new_lemma_41997 (h0 : ordered_comm_monoid (boolean_algebra (comm_group unsigned))) : has_exists_mul_of_le (boolean_algebra (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_41998 (h0 : not (uniform_space (normed_group fun_info) -> false)) : @complete_space.{0} (normed_group.{0} fun_info) (@classical.by_contradiction'.{1} (uniform_space.{0} (normed_group.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_41999 (h0 : list (encodable (random_gen string_imp))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_42000 (h0 : topological_space (normed_lattice_add_comm_group (has_Inf (has_Inf (has_Inf pos))))) : t1_space (normed_lattice_add_comm_group (has_Inf (has_Inf (has_Inf pos)))) := sorry --non-trivial
lemma new_lemma_42001 (h0 : topological_space (linear_ordered_semiring (has_norm (has_norm empty)))) : locally_compact_space (linear_ordered_semiring (has_norm (has_norm empty))) := sorry --non-trivial
lemma new_lemma_42002 (h0 : functor.add_const (topological_space (comm_group unsigned)) name) : @irreducible_space.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_42003 (h0 : group (encodable (random_gen fun_info))) : group.fg (encodable (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_42004 (h0 : topological_space (has_nndist (option congr_arg_kind))) : irreducible_space (has_nndist (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_42005 (h0 : topological_space (preorder (has_Inf real))) : discrete_topology (preorder (has_Inf real)) := sorry --non-trivial
lemma new_lemma_42006 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_nndist.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_nndist.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_42007 (h0 : ordered_add_comm_monoid (canonically_ordered_comm_semiring (option pos))) : archimedean (canonically_ordered_comm_semiring (option pos)) := sorry --non-trivial
lemma new_lemma_42008 (h0 : ring (normed_comm_ring congr_arg_kind)) : strong_rank_condition (normed_comm_ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_42009 (h0 : topological_space (has_nndist (finset ennreal))) : irreducible_space (has_nndist (finset ennreal)) := sorry --non-trivial
lemma new_lemma_42010 (h1 : not (function.extfun Type topological_space -> false)) : @discrete_topology.{0} (complete_semilattice_Sup.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h1) (complete_semilattice_Sup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_42011 (h0 h1 : list (group_with_zero char)) : list.is_infix h0 h1 := sorry --non-trivial
lemma new_lemma_42012 (h0 : group (has_norm (has_nnnorm (random_gen (has_nnnorm (has_nnnorm (random_gen linarith.ineq))))))) : group.fg (has_norm (has_nnnorm (random_gen (has_nnnorm (has_nnnorm (random_gen linarith.ineq)))))) := sorry --non-trivial
lemma new_lemma_42013 (h0 : topological_space (ring (option (option num)))) : totally_separated_space (ring (option (option num))) := sorry --non-trivial
lemma new_lemma_42014 (h0 : functor.add_const (filter (complete_distrib_lattice Type)) pos) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_42015 (h0 : ordered_add_comm_monoid (omega_complete_partial_order (has_bot empty))) : archimedean (omega_complete_partial_order (has_bot empty)) := sorry --non-trivial
lemma new_lemma_42016 (h0 : functor.add_const (function.extfun Type finset) name) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (generalized_boolean_algebra pos)) := sorry --non-trivial
lemma new_lemma_42017 (h0 : ring (distrib (has_nnnorm reducibility_hints))) : is_domain (distrib (has_nnnorm reducibility_hints)) := sorry --non-trivial
lemma new_lemma_42018 (h0 : function.extfun Type ring) : @rank_condition.{0} (linear_ordered_semiring.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_ordered_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_42019 (h0 : ring (has_neg (finset (finset linarith.comp)))) : rank_condition (has_neg (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_42020 (h0 : topological_space (boolean_algebra (mul_one_class linarith.comp))) : t0_space (boolean_algebra (mul_one_class linarith.comp)) := sorry --non-trivial
lemma new_lemma_42021 (h0 : add_monoid (has_inter pos)) : add_monoid.fg (has_inter pos) := sorry --non-trivial
lemma new_lemma_42022 (h0 : has_le (add_comm_semigroup (add_comm_semigroup linarith.ineq))) : no_bot_order (add_comm_semigroup (add_comm_semigroup linarith.ineq)) := sorry --non-trivial
lemma new_lemma_42023 (h0 : functor.add_const Prop (has_norm (has_norm num))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_42024 (h1 : topological_space (denumerable reducibility_hints)) : totally_disconnected_space (denumerable reducibility_hints) := sorry --non-trivial
lemma new_lemma_42025 (h0 : functor.add_const (finset (measurable_space.dynkin_system unsigned)) unsigned) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_42026 (h0 : ring (has_add (has_Inf (has_nndist (has_neg Type))))) : rank_condition (has_add (has_Inf (has_nndist (has_neg Type)))) := sorry --non-trivial
lemma new_lemma_42027 (h1 : ring (add_left_cancel_monoid fun_info)) : rank_condition (add_left_cancel_monoid fun_info) := sorry --non-trivial
lemma new_lemma_42028 (h0 : topological_space (add_cancel_comm_monoid (has_nnnorm (random_gen (has_nnnorm (mul_one_class char)))))) : t0_space (add_cancel_comm_monoid (has_nnnorm (random_gen (has_nnnorm (mul_one_class char))))) := sorry --non-trivial
lemma new_lemma_42029 (h0 : complete_lattice (option (semiring (semiring unsigned)))) : complete_lattice.is_Sup_finite_compact (option (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_42030 (h2 : ring (random_gen linarith.comp_source)) : rank_condition (random_gen linarith.comp_source) := sorry --non-trivial
lemma new_lemma_42031 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (complete_semilattice_Sup.{0} num) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (complete_semilattice_Sup.{0} num))  := sorry --non-trivial
lemma new_lemma_42032 (h2 : not (uniform_space (has_nnnorm to_additive.value_type) -> false)) : @complete_space.{0} (has_nnnorm.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_nnnorm.{0} to_additive.value_type)) h2)  := sorry --non-trivial
lemma new_lemma_42033 (h0 : group (semigroup congr_arg_kind)) : group.fg (semigroup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_42034 (h0 : topological_space (mul_zero_class (semiring num))) : t1_space (mul_zero_class (semiring num)) := sorry --non-trivial
lemma new_lemma_42035 (h0 : ordered_comm_monoid (ordered_comm_ring (finset (has_add linarith.comp)))) : has_exists_mul_of_le (ordered_comm_ring (finset (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_42036 (h0 : topological_space (comm_semigroup (has_add (has_bot pos)))) : preconnected_space (comm_semigroup (has_add (has_bot pos))) := sorry --non-trivial
lemma new_lemma_42037 (h0 : topological_space (semi_normed_comm_ring (linear_ordered_add_comm_monoid string_imp))) : t0_space (semi_normed_comm_ring (linear_ordered_add_comm_monoid string_imp)) := sorry --non-trivial
lemma new_lemma_42038 (h0 : topological_space (ordered_comm_group congr_arg_kind)) : loc_path_connected_space (ordered_comm_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_42039 (h0 : functor.add_const (topological_space (has_Inf Type)) (has_neg Type)) : @locally_compact_space.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_Inf.{1} Type)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_42040 (h0 : uniform_space (has_ssubset (mul_one_class fun_info))) : complete_space (has_ssubset (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_42041 (h0 : functor.add_const (function.extfun (Type 1) ring) (ring pos)) : @is_domain.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ring.{1}) (ring.{0} pos) h0) (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_42042 (h0 : functor.add_const (topological_space (has_Inf Type)) pos) : @sequential_space.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_Inf.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_42043 (h0 : functor.add_const (topological_space (has_zero linarith.comp)) Type) : @t1_space.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_zero.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_42044 (h0 : ordered_add_comm_monoid (linear_ordered_comm_ring congr_arg_kind)) : archimedean (linear_ordered_comm_ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_42045 (h0 : topological_space (random_gen num)) : discrete_topology (random_gen num) := sorry --non-trivial
lemma new_lemma_42046 (h0 : functor.add_const (topological_space (option unsigned)) empty) : @locally_compact_space.{0} (option.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_42047 (h0 : functor.comp topological_space comm_group Type) : @totally_disconnected_space.{1} (comm_group.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} comm_group.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_42048 (h0 : functor.add_const (filter (has_neg_part unsigned)) linarith.comp) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_42049 (h0 : topological_space (has_inv (random_gen linarith.comp_source))) : totally_disconnected_space (has_inv (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_42050 (h0 : ring (with_one (semiring unsigned))) : strong_rank_condition (with_one (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_42051 (h0 : topological_space (non_unital_non_assoc_semiring enat)) : t0_space (non_unital_non_assoc_semiring enat) := sorry --non-trivial
lemma new_lemma_42052 (h0 : not (group (id linarith.comp) -> false)) : @group.fg.{0} (@id.{2} Type linarith.comp) (@classical.by_contradiction'.{1} (group.{0} (@id.{2} Type linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_42053 (h0 : group (with_one (has_inv fun_info))) : normalizer_condition (with_one (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_42054 (h0 : group (topological_space (normed_field char))) : is_cyclic (topological_space (normed_field char)) := sorry --non-trivial
lemma new_lemma_42055 (h0 : not (semiring empty -> false)) : @is_noetherian_ring.{0} empty (@classical.by_contradiction'.{1} (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_42056 (h0 : topological_space (has_zero (comm_group (comm_group Type)))) : t0_space (has_zero (comm_group (comm_group Type))) := sorry --non-trivial
lemma new_lemma_42057 (h0 : complete_lattice (non_assoc_semiring num)) : complete_lattice.is_Sup_finite_compact (non_assoc_semiring num) := sorry --non-trivial
lemma new_lemma_42058 (h0 : functor.add_const (add_monoid (add_cancel_monoid name)) name) : @add_monoid.fg.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (add_monoid.{0} (add_cancel_monoid.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_42059 (h0 : semiring (finset pos)) : is_noetherian_ring (finset pos) := sorry --non-trivial
lemma new_lemma_42060 (h0 : functor.add_const (topological_space (semigroup linarith.comp)) pos) : @loc_path_connected_space.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_42061 (h0 : ring (ordered_ring (semiring empty))) : is_principal_ideal_ring (ordered_ring (semiring empty)) := sorry --non-trivial
lemma new_lemma_42062 (h0 : group (has_add (has_nndist (add_comm_monoid (finset environment.implicit_infer_kind))))) : is_cyclic (has_add (has_nndist (add_comm_monoid (finset environment.implicit_infer_kind)))) := sorry --non-trivial
lemma new_lemma_42063 (h0 : uniform_space (ordered_comm_ring (has_add (has_Inf pos)))) : separated_space (ordered_comm_ring (has_add (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_42064 (h0 h1 : std_gen -> std_gen -> std_gen) : left_distributive h0 h1 := sorry --non-trivial
lemma new_lemma_42065 (h0 : uniform_space (preorder (option (option (option (option (option empty))))))) : separated_space (preorder (option (option (option (option (option empty)))))) := sorry --non-trivial
lemma new_lemma_42066 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (ordered_ring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_42067 (h0 : functor.add_const (finset (boolean_algebra linarith.comp)) linarith.comp) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_42068 (h0 : functor.add_const (topological_space (has_neg_part Type)) Type) : @locally_compact_space.{1} (has_neg_part.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_neg_part.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_42069 (h0 : ring (simple_graph (finset (has_Inf (finset linarith.comp))))) : is_domain (simple_graph (finset (has_Inf (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_42070 (h0 : group (has_zero (boolean_algebra linarith.comp))) : normalizer_condition (has_zero (boolean_algebra linarith.comp)) := sorry --non-trivial
lemma new_lemma_42071 (h0 : functor.add_const (group (semigroup linarith.comp)) Type) : @is_simple_group.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 1} (group.{0} (semigroup.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_42072 (h0 : group (simple_graph (finset linarith.comp))) : is_simple_group (simple_graph (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_42073 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem group)) : @normalizer_condition.{0} fun_info (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) group.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) fun_info)  := sorry --non-trivial
lemma new_lemma_42074 (h0 : topological_space (ring (has_neg name))) : totally_separated_space (ring (has_neg name)) := sorry --non-trivial
lemma new_lemma_42075 (h0 : group (canonically_ordered_comm_semiring (has_add (finset name)))) : normalizer_condition (canonically_ordered_comm_semiring (has_add (finset name))) := sorry --non-trivial
lemma new_lemma_42076 (h0 : group (random_gen (random_gen to_additive.value_type))) : normalizer_condition (random_gen (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_42077 (h0 : set (fun_info -> semigroup char)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_42078 (h0 : functor.add_const (uniform_space (partial_order empty)) num) : @complete_space.{0} (partial_order.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (partial_order.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_42079 (h0 : ring (normed_group (semiring congr_arg_kind))) : is_principal_ideal_ring (normed_group (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_42080 (h0 : not (ring (has_neg fun_info) -> false)) : @is_domain.{0} (has_neg.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (has_neg.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_42081 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (has_nndist.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_nndist.{0} name))  := sorry --non-trivial
lemma new_lemma_42082 (h0 : group (add_cancel_monoid pos)) : normalizer_condition (add_cancel_monoid pos) := sorry --non-trivial
lemma new_lemma_42083 (h0 : group (has_top (random_gen (random_gen linarith.ineq)))) : is_cyclic (has_top (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_42084 (h0 : functor.add_const (function.extfun Type complete_lattice) Type) : @is_compactly_generated.{0} (has_zero.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type complete_lattice.{0}) Type h0) (has_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_42085 (h0 : ring (linear_ordered_field num)) : strong_rank_condition (linear_ordered_field num) := sorry --non-trivial
lemma new_lemma_42086 (h0 : add_group (ordered_cancel_add_comm_monoid name)) : is_add_cyclic (ordered_cancel_add_comm_monoid name) := sorry --non-trivial
lemma new_lemma_42087 (h0 : add_monoid (has_to_string (option ennreal))) : add_monoid.fg (has_to_string (option ennreal)) := sorry --non-trivial
lemma new_lemma_42088 (h0 : not (filter (measure_theory.measure_space congr_arg_kind) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_42089 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @sequential_space.{0} (has_pos_part.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_pos_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_42090 (h0 : functor.add_const (ring (bin_tree unsigned)) unsigned) : @is_domain.{0} (bin_tree.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (bin_tree.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_42091 (h0 : semiring (partial_order (semiring (semiring num)))) : is_noetherian_ring (partial_order (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_42092 (h0 : not (topological_space (has_ssubset (metric_space to_additive.value_type)) -> false)) : @t0_space.{0} (has_ssubset.{0} (metric_space.{0} to_additive.value_type)) (@classical.by_contradiction'.{1} (topological_space.{0} (has_ssubset.{0} (metric_space.{0} to_additive.value_type))) h0)  := sorry --non-trivial
lemma new_lemma_42093 (h0 : complete_lattice (comm_group (boolean_algebra.core (has_add name)))) : is_compactly_generated (comm_group (boolean_algebra.core (has_add name))) := sorry --non-trivial
lemma new_lemma_42094 (h0 : complete_lattice (distrib linarith.ineq)) : is_compactly_generated (distrib linarith.ineq) := sorry --non-trivial
lemma new_lemma_42095 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @path_connected_space.{0} (linear_ordered_semiring.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (linear_ordered_semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_42096 (h0 : complete_lattice (has_pos_part (has_pos_part pos))) : complete_lattice.is_Sup_finite_compact (has_pos_part (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_42097 (h0 : functor.add_const (complete_lattice (generalized_boolean_algebra pos)) pos) : @complete_lattice.is_Sup_finite_compact.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (generalized_boolean_algebra.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_42098 (h0 : complete_lattice (has_append (random_gen char))) : is_compactly_generated (has_append (random_gen char)) := sorry --non-trivial
lemma new_lemma_42099 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (linear_ordered_field.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (linear_ordered_field.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_42100 (h0 : group (has_add (has_to_string name))) : is_simple_group (has_add (has_to_string name)) := sorry --non-trivial
lemma new_lemma_42101 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_bot.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_bot.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_42102 (h0 : group (has_zero pos)) : normalizer_condition (has_zero pos) := sorry --non-trivial
lemma new_lemma_42103 (h0 : functor.add_const (group (finset name)) pos) : @normalizer_condition.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (group.{0} (finset.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_42104 (h1 : complete_lattice (fintype (has_nnnorm fun_info))) : complete_lattice.is_Sup_finite_compact (fintype (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_42105 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_add.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_add.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_42106 (h0 : topological_space (has_neg_part (comm_group pos))) : totally_separated_space (has_neg_part (comm_group pos)) := sorry --non-trivial
lemma new_lemma_42107 (h0 : topological_space (has_bot (has_add linarith.comp))) : totally_disconnected_space (has_bot (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_42108 (h0 : topological_space (has_add (sub_neg_monoid real))) : normal_space (has_add (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_42109 (h0 : topological_space (boolean_algebra.core (has_add (has_to_string Type)))) : regular_space (boolean_algebra.core (has_add (has_to_string Type))) := sorry --non-trivial
lemma new_lemma_42110 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_42111 (h0 : functor.add_const (topological_space (mul_one_class unsigned)) unsigned) : @locally_compact_space.{0} (mul_one_class.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_one_class.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_42112 (h0 : functor.add_const (monoid (has_to_string unsigned)) (has_neg (has_neg linarith.comp))) : @monoid.fg.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 0} (monoid.{0} (has_to_string.{0} unsigned)) (has_neg.{0} (has_neg.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_42113 (h0 : topological_space (finset (has_neg Type))) : totally_separated_space (finset (has_neg Type)) := sorry --non-trivial
lemma new_lemma_42114 (h0 : topological_space (canonically_linear_ordered_monoid Type)) : sequential_space (canonically_linear_ordered_monoid Type) := sorry --non-trivial
lemma new_lemma_42115 (h0 : not (topological_space (complete_linear_order num) -> false)) : @locally_compact_space.{0} (complete_linear_order.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (complete_linear_order.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_42116 (h0 : topological_space (has_ssubset (mul_one_class fun_info))) (h1 : add_group (has_ssubset (mul_one_class fun_info))) : topological_add_group (has_ssubset (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_42117 (h0 : monoid (semiring (has_top (has_norm linarith.comp_source)))) : monoid.fg (semiring (has_top (has_norm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_42118 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (ring string)) := sorry --non-trivial
lemma new_lemma_42119 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (measurable_space num)) := sorry --non-trivial
lemma new_lemma_42120 (h0 : semiring (semigroup (has_add pos))) : is_noetherian_ring (semigroup (has_add pos)) := sorry --non-trivial
lemma new_lemma_42121 (h0 : ring (uniform_space char)) : is_domain (uniform_space char) := sorry --non-trivial
lemma new_lemma_42122 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (boolean_algebra.core.{0} num) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (boolean_algebra.core.{0} num))  := sorry --non-trivial
lemma new_lemma_42123 (h0 : ring (with_one (has_nnnorm fun_info))) : strong_rank_condition (with_one (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_42124 (h0 : functor.add_const (function.extfun Type ring) (finset environment.implicit_infer_kind)) : @strong_rank_condition.{0} (normed_comm_ring.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) (finset.{0} environment.implicit_infer_kind) h0) (normed_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_42125 (h2 : topological_space (has_ssubset to_additive.value_type)) : totally_disconnected_space (has_ssubset to_additive.value_type) := sorry --non-trivial
lemma new_lemma_42126 (h0 : not (topological_space (option congr_arg_kind) -> false)) : @preirreducible_space.{0} (option.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (option.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_42127 (h0 : functor.add_const (topological_space (partial_order empty)) unsigned) : @irreducible_space.{0} (partial_order.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (partial_order.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_42128 (h0 : function.extfun Type ring) : @rank_condition.{0} (@id.{2} Type string_imp) (@function.extfun_app.{2 1} Type ring.{0} h0 (@id.{2} Type string_imp))  := sorry --non-trivial
lemma new_lemma_42129 (h0 : functor.add_const (fin has_zero.zero) real) : @complete_space.{1} (ordered_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (uniform_space.{1} (ordered_comm_monoid.{1} Type)) (@functor.add_const.run.{0 0} (fin (@has_zero.zero.{0} nat nat.has_zero)) real h0))  := sorry --non-trivial
lemma new_lemma_42130 (h0 : functor.add_const (complete_lattice (has_to_string name)) name) : @is_atomistic.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_to_string.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_42131 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (has_neg_part.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (has_neg_part.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_42132 (h0 : functor.add_const (function.extfun Type list) name) : list.nodup (function.extfun_app (functor.add_const.run h0) (simple_graph linarith.comp)) := sorry --non-trivial
lemma new_lemma_42133 (h0 : filter (mul_zero_class (add_comm_monoid Type))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_42134 (h0 : ring (pseudo_metric_space (option (option num)))) : rank_condition (pseudo_metric_space (option (option num))) := sorry --non-trivial
lemma new_lemma_42135 (h0 : functor.add_const (topological_space (has_star empty)) num) : @preirreducible_space.{0} (has_star.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_42136 (h0 : topological_space (with_bot (has_top linarith.ineq))) : irreducible_space (with_bot (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_42137 (h0 : complete_lattice (with_one (random_gen (with_bot string_imp)))) : is_atomistic (with_one (random_gen (with_bot string_imp))) := sorry --non-trivial
lemma new_lemma_42138 (h0 : topological_space (generalized_boolean_algebra (has_Inf name))) : normal_space (generalized_boolean_algebra (has_Inf name)) := sorry --non-trivial
lemma new_lemma_42139 (h0 : add_monoid (generalized_boolean_algebra (boolean_algebra.core Type))) : add_monoid.fg (generalized_boolean_algebra (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_42140 (h0 : add_group (semigroup (finset (has_nndist ennreal)))) : is_add_cyclic (semigroup (finset (has_nndist ennreal))) := sorry --non-trivial
lemma new_lemma_42141 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_42142 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (has_add.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_add.{0} num))  := sorry --non-trivial
lemma new_lemma_42143 (h0 : ring (option (has_to_string congr_arg_kind))) : is_domain (option (has_to_string congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_42144 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_bot.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_bot.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_42145 (h0 : uniform_space (has_emptyc (has_top num))) : separated_space (has_emptyc (has_top num)) := sorry --non-trivial
lemma new_lemma_42146 (h0 : list (semi_normed_comm_ring (has_ssubset linarith.comp_source))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_42147 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (dlist linarith.ineq)) := sorry --non-trivial
lemma new_lemma_42148 (h0 : add_group (has_dvd (has_nnnorm fun_info))) : is_add_cyclic (has_dvd (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_42149 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (add_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_42150 (h0 : Prop -> char) (h1 : coe_sort (set.range h0)) : set.range_splitting h0 h1 := sorry --non-trivial
lemma new_lemma_42151 (h0 : group (comm_group (boolean_algebra Type))) : is_simple_group (comm_group (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_42152 (h0 : topological_space (as_linear_order (option empty))) : discrete_topology (as_linear_order (option empty)) := sorry --non-trivial
lemma new_lemma_42153 (h0 : functor.add_const (topological_space (ring Type)) (ring Type)) : @regular_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (ring.{1} Type)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_42154 (h0 : functor.add_const (list (semigroup name)) linarith.comp) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_42155 (h0 : uniform_space (normed_group (has_top linarith.comp_source))) : complete_space (normed_group (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_42156 (h0 : ring (has_ssubset (has_ssubset linarith.ineq))) : strong_rank_condition (has_ssubset (has_ssubset linarith.ineq)) := sorry --non-trivial
lemma new_lemma_42157 (h0 : topological_space (add_cancel_monoid Type)) : t1_space (add_cancel_monoid Type) := sorry --non-trivial
lemma new_lemma_42158 (h0 : add_group (has_top (random_gen fun_info))) : is_add_cyclic (has_top (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_42159 (h0 : functor.add_const (topological_space (mul_zero_class num)) num) : @path_connected_space.{0} (mul_zero_class.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_42160 (h0 : monoid (has_to_string (has_add (has_neg_part pos)))) : monoid.fg (has_to_string (has_add (has_neg_part pos))) := sorry --non-trivial
lemma new_lemma_42161 (h0 : list (has_neg empty)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_42162 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (add_cancel_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (add_cancel_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_42163 (h0 : topological_space (ordered_comm_monoid (has_Inf pos))) : normal_space (ordered_comm_monoid (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_42164 (h0 : group (has_inv linarith.comp_source)) : group.fg (has_inv linarith.comp_source) := sorry --non-trivial
lemma new_lemma_42165 (h0 : topological_space (semigroup (has_to_string Type))) : preconnected_space (semigroup (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_42166 (h0 : functor.add_const (group (add_comm_monoid unsigned)) congr_arg_kind) : @is_simple_group.{0} (add_comm_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (add_comm_monoid.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_42167 (h0 : topological_space (has_Inf (ring (ring Type)))) : topological_space.separable_space (has_Inf (ring (ring Type))) := sorry --non-trivial
lemma new_lemma_42168 (h0 : topological_space (has_ssubset (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm linarith.ineq)))))) : t0_space (has_ssubset (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm linarith.ineq))))) := sorry --non-trivial
lemma new_lemma_42169 (h0 : functor.add_const (ordered_comm_monoid (boolean_algebra.core linarith.comp)) linarith.comp) : @has_exists_mul_of_le.{0} (boolean_algebra.core.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (boolean_algebra.core.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_42170 (h0 : topological_space (measure_theory.measure_space (semiring unsigned))) : totally_disconnected_space (measure_theory.measure_space (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_42171 (h0 : complete_lattice (option pos)) : is_compactly_generated (option pos) := sorry --non-trivial
lemma new_lemma_42172 (h0 : functor.add_const (function.extfun (Type 1) finset) linarith.comp) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (has_add Type)) := sorry --non-trivial
lemma new_lemma_42173 (h0 : ring (has_append (has_nnnorm to_additive.value_type))) : strong_rank_condition (has_append (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_42174 (h0 : topological_space (ring (has_Inf linarith.comp))) : totally_separated_space (ring (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_42175 (h0 : list (has_dist (option (option (option (option empty)))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_42176 (h0 : functor.add_const (functor.add_const (topological_space Type) pos) pos) : @t1_space.{1} Type (@functor.add_const.run.{1 0} (topological_space.{1} Type) pos (@functor.add_const.run.{1 0} (functor.add_const.{1 0} (topological_space.{1} Type) pos) pos h0))  := sorry --non-trivial
lemma new_lemma_42177 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (add_group.{0} num) (@function.extfun_app.{2 1} Type add_group.{0} h0 (add_group.{0} num))  := sorry --non-trivial
lemma new_lemma_42178 (h0 : ring (has_to_string (has_add (has_add (has_add pos))))) : is_principal_ideal_ring (has_to_string (has_add (has_add (has_add pos)))) := sorry --non-trivial
lemma new_lemma_42179 (h0 : ordered_add_comm_monoid (add_left_cancel_semigroup (semiring (semiring empty)))) : archimedean (add_left_cancel_semigroup (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_42180 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (normed_lattice_add_comm_group.{0} real) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (normed_lattice_add_comm_group.{0} real))  := sorry --non-trivial
lemma new_lemma_42181 (h0 : topological_space (left_cancel_semigroup (semiring (semiring unsigned)))) : discrete_topology (left_cancel_semigroup (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_42182 (h0 : functor.add_const (finset (mul_zero_class empty)) num) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_42183 (h0 : semiring (option (option (option unsigned)))) : is_noetherian_ring (option (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_42184 (h0 : add_group (canonically_linear_ordered_monoid (has_Inf Type))) : is_add_cyclic (canonically_linear_ordered_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_42185 (h0 : complete_lattice (finset (boolean_algebra (boolean_algebra (boolean_algebra name))))) : is_atomistic (finset (boolean_algebra (boolean_algebra (boolean_algebra name)))) := sorry --non-trivial
lemma new_lemma_42186 (h0 : has_mem.mem (has_union empty) has_emptyc.emptyc) : @complete_space.{0} (has_union.{0} empty) (@finset.pi.empty.{1 0} Type uniform_space.{0} (has_union.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_42187 (h0 : functor.add_const (function.extfun (Type 1) group) (has_add Type)) : @is_cyclic.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) group.{1}) (has_add.{1} Type) h0) (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_42188 (h0 : function.extfun (Type 1) group) : @is_cyclic.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} h0 (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_42189 (h0 : complete_lattice (boolean_algebra.core (option ennreal))) : is_compactly_generated (boolean_algebra.core (option ennreal)) := sorry --non-trivial
lemma new_lemma_42190 (h0 : functor.add_const (topological_space (has_zero linarith.comp)) environment.implicit_infer_kind) : @totally_separated_space.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_42191 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (normed_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_42192 (h0 : complete_lattice (distrib (has_compl fun_info))) : is_compactly_generated (distrib (has_compl fun_info)) := sorry --non-trivial
lemma new_lemma_42193 (h0 : not (add_group (complete_semilattice_Sup char) -> false)) : @is_add_cyclic.{0} (complete_semilattice_Sup.{0} char) (@classical.by_contradiction'.{1} (add_group.{0} (complete_semilattice_Sup.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_42194 (h0 : functor.add_const (complete_lattice (linear_ordered_cancel_comm_monoid empty)) empty) : @complete_lattice.is_Sup_finite_compact.{0} (linear_ordered_cancel_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (linear_ordered_cancel_comm_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_42195 (h0 : functor.add_const (topological_space (has_nndist linarith.comp)) linarith.comp) : @regular_space.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_42196 (h0 : topological_space (has_append (has_ssubset fun_info))) : path_connected_space (has_append (has_ssubset fun_info)) := sorry --non-trivial
lemma new_lemma_42197 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_42198 (h0 : filter (comm_monoid (semiring (semiring (semiring (semiring empty)))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_42199 (h0 : topological_space (comm_ring (comm_ring (comm_ring (comm_ring linarith.ineq))))) : t0_space (comm_ring (comm_ring (comm_ring (comm_ring linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_42200 (h0 : group (cancel_monoid (finset pos))) : is_simple_group (cancel_monoid (finset pos)) := sorry --non-trivial
lemma new_lemma_42201 (h0 : topological_space (ordered_comm_ring (has_pos_part Type))) : preconnected_space (ordered_comm_ring (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_42202 (h0 : monoid (measurable_space linarith.comp_source)) : monoid.fg (measurable_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_42203 (h0 : functor.add_const (function.extfun (Type 1) ordered_comm_monoid) pos) : @has_exists_mul_of_le.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_comm_monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ordered_comm_monoid.{1}) pos h0) (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_42204 (h0 : group (finset (ring Type))) : is_simple_group (finset (ring Type)) := sorry --non-trivial
lemma new_lemma_42205 (h0 : complete_lattice (has_zero (has_add (has_add pos)))) : is_atomistic (has_zero (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_42206 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (has_add.{0} (has_neg.{0} linarith.comp)) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_add.{0} (has_neg.{0} linarith.comp)))  := sorry --non-trivial
lemma new_lemma_42207 (h2 : complete_lattice (comm_ring to_additive.value_type)) : is_compactly_generated (comm_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_42208 (h0 : has_mem.mem (function.extfun Type) has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} (has_top.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@finset.pi.empty.{2 1} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) (function.extfun.{2 1} Type) h0) complete_lattice.{0}) (has_top.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_42209 (h0 : ring (normed_comm_ring (has_pos_part pos))) : is_domain (normed_comm_ring (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_42210 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (filter.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (filter.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_42211 (h0 : complete_lattice (has_Inf (finset pos))) : is_compactly_generated (has_Inf (finset pos)) := sorry --non-trivial
lemma new_lemma_42212 (h0 : not (topological_space (has_top linarith.comp_source) -> false)) : @t0_space.{0} (has_top.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (has_top.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_42213 (h0 : filter (normed_comm_ring (option pos))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_42214 (h0 : complete_lattice (random_gen (has_ssubset (has_ssubset reducibility_hints)))) : is_compactly_generated (random_gen (has_ssubset (has_ssubset reducibility_hints))) := sorry --non-trivial
lemma new_lemma_42215 (h0 : multiset (uniform_space (mul_one_class char))) (h1 : not (multiset (uniform_space (mul_one_class char)) -> false)) : multiset.disjoint h0 (classical.by_contradiction' h1) := sorry --non-trivial
lemma new_lemma_42216 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @normal_space.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_42217 (h0 : functor.add_const (topological_space Type) (ring pos)) : @loc_path_connected_space.{1} Type (@functor.add_const.run.{1 0} (topological_space.{1} Type) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_42218 (h0 : cancel_comm_monoid_with_zero (cancel_monoid (normed_comm_ring Type))) : unique_factorization_monoid (cancel_monoid (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_42219 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (preorder.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (preorder.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_42220 (h0 : uniform_space (normed_comm_ring (has_neg_part (has_neg_part (boolean_algebra Type))))) : complete_space (normed_comm_ring (has_neg_part (has_neg_part (boolean_algebra Type)))) := sorry --non-trivial
lemma new_lemma_42221 (h0 : topological_space (boolean_algebra (comm_group (comm_group Type)))) : t1_space (boolean_algebra (comm_group (comm_group Type))) := sorry --non-trivial
lemma new_lemma_42222 (h0 h1 : nat) (h3 : Prop) : scope_trace (id (fun (h2 : unit), h3)) := sorry --non-trivial
lemma new_lemma_42223 (h0 : monoid (add_comm_monoid name)) : monoid.fg (add_comm_monoid name) := sorry --non-trivial
lemma new_lemma_42224 (h0 : functor.add_const (ordered_add_comm_monoid (has_pos_part linarith.comp)) Type) : @archimedean.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 1} (ordered_add_comm_monoid.{0} (has_pos_part.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_42225 (h2 : topological_space (add_comm_semigroup ereal)) (h3 : preorder (add_comm_semigroup ereal)) : order_closed_topology (add_comm_semigroup ereal) := sorry --non-trivial
lemma new_lemma_42226 (h0 : topological_space num) : totally_disconnected_space num := sorry --non-trivial
lemma new_lemma_42227 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (@id.{2} Type unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (@id.{2} Type unsigned))  := sorry --non-trivial
lemma new_lemma_42228 (h1 : function.extfun Type group) : @is_cyclic.{0} (with_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h1 (with_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_42229 (h0 : list (boolean_algebra.core pos)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_42230 (h0 : linear_ordered_add_comm_group fun_info -> linear_ordered_add_comm_group fun_info -> bool) : is_dec_refl h0 := sorry --non-trivial
lemma new_lemma_42231 (h0 : function.extfun Type (functor.add_const (topological_space (semiring empty)))) : @totally_disconnected_space.{0} (semiring.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (semiring.{0} empty)) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (semiring.{0} empty))) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_42232 (h0 : functor.add_const (topological_space (has_Inf linarith.comp)) (has_neg (has_neg (has_neg Type)))) : @preconnected_space.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_Inf.{0} linarith.comp)) (has_neg.{1} (has_neg.{1} (has_neg.{1} Type))) h0)  := sorry --non-trivial
lemma new_lemma_42233 (h0 : prod (with_one unsigned) (with_one unsigned)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_42234 (h0 : filter (with_one (has_union linarith.comp))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_42235 (h0 : not (has_mem.mem (has_emptyc linarith.ineq) has_emptyc.emptyc -> false)) : @irreducible_space.{0} (has_emptyc.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_emptyc.{0} linarith.ineq) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_emptyc.{0} linarith.ineq) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_42236 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (generalized_boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (generalized_boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_42237 (h0 : complete_lattice (has_ssubset char)) : complete_lattice.is_Sup_finite_compact (has_ssubset char) := sorry --non-trivial
lemma new_lemma_42238 (h0 : topological_space (sub_neg_monoid (ordered_comm_monoid name))) : totally_disconnected_space (sub_neg_monoid (ordered_comm_monoid name)) := sorry --non-trivial
lemma new_lemma_42239 (h0 : topological_space (simple_graph (has_Inf (has_add pos)))) : path_connected_space (simple_graph (has_Inf (has_add pos))) := sorry --non-trivial
lemma new_lemma_42240 (h0 : topological_space Type) : t0_space Type := sorry --non-trivial
lemma new_lemma_42241 (h1 : topological_space (topological_space (has_ssubset (random_gen string_imp)))) : t0_space (topological_space (has_ssubset (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_42242 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_42243 (h0 : ring (has_Inf (has_add (has_Inf pos)))) : strong_rank_condition (has_Inf (has_add (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_42244 (h0 : fin has_zero.zero) : @preirreducible_space.{1} (simple_graph.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (simple_graph.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_42245 (h0 : functor.add_const (topological_space (add_cancel_monoid unsigned)) name) : @t0_space.{0} (add_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_42246 (h0 : functor.add_const (topological_space (has_nndist linarith.comp)) name) : @totally_separated_space.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_42247 (h0 : ordered_add_comm_monoid (comm_group (option (option (finset (option (option name))))))) : archimedean (comm_group (option (option (finset (option (option name)))))) := sorry --non-trivial
lemma new_lemma_42248 (h0 : topological_space (complete_semilattice_Sup (has_nnnorm linarith.comp_source))) : totally_disconnected_space (complete_semilattice_Sup (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_42249 (h0 : function.extfun Type (prod (linear_ordered_field (option unsigned)))) : id_rel (function.extfun_app h0 (linear_ordered_field (option unsigned))) := sorry --non-trivial
lemma new_lemma_42250 (h0 : topological_space (normed_lattice_add_comm_group (option (option empty)))) (h1 : preorder (normed_lattice_add_comm_group (option (option empty)))) : order_topology (normed_lattice_add_comm_group (option (option empty))) := sorry --non-trivial
lemma new_lemma_42251 (h0 : topological_space (ordered_ring num)) : totally_disconnected_space (ordered_ring num) := sorry --non-trivial
lemma new_lemma_42252 (h0 : uniform_space (cancel_monoid (has_add (boolean_algebra name)))) : complete_space (cancel_monoid (has_add (boolean_algebra name))) := sorry --non-trivial
lemma new_lemma_42253 (h0 : pseudo_metric_space (mul_zero_class ennreal)) (h1 : functor.comp add_monoid mul_zero_class ennreal) : @has_lipschitz_add.{0} (mul_zero_class.{0} ennreal) h0 (@functor.comp.run.{0 0 0} add_monoid.{0} mul_zero_class.{0} ennreal h1)  := sorry --non-trivial
lemma new_lemma_42254 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (filter.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (filter.{0} empty))  := sorry --non-trivial
lemma new_lemma_42255 (h0 : topological_space (cancel_monoid ennreal)) : t0_space (cancel_monoid ennreal) := sorry --non-trivial
lemma new_lemma_42256 (h0 : group (has_top (random_gen to_additive.value_type))) : group.fg (has_top (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_42257 (h0 : ring (semi_normed_comm_ring (has_ssubset (has_ssubset fun_info)))) : strong_rank_condition (semi_normed_comm_ring (has_ssubset (has_ssubset fun_info))) := sorry --non-trivial
lemma new_lemma_42258 (h0 : filter (has_top (semiring (random_gen linarith.comp)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_42259 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_union.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_union.{0} empty))  := sorry --non-trivial
lemma new_lemma_42260 (h0 : functor.add_const (complete_lattice (add_comm_monoid pos)) pos) : @is_compactly_generated.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_comm_monoid.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_42261 (h0 : not (function.extfun Type group -> false)) : @group.fg.{0} (partial_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (partial_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_42262 (h0 : functor.add_const (topological_space Type) linarith.comp) : @totally_disconnected_space.{1} Type (@functor.add_const.run.{1 0} (topological_space.{1} Type) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_42263 (h0 : functor.add_const (function.extfun (Type 1) topological_space) linarith.comp) : @t0_space.{1} (boolean_algebra.core.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) linarith.comp h0) (boolean_algebra.core.{1} Type))  := sorry --non-trivial
lemma new_lemma_42264 (h2 : ring (has_lt string.iterator_imp)) : is_domain (has_lt string.iterator_imp) := sorry --non-trivial
lemma new_lemma_42265 (h1 : group num) : normalizer_condition num := sorry --non-trivial
lemma new_lemma_42266 (h0 : functor.add_const (fin has_zero.zero) real) : is_principal_ideal_ring real := sorry --non-trivial
lemma new_lemma_42267 (h0 : functor.add_const (cancel_comm_monoid_with_zero (generalized_boolean_algebra Type)) (finset pos)) : @unique_factorization_monoid.{1} (generalized_boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (cancel_comm_monoid_with_zero.{1} (generalized_boolean_algebra.{1} Type)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_42268 (h0 : functor.add_const (topological_space (has_to_string pos)) Type) : @regular_space.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_to_string.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_42269 (h0 : topological_space (semigroup (has_add pos))) : path_connected_space (semigroup (has_add pos)) := sorry --non-trivial
lemma new_lemma_42270 (h0 : topological_space (has_neg (has_pos_part (has_pos_part pos)))) : t0_space (has_neg (has_pos_part (has_pos_part pos))) := sorry --non-trivial
lemma new_lemma_42271 (h0 : functor.add_const (topological_space (ordered_ring num)) (semiring empty)) : @topological_space.separable_space.{0} (ordered_ring.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} num)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_42272 (h0 : topological_space (has_nnnorm (random_gen (random_gen (random_gen (random_gen string_imp)))))) : t0_space (has_nnnorm (random_gen (random_gen (random_gen (random_gen string_imp))))) := sorry --non-trivial
lemma new_lemma_42273 (h0 : add_group (monoid (random_gen (random_gen char)))) : is_add_cyclic (monoid (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_42274 (h1 h2 : multiset linarith.ineq) : multiset.subset h1 h2 := sorry --non-trivial
lemma new_lemma_42275 (h0 : filter (pseudo_metric_space name)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_42276 (h0 : functor.add_const (topological_space (generalized_boolean_algebra linarith.comp)) Type) : @preirreducible_space.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (generalized_boolean_algebra.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_42277 (h0 : topological_space (has_to_string (has_add (finset linarith.comp)))) : t1_space (has_to_string (has_add (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_42278 (h0 : functor.add_const (ring (metric_space num)) (semiring (semiring num))) : @strong_rank_condition.{0} (metric_space.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (metric_space.{0} num)) (semiring.{0} (semiring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_42279 (h0 : function.extfun Type topological_space) : @normal_space.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_42280 (h0 : function.extfun (finset Type) (has_mem.mem (with_bot fun_info))) : @strong_rank_condition.{0} (with_bot.{0} fun_info) (@finset.pi.empty.{1 0} Type ring.{0} (with_bot.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_bot.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_42281 (h1 h2 : multiset (mul_one_class linarith.ineq)) : multiset.subset h1 h2 := sorry --non-trivial
lemma new_lemma_42282 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (measurable_space.dynkin_system.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (measurable_space.dynkin_system.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_42283 (h0 : functor.add_const (topological_space (ring Type)) (boolean_algebra Type)) : @totally_separated_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (ring.{1} Type)) (boolean_algebra.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_42284 (h0 : functor.add_const (group (option unsigned)) unsigned) : @is_cyclic.{0} (option.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (option.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_42285 (h0 : topological_space (generalized_boolean_algebra (has_neg Type))) : regular_space (generalized_boolean_algebra (has_neg Type)) := sorry --non-trivial
lemma new_lemma_42286 (h0 : complete_lattice (normed_group (denumerable fun_info))) : complete_lattice.is_Sup_finite_compact (normed_group (denumerable fun_info)) := sorry --non-trivial
lemma new_lemma_42287 (h0 : topological_space (has_one real.angle)) : totally_disconnected_space (has_one real.angle) := sorry --non-trivial
lemma new_lemma_42288 (h0 : has_mem.mem (normed_group (has_top fun_info)) has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} (normed_group.{0} (has_top.{0} fun_info)) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (normed_group.{0} (has_top.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_42289 (h0 : not (ring (topological_space char) -> false)) : @rank_condition.{0} (topological_space.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (topological_space.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_42290 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (mul_zero_class.{0} name) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (mul_zero_class.{0} name))  := sorry --non-trivial
lemma new_lemma_42291 (h0 : functor.add_const (semiring (normed_comm_ring linarith.comp)) (ring (ring name))) : @is_noetherian_ring.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (semiring.{0} (normed_comm_ring.{0} linarith.comp)) (ring.{0} (ring.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_42292 : infinite (add_cancel_monoid char) := sorry --non-trivial
lemma new_lemma_42293 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (ring.{0} (option.{0} ennreal)) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ring.{0} (option.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_42294 (h0 : uniform_space (has_to_string (has_to_string pos))) : separated_space (has_to_string (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_42295 (h0 : list (linear_ordered_add_comm_group (non_unital_non_assoc_ring to_additive.value_type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_42296 (h0 : functor.add_const (topological_space (has_nndist name)) name) : @locally_compact_space.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_42297 (h0 : functor.add_const (topological_space (mul_zero_class empty)) congr_arg_kind) : @topological_space.separable_space.{0} (mul_zero_class.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_42298 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (@id.{2} Type num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (@id.{2} Type num))  := sorry --non-trivial
lemma new_lemma_42299 (h0 : prod (as_linear_order empty) (as_linear_order empty)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_42300 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_emptyc.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_emptyc.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_42301 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (ordered_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_42302 (h0 : function.extfun Type topological_space) : @normal_space.{0} (has_top.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_top.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_42303 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring pos)) ennreal) : @topological_space.separable_space.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} pos)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_42304 (h1 : topological_space (has_compl char)) : totally_disconnected_space (has_compl char) := sorry --non-trivial
lemma new_lemma_42305 (h0 : topological_space (add_cancel_monoid (has_add environment.implicit_infer_kind))) : preconnected_space (add_cancel_monoid (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_42306 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @t0_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (boolean_algebra.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_42307 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (ring num)) := sorry --non-trivial
lemma new_lemma_42308 (h0 : uniform_space (add_comm_monoid (has_bot (comm_semigroup (has_bot real))))) : complete_space (add_comm_monoid (has_bot (comm_semigroup (has_bot real)))) := sorry --non-trivial
lemma new_lemma_42309 (h0 : topological_space (complete_distrib_lattice (mul_zero_class (mul_zero_class pos)))) : sequential_space (complete_distrib_lattice (mul_zero_class (mul_zero_class pos))) := sorry --non-trivial
lemma new_lemma_42310 (h0 : group (linear_ordered_add_comm_monoid congr_arg_kind)) : group.fg (linear_ordered_add_comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_42311 (h0 : not (ring (has_sub empty) -> false)) : @strong_rank_condition.{0} (has_sub.{0} empty) (@classical.by_contradiction'.{1} (ring.{0} (has_sub.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_42312 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (generalized_boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (generalized_boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_42313 (h2 : complete_lattice (dlist (random_gen fun_info))) : complete_lattice.is_Sup_finite_compact (dlist (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_42314 (h0 : ring (cancel_monoid (option ennreal))) : is_domain (cancel_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_42315 (h0 : topological_space (generalized_boolean_algebra (sub_neg_monoid (has_Inf pos)))) : preconnected_space (generalized_boolean_algebra (sub_neg_monoid (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_42316 (h0 : topological_space (has_neg_part (finset (finset pos)))) : totally_disconnected_space (has_neg_part (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_42317 (h0 : list linarith.comp_source) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_42318 (h0 : topological_space (comm_group (comm_group (comm_group name)))) : regular_space (comm_group (comm_group (comm_group name))) := sorry --non-trivial
lemma new_lemma_42319 (h0 : fin has_zero.zero) : @totally_separated_space.{0} (ring.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (ring.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_42320 (h0 : topological_space (preorder congr_arg_kind)) : totally_disconnected_space (preorder congr_arg_kind) := sorry --non-trivial
lemma new_lemma_42321 (h0 : function.extfun Type ring) : @is_domain.{0} (measurable_space.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (measurable_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_42322 (h0 : ring (has_nnnorm (mul_one_class (mul_one_class (mul_one_class linarith.comp_source))))) : is_domain (has_nnnorm (mul_one_class (mul_one_class (mul_one_class linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_42323 (h0 : group (has_norm (random_gen (has_nnnorm char)))) : is_cyclic (has_norm (random_gen (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_42324 (h0 : group (has_Inf (ring Type))) : is_cyclic (has_Inf (ring Type)) := sorry --non-trivial
lemma new_lemma_42325 (h0 : group (simple_graph (has_add (has_Inf (has_add Type))))) : is_cyclic (simple_graph (has_add (has_Inf (has_add Type)))) := sorry --non-trivial
lemma new_lemma_42326 (h0 : ring (semigroup (has_to_string ennreal))) : strong_rank_condition (semigroup (has_to_string ennreal)) := sorry --non-trivial
lemma new_lemma_42327 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (boolean_algebra.core.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_42328 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_42329 (h0 : not (ring (random_gen (has_nnnorm (has_nnnorm fun_info))) -> false)) : @rank_condition.{0} (random_gen.{0} (has_nnnorm.{0} (has_nnnorm.{0} fun_info))) (@classical.by_contradiction'.{1} (ring.{0} (random_gen.{0} (has_nnnorm.{0} (has_nnnorm.{0} fun_info)))) h0)  := sorry --non-trivial
lemma new_lemma_42330 (h0 : complete_lattice (has_emptyc (has_norm congr_arg_kind))) : is_compactly_generated (has_emptyc (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_42331 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @add_monoid.fg.{0} (has_bot.{0} real) (@matrix.vec_empty.{0} (add_monoid.{0} (has_bot.{0} real)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_42332 (h0 : functor.add_const (uniform_space (boolean_algebra linarith.comp)) (ring Type)) : @complete_space.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 1} (uniform_space.{0} (boolean_algebra.{0} linarith.comp)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_42333 (h0 : topological_space (normed_comm_ring (ring Type))) : discrete_topology (normed_comm_ring (ring Type)) := sorry --non-trivial
lemma new_lemma_42334 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (with_one.{0} (semiring.{0} (has_top.{0} (semiring.{0} (metric_space.{0} linarith.comp))))) (@function.extfun_app.{2 1} Type ring.{0} h0 (with_one.{0} (semiring.{0} (has_top.{0} (semiring.{0} (metric_space.{0} linarith.comp))))))  := sorry --non-trivial
lemma new_lemma_42335 (h0 : functor.add_const (list (normed_comm_ring Type)) name) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_42336 (h0 : list (ordered_ring unsigned)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_42337 (h0 : topological_space (normed_lattice_add_comm_group (has_neg real))) : discrete_topology (normed_lattice_add_comm_group (has_neg real)) := sorry --non-trivial
lemma new_lemma_42338 (h1 : group (has_ssubset fun_info)) : is_cyclic (has_ssubset fun_info) := sorry --non-trivial
lemma new_lemma_42339 (h0 : functor.add_const (complete_lattice (has_neg_part real.angle)) unsigned) : @complete_lattice.is_Sup_finite_compact.{0} (has_neg_part.{0} real.angle) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_neg_part.{0} real.angle)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_42340 (h0 : topological_space (generalized_boolean_algebra Type)) : totally_separated_space (generalized_boolean_algebra Type) := sorry --non-trivial
lemma new_lemma_42341 (h0 : not (topological_space (normed_group unsigned) -> false)) : @preirreducible_space.{0} (normed_group.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_group.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_42342 (h0 : cancel_comm_monoid_with_zero (add_cancel_monoid (has_neg linarith.comp))) : unique_factorization_monoid (add_cancel_monoid (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_42343 (h0 : add_monoid (measure_theory.measure_space linarith.comp)) : add_monoid.fg (measure_theory.measure_space linarith.comp) := sorry --non-trivial
lemma new_lemma_42344 (h1 : add_group (nondiscrete_normed_field enat)) : is_add_cyclic (nondiscrete_normed_field enat) := sorry --non-trivial
lemma new_lemma_42345 (h0 : topological_space (has_norm (semiring (semiring congr_arg_kind)))) : irreducible_space (has_norm (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_42346 (h0 : topological_space (has_top (random_gen (random_gen (random_gen congr_arg_kind))))) : totally_disconnected_space (has_top (random_gen (random_gen (random_gen congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_42347 (h0 : not (topological_space (linear_ordered_add_comm_group to_additive.value_type) -> false)) : @totally_disconnected_space.{0} (linear_ordered_add_comm_group.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_add_comm_group.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_42348 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (has_union.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_union.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_42349 (h0 : topological_space (measurable_space (random_gen (random_gen linarith.ineq)))) : t0_space (measurable_space (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_42350 (h0 : ring (boolean_algebra (has_pos_part Type))) : strong_rank_condition (boolean_algebra (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_42351 (h0 : ring (add_cancel_comm_monoid (random_gen (random_gen string_imp)))) : rank_condition (add_cancel_comm_monoid (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_42352 (h0 : complete_lattice (add_left_cancel_monoid string_imp)) : is_compactly_generated (add_left_cancel_monoid string_imp) := sorry --non-trivial
lemma new_lemma_42353 (h0 : functor.add_const (topological_space (has_neg environment.implicit_infer_kind)) name) : @sequential_space.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_42354 (h0 : topological_space (has_bot (has_bot Type))) : discrete_topology (has_bot (has_bot Type)) := sorry --non-trivial
lemma new_lemma_42355 (h0 : add_group (has_ssubset (has_nnnorm fun_info))) : is_add_cyclic (has_ssubset (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_42356 (h0 : topological_space (add_comm_monoid (has_bot (sub_neg_monoid pos)))) : t0_space (add_comm_monoid (has_bot (sub_neg_monoid pos))) := sorry --non-trivial
lemma new_lemma_42357 (h0 : ring (topological_space (random_gen linarith.ineq))) : is_domain (topological_space (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_42358 (h0 : cancel_comm_monoid_with_zero (semigroup empty)) : unique_factorization_monoid (semigroup empty) := sorry --non-trivial
lemma new_lemma_42359 (h0 : topological_space (has_add (has_neg (has_neg Type)))) : regular_space (has_add (has_neg (has_neg Type))) := sorry --non-trivial
lemma new_lemma_42360 (h0 : functor.add_const (topological_space (has_to_string linarith.comp)) Type) : @preirreducible_space.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_to_string.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_42361 (h0 : group (has_nndist (comm_group (comm_group Type)))) : group.fg (has_nndist (comm_group (comm_group Type))) := sorry --non-trivial
lemma new_lemma_42362 (h0 : uniform_space (has_bot (ordered_comm_monoid (has_add pos)))) : complete_space (has_bot (ordered_comm_monoid (has_add pos))) := sorry --non-trivial
lemma new_lemma_42363 (h0 : uniform_space (mul_zero_class (semiring (semiring (semiring unsigned))))) : separated_space (mul_zero_class (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_42364 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_42365 (h0 : not (complete_lattice (non_assoc_semiring empty) -> false)) : @is_compactly_generated.{0} (non_assoc_semiring.{0} empty) (@classical.by_contradiction'.{1} (complete_lattice.{0} (non_assoc_semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_42366 (h0 : filter (has_top (has_norm (has_norm linarith.comp)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_42367 (h0 : add_group (add_cancel_monoid (option (option ennreal)))) : is_add_cyclic (add_cancel_monoid (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_42368 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (mul_zero_class.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (mul_zero_class.{0} num))  := sorry --non-trivial
lemma new_lemma_42369 (h0 : functor.add_const (group (boolean_algebra environment.implicit_infer_kind)) linarith.comp) : @normalizer_condition.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_42370 (h0 : filter (add_monoid (denumerable linarith.ineq))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_42371 (h0 : function.extfun (finset Type) (has_mem.mem (semiring fun_info))) : @complete_lattice.is_Sup_finite_compact.{0} (semiring.{0} fun_info) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (semiring.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_42372 (h0 : functor.add_const (monoid (has_neg unsigned)) linarith.comp) : @monoid.fg.{0} (has_neg.{0} unsigned) (@functor.add_const.run.{0 0} (monoid.{0} (has_neg.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_42373 (h0 : fin has_zero.zero) : @is_principal_ideal_ring.{0} (ordered_comm_ring.{0} real) (@matrix.vec_empty.{0} (ring.{0} (ordered_comm_ring.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_42374 (h0 : topological_space (canonically_linear_ordered_monoid (finset linarith.comp))) : topological_space.separable_space (canonically_linear_ordered_monoid (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_42375 (h0 : filter (has_neg (normed_comm_ring pos))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_42376 (h0 h1 : fin has_zero.zero) : @has_measurable_div₂.{1} (sub_neg_monoid.{1} Type) (@matrix.vec_empty.{1} (measurable_space.{1} (sub_neg_monoid.{1} Type)) h0) (@matrix.vec_empty.{1} (has_div.{1} (sub_neg_monoid.{1} Type)) h1)  := sorry --non-trivial
lemma new_lemma_42377 (h0 : functor.add_const (ring (has_inter ennreal)) num) : @is_domain.{0} (has_inter.{0} ennreal) (@functor.add_const.run.{0 0} (ring.{0} (has_inter.{0} ennreal)) num h0)  := sorry --non-trivial
lemma new_lemma_42378 (h0 : functor.add_const (topological_space (ordered_comm_ring linarith.comp)) pos) : @path_connected_space.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_42379 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_42380 (h0 : function.extfun (finset Type) (has_mem.mem (has_emptyc congr_arg_kind))) : @is_domain.{0} (has_emptyc.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type ring.{0} (has_emptyc.{0} congr_arg_kind) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_emptyc.{0} congr_arg_kind)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_42381 (h0 : function.extfun Type group) : @group.fg.{0} (has_ssubset.{0} char) (@function.extfun_app.{2 1} Type group.{0} h0 (has_ssubset.{0} char))  := sorry --non-trivial
lemma new_lemma_42382 (h0 : topological_space (preorder (semiring (semiring (semiring (semiring num)))))) : normal_space (preorder (semiring (semiring (semiring (semiring num))))) := sorry --non-trivial
lemma new_lemma_42383 (h0 : topological_space (semiring (has_top congr_arg_kind))) : t0_space (semiring (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_42384 (h0 : set (semi_normed_comm_ring string.iterator_imp)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_42385 (h0 : functor.add_const (topological_space (ordered_comm_ring Type)) pos) : @totally_separated_space.{1} (ordered_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ordered_comm_ring.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_42386 (h0 : function.extfun Type topological_space) : @normal_space.{0} (with_one.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_one.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_42387 (h0 : group (boolean_algebra.core num)) : group.fg (boolean_algebra.core num) := sorry --non-trivial
lemma new_lemma_42388 (h0 : not (ring (distrib_lattice linarith.comp_source) -> false)) : @strong_rank_condition.{0} (distrib_lattice.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (distrib_lattice.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_42389 (h0 : semiring (has_neg (has_to_string pos))) : is_noetherian_ring (has_neg (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_42390 (h0 : list (ordered_comm_ring (has_Inf (ring (boolean_algebra.core pos))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_42391 (h0 : functor.add_const (topological_space (has_nndist Type)) pos) : @path_connected_space.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_nndist.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_42392 (h0 : functor.add_const (list (has_to_string (has_to_string name))) Type) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_42393 (h0 : functor.add_const (ring (comm_group pos)) Type) : @is_domain.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (comm_group.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_42394 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (has_zero.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_zero.{0} name))  := sorry --non-trivial
lemma new_lemma_42395 (h0 : topological_space (has_nndist (has_neg pos))) : t0_space (has_nndist (has_neg pos)) := sorry --non-trivial
lemma new_lemma_42396 (h3 : not (topological_space (has_append reducibility_hints) -> false)) : @t0_space.{0} (has_append.{0} reducibility_hints) (@classical.by_contradiction'.{1} (topological_space.{0} (has_append.{0} reducibility_hints)) h3)  := sorry --non-trivial
lemma new_lemma_42397 (h0 : topological_space (linear_ordered_comm_group congr_arg_kind)) : t1_space (linear_ordered_comm_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_42398 (h0 : functor.add_const (topological_space (add_cancel_monoid empty)) unsigned) : @totally_separated_space.{0} (add_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_42399 (h0 : function.extfun nat fin) : @discrete_topology.{0} (has_add.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (has_add.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_42400 (h0 : functor.add_const (function.extfun (Type -> Type) (function.extfun Type)) linarith.comp_source) : @path_connected_space.{0} (has_emptyc.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@functor.add_const.run.{1 0} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) linarith.comp_source h0) topological_space.{0}) (has_emptyc.{0} num))  := sorry --non-trivial
lemma new_lemma_42401 (h0 : functor.add_const (finset (has_Sup empty)) (semiring (semiring empty))) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_42402 (h0 : topological_space (simple_graph empty)) : discrete_topology (simple_graph empty) := sorry --non-trivial
lemma new_lemma_42403 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @regular_space.{1} (has_bot.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (has_bot.{1} Type))  := sorry --non-trivial
lemma new_lemma_42404 (h0 : ring (topological_space (random_gen (random_gen (random_gen linarith.ineq))))) : rank_condition (topological_space (random_gen (random_gen (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_42405 (h0 : monoid (simple_graph (finset linarith.comp))) : monoid.fg (simple_graph (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_42406 (h0 : function.extfun Type topological_space) : @t1_space.{0} (boolean_algebra.core.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} pos))  := sorry --non-trivial
lemma new_lemma_42407 (h0 : topological_space (comm_group (ring pos))) : totally_disconnected_space (comm_group (ring pos)) := sorry --non-trivial
lemma new_lemma_42408 (h0 : group (has_zero (has_neg linarith.comp))) : group.fg (has_zero (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_42409 (h0 : complete_lattice (has_ssubset (random_gen linarith.comp_source))) : complete_lattice.is_Sup_finite_compact (has_ssubset (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_42410 (h0 : topological_space (has_pos_part (has_Inf real))) : irreducible_space (has_pos_part (has_Inf real)) := sorry --non-trivial
lemma new_lemma_42411 (h0 : functor.add_const (uniform_space (ordered_comm_group empty)) num) : @separated_space.{0} (ordered_comm_group.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (ordered_comm_group.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_42412 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (linear_ordered_add_comm_group.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (linear_ordered_add_comm_group.{0} num))  := sorry --non-trivial
lemma new_lemma_42413 (h0 : has_lt (has_compl environment.projection_info)) : no_max_order (has_compl environment.projection_info) := sorry --non-trivial
lemma new_lemma_42414 (h0 : functor.add_const (topological_space (finset linarith.comp)) name) : @loc_path_connected_space.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_42415 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (has_edist.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_edist.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_42416 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (has_emptyc.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_emptyc.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_42417 (h0 : functor.add_const (function.extfun Type ring) name) : @rank_condition.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) name h0) (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_42418 (h0 : functor.add_const (complete_lattice (has_add Type)) (has_to_string Type)) : @complete_lattice.is_Sup_finite_compact.{1} (has_add.{1} Type) (@functor.add_const.run.{1 1} (complete_lattice.{1} (has_add.{1} Type)) (has_to_string.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_42419 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (monoid congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_42420 (h0 : complete_lattice (boolean_algebra (has_to_string (has_pos_part (has_pos_part Type))))) : is_compactly_generated (boolean_algebra (has_to_string (has_pos_part (has_pos_part Type)))) := sorry --non-trivial
lemma new_lemma_42421 (h0 : topological_space (omega_complete_partial_order (semiring empty))) : irreducible_space (omega_complete_partial_order (semiring empty)) := sorry --non-trivial
lemma new_lemma_42422 (h0 : topological_space (has_bot (has_bot Type))) : sequential_space (has_bot (has_bot Type)) := sorry --non-trivial
lemma new_lemma_42423 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (semigroup.{0} (semiring.{0} (semiring.{0} unsigned))) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} (semiring.{0} (semiring.{0} unsigned))))  := sorry --non-trivial
lemma new_lemma_42424 (h0 : not (add_group (has_add to_additive.value_type) -> false)) : @is_add_cyclic.{0} (has_add.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (add_group.{0} (has_add.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_42425 (h0 : ring (option ennreal)) : rank_condition (option ennreal) := sorry --non-trivial
lemma new_lemma_42426 (h0 : function.extfun (Type 1) topological_space) : @preirreducible_space.{1} (plift.{1} empty) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (plift.{1} empty))  := sorry --non-trivial
lemma new_lemma_42427 (h0 : filter (boolean_algebra (ring linarith.comp))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_42428 (h1 : not (ring (with_one string.iterator_imp) -> false)) : @rank_condition.{0} (with_one.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (ring.{0} (with_one.{0} string.iterator_imp)) h1)  := sorry --non-trivial
lemma new_lemma_42429 (h0 : topological_space (comm_semigroup name)) : totally_separated_space (comm_semigroup name) := sorry --non-trivial
lemma new_lemma_42430 (h0 : ring (add_comm_monoid (has_add Type))) : rank_condition (add_comm_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_42431 (h0 : filter (has_to_string name)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_42432 (h0 : functor.add_const (topological_space environment.implicit_infer_kind) name) : @preconnected_space.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 0} (topological_space.{0} environment.implicit_infer_kind) name h0)  := sorry --non-trivial
lemma new_lemma_42433 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (complete_distrib_lattice.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (complete_distrib_lattice.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_42434 (h0 : functor.add_const (group (add_cancel_monoid name)) name) : @is_cyclic.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (group.{0} (add_cancel_monoid.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_42435 (h0 : topological_space (sub_neg_monoid pos)) : discrete_topology (sub_neg_monoid pos) := sorry --non-trivial
lemma new_lemma_42436 (h0 : not (complete_lattice (non_unital_non_assoc_semiring char) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (non_unital_non_assoc_semiring.{0} char) (@classical.by_contradiction'.{1} (complete_lattice.{0} (non_unital_non_assoc_semiring.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_42437 (h0 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} (measurable_space.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h0) (measurable_space.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_42438 (h0 : ring (has_pos_part (has_to_string Type))) : is_domain (has_pos_part (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_42439 (h0 : has_mem.mem uniform_space has_emptyc.emptyc) : @separated_space.{0} (has_norm.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) uniform_space.{0} h0) (has_norm.{0} num))  := sorry --non-trivial
lemma new_lemma_42440 (h0 : function.extfun (Type 1) ring) : @is_domain.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_42441 (h0 : ring (mul_zero_class (has_to_string ennreal))) : is_principal_ideal_ring (mul_zero_class (has_to_string ennreal)) := sorry --non-trivial
lemma new_lemma_42442 (h0 : topological_space (ring (has_neg name))) : loc_path_connected_space (ring (has_neg name)) := sorry --non-trivial
lemma new_lemma_42443 (h0 : topological_space (id (random_gen linarith.comp))) : totally_disconnected_space (id (random_gen linarith.comp)) := sorry --non-trivial
lemma new_lemma_42444 (h0 : uniform_space (semigroup (mul_one_class (normed_comm_ring (has_neg linarith.comp))))) : separated_space (semigroup (mul_one_class (normed_comm_ring (has_neg linarith.comp)))) := sorry --non-trivial
lemma new_lemma_42445 (h0 : function.extfun (finset Type) (has_mem.mem (has_norm linarith.ineq))) : @totally_separated_space.{0} (has_norm.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_norm.{0} linarith.ineq) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_norm.{0} linarith.ineq)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_42446 (h0 : function.extfun (finset Type) (has_mem.mem (id empty))) : @totally_disconnected_space.{0} (@id.{2} Type empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (@id.{2} Type empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (@id.{2} Type empty)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_42447 (h0 : complete_lattice (has_neg (has_neg linarith.comp))) : complete_lattice.is_Sup_finite_compact (has_neg (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_42448 (h0 : filter (has_to_string (has_add (has_add pos)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_42449 (h0 : topological_space (canonically_ordered_add_monoid num)) : irreducible_space (canonically_ordered_add_monoid num) := sorry --non-trivial
lemma new_lemma_42450 (h0 : topological_space (add_cancel_monoid (add_cancel_monoid (add_cancel_monoid pos)))) : t0_space (add_cancel_monoid (add_cancel_monoid (add_cancel_monoid pos))) := sorry --non-trivial
lemma new_lemma_42451 (h0 : list (normed_comm_ring (option (option (option ennreal))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_42452 (h0 : topological_space (has_ssubset linarith.ineq)) : totally_disconnected_space (has_ssubset linarith.ineq) := sorry --non-trivial
lemma new_lemma_42453 (h0 : functor.add_const (group (has_neg linarith.comp)) Type) : @group.fg.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 1} (group.{0} (has_neg.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_42454 (h0 : not (has_mem.mem (semiring num) has_emptyc.emptyc -> false)) : @monoid.fg.{0} (semiring.{0} num) (@finset.pi.empty.{1 0} Type monoid.{0} (semiring.{0} num) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} num) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_42455 (h0 : functor.add_const (function.extfun (Type 1) topological_space) (ring (has_add (has_add pos)))) : @regular_space.{1} (has_pos_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) (ring.{0} (has_add.{0} (has_add.{0} pos))) h0) (has_pos_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_42456 (h0 : complete_lattice (has_add (complete_distrib_lattice real))) : is_compactly_generated (has_add (complete_distrib_lattice real)) := sorry --non-trivial
lemma new_lemma_42457 (h0 : list (semigroup name)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_42458 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (linear_ordered_comm_monoid_with_zero.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_monoid_with_zero.{0} empty))  := sorry --non-trivial
lemma new_lemma_42459 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (has_emptyc.{0} string_imp) (@function.extfun_app.{2 1} Type monoid.{0} h0 (has_emptyc.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_42460 (h0 : fin has_zero.zero) : @is_add_cyclic.{1} (has_pos_part.{1} Type) (@matrix.vec_empty.{1} (add_group.{1} (has_pos_part.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_42461 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_42462 (h0 : topological_space (ordered_comm_ring (has_Inf (finset (has_Inf (has_Inf linarith.comp)))))) : totally_separated_space (ordered_comm_ring (has_Inf (finset (has_Inf (has_Inf linarith.comp))))) := sorry --non-trivial
lemma new_lemma_42463 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (linear_ordered_comm_ring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_ring.{0} num))  := sorry --non-trivial
lemma new_lemma_42464 (h1 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} linarith.comp_source (@function.extfun_app.{2 1} Type complete_lattice.{0} h1 linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_42465 (h0 : functor.add_const (topological_space (add_cancel_monoid environment.implicit_infer_kind)) pos) : @sequential_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_42466 (h0 : topological_space (complete_semilattice_Sup (semiring num))) : t1_space (complete_semilattice_Sup (semiring num)) := sorry --non-trivial
lemma new_lemma_42467 (h0 : functor.add_const (cancel_comm_monoid_with_zero (finset name)) pos) : @unique_factorization_monoid.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (finset.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_42468 (h0 : functor.add_const (topological_space (finset Type)) Type) : @sequential_space.{1} (finset.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (finset.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_42469 (h1 : complete_lattice (distrib std_gen)) : is_compactly_generated (distrib std_gen) := sorry --non-trivial
lemma new_lemma_42470 (h0 : not (has_lift_t (random_gen fun_info) Prop -> false)) (h1 : random_gen fun_info) : @lift_t.{1 1} (random_gen.{0} fun_info) Prop (@classical.by_contradiction'.{1} (has_lift_t.{1 1} (random_gen.{0} fun_info) Prop) h0) h1  := sorry --non-trivial
lemma new_lemma_42471 (h0 h1 : multiset (has_ssubset (mul_one_class string.iterator_imp))) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_42472 (h2 : ring (non_unital_non_assoc_semiring (mul_one_class string.iterator_imp))) : rank_condition (non_unital_non_assoc_semiring (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_42473 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (has_inter.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_inter.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_42474 (h0 : functor.add_const (function.extfun Type uniform_space) unsigned) : @complete_space.{0} (cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) unsigned h0) (cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_42475 (h0 : topological_space (generalized_boolean_algebra (has_neg (has_Inf Type)))) : path_connected_space (generalized_boolean_algebra (has_neg (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_42476 (h0 : not (function.extfun Type group -> false)) : @normalizer_condition.{0} (linear_ordered_semiring.{0} (has_norm.{0} (has_norm.{0} (has_norm.{0} (semiring.{0} empty))))) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (linear_ordered_semiring.{0} (has_norm.{0} (has_norm.{0} (has_norm.{0} (semiring.{0} empty))))))  := sorry --non-trivial
lemma new_lemma_42477 (h0 : topological_space (mul_zero_class (semiring (semiring empty)))) : t1_space (mul_zero_class (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_42478 (h0 : ordered_comm_monoid (mul_zero_class (has_nndist name))) : has_exists_mul_of_le (mul_zero_class (has_nndist name)) := sorry --non-trivial
lemma new_lemma_42479 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (has_inv.{0} linarith.ineq) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_inv.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_42480 (h0 : functor.add_const (uniform_space (has_zero Type)) environment.implicit_infer_kind) : @separated_space.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (has_zero.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_42481 (h0 : group (cancel_monoid (option (option (option unsigned))))) : normalizer_condition (cancel_monoid (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_42482 (h0 : fin has_zero.zero) : @totally_separated_space.{1} (has_pos_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@matrix.vec_empty.{2} (function.extfun.{3 2} (Type 1) topological_space.{1}) h0) (has_pos_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_42483 (h0 : function.extfun Type ring) : @is_domain.{0} (has_ssubset.{0} linarith.ineq) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_ssubset.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_42484 (h0 : functor.add_const (topological_space (semiring unsigned)) empty) : @irreducible_space.{0} (semiring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (semiring.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_42485 (h0 : functor.add_const (topological_space (ordered_ring unsigned)) (semiring unsigned)) : @locally_compact_space.{0} (ordered_ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} unsigned)) (semiring.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_42486 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_domain.{1} (has_neg_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ring.{1}) (has_neg_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_42487 (h0 : complete_lattice (has_add (has_pos_part (sub_neg_monoid (has_bot pos))))) : complete_lattice.is_Sup_finite_compact (has_add (has_pos_part (sub_neg_monoid (has_bot pos)))) := sorry --non-trivial
lemma new_lemma_42488 (h0 : finset (canonically_ordered_comm_semiring (finset name))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_42489 (h0 : function.extfun nat fin) : @is_principal_ideal_ring.{0} (complete_distrib_lattice.{0} real) (@matrix.vec_empty.{0} (ring.{0} (complete_distrib_lattice.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_42490 (h0 : monoid (canonically_ordered_comm_semiring num)) : monoid.fg (canonically_ordered_comm_semiring num) := sorry --non-trivial
lemma new_lemma_42491 (h0 : functor.add_const (add_monoid (free_add_monoid unsigned)) congr_arg_kind) : add_monoid.fg (free_add_monoid unsigned) := sorry --non-trivial
lemma new_lemma_42492 (h0 : add_monoid (has_union (has_norm (with_bot (with_bot unsigned))))) : add_monoid.fg (has_union (has_norm (with_bot (with_bot unsigned)))) := sorry --non-trivial
lemma new_lemma_42493 (h0 : filter (cancel_monoid (has_neg pos))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_42494 (h2 : add_group (with_zero to_additive.value_type)) : is_add_cyclic (with_zero to_additive.value_type) := sorry --non-trivial
lemma new_lemma_42495 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @normal_space.{0} (has_nndist.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (has_nndist.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_42496 (h0 : topological_space (semiring num)) : preirreducible_space (semiring num) := sorry --non-trivial
lemma new_lemma_42497 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (dlist.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (dlist.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_42498 (h0 : functor.comp topological_space semigroup Type) : @t1_space.{1} (semigroup.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} semigroup.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_42499 (h0 : functor.add_const (topological_space (ordered_comm_monoid pos)) (ring pos)) : @loc_path_connected_space.{0} (ordered_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_monoid.{0} pos)) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_42500 (h0 : has_scalar std_gen string_imp) (h1 : has_scalar (mul_opposite std_gen) string_imp) : is_central_scalar std_gen string_imp := sorry --non-trivial
lemma new_lemma_42501 (h0 : functor.add_const (add_group (boolean_algebra.core pos)) Type) : @is_add_cyclic.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 1} (add_group.{0} (boolean_algebra.core.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_42502 (h0 : add_group (with_one (semiring (has_norm (semiring linarith.comp))))) : is_add_cyclic (with_one (semiring (has_norm (semiring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_42503 (h0 : functor.add_const (topological_space pos) pos) : @totally_disconnected_space.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) pos h0)  := sorry --non-trivial
lemma new_lemma_42504 (h0 : ring (semi_normed_ring (mul_one_class char))) : is_domain (semi_normed_ring (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_42505 (h0 : topological_space (measurable_space unsigned)) : discrete_topology (measurable_space unsigned) := sorry --non-trivial
lemma new_lemma_42506 (h0 : finset (has_add (measurable_space.dynkin_system unsigned))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_42507 (h0 : semiring (has_star (semiring (semiring unsigned)))) : is_noetherian_ring (has_star (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_42508 (h0 : filter (has_neg (ring Type))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_42509 (h0 : cancel_comm_monoid_with_zero (has_star (semiring (semiring empty)))) : unique_factorization_monoid (has_star (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_42510 (h0 : ring (canonically_ordered_comm_semiring congr_arg_kind)) : is_principal_ideal_ring (canonically_ordered_comm_semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_42511 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_42512 (h0 : group (add_cancel_monoid (has_Inf pos))) : group.fg (add_cancel_monoid (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_42513 (h0 : topological_space (has_pos_part (has_Inf Type))) : preirreducible_space (has_pos_part (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_42514 (h0 : functor.add_const (topological_space (has_zero pos)) Type) : @locally_compact_space.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_zero.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_42515 (h0 : finset (complete_distrib_lattice (cancel_monoid linarith.comp))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_42516 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @locally_compact_space.{1} (sub_neg_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (sub_neg_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin (@matrix.vec_empty.{0} (function.extfun.{1 1} nat fin) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero))) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_42517 (h0 : filter (linear_ordered_add_comm_group (has_norm (has_norm (has_norm (has_norm linarith.ineq)))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_42518 (h0 : complete_lattice (has_dist linarith.comp_source)) : complete_lattice.is_Sup_finite_compact (has_dist linarith.comp_source) := sorry --non-trivial
lemma new_lemma_42519 (h0 : finset (canonically_ordered_comm_semiring (ring (ring linarith.comp)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_42520 (h0 : functor.add_const (topological_space (measurable_space.dynkin_system num)) num) : @path_connected_space.{0} (measurable_space.dynkin_system.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (measurable_space.dynkin_system.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_42521 (h0 : functor.add_const (uniform_space (has_zero linarith.comp)) name) : @separated_space.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_zero.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_42522 (h0 : functor.add_const (topological_space (has_neg_part ennreal)) pos) : @discrete_topology.{0} (has_neg_part.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} ennreal)) pos h0)  := sorry --non-trivial
lemma new_lemma_42523 (h0 : function.extfun Type ring) : @rank_condition.{0} (encodable.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} h0 (encodable.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_42524 (h0 : uniform_space (uniform_space (has_ssubset string_imp))) : complete_space (uniform_space (has_ssubset string_imp)) := sorry --non-trivial
lemma new_lemma_42525 (h0 : finset (complete_distrib_lattice (finset name))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_42526 (h0 : functor.add_const (add_group (has_to_string unsigned)) environment.implicit_infer_kind) : @is_add_cyclic.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 0} (add_group.{0} (has_to_string.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_42527 (h0 : functor.add_const (group (left_cancel_monoid unsigned)) num) : @group.fg.{0} (left_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (left_cancel_monoid.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_42528 (h0 : uniform_space (random_gen (has_inv (has_inv linarith.comp_source)))) : complete_space (random_gen (has_inv (has_inv linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_42529 (h0 : not (ring (add_right_cancel_monoid unsigned) -> false)) : @is_domain.{0} (add_right_cancel_monoid.{0} unsigned) (@classical.by_contradiction'.{1} (ring.{0} (add_right_cancel_monoid.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_42530 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (non_assoc_semiring unsigned)) := sorry --non-trivial
lemma new_lemma_42531 (h0 : set (nondiscrete_normed_field (add_comm_semigroup (add_comm_semigroup string.iterator_imp)) -> linarith.ineq)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_42532 (h1 : group (topological_space (random_gen string_imp))) : group.fg (topological_space (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_42533 (h0 : has_neg (has_compl linarith.ineq)) (h1 : measurable_space (has_compl linarith.ineq)) : has_measurable_neg (has_compl linarith.ineq) := sorry --non-trivial
lemma new_lemma_42534 (h0 : not (function.extfun Type topological_space -> false)) : @normal_space.{0} (random_gen.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (random_gen.{0} empty))  := sorry --non-trivial
lemma new_lemma_42535 (h0 : add_group (complete_distrib_lattice (has_pos_part Type))) : is_add_cyclic (complete_distrib_lattice (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_42536 (h0 : functor.add_const (ring (add_cancel_monoid pos)) (has_zero Type)) : @is_principal_ideal_ring.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (add_cancel_monoid.{0} pos)) (has_zero.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_42537 (h1 : set (char -> add_comm_semigroup fun_info)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_42538 (h0 : functor.add_const (functor.add_const (topological_space Type) pos) name) : @irreducible_space.{1} Type (@functor.add_const.run.{1 0} (topological_space.{1} Type) pos (@functor.add_const.run.{1 0} (functor.add_const.{1 0} (topological_space.{1} Type) pos) name h0))  := sorry --non-trivial
lemma new_lemma_42539 (h0 : group (with_one empty)) : is_cyclic (with_one empty) := sorry --non-trivial
lemma new_lemma_42540 (h0 : ring (has_union congr_arg_kind)) : strong_rank_condition (has_union congr_arg_kind) := sorry --non-trivial
lemma new_lemma_42541 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_nndist.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_nndist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_42542 (h0 : monoid (add_right_cancel_monoid empty)) : monoid.fg (add_right_cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_42543 (h0 : functor.add_const (topological_space (preorder empty)) unsigned) : @totally_separated_space.{0} (preorder.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (preorder.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_42544 (h0 : topological_space (has_neg (has_add name))) : locally_compact_space (has_neg (has_add name)) := sorry --non-trivial
lemma new_lemma_42545 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (left_cancel_monoid (semiring empty))) := sorry --non-trivial
lemma new_lemma_42546 (h0 : ring (has_emptyc (has_norm (random_gen linarith.comp_source)))) : is_domain (has_emptyc (has_norm (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_42547 (h0 : function.extfun Type (functor.add_const (topological_space (canonically_ordered_add_monoid empty)))) : @t0_space.{0} (canonically_ordered_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_add_monoid.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (canonically_ordered_add_monoid.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_42548 (h0 : topological_space (measurable_space.dynkin_system (semiring empty))) : irreducible_space (measurable_space.dynkin_system (semiring empty)) := sorry --non-trivial
lemma new_lemma_42549 (h0 : ring (has_lt string.iterator_imp) -> Prop) (h1 : Exists (fun (x : ring (has_lt string.iterator_imp)), h0 x)) : @strong_rank_condition.{0} (has_lt.{0} string.iterator_imp) (@classical.some.{1} (ring.{0} (has_lt.{0} string.iterator_imp)) h0 h1)  := sorry --non-trivial
lemma new_lemma_42550 (h0 : function.extfun Type topological_space) : @t0_space.{0} (filter.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (filter.{0} empty))  := sorry --non-trivial
lemma new_lemma_42551 (h1 : set (char -> environment.implicit_infer_kind)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_42552 (h0 : uniform_space (ordered_cancel_add_comm_monoid ennreal)) : complete_space (ordered_cancel_add_comm_monoid ennreal) := sorry --non-trivial
lemma new_lemma_42553 (h3 : uniform_space linarith.comp_source) : complete_space linarith.comp_source := sorry --non-trivial
lemma new_lemma_42554 (h0 : add_group (has_zero (has_zero (finset (normed_comm_ring pos))))) : is_add_cyclic (has_zero (has_zero (finset (normed_comm_ring pos)))) := sorry --non-trivial
lemma new_lemma_42555 (h0 : group (rel empty num)) : normalizer_condition (rel empty num) := sorry --non-trivial
lemma new_lemma_42556 (h0 : not (group (with_bot num) -> false)) : @normalizer_condition.{0} (with_bot.{0} num) (@classical.by_contradiction'.{1} (group.{0} (with_bot.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_42557 (h0 : topological_space (has_neg (has_add Type))) : sequential_space (has_neg (has_add Type)) := sorry --non-trivial
lemma new_lemma_42558 (h0 : functor.add_const (topological_space (canonically_ordered_add_monoid num)) empty) : @locally_compact_space.{0} (canonically_ordered_add_monoid.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_add_monoid.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_42559 (h0 : ring (metric_space (has_norm empty))) : strong_rank_condition (metric_space (has_norm empty)) := sorry --non-trivial
lemma new_lemma_42560 (h0 : group (topological_space (has_nnnorm to_additive.value_type))) : group.fg (topological_space (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_42561 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (add_comm_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_42562 (h0 : complete_lattice (add_cancel_comm_monoid empty)) : is_compactly_generated (add_cancel_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_42563 (h0 : set (nondiscrete_normed_field string.iterator_imp)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_42564 (h0 : functor.add_const (list (normed_comm_ring (ring linarith.comp))) linarith.comp) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_42565 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (boolean_algebra.core.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (boolean_algebra.core.{0} empty))  := sorry --non-trivial
lemma new_lemma_42566 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (has_nndist.{0} name) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (has_nndist.{0} name))  := sorry --non-trivial
lemma new_lemma_42567 (h0 : ring (random_gen (mul_one_class char))) : is_domain (random_gen (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_42568 (h0 : topological_space (has_to_string (comm_group (comm_group name)))) : t0_space (has_to_string (comm_group (comm_group name))) := sorry --non-trivial
lemma new_lemma_42569 (h0 : functor.add_const (complete_lattice (cancel_monoid environment.implicit_infer_kind)) name) : @is_compactly_generated.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (cancel_monoid.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_42570 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (comm_ring.{0} linarith.ineq) (@function.extfun_app.{2 1} Type add_group.{0} h0 (comm_ring.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_42571 (h1 : monoid linarith.ineq) : monoid.fg linarith.ineq := sorry --non-trivial
lemma new_lemma_42572 (h0 : topological_space (has_to_string (comm_group pos))) : t1_space (has_to_string (comm_group pos)) := sorry --non-trivial
lemma new_lemma_42573 (h0 : ring (has_union (semiring unsigned))) : rank_condition (has_union (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_42574 (h0 h2 : multiset (add_comm_semigroup fun_info)) : multiset.disjoint h0 h2 := sorry --non-trivial
lemma new_lemma_42575 (h0 : functor.add_const (topological_space ennreal) ennreal) : totally_separated_space ennreal := sorry --non-trivial
lemma new_lemma_42576 (h0 : functor.add_const (topological_space (add_cancel_monoid empty)) empty) : @locally_compact_space.{0} (add_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_42577 (h0 : monoid (has_top string_imp)) : monoid.fg (has_top string_imp) := sorry --non-trivial
lemma new_lemma_42578 (h0 : functor.add_const (list (has_to_string congr_arg_kind)) congr_arg_kind) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_42579 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @complete_lattice.is_Sup_finite_compact.{1} (comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 complete_lattice.{1}) (comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_42580 (h0 : ordered_add_comm_monoid (complete_distrib_lattice (finset pos))) : archimedean (complete_distrib_lattice (finset pos)) := sorry --non-trivial
lemma new_lemma_42581 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (finset num)) := sorry --non-trivial
lemma new_lemma_42582 (h0 : functor.add_const (add_monoid (add_cancel_monoid unsigned)) unsigned) : @add_monoid.fg.{0} (add_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (add_monoid.{0} (add_cancel_monoid.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_42583 (h0 : topological_space (has_neg_part (option (option unsigned)))) : discrete_topology (has_neg_part (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_42584 (h0 : ring (canonically_ordered_comm_semiring (has_add pos))) : is_principal_ideal_ring (canonically_ordered_comm_semiring (has_add pos)) := sorry --non-trivial
lemma new_lemma_42585 (h0 : topological_space (has_pos_part (ring (finset (has_Inf pos))))) : t0_space (has_pos_part (ring (finset (has_Inf pos)))) := sorry --non-trivial
lemma new_lemma_42586 (h1 : topological_space (denumerable to_additive.value_type)) : path_connected_space (denumerable to_additive.value_type) := sorry --non-trivial
lemma new_lemma_42587 (h0 : not (has_mem.mem (measurable_space num) has_emptyc.emptyc -> false)) : @normalizer_condition.{0} (measurable_space.{0} num) (@finset.pi.empty.{1 0} Type group.{0} (measurable_space.{0} num) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (measurable_space.{0} num) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_42588 (h0 : functor.add_const (ring (generalized_boolean_algebra linarith.comp)) pos) : @is_principal_ideal_ring.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (generalized_boolean_algebra.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_42589 (h0 : not (ring (fintype to_additive.value_type) -> false)) : @strong_rank_condition.{0} (fintype.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (fintype.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_42590 (h0 : ring (measurable_space.dynkin_system empty)) : is_domain (measurable_space.dynkin_system empty) := sorry --non-trivial
lemma new_lemma_42591 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_42592 (h0 : uniform_space (measurable_space (metric_space num))) : complete_space (measurable_space (metric_space num)) := sorry --non-trivial
lemma new_lemma_42593 (h0 : functor.add_const (uniform_space (has_nndist Type)) pos) : @separated_space.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (has_nndist.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_42594 (h0 : functor.add_const (complete_lattice (ring Type)) (boolean_algebra (has_neg_part Type))) : @is_atomistic.{1} (ring.{1} Type) (@functor.add_const.run.{1 1} (complete_lattice.{1} (ring.{1} Type)) (boolean_algebra.{1} (has_neg_part.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_42595 (h0 : add_group (distrib (has_nnnorm fun_info))) : is_add_cyclic (distrib (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_42596 (h0 : uniform_space (has_pos_part (sub_neg_monoid pos))) : complete_space (has_pos_part (sub_neg_monoid pos)) := sorry --non-trivial
lemma new_lemma_42597 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_bot.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_bot.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_42598 (h1 : complete_lattice (fintype fun_info)) : complete_lattice.is_Sup_finite_compact (fintype fun_info) := sorry --non-trivial
lemma new_lemma_42599 (h0 : functor.add_const (topological_space (has_neg name)) environment.implicit_infer_kind) : @irreducible_space.{0} (has_neg.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_42600 (h0 : cancel_comm_monoid_with_zero (add_comm_monoid (option unsigned))) : unique_factorization_monoid (add_comm_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_42601 (h0 : ordered_add_comm_monoid (canonically_ordered_monoid (has_neg name))) : archimedean (canonically_ordered_monoid (has_neg name)) := sorry --non-trivial
lemma new_lemma_42602 (h0 : functor.add_const (topological_space (cancel_monoid pos)) (boolean_algebra linarith.comp)) : @irreducible_space.{0} (cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} pos)) (boolean_algebra.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_42603 (h2 : complete_lattice (has_lt linarith.comp_source)) : is_compactly_generated (has_lt linarith.comp_source) := sorry --non-trivial
lemma new_lemma_42604 (h0 : function.extfun (finset Type) (has_mem.mem (with_bot linarith.comp_source))) : @path_connected_space.{0} (with_bot.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_bot.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_bot.{0} linarith.comp_source)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_42605 (h0 : not (topological_space (complete_semilattice_Sup unsigned) -> false)) : @t0_space.{0} (complete_semilattice_Sup.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (complete_semilattice_Sup.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_42606 (h0 : ring (has_div to_additive.value_type)) : is_domain (has_div to_additive.value_type) := sorry --non-trivial
lemma new_lemma_42607 (h0 : not (complete_lattice (semiring linarith.comp) -> false)) : @is_compactly_generated.{0} (semiring.{0} linarith.comp) (@classical.by_contradiction'.{1} (complete_lattice.{0} (semiring.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_42608 (h0 : ring (denumerable linarith.comp_source)) : rank_condition (denumerable linarith.comp_source) := sorry --non-trivial
lemma new_lemma_42609 (h0 : complete_lattice (measurable_space (has_norm to_additive.value_type))) : complete_lattice.is_Sup_finite_compact (measurable_space (has_norm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_42610 (h0 : topological_space (normed_group (has_ssubset fun_info))) : t0_space (normed_group (has_ssubset fun_info)) := sorry --non-trivial
lemma new_lemma_42611 (h0 : complete_lattice (boolean_algebra (ring linarith.comp))) : is_compactly_generated (boolean_algebra (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_42612 (h0 : functor.add_const (ordered_comm_monoid (has_pos_part linarith.comp)) Type) : @has_exists_mul_of_le.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (has_pos_part.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_42613 (h0 : topological_space (bin_tree empty)) : loc_path_connected_space (bin_tree empty) := sorry --non-trivial
lemma new_lemma_42614 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (as_linear_order congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_42615 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @group.fg.{0} (ring.{0} linarith.comp) (@matrix.vec_empty.{0} (group.{0} (ring.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_42616 (h0 : list (comm_ring (has_norm to_additive.value_type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_42617 (h0 : function.extfun Type (functor.add_const (ring znum))) : @rank_condition.{0} znum (@functor.add_const.run.{0 0} (ring.{0} znum) (option.{0} (option.{0} unsigned)) (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} znum)) h0 (option.{0} (option.{0} unsigned))))  := sorry --non-trivial
lemma new_lemma_42618 (h1 : has_mem.mem (has_norm linarith.comp) has_emptyc.emptyc) : @normal_space.{0} (has_norm.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_norm.{0} linarith.comp) h1)  := sorry --non-trivial
lemma new_lemma_42619 (h0 : functor.add_const (group (partial_order num)) num) : @normalizer_condition.{0} (partial_order.{0} num) (@functor.add_const.run.{0 0} (group.{0} (partial_order.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_42620 (h0 : topological_space (boolean_algebra.core name)) : t0_space (boolean_algebra.core name) := sorry --non-trivial
lemma new_lemma_42621 (h1 : topological_space (comm_ring (has_nnnorm (has_nnnorm (has_nnnorm to_additive.value_type))))) : t0_space (comm_ring (has_nnnorm (has_nnnorm (has_nnnorm to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_42622 (h0 : filter (ring (finset linarith.comp))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_42623 (h1 : set (has_nnnorm (random_gen string_imp))) : set.finite h1 := sorry --non-trivial
lemma new_lemma_42624 (h0 : has_mem.mem (random_gen linarith.comp_source) has_emptyc.emptyc) : @locally_compact_space.{0} (random_gen.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (random_gen.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_42625 (h0 : add_group (with_bot (has_top unsigned))) : is_add_cyclic (with_bot (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_42626 (h0 : functor.add_const (topological_space (bin_tree empty)) empty) : @t1_space.{0} (bin_tree.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (bin_tree.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_42627 (h0 : functor.add_const (function.extfun Type topological_space) (has_neg_part name)) : @preirreducible_space.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (has_neg_part.{0} name) h0) (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_42628 (h0 : functor.add_const Prop (has_neg (has_to_string pos))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_42629 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (complete_distrib_lattice.{0} ennreal) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (complete_distrib_lattice.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_42630 (h0 : semiring (semiring (semiring (semiring num)))) : is_noetherian_ring (semiring (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_42631 (h0 : add_group (simple_graph (mul_one_class (mul_one_class reducibility_hints)))) : is_add_cyclic (simple_graph (mul_one_class (mul_one_class reducibility_hints))) := sorry --non-trivial
lemma new_lemma_42632 (h0 : topological_space (linear_order empty)) : totally_disconnected_space (linear_order empty) := sorry --non-trivial
lemma new_lemma_42633 (h0 : topological_space (has_top (random_gen fun_info))) : path_connected_space (has_top (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_42634 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (linear_ordered_semiring.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (linear_ordered_semiring.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_42635 (h0 : topological_space (has_lt (mul_one_class (mul_one_class char)))) : path_connected_space (has_lt (mul_one_class (mul_one_class char))) := sorry --non-trivial
lemma new_lemma_42636 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (left_cancel_monoid.{0} (semiring.{0} congr_arg_kind)) (@function.extfun_app.{2 1} Type ring.{0} h0 (left_cancel_monoid.{0} (semiring.{0} congr_arg_kind)))  := sorry --non-trivial
lemma new_lemma_42637 (h0 : finset (add_cancel_monoid (option num))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_42638 (h0 : not (topological_space (has_union num) -> false)) : @locally_compact_space.{0} (has_union.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (has_union.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_42639 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_42640 (h1 : topological_space (normed_field reducibility_hints)) : totally_disconnected_space (normed_field reducibility_hints) := sorry --non-trivial
lemma new_lemma_42641 (h0 : topological_space (canonically_ordered_comm_semiring empty)) : loc_path_connected_space (canonically_ordered_comm_semiring empty) := sorry --non-trivial
lemma new_lemma_42642 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (with_bot.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (with_bot.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_42643 (h0 : list (has_add (ring Type))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_42644 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_42645 (h0 : add_monoid (has_neg_part (comm_group (comm_group Type)))) : add_monoid.fg (has_neg_part (comm_group (comm_group Type))) := sorry --non-trivial
lemma new_lemma_42646 (h0 : group (canonically_ordered_add_monoid congr_arg_kind)) : is_cyclic (canonically_ordered_add_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_42647 (h0 : functor.add_const (finset Type) (ring (ring (has_Inf (finset linarith.comp))))) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_42648 (h0 : topological_space (simple_graph (ring (has_pos_part (has_add (finset Type)))))) : normal_space (simple_graph (ring (has_pos_part (has_add (finset Type))))) := sorry --non-trivial
lemma new_lemma_42649 (h0 : fin has_zero.zero) : @t1_space.{0} (canonically_linear_ordered_monoid.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (canonically_linear_ordered_monoid.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_42650 (h0 : functor.add_const (complete_lattice (bin_tree unsigned)) empty) : @is_atomistic.{0} (bin_tree.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (bin_tree.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_42651 (h0 : topological_space (semigroup (option pos))) : preirreducible_space (semigroup (option pos)) := sorry --non-trivial
lemma new_lemma_42652 (h0 : complete_lattice (linear_ordered_comm_ring (has_top congr_arg_kind))) : is_compactly_generated (linear_ordered_comm_ring (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_42653 (h0 : ring (left_cancel_semigroup (semiring (semiring empty)))) : strong_rank_condition (left_cancel_semigroup (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_42654 (h0 : functor.add_const (monoid (add_cancel_monoid environment.implicit_infer_kind)) environment.implicit_infer_kind) : @monoid.fg.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (monoid.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_42655 (h0 : ring (dlist (measurable_space (fintype (add_monoid char))))) : strong_rank_condition (dlist (measurable_space (fintype (add_monoid char)))) := sorry --non-trivial
lemma new_lemma_42656 (h0 : uniform_space (ring (has_add name))) : complete_space (ring (has_add name)) := sorry --non-trivial
lemma new_lemma_42657 (h0 : functor.add_const (topological_space (has_dist empty)) congr_arg_kind) : @loc_path_connected_space.{0} (has_dist.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_dist.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_42658 (h0 : semiring (partial_order num)) : is_noetherian_ring (partial_order num) := sorry --non-trivial
lemma new_lemma_42659 (h0 : functor.add_const (topological_space (has_neg ennreal)) unsigned) : @preconnected_space.{0} (has_neg.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_42660 (h0 : has_pos_part Type -> has_pos_part Type -> Prop) : transitive h0 := sorry --non-trivial
lemma new_lemma_42661 (h0 : add_group (normed_lattice_add_comm_group real)) : is_add_cyclic (normed_lattice_add_comm_group real) := sorry --non-trivial
lemma new_lemma_42662 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (has_dist.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_dist.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_42663 (h0 : ordered_add_comm_monoid (has_neg_part (option (mul_zero_class pos)))) : archimedean (has_neg_part (option (mul_zero_class pos))) := sorry --non-trivial
lemma new_lemma_42664 (h0 : ring (ring (option (option num)))) : is_domain (ring (option (option num))) := sorry --non-trivial
lemma new_lemma_42665 (h0 : complete_lattice (has_inner unsigned unsigned)) : is_compactly_generated (has_inner unsigned unsigned) := sorry --non-trivial
lemma new_lemma_42666 (h0 : finset (has_to_string (has_add (has_add name)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_42667 (h0 : complete_lattice (id (random_gen (random_gen string_imp)))) : complete_lattice.is_Sup_finite_compact (id (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_42668 (h0 : topological_space (normed_group (denumerable to_additive.value_type))) : t0_space (normed_group (denumerable to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_42669 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_bot.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_bot.{0} pos))  := sorry --non-trivial
lemma new_lemma_42670 (h0 : function.extfun Type (functor.add_const (ordered_comm_monoid ennreal))) : @has_exists_mul_of_le.{0} ennreal (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} ennreal) pos (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ordered_comm_monoid.{0} ennreal)) h0 pos))  := sorry --non-trivial
lemma new_lemma_42671 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (complete_distrib_lattice.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_42672 (h0 : not (complete_lattice (normed_group num) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (normed_group.{0} num) (@classical.by_contradiction'.{1} (complete_lattice.{0} (normed_group.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_42673 (h0 : uniform_space (add_group (has_union (has_union (has_union (has_union linarith.comp)))))) : separated_space (add_group (has_union (has_union (has_union (has_union linarith.comp))))) := sorry --non-trivial
lemma new_lemma_42674 (h1 : complete_lattice (semi_normed_comm_ring linarith.comp_source)) : complete_lattice.is_Sup_finite_compact (semi_normed_comm_ring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_42675 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_Inf Type)) Type) : @unique_factorization_monoid.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 1} (cancel_comm_monoid_with_zero.{1} (has_Inf.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_42676 (h0 : finset (semigroup (has_pos_part (has_pos_part (has_pos_part linarith.comp))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_42677 (h0 : semiring (has_norm linarith.comp_source)) (h1 : has_norm linarith.comp_source) : odd h1 := sorry --non-trivial
lemma new_lemma_42678 (h0 : group (comm_group (has_scalar linarith.comp Type))) : group.fg (comm_group (has_scalar linarith.comp Type)) := sorry --non-trivial
lemma new_lemma_42679 (h0 : topological_space (id linarith.comp)) : t0_space (id linarith.comp) := sorry --non-trivial
lemma new_lemma_42680 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (complete_linear_order.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (complete_linear_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_42681 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @t1_space.{0} (ordered_comm_monoid.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_monoid.{0} pos)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_42682 (h0 : topological_space (has_ssubset linarith.comp_source)) : irreducible_space (has_ssubset linarith.comp_source) := sorry --non-trivial
lemma new_lemma_42683 (h0 : functor.add_const (topological_space (has_star num)) unsigned) : @normal_space.{0} (has_star.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_42684 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_simple_group.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 group.{1}) (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_42685 (h0 : complete_lattice (boolean_algebra.core (has_add pos))) : is_compactly_generated (boolean_algebra.core (has_add pos)) := sorry --non-trivial
lemma new_lemma_42686 (h0 : topological_space (has_neg (has_add environment.implicit_infer_kind))) : locally_compact_space (has_neg (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_42687 (h0 : functor.add_const (add_group (has_add pos)) pos) : @is_add_cyclic.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (has_add.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_42688 (h0 : functor.add_const (function.extfun (Type 1) ordered_comm_monoid) name) : @has_exists_mul_of_le.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_comm_monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ordered_comm_monoid.{1}) name h0) (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_42689 (h0 : cancel_comm_monoid_with_zero (add_left_cancel_semigroup congr_arg_kind)) : unique_factorization_monoid (add_left_cancel_semigroup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_42690 (h0 : topological_space (has_zero (boolean_algebra (boolean_algebra unsigned)))) : preconnected_space (has_zero (boolean_algebra (boolean_algebra unsigned))) := sorry --non-trivial
lemma new_lemma_42691 (h0 : functor.add_const (filter (semigroup unsigned)) unsigned) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_42692 (h0 : ring (ring (finset Type))) : strong_rank_condition (ring (finset Type)) := sorry --non-trivial
lemma new_lemma_42693 (h1 : complete_lattice (id to_additive.value_type)) : is_compactly_generated (id to_additive.value_type) := sorry --non-trivial
lemma new_lemma_42694 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (add_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} h0 (add_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_42695 (h0 : group (left_cancel_monoid (semiring num))) : group.fg (left_cancel_monoid (semiring num)) := sorry --non-trivial
lemma new_lemma_42696 (h0 : ring (canonically_ordered_monoid (has_neg (has_neg pos)))) : rank_condition (canonically_ordered_monoid (has_neg (has_neg pos))) := sorry --non-trivial
lemma new_lemma_42697 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} (has_zero.{0} ennreal) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) (has_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_42698 (h0 : add_group (normed_group (has_inv linarith.comp_source))) : is_add_cyclic (normed_group (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_42699 (h0 : functor.add_const (ring (has_pos_part linarith.comp)) (has_pos_part linarith.comp)) : @is_principal_ideal_ring.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_pos_part.{0} linarith.comp)) (has_pos_part.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_42700 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @complete_space.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 uniform_space.{1}) (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_42701 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (complete_distrib_lattice.{0} real) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (complete_distrib_lattice.{0} real))  := sorry --non-trivial
lemma new_lemma_42702 (h0 : uniform_space Type) : separated_space Type := sorry --non-trivial
lemma new_lemma_42703 (h0 : functor.comp topological_space has_neg environment.implicit_infer_kind) : @preirreducible_space.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_42704 (h0 : group (pseudo_metric_space (option unsigned))) : is_simple_group (pseudo_metric_space (option unsigned)) := sorry --non-trivial
lemma new_lemma_42705 (h0 : semiring (measurable_space.dynkin_system unsigned)) : is_noetherian_ring (measurable_space.dynkin_system unsigned) := sorry --non-trivial
lemma new_lemma_42706 (h0 : function.extfun (Type 1) (functor.add_const (topological_space pos))) : @totally_disconnected_space.{0} pos (@functor.add_const.run.{0 1} (topological_space.{0} pos) Type (@function.extfun_app.{3 1} (Type 1) (functor.add_const.{0 1} (topological_space.{0} pos)) h0 Type))  := sorry --non-trivial
lemma new_lemma_42707 (h0 : group (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm to_additive.value_type))))) : is_cyclic (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_42708 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (group_with_zero.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (group_with_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_42709 (h0 : has_mem.mem (with_bot num) has_emptyc.emptyc) : @normal_space.{0} (with_bot.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_bot.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_42710 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (semigroup.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_42711 (h0 : topological_space (has_pos_part (has_neg pos))) : preirreducible_space (has_pos_part (has_neg pos)) := sorry --non-trivial
lemma new_lemma_42712 (h0 : functor.add_const (semiring (has_neg linarith.comp)) pos) : @is_noetherian_ring.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (semiring.{0} (has_neg.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_42713 (h0 : functor.add_const (function.extfun (Type 1) topological_space) Type) : @path_connected_space.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) Type h0) (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_42714 (h0 : add_group (has_add (add_cancel_monoid (has_nndist name)))) : is_add_cyclic (has_add (add_cancel_monoid (has_nndist name))) := sorry --non-trivial
lemma new_lemma_42715 (h2 : ring (denumerable (has_ssubset linarith.comp_source))) : is_domain (denumerable (has_ssubset linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_42716 (h0 : add_monoid (has_inter (option (option empty)))) : add_monoid.fg (has_inter (option (option empty))) := sorry --non-trivial
lemma new_lemma_42717 (h0 : complete_lattice (has_Inf (has_Inf (has_Inf real)))) : complete_lattice.is_Sup_finite_compact (has_Inf (has_Inf (has_Inf real))) := sorry --non-trivial
lemma new_lemma_42718 (h0 : topological_space (canonically_ordered_comm_semiring (has_add ennreal))) : topological_space.separable_space (canonically_ordered_comm_semiring (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_42719 (h0 : has_mem.mem (with_one (has_norm empty)) has_emptyc.emptyc) : @path_connected_space.{0} (with_one.{0} (has_norm.{0} empty)) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_one.{0} (has_norm.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_42720 (h0 : ring (uniform_space (mul_one_class (mul_one_class (mul_one_class fun_info))))) : rank_condition (uniform_space (mul_one_class (mul_one_class (mul_one_class fun_info)))) := sorry --non-trivial
lemma new_lemma_42721 (h0 : uniform_space (metric_space to_additive.value_type)) : complete_space (metric_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_42722 (h0 : group (id (semiring num))) : group.fg (id (semiring num)) := sorry --non-trivial
lemma new_lemma_42723 (h0 : function.extfun Type topological_space) : @t1_space.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_42724 (h0 : semiring (complete_distrib_lattice (has_add pos))) : is_noetherian_ring (complete_distrib_lattice (has_add pos)) := sorry --non-trivial
lemma new_lemma_42725 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @has_exists_mul_of_le.{1} (normed_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_comm_monoid.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ordered_comm_monoid.{1}) (normed_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_42726 (h0 : list (canonically_ordered_add_monoid congr_arg_kind)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_42727 (h0 : set (semi_normed_comm_ring (mul_one_class linarith.comp_source))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_42728 (h0 : ring (ring (has_add Type))) : is_domain (ring (has_add Type)) := sorry --non-trivial
lemma new_lemma_42729 (h0 : ordered_add_comm_monoid (has_pos_part (has_neg (has_Inf (has_neg name))))) : archimedean (has_pos_part (has_neg (has_Inf (has_neg name)))) := sorry --non-trivial
lemma new_lemma_42730 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (ring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} name))  := sorry --non-trivial
lemma new_lemma_42731 (h0 : group (has_neg (has_neg (boolean_algebra (boolean_algebra (has_neg Type)))))) : is_cyclic (has_neg (has_neg (boolean_algebra (boolean_algebra (has_neg Type))))) := sorry --non-trivial
lemma new_lemma_42732 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_edist.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_edist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_42733 (h0 : group enat) : is_cyclic enat := sorry --non-trivial
lemma new_lemma_42734 (h2 : complete_lattice (with_one string_imp)) : is_atomistic (with_one string_imp) := sorry --non-trivial
lemma new_lemma_42735 (h0 : functor.add_const (group (ring linarith.comp)) pos) : @is_cyclic.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (ring.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_42736 (h0 : monoid (has_zero (ring (finset name)))) : monoid.fg (has_zero (ring (finset name))) := sorry --non-trivial
lemma new_lemma_42737 (h0 : group (random_gen (random_gen string_imp))) : normalizer_condition (random_gen (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_42738 (h0 : topological_space (normed_field linarith.ineq)) : totally_disconnected_space (normed_field linarith.ineq) := sorry --non-trivial
lemma new_lemma_42739 (h0 : complete_lattice (ordered_comm_ring char)) : is_compactly_generated (ordered_comm_ring char) := sorry --non-trivial
lemma new_lemma_42740 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_to_string.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_42741 (h0 : topological_space (complete_semilattice_Sup to_additive.value_type)) : t0_space (complete_semilattice_Sup to_additive.value_type) := sorry --non-trivial
lemma new_lemma_42742 (h0 : add_monoid (boolean_algebra.core (has_Inf linarith.comp))) : add_monoid.fg (boolean_algebra.core (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_42743 (h0 : finset (normed_lattice_add_comm_group pos)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_42744 (h0 : uniform_space (has_norm linarith.ineq)) : complete_space (has_norm linarith.ineq) := sorry --non-trivial
lemma new_lemma_42745 (h0 : add_group (with_one (random_gen empty))) : is_add_cyclic (with_one (random_gen empty)) := sorry --non-trivial
lemma new_lemma_42746 (h0 : functor.add_const (monoid (boolean_algebra.core linarith.comp)) Type) : @monoid.fg.{0} (boolean_algebra.core.{0} linarith.comp) (@functor.add_const.run.{0 1} (monoid.{0} (boolean_algebra.core.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_42747 (h0 : set (has_div string_imp)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_42748 (h0 : functor.add_const (list (has_to_string pos)) name) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_42749 (h0 : ring (id congr_arg_kind)) : is_domain (id congr_arg_kind) := sorry --non-trivial
lemma new_lemma_42750 (h2 : complete_lattice (has_div linarith.comp_source)) : complete_lattice.is_Sup_finite_compact (has_div linarith.comp_source) := sorry --non-trivial
lemma new_lemma_42751 (h0 : function.extfun Type (functor.comp topological_space boolean_algebra.core)) : @sequential_space.{0} (boolean_algebra.core.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} boolean_algebra.core.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} boolean_algebra.core.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_42752 (h0 : uniform_space (has_sub (semiring empty))) : complete_space (has_sub (semiring empty)) := sorry --non-trivial
lemma new_lemma_42753 (h0 : topological_space (plift empty)) : totally_disconnected_space (plift empty) := sorry --non-trivial
lemma new_lemma_42754 (h0 : topological_space (generalized_boolean_algebra (sub_neg_monoid (ordered_comm_monoid pos)))) : sequential_space (generalized_boolean_algebra (sub_neg_monoid (ordered_comm_monoid pos))) := sorry --non-trivial
lemma new_lemma_42755 (h0 : topological_space (cancel_monoid num)) : totally_disconnected_space (cancel_monoid num) := sorry --non-trivial
lemma new_lemma_42756 (h0 : group (has_to_string (has_add pos))) : normalizer_condition (has_to_string (has_add pos)) := sorry --non-trivial
lemma new_lemma_42757 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (finset.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} name))  := sorry --non-trivial
lemma new_lemma_42758 (h0 : add_monoid (monoid (option unsigned))) : add_monoid.fg (monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_42759 (h0 : topological_space (has_pos_part (has_neg (has_neg pos)))) : discrete_topology (has_pos_part (has_neg (has_neg pos))) := sorry --non-trivial
lemma new_lemma_42760 (h0 : topological_space (with_bot (with_bot (random_gen congr_arg_kind)))) : irreducible_space (with_bot (with_bot (random_gen congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_42761 (h0 : topological_space (has_to_string (has_neg (has_neg (has_neg_part pos))))) : loc_path_connected_space (has_to_string (has_neg (has_neg (has_neg_part pos)))) := sorry --non-trivial
lemma new_lemma_42762 (h0 : functor.add_const (topological_space (comm_monoid unsigned)) congr_arg_kind) : @irreducible_space.{0} (comm_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_monoid.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_42763 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 int) := sorry --non-trivial
lemma new_lemma_42764 (h0 h1 : multiset (non_unital_non_assoc_semiring (mul_one_class reducibility_hints))) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_42765 (h0 : semiring (simple_graph (has_add (has_nndist pos)))) : is_noetherian_ring (simple_graph (has_add (has_nndist pos))) := sorry --non-trivial
lemma new_lemma_42766 (h0 : monoid (has_to_string (finset environment.implicit_infer_kind))) : monoid.fg (has_to_string (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_42767 (h0 : not (function.extfun Type monoid -> false)) : @monoid.fg.{0} (semiring.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type monoid.{0}) h0) (semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_42768 (h0 : group (canonically_ordered_comm_semiring name)) : is_cyclic (canonically_ordered_comm_semiring name) := sorry --non-trivial
lemma new_lemma_42769 (h0 : finset (plift (semiring congr_arg_kind))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_42770 (h0 : topological_space (semigroup (finset (ring (finset name))))) : irreducible_space (semigroup (finset (ring (finset name)))) := sorry --non-trivial
lemma new_lemma_42771 (h0 : ring (has_nnnorm string.iterator_imp)) : is_domain (has_nnnorm string.iterator_imp) := sorry --non-trivial
lemma new_lemma_42772 (h0 : group (finset (has_add ennreal))) : is_simple_group (finset (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_42773 (h0 : filter (has_neg unsigned)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_42774 (h0 : topological_space (normed_comm_ring Type)) : sequential_space (normed_comm_ring Type) := sorry --non-trivial
lemma new_lemma_42775 (h0 : functor.add_const (ring (pseudo_metric_space unsigned)) unsigned) : @is_principal_ideal_ring.{0} (pseudo_metric_space.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (pseudo_metric_space.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_42776 (h0 : option Prop) (h1 : functor.add_const Prop pos) : option.get_or_else h0 (functor.add_const.run h1) := sorry --non-trivial
lemma new_lemma_42777 (h0 : functor.add_const (topological_space (pseudo_metric_space name)) (option name)) : @t0_space.{0} (pseudo_metric_space.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (pseudo_metric_space.{0} name)) (option.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_42778 (h0 : topological_space (has_compl (mul_one_class fun_info))) : totally_disconnected_space (has_compl (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_42779 (h0 : uniform_space (measurable_space (random_gen linarith.comp_source))) : complete_space (measurable_space (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_42780 (h0 : topological_space (fintype linarith.comp_source)) : t0_space (fintype linarith.comp_source) := sorry --non-trivial
lemma new_lemma_42781 (h0 : topological_space (semi_normed_comm_ring (mul_one_class ereal))) : path_connected_space (semi_normed_comm_ring (mul_one_class ereal)) := sorry --non-trivial
lemma new_lemma_42782 (h3 : topological_space fun_info) : totally_disconnected_space fun_info := sorry --non-trivial
lemma new_lemma_42783 (h0 : not (function.extfun (Type 1) add_group -> false)) : @is_add_cyclic.{1} (plift.{1} empty) (@function.extfun_app.{3 2} (Type 1) add_group.{1} (@classical.by_contradiction'.{3} (function.extfun.{3 2} (Type 1) add_group.{1}) h0) (plift.{1} empty))  := sorry --non-trivial
lemma new_lemma_42784 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (add_semigroup.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_42785 (h0 : complete_lattice (semiring (semiring empty))) : complete_lattice.is_Sup_finite_compact (semiring (semiring empty)) := sorry --non-trivial
lemma new_lemma_42786 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_42787 (h3 : topological_space (encodable linarith.comp_source)) : path_connected_space (encodable linarith.comp_source) := sorry --non-trivial
lemma new_lemma_42788 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (has_inv.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_inv.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_42789 (h0 : topological_space (has_zero (mul_zero_class ennreal))) : irreducible_space (has_zero (mul_zero_class ennreal)) := sorry --non-trivial
lemma new_lemma_42790 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} (has_one.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (has_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_42791 (h0 : uniform_space (semiring (semiring (semiring (semiring num))))) : complete_space (semiring (semiring (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_42792 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @t1_space.{0} (has_to_string.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (has_to_string.{0} name))  := sorry --non-trivial
lemma new_lemma_42793 (h0 : topological_space (ordered_comm_ring (ring pos))) : irreducible_space (ordered_comm_ring (ring pos)) := sorry --non-trivial
lemma new_lemma_42794 (h0 : topological_space (has_one (semiring (semiring linarith.comp)))) : totally_separated_space (has_one (semiring (semiring linarith.comp))) := sorry --non-trivial
lemma new_lemma_42795 (h0 : topological_space (has_top (has_norm to_additive.value_type))) : irreducible_space (has_top (has_norm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_42796 (h0 : ring (has_sdiff num)) : strong_rank_condition (has_sdiff num) := sorry --non-trivial
lemma new_lemma_42797 (h0 : function.extfun (Type 1) topological_space) : @sequential_space.{1} (ordered_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (ordered_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_42798 (h0 : uniform_space (comm_monoid (option congr_arg_kind))) : complete_space (comm_monoid (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_42799 (h0 : topological_space (semigroup (has_neg_part environment.implicit_infer_kind))) : totally_separated_space (semigroup (has_neg_part environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_42800 (h0 : add_monoid (linear_ordered_field (has_add Type))) : add_monoid.fg (linear_ordered_field (has_add Type)) := sorry --non-trivial
lemma new_lemma_42801 (h0 : prod (measure_theory.measure_space (has_top unsigned)) (measure_theory.measure_space (has_top unsigned))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_42802 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} linarith.comp (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) linarith.comp)  := sorry --non-trivial
lemma new_lemma_42803 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (normed_lattice_add_comm_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (normed_lattice_add_comm_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_42804 (h0 : not (group (complete_linear_order unsigned) -> false)) : @normalizer_condition.{0} (complete_linear_order.{0} unsigned) (@classical.by_contradiction'.{1} (group.{0} (complete_linear_order.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_42805 (h0 : topological_space (random_gen (has_top fun_info))) : totally_separated_space (random_gen (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_42806 (h0 : group (semigroup (has_add (finset linarith.comp)))) : group.fg (semigroup (has_add (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_42807 (h0 : uniform_space (comm_ring fun_info)) : complete_space (comm_ring fun_info) := sorry --non-trivial
lemma new_lemma_42808 (h0 : topological_space (generalized_boolean_algebra (sub_neg_monoid Type))) : totally_disconnected_space (generalized_boolean_algebra (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_42809 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (mul_zero_class.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (mul_zero_class.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_42810 (h0 : list (has_inv string_imp)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_42811 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @t1_space.{1} (canonically_ordered_comm_semiring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (canonically_ordered_comm_semiring.{1} Type))  := sorry --non-trivial
lemma new_lemma_42812 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_emptyc.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_emptyc.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_42813 (h0 : not (add_monoid (option congr_arg_kind) -> false)) : @add_monoid.fg.{0} (option.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (add_monoid.{0} (option.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_42814 (h0 : functor.add_const (finset (generalized_boolean_algebra name)) (has_add (finset pos))) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_42815 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (generalized_boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (generalized_boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_42816 (h0 : topological_space (bin_tree (semiring num))) : discrete_topology (bin_tree (semiring num)) := sorry --non-trivial
lemma new_lemma_42817 (h0 : topological_space (canonically_ordered_monoid Type)) : normal_space (canonically_ordered_monoid Type) := sorry --non-trivial
lemma new_lemma_42818 (h0 : add_monoid (finset (has_add ennreal))) : add_monoid.fg (finset (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_42819 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_ssubset.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_ssubset.{0} empty))  := sorry --non-trivial
lemma new_lemma_42820 (h0 : set (add_comm_semigroup (add_comm_semigroup enat))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_42821 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_42822 (h0 : topological_space (add_cancel_monoid (option ennreal))) : normal_space (add_cancel_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_42823 (h0 : topological_space (has_add (has_add (finset pos)))) : normal_space (has_add (has_add (finset pos))) := sorry --non-trivial
lemma new_lemma_42824 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (canonically_linear_ordered_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (canonically_linear_ordered_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_42825 (h0 : function.extfun Type option) (h1 : Prop) : option.get_or_else (function.extfun_app h0 Prop) h1 := sorry --non-trivial
lemma new_lemma_42826 (h2 : topological_space (has_compl to_additive.value_type)) : path_connected_space (has_compl to_additive.value_type) := sorry --non-trivial
lemma new_lemma_42827 (h0 : not (add_monoid (has_sub num) -> false)) : @add_monoid.fg.{0} (has_sub.{0} num) (@classical.by_contradiction'.{1} (add_monoid.{0} (has_sub.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_42828 (h0 : ordered_add_comm_monoid (canonically_ordered_monoid name)) : archimedean (canonically_ordered_monoid name) := sorry --non-trivial
lemma new_lemma_42829 (h0 : list (mul_zero_class environment.implicit_infer_kind)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_42830 (h0 : has_mem.mem (with_one linarith.comp_source) has_emptyc.emptyc) : @irreducible_space.{0} (with_one.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_one.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_42831 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (ring.{0} name) (@function.extfun_app.{2 1} Type add_group.{0} h0 (ring.{0} name))  := sorry --non-trivial
lemma new_lemma_42832 (h0 : has_mem.mem (semiring linarith.comp) has_emptyc.emptyc) : filter.ne_bot (finset.pi.empty filter (semiring linarith.comp) h0) := sorry --non-trivial
lemma new_lemma_42833 (h0 : topological_space (has_top (has_nnnorm (has_nnnorm linarith.ineq)))) : t0_space (has_top (has_nnnorm (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_42834 (h0 : not (group (has_union unsigned) -> false)) : @is_cyclic.{0} (has_union.{0} unsigned) (@classical.by_contradiction'.{1} (group.{0} (has_union.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_42835 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (add_semigroup.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_42836 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (semiring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (semiring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_42837 (h0 : ring (comm_ring (metric_space (metric_space to_additive.value_type)))) : rank_condition (comm_ring (metric_space (metric_space to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_42838 (h0 : ring (cancel_monoid (has_to_string unsigned))) : is_principal_ideal_ring (cancel_monoid (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_42839 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_compl.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_compl.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_42840 (h0 : list (has_bot (ordered_comm_monoid real))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_42841 (h0 : topological_space (distrib (has_nnnorm (random_gen (has_nnnorm reducibility_hints))))) : totally_disconnected_space (distrib (has_nnnorm (random_gen (has_nnnorm reducibility_hints)))) := sorry --non-trivial
lemma new_lemma_42842 (h0 : topological_space (plift unsigned)) : discrete_topology (plift unsigned) := sorry --non-trivial
lemma new_lemma_42843 (h0 : function.extfun Type group) : @normalizer_condition.{0} (cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} h0 (cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_42844 (h0 : complete_lattice (canonically_ordered_monoid (has_add Type))) : is_compactly_generated (canonically_ordered_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_42845 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (has_zero.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_42846 (h0 : ring (has_inv linarith.comp_source)) : is_domain (has_inv linarith.comp_source) := sorry --non-trivial
lemma new_lemma_42847 (h0 : functor.add_const (complete_lattice (has_edist unsigned)) empty) : @complete_lattice.is_Sup_finite_compact.{0} (has_edist.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_edist.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_42848 (h0 : ordered_add_comm_monoid (ring (cancel_monoid Type))) : archimedean (ring (cancel_monoid Type)) := sorry --non-trivial
lemma new_lemma_42849 (h2 : not (ring congr_arg_kind -> false)) : @is_domain.{0} congr_arg_kind (@classical.by_contradiction'.{1} (ring.{0} congr_arg_kind) h2)  := sorry --non-trivial
lemma new_lemma_42850 (h0 : topological_space (normed_lattice_add_comm_group (has_Inf Type))) : discrete_topology (normed_lattice_add_comm_group (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_42851 (h0 : monoid (has_to_string (ring Type))) : monoid.fg (has_to_string (ring Type)) := sorry --non-trivial
lemma new_lemma_42852 (h0 : function.extfun (Type 1) topological_space) : @preconnected_space.{1} (complete_distrib_lattice.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (complete_distrib_lattice.{1} Type))  := sorry --non-trivial
lemma new_lemma_42853 (h0 : ordered_comm_monoid (ring (option (option pos)))) : has_exists_mul_of_le (ring (option (option pos))) := sorry --non-trivial
lemma new_lemma_42854 (h0 : topological_space (mul_zero_class (has_nndist (has_nndist name)))) : totally_disconnected_space (mul_zero_class (has_nndist (has_nndist name))) := sorry --non-trivial
lemma new_lemma_42855 (h1 : ring (denumerable to_additive.value_type)) : is_domain (denumerable to_additive.value_type) := sorry --non-trivial
lemma new_lemma_42856 (h0 : ring (semi_normed_comm_ring reducibility_hints)) : strong_rank_condition (semi_normed_comm_ring reducibility_hints) := sorry --non-trivial
lemma new_lemma_42857 (h0 : topological_space (with_bot (has_norm (random_gen (has_norm (has_norm fun_info)))))) : t0_space (with_bot (has_norm (random_gen (has_norm (has_norm fun_info))))) := sorry --non-trivial
lemma new_lemma_42858 (h0 : complete_lattice (ordered_cancel_add_comm_monoid (option ennreal))) : complete_lattice.is_Sup_finite_compact (ordered_cancel_add_comm_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_42859 (h4 : complete_lattice (semi_normed_comm_ring to_additive.value_type)) : is_compactly_generated (semi_normed_comm_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_42860 (h0 : functor.add_const (topological_space (add_cancel_monoid linarith.comp)) (ring environment.implicit_infer_kind)) : @t0_space.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} linarith.comp)) (ring.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_42861 (h0 : topological_space (boolean_algebra (finset (has_pos_part Type)))) : totally_disconnected_space (boolean_algebra (finset (has_pos_part Type))) := sorry --non-trivial
lemma new_lemma_42862 (h0 : functor.add_const (ring (has_add linarith.comp)) environment.implicit_infer_kind) : @rank_condition.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_add.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_42863 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (normed_linear_ordered_group.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} h0 (normed_linear_ordered_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_42864 (h0 : list (complete_distrib_lattice pos)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_42865 (h0 : uniform_space (random_gen (has_inv to_additive.value_type))) : complete_space (random_gen (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_42866 (h0 : functor.add_const (topological_space (has_zero name)) linarith.comp) : @t1_space.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_42867 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (has_add.{0} ennreal) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (has_add.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_42868 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : complete_lattice.is_Sup_finite_compact (measurable_space fun_info) := sorry --non-trivial
lemma new_lemma_42869 (h0 : fin has_zero.zero) : @complete_space.{0} (sub_neg_monoid.{0} pos) (@matrix.vec_empty.{0} (uniform_space.{0} (sub_neg_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_42870 (h0 : topological_space (has_add (add_comm_monoid name))) : preirreducible_space (has_add (add_comm_monoid name)) := sorry --non-trivial
lemma new_lemma_42871 (h0 : functor.add_const (group (boolean_algebra.core Type)) name) : @group.fg.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (boolean_algebra.core.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_42872 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (has_one.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (has_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_42873 (h0 : ring (has_norm (random_gen (random_gen linarith.ineq)))) : rank_condition (has_norm (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_42874 (h0 : functor.add_const (filter (has_nndist pos)) environment.implicit_infer_kind) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_42875 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_42876 (h0 : cancel_comm_monoid_with_zero (canonically_ordered_comm_semiring pos)) : unique_factorization_monoid (canonically_ordered_comm_semiring pos) := sorry --non-trivial
lemma new_lemma_42877 (h0 : add_group (distrib (mul_one_class reducibility_hints))) : is_add_cyclic (distrib (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_42878 (h0 : functor.add_const (ordered_comm_monoid (semigroup linarith.comp)) pos) : @has_exists_mul_of_le.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (semigroup.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_42879 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_42880 (h0 : function.extfun Type topological_space) : discrete_topology nnreal := sorry --non-trivial
lemma new_lemma_42881 (h0 : uniform_space (with_one (semiring linarith.comp))) : separated_space (with_one (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_42882 (h0 : topological_space (add_comm_monoid (comm_group (comm_group (comm_group pos))))) : t1_space (add_comm_monoid (comm_group (comm_group (comm_group pos)))) := sorry --non-trivial
lemma new_lemma_42883 (h0 : topological_space (id (semiring (semiring unsigned)))) : path_connected_space (id (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_42884 (h0 : list (has_pos_part (boolean_algebra.core (ring linarith.comp)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_42885 (h0 : topological_space (mul_zero_class (finset (has_nndist name)))) : t0_space (mul_zero_class (finset (has_nndist name))) := sorry --non-trivial
lemma new_lemma_42886 (h0 : uniform_space (normed_field (mul_one_class string.iterator_imp))) : complete_space (normed_field (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_42887 (h0 : complete_lattice (has_append to_additive.value_type)) : complete_lattice.is_Sup_finite_compact (has_append to_additive.value_type) := sorry --non-trivial
lemma new_lemma_42888 (h0 : ring (has_zero (finset (finset environment.implicit_infer_kind)))) : strong_rank_condition (has_zero (finset (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_42889 (h0 : group (normed_group (random_gen (random_gen (random_gen to_additive.value_type))))) : is_cyclic (normed_group (random_gen (random_gen (random_gen to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_42890 (h0 : functor.add_const (topological_space (has_to_string pos)) linarith.comp) : @locally_compact_space.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_42891 (h0 : list (has_Inf (has_pos_part pos))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_42892 (h0 : group (has_top (random_gen (random_gen (random_gen to_additive.value_type))))) : group.fg (has_top (random_gen (random_gen (random_gen to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_42893 (h0 : functor.add_const (filter (add_cancel_monoid Type)) Type) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_42894 (h0 : topological_space (has_to_string (has_nndist (option ennreal)))) : normal_space (has_to_string (has_nndist (option ennreal))) := sorry --non-trivial
lemma new_lemma_42895 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (complete_linear_order.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (complete_linear_order.{0} num))  := sorry --non-trivial
lemma new_lemma_42896 (h0 : not (filter (has_one num) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_42897 (h0 : complete_lattice (distrib linarith.ineq)) : complete_lattice.is_Sup_finite_compact (distrib linarith.ineq) := sorry --non-trivial
lemma new_lemma_42898 (h0 : Type) (h1 : eq Prop h0) (h2 : h0) : id (eq.mpr h1 h2) := sorry --non-trivial
lemma new_lemma_42899 (h0 : cancel_comm_monoid_with_zero (add_group empty)) (h1 : filter (gcd_monoid (add_group empty))) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_42900 (h0 : functor.add_const (function.extfun (Type 1) topological_space) (ordered_ring name)) : @irreducible_space.{1} Type (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) (ordered_ring.{0} name) h0) Type)  := sorry --non-trivial
lemma new_lemma_42901 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (complete_semilattice_Sup.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_semilattice_Sup.{0} empty))  := sorry --non-trivial
lemma new_lemma_42902 (h0 : topological_space (ring (ring (has_neg_part linarith.comp)))) : normal_space (ring (ring (has_neg_part linarith.comp))) := sorry --non-trivial
lemma new_lemma_42903 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (linear_ordered_add_comm_group.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 group.{0}) (linear_ordered_add_comm_group.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_42904 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem monoid)) : @monoid.fg.{0} (has_top.{0} num) (@function.extfun_app.{2 1} Type monoid.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) monoid.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) monoid.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_top.{0} num))  := sorry --non-trivial
lemma new_lemma_42905 (h0 : topological_space (has_nnnorm environment.projection_info)) (h1 : set (set (has_nnnorm environment.projection_info))) : topological_space.is_topological_basis h1 := sorry --non-trivial
lemma new_lemma_42906 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (has_add.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_add.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_42907 (h0 : topological_space (has_nndist (finset environment.implicit_infer_kind))) : normal_space (has_nndist (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_42908 (h0 : topological_space (linear_ordered_add_comm_group (random_gen linarith.ineq))) : totally_disconnected_space (linear_ordered_add_comm_group (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_42909 (h0 : functor.add_const (topological_space (has_compl to_additive.value_type)) linarith.ineq) : @t0_space.{0} (has_compl.{0} to_additive.value_type) (@functor.add_const.run.{0 0} (topological_space.{0} (has_compl.{0} to_additive.value_type)) linarith.ineq h0)  := sorry --non-trivial
lemma new_lemma_42910 (h0 : ring (distrib (random_gen reducibility_hints))) : rank_condition (distrib (random_gen reducibility_hints)) := sorry --non-trivial
lemma new_lemma_42911 (h0 : topological_space (mul_zero_class (has_add (finset ennreal)))) : topological_space.separable_space (mul_zero_class (has_add (finset ennreal))) := sorry --non-trivial
lemma new_lemma_42912 (h0 : functor.add_const (cancel_comm_monoid_with_zero (ring pos)) Type) : @unique_factorization_monoid.{0} (ring.{0} pos) (@functor.add_const.run.{0 1} (cancel_comm_monoid_with_zero.{0} (ring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_42913 (h1 : ring (mul_one_class (normed_field (mul_one_class (normed_field linarith.ineq))))) : is_domain (mul_one_class (normed_field (mul_one_class (normed_field linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_42914 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (preorder unsigned)) := sorry --non-trivial
lemma new_lemma_42915 (h0 : function.extfun nat fin) : @strong_rank_condition.{1} (canonically_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (canonically_ordered_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_42916 (h0 : uniform_space (has_norm (semiring (semiring (semiring unsigned))))) : separated_space (has_norm (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_42917 (h0 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} (with_bot.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (with_bot.{0} empty))  := sorry --non-trivial
lemma new_lemma_42918 (h0 : set (semi_normed_comm_ring (mul_one_class (mul_one_class char)))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_42919 (h0 : functor.add_const (group (normed_comm_ring Type)) pos) : @is_simple_group.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (normed_comm_ring.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_42920 (h0 : topological_space (pseudo_metric_space num)) : locally_compact_space (pseudo_metric_space num) := sorry --non-trivial
lemma new_lemma_42921 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @regular_space.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_42922 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (measure_theory.measure_space num)) := sorry --non-trivial
lemma new_lemma_42923 (h0 : topological_space (normed_comm_ring (has_add name))) : irreducible_space (normed_comm_ring (has_add name)) := sorry --non-trivial
lemma new_lemma_42924 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_42925 (h0 : ring (add_cancel_monoid (finset ennreal))) : rank_condition (add_cancel_monoid (finset ennreal)) := sorry --non-trivial
lemma new_lemma_42926 (h0 : list (linear_ordered_add_comm_group (has_inv (has_inv (dlist to_additive.value_type))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_42927 (h0 : functor.add_const (topological_space (is_R_or_C unsigned)) empty) : @t0_space.{0} (is_R_or_C.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (is_R_or_C.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_42928 (h0 : function.extfun Type ring) : @is_domain.{0} (boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_42929 (h0 : group (normed_comm_ring (finset ennreal))) : is_cyclic (normed_comm_ring (finset ennreal)) := sorry --non-trivial
lemma new_lemma_42930 (h0 : list (add_cancel_monoid (ring Type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_42931 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} (semiring.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_42932 (h0 : topological_space (add_comm_monoid environment.implicit_infer_kind)) : discrete_topology (add_comm_monoid environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_42933 (h0 : topological_space (normed_lattice_add_comm_group (has_add (has_Inf real)))) : preirreducible_space (normed_lattice_add_comm_group (has_add (has_Inf real))) := sorry --non-trivial
lemma new_lemma_42934 (h0 : functor.add_const (ring (has_to_string environment.implicit_infer_kind)) pos) : @strong_rank_condition.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (has_to_string.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_42935 (h0 : ring (semigroup (has_pos_part linarith.comp))) : is_domain (semigroup (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_42936 (h0 : group (complete_semilattice_Sup (has_nnnorm (has_nnnorm (has_nnnorm linarith.comp_source))))) : group.fg (complete_semilattice_Sup (has_nnnorm (has_nnnorm (has_nnnorm linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_42937 (h0 : function.extfun Type topological_space) : irreducible_space nnreal := sorry --non-trivial
lemma new_lemma_42938 (h0 : group (plift (add_cancel_monoid unsigned))) : is_cyclic (plift (add_cancel_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_42939 (h0 : topological_space (has_nndist unsigned)) : regular_space (has_nndist unsigned) := sorry --non-trivial
lemma new_lemma_42940 (h0 : not (function.extfun Type filter -> false)) : filter.ne_bot (function.extfun_app (classical.by_contradiction' h0) unsigned) := sorry --non-trivial
lemma new_lemma_42941 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (finset.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (finset.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_42942 (h0 : filter (boolean_algebra (semigroup Type))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_42943 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (denumerable.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (denumerable.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_42944 (h0 : list Prop) (h1 : sym2 (list Prop)) (h2 : has_mem.mem h0 (id h1)) : list.head (sym2.mem.other h2) := sorry --non-trivial
lemma new_lemma_42945 (h0 : function.extfun Type topological_space) : @t0_space.{0} (add_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_42946 (h0 : topological_space (semi_normed_group unsigned)) : discrete_topology (semi_normed_group unsigned) := sorry --non-trivial
lemma new_lemma_42947 (h0 : topological_space (finset (ring environment.implicit_infer_kind))) : totally_separated_space (finset (ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_42948 (h0 : list (bin_tree empty)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_42949 (h0 : ring (has_add (finset (has_neg (has_neg linarith.comp))))) : is_domain (has_add (finset (has_neg (has_neg linarith.comp)))) := sorry --non-trivial
lemma new_lemma_42950 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_42951 (h0 : ring (has_Inf (finset pos))) : is_domain (has_Inf (finset pos)) := sorry --non-trivial
lemma new_lemma_42952 (h0 : uniform_space (bin_tree (option unsigned))) : complete_space (bin_tree (option unsigned)) := sorry --non-trivial
lemma new_lemma_42953 (h0 : functor.add_const (add_monoid (has_nndist environment.implicit_infer_kind)) pos) : @add_monoid.fg.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_nndist.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_42954 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem complete_lattice)) : @complete_lattice.is_Sup_finite_compact.{0} empty (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) complete_lattice.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) empty)  := sorry --non-trivial
lemma new_lemma_42955 (h0 : functor.add_const (complete_lattice (boolean_algebra.core pos)) pos) : @complete_lattice.is_Sup_finite_compact.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (boolean_algebra.core.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_42956 (h0 : functor.add_const (add_monoid (add_comm_monoid num)) (option ennreal)) : @add_monoid.fg.{0} (add_comm_monoid.{0} num) (@functor.add_const.run.{0 0} (add_monoid.{0} (add_comm_monoid.{0} num)) (option.{0} ennreal) h0)  := sorry --non-trivial
lemma new_lemma_42957 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_to_string.{0} real) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_to_string.{0} real))  := sorry --non-trivial
lemma new_lemma_42958 (h0 : topological_space (has_add pos)) : topological_space.separable_space (has_add pos) := sorry --non-trivial
lemma new_lemma_42959 (h0 : topological_space (has_add (has_neg name))) : totally_separated_space (has_add (has_neg name)) := sorry --non-trivial
lemma new_lemma_42960 (h0 : semiring (linear_ordered_semiring (add_group linarith.comp))) : is_noetherian_ring (linear_ordered_semiring (add_group linarith.comp)) := sorry --non-trivial
lemma new_lemma_42961 (h0 : topological_space (option (option (option (option name))))) : totally_separated_space (option (option (option (option name)))) := sorry --non-trivial
lemma new_lemma_42962 (h0 : topological_space (complete_distrib_lattice name)) : preirreducible_space (complete_distrib_lattice name) := sorry --non-trivial
lemma new_lemma_42963 (h0 : complete_lattice (complete_linear_order num)) : is_compactly_generated (complete_linear_order num) := sorry --non-trivial
lemma new_lemma_42964 (h0 : ring (boolean_algebra (has_to_string linarith.comp))) : is_domain (boolean_algebra (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_42965 (h0 : topological_space (ring (has_neg name))) : t1_space (ring (has_neg name)) := sorry --non-trivial
lemma new_lemma_42966 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (has_add.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} real))  := sorry --non-trivial
lemma new_lemma_42967 (h0 h1 : multiset (add_comm_semigroup reducibility_hints)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_42968 (h0 : ordered_add_comm_monoid (semigroup (option name))) : archimedean (semigroup (option name)) := sorry --non-trivial
lemma new_lemma_42969 (h0 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} (measurable_space.dynkin_system.{0} num) (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h0) (measurable_space.dynkin_system.{0} num))  := sorry --non-trivial
lemma new_lemma_42970 (h0 : uniform_space (measurable_space.dynkin_system (has_norm empty))) : complete_space (measurable_space.dynkin_system (has_norm empty)) := sorry --non-trivial
lemma new_lemma_42971 (h0 : topological_space (sub_neg_monoid pos)) : topological_space.separable_space (sub_neg_monoid pos) := sorry --non-trivial
lemma new_lemma_42972 (h0 : add_group (option ennreal)) : is_add_cyclic (option ennreal) := sorry --non-trivial
lemma new_lemma_42973 (h0 : topological_space (canonically_ordered_comm_semiring (has_add (has_add Type)))) : t1_space (canonically_ordered_comm_semiring (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_42974 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (ring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} num))  := sorry --non-trivial
lemma new_lemma_42975 (h0 : prod (mul_zero_class (semiring (semiring congr_arg_kind))) (mul_zero_class (semiring (semiring congr_arg_kind)))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_42976 (h0 : uniform_space (semi_normed_ring (metric_space char))) : complete_space (semi_normed_ring (metric_space char)) := sorry --non-trivial
lemma new_lemma_42977 (h0 : topological_space (ordered_comm_monoid (ring Type))) : loc_path_connected_space (ordered_comm_monoid (ring Type)) := sorry --non-trivial
lemma new_lemma_42978 (h0 : functor.add_const (topological_space (id unsigned)) empty) : @totally_separated_space.{0} (@id.{2} Type unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (@id.{2} Type unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_42979 (h0 : functor.add_const (topological_space (mul_zero_class ennreal)) Type) : @preirreducible_space.{0} (mul_zero_class.{0} ennreal) (@functor.add_const.run.{0 1} (topological_space.{0} (mul_zero_class.{0} ennreal)) Type h0)  := sorry --non-trivial
lemma new_lemma_42980 (h1 : group (with_one num)) : is_cyclic (with_one num) := sorry --non-trivial
lemma new_lemma_42981 (h0 : group (add_cancel_monoid (ring Type))) : group.fg (add_cancel_monoid (ring Type)) := sorry --non-trivial
lemma new_lemma_42982 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (has_Sup empty)) := sorry --non-trivial
lemma new_lemma_42983 (h0 : complete_lattice (generalized_boolean_algebra (sub_neg_monoid real))) : is_atomistic (generalized_boolean_algebra (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_42984 (h0 : topological_space (generalized_boolean_algebra pos)) : preconnected_space (generalized_boolean_algebra pos) := sorry --non-trivial
lemma new_lemma_42985 (h2 : group (with_bot (random_gen string_imp))) : normalizer_condition (with_bot (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_42986 (h0 : ring (has_neg (add_comm_monoid pos))) : is_domain (has_neg (add_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_42987 (h0 : function.extfun (Type 1) topological_space) : @t1_space.{1} (complete_distrib_lattice.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (complete_distrib_lattice.{1} Type))  := sorry --non-trivial
lemma new_lemma_42988 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (has_zero.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_42989 (h0 : not (uniform_space (has_top char) -> false)) : @complete_space.{0} (has_top.{0} char) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_top.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_42990 (h0 : ring (has_to_string linarith.comp)) : is_principal_ideal_ring (has_to_string linarith.comp) := sorry --non-trivial
lemma new_lemma_42991 (h0 : topological_space (semigroup num)) : preconnected_space (semigroup num) := sorry --non-trivial
lemma new_lemma_42992 (h0 : uniform_space (linear_ordered_comm_ring empty)) : separated_space (linear_ordered_comm_ring empty) := sorry --non-trivial
lemma new_lemma_42993 (h0 : functor.add_const (group (boolean_algebra linarith.comp)) (has_neg pos)) : @is_simple_group.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.{0} linarith.comp)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_42994 (h0 : functor.add_const (topological_space (boolean_algebra pos)) name) : @t0_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_42995 (h0 : functor.add_const (filter (cancel_monoid name)) unsigned) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_42996 (h0 : ring (distrib_lattice (add_semigroup string_imp))) : rank_condition (distrib_lattice (add_semigroup string_imp)) := sorry --non-trivial
lemma new_lemma_42997 (h0 : topological_space (ordered_cancel_add_comm_monoid ennreal)) : topological_space.separable_space (ordered_cancel_add_comm_monoid ennreal) := sorry --non-trivial
lemma new_lemma_42998 (h0 : functor.add_const (topological_space (comm_group Type)) linarith.comp) : @preconnected_space.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (comm_group.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_42999 (h2 : ring (fintype (has_nnnorm (has_ssubset (random_gen linarith.ineq))))) : strong_rank_condition (fintype (has_nnnorm (has_ssubset (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_43000 (h0 : topological_space (has_nnnorm environment.projection_info)) (h1 : preorder (has_nnnorm environment.projection_info)) : order_closed_topology (has_nnnorm environment.projection_info) := sorry --non-trivial
lemma new_lemma_43001 (h0 : add_group (has_add to_additive.value_type)) : is_add_cyclic (has_add to_additive.value_type) := sorry --non-trivial
lemma new_lemma_43002 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @regular_space.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_43003 (h0 : topological_space (has_one (has_norm (semiring fun_info)))) : irreducible_space (has_one (has_norm (semiring fun_info))) := sorry --non-trivial
lemma new_lemma_43004 (h0 : group (semigroup (has_neg pos))) : is_cyclic (semigroup (has_neg pos)) := sorry --non-trivial
lemma new_lemma_43005 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @path_connected_space.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_43006 (h0 : list (normed_comm_ring (finset linarith.comp))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_43007 (h0 : ring (measurable_space (has_top fun_info))) : strong_rank_condition (measurable_space (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_43008 (h0 : functor.add_const (uniform_space (simple_graph Type)) Type) : @separated_space.{1} (simple_graph.{1} Type) (@functor.add_const.run.{1 1} (uniform_space.{1} (simple_graph.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_43009 (h0 : topological_space (has_add (has_add (has_Inf linarith.comp)))) : irreducible_space (has_add (has_add (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_43010 (h0 : filter (boolean_algebra.core (finset name))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_43011 (h0 : not (function.extfun (Type 1) ring -> false)) : @strong_rank_condition.{1} (plift.{1} empty) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@classical.by_contradiction'.{3} (function.extfun.{3 2} (Type 1) ring.{1}) h0) (plift.{1} empty))  := sorry --non-trivial
lemma new_lemma_43012 (h1 : topological_space (normed_field (mul_one_class reducibility_hints))) : t0_space (normed_field (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_43013 (h0 : topological_space (has_top (has_inv (has_inv (has_inv linarith.comp_source))))) : t0_space (has_top (has_inv (has_inv (has_inv linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_43014 (h0 : topological_space (finset (option ennreal))) (h1 : measurable_space (finset (option ennreal))) : opens_measurable_space (finset (option ennreal)) := sorry --non-trivial
lemma new_lemma_43015 (h0 : not (function.extfun Type group -> false)) : @normalizer_condition.{0} (option.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (option.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_43016 (h0 : topological_space (boolean_algebra.core (option empty))) : locally_compact_space (boolean_algebra.core (option empty)) := sorry --non-trivial
lemma new_lemma_43017 (h0 : ordered_comm_monoid (canonically_ordered_comm_semiring linarith.comp)) : has_exists_mul_of_le (canonically_ordered_comm_semiring linarith.comp) := sorry --non-trivial
lemma new_lemma_43018 (h0 : functor.add_const (function.extfun Type topological_space) environment.implicit_infer_kind) : @normal_space.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) environment.implicit_infer_kind h0) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_43019 (h0 : complete_lattice (semigroup name)) : complete_lattice.is_Sup_finite_compact (semigroup name) := sorry --non-trivial
lemma new_lemma_43020 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (with_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (with_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_43021 (h0 : functor.add_const (topological_space (boolean_algebra.core pos)) Type) : @sequential_space.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.core.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_43022 (h0 : functor.add_const (filter (has_to_string environment.implicit_infer_kind)) Type) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_43023 (h0 : functor.add_const (filter (add_comm_monoid pos)) (has_neg linarith.comp)) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_43024 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_43025 (h0 : has_mem.mem (linear_ordered_semiring congr_arg_kind) has_emptyc.emptyc) : @path_connected_space.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (linear_ordered_semiring.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_43026 (h0 : ordered_comm_monoid (add_comm_monoid (comm_group Type))) : has_exists_mul_of_le (add_comm_monoid (comm_group Type)) := sorry --non-trivial
lemma new_lemma_43027 (h0 : monoid (id (has_inv (has_inv (has_inv linarith.comp_source))))) : monoid.fg (id (has_inv (has_inv (has_inv linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_43028 (h0 : uniform_space (has_add (finset pos))) : complete_space (has_add (finset pos)) := sorry --non-trivial
lemma new_lemma_43029 (h0 : ordered_add_comm_monoid (has_Inf pos)) : archimedean (has_Inf pos) := sorry --non-trivial
lemma new_lemma_43030 (h0 : functor.add_const (finset (finset pos)) linarith.comp) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_43031 (h0 : group (measurable_space num)) : normalizer_condition (measurable_space num) := sorry --non-trivial
lemma new_lemma_43032 (h0 : monoid (measurable_space congr_arg_kind)) : monoid.fg (measurable_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_43033 (h0 : topological_space (add_semigroup empty)) : locally_compact_space (add_semigroup empty) := sorry --non-trivial
lemma new_lemma_43034 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (with_zero.{0} fun_info) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (with_zero.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_43035 (h0 : not (topological_space (has_emptyc linarith.comp_source) -> false)) : @irreducible_space.{0} (has_emptyc.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (has_emptyc.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_43036 (h0 : topological_space (has_add (has_neg (has_add Type)))) : t0_space (has_add (has_neg (has_add Type))) := sorry --non-trivial
lemma new_lemma_43037 (h0 : ring (has_nndist (ring Type))) : is_principal_ideal_ring (has_nndist (ring Type)) := sorry --non-trivial
lemma new_lemma_43038 (h0 : functor.add_const (function.extfun (Type 1) topological_space) (has_neg (has_add Type))) : @t1_space.{1} Type (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) (has_neg.{1} (has_add.{1} Type)) h0) Type)  := sorry --non-trivial
lemma new_lemma_43039 (h0 : ring (finset (has_nndist Type))) : strong_rank_condition (finset (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_43040 (h0 : topological_space (mul_zero_class (cancel_monoid (finset (has_nndist name))))) : totally_separated_space (mul_zero_class (cancel_monoid (finset (has_nndist name)))) := sorry --non-trivial
lemma new_lemma_43041 (h1 : ring (semiring congr_arg_kind)) : strong_rank_condition (semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_43042 (h0 : topological_space (with_bot unsigned)) : totally_separated_space (with_bot unsigned) := sorry --non-trivial
lemma new_lemma_43043 (h0 : group (distrib_lattice (has_top to_additive.value_type))) : group.fg (distrib_lattice (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_43044 (h0 : semiring (generalized_boolean_algebra (has_bot real))) : is_noetherian_ring (generalized_boolean_algebra (has_bot real)) := sorry --non-trivial
lemma new_lemma_43045 (h0 : semiring (add_cancel_monoid (semiring empty))) : is_noetherian_ring (add_cancel_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_43046 (h0 : topological_space (right_cancel_semigroup unsigned)) : totally_separated_space (right_cancel_semigroup unsigned) := sorry --non-trivial
lemma new_lemma_43047 (h0 : ring (complete_distrib_lattice (has_add pos))) : is_domain (complete_distrib_lattice (has_add pos)) := sorry --non-trivial
lemma new_lemma_43048 (h0 : ring (fintype string_imp)) : is_domain (fintype string_imp) := sorry --non-trivial
lemma new_lemma_43049 (h0 : uniform_space (distrib_lattice (random_gen (has_nnnorm to_additive.value_type)))) : complete_space (distrib_lattice (random_gen (has_nnnorm to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_43050 (h0 : uniform_space (random_gen (has_top (linear_ordered_semiring empty)))) : separated_space (random_gen (has_top (linear_ordered_semiring empty))) := sorry --non-trivial
lemma new_lemma_43051 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (monoid_with_zero.{0} pos) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (monoid_with_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_43052 (h0 : function.extfun nat fin) : @is_cyclic.{0} (normed_lattice_add_comm_group.{0} pos) (@matrix.vec_empty.{0} (group.{0} (normed_lattice_add_comm_group.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_43053 (h0 : topological_space (add_comm_monoid (option (option empty)))) : irreducible_space (add_comm_monoid (option (option empty))) := sorry --non-trivial
lemma new_lemma_43054 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (has_zero.{0} ennreal) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (has_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_43055 (h0 : ordered_comm_monoid (simple_graph (ring (has_add linarith.comp)))) : has_exists_mul_of_le (simple_graph (ring (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_43056 (h0 : fin has_zero.zero) : @irreducible_space.{0} (ordered_comm_ring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (ordered_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_43057 (h0 : uniform_space (distrib (has_ssubset (has_ssubset reducibility_hints)))) : complete_space (distrib (has_ssubset (has_ssubset reducibility_hints))) := sorry --non-trivial
lemma new_lemma_43058 (h0 : topological_space (mul_zero_class unsigned)) : t0_space (mul_zero_class unsigned) := sorry --non-trivial
lemma new_lemma_43059 (h0 : topological_space (finset (finset (finset linarith.comp)))) : irreducible_space (finset (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_43060 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (linear_ordered_comm_monoid_with_zero.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (linear_ordered_comm_monoid_with_zero.{0} num))  := sorry --non-trivial
lemma new_lemma_43061 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (normed_comm_ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_43062 (h0 : group (generalized_boolean_algebra (has_Inf linarith.comp))) : is_cyclic (generalized_boolean_algebra (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_43063 (h0 : group (semiring (has_norm linarith.comp))) : group.fg (semiring (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_43064 (h0 : topological_space (linear_ordered_field (option unsigned))) : discrete_topology (linear_ordered_field (option unsigned)) := sorry --non-trivial
lemma new_lemma_43065 (h0 : functor.comp filter ring name) : filter.ne_bot (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_43066 (h0 : uniform_space (with_zero (has_nnnorm linarith.ineq))) : complete_space (with_zero (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_43067 (h0 : functor.add_const (topological_space (has_to_string linarith.comp)) environment.implicit_infer_kind) : @preconnected_space.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_43068 (h0 : finset (is_R_or_C (option unsigned))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_43069 (h0 : add_monoid (has_zero (finset (finset (finset pos))))) : add_monoid.fg (has_zero (finset (finset (finset pos)))) := sorry --non-trivial
lemma new_lemma_43070 (h0 : functor.add_const Prop (comm_group Type)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_43071 (h0 : prod (add_cancel_monoid name) (add_cancel_monoid name)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_43072 (h0 : functor.add_const (topological_space (non_assoc_semiring empty)) empty) : @t1_space.{0} (non_assoc_semiring.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (non_assoc_semiring.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_43073 (h0 : functor.add_const (function.extfun Type topological_space) name) : @totally_separated_space.{0} (has_Inf.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (has_Inf.{0} name))  := sorry --non-trivial
lemma new_lemma_43074 (h0 : functor.add_const (topological_space (complete_distrib_lattice unsigned)) (finset environment.implicit_infer_kind)) : @preconnected_space.{0} (complete_distrib_lattice.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} unsigned)) (finset.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_43075 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_43076 (h0 : ring (normed_group (has_top (has_top fun_info)))) : rank_condition (normed_group (has_top (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_43077 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (canonically_linear_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_linear_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_43078 (h0 : functor.add_const (monoid (left_cancel_semigroup num)) (semiring num)) : @monoid.fg.{0} (left_cancel_semigroup.{0} num) (@functor.add_const.run.{0 0} (monoid.{0} (left_cancel_semigroup.{0} num)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_43079 (h0 : cancel_comm_monoid_with_zero (linear_ordered_comm_ring (semiring (semiring (semiring num))))) : unique_factorization_monoid (linear_ordered_comm_ring (semiring (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_43080 (h0 : functor.add_const (add_group (has_to_string Type)) name) : @is_add_cyclic.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (add_group.{1} (has_to_string.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_43081 (h0 : functor.add_const (add_group (complete_distrib_lattice unsigned)) pos) : @is_add_cyclic.{0} (complete_distrib_lattice.{0} unsigned) (@functor.add_const.run.{0 0} (add_group.{0} (complete_distrib_lattice.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_43082 (h0 : group (generalized_boolean_algebra (has_add Type))) : group.fg (generalized_boolean_algebra (has_add Type)) := sorry --non-trivial
lemma new_lemma_43083 (h1 : topological_space (add_cancel_monoid char)) (h2 : preorder (add_cancel_monoid char)) : order_topology (add_cancel_monoid char) := sorry --non-trivial
lemma new_lemma_43084 (h0 : has_mem.mem congr_arg_kind has_emptyc.emptyc) : @monoid.fg.{0} congr_arg_kind (@finset.pi.empty.{1 0} Type monoid.{0} congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_43085 (h0 : complete_lattice (with_zero linarith.comp_source)) : complete_lattice.is_Sup_finite_compact (with_zero linarith.comp_source) := sorry --non-trivial
lemma new_lemma_43086 (h0 : ordered_comm_monoid (semigroup (ring unsigned))) : has_exists_mul_of_le (semigroup (ring unsigned)) := sorry --non-trivial
lemma new_lemma_43087 (h0 : monoid (generalized_boolean_algebra (sub_neg_monoid name))) : monoid.fg (generalized_boolean_algebra (sub_neg_monoid name)) := sorry --non-trivial
lemma new_lemma_43088 (h0 : functor.add_const (filter (has_add (finset linarith.comp))) pos) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_43089 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (complete_distrib_lattice.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (complete_distrib_lattice.{0} empty))  := sorry --non-trivial
lemma new_lemma_43090 (h0 : functor.add_const (function.extfun Type topological_space) environment.implicit_infer_kind) : @topological_space.separable_space.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) environment.implicit_infer_kind h0) (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_43091 (h0 : filter (add_left_cancel_monoid char)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_43092 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (@id.{2} Type congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (@id.{2} Type congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_43093 (h0 : topological_space (boolean_algebra.core (option num))) : normal_space (boolean_algebra.core (option num)) := sorry --non-trivial
lemma new_lemma_43094 (h0 : uniform_space (boolean_algebra (comm_group name))) : complete_space (boolean_algebra (comm_group name)) := sorry --non-trivial
lemma new_lemma_43095 (h0 : functor.add_const (topological_space (has_to_string Type)) (ring Type)) : @loc_path_connected_space.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_to_string.{1} Type)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_43096 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (has_Sup.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (has_Sup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_43097 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (is_R_or_C unsigned)) := sorry --non-trivial
lemma new_lemma_43098 (h0 : filter (comm_ring (has_norm (has_inv (random_gen (random_gen linarith.ineq)))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_43099 (h1 h2 : multiset (mul_one_class fun_info)) : multiset.subset h1 h2 := sorry --non-trivial
lemma new_lemma_43100 (h0 : topological_space (simple_graph (random_gen (metric_space char)))) : t0_space (simple_graph (random_gen (metric_space char))) := sorry --non-trivial
lemma new_lemma_43101 (h1 : topological_space (has_top linarith.ineq)) : totally_disconnected_space (has_top linarith.ineq) := sorry --non-trivial
lemma new_lemma_43102 (h5 : add_group (nondiscrete_normed_field (nondiscrete_normed_field fun_info))) : is_add_cyclic (nondiscrete_normed_field (nondiscrete_normed_field fun_info)) := sorry --non-trivial
lemma new_lemma_43103 (h0 : add_group environment.implicit_infer_kind) : is_add_cyclic environment.implicit_infer_kind := sorry --non-trivial
lemma new_lemma_43104 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (denumerable.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (denumerable.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_43105 (h0 : functor.add_const (monoid (add_cancel_monoid Type)) (normed_comm_ring Type)) : @monoid.fg.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 1} (monoid.{1} (add_cancel_monoid.{1} Type)) (normed_comm_ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_43106 (h0 : functor.add_const Prop (semigroup (has_neg (has_neg linarith.comp)))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_43107 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_43108 (h0 : list (has_to_string pos)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_43109 (h0 : topological_space (has_neg_part (has_add (comm_group Type)))) : irreducible_space (has_neg_part (has_add (comm_group Type))) := sorry --non-trivial
lemma new_lemma_43110 (h0 : not (complete_lattice (has_emptyc linarith.ineq) -> false)) : @is_atomistic.{0} (has_emptyc.{0} linarith.ineq) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_emptyc.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_43111 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @rank_condition.{0} to_additive.value_type (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) ring.{0}) to_additive.value_type)  := sorry --non-trivial
lemma new_lemma_43112 (h0 : not (ring (with_one linarith.comp) -> false)) : @is_domain.{0} (with_one.{0} linarith.comp) (@classical.by_contradiction'.{1} (ring.{0} (with_one.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_43113 (h0 : functor.add_const (finset (has_neg name)) name) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_43114 (h0 : ordered_comm_monoid (add_comm_monoid (has_bot linarith.comp))) : has_exists_mul_of_le (add_comm_monoid (has_bot linarith.comp)) := sorry --non-trivial
lemma new_lemma_43115 (h0 : topological_space (ordered_comm_monoid (has_Inf (ring Type)))) : topological_space.separable_space (ordered_comm_monoid (has_Inf (ring Type))) := sorry --non-trivial
lemma new_lemma_43116 (h0 : not (has_mem.mem (random_gen fun_info) has_emptyc.emptyc -> false)) : @totally_disconnected_space.{0} (random_gen.{0} fun_info) (@finset.pi.empty.{1 0} Type topological_space.{0} (random_gen.{0} fun_info) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} fun_info) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_43117 (h0 : not (add_group (dlist (has_nnnorm fun_info)) -> false)) : @is_add_cyclic.{0} (dlist.{0} (has_nnnorm.{0} fun_info)) (@classical.by_contradiction'.{1} (add_group.{0} (dlist.{0} (has_nnnorm.{0} fun_info))) h0)  := sorry --non-trivial
lemma new_lemma_43118 (h1 : ring (normed_field enat)) : is_domain (normed_field enat) := sorry --non-trivial
lemma new_lemma_43119 (h1 : ring (with_zero (random_gen string_imp))) : rank_condition (with_zero (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_43120 (h0 : ring (has_pos_part (has_add (ring linarith.comp)))) : strong_rank_condition (has_pos_part (has_add (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_43121 (h0 : not (function.extfun Type uniform_space -> false)) : @separated_space.{0} (has_top.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (has_top.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_43122 (h0 : functor.add_const (topological_space Type) (comm_group name)) : @totally_separated_space.{1} Type (@functor.add_const.run.{1 0} (topological_space.{1} Type) (comm_group.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_43123 (h0 : ring (semi_normed_comm_ring (has_nnnorm (has_nnnorm fun_info)))) : strong_rank_condition (semi_normed_comm_ring (has_nnnorm (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_43124 (h0 : topological_space (option (option ennreal))) : loc_path_connected_space (option (option ennreal)) := sorry --non-trivial
lemma new_lemma_43125 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (bin_tree.{0} unsigned) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (bin_tree.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_43126 (h0 : topological_space (complete_distrib_lattice (boolean_algebra.core (has_add Type)))) : totally_disconnected_space (complete_distrib_lattice (boolean_algebra.core (has_add Type))) := sorry --non-trivial
lemma new_lemma_43127 (h0 : has_lt (add_comm_semigroup ereal)) : no_max_order (add_comm_semigroup ereal) := sorry --non-trivial
lemma new_lemma_43128 (h0 : functor.add_const (complete_lattice (has_Inf linarith.comp)) pos) : @complete_lattice.is_Sup_finite_compact.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_Inf.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_43129 (h0 : ordered_comm_monoid (has_zero (has_neg name))) : has_exists_mul_of_le (has_zero (has_neg name)) := sorry --non-trivial
lemma new_lemma_43130 (h0 : list (canonically_ordered_monoid (has_Inf name))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_43131 (h0 : function.extfun nat fin) : @is_add_cyclic.{1} (canonically_ordered_comm_semiring.{1} Type) (@matrix.vec_empty.{1} (add_group.{1} (canonically_ordered_comm_semiring.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_43132 (h0 : topological_space (finset (option (option (option unsigned))))) : discrete_topology (finset (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_43133 (h0 : cancel_comm_monoid_with_zero (comm_monoid num)) : unique_factorization_monoid (comm_monoid num) := sorry --non-trivial
lemma new_lemma_43134 (h0 : monoid (id (has_inv fun_info))) : monoid.fg (id (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_43135 (h0 : functor.add_const (ring (has_pos_part linarith.comp)) name) : @rank_condition.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_pos_part.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_43136 (h1 : topological_space (has_ssubset environment.projection_info)) : t0_space (has_ssubset environment.projection_info) := sorry --non-trivial
lemma new_lemma_43137 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (canonically_ordered_add_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (canonically_ordered_add_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_43138 (h1 : topological_space (nondiscrete_normed_field char)) (h2 : add_group (nondiscrete_normed_field char)) : topological_add_group (nondiscrete_normed_field char) := sorry --non-trivial
lemma new_lemma_43139 (h0 : ring (add_comm_monoid (option pos))) : is_principal_ideal_ring (add_comm_monoid (option pos)) := sorry --non-trivial
lemma new_lemma_43140 (h0 : topological_space (has_inner empty unsigned)) : locally_compact_space (has_inner empty unsigned) := sorry --non-trivial
lemma new_lemma_43141 (h0 : add_group (comm_semigroup (sub_neg_monoid Type))) : is_add_cyclic (comm_semigroup (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_43142 (h0 : topological_space (has_nndist pos)) : normal_space (has_nndist pos) := sorry --non-trivial
lemma new_lemma_43143 (h0 : topological_space (has_inv (has_nnnorm linarith.comp_source))) : t0_space (has_inv (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_43144 (h0 : ring (add_comm_monoid environment.implicit_infer_kind)) : rank_condition (add_comm_monoid environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_43145 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (has_neg_part.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_neg_part.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_43146 (h0 : semiring (add_cancel_monoid (ring (boolean_algebra linarith.comp)))) : is_noetherian_ring (add_cancel_monoid (ring (boolean_algebra linarith.comp))) := sorry --non-trivial
lemma new_lemma_43147 (h0 : topological_space (semigroup (has_neg (has_neg (has_neg linarith.comp))))) : regular_space (semigroup (has_neg (has_neg (has_neg linarith.comp)))) := sorry --non-trivial
lemma new_lemma_43148 (h0 : has_mem.mem (linear_ordered_comm_ring num) has_emptyc.emptyc) : finset.nonempty (finset.pi.empty finset (linear_ordered_comm_ring num) h0) := sorry --non-trivial
lemma new_lemma_43149 (h0 : functor.add_const (uniform_space (ring linarith.comp)) (has_neg linarith.comp)) : @complete_space.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (ring.{0} linarith.comp)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_43150 (h0 : not (topological_space (id unsigned) -> false)) : @locally_compact_space.{0} (@id.{2} Type unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (@id.{2} Type unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_43151 (h0 : group (has_top (has_norm (random_gen (has_norm (semiring num)))))) : normalizer_condition (has_top (has_norm (random_gen (has_norm (semiring num))))) := sorry --non-trivial
lemma new_lemma_43152 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (with_bot.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (with_bot.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_43153 (h0 : functor.add_const (ring (left_cancel_monoid unsigned)) unsigned) : @is_principal_ideal_ring.{0} (left_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (left_cancel_monoid.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_43154 (h0 : functor.add_const (group (has_to_string (has_add pos))) pos) : @normalizer_condition.{0} (has_to_string.{0} (has_add.{0} pos)) (@functor.add_const.run.{0 0} (group.{0} (has_to_string.{0} (has_add.{0} pos))) pos h0)  := sorry --non-trivial
lemma new_lemma_43155 (h0 : topological_space (finset (boolean_algebra (ring (has_neg Type))))) : normal_space (finset (boolean_algebra (ring (has_neg Type)))) := sorry --non-trivial
lemma new_lemma_43156 (h0 : topological_space (linear_ordered_add_comm_group (has_top (has_top (has_top fun_info))))) : t0_space (linear_ordered_add_comm_group (has_top (has_top (has_top fun_info)))) := sorry --non-trivial
lemma new_lemma_43157 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (with_bot.{0} (random_gen.{0} string_imp)) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (with_bot.{0} (random_gen.{0} string_imp)))  := sorry --non-trivial
lemma new_lemma_43158 (h0 : not (ring (non_assoc_semiring congr_arg_kind) -> false)) : @is_principal_ideal_ring.{0} (non_assoc_semiring.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (ring.{0} (non_assoc_semiring.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_43159 (h0 : filter (finset pos)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_43160 (h0 : semiring (comm_semigroup (sub_neg_monoid pos))) : is_noetherian_ring (comm_semigroup (sub_neg_monoid pos)) := sorry --non-trivial
lemma new_lemma_43161 (h0 : list (free_add_monoid (semiring (semiring (semiring empty))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_43162 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (has_norm.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_norm.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_43163 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} (has_emptyc.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (has_emptyc.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_43164 (h0 : functor.add_const (add_monoid (has_nndist pos)) (mul_one_class linarith.comp)) : @add_monoid.fg.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_nndist.{0} pos)) (mul_one_class.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_43165 (h0 : functor.add_const (ring (has_add pos)) (ring Type)) : @strong_rank_condition.{0} (has_add.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (has_add.{0} pos)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_43166 (h0 : topological_space (add_cancel_comm_monoid unsigned)) (h1 : group (add_cancel_comm_monoid unsigned)) : topological_group (add_cancel_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_43167 (h0 : monoid (has_norm (has_top (random_gen (comm_ring linarith.ineq))))) : monoid.fg (has_norm (has_top (random_gen (comm_ring linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_43168 (h0 : monoid (generalized_boolean_algebra (sub_neg_monoid pos))) : monoid.fg (generalized_boolean_algebra (sub_neg_monoid pos)) := sorry --non-trivial
lemma new_lemma_43169 (h0 : topological_space (finset (has_add Type))) : totally_disconnected_space (finset (has_add Type)) := sorry --non-trivial
lemma new_lemma_43170 (h0 : topological_space (with_one (has_nnnorm (has_nnnorm (has_nnnorm fun_info))))) : locally_compact_space (with_one (has_nnnorm (has_nnnorm (has_nnnorm fun_info)))) := sorry --non-trivial
lemma new_lemma_43171 (h0 : topological_space (boolean_algebra.core (option unsigned))) : discrete_topology (boolean_algebra.core (option unsigned)) := sorry --non-trivial
lemma new_lemma_43172 (h1 : ring (encodable char)) : rank_condition (encodable char) := sorry --non-trivial
lemma new_lemma_43173 (h0 : not (topological_space linarith.comp_source -> false)) : @totally_disconnected_space.{0} linarith.comp_source (@classical.by_contradiction'.{1} (topological_space.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_43174 (h0 : semiring (has_to_string (has_neg pos))) : is_noetherian_ring (has_to_string (has_neg pos)) := sorry --non-trivial
lemma new_lemma_43175 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (group_with_zero.{0} ennreal) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (group_with_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_43176 (h0 : complete_lattice (add_cancel_comm_monoid string.iterator_imp)) : complete_lattice.is_Sup_finite_compact (add_cancel_comm_monoid string.iterator_imp) := sorry --non-trivial
lemma new_lemma_43177 (h0 : group (add_cancel_monoid ennreal)) : is_simple_group (add_cancel_monoid ennreal) := sorry --non-trivial
lemma new_lemma_43178 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (has_norm.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_norm.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_43179 (h0 : ring (normed_field (random_gen (random_gen linarith.comp_source)))) : rank_condition (normed_field (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_43180 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (canonically_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_43181 (h0 : functor.add_const (topological_space (boolean_algebra linarith.comp)) name) : @preirreducible_space.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_43182 (h0 : fin has_zero.zero) : @preconnected_space.{0} (has_Inf.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (has_Inf.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_43183 (h0 : topological_space (random_gen (semiring (has_norm (has_norm linarith.comp))))) : discrete_topology (random_gen (semiring (has_norm (has_norm linarith.comp)))) := sorry --non-trivial
lemma new_lemma_43184 (h0 : function.extfun Type topological_space) : @t0_space.{0} (group_with_zero.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (group_with_zero.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_43185 (h0 : functor.add_const (topological_space (boolean_algebra linarith.comp)) name) : @irreducible_space.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_43186 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (has_Sup.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (has_Sup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_43187 (h0 : topological_space (finset (finset name))) : sequential_space (finset (finset name)) := sorry --non-trivial
lemma new_lemma_43188 (h0 : fin has_zero.zero) : @monoid.fg.{1} (boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (monoid.{1} (boolean_algebra.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_43189 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (comm_ring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (comm_ring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_43190 (h0 : topological_space (normed_lattice_add_comm_group Type)) : preirreducible_space (normed_lattice_add_comm_group Type) := sorry --non-trivial
lemma new_lemma_43191 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (generalized_boolean_algebra.{0} (has_add.{0} linarith.comp)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (generalized_boolean_algebra.{0} (has_add.{0} linarith.comp)))  := sorry --non-trivial
lemma new_lemma_43192 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_to_string.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (has_to_string.{0} num))  := sorry --non-trivial
lemma new_lemma_43193 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_norm.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_norm.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_43194 (h0 : ring (complete_semilattice_Sup (random_gen linarith.ineq))) : is_domain (complete_semilattice_Sup (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_43195 (h0 : group (has_top (has_ssubset (random_gen (random_gen (random_gen fun_info)))))) : is_cyclic (has_top (has_ssubset (random_gen (random_gen (random_gen fun_info))))) := sorry --non-trivial
lemma new_lemma_43196 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @is_atomistic.{0} (has_inter.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) complete_lattice.{0}) (has_inter.{0} num))  := sorry --non-trivial
lemma new_lemma_43197 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (add_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_43198 (h0 : uniform_space (has_neg (ring Type))) : complete_space (has_neg (ring Type)) := sorry --non-trivial
lemma new_lemma_43199 (h0 : topological_space (has_zero (ring (finset linarith.comp)))) : t1_space (has_zero (ring (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_43200 (h0 : not (topological_space (complete_semilattice_Sup fun_info) -> false)) : @path_connected_space.{0} (complete_semilattice_Sup.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (complete_semilattice_Sup.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_43201 (h0 : add_monoid (finset congr_arg_kind)) : add_monoid.fg (finset congr_arg_kind) := sorry --non-trivial
lemma new_lemma_43202 (h0 : ring (has_compl std_gen)) : strong_rank_condition (has_compl std_gen) := sorry --non-trivial
lemma new_lemma_43203 (h0 : complete_lattice (has_to_string (has_neg linarith.comp))) : is_compactly_generated (has_to_string (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_43204 (h0 : functor.add_const (group (add_cancel_monoid pos)) name) : @is_cyclic.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (add_cancel_monoid.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_43205 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (option.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (option.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_43206 (h0 : group (finset (has_add name))) : normalizer_condition (finset (has_add name)) := sorry --non-trivial
lemma new_lemma_43207 (h0 : function.extfun Type topological_space) : @normal_space.{0} (has_dist.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_dist.{0} empty))  := sorry --non-trivial
lemma new_lemma_43208 (h0 : has_mem.mem (normed_group num) has_emptyc.emptyc) : @strong_rank_condition.{0} (normed_group.{0} num) (@finset.pi.empty.{1 0} Type ring.{0} (normed_group.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_43209 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (pseudo_metric_space.{0} (option.{0} (option.{0} empty))) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (pseudo_metric_space.{0} (option.{0} (option.{0} empty))))  := sorry --non-trivial
lemma new_lemma_43210 (h0 : topological_space (comm_group (has_add (normed_comm_ring (has_nndist pos))))) : sequential_space (comm_group (has_add (normed_comm_ring (has_nndist pos)))) := sorry --non-trivial
lemma new_lemma_43211 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (add_group.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (add_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_43212 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @totally_separated_space.{0} (linear_ordered_add_comm_group.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) topological_space.{0}) (linear_ordered_add_comm_group.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_43213 (h0 : not (add_group (has_lt linarith.ineq) -> false)) : @is_add_cyclic.{0} (has_lt.{0} linarith.ineq) (@classical.by_contradiction'.{1} (add_group.{0} (has_lt.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_43214 (h1 : add_comm_semigroup fun_info -> add_comm_semigroup fun_info) (h2 : add_comm_semigroup fun_info) : function.is_fixed_pt h1 h2 := sorry --non-trivial
lemma new_lemma_43215 (h0 : functor.add_const (topological_space (has_zero linarith.comp)) linarith.comp) : @preconnected_space.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_43216 (h0 : ring (add_comm_semigroup (add_comm_semigroup (mul_one_class std_gen)))) : strong_rank_condition (add_comm_semigroup (add_comm_semigroup (mul_one_class std_gen))) := sorry --non-trivial
lemma new_lemma_43217 (h0 : has_mem.mem (semiring empty) has_emptyc.emptyc) : @irreducible_space.{0} (semiring.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_43218 (h0 : finset (has_neg (normed_comm_ring environment.implicit_infer_kind))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_43219 (h0 : topological_space (cancel_monoid (option (option name)))) : path_connected_space (cancel_monoid (option (option name))) := sorry --non-trivial
lemma new_lemma_43220 (h0 : fin has_zero.zero) : @unique_factorization_monoid.{0} (canonically_linear_ordered_monoid.{0} pos) (@matrix.vec_empty.{0} (cancel_comm_monoid_with_zero.{0} (canonically_linear_ordered_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_43221 (h0 : topological_space (add_cancel_monoid (comm_group (comm_group Type)))) : totally_disconnected_space (add_cancel_monoid (comm_group (comm_group Type))) := sorry --non-trivial
lemma new_lemma_43222 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (has_neg.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} num))  := sorry --non-trivial
lemma new_lemma_43223 (h0 : complete_lattice (add_comm_semigroup (mul_one_class enat))) : complete_lattice.is_Sup_finite_compact (add_comm_semigroup (mul_one_class enat)) := sorry --non-trivial
lemma new_lemma_43224 (h0 : functor.add_const (topological_space (complete_linear_order empty)) unsigned) : @t0_space.{0} (complete_linear_order.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_linear_order.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_43225 (h0 : has_mem.mem (measurable_space num) has_emptyc.emptyc) : @add_monoid.fg.{0} (measurable_space.{0} num) (@finset.pi.empty.{1 0} Type add_monoid.{0} (measurable_space.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_43226 (h0 : ring (canonically_ordered_monoid name)) : rank_condition (canonically_ordered_monoid name) := sorry --non-trivial
lemma new_lemma_43227 (h0 : functor.add_const (ring (has_zero pos)) name) : @rank_condition.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_zero.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_43228 (h0 h1 : multiset (simple_graph enat)) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_43229 (h0 : complete_lattice (has_norm (has_inv linarith.comp_source))) : is_atomistic (has_norm (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_43230 (h0 : functor.add_const (function.extfun Type topological_space) unsigned) : @t0_space.{0} (mul_zero_class.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) unsigned h0) (mul_zero_class.{0} name))  := sorry --non-trivial
lemma new_lemma_43231 (h0 : functor.add_const (topological_space (linear_ordered_field name)) pos) : @irreducible_space.{0} (linear_ordered_field.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_field.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_43232 (h0 : functor.add_const (complete_lattice (measurable_space.dynkin_system congr_arg_kind)) congr_arg_kind) : @is_atomistic.{0} (measurable_space.dynkin_system.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (measurable_space.dynkin_system.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_43233 (h0 : prod (with_one num) (with_one num)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_43234 (h0 : functor.add_const (topological_space (has_add pos)) ennreal) : @regular_space.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} pos)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_43235 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (comm_group.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} comm_group.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} comm_group.{0}) (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 (functor.comp.{0 0 0} topological_space.{0} comm_group.{0})) pos))  := sorry --non-trivial
lemma new_lemma_43236 (h3 : set (linarith.ineq -> add_comm_semigroup enat)) : set.separates_points h3 := sorry --non-trivial
lemma new_lemma_43237 (h1 : ring (nondiscrete_normed_field char)) : rank_condition (nondiscrete_normed_field char) := sorry --non-trivial
lemma new_lemma_43238 (h0 : fin has_zero.zero) : @complete_space.{1} (canonically_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (uniform_space.{1} (canonically_ordered_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_43239 (h0 : topological_space (semi_normed_comm_ring char)) : t0_space (semi_normed_comm_ring char) := sorry --non-trivial
lemma new_lemma_43240 (h0 : functor.add_const (ring (normed_comm_ring linarith.comp)) (ring (finset linarith.comp))) : @is_principal_ideal_ring.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (normed_comm_ring.{0} linarith.comp)) (ring.{0} (finset.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_43241 (h0 : functor.add_const (topological_space (finset pos)) (has_Inf (finset Type))) : @locally_compact_space.{0} (finset.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (finset.{0} pos)) (has_Inf.{1} (finset.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_43242 (h0 : functor.add_const (semiring (has_neg_part ennreal)) pos) : @is_noetherian_ring.{0} (has_neg_part.{0} ennreal) (@functor.add_const.run.{0 0} (semiring.{0} (has_neg_part.{0} ennreal)) pos h0)  := sorry --non-trivial
lemma new_lemma_43243 (h0 : topological_space (has_Inf (has_add (finset (has_add (has_pos_part pos)))))) : sequential_space (has_Inf (has_add (finset (has_add (has_pos_part pos))))) := sorry --non-trivial
lemma new_lemma_43244 (h0 : functor.add_const (topological_space (has_add Type)) (has_neg pos)) : @normal_space.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_add.{1} Type)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_43245 (h0 : ring (generalized_boolean_algebra linarith.comp)) : strong_rank_condition (generalized_boolean_algebra linarith.comp) := sorry --non-trivial
lemma new_lemma_43246 (h0 : functor.add_const (ordered_add_comm_monoid (ring environment.implicit_infer_kind)) pos) : @archimedean.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (ring.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_43247 (h0 : functor.add_const (complete_lattice (has_nndist environment.implicit_infer_kind)) unsigned) : @is_compactly_generated.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_nndist.{0} environment.implicit_infer_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_43248 (h0 : topological_space (has_pos_part (boolean_algebra.core pos))) : preconnected_space (has_pos_part (boolean_algebra.core pos)) := sorry --non-trivial
lemma new_lemma_43249 (h0 : ring (add_left_cancel_monoid (random_gen (has_ssubset string_imp)))) : rank_condition (add_left_cancel_monoid (random_gen (has_ssubset string_imp))) := sorry --non-trivial
lemma new_lemma_43250 (h0 : measurable_space (nondiscrete_normed_field reducibility_hints)) (h1 : filter (nondiscrete_normed_field reducibility_hints)) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_43251 (h0 : topological_space (generalized_boolean_algebra (has_add linarith.comp))) : preirreducible_space (generalized_boolean_algebra (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_43252 (h0 : functor.add_const (topological_space (ring Type)) environment.implicit_infer_kind) : @topological_space.separable_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ring.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_43253 (h0 : filter (add_cancel_monoid (semiring empty))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_43254 (h0 : topological_space (comm_ring (has_ssubset reducibility_hints))) : totally_disconnected_space (comm_ring (has_ssubset reducibility_hints)) := sorry --non-trivial
lemma new_lemma_43255 (h6 : complete_lattice (random_gen fun_info)) : complete_lattice.is_Sup_finite_compact (random_gen fun_info) := sorry --non-trivial
lemma new_lemma_43256 (h0 : functor.add_const (function.extfun Type ring) linarith.comp) : @is_principal_ideal_ring.{0} (ordered_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) linarith.comp h0) (ordered_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_43257 (h0 : functor.add_const (topological_space (has_add linarith.comp)) name) : @topological_space.separable_space.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_43258 (h0 : add_group (normed_field (mul_one_class (mul_one_class reducibility_hints)))) : is_add_cyclic (normed_field (mul_one_class (mul_one_class reducibility_hints))) := sorry --non-trivial
lemma new_lemma_43259 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : functor.const.run (function.extfun_app (function.extfun_app h0 (functor.const Prop)) fun_info) := sorry --non-trivial
lemma new_lemma_43260 (h0 : functor.add_const (function.extfun (Type 1) monoid) (has_add Type)) : @monoid.fg.{1} (comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) monoid.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) monoid.{1}) (has_add.{1} Type) h0) (comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_43261 (h0 : topological_space (has_add environment.implicit_infer_kind)) : preconnected_space (has_add environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_43262 (h0 : with_bot (list pnat)) (h1 : ne h0 has_bot.bot) (h2 : pnat) : pnat.coprime (list.head (with_bot.unbot h0 h1)) (id h2) := sorry --non-trivial
lemma new_lemma_43263 (h1 : group (has_ssubset (random_gen string_imp))) : group.fg (has_ssubset (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_43264 (h0 : group (partial_order (has_top unsigned))) : normalizer_condition (partial_order (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_43265 (h0 : functor.add_const (topological_space (add_semigroup unsigned)) empty) : @loc_path_connected_space.{0} (add_semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_semigroup.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_43266 (h1 : topological_space (has_ssubset to_additive.value_type)) : locally_compact_space (has_ssubset to_additive.value_type) := sorry --non-trivial
lemma new_lemma_43267 (h1 : topological_space (normed_field std_gen)) : path_connected_space (normed_field std_gen) := sorry --non-trivial
lemma new_lemma_43268 (h0 : group (linear_ordered_semiring (semiring congr_arg_kind))) : is_cyclic (linear_ordered_semiring (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_43269 (h0 : ring (has_lt (random_gen (random_gen char)))) : strong_rank_condition (has_lt (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_43270 (h0 : not (filter (has_top num) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_43271 (h0 : list (pseudo_metric_space unsigned)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_43272 (h0 : function.extfun Type ring) : @rank_condition.{0} (complete_distrib_lattice.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} h0 (complete_distrib_lattice.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_43273 (h0 : topological_space (measurable_space (has_top linarith.comp_source))) : irreducible_space (measurable_space (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_43274 (h1 : ring (normed_field (option (random_gen to_additive.value_type)))) : strong_rank_condition (normed_field (option (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_43275 (h0 : functor.add_const (functor.add_const Prop (comm_group linarith.comp)) (has_add Type)) : functor.add_const.run (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_43276 (h0 : monoid (with_one (has_top linarith.ineq))) : monoid.fg (with_one (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_43277 (h0 : functor.add_const (add_group (has_zero pos)) linarith.comp) : @is_add_cyclic.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (has_zero.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_43278 (h0 : function.extfun Type topological_space) : @t0_space.{0} (measurable_space.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measurable_space.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_43279 (h0 : ring (distrib_lattice (random_gen linarith.comp_source))) : is_domain (distrib_lattice (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_43280 (h5 : add_group (random_gen (comm_ring char))) : is_add_cyclic (random_gen (comm_ring char)) := sorry --non-trivial
lemma new_lemma_43281 (h0 : group (measurable_space.dynkin_system (semiring num))) : group.fg (measurable_space.dynkin_system (semiring num)) := sorry --non-trivial
lemma new_lemma_43282 (h1 : complete_lattice (ordered_comm_ring linarith.comp_source)) : complete_lattice.is_Sup_finite_compact (ordered_comm_ring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_43283 (h0 : topological_space (ordered_comm_ring (finset Type))) : irreducible_space (ordered_comm_ring (finset Type)) := sorry --non-trivial
lemma new_lemma_43284 (h0 : list (distrib_lattice (has_norm fun_info))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_43285 (h0 : uniform_space (metric_space empty)) : complete_space (metric_space empty) := sorry --non-trivial
lemma new_lemma_43286 (h0 : functor.add_const (ordered_comm_monoid (semigroup pos)) (has_to_string (ring (measurable_space (finset pos))))) : @has_exists_mul_of_le.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (semigroup.{0} pos)) (has_to_string.{0} (ring.{0} (measurable_space.{0} (finset.{0} pos)))) h0)  := sorry --non-trivial
lemma new_lemma_43287 (h0 : functor.add_const (functor.add_const (finset linarith.comp) (finset linarith.comp)) linarith.comp) : finset.nonempty (functor.add_const.run (functor.add_const.run h0)) := sorry --non-trivial
lemma new_lemma_43288 (h0 : uniform_space (has_compl char)) : complete_space (has_compl char) := sorry --non-trivial
lemma new_lemma_43289 (h0 : topological_space (partial_order empty)) : preirreducible_space (partial_order empty) := sorry --non-trivial
lemma new_lemma_43290 (h0 : functor.add_const (topological_space (complete_distrib_lattice pos)) pos) : @normal_space.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_43291 (h0 : topological_space (normed_comm_ring (has_add (has_add Type)))) : totally_disconnected_space (normed_comm_ring (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_43292 (h0 : ring (div_inv_monoid char)) : strong_rank_condition (div_inv_monoid char) := sorry --non-trivial
lemma new_lemma_43293 (h0 : function.extfun Type (functor.add_const (ordered_add_comm_monoid (bin_tree empty)))) : @archimedean.{0} (bin_tree.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (bin_tree.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ordered_add_comm_monoid.{0} (bin_tree.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_43294 (h0 : monoid (finset (has_neg Type))) : monoid.fg (finset (has_neg Type)) := sorry --non-trivial
lemma new_lemma_43295 (h0 : uniform_space (random_gen (has_norm to_additive.value_type))) : complete_space (random_gen (has_norm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_43296 (h0 : ring (add_cancel_monoid (ring Type))) : strong_rank_condition (add_cancel_monoid (ring Type)) := sorry --non-trivial
lemma new_lemma_43297 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (pseudo_metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (pseudo_metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_43298 (h0 : function.extfun Type topological_space) : @t0_space.{0} (boolean_algebra.core.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_43299 (h0 : complete_lattice (nondiscrete_normed_field char)) : complete_lattice.is_Sup_finite_compact (nondiscrete_normed_field char) := sorry --non-trivial
lemma new_lemma_43300 (h0 h1 : multiset (has_lt (mul_one_class (mul_one_class char)))) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_43301 (h0 : topological_space (ring num)) : locally_compact_space (ring num) := sorry --non-trivial
lemma new_lemma_43302 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (normed_lattice_add_comm_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_lattice_add_comm_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_43303 (h0 : monoid fun_info) (h1 : fun_info) : is_of_fin_order h1 := sorry --non-trivial
lemma new_lemma_43304 (h0 : function.extfun Type topological_space) : @t1_space.{0} (comm_group.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_group.{0} name))  := sorry --non-trivial
lemma new_lemma_43305 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (has_neg.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_neg.{0} empty))  := sorry --non-trivial
lemma new_lemma_43306 (h0 : not (ring (linear_ordered_comm_group_with_zero string.iterator_imp) -> false)) : @is_domain.{0} (linear_ordered_comm_group_with_zero.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (ring.{0} (linear_ordered_comm_group_with_zero.{0} string.iterator_imp)) h0)  := sorry --non-trivial
lemma new_lemma_43307 (h0 : functor.add_const (topological_space (non_assoc_semiring unsigned)) empty) : @topological_space.separable_space.{0} (non_assoc_semiring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (non_assoc_semiring.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_43308 (h3 : ring std_gen) : strong_rank_condition std_gen := sorry --non-trivial
lemma new_lemma_43309 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_43310 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (add_cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (add_cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_43311 (h0 : topological_space (add_cancel_monoid (comm_group unsigned))) : preirreducible_space (add_cancel_monoid (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_43312 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_zero.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_43313 (h0 : group (left_cancel_monoid (semiring empty))) : is_cyclic (left_cancel_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_43314 (h0 : not (uniform_space (with_bot congr_arg_kind) -> false)) : @separated_space.{0} (with_bot.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (uniform_space.{0} (with_bot.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_43315 (h0 : uniform_space (has_neg num)) : complete_space (has_neg num) := sorry --non-trivial
lemma new_lemma_43316 (h0 : measurable_space (has_sub unsigned)) (h1 : has_add (has_sub unsigned)) : has_measurable_add (has_sub unsigned) := sorry --non-trivial
lemma new_lemma_43317 (h0 : list (has_inter ennreal)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_43318 (h0 : functor.add_const (prod (partial_order empty) (partial_order empty)) empty) : id_rel (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_43319 (h0 : topological_space (has_top (random_gen (random_gen (random_gen linarith.comp_source))))) : totally_disconnected_space (has_top (random_gen (random_gen (random_gen linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_43320 (h0 : topological_space (has_Sup (semiring (semiring (semiring congr_arg_kind))))) : t1_space (has_Sup (semiring (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_43321 (h0 : functor.add_const (functor.add_const Prop (boolean_algebra pos)) linarith.comp) : functor.add_const.run (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_43322 (h0 : topological_space (normed_group (has_top (has_top num)))) : preirreducible_space (normed_group (has_top (has_top num))) := sorry --non-trivial
lemma new_lemma_43323 (h0 : not (has_mem.mem (with_one num) has_emptyc.emptyc -> false)) : @is_domain.{0} (with_one.{0} num) (@finset.pi.empty.{1 0} Type ring.{0} (with_one.{0} num) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_one.{0} num) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_43324 (h0 : function.extfun Type topological_space) : @t1_space.{0} (has_zero.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_43325 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (canonically_ordered_comm_semiring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_43326 (h0 : function.extfun Type group) : @is_simple_group.{0} (has_nndist.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (has_nndist.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_43327 (h0 : functor.add_const (topological_space (left_cancel_monoid congr_arg_kind)) (option unsigned)) : @preirreducible_space.{0} (left_cancel_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} congr_arg_kind)) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_43328 (h0 : monoid (has_add (has_neg (has_neg (has_add linarith.comp))))) : monoid.fg (has_add (has_neg (has_neg (has_add linarith.comp)))) := sorry --non-trivial
lemma new_lemma_43329 (h0 : uniform_space (simple_graph linarith.ineq)) : complete_space (simple_graph linarith.ineq) := sorry --non-trivial
lemma new_lemma_43330 (h0 : cancel_comm_monoid_with_zero (plift (semiring (semiring num)))) : unique_factorization_monoid (plift (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_43331 (h0 : complete_lattice (id (random_gen num))) : complete_lattice.is_Sup_finite_compact (id (random_gen num)) := sorry --non-trivial
lemma new_lemma_43332 (h0 : ring (ordered_cancel_add_comm_monoid (option (option ennreal)))) : strong_rank_condition (ordered_cancel_add_comm_monoid (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_43333 (h0 : add_monoid (has_dist empty)) : add_monoid.fg (has_dist empty) := sorry --non-trivial
lemma new_lemma_43334 (h0 : group (normed_lattice_add_comm_group (sub_neg_monoid Type))) : group.fg (normed_lattice_add_comm_group (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_43335 (h1 : uniform_space (has_neg string_imp)) : complete_space (has_neg string_imp) := sorry --non-trivial
lemma new_lemma_43336 (h0 : group (is_R_or_C unsigned)) : normalizer_condition (is_R_or_C unsigned) := sorry --non-trivial
lemma new_lemma_43337 (h1 : ring (div_inv_monoid linarith.ineq)) : is_domain (div_inv_monoid linarith.ineq) := sorry --non-trivial
lemma new_lemma_43338 (h0 : functor.add_const (topological_space (add_cancel_monoid pos)) Type) : @topological_space.separable_space.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (add_cancel_monoid.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_43339 (h0 : ring (linear_ordered_add_comm_group_with_top unsigned)) : rank_condition (linear_ordered_add_comm_group_with_top unsigned) := sorry --non-trivial
lemma new_lemma_43340 (h0 : ring (has_lt (comm_ring to_additive.value_type))) : rank_condition (has_lt (comm_ring to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_43341 (h0 : add_group (has_union (has_top linarith.comp))) : is_add_cyclic (has_union (has_top linarith.comp)) := sorry --non-trivial
lemma new_lemma_43342 (h0 : function.extfun (finset Type) (has_mem.mem (normed_group congr_arg_kind))) : @add_monoid.fg.{0} (normed_group.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type add_monoid.{0} (normed_group.{0} congr_arg_kind) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (normed_group.{0} congr_arg_kind)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_43343 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (has_one.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_one.{0} num))  := sorry --non-trivial
lemma new_lemma_43344 (h0 : cancel_comm_monoid_with_zero (has_nndist unsigned)) : unique_factorization_monoid (has_nndist unsigned) := sorry --non-trivial
lemma new_lemma_43345 (h0 : functor.add_const (ring (boolean_algebra Type)) (comm_group name)) : @rank_condition.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (boolean_algebra.{1} Type)) (comm_group.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_43346 (h0 : ring (has_edist (option unsigned))) : strong_rank_condition (has_edist (option unsigned)) := sorry --non-trivial
lemma new_lemma_43347 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (finset.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_43348 (h0 : functor.add_const (add_monoid (cancel_monoid name)) environment.implicit_infer_kind) : @add_monoid.fg.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (add_monoid.{0} (cancel_monoid.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_43349 (h0 : filter (has_top (random_gen (random_gen to_additive.value_type)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_43350 (h0 : topological_space (normed_comm_ring (comm_group unsigned))) : totally_separated_space (normed_comm_ring (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_43351 (h0 : topological_space (has_top (has_top (has_top fun_info)))) : locally_compact_space (has_top (has_top (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_43352 (h0 : functor.add_const (topological_space (comm_group name)) linarith.comp) : @preirreducible_space.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_43353 (h0 : topological_space (has_neg_part (finset name))) : totally_disconnected_space (has_neg_part (finset name)) := sorry --non-trivial
lemma new_lemma_43354 (h0 : fin has_zero.zero) : @preconnected_space.{0} (has_to_string.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (has_to_string.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_43355 (h0 : ring (with_bot (comm_ring linarith.ineq))) : rank_condition (with_bot (comm_ring linarith.ineq)) := sorry --non-trivial
lemma new_lemma_43356 (h0 : topological_space (normed_comm_ring (has_add environment.implicit_infer_kind))) : preconnected_space (normed_comm_ring (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_43357 (h0 : functor.add_const (semiring (has_pos_part pos)) linarith.comp) : @is_noetherian_ring.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 0} (semiring.{0} (has_pos_part.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_43358 (h0 : functor.add_const (group (boolean_algebra.core name)) Type) : @is_simple_group.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 1} (group.{0} (boolean_algebra.core.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_43359 (h0 : ring (add_group_with_zero_nhd (has_norm fun_info))) : rank_condition (add_group_with_zero_nhd (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_43360 (h0 : not (topological_space (plift num) -> false)) : @t1_space.{1} (plift.{1} num) (@classical.by_contradiction'.{2} (topological_space.{1} (plift.{1} num)) h0)  := sorry --non-trivial
lemma new_lemma_43361 (h0 : uniform_space (boolean_algebra (boolean_algebra Type))) : separated_space (boolean_algebra (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_43362 (h0 : add_group (add_cancel_monoid (finset (finset environment.implicit_infer_kind)))) : is_add_cyclic (add_cancel_monoid (finset (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_43363 (h0 : group (normed_lattice_add_comm_group (sub_neg_monoid Type))) : is_simple_group (normed_lattice_add_comm_group (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_43364 (h0 : complete_lattice (random_gen (mul_one_class linarith.comp_source))) : is_compactly_generated (random_gen (mul_one_class linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_43365 (h0 : complete_lattice (measurable_space (has_norm (has_norm fun_info)))) : is_compactly_generated (measurable_space (has_norm (has_norm fun_info))) := sorry --non-trivial
lemma new_lemma_43366 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (has_bot.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_bot.{0} pos))  := sorry --non-trivial
lemma new_lemma_43367 (h0 : topological_space (canonically_ordered_monoid (has_Inf (has_Inf Type)))) : t1_space (canonically_ordered_monoid (has_Inf (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_43368 (h0 : function.extfun nat fin) : @regular_space.{0} (generalized_boolean_algebra.{0} name) (@matrix.vec_empty.{0} (topological_space.{0} (generalized_boolean_algebra.{0} name)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_43369 (h0 : topological_space (has_pos_part (has_add (has_to_string (has_to_string (ring pos)))))) : discrete_topology (has_pos_part (has_add (has_to_string (has_to_string (ring pos))))) := sorry --non-trivial
lemma new_lemma_43370 (h0 : functor.add_const (topological_space (has_to_string name)) Type) : @sequential_space.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (has_to_string.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_43371 (h0 : topological_space (canonically_ordered_monoid (ordered_comm_monoid pos))) : preconnected_space (canonically_ordered_monoid (ordered_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_43372 (h0 : functor.add_const (topological_space (boolean_algebra.core Type)) (boolean_algebra.core Type)) : @path_connected_space.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (boolean_algebra.core.{1} Type)) (boolean_algebra.core.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_43373 (h0 : topological_space (has_emptyc (semiring (semiring empty)))) : totally_disconnected_space (has_emptyc (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_43374 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} string_imp (@function.extfun_app.{2 1} Type ring.{0} h0 string_imp)  := sorry --non-trivial
lemma new_lemma_43375 (h1 : topological_space (distrib char)) : totally_disconnected_space (distrib char) := sorry --non-trivial
lemma new_lemma_43376 (h0 : complete_lattice (finset real)) : is_atomistic (finset real) := sorry --non-trivial
lemma new_lemma_43377 (h0 : set (non_unital_non_assoc_semiring (mul_one_class string_imp))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_43378 (h0 : function.extfun Type ring) : @rank_condition.{0} (with_one.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} h0 (with_one.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_43379 (h0 : group (comm_ring (denumerable (denumerable (metric_space (random_gen to_additive.value_type)))))) : is_cyclic (comm_ring (denumerable (denumerable (metric_space (random_gen to_additive.value_type))))) := sorry --non-trivial
lemma new_lemma_43380 (h0 : functor.add_const (ordered_comm_monoid (boolean_algebra.core environment.implicit_infer_kind)) pos) : @has_exists_mul_of_le.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_43381 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (add_right_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_right_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_43382 (h0 : group (distrib (has_nnnorm (has_nnnorm linarith.ineq)))) : is_cyclic (distrib (has_nnnorm (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_43383 (h1 : add_group (has_top (random_gen string_imp))) : is_add_cyclic (has_top (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_43384 (h0 : ring (has_to_string (ordered_comm_ring Type))) : is_domain (has_to_string (ordered_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_43385 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (finset.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (finset.{0} num))  := sorry --non-trivial
lemma new_lemma_43386 (h0 : filter (semigroup (has_add (add_comm_monoid pos)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_43387 (h0 : complete_lattice (has_union congr_arg_kind)) : complete_lattice.is_Sup_finite_compact (has_union congr_arg_kind) := sorry --non-trivial
lemma new_lemma_43388 (h0 : topological_space (complete_distrib_lattice (has_add (ring (has_neg_part Type))))) : preirreducible_space (complete_distrib_lattice (has_add (ring (has_neg_part Type)))) := sorry --non-trivial
lemma new_lemma_43389 (h0 : functor.comp cancel_comm_monoid_with_zero complete_distrib_lattice environment.implicit_infer_kind) : @unique_factorization_monoid.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} cancel_comm_monoid_with_zero.{0} complete_distrib_lattice.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_43390 (h0 : not (complete_lattice (denumerable reducibility_hints) -> false)) : @is_compactly_generated.{0} (denumerable.{0} reducibility_hints) (@classical.by_contradiction'.{1} (complete_lattice.{0} (denumerable.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_43391 (h0 : ring (has_add (ordered_comm_monoid real))) : rank_condition (has_add (ordered_comm_monoid real)) := sorry --non-trivial
lemma new_lemma_43392 (h1 : topological_space (with_zero fun_info)) : t0_space (with_zero fun_info) := sorry --non-trivial
lemma new_lemma_43393 (h2 : topological_space (measurable_space linarith.ineq)) : path_connected_space (measurable_space linarith.ineq) := sorry --non-trivial
lemma new_lemma_43394 (h0 : ring (left_cancel_monoid empty)) : is_principal_ideal_ring (left_cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_43395 (h0 : not (complete_lattice (distrib linarith.ineq) -> false)) : @is_compactly_generated.{0} (distrib.{0} linarith.ineq) (@classical.by_contradiction'.{1} (complete_lattice.{0} (distrib.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_43396 (h1 : add_group (metric_space string_imp)) : is_add_cyclic (metric_space string_imp) := sorry --non-trivial
lemma new_lemma_43397 (h0 : list (has_norm (has_nnnorm to_additive.value_type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_43398 (h0 : functor.add_const (topological_space (has_neg linarith.comp)) linarith.comp) : @t0_space.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_43399 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (finset.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (finset.{0} num))  := sorry --non-trivial
lemma new_lemma_43400 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_dist.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} h0 (has_dist.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_43401 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (measurable_space.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (measurable_space.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_43402 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (normed_group.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (normed_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_43403 (h0 : functor.add_const (ring (mul_zero_class unsigned)) num) : @rank_condition.{0} (mul_zero_class.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (mul_zero_class.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_43404 (h0 : ring (complete_distrib_lattice (comm_group (comm_group name)))) : is_principal_ideal_ring (complete_distrib_lattice (comm_group (comm_group name))) := sorry --non-trivial
lemma new_lemma_43405 (h0 : functor.add_const (complete_lattice (plift num)) num) : @is_compactly_generated.{1} (plift.{1} num) (@functor.add_const.run.{1 0} (complete_lattice.{1} (plift.{1} num)) num h0)  := sorry --non-trivial
lemma new_lemma_43406 (h0 : topological_space (has_neg_part Type)) : preirreducible_space (has_neg_part Type) := sorry --non-trivial
lemma new_lemma_43407 (h0 : functor.add_const (topological_space (boolean_algebra Type)) (has_Inf pos)) : @t0_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.{1} Type)) (has_Inf.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_43408 (h0 : function.extfun Type (functor.comp topological_space finset)) : @sequential_space.{0} (finset.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} finset.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} finset.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_43409 (h0 : uniform_space (id (semiring fun_info))) : separated_space (id (semiring fun_info)) := sorry --non-trivial
lemma new_lemma_43410 (h0 : topological_space (with_one to_additive.value_type)) : totally_separated_space (with_one to_additive.value_type) := sorry --non-trivial
lemma new_lemma_43411 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_neg_part.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_43412 (h0 : function.extfun (num -> Type) (function.extfun num)) : @infi.{0 1} Prop (@conditionally_complete_lattice.to_has_Inf.{0} Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice)) num (@function.extfun_app.{1 1} num (λ (x : num), Prop) (@function.extfun_app.{2 1} (num → Type) (function.extfun.{1 1} num) h0 (λ (x : num), Prop)))  := sorry --non-trivial
lemma new_lemma_43413 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_one.{0} (has_norm.{0} empty)) (@function.extfun_app.{2 1} Type group.{0} h0 (has_one.{0} (has_norm.{0} empty)))  := sorry --non-trivial
lemma new_lemma_43414 (h0 : ring (has_union (semiring congr_arg_kind))) : rank_condition (has_union (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_43415 (h0 : group (has_nndist (has_neg_part (has_neg name)))) : normalizer_condition (has_nndist (has_neg_part (has_neg name))) := sorry --non-trivial
lemma new_lemma_43416 (h0 : finset (group_with_zero (option ennreal))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_43417 (h0 : functor.add_const (complete_lattice (canonically_ordered_comm_semiring pos)) pos) : @complete_lattice.is_Sup_finite_compact.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (canonically_ordered_comm_semiring.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_43418 (h0 : topological_space (canonically_ordered_add_monoid congr_arg_kind)) : totally_separated_space (canonically_ordered_add_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_43419 (h0 : topological_space linarith.ineq) : path_connected_space linarith.ineq := sorry --non-trivial
lemma new_lemma_43420 (h0 : list (boolean_algebra (has_neg linarith.comp))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_43421 (h0 : functor.add_const (topological_space (add_comm_monoid name)) name) : @preconnected_space.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_43422 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} num (@function.extfun_app.{2 1} Type topological_space.{0} h0 num)  := sorry --non-trivial
lemma new_lemma_43423 (h0 : topological_space (normed_comm_ring (has_neg pos))) : totally_disconnected_space (normed_comm_ring (has_neg pos)) := sorry --non-trivial
lemma new_lemma_43424 (h0 : topological_space (boolean_algebra (comm_group pos))) : loc_path_connected_space (boolean_algebra (comm_group pos)) := sorry --non-trivial
lemma new_lemma_43425 (h0 : functor.add_const (semiring (bin_tree congr_arg_kind)) congr_arg_kind) : @is_noetherian_ring.{0} (bin_tree.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (semiring.{0} (bin_tree.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_43426 (h0 : topological_space (linear_ordered_field (option (option (option (option (option unsigned))))))) : discrete_topology (linear_ordered_field (option (option (option (option (option unsigned)))))) := sorry --non-trivial
lemma new_lemma_43427 (h0 : functor.add_const (topological_space (has_nndist Type)) name) : @preconnected_space.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_nndist.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_43428 (h0 : functor.comp topological_space add_cancel_monoid (lex (semigroup (has_to_string real)))) : @loc_path_connected_space.{0} (add_cancel_monoid.{0} (lex.{0} (semigroup.{0} (has_to_string.{0} real)))) (@functor.comp.run.{0 0 0} topological_space.{0} add_cancel_monoid.{0} (lex.{0} (semigroup.{0} (has_to_string.{0} real))) h0)  := sorry --non-trivial
lemma new_lemma_43429 (h0 : topological_space (with_bot linarith.comp)) : t0_space (with_bot linarith.comp) := sorry --non-trivial
lemma new_lemma_43430 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (ordered_comm_ring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_43431 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @locally_compact_space.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_43432 (h0 : functor.add_const (topological_space (has_to_string Type)) Type) : @t1_space.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_to_string.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_43433 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (generalized_boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (generalized_boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_43434 (h0 : ring (topological_space (random_gen string_imp))) : strong_rank_condition (topological_space (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_43435 (h0 : monoid (has_norm (has_norm (has_norm (has_norm (has_norm (has_norm linarith.comp))))))) : monoid.fg (has_norm (has_norm (has_norm (has_norm (has_norm (has_norm linarith.comp)))))) := sorry --non-trivial
lemma new_lemma_43436 (h0 : list (finset (option empty))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_43437 (h0 : functor.add_const (complete_lattice (normed_comm_ring linarith.comp)) environment.implicit_infer_kind) : @is_atomistic.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (normed_comm_ring.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_43438 (h0 : filter (has_ssubset (has_inv linarith.ineq))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_43439 (h0 : topological_space (generalized_boolean_algebra (ring linarith.comp))) : irreducible_space (generalized_boolean_algebra (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_43440 (h0 : group (ring pos)) : is_simple_group (ring pos) := sorry --non-trivial
lemma new_lemma_43441 (h0 : semiring real) : is_noetherian_ring real := sorry --non-trivial
lemma new_lemma_43442 (h0 : add_group (add_cancel_monoid (option (option (option empty))))) : is_add_cyclic (add_cancel_monoid (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_43443 (h0 : topological_space enat) (h4 : preorder enat) : order_closed_topology enat := sorry --non-trivial
lemma new_lemma_43444 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (has_norm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_43445 (h0 : functor.add_const (ordered_add_comm_monoid (boolean_algebra environment.implicit_infer_kind)) unsigned) : @archimedean.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_43446 (h0 : topological_space (add_comm_semigroup (add_comm_semigroup (mul_one_class (mul_one_class ereal))))) : path_connected_space (add_comm_semigroup (add_comm_semigroup (mul_one_class (mul_one_class ereal)))) := sorry --non-trivial
lemma new_lemma_43447 (h0 : canonically_linear_ordered_monoid name -> canonically_linear_ordered_monoid name -> Prop) : transitive h0 := sorry --non-trivial
lemma new_lemma_43448 (h0 : complete_lattice (ordered_comm_ring (sub_neg_monoid name))) : complete_lattice.is_Sup_finite_compact (ordered_comm_ring (sub_neg_monoid name)) := sorry --non-trivial
lemma new_lemma_43449 (h0 : add_monoid (linear_ordered_cancel_comm_monoid unsigned)) : add_monoid.fg (linear_ordered_cancel_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_43450 (h0 : functor.add_const Prop (has_add (has_nndist name))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_43451 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (linear_ordered_semiring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_43452 (h1 : uniform_space (add_comm_semigroup fun_info)) : complete_space (add_comm_semigroup fun_info) := sorry --non-trivial
lemma new_lemma_43453 (h1 : topological_space (add_monoid (has_nnnorm char))) : path_connected_space (add_monoid (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_43454 (h0 : function.extfun (Type 1) topological_space) : @locally_compact_space.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_43455 (h1 : Prop) : function.sometimes (fun (h0 : environment.implicit_infer_kind), h1) := sorry --non-trivial
lemma new_lemma_43456 (h0 : complete_lattice (cancel_monoid (finset Type))) : complete_lattice.is_Sup_finite_compact (cancel_monoid (finset Type)) := sorry --non-trivial
lemma new_lemma_43457 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (has_neg.{0} num) (@function.extfun_app.{2 1} Type semiring.{0} h0 (has_neg.{0} num))  := sorry --non-trivial
lemma new_lemma_43458 (h0 : ordered_add_comm_monoid (has_zero (finset name))) : archimedean (has_zero (finset name)) := sorry --non-trivial
lemma new_lemma_43459 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (add_left_cancel_semigroup.{0} (option.{0} (option.{0} unsigned))) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_left_cancel_semigroup.{0} (option.{0} (option.{0} unsigned))))  := sorry --non-trivial
lemma new_lemma_43460 (h0 : group (has_to_string (ring (finset pos)))) : group.fg (has_to_string (ring (finset pos))) := sorry --non-trivial
lemma new_lemma_43461 (h1 : has_lt (normed_field ereal)) : no_max_order (normed_field ereal) := sorry --non-trivial
lemma new_lemma_43462 (h0 : functor.add_const (topological_space (has_bot empty)) (semiring (semiring (semiring empty)))) : @preirreducible_space.{0} (has_bot.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_bot.{0} empty)) (semiring.{0} (semiring.{0} (semiring.{0} empty))) h0)  := sorry --non-trivial
lemma new_lemma_43463 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_norm.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_norm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_43464 (h0 : topological_space (canonically_linear_ordered_monoid (ordered_comm_monoid real))) : sequential_space (canonically_linear_ordered_monoid (ordered_comm_monoid real)) := sorry --non-trivial
lemma new_lemma_43465 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (complete_distrib_lattice.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (complete_distrib_lattice.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_43466 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (linear_ordered_semiring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_ordered_semiring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_43467 (h0 : function.extfun Type comm_ring) : @local_ring.{0} (has_to_string.{0} unsigned) (@function.extfun_app.{2 1} Type comm_ring.{0} h0 (has_to_string.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_43468 (h0 : functor.add_const (topological_space (has_neg pos)) (comm_group Type)) : @locally_compact_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg.{0} pos)) (comm_group.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_43469 (h0 : complete_lattice (has_top (has_norm to_additive.value_type))) : complete_lattice.is_Sup_finite_compact (has_top (has_norm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_43470 (h0 : topological_space (generalized_boolean_algebra (has_Inf (has_Inf (has_Inf real))))) : irreducible_space (generalized_boolean_algebra (has_Inf (has_Inf (has_Inf real)))) := sorry --non-trivial
lemma new_lemma_43471 (h0 : has_le linarith.ineq) (h1 : linarith.ineq) : is_bot h1 := sorry --non-trivial
lemma new_lemma_43472 (h0 : topological_space (has_ssubset (has_neg char))) : t0_space (has_ssubset (has_neg char)) := sorry --non-trivial
lemma new_lemma_43473 (h0 : functor.comp topological_space comm_group unsigned) : @preirreducible_space.{0} (comm_group.{0} unsigned) (@functor.comp.run.{0 0 0} topological_space.{0} comm_group.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_43474 (h0 : ring (has_inf (option (option ennreal)))) : is_domain (has_inf (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_43475 (h0 : functor.add_const (ordered_add_comm_monoid (has_star empty)) unsigned) : @archimedean.{0} (has_star.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_star.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_43476 (h0 : not (cancel_comm_monoid_with_zero (mul_zero_class unsigned) -> false)) : @unique_factorization_monoid.{0} (mul_zero_class.{0} unsigned) (@classical.by_contradiction'.{1} (cancel_comm_monoid_with_zero.{0} (mul_zero_class.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_43477 (h0 : ordered_add_comm_monoid (semigroup (has_neg Type))) : archimedean (semigroup (has_neg Type)) := sorry --non-trivial
lemma new_lemma_43478 (h0 : ring (mul_one_class (canonically_linear_ordered_monoid string_imp))) : is_domain (mul_one_class (canonically_linear_ordered_monoid string_imp)) := sorry --non-trivial
lemma new_lemma_43479 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 pos) := sorry --non-trivial
lemma new_lemma_43480 (h0 : add_group (semiring (semiring empty))) : is_add_cyclic (semiring (semiring empty)) := sorry --non-trivial
lemma new_lemma_43481 (h0 : linear_ordered_field (option linarith.comp_source)) (h1 : ring (finset nat)) (h2 : finset nat -> option linarith.comp_source) : is_cau_seq h2 finset.Iio := sorry --non-trivial
lemma new_lemma_43482 (h0 : has_neg (semi_normed_comm_ring linarith.ineq)) (h1 : measurable_space (semi_normed_comm_ring linarith.ineq)) : has_measurable_neg (semi_normed_comm_ring linarith.ineq) := sorry --non-trivial
lemma new_lemma_43483 (h0 : functor.add_const (topological_space (ordered_comm_ring pos)) Type) : @regular_space.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (ordered_comm_ring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_43484 (h0 : uniform_space (normed_group (semiring num))) : complete_space (normed_group (semiring num)) := sorry --non-trivial
lemma new_lemma_43485 (h0 : not (semiring (canonically_linear_ordered_monoid num) -> false)) : @is_noetherian_ring.{0} (canonically_linear_ordered_monoid.{0} num) (@classical.by_contradiction'.{1} (semiring.{0} (canonically_linear_ordered_monoid.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_43486 (h0 : complete_lattice (has_add (random_gen linarith.ineq))) : complete_lattice.is_Sup_finite_compact (has_add (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_43487 (h0 : complete_lattice (cancel_monoid congr_arg_kind)) : is_compactly_generated (cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_43488 (h0 : topological_space (has_neg (has_to_string (has_pos_part pos)))) : sequential_space (has_neg (has_to_string (has_pos_part pos))) := sorry --non-trivial
lemma new_lemma_43489 (h0 : ring (has_emptyc empty)) : strong_rank_condition (has_emptyc empty) := sorry --non-trivial
lemma new_lemma_43490 (h3 : topological_space linarith.ineq) : path_connected_space linarith.ineq := sorry --non-trivial
lemma new_lemma_43491 (h0 : topological_space (has_one (has_norm congr_arg_kind))) : t0_space (has_one (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_43492 (h0 : group (has_ssubset (has_top fun_info))) : group.fg (has_ssubset (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_43493 (h0 : group (has_compl linarith.ineq)) : group.fg (has_compl linarith.ineq) := sorry --non-trivial
lemma new_lemma_43494 (h0 : ordered_add_comm_monoid (option (option (option (option (option (option (option unsigned)))))))) : archimedean (option (option (option (option (option (option (option unsigned))))))) := sorry --non-trivial
lemma new_lemma_43495 (h0 : functor.add_const (ring (has_zero Type)) (has_neg_part Type)) : @rank_condition.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 1} (ring.{1} (has_zero.{1} Type)) (has_neg_part.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_43496 (h0 : function.extfun (Type 1) ring) : @rank_condition.{1} (canonically_ordered_comm_semiring.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (canonically_ordered_comm_semiring.{1} Type))  := sorry --non-trivial
lemma new_lemma_43497 (h0 : topological_space (has_neg (option (option ennreal)))) : t0_space (has_neg (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_43498 (h0 : preorder (linear_ordered_comm_group_with_zero linarith.ineq)) (h1 : pred_order (linear_ordered_comm_group_with_zero linarith.ineq)) : is_pred_archimedean (linear_ordered_comm_group_with_zero linarith.ineq) := sorry --non-trivial
lemma new_lemma_43499 (h0 : uniform_space (left_cancel_monoid congr_arg_kind)) : complete_space (left_cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_43500 (h0 : functor.add_const (semiring (preorder num)) empty) : @is_noetherian_ring.{0} (preorder.{0} num) (@functor.add_const.run.{0 0} (semiring.{0} (preorder.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_43501 (h0 : group (ordered_comm_monoid (ring Type))) : normalizer_condition (ordered_comm_monoid (ring Type)) := sorry --non-trivial
lemma new_lemma_43502 (h0 : monoid (comm_semigroup real)) : monoid.fg (comm_semigroup real) := sorry --non-trivial
lemma new_lemma_43503 (h0 : function.extfun nat fin) : @is_add_cyclic.{0} (has_add.{0} real) (@matrix.vec_empty.{0} (add_group.{0} (has_add.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_43504 (h0 : group (canonically_linear_ordered_monoid (has_Inf (has_Inf real)))) : is_simple_group (canonically_linear_ordered_monoid (has_Inf (has_Inf real))) := sorry --non-trivial
lemma new_lemma_43505 (h0 : topological_space (comm_group (has_add (add_cancel_monoid name)))) : loc_path_connected_space (comm_group (has_add (add_cancel_monoid name))) := sorry --non-trivial
lemma new_lemma_43506 (h0 : functor.add_const (topological_space (has_add real)) (has_Inf Type)) : @regular_space.{0} (has_add.{0} real) (@functor.add_const.run.{0 1} (topological_space.{0} (has_add.{0} real)) (has_Inf.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_43507 (h0 : functor.add_const (topological_space (has_zero unsigned)) name) : @sequential_space.{0} (has_zero.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_43508 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (canonically_ordered_comm_semiring pos)) := sorry --non-trivial
lemma new_lemma_43509 (h0 : ring (add_comm_monoid (finset ennreal))) : strong_rank_condition (add_comm_monoid (finset ennreal)) := sorry --non-trivial
lemma new_lemma_43510 (h0 : monoid (with_bot (random_gen (random_gen linarith.comp_source)))) : monoid.fg (with_bot (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_43511 (h0 : functor.add_const (complete_lattice (add_cancel_comm_monoid empty)) empty) : @is_atomistic.{0} (add_cancel_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_cancel_comm_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_43512 (h0 : function.extfun (finset Type) (has_mem.mem (normed_group unsigned))) : @separated_space.{0} (normed_group.{0} unsigned) (@finset.pi.empty.{1 0} Type uniform_space.{0} (normed_group.{0} unsigned) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (normed_group.{0} unsigned)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_43513 (h0 : functor.add_const (ring (has_star empty)) num) : @strong_rank_condition.{0} (has_star.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (has_star.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_43514 (h0 : not (function.extfun Type filter -> false)) : filter.ne_bot (function.extfun_app (classical.by_contradiction' h0) (preorder empty)) := sorry --non-trivial
lemma new_lemma_43515 (h0 : complete_lattice (distrib (has_nnnorm linarith.comp_source))) : complete_lattice.is_Sup_finite_compact (distrib (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_43516 (h0 : ring (topological_space (mul_one_class fun_info))) : is_domain (topological_space (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_43517 (h0 : list (semigroup (option (option (option (option (option (option (option (option (option unsigned))))))))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_43518 (h0 : group (ordered_cancel_add_comm_monoid (option ennreal))) : is_simple_group (ordered_cancel_add_comm_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_43519 (h0 : topological_space (add_group (semiring (semiring unsigned)))) : locally_compact_space (add_group (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_43520 (h0 : function.extfun Type topological_space) : @normal_space.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_43521 (h0 : group (canonically_ordered_monoid real)) : is_simple_group (canonically_ordered_monoid real) := sorry --non-trivial
lemma new_lemma_43522 (h0 : topological_space (ordered_comm_monoid (has_add Type))) : topological_space.separable_space (ordered_comm_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_43523 (h0 : functor.add_const (list (semigroup name)) Type) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_43524 (h0 : functor.add_const (complete_lattice (has_inter unsigned)) num) : @is_compactly_generated.{0} (has_inter.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_inter.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_43525 (h0 : has_top unsigned -> has_top unsigned -> Prop) : is_strict_order (has_top unsigned) h0 := sorry --non-trivial
lemma new_lemma_43526 (h0 : functor.add_const (list (add_cancel_monoid pos)) environment.implicit_infer_kind) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_43527 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @topological_space.separable_space.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_43528 (h0 : uniform_space (denumerable (has_inv (comm_ring (random_gen fun_info))))) : complete_space (denumerable (has_inv (comm_ring (random_gen fun_info)))) := sorry --non-trivial
lemma new_lemma_43529 (h0 : function.extfun Type topological_space) : @normal_space.{0} (monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_43530 (h0 : add_group (comm_ring (random_gen (random_gen (random_gen (random_gen string_imp)))))) : is_add_cyclic (comm_ring (random_gen (random_gen (random_gen (random_gen string_imp))))) := sorry --non-trivial
lemma new_lemma_43531 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (linear_ordered_cancel_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_cancel_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_43532 (h0 : group (has_ssubset (random_gen string_imp))) : group.fg (has_ssubset (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_43533 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_43534 (h0 : group (has_top (random_gen linarith.comp_source))) : group.fg (has_top (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_43535 (h0 : fin has_zero.zero) : @is_compactly_generated.{0} (boolean_algebra.{0} pos) (@matrix.vec_empty.{0} (complete_lattice.{0} (boolean_algebra.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_43536 (h0 : not (function.extfun Type monoid -> false)) : @monoid.fg.{0} (normed_group.{0} linarith.ineq) (@function.extfun_app.{2 1} Type monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type monoid.{0}) h0) (normed_group.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_43537 (h0 : has_mem.mem (normed_group linarith.comp_source) has_emptyc.emptyc) : @group.fg.{0} (normed_group.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type group.{0} (normed_group.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_43538 (h0 : filter (add_monoid linarith.ineq)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_43539 (h0 : topological_space (measurable_space (random_gen num))) : path_connected_space (measurable_space (random_gen num)) := sorry --non-trivial
lemma new_lemma_43540 (h0 : function.extfun Type group) : @is_cyclic.{0} (linear_ordered_add_comm_group.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} h0 (linear_ordered_add_comm_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_43541 (h0 : function.extfun Type topological_space) : @t0_space.{0} (comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_43542 (h0 : topological_space (simple_graph (sub_neg_monoid (has_add (boolean_algebra.core pos))))) : totally_separated_space (simple_graph (sub_neg_monoid (has_add (boolean_algebra.core pos)))) := sorry --non-trivial
lemma new_lemma_43543 (h0 : group (has_zero (has_neg (has_neg (ring (add_cancel_monoid Type)))))) : normalizer_condition (has_zero (has_neg (has_neg (ring (add_cancel_monoid Type))))) := sorry --non-trivial
lemma new_lemma_43544 (h0 : ring congr_arg_kind) : is_domain congr_arg_kind := sorry --non-trivial
lemma new_lemma_43545 (h0 : ring (div_inv_monoid to_additive.value_type)) : is_domain (div_inv_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_43546 (h0 : uniform_space (has_bot (has_Inf (sub_neg_monoid real)))) : separated_space (has_bot (has_Inf (sub_neg_monoid real))) := sorry --non-trivial
lemma new_lemma_43547 (h1 : add_group (has_top string_imp)) : is_add_cyclic (has_top string_imp) := sorry --non-trivial
lemma new_lemma_43548 (h0 : function.extfun Type group) : @group.fg.{0} (normed_group.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (normed_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_43549 (h0 : topological_space environment.implicit_infer_kind) : totally_disconnected_space environment.implicit_infer_kind := sorry --non-trivial
lemma new_lemma_43550 (h0 : list (semigroup (has_neg (has_neg Type)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_43551 (h0 : topological_space (ordered_comm_ring (has_add linarith.comp))) : loc_path_connected_space (ordered_comm_ring (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_43552 (h0 : functor.add_const (topological_space (left_cancel_semigroup unsigned)) congr_arg_kind) : @t0_space.{0} (left_cancel_semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_semigroup.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_43553 (h0 : fin has_zero.zero) : @ulower.up.{0} Prop encodable.Prop (@matrix.vec_empty.{0} (@ulower.{0} Prop encodable.Prop) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)))  := sorry --non-trivial
lemma new_lemma_43554 (h0 : functor.add_const (complete_lattice (has_add Type)) Type) : @is_atomistic.{1} (has_add.{1} Type) (@functor.add_const.run.{1 1} (complete_lattice.{1} (has_add.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_43555 (h0 : ring (has_top (has_top congr_arg_kind))) : rank_condition (has_top (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_43556 (h0 : topological_space (complete_distrib_lattice (has_to_string pos))) : normal_space (complete_distrib_lattice (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_43557 (h0 : complete_lattice (has_top (has_norm congr_arg_kind))) : complete_lattice.is_Sup_finite_compact (has_top (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_43558 (h0 : ring (pseudo_metric_space congr_arg_kind)) : rank_condition (pseudo_metric_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_43559 (h0 : has_lt (has_div (mul_one_class environment.projection_info))) : no_max_order (has_div (mul_one_class environment.projection_info)) := sorry --non-trivial
lemma new_lemma_43560 (h0 : group (normed_group (random_gen (random_gen (random_gen linarith.ineq))))) : normalizer_condition (normed_group (random_gen (random_gen (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_43561 (h0 : functor.add_const (function.extfun Type add_group) linarith.comp) : @is_add_cyclic.{0} (ordered_comm_ring.{0} name) (@function.extfun_app.{2 1} Type add_group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_group.{0}) linarith.comp h0) (ordered_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_43562 (h0 : functor.add_const (topological_space (comm_group pos)) name) : @irreducible_space.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_43563 (h0 : functor.add_const (uniform_space (has_to_string Type)) (has_neg Type)) : @separated_space.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 1} (uniform_space.{1} (has_to_string.{1} Type)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_43564 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_neg.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_43565 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (semigroup.{0} name) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_43566 (h0 : functor.add_const (topological_space (ordered_comm_ring pos)) linarith.comp) : @preconnected_space.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_43567 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (normed_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_43568 (h0 : add_monoid (linear_ordered_semiring (semiring empty))) : add_monoid.fg (linear_ordered_semiring (semiring empty)) := sorry --non-trivial
lemma new_lemma_43569 (h0 : functor.add_const (topological_space (has_add pos)) real) : @totally_separated_space.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} pos)) real h0)  := sorry --non-trivial
lemma new_lemma_43570 (h0 : topological_space (measurable_space linarith.comp_source)) : locally_compact_space (measurable_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_43571 (h0 : ring (comm_monoid empty)) : strong_rank_condition (comm_monoid empty) := sorry --non-trivial
lemma new_lemma_43572 (h0 : function.extfun Type ring) : @is_domain.{0} (has_bot.{0} (has_Inf.{0} real)) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_bot.{0} (has_Inf.{0} real)))  := sorry --non-trivial
lemma new_lemma_43573 (h0 : ring (has_one (with_bot congr_arg_kind))) : rank_condition (has_one (with_bot congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_43574 (h0 : functor.add_const (topological_space (semigroup name)) pos) : @t0_space.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_43575 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @add_monoid.fg.{0} (add_right_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) add_monoid.{0}) (add_right_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_43576 (h0 : uniform_space (ordered_ring num)) : complete_space (ordered_ring num) := sorry --non-trivial
lemma new_lemma_43577 (h0 : semiring (ordered_comm_ring (has_bot pos))) : is_noetherian_ring (ordered_comm_ring (has_bot pos)) := sorry --non-trivial
lemma new_lemma_43578 (h0 : topological_space (ring (has_add pos))) : loc_path_connected_space (ring (has_add pos)) := sorry --non-trivial
lemma new_lemma_43579 (h0 : ring (canonically_ordered_comm_semiring environment.implicit_infer_kind)) : strong_rank_condition (canonically_ordered_comm_semiring environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_43580 (h0 : group (complete_semilattice_Sup (has_nnnorm linarith.comp_source))) : group.fg (complete_semilattice_Sup (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_43581 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (has_add.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_add.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_43582 (h0 : functor.add_const (topological_space (complete_distrib_lattice Type)) (semigroup linarith.comp)) : @locally_compact_space.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (complete_distrib_lattice.{1} Type)) (semigroup.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_43583 (h0 : topological_space (normed_comm_ring (finset Type))) : regular_space (normed_comm_ring (finset Type)) := sorry --non-trivial
lemma new_lemma_43584 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (linear_ordered_comm_ring.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_ordered_comm_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_43585 (h0 : add_comm_monoid (pseudo_metric_space ennreal) -> add_comm_monoid (pseudo_metric_space ennreal) -> Prop) : is_symm (add_comm_monoid (pseudo_metric_space ennreal)) h0 := sorry --non-trivial
lemma new_lemma_43586 (h0 : topological_space (linear_ordered_comm_ring (semiring (semiring (semiring (semiring empty)))))) : normal_space (linear_ordered_comm_ring (semiring (semiring (semiring (semiring empty))))) := sorry --non-trivial
lemma new_lemma_43587 (h0 : thunk pnat) (h1 : fin has_zero.zero) : pnat.coprime (@trace_call_stack.{0} pnat h0) (@matrix.vec_empty.{0} pnat h1)  := sorry --non-trivial
lemma new_lemma_43588 (h0 : ordered_add_comm_monoid (normed_comm_ring (option pos))) : archimedean (normed_comm_ring (option pos)) := sorry --non-trivial
lemma new_lemma_43589 (h0 : uniform_space (group_with_zero (option (option (option ennreal))))) : separated_space (group_with_zero (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_43590 (h0 : functor.add_const (topological_space (cancel_monoid environment.implicit_infer_kind)) name) : @topological_space.separable_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_43591 (h0 : complete_lattice (non_unital_non_assoc_semiring to_additive.value_type)) : complete_lattice.is_Sup_finite_compact (non_unital_non_assoc_semiring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_43592 (h0 : functor.add_const (uniform_space (add_comm_monoid pos)) (mul_zero_class environment.implicit_infer_kind)) : @complete_space.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (add_comm_monoid.{0} pos)) (mul_zero_class.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_43593 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (canonically_linear_ordered_monoid ennreal)) := sorry --non-trivial
lemma new_lemma_43594 (h0 : ordered_comm_monoid (has_bot (has_Inf (has_Inf linarith.comp)))) : has_exists_mul_of_le (has_bot (has_Inf (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_43595 (h0 : functor.add_const (topological_space (linear_ordered_field pos)) name) : @sequential_space.{0} (linear_ordered_field.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_field.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_43596 (h0 : functor.add_const (topological_space (boolean_algebra.core environment.implicit_infer_kind)) Type) : @totally_disconnected_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_43597 (h0 : filter (complete_distrib_lattice (mul_zero_class name))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_43598 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_to_string.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_to_string.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_43599 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_43600 (h0 : set (distrib (mul_one_class fun_info))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_43601 (h0 : monoid (with_bot (has_inv to_additive.value_type))) : monoid.fg (with_bot (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_43602 (h0 : finset (plift congr_arg_kind)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_43603 (h0 : add_monoid (linear_ordered_semiring linarith.comp)) : add_monoid.fg (linear_ordered_semiring linarith.comp) := sorry --non-trivial
lemma new_lemma_43604 (h0 : ring (has_add (option (option ennreal)))) : rank_condition (has_add (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_43605 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (has_neg.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_neg.{0} empty))  := sorry --non-trivial
lemma new_lemma_43606 (h0 : topological_space (linear_ordered_add_comm_group (dlist linarith.ineq))) : totally_separated_space (linear_ordered_add_comm_group (dlist linarith.ineq)) := sorry --non-trivial
lemma new_lemma_43607 (h0 : ordered_add_comm_monoid (has_dist congr_arg_kind)) : archimedean (has_dist congr_arg_kind) := sorry --non-trivial
lemma new_lemma_43608 (h0 : semiring (ordered_cancel_add_comm_monoid (has_neg pos))) : is_noetherian_ring (ordered_cancel_add_comm_monoid (has_neg pos)) := sorry --non-trivial
lemma new_lemma_43609 (h0 : uniform_space (has_add (comm_group linarith.comp))) : separated_space (has_add (comm_group linarith.comp)) := sorry --non-trivial
lemma new_lemma_43610 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (comm_ring.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_ring.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_43611 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (semigroup.{0} (has_to_string.{0} congr_arg_kind)) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (semigroup.{0} (has_to_string.{0} congr_arg_kind)))  := sorry --non-trivial
lemma new_lemma_43612 (h0 : ring (has_neg_part (has_add name))) : rank_condition (has_neg_part (has_add name)) := sorry --non-trivial
lemma new_lemma_43613 (h0 : topological_space (metric_space (semiring empty))) : irreducible_space (metric_space (semiring empty)) := sorry --non-trivial
lemma new_lemma_43614 (h0 : add_group (has_Inf (has_Inf (sub_neg_monoid (has_Inf real))))) : is_add_cyclic (has_Inf (has_Inf (sub_neg_monoid (has_Inf real)))) := sorry --non-trivial
lemma new_lemma_43615 (h0 : complete_lattice (linear_ordered_comm_group (option num))) : is_atomistic (linear_ordered_comm_group (option num)) := sorry --non-trivial
lemma new_lemma_43616 (h0 : ring (has_zero (ring (ring environment.implicit_infer_kind)))) : rank_condition (has_zero (ring (ring environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_43617 (h1 : ring (add_monoid (has_lt char))) : strong_rank_condition (add_monoid (has_lt char)) := sorry --non-trivial
lemma new_lemma_43618 (h0 : function.extfun Type group) : @group.fg.{0} (linear_ordered_add_comm_group.{0} (has_nnnorm.{0} linarith.comp_source)) (@function.extfun_app.{2 1} Type group.{0} h0 (linear_ordered_add_comm_group.{0} (has_nnnorm.{0} linarith.comp_source)))  := sorry --non-trivial
lemma new_lemma_43619 (h0 : topological_space (with_bot (has_top unsigned))) : path_connected_space (with_bot (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_43620 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (has_zero.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (has_zero.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_43621 (h0 : functor.add_const (topological_space (bin_tree congr_arg_kind)) unsigned) : @normal_space.{0} (bin_tree.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (bin_tree.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_43622 (h0 : ring (has_mul fun_info)) : rank_condition (has_mul fun_info) := sorry --non-trivial
lemma new_lemma_43623 (h0 : topological_space (has_neg (has_add (has_add Type)))) : discrete_topology (has_neg (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_43624 (h1 : ring (with_one linarith.ineq)) : rank_condition (with_one linarith.ineq) := sorry --non-trivial
lemma new_lemma_43625 (h0 : has_mem.mem (linear_ordered_semiring (has_top empty)) has_emptyc.emptyc) : @normal_space.{0} (linear_ordered_semiring.{0} (has_top.{0} empty)) (@finset.pi.empty.{1 0} Type topological_space.{0} (linear_ordered_semiring.{0} (has_top.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_43626 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (linear_ordered_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (linear_ordered_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_43627 (h0 : complete_lattice to_additive.value_type) : is_compactly_generated to_additive.value_type := sorry --non-trivial
lemma new_lemma_43628 (h0 : group (random_gen (random_gen (has_inv linarith.comp_source)))) : group.fg (random_gen (random_gen (has_inv linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_43629 (h0 : topological_space (has_emptyc (measurable_space (has_norm (has_norm empty))))) : irreducible_space (has_emptyc (measurable_space (has_norm (has_norm empty)))) := sorry --non-trivial
lemma new_lemma_43630 (h0 : group (has_neg (has_to_string linarith.comp))) : group.fg (has_neg (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_43631 (h0 : has_scalar (option (option empty)) empty) : has_faithful_scalar (option (option empty)) empty := sorry --non-trivial
lemma new_lemma_43632 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (monoid_with_zero.{0} pos) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (monoid_with_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_43633 (h0 : topological_space (has_compl (distrib string.iterator_imp))) : path_connected_space (has_compl (distrib string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_43634 (h0 : group (cancel_monoid unsigned)) : is_cyclic (cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_43635 (h0 : multiset (uniform_space (mul_one_class (mul_one_class (mul_one_class fun_info))))) (h1 : not (multiset (uniform_space (mul_one_class (mul_one_class (mul_one_class fun_info)))) -> false)) : multiset.disjoint h0 (classical.by_contradiction' h1) := sorry --non-trivial
lemma new_lemma_43636 (h0 : topological_space (semigroup (option (option ennreal)))) : loc_path_connected_space (semigroup (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_43637 (h0 : filter (boolean_algebra (finset (finset linarith.comp)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_43638 (h0 : set (set (has_norm (has_inv linarith.comp_source)))) : is_countably_spanning h0 := sorry --non-trivial
lemma new_lemma_43639 (h0 : topological_space (with_bot unsigned)) : preirreducible_space (with_bot unsigned) := sorry --non-trivial
lemma new_lemma_43640 (h0 : topological_space (add_cancel_monoid unsigned)) : preirreducible_space (add_cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_43641 (h0 : topological_space (normed_comm_ring (option ennreal))) : totally_separated_space (normed_comm_ring (option ennreal)) := sorry --non-trivial
lemma new_lemma_43642 (h3 : add_group (random_gen fun_info)) : is_add_cyclic (random_gen fun_info) := sorry --non-trivial
lemma new_lemma_43643 (h0 : functor.add_const (topological_space (comm_group ennreal)) Type) : @normal_space.{0} (comm_group.{0} ennreal) (@functor.add_const.run.{0 1} (topological_space.{0} (comm_group.{0} ennreal)) Type h0)  := sorry --non-trivial
lemma new_lemma_43644 (h0 : add_group (semiring (has_top fun_info))) : is_add_cyclic (semiring (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_43645 (h0 : functor.add_const (list (has_pos_part Type)) Type) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_43646 (h0 : functor.add_const (filter (semigroup Type)) (has_add (has_add (has_add name)))) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_43647 (h0 : ring (add_left_cancel_monoid (has_inv (has_nnnorm (with_zero linarith.ineq))))) : rank_condition (add_left_cancel_monoid (has_inv (has_nnnorm (with_zero linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_43648 (h0 : topological_space (complete_semilattice_Sup (semiring unsigned))) : totally_disconnected_space (complete_semilattice_Sup (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_43649 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @locally_compact_space.{0} (linear_ordered_semiring.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (linear_ordered_semiring.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_43650 (h0 : topological_space (has_le to_additive.value_type)) : totally_disconnected_space (has_le to_additive.value_type) := sorry --non-trivial
lemma new_lemma_43651 (h0 : group (has_sub char)) : group.fg (has_sub char) := sorry --non-trivial
lemma new_lemma_43652 (h0 : not (add_group (with_one (random_gen linarith.ineq)) -> false)) : @is_add_cyclic.{0} (with_one.{0} (random_gen.{0} linarith.ineq)) (@classical.by_contradiction'.{1} (add_group.{0} (with_one.{0} (random_gen.{0} linarith.ineq))) h0)  := sorry --non-trivial
lemma new_lemma_43653 (h0 : has_mem.mem (linear_ordered_semiring linarith.comp_source) has_emptyc.emptyc) : @irreducible_space.{0} (linear_ordered_semiring.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (linear_ordered_semiring.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_43654 (h0 : topological_space (ordered_comm_monoid (has_pos_part (has_add (has_add pos))))) : locally_compact_space (ordered_comm_monoid (has_pos_part (has_add (has_add pos)))) := sorry --non-trivial
lemma new_lemma_43655 (h0 : filter (add_semigroup num)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_43656 (h0 : topological_space (add_cancel_monoid (option empty))) : discrete_topology (add_cancel_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_43657 (h0 : function.extfun (Type 1) ring) : @rank_condition.{1} (mul_zero_class.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (mul_zero_class.{1} Type))  := sorry --non-trivial
lemma new_lemma_43658 (h0 : topological_space (add_cancel_comm_monoid linarith.comp_source)) (h1 : has_sub (add_cancel_comm_monoid linarith.comp_source)) : has_continuous_sub (add_cancel_comm_monoid linarith.comp_source) := sorry --non-trivial
lemma new_lemma_43659 (h0 : group (has_zero (has_neg pos))) : is_cyclic (has_zero (has_neg pos)) := sorry --non-trivial
lemma new_lemma_43660 (h0 : filter (semiring (semiring empty))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_43661 (h0 : functor.add_const (cancel_comm_monoid_with_zero (canonically_ordered_monoid pos)) real) : @unique_factorization_monoid.{0} (canonically_ordered_monoid.{0} pos) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (canonically_ordered_monoid.{0} pos)) real h0)  := sorry --non-trivial
lemma new_lemma_43662 (h0 : functor.comp topological_space has_neg (has_add pos)) : @t1_space.{0} (has_neg.{0} (has_add.{0} pos)) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_43663 (h1 : topological_space (has_nnnorm (has_top (has_nnnorm string_imp)))) : locally_compact_space (has_nnnorm (has_top (has_nnnorm string_imp))) := sorry --non-trivial
lemma new_lemma_43664 (h0 : topological_space (ordered_comm_ring (has_nndist (finset linarith.comp)))) : discrete_topology (ordered_comm_ring (has_nndist (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_43665 (h0 : functor.add_const (topological_space (comm_group unsigned)) Type) : @regular_space.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (comm_group.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_43666 (h0 : set (mul_one_class enat)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_43667 (h0 : topological_space (random_gen (has_top (semiring unsigned)))) : irreducible_space (random_gen (has_top (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_43668 (h0 : not (ring (distrib (has_nnnorm linarith.comp_source)) -> false)) : @strong_rank_condition.{0} (distrib.{0} (has_nnnorm.{0} linarith.comp_source)) (@classical.by_contradiction'.{1} (ring.{0} (distrib.{0} (has_nnnorm.{0} linarith.comp_source))) h0)  := sorry --non-trivial
lemma new_lemma_43669 (h0 : topological_space (normed_comm_ring (has_add pos))) : loc_path_connected_space (normed_comm_ring (has_add pos)) := sorry --non-trivial
lemma new_lemma_43670 (h0 : functor.add_const (function.extfun Type ring) pos) : @is_domain.{0} (has_Inf.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) pos h0) (has_Inf.{0} name))  := sorry --non-trivial
lemma new_lemma_43671 (h0 : functor.add_const Prop (normed_comm_ring (finset Type))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_43672 (h0 : complete_lattice (has_ssubset (has_nnnorm fun_info))) : is_compactly_generated (has_ssubset (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_43673 (h0 : group (option (semiring empty))) : normalizer_condition (option (semiring empty)) := sorry --non-trivial
lemma new_lemma_43674 (h0 : topological_space (distrib_lattice (random_gen string_imp))) : totally_separated_space (distrib_lattice (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_43675 (h0 : topological_space (has_zero (has_add Type))) : preirreducible_space (has_zero (has_add Type)) := sorry --non-trivial
lemma new_lemma_43676 (h0 : has_mem.mem complete_lattice has_emptyc.emptyc) : @is_compactly_generated.{0} unsigned (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} h0) unsigned)  := sorry --non-trivial
lemma new_lemma_43677 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (measure_theory.measure_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (measure_theory.measure_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_43678 (h0 : topological_space (sub_neg_monoid (ordered_comm_monoid real))) : locally_compact_space (sub_neg_monoid (ordered_comm_monoid real)) := sorry --non-trivial
lemma new_lemma_43679 (h0 : not (topological_space (random_gen to_additive.value_type) -> false)) : @t0_space.{0} (random_gen.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (random_gen.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_43680 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (@id.{2} Type empty) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (@id.{2} Type empty))  := sorry --non-trivial
lemma new_lemma_43681 (h2 : set (has_lt linarith.comp_source)) : set.finite h2 := sorry --non-trivial
lemma new_lemma_43682 (h0 : functor.add_const (functor.add_const (topological_space Type) linarith.comp) (has_Inf pos)) : @totally_disconnected_space.{1} Type (@functor.add_const.run.{1 0} (topological_space.{1} Type) linarith.comp (@functor.add_const.run.{1 0} (functor.add_const.{1 0} (topological_space.{1} Type) linarith.comp) (has_Inf.{0} pos) h0))  := sorry --non-trivial
lemma new_lemma_43683 (h0 : filter (linear_ordered_semiring linarith.comp)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_43684 (h1 : ring (comm_ring linarith.ineq)) : is_domain (comm_ring linarith.ineq) := sorry --non-trivial
lemma new_lemma_43685 (h0 : functor.add_const (function.extfun (Type 1) ordered_comm_monoid) pos) : @has_exists_mul_of_le.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_comm_monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ordered_comm_monoid.{1}) pos h0) (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_43686 (h0 : functor.add_const (ring (add_right_cancel_monoid num)) congr_arg_kind) : @is_principal_ideal_ring.{0} (add_right_cancel_monoid.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (add_right_cancel_monoid.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_43687 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_43688 (h0 : add_group (linear_ordered_semiring (has_norm (has_norm fun_info)))) : is_add_cyclic (linear_ordered_semiring (has_norm (has_norm fun_info))) := sorry --non-trivial
lemma new_lemma_43689 (h0 : ring (boolean_algebra.core char)) : is_principal_ideal_ring (boolean_algebra.core char) := sorry --non-trivial
lemma new_lemma_43690 (h0 : ring (has_union (with_bot num))) : is_domain (has_union (with_bot num)) := sorry --non-trivial
lemma new_lemma_43691 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (canonically_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_43692 (h0 : add_group (has_compl (has_nnnorm fun_info))) : is_add_cyclic (has_compl (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_43693 (h0 : group (normed_lattice_add_comm_group (has_pos_part name))) : group.fg (normed_lattice_add_comm_group (has_pos_part name)) := sorry --non-trivial
lemma new_lemma_43694 (h0 : complete_lattice (div_inv_monoid char)) : complete_lattice.is_Sup_finite_compact (div_inv_monoid char) := sorry --non-trivial
lemma new_lemma_43695 (h0 : fin has_zero.zero) : id (matrix.vec_empty h0) := sorry --non-trivial
lemma new_lemma_43696 (h0 : uniform_space (partial_order (semiring empty))) : complete_space (partial_order (semiring empty)) := sorry --non-trivial
lemma new_lemma_43697 (h0 : set (normed_field string.iterator_imp)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_43698 (h0 : topological_space (canonically_linear_ordered_monoid pos)) : irreducible_space (canonically_linear_ordered_monoid pos) := sorry --non-trivial
lemma new_lemma_43699 (h0 : filter (has_zero (finset (finset linarith.comp)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_43700 (h0 : topological_space (boolean_algebra (has_to_string (has_to_string unsigned)))) : t0_space (boolean_algebra (has_to_string (has_to_string unsigned))) := sorry --non-trivial
lemma new_lemma_43701 (h0 : topological_space (complete_semilattice_Sup (random_gen to_additive.value_type))) : irreducible_space (complete_semilattice_Sup (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_43702 (h0 : not (function.extfun Type topological_space -> false)) : @topological_space.separable_space.{0} (left_cancel_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (left_cancel_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_43703 (h0 : topological_space (has_neg (has_add pos))) : preirreducible_space (has_neg (has_add pos)) := sorry --non-trivial
lemma new_lemma_43704 (h0 : not (group (complete_linear_order unsigned) -> false)) : @group.fg.{0} (complete_linear_order.{0} unsigned) (@classical.by_contradiction'.{1} (group.{0} (complete_linear_order.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_43705 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_inv.{0} string_imp) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_inv.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_43706 (h0 : semiring empty -> semiring empty -> semiring empty) : is_right_cancel (semiring empty) h0 := sorry --non-trivial
lemma new_lemma_43707 (h0 : topological_space (ordered_comm_ring (has_pos_part pos))) : irreducible_space (ordered_comm_ring (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_43708 (h0 : topological_space (normed_comm_ring empty)) : preirreducible_space (normed_comm_ring empty) := sorry --non-trivial
lemma new_lemma_43709 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_43710 (h0 : functor.add_const (function.extfun Type finset) name) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (boolean_algebra linarith.comp)) := sorry --non-trivial
lemma new_lemma_43711 (h0 : fin has_zero.zero) : @irreducible_space.{1} (boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (boolean_algebra.{1} Type)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_43712 (h0 : add_group (normed_field (has_nnnorm reducibility_hints))) : is_add_cyclic (normed_field (has_nnnorm reducibility_hints)) := sorry --non-trivial
lemma new_lemma_43713 (h1 : has_coe (option char) Prop) (h2 : option char) : @coe_b.{1 1} (option.{0} char) Prop h1 h2  := sorry --non-trivial
lemma new_lemma_43714 (h0 : list (cancel_monoid (option (option (option unsigned))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_43715 (h0 : topological_space (with_one (has_norm (semiring num)))) : t0_space (with_one (has_norm (semiring num))) := sorry --non-trivial
lemma new_lemma_43716 (h0 : topological_space (complete_semilattice_Sup (has_ssubset (dlist fun_info)))) : t0_space (complete_semilattice_Sup (has_ssubset (dlist fun_info))) := sorry --non-trivial
lemma new_lemma_43717 (h0 : fin has_zero.zero) : @unique_factorization_monoid.{1} (has_pos_part.{1} Type) (@matrix.vec_empty.{1} (cancel_comm_monoid_with_zero.{1} (has_pos_part.{1} Type)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_43718 (h0 : list (topological_space (has_nndist num))) : @irreducible_space.{0} (has_nndist.{0} num) (@list.head.{0} (topological_space.{0} (has_nndist.{0} num)) (@inhabited_topological_space.{0} (has_nndist.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_43719 (h0 : empty -> semigroup empty -> Prop) : relator.bi_total h0 := sorry --non-trivial
lemma new_lemma_43720 (h0 : functor.add_const (topological_space (add_cancel_monoid linarith.comp)) (finset linarith.comp)) : @discrete_topology.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} linarith.comp)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_43721 (h0 : functor.add_const (group (semigroup Type)) name) : @normalizer_condition.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (semigroup.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_43722 (h0 : topological_space (preorder congr_arg_kind)) : topological_space.separable_space (preorder congr_arg_kind) := sorry --non-trivial
lemma new_lemma_43723 (h0 : add_group (measurable_space (random_gen (random_gen (random_gen to_additive.value_type))))) : is_add_cyclic (measurable_space (random_gen (random_gen (random_gen to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_43724 (h0 : functor.add_const (function.extfun Type complete_lattice) Type) : @is_compactly_generated.{0} (semigroup.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type complete_lattice.{0}) Type h0) (semigroup.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_43725 (h0 : functor.add_const (topological_space (has_nndist Type)) Type) : @t1_space.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_nndist.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_43726 (h0 : topological_space (has_Inf (has_to_string (has_add linarith.comp)))) : t1_space (has_Inf (has_to_string (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_43727 (h0 : complete_lattice (linear_ordered_comm_ring (has_top empty))) : is_compactly_generated (linear_ordered_comm_ring (has_top empty)) := sorry --non-trivial
lemma new_lemma_43728 (h0 : group (add_cancel_monoid (with_zero ennreal))) : group.fg (add_cancel_monoid (with_zero ennreal)) := sorry --non-trivial
lemma new_lemma_43729 (h0 : functor.add_const (complete_lattice (comm_semigroup num)) (option empty)) : @is_atomistic.{0} (comm_semigroup.{0} num) (@functor.add_const.run.{0 0} (complete_lattice.{0} (comm_semigroup.{0} num)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_43730 (h0 : topological_space (measurable_space (random_gen (random_gen num)))) : discrete_topology (measurable_space (random_gen (random_gen num))) := sorry --non-trivial
lemma new_lemma_43731 (h0 : topological_space (has_scalar unsigned (semiring (semiring linarith.comp)))) : irreducible_space (has_scalar unsigned (semiring (semiring linarith.comp))) := sorry --non-trivial
lemma new_lemma_43732 (h0 : list (comm_group unsigned)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_43733 (h0 : ring (ordered_ring (option (option (option unsigned))))) : rank_condition (ordered_ring (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_43734 (h0 : functor.add_const (ring (add_comm_monoid Type)) environment.implicit_infer_kind) : @strong_rank_condition.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (add_comm_monoid.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_43735 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_atomistic.{0} (has_one.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (has_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_43736 (h2 : measurable_space (nondiscrete_normed_field linarith.ineq)) (h3 : measure_theory.measure (nondiscrete_normed_field linarith.ineq)) : measure_theory.is_finite_measure h3 := sorry --non-trivial
lemma new_lemma_43737 (h1 : uniform_space (with_bot linarith.ineq)) : complete_space (with_bot linarith.ineq) := sorry --non-trivial
lemma new_lemma_43738 (h0 : topological_space (has_pos_part (ring (has_neg linarith.comp)))) : t0_space (has_pos_part (ring (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_43739 (h0 : topological_space (semigroup (option (option pos)))) : preirreducible_space (semigroup (option (option pos))) := sorry --non-trivial
lemma new_lemma_43740 (h0 : functor.add_const (topological_space (has_to_string linarith.comp)) pos) : @t0_space.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_43741 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @regular_space.{0} (has_zero.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_zero.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_43742 (h0 : ring (linear_ordered_comm_group congr_arg_kind)) : rank_condition (linear_ordered_comm_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_43743 (h0 : complete_lattice (normed_field (has_nnnorm fun_info))) : complete_lattice.is_Sup_finite_compact (normed_field (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_43744 (h0 : fin has_zero.zero) : @path_connected_space.{1} (has_pos_part.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (has_pos_part.{1} Type)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_43745 (h0 : topological_space (canonically_linear_ordered_monoid real)) : discrete_topology (canonically_linear_ordered_monoid real) := sorry --non-trivial
lemma new_lemma_43746 (h0 : complete_lattice (canonically_linear_ordered_monoid unsigned)) : is_compactly_generated (canonically_linear_ordered_monoid unsigned) := sorry --non-trivial
lemma new_lemma_43747 (h0 : group (comm_group linarith.comp)) : normalizer_condition (comm_group linarith.comp) := sorry --non-trivial
lemma new_lemma_43748 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_compactly_generated.{0} (has_star.{0} (semiring.{0} (semiring.{0} (semiring.{0} num)))) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (has_star.{0} (semiring.{0} (semiring.{0} (semiring.{0} num)))))  := sorry --non-trivial
lemma new_lemma_43749 (h0 : topological_space (preorder (semiring (semiring (semiring (semiring (semiring num))))))) : preirreducible_space (preorder (semiring (semiring (semiring (semiring (semiring num)))))) := sorry --non-trivial
lemma new_lemma_43750 (h0 : add_monoid (has_star (option empty))) : add_monoid.fg (has_star (option empty)) := sorry --non-trivial
lemma new_lemma_43751 (h0 : semiring (add_group (with_bot unsigned))) : is_noetherian_ring (add_group (with_bot unsigned)) := sorry --non-trivial
lemma new_lemma_43752 (h0 : topological_space (boolean_algebra (sub_neg_monoid (has_pos_part Type)))) : totally_disconnected_space (boolean_algebra (sub_neg_monoid (has_pos_part Type))) := sorry --non-trivial
lemma new_lemma_43753 (h0 : filter (as_linear_order congr_arg_kind)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_43754 (h0 : topological_space (comm_ring (random_gen linarith.ineq))) : irreducible_space (comm_ring (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_43755 (h0 : add_monoid (omega_complete_partial_order (add_cancel_comm_monoid congr_arg_kind))) : add_monoid.fg (omega_complete_partial_order (add_cancel_comm_monoid congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_43756 (h0 : functor.add_const (function.extfun Type monoid) linarith.comp) : @monoid.fg.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type monoid.{0}) linarith.comp h0) (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_43757 (h0 : fin has_zero.zero) : @discrete_topology.{0} (sub_neg_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (sub_neg_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_43758 (h0 : functor.add_const (function.extfun (Type 1) cancel_comm_monoid_with_zero) linarith.comp) : @unique_factorization_monoid.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1}) linarith.comp h0) (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_43759 (h0 : group (has_zero congr_arg_kind)) : group.fg (has_zero congr_arg_kind) := sorry --non-trivial
lemma new_lemma_43760 (h0 : functor.add_const (add_monoid (generalized_boolean_algebra Type)) (ring linarith.comp)) : @add_monoid.fg.{1} (generalized_boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (add_monoid.{1} (generalized_boolean_algebra.{1} Type)) (ring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_43761 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (has_inter num)) := sorry --non-trivial
lemma new_lemma_43762 (h0 : complete_lattice (boolean_algebra Type)) : complete_lattice.is_Sup_finite_compact (boolean_algebra Type) := sorry --non-trivial
lemma new_lemma_43763 (h1 : add_group (semiring (random_gen (random_gen (random_gen linarith.ineq))))) : is_add_cyclic (semiring (random_gen (random_gen (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_43764 (h0 : functor.add_const (finset (comm_group linarith.comp)) name) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_43765 (h0 : ring (normed_comm_ring (finset environment.implicit_infer_kind))) : strong_rank_condition (normed_comm_ring (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_43766 (h0 : complete_lattice (has_to_string (boolean_algebra.core name))) : is_atomistic (has_to_string (boolean_algebra.core name)) := sorry --non-trivial
lemma new_lemma_43767 (h0 : topological_space (plift (option (option (option (option unsigned)))))) : discrete_topology (plift (option (option (option (option unsigned))))) := sorry --non-trivial
lemma new_lemma_43768 (h0 : functor.add_const Prop (linear_ordered_semiring (semiring (has_norm (with_bot (semiring linarith.comp)))))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_43769 (h0 : topological_space (with_bot (semiring num))) : totally_disconnected_space (with_bot (semiring num)) := sorry --non-trivial
lemma new_lemma_43770 (h3 : add_group (random_gen char)) : is_add_cyclic (random_gen char) := sorry --non-trivial
lemma new_lemma_43771 (h0 : fin has_zero.zero) : @complete_space.{0} (ordered_comm_ring.{0} real) (@matrix.vec_empty.{0} (uniform_space.{0} (ordered_comm_ring.{0} real)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)))  := sorry --non-trivial
lemma new_lemma_43772 (h0 : complete_lattice (complete_semilattice_Sup (random_gen fun_info))) : is_compactly_generated (complete_semilattice_Sup (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_43773 (h0 : semiring (boolean_algebra (has_Inf (generalized_boolean_algebra (ring pos))))) : is_noetherian_ring (boolean_algebra (has_Inf (generalized_boolean_algebra (ring pos)))) := sorry --non-trivial
lemma new_lemma_43774 (h0 : list (add_comm_monoid (option ennreal))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_43775 (h0 : topological_space (add_comm_monoid (has_add environment.implicit_infer_kind))) : totally_disconnected_space (add_comm_monoid (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_43776 (h0 : ordered_comm_monoid (boolean_algebra (comm_group (comm_group unsigned)))) : has_exists_mul_of_le (boolean_algebra (comm_group (comm_group unsigned))) := sorry --non-trivial
lemma new_lemma_43777 (h0 : fintype char) (h1 : not (sym2 (fintype char) -> false)) : sym2.mem h0 (classical.by_contradiction' h1) := sorry --non-trivial
lemma new_lemma_43778 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @regular_space.{1} (mul_zero_class.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (mul_zero_class.{1} Type))  := sorry --non-trivial
lemma new_lemma_43779 (h0 : functor.comp topological_space option pos) : @totally_separated_space.{0} (option.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} option.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_43780 (h0 : function.extfun (Type 1) complete_lattice) : @is_compactly_generated.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} h0 (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_43781 (h0 : topological_space (cancel_monoid (boolean_algebra.core (has_add name)))) : preirreducible_space (cancel_monoid (boolean_algebra.core (has_add name))) := sorry --non-trivial
lemma new_lemma_43782 (h0 : topological_space unsigned) (h1 : function.extfun Type preorder) : @order_topology.{0} unsigned h0 (@function.extfun_app.{2 1} Type preorder.{0} h1 unsigned)  := sorry --non-trivial
lemma new_lemma_43783 (h0 : functor.add_const (topological_space (ordered_ring num)) unsigned) : @t1_space.{0} (ordered_ring.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_43784 (h0 : has_add (option (option (option pos))) -> has_add (option (option (option pos))) -> Prop) : is_symm (has_add (option (option (option pos)))) h0 := sorry --non-trivial
lemma new_lemma_43785 (h0 : functor.add_const (topological_space (add_comm_monoid name)) (has_to_string (has_neg Type))) : @preconnected_space.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (add_comm_monoid.{0} name)) (has_to_string.{1} (has_neg.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_43786 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (canonically_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type monoid.{0} h0 (canonically_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_43787 (h0 : functor.add_const (ring (add_left_cancel_semigroup congr_arg_kind)) empty) : @is_domain.{0} (add_left_cancel_semigroup.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ring.{0} (add_left_cancel_semigroup.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_43788 (h0 : topological_space (dlist (random_gen to_additive.value_type))) : t0_space (dlist (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_43789 (h0 : topological_space (mul_one_class to_additive.value_type)) (h1 : preorder (mul_one_class to_additive.value_type)) : order_topology (mul_one_class to_additive.value_type) := sorry --non-trivial
lemma new_lemma_43790 (h0 : set (semi_normed_comm_ring enat)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_43791 (h0 : filter (complete_distrib_lattice name)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_43792 (h0 : prod (left_cancel_monoid empty) (left_cancel_monoid empty)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_43793 (h0 : functor.add_const (group (cancel_monoid unsigned)) unsigned) : @group.fg.{0} (cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (cancel_monoid.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_43794 (h0 : topological_space (ordered_comm_monoid (has_add linarith.comp))) : irreducible_space (ordered_comm_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_43795 (h0 : complete_lattice (has_Inf to_additive.value_type)) : is_compactly_generated (has_Inf to_additive.value_type) := sorry --non-trivial
lemma new_lemma_43796 (h0 : complete_lattice (has_add (has_bot linarith.comp))) : complete_lattice.is_Sup_finite_compact (has_add (has_bot linarith.comp)) := sorry --non-trivial
lemma new_lemma_43797 (h1 : has_emptyc (random_gen to_additive.value_type) -> Prop) : @infi.{0 1} Prop (@conditionally_complete_lattice.to_has_Inf.{0} Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice)) (has_emptyc.{0} (random_gen.{0} to_additive.value_type)) h1  := sorry --non-trivial
lemma new_lemma_43798 (h0 : not (function.extfun (Type 1 -> Type 1) (function.extfun (Type 1)) -> false)) : @normal_space.{1} (plift.{1} unsigned) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) (@classical.by_contradiction'.{3} (function.extfun.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1))) h0) topological_space.{1}) (plift.{1} unsigned))  := sorry --non-trivial
lemma new_lemma_43799 (h0 : functor.add_const (topological_space (boolean_algebra name)) Type) : @t1_space.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_43800 (h0 : functor.add_const (group (semigroup Type)) (finset linarith.comp)) : @normalizer_condition.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (semigroup.{1} Type)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_43801 (h0 : function.extfun (((Type -> Type) -> Type 1) -> Type 1) (function.extfun ((Type -> Type) -> Type 1))) : @rank_condition.{0} (complete_semilattice_Sup.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} linarith.ineq)))) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) (@function.extfun_app.{3 3} (((Type → Type) → Type 1) → Type 1) (function.extfun.{3 2} ((Type → Type) → Type 1)) h0 (function.extfun.{2 2} (Type → Type))) (function.extfun.{2 1} Type)) ring.{0}) (complete_semilattice_Sup.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} linarith.ineq)))))  := sorry --non-trivial
lemma new_lemma_43802 (h1 : list Prop) : list.tfae h1 := sorry --non-trivial
lemma new_lemma_43803 (h0 : uniform_space (complete_distrib_lattice (ring pos))) : separated_space (complete_distrib_lattice (ring pos)) := sorry --non-trivial
lemma new_lemma_43804 (h0 : has_mem.mem (has_norm empty) has_emptyc.emptyc) : @is_add_cyclic.{0} (has_norm.{0} empty) (@finset.pi.empty.{1 0} Type add_group.{0} (has_norm.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_43805 (h2 : ring (encodable linarith.ineq)) : rank_condition (encodable linarith.ineq) := sorry --non-trivial
lemma new_lemma_43806 (h2 : not (topological_space (add_monoid to_additive.value_type) -> false)) : @path_connected_space.{0} (add_monoid.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (add_monoid.{0} to_additive.value_type)) h2)  := sorry --non-trivial
lemma new_lemma_43807 (h0 : topological_space (group_with_zero (option (option unsigned)))) : totally_disconnected_space (group_with_zero (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_43808 (h0 : ring (linear_ordered_add_comm_group (has_nnnorm char))) : strong_rank_condition (linear_ordered_add_comm_group (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_43809 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (normed_lattice_add_comm_group.{0} real) (@function.extfun_app.{2 1} Type ring.{0} h0 (normed_lattice_add_comm_group.{0} real))  := sorry --non-trivial
lemma new_lemma_43810 (h0 : function.extfun Type ring) : @rank_condition.{0} (normed_linear_ordered_group.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (normed_linear_ordered_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_43811 (h0 : functor.add_const (filter (normed_comm_ring unsigned)) pos) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_43812 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (complete_distrib_lattice.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (complete_distrib_lattice.{0} num))  := sorry --non-trivial
lemma new_lemma_43813 (h0 : group (boolean_algebra.core (comm_group name))) : is_simple_group (boolean_algebra.core (comm_group name)) := sorry --non-trivial
lemma new_lemma_43814 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (semigroup.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} num))  := sorry --non-trivial
lemma new_lemma_43815 (h0 : topological_space (comm_ring (fintype string_imp))) : t0_space (comm_ring (fintype string_imp)) := sorry --non-trivial
lemma new_lemma_43816 (h0 : group (add_cancel_monoid (has_neg environment.implicit_infer_kind))) : is_simple_group (add_cancel_monoid (has_neg environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_43817 (h0 : monoid (normed_group (has_top fun_info))) : monoid.fg (normed_group (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_43818 (h1 : not (topological_space (linear_ordered_add_comm_group char) -> false)) : @totally_disconnected_space.{0} (linear_ordered_add_comm_group.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_add_comm_group.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_43819 (h0 : topological_space (boolean_algebra.core (has_add (has_add (has_add Type))))) : preconnected_space (boolean_algebra.core (has_add (has_add (has_add Type)))) := sorry --non-trivial
lemma new_lemma_43820 (h0 : ring (has_union empty)) (h1 : complete_lattice (subring (has_union empty))) : is_atomistic (subring (has_union empty)) := sorry --non-trivial
lemma new_lemma_43821 (h0 : uniform_space (comm_ring string_imp)) : complete_space (comm_ring string_imp) := sorry --non-trivial
lemma new_lemma_43822 (h0 : topological_space (has_to_string (boolean_algebra name))) : preconnected_space (has_to_string (boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_43823 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_43824 (h0 : complete_lattice (linear_ordered_comm_ring (has_inv (has_inv fun_info)))) : is_compactly_generated (linear_ordered_comm_ring (has_inv (has_inv fun_info))) := sorry --non-trivial
lemma new_lemma_43825 (h0 : functor.add_const (add_group (comm_group name)) pos) : @is_add_cyclic.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (add_group.{0} (comm_group.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_43826 (h0 : add_monoid (free_add_monoid (semiring (semiring (semiring unsigned))))) : add_monoid.fg (free_add_monoid (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_43827 (h0 : has_mem.mem uniform_space has_emptyc.emptyc) : @complete_space.{0} (has_top.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) uniform_space.{0} h0) (has_top.{0} num))  := sorry --non-trivial
lemma new_lemma_43828 (h0 : has_mem.mem monoid has_emptyc.emptyc) : @monoid.fg.{0} (with_bot.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type monoid.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) monoid.{0} h0) (with_bot.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_43829 (h0 : functor.add_const (ring (has_neg_part unsigned)) name) : @is_domain.{0} (has_neg_part.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (has_neg_part.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_43830 (h0 : group (with_bot (denumerable linarith.ineq))) : is_cyclic (with_bot (denumerable linarith.ineq)) := sorry --non-trivial
lemma new_lemma_43831 (h0 : ordered_add_comm_monoid (normed_linear_ordered_group (option unsigned))) : archimedean (normed_linear_ordered_group (option unsigned)) := sorry --non-trivial
lemma new_lemma_43832 (h0 : function.extfun Type group) : @group.fg.{0} (measurable_space.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (measurable_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_43833 (h0 : functor.add_const (topological_space (has_neg_part Type)) Type) : @discrete_topology.{1} (has_neg_part.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_neg_part.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_43834 (h2 : topological_space (has_compl (has_ssubset (random_gen char)))) : t0_space (has_compl (has_ssubset (random_gen char))) := sorry --non-trivial
lemma new_lemma_43835 (h0 : complete_lattice (normed_lattice_add_comm_group (has_add Type))) : is_atomistic (normed_lattice_add_comm_group (has_add Type)) := sorry --non-trivial
lemma new_lemma_43836 (h0 : topological_space (ordered_comm_monoid (ring Type))) : preirreducible_space (ordered_comm_monoid (ring Type)) := sorry --non-trivial
lemma new_lemma_43837 (h1 : function.extfun Type topological_space) : @irreducible_space.{0} (with_bot.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (with_bot.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_43838 (h0 : ring (linear_ordered_comm_group num)) : is_domain (linear_ordered_comm_group num) := sorry --non-trivial
lemma new_lemma_43839 (h0 : topological_space occurrences) : totally_disconnected_space occurrences := sorry --non-trivial
lemma new_lemma_43840 (h0 : filter (random_gen (filter to_additive.value_type))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_43841 (h0 : topological_space (has_nnnorm (mul_one_class enat))) : path_connected_space (has_nnnorm (mul_one_class enat)) := sorry --non-trivial
lemma new_lemma_43842 (h0 : functor.add_const (ring (semigroup Type)) environment.implicit_infer_kind) : @strong_rank_condition.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (semigroup.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_43843 (h0 : complete_lattice (pseudo_metric_space ennreal)) : is_atomistic (pseudo_metric_space ennreal) := sorry --non-trivial
lemma new_lemma_43844 (h0 : functor.add_const (group (complete_distrib_lattice pos)) linarith.comp) : @is_simple_group.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (complete_distrib_lattice.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_43845 (h0 : functor.add_const (function.extfun Type group) Type) : @normalizer_condition.{0} (has_zero.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type group.{0}) Type h0) (has_zero.{0} name))  := sorry --non-trivial
lemma new_lemma_43846 (h0 : ring (add_comm_semigroup (mul_one_class ereal))) : strong_rank_condition (add_comm_semigroup (mul_one_class ereal)) := sorry --non-trivial
lemma new_lemma_43847 (h0 : add_monoid (canonically_ordered_monoid (has_add name))) : add_monoid.fg (canonically_ordered_monoid (has_add name)) := sorry --non-trivial
lemma new_lemma_43848 (h0 : has_mem.mem (linear_ordered_semiring num) has_emptyc.emptyc) : @totally_separated_space.{0} (linear_ordered_semiring.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (linear_ordered_semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_43849 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (with_bot.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (with_bot.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_43850 (h0 : topological_space (add_comm_semigroup char)) : topological_space.first_countable_topology (add_comm_semigroup char) := sorry --non-trivial
lemma new_lemma_43851 (h0 : function.extfun Type topological_space) : @t1_space.{0} (option.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (option.{0} empty))  := sorry --non-trivial
lemma new_lemma_43852 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_one.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_one.{0} num))  := sorry --non-trivial
lemma new_lemma_43853 (h0 : finset (normed_comm_ring (has_to_string (finset linarith.comp)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_43854 (h0 : filter (has_top (uniform_space.core (random_gen linarith.ineq)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_43855 (h0 : topological_space (boolean_algebra (has_Inf (semigroup linarith.comp)))) : totally_separated_space (boolean_algebra (has_Inf (semigroup linarith.comp))) := sorry --non-trivial
lemma new_lemma_43856 (h0 : ring (boolean_algebra (mul_one_class linarith.comp))) : rank_condition (boolean_algebra (mul_one_class linarith.comp)) := sorry --non-trivial
lemma new_lemma_43857 (h0 : functor.add_const (function.extfun Type cancel_comm_monoid_with_zero) name) : @unique_factorization_monoid.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type cancel_comm_monoid_with_zero.{0}) name h0) (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_43858 (h0 : functor.add_const (ring (has_to_string unsigned)) Type) : @is_principal_ideal_ring.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 1} (ring.{0} (has_to_string.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_43859 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (boolean_algebra.core.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (boolean_algebra.core.{0} name))  := sorry --non-trivial
lemma new_lemma_43860 (h0 : topological_space (has_bot (has_neg (has_neg (has_neg name))))) : normal_space (has_bot (has_neg (has_neg (has_neg name)))) := sorry --non-trivial
lemma new_lemma_43861 (h0 : function.extfun Type group) : @normalizer_condition.{0} (free_add_monoid.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (free_add_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_43862 (h0 : fin has_zero.zero) : @add_monoid.fg.{0} (complete_distrib_lattice.{0} pos) (@matrix.vec_empty.{0} (add_monoid.{0} (complete_distrib_lattice.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_43863 (h0 : functor.add_const (topological_space (ordered_comm_group empty)) empty) : @totally_disconnected_space.{0} (ordered_comm_group.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_group.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_43864 (h0 : complete_lattice (has_norm (has_norm (has_norm to_additive.value_type)))) : is_compactly_generated (has_norm (has_norm (has_norm to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_43865 (h0 : topological_space (mul_zero_class (semiring unsigned))) : normal_space (mul_zero_class (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_43866 (h0 : topological_space (normed_comm_ring (has_nndist environment.implicit_infer_kind))) : totally_disconnected_space (normed_comm_ring (has_nndist environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_43867 (h0 : functor.add_const (add_monoid (has_add environment.implicit_infer_kind)) linarith.comp) : @add_monoid.fg.{0} (has_add.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_add.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_43868 (h0 : functor.add_const (group (add_comm_monoid linarith.comp)) Type) : @is_simple_group.{0} (add_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (group.{0} (add_comm_monoid.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_43869 (h0 : topological_space (has_emptyc string_imp)) : totally_separated_space (has_emptyc string_imp) := sorry --non-trivial
lemma new_lemma_43870 (h0 : not (group (ordered_comm_monoid char) -> false)) : @group.fg.{0} (ordered_comm_monoid.{0} char) (@classical.by_contradiction'.{1} (group.{0} (ordered_comm_monoid.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_43871 (h0 : fin has_zero.zero) : @irreducible_space.{0} (canonically_linear_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))) (canonically_linear_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_43872 (h1 : group (normed_field (non_unital_non_assoc_semiring reducibility_hints))) : is_cyclic (normed_field (non_unital_non_assoc_semiring reducibility_hints)) := sorry --non-trivial
lemma new_lemma_43873 (h0 : functor.add_const (topological_space (has_neg environment.implicit_infer_kind)) (has_neg Type)) : @irreducible_space.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg.{0} environment.implicit_infer_kind)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_43874 (h0 : complete_lattice (simple_graph string_imp)) : is_compactly_generated (simple_graph string_imp) := sorry --non-trivial
lemma new_lemma_43875 (h0 : functor.add_const (topological_space (boolean_algebra.core linarith.comp)) name) : @preirreducible_space.{0} (boolean_algebra.core.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_43876 (h0 : ring (has_add (has_Inf (ordered_ring (has_Inf (has_neg Type)))))) : is_principal_ideal_ring (has_add (has_Inf (ordered_ring (has_Inf (has_neg Type))))) := sorry --non-trivial
lemma new_lemma_43877 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (has_emptyc.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_emptyc.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_43878 (h0 : functor.add_const (group (add_cancel_monoid linarith.comp)) linarith.comp) : @is_cyclic.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (add_cancel_monoid.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_43879 (h0 : topological_space (finset (option unsigned))) : t1_space (finset (option unsigned)) := sorry --non-trivial
lemma new_lemma_43880 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (complete_distrib_lattice.{0} pos) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (complete_distrib_lattice.{0} pos))  := sorry --non-trivial
lemma new_lemma_43881 (h0 : set (has_div to_additive.value_type)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_43882 (h0 : cancel_comm_monoid_with_zero (option num)) : unique_factorization_monoid (option num) := sorry --non-trivial
lemma new_lemma_43883 (h0 : functor.add_const (group (add_cancel_monoid pos)) Type) : @normalizer_condition.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (add_cancel_monoid.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_43884 (h0 : group (with_bot (random_gen (random_gen linarith.ineq)))) : normalizer_condition (with_bot (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_43885 (h0 : prod (boolean_algebra.core unsigned) (boolean_algebra.core unsigned)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_43886 (h0 : fin has_zero.zero) : @is_atomistic.{0} (generalized_boolean_algebra.{0} real) (@matrix.vec_empty.{0} (complete_lattice.{0} (generalized_boolean_algebra.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_43887 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (has_emptyc.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type monoid.{0} h0 (has_emptyc.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_43888 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @archimedean.{0} (add_comm_monoid.{0} pos) (@matrix.vec_empty.{0} (ordered_add_comm_monoid.{0} (add_comm_monoid.{0} pos)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_43889 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (has_top.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_top.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_43890 (h0 : fin has_zero.zero) : @is_cyclic.{1} (canonically_linear_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (group.{1} (canonically_linear_ordered_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_43891 (h0 : group (add_comm_monoid real)) : is_cyclic (add_comm_monoid real) := sorry --non-trivial
lemma new_lemma_43892 (h0 : functor.add_const (uniform_space (ring linarith.comp)) environment.implicit_infer_kind) : @separated_space.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (ring.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_43893 (h1 : group (has_compl (has_ssubset (has_ssubset (has_ssubset linarith.comp_source))))) : is_cyclic (has_compl (has_ssubset (has_ssubset (has_ssubset linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_43894 (h0 : function.extfun Type topological_space) : irreducible_space ennreal := sorry --non-trivial
lemma new_lemma_43895 (h0 : topological_space (has_top fun_info)) : discrete_topology (has_top fun_info) := sorry --non-trivial
lemma new_lemma_43896 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (has_norm.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_norm.{0} empty))  := sorry --non-trivial
lemma new_lemma_43897 (h0 : semiring (with_one num)) : is_noetherian_ring (with_one num) := sorry --non-trivial
lemma new_lemma_43898 (h0 : not (ring (normed_field string_imp) -> false)) : @strong_rank_condition.{0} (normed_field.{0} string_imp) (@classical.by_contradiction'.{1} (ring.{0} (normed_field.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_43899 (h0 : group (finset num)) : is_simple_group (finset num) := sorry --non-trivial
lemma new_lemma_43900 (h0 : functor.add_const (topological_space (semigroup empty)) num) : @totally_separated_space.{0} (semigroup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_43901 (h0 h1 : not (multiset (semi_normed_comm_ring char) -> false)) : multiset.disjoint (classical.by_contradiction' h0) (classical.by_contradiction' h1) := sorry --non-trivial
lemma new_lemma_43902 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_to_string.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_43903 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (ordered_comm_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_43904 (h0 : cancel_comm_monoid_with_zero (has_neg (has_neg pos))) : unique_factorization_monoid (has_neg (has_neg pos)) := sorry --non-trivial
lemma new_lemma_43905 (h0 : complete_lattice (comm_semigroup real)) : is_atomistic (comm_semigroup real) := sorry --non-trivial
lemma new_lemma_43906 (h0 : topological_space (has_neg (has_add name))) : t1_space (has_neg (has_add name)) := sorry --non-trivial
lemma new_lemma_43907 (h0 : not (add_group (add_cancel_comm_monoid fun_info) -> false)) : @is_add_cyclic.{0} (add_cancel_comm_monoid.{0} fun_info) (@classical.by_contradiction'.{1} (add_group.{0} (add_cancel_comm_monoid.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_43908 (h0 : ring (normed_group (has_top to_additive.value_type))) : is_domain (normed_group (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_43909 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (semigroup empty)) := sorry --non-trivial
lemma new_lemma_43910 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (has_zero.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_43911 (h0 : functor.add_const (ring (add_comm_monoid Type)) environment.implicit_infer_kind) : @rank_condition.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (add_comm_monoid.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_43912 (h0 : ordered_comm_monoid (add_cancel_monoid (canonically_ordered_comm_semiring name))) : has_exists_mul_of_le (add_cancel_monoid (canonically_ordered_comm_semiring name)) := sorry --non-trivial
lemma new_lemma_43913 (h2 : uniform_space (normed_field reducibility_hints)) : complete_space (normed_field reducibility_hints) := sorry --non-trivial
lemma new_lemma_43914 (h0 : topological_space (has_inter ennreal)) : preconnected_space (has_inter ennreal) := sorry --non-trivial
lemma new_lemma_43915 (h0 : functor.add_const (topological_space (has_neg pos)) Type) : @totally_separated_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_43916 (h0 : functor.add_const (function.extfun (Type 1) group) linarith.comp) : @is_simple_group.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) group.{1}) linarith.comp h0) (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_43917 (h0 : function.extfun Type group) : @group.fg.{0} (linear_order.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (linear_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_43918 (h0 : not (filter (with_bot linarith.comp) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_43919 (h0 : ulower Prop) (h1 : list (ulower Prop)) : @ulower.up.{0} Prop encodable.Prop (@list.ilast'.{0} (@ulower.{0} Prop encodable.Prop) h0 h1)  := sorry --non-trivial
lemma new_lemma_43920 (h0 : prod (complete_distrib_lattice (option ennreal)) (complete_distrib_lattice (option ennreal))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_43921 (h0 : functor.add_const (group (canonically_linear_ordered_monoid name)) pos) : @group.fg.{0} (canonically_linear_ordered_monoid.{0} name) (@functor.add_const.run.{0 0} (group.{0} (canonically_linear_ordered_monoid.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_43922 (h1 : uniform_space (semi_normed_ring to_additive.value_type)) : complete_space (semi_normed_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_43923 (h0 : functor.add_const (topological_space (has_neg_part name)) (has_neg (has_neg linarith.comp))) : @locally_compact_space.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} name)) (has_neg.{0} (has_neg.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_43924 (h0 : functor.add_const (topological_space (pseudo_emetric_space name)) pos) : @topological_space.separable_space.{0} (pseudo_emetric_space.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (pseudo_emetric_space.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_43925 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_compactly_generated.{0} (has_norm.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (has_norm.{0} empty))  := sorry --non-trivial
lemma new_lemma_43926 (h0 : ring (non_assoc_semiring (option (option unsigned)))) : is_principal_ideal_ring (non_assoc_semiring (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_43927 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_Sup.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_Sup.{0} num))  := sorry --non-trivial
lemma new_lemma_43928 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (semiring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (semiring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_43929 (h0 : ring (has_emptyc (has_norm empty))) : is_domain (has_emptyc (has_norm empty)) := sorry --non-trivial
lemma new_lemma_43930 (h0 : has_mem.mem (semiring num) has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} (semiring.{0} num) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_43931 (h0 : not (topological_space (mul_one_class to_additive.value_type) -> false)) : @locally_compact_space.{0} (mul_one_class.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (mul_one_class.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_43932 (h1 : functor.comp complete_lattice has_compl string_imp) : @is_compactly_generated.{0} (has_compl.{0} string_imp) (@functor.comp.run.{0 0 0} complete_lattice.{0} has_compl.{0} string_imp h1)  := sorry --non-trivial
lemma new_lemma_43933 (h0 : topological_space (linear_ordered_comm_group (option empty))) : irreducible_space (linear_ordered_comm_group (option empty)) := sorry --non-trivial
lemma new_lemma_43934 (h0 : not (complete_lattice (has_norm (random_gen linarith.ineq)) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_norm.{0} (random_gen.{0} linarith.ineq)) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_norm.{0} (random_gen.{0} linarith.ineq))) h0)  := sorry --non-trivial
lemma new_lemma_43935 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (normed_lattice_add_comm_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_lattice_add_comm_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_43936 (h0 : add_group (has_neg_part (finset Type))) : is_add_cyclic (has_neg_part (finset Type)) := sorry --non-trivial
lemma new_lemma_43937 (h0 : group (normed_group (has_nnnorm char))) : is_cyclic (normed_group (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_43938 (h0 : topological_space real.angle) : irreducible_space real.angle := sorry --non-trivial
lemma new_lemma_43939 (h0 : filter (has_norm (id (with_bot (has_union linarith.comp))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_43940 (h0 : functor.add_const (function.extfun (Type 1) complete_lattice) (has_Inf linarith.comp)) : @complete_lattice.is_Sup_finite_compact.{1} Type (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) complete_lattice.{1}) (has_Inf.{0} linarith.comp) h0) Type)  := sorry --non-trivial
lemma new_lemma_43941 (h0 : semiring (normed_comm_ring enat)) (h1 : not (ideal (normed_comm_ring enat) -> false)) : ideal.fg (classical.by_contradiction' h1) := sorry --non-trivial
lemma new_lemma_43942 (h0 : function.extfun Type (functor.add_const (group (normed_group empty)))) : @is_cyclic.{0} (normed_group.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (normed_group.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (group.{0} (normed_group.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_43943 (h0 : topological_space (has_one linarith.comp)) : discrete_topology (has_one linarith.comp) := sorry --non-trivial
lemma new_lemma_43944 (h0 : topological_space (has_ssubset (has_ssubset fun_info))) : t0_space (has_ssubset (has_ssubset fun_info)) := sorry --non-trivial
lemma new_lemma_43945 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} empty (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) empty)  := sorry --non-trivial
lemma new_lemma_43946 (h0 : functor.add_const (semiring (boolean_algebra Type)) Type) : @is_noetherian_ring.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 1} (semiring.{1} (boolean_algebra.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_43947 (h0 : group (normed_lattice_add_comm_group (has_neg real))) : is_simple_group (normed_lattice_add_comm_group (has_neg real)) := sorry --non-trivial
lemma new_lemma_43948 (h0 : topological_space (normed_comm_ring (comm_group name))) : regular_space (normed_comm_ring (comm_group name)) := sorry --non-trivial
lemma new_lemma_43949 (h0 : complete_lattice (normed_comm_ring (has_neg Type))) : is_compactly_generated (normed_comm_ring (has_neg Type)) := sorry --non-trivial
lemma new_lemma_43950 (h0 : topological_space (has_Inf (ring Type))) : t0_space (has_Inf (ring Type)) := sorry --non-trivial
lemma new_lemma_43951 (h0 : functor.add_const (monoid (has_neg Type)) name) : @monoid.fg.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (monoid.{1} (has_neg.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_43952 (h0 : topological_space (add_cancel_monoid (has_to_string linarith.comp))) : path_connected_space (add_cancel_monoid (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_43953 (h0 : functor.add_const (function.extfun Type topological_space) name) : @discrete_topology.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_43954 (h0 : ring (linear_ordered_semiring (random_gen (random_gen num)))) : rank_condition (linear_ordered_semiring (random_gen (random_gen num))) := sorry --non-trivial
lemma new_lemma_43955 (h0 : not (has_mem.mem (has_norm num) has_emptyc.emptyc -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_norm.{0} num) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (has_norm.{0} num) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_norm.{0} num) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_43956 (h0 : functor.add_const (topological_space (semigroup linarith.comp)) (has_neg Type)) : @irreducible_space.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (semigroup.{0} linarith.comp)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_43957 (h0 : fin has_zero.zero) : @path_connected_space.{0} (complete_distrib_lattice.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (complete_distrib_lattice.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_43958 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (has_emptyc.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (has_emptyc.{0} empty))  := sorry --non-trivial
lemma new_lemma_43959 (h1 : topological_space (random_gen empty)) : normal_space (random_gen empty) := sorry --non-trivial
lemma new_lemma_43960 (h0 : functor.add_const (functor.add_const (topological_space pos) num) empty) : @irreducible_space.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) num (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (topological_space.{0} pos) num) empty h0))  := sorry --non-trivial
lemma new_lemma_43961 (h0 : char -> char -> char) (h1 : char) : right_identity h0 h1 := sorry --non-trivial
lemma new_lemma_43962 (h0 : complete_lattice (mul_one_class (mul_one_class (add_comm_semigroup ereal)))) : complete_lattice.is_Sup_finite_compact (mul_one_class (mul_one_class (add_comm_semigroup ereal))) := sorry --non-trivial
lemma new_lemma_43963 (h0 : filter (id unsigned)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_43964 (h0 : prod (normed_field linarith.ineq) (normed_field linarith.ineq)) : set.diagonal (normed_field linarith.ineq) h0 := sorry --non-trivial
lemma new_lemma_43965 (h1 : ring (random_gen linarith.comp_source)) : strong_rank_condition (random_gen linarith.comp_source) := sorry --non-trivial
lemma new_lemma_43966 (h0 : functor.add_const (topological_space (comm_group linarith.comp)) name) : @topological_space.separable_space.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_43967 (h0 : functor.add_const (uniform_space (ring Type)) (ring Type)) : @separated_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 1} (uniform_space.{1} (ring.{1} Type)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_43968 (h1 : has_mem.mem (with_one linarith.comp_source) has_emptyc.emptyc) : @complete_space.{0} (with_one.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type uniform_space.{0} (with_one.{0} linarith.comp_source) h1)  := sorry --non-trivial
lemma new_lemma_43969 (h0 : add_group (has_emptyc Type)) : is_add_cyclic (has_emptyc Type) := sorry --non-trivial
lemma new_lemma_43970 (h0 : functor.add_const (topological_space (finset pos)) linarith.comp) : @totally_separated_space.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_43971 (h0 : function.extfun Type (functor.comp ordered_add_comm_monoid semigroup)) : @archimedean.{0} (semigroup.{0} ennreal) (@functor.comp.run.{0 0 0} ordered_add_comm_monoid.{0} semigroup.{0} ennreal (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} ordered_add_comm_monoid.{0} semigroup.{0}) h0 ennreal))  := sorry --non-trivial
lemma new_lemma_43972 (h0 : functor.add_const (filter (has_to_string unsigned)) Type) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_43973 (h0 : topological_space (has_zero (boolean_algebra name))) : locally_compact_space (has_zero (boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_43974 (h0 : functor.add_const (function.extfun (Type 1) add_group) pos) : @is_add_cyclic.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) add_group.{1}) pos h0) (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_43975 (h0 : functor.add_const (topological_space (mul_zero_class environment.implicit_infer_kind)) Type) : @path_connected_space.{0} (mul_zero_class.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (mul_zero_class.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_43976 (h0 : topological_space (boolean_algebra.core environment.implicit_infer_kind)) : totally_separated_space (boolean_algebra.core environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_43977 (h0 : functor.comp group has_to_string linarith.comp) : @is_cyclic.{0} (has_to_string.{0} linarith.comp) (@functor.comp.run.{0 0 0} group.{0} has_to_string.{0} linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_43978 (h0 : topological_space (with_one (random_gen to_additive.value_type))) : path_connected_space (with_one (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_43979 (h0 : semiring (has_pos_part (has_bot real))) : is_noetherian_ring (has_pos_part (has_bot real)) := sorry --non-trivial
lemma new_lemma_43980 (h0 : fin has_zero.zero) : @is_add_cyclic.{0} (add_comm_monoid.{0} name) (@matrix.vec_empty.{0} (add_group.{0} (add_comm_monoid.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_43981 (h0 : topological_space (canonically_ordered_monoid num)) : t1_space (canonically_ordered_monoid num) := sorry --non-trivial
lemma new_lemma_43982 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @path_connected_space.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_43983 (h0 : functor.add_const (ring (generalized_boolean_algebra Type)) (has_add linarith.comp)) : @is_principal_ideal_ring.{1} (generalized_boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (generalized_boolean_algebra.{1} Type)) (has_add.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_43984 (h0 : add_monoid (has_neg (has_to_string name))) : add_monoid.fg (has_neg (has_to_string name)) := sorry --non-trivial
lemma new_lemma_43985 (h0 : topological_space (comm_semigroup Type)) : t0_space (comm_semigroup Type) := sorry --non-trivial
lemma new_lemma_43986 (h0 : function.extfun Type (functor.add_const (list (semigroup empty)))) : palindrome (functor.add_const.run (function.extfun_app h0 empty)) := sorry --non-trivial
lemma new_lemma_43987 (h0 : topological_space (sub_neg_monoid (finset linarith.comp))) : normal_space (sub_neg_monoid (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_43988 (h0 : functor.add_const (complete_lattice (has_add unsigned)) unsigned) : @is_compactly_generated.{0} (has_add.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_add.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_43989 (h0 : uniform_space (has_neg (has_add pos))) : separated_space (has_neg (has_add pos)) := sorry --non-trivial
lemma new_lemma_43990 (h0 : topological_space (ordered_comm_ring (ring (ring linarith.comp)))) : normal_space (ordered_comm_ring (ring (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_43991 (h0 : fin has_zero.zero) : @is_add_cyclic.{0} (complete_distrib_lattice.{0} linarith.comp) (@matrix.vec_empty.{0} (add_group.{0} (complete_distrib_lattice.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_43992 (h0 : function.extfun Type ring) : @is_domain.{0} (bin_tree.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (bin_tree.{0} empty))  := sorry --non-trivial
lemma new_lemma_43993 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (normed_group.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_group.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_43994 (h0 : ring (has_neg_part (has_nndist ennreal))) : rank_condition (has_neg_part (has_nndist ennreal)) := sorry --non-trivial
lemma new_lemma_43995 (h1 h2 : multiset (mul_one_class environment.projection_info)) : multiset.subset h1 h2 := sorry --non-trivial
lemma new_lemma_43996 (h0 : functor.add_const (topological_space (left_cancel_monoid unsigned)) unsigned) : @preirreducible_space.{0} (left_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_43997 (h0 : has_mem.mem (semiring empty) has_emptyc.emptyc) : @complete_space.{0} (semiring.{0} empty) (@finset.pi.empty.{1 0} Type uniform_space.{0} (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_43998 (h0 : functor.add_const (ring (ordered_comm_monoid Type)) pos) : @is_domain.{1} (ordered_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (ordered_comm_monoid.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_43999 (h0 : complete_lattice (generalized_boolean_algebra (has_Inf linarith.comp))) : complete_lattice.is_Sup_finite_compact (generalized_boolean_algebra (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_44000 (h0 : function.extfun (((Type -> Type) -> Type 1) -> Type 1) (function.extfun ((Type -> Type) -> Type 1))) : @normal_space.{0} (monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) (@function.extfun_app.{3 3} (((Type → Type) → Type 1) → Type 1) (function.extfun.{3 2} ((Type → Type) → Type 1)) h0 (function.extfun.{2 2} (Type → Type))) (function.extfun.{2 1} Type)) topological_space.{0}) (monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_44001 (h0 : function.extfun nat fin) : @unique_factorization_monoid.{1} (sub_neg_monoid.{1} Type) (@matrix.vec_empty.{1} (cancel_comm_monoid_with_zero.{1} (sub_neg_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_44002 (h0 : fin has_zero.zero) : @irreducible_space.{1} (canonically_ordered_comm_semiring.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (canonically_ordered_comm_semiring.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_44003 (h1 : uniform_space std_gen) : complete_space std_gen := sorry --non-trivial
lemma new_lemma_44004 (h0 : uniform_space (non_unital_non_assoc_semiring (comm_ring (denumerable to_additive.value_type)))) : complete_space (non_unital_non_assoc_semiring (comm_ring (denumerable to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_44005 (h0 : not (uniform_space (topological_space to_additive.value_type) -> false)) : @complete_space.{0} (topological_space.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (uniform_space.{0} (topological_space.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_44006 (h0 : add_group (canonically_linear_ordered_monoid (option (mul_zero_class name)))) : is_add_cyclic (canonically_linear_ordered_monoid (option (mul_zero_class name))) := sorry --non-trivial
lemma new_lemma_44007 (h0 : topological_space (linear_ordered_add_comm_group (has_nnnorm linarith.comp_source))) : totally_disconnected_space (linear_ordered_add_comm_group (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_44008 (h0 : topological_space (canonically_linear_ordered_monoid (has_nndist (boolean_algebra.core name)))) : normal_space (canonically_linear_ordered_monoid (has_nndist (boolean_algebra.core name))) := sorry --non-trivial
lemma new_lemma_44009 (h0 : linarith.comp -> Type -> Prop) : relator.bi_total h0 := sorry --non-trivial
lemma new_lemma_44010 (h0 : functor.add_const (filter (comm_group name)) name) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_44011 (h0 : has_neg (non_unital_non_assoc_semiring fun_info)) (h1 : measurable_space (non_unital_non_assoc_semiring fun_info)) : has_measurable_neg (non_unital_non_assoc_semiring fun_info) := sorry --non-trivial
lemma new_lemma_44012 (h0 : topological_space (complete_distrib_lattice name)) : sequential_space (complete_distrib_lattice name) := sorry --non-trivial
lemma new_lemma_44013 (h0 : topological_space (has_add (has_neg Type))) : path_connected_space (has_add (has_neg Type)) := sorry --non-trivial
lemma new_lemma_44014 (h0 : functor.add_const (uniform_space (ring linarith.comp)) (has_nndist Type)) : @separated_space.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (uniform_space.{0} (ring.{0} linarith.comp)) (has_nndist.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_44015 (h0 : functor.add_const (topological_space (free_add_monoid unsigned)) unsigned) : @totally_separated_space.{0} (free_add_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_44016 (h0 : functor.add_const (topological_space (comm_group pos)) Type) : @loc_path_connected_space.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (comm_group.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_44017 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_atomistic.{1} (cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 complete_lattice.{1}) (cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_44018 (h1 : add_group (mul_one_class (normed_field (add_comm_semigroup enat)))) : is_add_cyclic (mul_one_class (normed_field (add_comm_semigroup enat))) := sorry --non-trivial
lemma new_lemma_44019 (h0 : topological_space (add_comm_monoid (comm_group pos))) : totally_disconnected_space (add_comm_monoid (comm_group pos)) := sorry --non-trivial
lemma new_lemma_44020 (h0 : topological_space (has_pos_part (has_neg name))) : irreducible_space (has_pos_part (has_neg name)) := sorry --non-trivial
lemma new_lemma_44021 (h0 : ring (ordered_comm_ring real)) : strong_rank_condition (ordered_comm_ring real) := sorry --non-trivial
lemma new_lemma_44022 (h0 : functor.add_const (function.extfun Type uniform_space) name) : @complete_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) name h0) (boolean_algebra.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_44023 (h0 : filter (plift (semiring unsigned))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_44024 (h0 : topological_space (has_one (semiring (semiring unsigned)))) : path_connected_space (has_one (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_44025 (h1 : not (topological_space (semi_normed_ring linarith.comp_source) -> false)) : @path_connected_space.{0} (semi_normed_ring.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (semi_normed_ring.{0} linarith.comp_source)) h1)  := sorry --non-trivial
lemma new_lemma_44026 (h0 : functor.add_const (complete_lattice (comm_group pos)) Type) : @is_compactly_generated.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 1} (complete_lattice.{0} (comm_group.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_44027 (h1 : has_coe char Prop) (h3 : char) : @coe_b.{1 1} char Prop h1 h3  := sorry --non-trivial
lemma new_lemma_44028 (h0 : not (function.extfun (Type 1) topological_space -> false)) : @normal_space.{1} (plift.{1} linarith.comp) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@classical.by_contradiction'.{3} (function.extfun.{3 2} (Type 1) topological_space.{1}) h0) (plift.{1} linarith.comp))  := sorry --non-trivial
lemma new_lemma_44029 (h4 : uniform_space (nondiscrete_normed_field linarith.ineq)) : complete_space (nondiscrete_normed_field linarith.ineq) := sorry --non-trivial
lemma new_lemma_44030 (h0 : list (with_one (has_top (has_norm (has_top linarith.comp_source))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_44031 (h0 : complete_lattice (add_cancel_monoid name)) : is_atomistic (add_cancel_monoid name) := sorry --non-trivial
lemma new_lemma_44032 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (linear_ordered_comm_monoid_with_zero.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_monoid_with_zero.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_44033 (h0 : functor.add_const (filter (canonically_ordered_comm_semiring name)) pos) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_44034 (h0 : topological_space (complete_distrib_lattice (boolean_algebra Type))) : path_connected_space (complete_distrib_lattice (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_44035 (h0 : functor.add_const (function.extfun Type group) environment.implicit_infer_kind) : @is_cyclic.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) environment.implicit_infer_kind h0) (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_44036 (h0 : group (add_cancel_monoid (option ennreal))) : normalizer_condition (add_cancel_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_44037 (h0 : topological_space (boolean_algebra (ring (finset environment.implicit_infer_kind)))) : preconnected_space (boolean_algebra (ring (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_44038 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (generalized_boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (generalized_boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_44039 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (canonically_ordered_add_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_add_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_44040 (h0 : functor.add_const (add_group (has_neg name)) linarith.comp) : @is_add_cyclic.{0} (has_neg.{0} name) (@functor.add_const.run.{0 0} (add_group.{0} (has_neg.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_44041 (h0 : ring (with_bot (has_top fun_info))) : rank_condition (with_bot (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_44042 (h0 : complete_lattice (finset real)) : is_compactly_generated (finset real) := sorry --non-trivial
lemma new_lemma_44043 (h0 : functor.add_const (function.extfun Type ring) pos) : @is_domain.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) pos h0) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_44044 (h0 : functor.add_const (topological_space (canonically_ordered_add_monoid unsigned)) congr_arg_kind) : @t1_space.{0} (canonically_ordered_add_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_add_monoid.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_44045 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_bot.{0} (option.{0} unsigned)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_bot.{0} (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_44046 (h0 : not (complete_lattice (has_union empty) -> false)) : @is_atomistic.{0} (has_union.{0} empty) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_union.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_44047 (h0 : topological_space (add_cancel_monoid empty)) : loc_path_connected_space (add_cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_44048 (h0 : monoid (with_bot (has_inv (comm_ring fun_info)))) : monoid.fg (with_bot (has_inv (comm_ring fun_info))) := sorry --non-trivial
lemma new_lemma_44049 (h0 : function.extfun Type topological_space) : @normal_space.{0} (has_zero.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_44050 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (ordered_cancel_add_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (ordered_cancel_add_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_44051 (h0 : group (finset ennreal)) : is_simple_group (finset ennreal) := sorry --non-trivial
lemma new_lemma_44052 (h0 : functor.add_const (topological_space (comm_group linarith.comp)) pos) : @loc_path_connected_space.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_44053 (h0 : functor.add_const (topological_space (finset pos)) pos) : @irreducible_space.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_44054 (h0 : ring (random_gen (has_norm (has_norm (has_norm (has_norm linarith.comp_source)))))) : rank_condition (random_gen (has_norm (has_norm (has_norm (has_norm linarith.comp_source))))) := sorry --non-trivial
lemma new_lemma_44055 (h0 : topological_space (as_linear_order num)) : totally_disconnected_space (as_linear_order num) := sorry --non-trivial
lemma new_lemma_44056 (h0 : topological_space (linear_ordered_add_comm_group (random_gen linarith.comp_source))) : path_connected_space (linear_ordered_add_comm_group (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_44057 (h0 : functor.add_const (list (has_add Type)) environment.implicit_infer_kind) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_44058 (h0 : functor.add_const (topological_space (partial_order num)) num) : @t1_space.{0} (partial_order.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (partial_order.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_44059 (h0 : functor.add_const (ring (left_cancel_monoid empty)) empty) : @rank_condition.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (left_cancel_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_44060 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (simple_graph.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} h0 (simple_graph.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_44061 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @t0_space.{1} (boolean_algebra.core.{1} (has_add.{1} Type)) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (boolean_algebra.core.{1} (has_add.{1} Type)))  := sorry --non-trivial
lemma new_lemma_44062 (h0 : uniform_space (has_zero (finset Type))) : separated_space (has_zero (finset Type)) := sorry --non-trivial
lemma new_lemma_44063 (h2 : ring (distrib char)) : strong_rank_condition (distrib char) := sorry --non-trivial
lemma new_lemma_44064 (h0 : topological_space (generalized_boolean_algebra (has_bot (boolean_algebra (has_add (has_bot real)))))) : t1_space (generalized_boolean_algebra (has_bot (boolean_algebra (has_add (has_bot real))))) := sorry --non-trivial
lemma new_lemma_44065 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} (has_union.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_union.{0} num))  := sorry --non-trivial
lemma new_lemma_44066 (h0 : topological_space (with_one (has_top (has_top linarith.ineq)))) : path_connected_space (with_one (has_top (has_top linarith.ineq))) := sorry --non-trivial
lemma new_lemma_44067 (h0 : cancel_comm_monoid_with_zero (has_zero ennreal)) : unique_factorization_monoid (has_zero ennreal) := sorry --non-trivial
lemma new_lemma_44068 (h0 : function.extfun (set linarith.ineq) (fun (x : set linarith.ineq), Prop)) : is_countably_spanning (function.extfun_app h0) := sorry --non-trivial
lemma new_lemma_44069 (h1 : function.extfun Type topological_space) : @irreducible_space.{0} (measurable_space.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (measurable_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_44070 (h0 : ring (has_nnnorm (random_gen to_additive.value_type))) : is_domain (has_nnnorm (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_44071 (h0 : functor.add_const (complete_lattice (semigroup environment.implicit_infer_kind)) Type) : @is_compactly_generated.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (complete_lattice.{0} (semigroup.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_44072 (h0 : topological_space (has_nnnorm (has_nnnorm char))) : locally_compact_space (has_nnnorm (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_44073 (h0 : topological_space (complete_distrib_lattice (has_neg_part name))) : regular_space (complete_distrib_lattice (has_neg_part name)) := sorry --non-trivial
lemma new_lemma_44074 (h0 : not (ring reducibility_hints -> false)) : @rank_condition.{0} reducibility_hints (@classical.by_contradiction'.{1} (ring.{0} reducibility_hints) h0)  := sorry --non-trivial
lemma new_lemma_44075 (h0 : group (add_comm_monoid ennreal)) : is_cyclic (add_comm_monoid ennreal) := sorry --non-trivial
lemma new_lemma_44076 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (mul_zero_class.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (mul_zero_class.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_44077 (h0 : functor.add_const (group (finset unsigned)) unsigned) : @normalizer_condition.{0} (finset.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (finset.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_44078 (h0 : list (has_ssubset string.iterator_imp) -> Prop) (h1 : Exists (fun (x : list (has_ssubset string.iterator_imp)), h0 x)) (h2 : list (has_ssubset string.iterator_imp)) : list.is_rotated (classical.some h1) h2 := sorry --non-trivial
lemma new_lemma_44079 (h0 : functor.add_const (topological_space (partial_order congr_arg_kind)) num) : @t1_space.{0} (partial_order.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (partial_order.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_44080 (h0 : add_group (distrib_lattice (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm fun_info)))))) : is_add_cyclic (distrib_lattice (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm fun_info))))) := sorry --non-trivial
lemma new_lemma_44081 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @t0_space.{0} (ordered_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (ordered_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_44082 (h0 : ring (encodable string_imp)) : rank_condition (encodable string_imp) := sorry --non-trivial
lemma new_lemma_44083 (h0 : functor.add_const (topological_space (boolean_algebra.core environment.implicit_infer_kind)) name) : @preconnected_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_44084 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_union.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} h0 (has_union.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_44085 (h0 : topological_space (has_nndist pos)) : loc_path_connected_space (has_nndist pos) := sorry --non-trivial
lemma new_lemma_44086 (h0 : functor.add_const (uniform_space (comm_group unsigned)) environment.implicit_infer_kind) : @separated_space.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (uniform_space.{0} (comm_group.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_44087 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @irreducible_space.{0} (linear_ordered_semiring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (linear_ordered_semiring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_44088 (h0 : ring (has_neg (option (option (option empty))))) : is_principal_ideal_ring (has_neg (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_44089 (h0 : function.extfun (Type 1) ordered_add_comm_monoid) : @archimedean.{1} (add_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_add_comm_monoid.{1} h0 (add_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_44090 (h1 : topological_space (has_div linarith.ineq)) : totally_disconnected_space (has_div linarith.ineq) := sorry --non-trivial
lemma new_lemma_44091 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (measurable_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measurable_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_44092 (h0 : functor.add_const (topological_space (boolean_algebra Type)) linarith.comp) : @preirreducible_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_44093 (h0 : functor.add_const (filter (ring Type)) (has_add environment.implicit_infer_kind)) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_44094 (h0 : filter (with_zero (random_gen (has_nnnorm linarith.ineq)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_44095 (h0 : uniform_space (measurable_space linarith.comp_source)) : complete_space (measurable_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_44096 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (has_nndist.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_44097 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_add_cyclic.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_group.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 add_group.{1}) (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_44098 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @sequential_space.{0} (has_zero.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (has_zero.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_44099 (h0 : ring (has_nndist linarith.comp)) : is_principal_ideal_ring (has_nndist linarith.comp) := sorry --non-trivial
lemma new_lemma_44100 (h0 : filter (canonically_ordered_monoid (has_Inf (has_Inf pos)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_44101 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (left_cancel_monoid.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (left_cancel_monoid.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_44102 (h0 : topological_space (add_cancel_monoid (option (option ennreal)))) : preconnected_space (add_cancel_monoid (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_44103 (h0 : topological_space (has_zero (ring pos))) : topological_space.separable_space (has_zero (ring pos)) := sorry --non-trivial
lemma new_lemma_44104 (h0 : topological_space (boolean_algebra.core (has_add (has_add (has_add (finset pos)))))) : discrete_topology (boolean_algebra.core (has_add (has_add (has_add (finset pos))))) := sorry --non-trivial
lemma new_lemma_44105 (h0 : filter (has_ssubset (has_nnnorm (has_nnnorm linarith.ineq)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_44106 (h1 : not (topological_space (linear_ordered_add_comm_group to_additive.value_type) -> false)) : @totally_disconnected_space.{0} (linear_ordered_add_comm_group.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_add_comm_group.{0} to_additive.value_type)) h1)  := sorry --non-trivial
lemma new_lemma_44107 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (add_comm_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_comm_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_44108 (h3 : topological_space (has_ssubset to_additive.value_type)) : t0_space (has_ssubset to_additive.value_type) := sorry --non-trivial
lemma new_lemma_44109 (h0 : not (topological_space (normed_group congr_arg_kind) -> false)) : @totally_disconnected_space.{0} (normed_group.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_group.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_44110 (h0 : topological_space (ring unsigned)) : path_connected_space (ring unsigned) := sorry --non-trivial
lemma new_lemma_44111 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring pos)) name) : @preirreducible_space.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_44112 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (has_add.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_add.{0} real))  := sorry --non-trivial
lemma new_lemma_44113 (h0 : ring (has_neg (has_neg (finset pos)))) : strong_rank_condition (has_neg (has_neg (finset pos))) := sorry --non-trivial
lemma new_lemma_44114 (h0 : has_mem.mem (has_emptyc empty) has_emptyc.emptyc) : @normalizer_condition.{0} (has_emptyc.{0} empty) (@finset.pi.empty.{1 0} Type group.{0} (has_emptyc.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_44115 (h0 : topological_space (semiring (semiring congr_arg_kind))) : path_connected_space (semiring (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_44116 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_inter.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_inter.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_44117 (h0 : add_monoid (normed_comm_ring (add_comm_monoid environment.implicit_infer_kind))) : add_monoid.fg (normed_comm_ring (add_comm_monoid environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_44118 (h0 : ring (has_top (comm_ring to_additive.value_type))) : is_domain (has_top (comm_ring to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_44119 (h0 : add_monoid (simple_graph (has_add pos))) : add_monoid.fg (simple_graph (has_add pos)) := sorry --non-trivial
lemma new_lemma_44120 (h0 : topological_space (topological_space (mul_one_class char))) : path_connected_space (topological_space (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_44121 (h0 : ring (complete_distrib_lattice (has_Inf (finset linarith.comp)))) : is_domain (complete_distrib_lattice (has_Inf (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_44122 (h2 : topological_space (denumerable linarith.ineq)) : path_connected_space (denumerable linarith.ineq) := sorry --non-trivial
lemma new_lemma_44123 (h0 : ring (has_Inf (ring Type))) : rank_condition (has_Inf (ring Type)) := sorry --non-trivial
lemma new_lemma_44124 (h0 : functor.add_const Prop (add_right_cancel_monoid (semiring (non_assoc_semiring empty)))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_44125 (h0 : topological_space (finset (has_to_string pos))) : normal_space (finset (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_44126 (h0 : topological_space (has_nndist (boolean_algebra environment.implicit_infer_kind))) : totally_separated_space (has_nndist (boolean_algebra environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_44127 (h0 : topological_space (has_neg (has_neg_part Type))) : normal_space (has_neg (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_44128 (h0 : topological_space (simple_graph (option empty))) : t1_space (simple_graph (option empty)) := sorry --non-trivial
lemma new_lemma_44129 (h0 : group (normed_comm_ring empty)) : normalizer_condition (normed_comm_ring empty) := sorry --non-trivial
lemma new_lemma_44130 (h0 : ring (semigroup (ring (has_add unsigned)))) : rank_condition (semigroup (ring (has_add unsigned))) := sorry --non-trivial
lemma new_lemma_44131 (h0 : list (has_top (with_one (random_gen to_additive.value_type)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_44132 (h0 : function.extfun Type (prod (has_Sup congr_arg_kind))) : id_rel (function.extfun_app h0 (has_Sup congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_44133 (h0 : topological_space (ordered_comm_monoid (ordered_comm_ring (has_add Type)))) : regular_space (ordered_comm_monoid (ordered_comm_ring (has_add Type))) := sorry --non-trivial
lemma new_lemma_44134 (h0 : functor.add_const (group (has_neg (has_add linarith.comp))) (has_add (has_neg (ordered_ring (ordered_ring Type))))) : @is_cyclic.{0} (has_neg.{0} (has_add.{0} linarith.comp)) (@functor.add_const.run.{0 1} (group.{0} (has_neg.{0} (has_add.{0} linarith.comp))) (has_add.{1} (has_neg.{1} (ordered_ring.{1} (ordered_ring.{1} Type)))) h0)  := sorry --non-trivial
lemma new_lemma_44135 (h0 : ring (normed_group (has_norm (has_norm num)))) : strong_rank_condition (normed_group (has_norm (has_norm num))) := sorry --non-trivial
lemma new_lemma_44136 (h0 : uniform_space (finset (has_Inf pos))) : complete_space (finset (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_44137 (h0 : function.extfun (finset (Type -> Type) -> Prop) (function.extfun (finset (Type -> Type)))) : @is_domain.{0} unsigned (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) ring.{0}) (@function.extfun_app.{2 0} (finset.{1} (Type → Type) → Prop) (function.extfun.{2 0} (finset.{1} (Type → Type))) h0 (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) ring.{0})) (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) unsigned)  := sorry --non-trivial
lemma new_lemma_44138 (h0 : ring (semigroup (finset (finset pos)))) : strong_rank_condition (semigroup (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_44139 (h0 : functor.add_const (topological_space (canonically_ordered_monoid linarith.comp)) pos) : @loc_path_connected_space.{0} (canonically_ordered_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_monoid.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_44140 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (with_one.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (with_one.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_44141 (h0 : not (group (has_compl string_imp) -> false)) : @is_cyclic.{0} (has_compl.{0} string_imp) (@classical.by_contradiction'.{1} (group.{0} (has_compl.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_44142 (h0 : add_monoid (canonically_ordered_monoid (has_neg Type))) : add_monoid.fg (canonically_ordered_monoid (has_neg Type)) := sorry --non-trivial
lemma new_lemma_44143 (h0 : uniform_space (ring ennreal)) : complete_space (ring ennreal) := sorry --non-trivial
lemma new_lemma_44144 (h1 : topological_space (normed_field string.iterator_imp)) : totally_disconnected_space (normed_field string.iterator_imp) := sorry --non-trivial
lemma new_lemma_44145 (h0 : ring (boolean_algebra.core num)) : strong_rank_condition (boolean_algebra.core num) := sorry --non-trivial
lemma new_lemma_44146 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (complete_semilattice_Sup.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (complete_semilattice_Sup.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (complete_lattice.{0} (complete_semilattice_Sup.{0} empty))) (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 (functor.add_const.{0 0} (complete_lattice.{0} (complete_semilattice_Sup.{0} empty)))) empty))  := sorry --non-trivial
lemma new_lemma_44147 (h0 : functor.add_const (add_monoid (has_bot empty)) empty) : @add_monoid.fg.{0} (has_bot.{0} empty) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_bot.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_44148 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @group.fg.{0} (encodable.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) group.{0}) (encodable.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_44149 (h0 : not (function.extfun Type topological_space -> false)) : @discrete_topology.{0} (has_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_44150 (h0 : semiring (linear_ordered_field (has_to_string (has_to_string num)))) : is_noetherian_ring (linear_ordered_field (has_to_string (has_to_string num))) := sorry --non-trivial
lemma new_lemma_44151 (h0 : topological_space (measure_theory.measure_space congr_arg_kind)) : normal_space (measure_theory.measure_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_44152 (h0 : topological_space (has_top (has_inv (has_inv (has_inv to_additive.value_type))))) : locally_compact_space (has_top (has_inv (has_inv (has_inv to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_44153 (h0 : functor.add_const (topological_space (comm_monoid empty)) empty) : @locally_compact_space.{0} (comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_44154 (h2 : has_lt (simple_graph fun_info)) : no_max_order (simple_graph fun_info) := sorry --non-trivial
lemma new_lemma_44155 (h0 : function.extfun Type (functor.add_const (topological_space (has_Inf linarith.comp)))) : @totally_separated_space.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} linarith.comp)) linarith.comp (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (has_Inf.{0} linarith.comp))) h0 linarith.comp))  := sorry --non-trivial
lemma new_lemma_44156 (h3 : not (topological_space (denumerable char) -> false)) : @t0_space.{0} (denumerable.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (denumerable.{0} char)) h3)  := sorry --non-trivial
lemma new_lemma_44157 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @locally_compact_space.{0} (distrib_lattice.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) topological_space.{0}) (distrib_lattice.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_44158 (h1 : group (has_norm num)) : normalizer_condition (has_norm num) := sorry --non-trivial
lemma new_lemma_44159 (h0 : not (topological_space (semiring num) -> false)) : @t0_space.{0} (semiring.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (semiring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_44160 (h0 : ring (has_neg_part (finset Type))) : is_domain (has_neg_part (finset Type)) := sorry --non-trivial
lemma new_lemma_44161 (h0 : uniform_space (has_compl linarith.comp_source)) : complete_space (has_compl linarith.comp_source) := sorry --non-trivial
lemma new_lemma_44162 (h0 : ordered_add_comm_monoid (semigroup (has_neg_part (option (boolean_algebra pos))))) : archimedean (semigroup (has_neg_part (option (boolean_algebra pos)))) := sorry --non-trivial
lemma new_lemma_44163 (h0 : topological_space (linear_ordered_semiring unsigned)) : totally_separated_space (linear_ordered_semiring unsigned) := sorry --non-trivial
lemma new_lemma_44164 (h0 : functor.add_const (add_group (add_semigroup empty)) (option empty)) : @is_add_cyclic.{0} (add_semigroup.{0} empty) (@functor.add_const.run.{0 0} (add_group.{0} (add_semigroup.{0} empty)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_44165 (h0 : topological_space (linear_ordered_semiring (random_gen (random_gen fun_info)))) : locally_compact_space (linear_ordered_semiring (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_44166 (h0 : char -> char -> Prop) (h1 h4 : char) : eqv_gen h0 h1 h4 := sorry --non-trivial
lemma new_lemma_44167 (h0 : ring (has_union empty)) : is_domain (has_union empty) := sorry --non-trivial
lemma new_lemma_44168 (h1 : ring (add_comm_semigroup (normed_field (mul_one_class enat)))) : strong_rank_condition (add_comm_semigroup (normed_field (mul_one_class enat))) := sorry --non-trivial
lemma new_lemma_44169 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} unsigned (@function.extfun_app.{2 1} Type topological_space.{0} h0 unsigned)  := sorry --non-trivial
lemma new_lemma_44170 (h0 : functor.add_const (cancel_comm_monoid_with_zero (bin_tree unsigned)) unsigned) : @unique_factorization_monoid.{0} (bin_tree.{0} unsigned) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (bin_tree.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_44171 (h0 : not (group (partial_order unsigned) -> false)) : @group.fg.{0} (partial_order.{0} unsigned) (@classical.by_contradiction'.{1} (group.{0} (partial_order.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_44172 (h0 : complete_lattice (finset Type)) : is_compactly_generated (finset Type) := sorry --non-trivial
lemma new_lemma_44173 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (sub_neg_monoid pos)) := sorry --non-trivial
lemma new_lemma_44174 (h0 : group (add_monoid (has_nnnorm linarith.comp_source))) : is_cyclic (add_monoid (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_44175 (h0 : ring (denumerable (has_nnnorm (has_nnnorm (has_ssubset char))))) : is_domain (denumerable (has_nnnorm (has_nnnorm (has_ssubset char)))) := sorry --non-trivial
lemma new_lemma_44176 (h0 : functor.add_const (topological_space (has_nndist environment.implicit_infer_kind)) (has_neg linarith.comp)) : @locally_compact_space.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} environment.implicit_infer_kind)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_44177 (h0 : add_group (ordered_ring num)) : is_add_cyclic (ordered_ring num) := sorry --non-trivial
lemma new_lemma_44178 (h0 : group (has_star (semiring unsigned))) : is_cyclic (has_star (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_44179 (h0 : function.extfun Type group) : @normalizer_condition.{0} (add_group_with_zero_nhd.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (add_group_with_zero_nhd.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_44180 (h0 : group (normed_group (semiring empty))) : normalizer_condition (normed_group (semiring empty)) := sorry --non-trivial
lemma new_lemma_44181 (h0 : functor.add_const (complete_lattice (has_nndist pos)) (has_to_string environment.implicit_infer_kind)) : @is_compactly_generated.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_nndist.{0} pos)) (has_to_string.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_44182 (h2 : not (ring (topological_space char) -> false)) : @strong_rank_condition.{0} (topological_space.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (topological_space.{0} char)) h2)  := sorry --non-trivial
lemma new_lemma_44183 (h0 : functor.add_const (ring (ordered_ring empty)) num) : @is_principal_ideal_ring.{0} (ordered_ring.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (ordered_ring.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_44184 (h0 : functor.add_const (complete_lattice (canonically_ordered_comm_semiring Type)) name) : @is_atomistic.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (canonically_ordered_comm_semiring.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_44185 (h0 : group (semigroup (comm_group (has_add unsigned)))) : is_simple_group (semigroup (comm_group (has_add unsigned))) := sorry --non-trivial
lemma new_lemma_44186 (h0 : functor.add_const (topological_space (has_neg_part unsigned)) (option (option pos))) : @preconnected_space.{0} (has_neg_part.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} unsigned)) (option.{0} (option.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_44187 (h0 : topological_space (has_to_string (has_add unsigned))) : discrete_topology (has_to_string (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_44188 (h0 : add_monoid (linear_ordered_field ennreal)) : add_monoid.fg (linear_ordered_field ennreal) := sorry --non-trivial
lemma new_lemma_44189 (h1 : std_gen -> std_gen -> Prop) (h2 h3 : std_gen) : eqv_gen h1 h2 h3 := sorry --non-trivial
lemma new_lemma_44190 (h0 : topological_space (has_pos_part (finset (has_add linarith.comp)))) : totally_separated_space (has_pos_part (finset (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_44191 (h0 : complete_lattice (with_bot num)) : is_atomistic (with_bot num) := sorry --non-trivial
lemma new_lemma_44192 (h0 : topological_space (ring (has_add (has_add linarith.comp)))) : totally_separated_space (ring (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_44193 (h0 : topological_space (generalized_boolean_algebra (has_add (ring name)))) : preirreducible_space (generalized_boolean_algebra (has_add (ring name))) := sorry --non-trivial
lemma new_lemma_44194 (h0 : group (normed_linear_ordered_group congr_arg_kind)) : normalizer_condition (normed_linear_ordered_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_44195 (h0 : functor.add_const (finset (boolean_algebra environment.implicit_infer_kind)) Type) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_44196 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (is_R_or_C.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (is_R_or_C.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_44197 (h0 : not (prod fun_info fun_info -> false)) : set.diagonal fun_info (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_44198 (h0 : topological_space (finset (has_zero (finset (has_neg (ring Type)))))) : locally_compact_space (finset (has_zero (finset (has_neg (ring Type))))) := sorry --non-trivial
lemma new_lemma_44199 (h0 : partial_order (option_t (sum ennreal) ennreal)) (h1 : order_top (option_t (sum ennreal) ennreal)) : is_coatomic (option_t (sum ennreal) ennreal) := sorry --non-trivial
lemma new_lemma_44200 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (random_gen.{0} linarith.ineq) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 uniform_space.{0}) (random_gen.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_44201 (h0 : topological_space (finset (finset (finset linarith.comp)))) : discrete_topology (finset (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_44202 (h0 : ring (has_zero num)) : strong_rank_condition (has_zero num) := sorry --non-trivial
lemma new_lemma_44203 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @t0_space.{0} (semiring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_44204 (h0 : functor.add_const (fin has_zero.zero) (sub_neg_monoid (has_neg name))) : @loc_path_connected_space.{0} (has_add.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) (@functor.add_const.run.{0 0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (sub_neg_monoid.{0} (has_neg.{0} name)) h0)) (has_add.{0} real))  := sorry --non-trivial
lemma new_lemma_44205 (h0 : functor.add_const (topological_space (ring linarith.comp)) linarith.comp) : @locally_compact_space.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_44206 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (add_comm_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_44207 (h0 : complete_lattice (with_bot (has_top unsigned))) : is_atomistic (with_bot (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_44208 (h0 : not (ring (encodable linarith.comp_source) -> false)) : @is_domain.{0} (encodable.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (encodable.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_44209 (h0 : function.extfun Type group) : @is_cyclic.{0} (add_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (add_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_44210 (h0 : functor.add_const (topological_space (ring environment.implicit_infer_kind)) name) : @topological_space.separable_space.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_44211 (h0 : not (complete_lattice (metric_space num) -> false)) : @is_compactly_generated.{0} (metric_space.{0} num) (@classical.by_contradiction'.{1} (complete_lattice.{0} (metric_space.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_44212 (h0 : function.extfun nat fin) : @has_exists_mul_of_le.{0} (has_Inf.{0} pos) (@matrix.vec_empty.{0} (ordered_comm_monoid.{0} (has_Inf.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_44213 (h0 : topological_space (boolean_algebra (finset environment.implicit_infer_kind))) : preconnected_space (boolean_algebra (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_44214 (h0 : ring (linear_ordered_comm_group (option unsigned))) : is_principal_ideal_ring (linear_ordered_comm_group (option unsigned)) := sorry --non-trivial
lemma new_lemma_44215 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (add_comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_group.{0} h0 (add_comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_44216 (h0 : ring (boolean_algebra (has_add environment.implicit_infer_kind))) : is_principal_ideal_ring (boolean_algebra (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_44217 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (add_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_44218 (h0 : functor.add_const (topological_space linarith.comp) Type) : @loc_path_connected_space.{0} linarith.comp (@functor.add_const.run.{0 1} (topological_space.{0} linarith.comp) Type h0)  := sorry --non-trivial
lemma new_lemma_44219 (h0 : functor.add_const (function.extfun Type ordered_add_comm_monoid) linarith.comp) : @archimedean.{0} (has_neg.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_add_comm_monoid.{0}) linarith.comp h0) (has_neg.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_44220 (h0 : monoid (has_pos_part (finset (finset (finset linarith.comp))))) : monoid.fg (has_pos_part (finset (finset (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_44221 (h0 : functor.add_const (topological_space (left_cancel_semigroup unsigned)) unsigned) : @totally_separated_space.{0} (left_cancel_semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_semigroup.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_44222 (h0 : functor.add_const (topological_space (add_comm_monoid Type)) Type) : @regular_space.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (add_comm_monoid.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_44223 (h0 : add_monoid (semigroup (has_neg_part pos))) : add_monoid.fg (semigroup (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_44224 (h0 : list (has_top (random_gen (random_gen to_additive.value_type)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_44225 (h0 : fin has_zero.zero) : @group.fg.{1} (complete_distrib_lattice.{1} Type) (@matrix.vec_empty.{1} (group.{1} (complete_distrib_lattice.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_44226 (h0 : functor.add_const (complete_lattice (complete_distrib_lattice empty)) (semiring empty)) : @is_atomistic.{0} (complete_distrib_lattice.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (complete_distrib_lattice.{0} empty)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_44227 (h0 : group (has_nnnorm (random_gen string_imp))) : group.fg (has_nnnorm (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_44228 (h0 : topological_space (bin_tree unsigned)) : locally_compact_space (bin_tree unsigned) := sorry --non-trivial
lemma new_lemma_44229 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_dist.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_dist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_44230 (h0 : group (boolean_algebra.core (ring pos))) : group.fg (boolean_algebra.core (ring pos)) := sorry --non-trivial
lemma new_lemma_44231 (h0 : topological_space (normed_group (has_norm (has_norm (has_norm fun_info))))) : totally_separated_space (normed_group (has_norm (has_norm (has_norm fun_info)))) := sorry --non-trivial
lemma new_lemma_44232 (h0 : monoid (boolean_algebra (cancel_monoid pos))) : monoid.fg (boolean_algebra (cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_44233 (h0 : fin has_zero.zero) : @is_domain.{0} (ordered_comm_monoid.{0} real) (@matrix.vec_empty.{0} (ring.{0} (ordered_comm_monoid.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_44234 (h0 : topological_space (normed_linear_ordered_group (option (option (option unsigned))))) : path_connected_space (normed_linear_ordered_group (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_44235 (h0 : functor.add_const (filter (has_neg pos)) Type) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_44236 (h0 : list (comm_ring (with_one (has_inv fun_info)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_44237 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_simple_group.{0} (generalized_boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (generalized_boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_44238 (h2 : has_mem.mem (with_one linarith.ineq) has_emptyc.emptyc) : @monoid.fg.{0} (with_one.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type monoid.{0} (with_one.{0} linarith.ineq) h2)  := sorry --non-trivial
lemma new_lemma_44239 (h0 : semiring (add_cancel_monoid congr_arg_kind)) : is_noetherian_ring (add_cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_44240 (h0 : functor.add_const (topological_space (ring linarith.comp)) Type) : @normal_space.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (ring.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_44241 (h0 : group (has_one (semiring (has_top unsigned)))) : group.fg (has_one (semiring (has_top unsigned))) := sorry --non-trivial
lemma new_lemma_44242 (h0 : uniform_space (has_bot (has_add (has_add (has_add pos))))) : complete_space (has_bot (has_add (has_add (has_add pos)))) := sorry --non-trivial
lemma new_lemma_44243 (h0 : complete_lattice (has_top (random_gen (has_inv linarith.comp_source)))) : is_compactly_generated (has_top (random_gen (has_inv linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_44244 (h0 : topological_space (has_bot (has_bot (has_pos_part linarith.comp)))) : normal_space (has_bot (has_bot (has_pos_part linarith.comp))) := sorry --non-trivial
lemma new_lemma_44245 (h0 : ordered_comm_monoid (normed_lattice_add_comm_group (has_Inf real))) : has_exists_mul_of_le (normed_lattice_add_comm_group (has_Inf real)) := sorry --non-trivial
lemma new_lemma_44246 (h0 : not (function.extfun Type semiring -> false)) : @is_noetherian_ring.{0} (add_right_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type semiring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type semiring.{0}) h0) (add_right_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_44247 (h0 : group (generalized_boolean_algebra (has_add (has_pos_part pos)))) : normalizer_condition (generalized_boolean_algebra (has_add (has_pos_part pos))) := sorry --non-trivial
lemma new_lemma_44248 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (with_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_44249 (h0 : topological_space (ordered_comm_monoid (has_add pos))) : regular_space (ordered_comm_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_44250 (h0 : topological_space (ring (has_pos_part (has_Inf Type)))) : totally_separated_space (ring (has_pos_part (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_44251 (h0 : functor.add_const (group (generalized_boolean_algebra Type)) pos) : @group.fg.{1} (generalized_boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (generalized_boolean_algebra.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_44252 (h0 : functor.comp finset complete_distrib_lattice name) : finset.nonempty (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_44253 (h0 : function.extfun Type ring) : @is_domain.{0} znum (@function.extfun_app.{2 1} Type ring.{0} h0 znum)  := sorry --non-trivial
lemma new_lemma_44254 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_44255 (h0 : monoid (add_comm_monoid (add_comm_monoid Type))) : monoid.fg (add_comm_monoid (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_44256 (h0 : functor.add_const (function.extfun Type group) environment.implicit_infer_kind) : @is_cyclic.{0} (has_nndist.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) environment.implicit_infer_kind h0) (has_nndist.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_44257 (h0 : ring (ring (has_add name))) : is_principal_ideal_ring (ring (has_add name)) := sorry --non-trivial
lemma new_lemma_44258 (h1 : set (distrib string_imp)) : set.finite h1 := sorry --non-trivial
lemma new_lemma_44259 (h0 : ring (add_cancel_comm_monoid (comm_ring linarith.comp_source))) : is_domain (add_cancel_comm_monoid (comm_ring linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_44260 (h0 : not (add_group (uniform_space string_imp) -> false)) : @is_add_cyclic.{0} (uniform_space.{0} string_imp) (@classical.by_contradiction'.{1} (add_group.{0} (uniform_space.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_44261 (h0 : complete_lattice (normed_group (has_inv linarith.comp_source))) : is_atomistic (normed_group (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_44262 (h0 : group (comm_ring (has_nnnorm (has_nnnorm linarith.ineq)))) : group.fg (comm_ring (has_nnnorm (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_44263 (h2 : measurable_space (nondiscrete_normed_field string.iterator_imp)) (h3 : measure_theory.measure (nondiscrete_normed_field string.iterator_imp)) : measure_theory.is_finite_measure h3 := sorry --non-trivial
lemma new_lemma_44264 (h0 : not (complete_lattice (random_gen string_imp) -> false)) : @is_compactly_generated.{0} (random_gen.{0} string_imp) (@classical.by_contradiction'.{1} (complete_lattice.{0} (random_gen.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_44265 (h0 : set (mul_one_class (mul_one_class ereal) -> char)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_44266 (h0 : topological_space (semiring empty)) : irreducible_space (semiring empty) := sorry --non-trivial
lemma new_lemma_44267 (h0 : list (ulower Prop)) (h1 : punit) : @category_theory.hom_of_element.{0} Prop (@ulower.up.{0} Prop encodable.Prop (@list.head.{0} (@ulower.{0} Prop encodable.Prop) (@ulower.inhabited.{0} Prop encodable.Prop sort.inhabited.{0}) h0)) h1  := sorry --non-trivial
lemma new_lemma_44268 (h0 : complete_lattice (has_bot pos)) : is_compactly_generated (has_bot pos) := sorry --non-trivial
lemma new_lemma_44269 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @path_connected_space.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_44270 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (measurable_space.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (measurable_space.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_44271 (h0 : functor.add_const (topological_space (finset linarith.comp)) pos) : @loc_path_connected_space.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_44272 (h0 : uniform_space (has_pos_part (has_Inf pos))) : separated_space (has_pos_part (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_44273 (h0 : ordered_add_comm_monoid (canonically_linear_ordered_monoid Type)) : archimedean (canonically_linear_ordered_monoid Type) := sorry --non-trivial
lemma new_lemma_44274 (h0 : function.extfun Type topological_space) : @t1_space.{0} (linear_ordered_comm_ring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_ring.{0} num))  := sorry --non-trivial
lemma new_lemma_44275 (h0 : functor.add_const (topological_space (has_neg_part unsigned)) pos) : @discrete_topology.{0} (has_neg_part.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_44276 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (semigroup.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (semigroup.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_44277 (h0 : filter (boolean_algebra.core num)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_44278 (h0 : functor.add_const (topological_space (boolean_algebra linarith.comp)) Type) : @preconnected_space.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_44279 (h0 : complete_lattice (has_zero (has_nndist linarith.comp))) : is_compactly_generated (has_zero (has_nndist linarith.comp)) := sorry --non-trivial
lemma new_lemma_44280 (h0 : functor.add_const (ordered_add_comm_monoid (ring environment.implicit_infer_kind)) (has_neg Type)) : @archimedean.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (ordered_add_comm_monoid.{0} (ring.{0} environment.implicit_infer_kind)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_44281 (h1 : not (ring (random_gen congr_arg_kind) -> false)) : @is_domain.{0} (random_gen.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (ring.{0} (random_gen.{0} congr_arg_kind)) h1)  := sorry --non-trivial
lemma new_lemma_44282 (h0 : functor.comp filter boolean_algebra.core Type) : countable_Inter_filter (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_44283 (h0 : add_monoid (mul_zero_class (option unsigned))) : add_monoid.fg (mul_zero_class (option unsigned)) := sorry --non-trivial
lemma new_lemma_44284 (h0 : functor.add_const (ordered_comm_monoid (add_cancel_monoid pos)) environment.implicit_infer_kind) : @has_exists_mul_of_le.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (add_cancel_monoid.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_44285 (h0 : group (has_emptyc (with_bot (with_bot linarith.comp_source)))) : normalizer_condition (has_emptyc (with_bot (with_bot linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_44286 (h0 : add_monoid (ordered_comm_ring (boolean_algebra.core (has_add (has_Inf (has_add linarith.comp)))))) : add_monoid.fg (ordered_comm_ring (boolean_algebra.core (has_add (has_Inf (has_add linarith.comp))))) := sorry --non-trivial
lemma new_lemma_44287 (h0 : list (finset (has_add name))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_44288 (h0 : functor.add_const (topological_space (add_comm_monoid name)) unsigned) : @regular_space.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_44289 (h0 : topological_space (ring num)) : totally_separated_space (ring num) := sorry --non-trivial
lemma new_lemma_44290 (h0 : topological_space (has_Inf Type)) : discrete_topology (has_Inf Type) := sorry --non-trivial
lemma new_lemma_44291 (h1 : add_group (add_monoid linarith.comp_source)) : is_add_cyclic (add_monoid linarith.comp_source) := sorry --non-trivial
lemma new_lemma_44292 (h0 : complete_lattice num) : is_compactly_generated num := sorry --non-trivial
lemma new_lemma_44293 (h0 : functor.add_const (function.extfun Type topological_space) name) : @t0_space.{0} (generalized_boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (generalized_boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_44294 (h0 : topological_space (simple_graph linarith.ineq)) (h1 : preorder (simple_graph linarith.ineq)) : order_topology (simple_graph linarith.ineq) := sorry --non-trivial
lemma new_lemma_44295 (h0 : add_group (omega_complete_partial_order (semiring (semiring unsigned)))) : is_add_cyclic (omega_complete_partial_order (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_44296 (h0 : topological_space (measurable_space.dynkin_system empty)) : normal_space (measurable_space.dynkin_system empty) := sorry --non-trivial
lemma new_lemma_44297 (h0 : topological_space (ordered_comm_monoid (finset name))) : preconnected_space (ordered_comm_monoid (finset name)) := sorry --non-trivial
lemma new_lemma_44298 (h0 : fin has_zero.zero) : @path_connected_space.{0} (has_add.{0} fun_info) (@matrix.vec_empty.{0} (topological_space.{0} (has_add.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_44299 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (canonically_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_44300 (h0 : topological_space (has_to_string (has_add linarith.comp))) : t1_space (has_to_string (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_44301 (h0 : ring (has_nndist environment.implicit_infer_kind)) : is_domain (has_nndist environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_44302 (h1 : prod linarith.ineq linarith.ineq) : set.diagonal linarith.ineq h1 := sorry --non-trivial
lemma new_lemma_44303 (h0 : topological_space (comm_group (option pos))) : path_connected_space (comm_group (option pos)) := sorry --non-trivial
lemma new_lemma_44304 (h0 : list (ordered_ring (option unsigned))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_44305 (h2 h3 : multiset (simple_graph (mul_one_class (mul_one_class (mul_one_class (mul_one_class char)))))) : multiset.disjoint h2 h3 := sorry --non-trivial
lemma new_lemma_44306 (h0 : topological_space (normed_comm_ring (normed_comm_ring (has_add environment.implicit_infer_kind)))) : preirreducible_space (normed_comm_ring (normed_comm_ring (has_add environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_44307 (h1 : group (with_bot (has_norm (measurable_space to_additive.value_type)))) : normalizer_condition (with_bot (has_norm (measurable_space to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_44308 (h0 : topological_space (normed_group to_additive.value_type)) : totally_disconnected_space (normed_group to_additive.value_type) := sorry --non-trivial
lemma new_lemma_44309 (h0 : not (list (normed_group linarith.comp_source) -> false)) : list.nodup (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_44310 (h0 : function.extfun Type ring) : @is_domain.{0} (linear_ordered_add_comm_group.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_ordered_add_comm_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_44311 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (with_bot.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (with_bot.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_44312 (h0 : ring (canonically_ordered_comm_semiring (option pos))) : strong_rank_condition (canonically_ordered_comm_semiring (option pos)) := sorry --non-trivial
lemma new_lemma_44313 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_44314 (h0 : normed_group linarith.comp_source -> Prop) : Exists h0 := sorry --non-trivial
lemma new_lemma_44315 (h0 : add_group (add_cancel_comm_monoid (linear_ordered_add_comm_group string_imp))) : is_add_cyclic (add_cancel_comm_monoid (linear_ordered_add_comm_group string_imp)) := sorry --non-trivial
lemma new_lemma_44316 (h0 : function.extfun Type add_comm_group) (h1 : has_norm linarith.comp_source) : @normed_group.core.{0} linarith.comp_source (@function.extfun_app.{2 1} Type add_comm_group.{0} h0 linarith.comp_source) h1  := sorry --non-trivial
lemma new_lemma_44317 (h0 : functor.add_const (complete_lattice (complete_distrib_lattice empty)) unsigned) : @is_atomistic.{0} (complete_distrib_lattice.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (complete_distrib_lattice.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_44318 (h0 : add_group (has_nndist pos)) : is_add_cyclic (has_nndist pos) := sorry --non-trivial
lemma new_lemma_44319 (h0 : topological_space (has_norm (has_top to_additive.value_type))) : totally_separated_space (has_norm (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_44320 (h0 : topological_space (ring (boolean_algebra pos))) : totally_disconnected_space (ring (boolean_algebra pos)) := sorry --non-trivial
lemma new_lemma_44321 (h1 : ring (normed_field string.iterator_imp)) : rank_condition (normed_field string.iterator_imp) := sorry --non-trivial
lemma new_lemma_44322 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (with_one.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (with_one.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_44323 (h0 : group (ring (has_add pos))) : is_simple_group (ring (has_add pos)) := sorry --non-trivial
lemma new_lemma_44324 (h0 : group (has_nndist (boolean_algebra.core name))) : is_cyclic (has_nndist (boolean_algebra.core name)) := sorry --non-trivial
lemma new_lemma_44325 (h0 : semiring (add_right_cancel_monoid unsigned)) : is_noetherian_ring (add_right_cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_44326 (h0 : group (linear_ordered_semiring (has_norm empty))) : group.fg (linear_ordered_semiring (has_norm empty)) := sorry --non-trivial
lemma new_lemma_44327 (h0 : semiring (add_comm_monoid (ring linarith.comp))) : is_noetherian_ring (add_comm_monoid (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_44328 (h0 : function.extfun Type uniform_space) : @separated_space.{0} string_imp (@function.extfun_app.{2 1} Type uniform_space.{0} h0 string_imp)  := sorry --non-trivial
lemma new_lemma_44329 (h0 : topological_space (ordered_comm_monoid (has_pos_part (has_Inf linarith.comp)))) : preirreducible_space (ordered_comm_monoid (has_pos_part (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_44330 (h0 : topological_space (comm_ring (has_ssubset (has_ssubset (has_ssubset to_additive.value_type))))) : locally_compact_space (comm_ring (has_ssubset (has_ssubset (has_ssubset to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_44331 (h0 : uniform_space (uniform_space (mul_one_class linarith.ineq))) : complete_space (uniform_space (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_44332 (h0 : topological_space (simple_graph (has_add (ring (ordered_comm_monoid linarith.comp))))) : loc_path_connected_space (simple_graph (has_add (ring (ordered_comm_monoid linarith.comp)))) := sorry --non-trivial
lemma new_lemma_44333 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @is_cyclic.{1} (boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (group.{1} (boolean_algebra.{1} Type)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_44334 (h0 : not (function.extfun Type topological_space -> false)) : @irreducible_space.{0} congr_arg_kind (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_44335 (h0 : simple_graph char) (h1 : char) (h2 : sym2 char) : simple_graph.incidence_set h0 h1 h2 := sorry --non-trivial
lemma new_lemma_44336 (h0 : ring (mul_zero_class (has_add (normed_comm_ring unsigned)))) : is_principal_ideal_ring (mul_zero_class (has_add (normed_comm_ring unsigned))) := sorry --non-trivial
lemma new_lemma_44337 (h0 : group (semigroup (has_add linarith.comp))) : is_simple_group (semigroup (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_44338 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (normed_lattice_add_comm_group.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (normed_lattice_add_comm_group.{0} name))  := sorry --non-trivial
lemma new_lemma_44339 (h0 : topological_space (linear_ordered_comm_ring unsigned)) (h1 : function.extfun (linear_ordered_comm_ring unsigned) (fun (x : linear_ordered_comm_ring unsigned), Prop)) : is_totally_separated (function.extfun_app h1) := sorry --non-trivial
lemma new_lemma_44340 (h0 : not (complete_lattice (linear_ordered_add_comm_group linarith.comp_source) -> false)) : @is_compactly_generated.{0} (linear_ordered_add_comm_group.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (complete_lattice.{0} (linear_ordered_add_comm_group.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_44341 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (has_Sup.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} h0 (has_Sup.{0} empty))  := sorry --non-trivial
lemma new_lemma_44342 (h0 : ring (with_one empty)) : is_domain (with_one empty) := sorry --non-trivial
lemma new_lemma_44343 (h0 : fin has_zero.zero) : @locally_compact_space.{1} (canonically_ordered_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@matrix.vec_empty.{2} (function.extfun.{3 2} (Type 1) topological_space.{1}) h0) (canonically_ordered_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_44344 (h0 : group (has_nndist (finset linarith.comp))) : normalizer_condition (has_nndist (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_44345 (h0 : monoid (with_bot (semiring unsigned))) : monoid.fg (with_bot (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_44346 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (boolean_algebra.core.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (boolean_algebra.core.{0} name))  := sorry --non-trivial
lemma new_lemma_44347 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_norm.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_norm.{0} empty))  := sorry --non-trivial
lemma new_lemma_44348 (h0 : complete_lattice (comm_ring real)) : is_compactly_generated (comm_ring real) := sorry --non-trivial
lemma new_lemma_44349 (h0 : fin has_zero.zero) : @is_add_cyclic.{0} (has_add.{0} pos) (@matrix.vec_empty.{0} (add_group.{0} (has_add.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_44350 (h0 : uniform_space (left_cancel_semigroup congr_arg_kind)) : separated_space (left_cancel_semigroup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_44351 (h0 : functor.add_const (topological_space (has_edist unsigned)) empty) : @totally_disconnected_space.{0} (has_edist.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_edist.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_44352 (h0 : functor.add_const (group (has_neg Type)) name) : @normalizer_condition.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (has_neg.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_44353 (h0 : ring (semiring (random_gen (has_top num)))) : strong_rank_condition (semiring (random_gen (has_top num))) := sorry --non-trivial
lemma new_lemma_44354 (h0 : complete_lattice (complete_linear_order (semiring (semiring unsigned)))) : complete_lattice.is_Sup_finite_compact (complete_linear_order (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_44355 (h0 : not (group (semiring num) -> false)) : @normalizer_condition.{0} (semiring.{0} num) (@classical.by_contradiction'.{1} (group.{0} (semiring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_44356 (h0 : topological_space (measure_theory.measure_space num)) : discrete_topology (measure_theory.measure_space num) := sorry --non-trivial
lemma new_lemma_44357 (h0 : prod (has_star (semiring (semiring unsigned))) (has_star (semiring (semiring unsigned)))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_44358 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (add_left_cancel_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (add_left_cancel_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_44359 (h0 : topological_space (has_add (option (cancel_monoid (ring pos))))) : t1_space (has_add (option (cancel_monoid (ring pos)))) := sorry --non-trivial
lemma new_lemma_44360 (h0 : function.extfun Type complete_lattice) : is_compactly_generated (topological_space fun_info) := sorry --non-trivial
lemma new_lemma_44361 (h0 : uniform_space (has_to_string (boolean_algebra linarith.comp))) : separated_space (has_to_string (boolean_algebra linarith.comp)) := sorry --non-trivial
lemma new_lemma_44362 (h0 : topological_space (has_neg_part (pseudo_metric_space pos))) : discrete_topology (has_neg_part (pseudo_metric_space pos)) := sorry --non-trivial
lemma new_lemma_44363 (h0 : filter (distrib_lattice (random_gen to_additive.value_type))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_44364 (h0 : functor.add_const (topological_space (ring name)) linarith.comp) : @path_connected_space.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_44365 (h0 : topological_space (has_neg linarith.comp)) : topological_space.separable_space (has_neg linarith.comp) := sorry --non-trivial
lemma new_lemma_44366 (h0 : ring (has_nnnorm std_gen)) : strong_rank_condition (has_nnnorm std_gen) := sorry --non-trivial
lemma new_lemma_44367 (h0 : topological_space (canonically_ordered_comm_semiring (cancel_monoid pos))) : normal_space (canonically_ordered_comm_semiring (cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_44368 (h0 : functor.comp topological_space has_zero unsigned) : @normal_space.{0} (has_zero.{0} unsigned) (@functor.comp.run.{0 0 0} topological_space.{0} has_zero.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_44369 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} linarith.comp_source (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 ring.{0}) linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_44370 (h0 : group (complete_linear_order (semiring (semiring (semiring empty))))) : is_cyclic (complete_linear_order (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_44371 (h0 : functor.add_const (complete_lattice (comm_group name)) name) : @is_compactly_generated.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (comm_group.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_44372 (h2 : uniform_space linarith.comp_source) : complete_space linarith.comp_source := sorry --non-trivial
lemma new_lemma_44373 (h0 : group (boolean_algebra (mul_one_class (has_Inf Type)))) : is_cyclic (boolean_algebra (mul_one_class (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_44374 (h0 : functor.add_const (uniform_space (has_Inf pos)) linarith.comp) : @complete_space.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_Inf.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_44375 (h0 : functor.add_const (topological_space (cancel_monoid name)) pos) : @totally_disconnected_space.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_44376 (h0 : ring (partial_order (semiring (is_R_or_C congr_arg_kind)))) : rank_condition (partial_order (semiring (is_R_or_C congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_44377 (h0 : topological_space (has_norm (random_gen (random_gen to_additive.value_type)))) : t0_space (has_norm (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_44378 (h0 : functor.add_const (topological_space (has_Inf Type)) pos) : @normal_space.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_Inf.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_44379 (h0 : filter (has_top (semiring (has_one linarith.comp)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_44380 (h0 : topological_space (has_to_string (finset pos))) : preconnected_space (has_to_string (finset pos)) := sorry --non-trivial
lemma new_lemma_44381 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (has_top.{0} linarith.ineq) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_top.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_44382 (h0 : ring (has_star (semiring congr_arg_kind))) : rank_condition (has_star (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_44383 (h0 : filter (has_neg_part (has_neg_part Type))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_44384 (h0 : functor.add_const (ordered_comm_monoid (has_Inf pos)) (ordered_ring (pseudo_metric_space name))) : @has_exists_mul_of_le.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_Inf.{0} pos)) (ordered_ring.{0} (pseudo_metric_space.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_44385 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (ordered_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (ordered_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_44386 (h0 : not (complete_lattice (simple_graph reducibility_hints) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (simple_graph.{0} reducibility_hints) (@classical.by_contradiction'.{1} (complete_lattice.{0} (simple_graph.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_44387 (h0 : complete_lattice (semi_normed_comm_ring (has_ssubset reducibility_hints))) : is_compactly_generated (semi_normed_comm_ring (has_ssubset reducibility_hints)) := sorry --non-trivial
lemma new_lemma_44388 (h0 : functor.add_const (topological_space (option empty)) congr_arg_kind) : @topological_space.separable_space.{0} (option.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_44389 (h0 : functor.add_const (topological_space (ring name)) name) : @preirreducible_space.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_44390 (h0 : functor.add_const (ring (canonically_ordered_monoid pos)) linarith.comp) : @is_principal_ideal_ring.{0} (canonically_ordered_monoid.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (canonically_ordered_monoid.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_44391 (h0 : ring (has_lt char)) : strong_rank_condition (has_lt char) := sorry --non-trivial
lemma new_lemma_44392 (h0 : ring (normed_comm_ring (add_comm_monoid environment.implicit_infer_kind))) : rank_condition (normed_comm_ring (add_comm_monoid environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_44393 (h0 : filter (has_to_string (semigroup name))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_44394 (h1 : topological_space (distrib_lattice (has_nnnorm char))) : path_connected_space (distrib_lattice (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_44395 (h0 : list (simple_graph (canonically_ordered_comm_semiring name))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_44396 (h0 : set (add_comm_semigroup ereal -> add_comm_semigroup ereal)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_44397 (h0 : function.extfun Type (functor.add_const (topological_space (boolean_algebra linarith.comp)))) : @t0_space.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} linarith.comp)) linarith.comp (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (boolean_algebra.{0} linarith.comp))) h0 linarith.comp))  := sorry --non-trivial
lemma new_lemma_44398 (h0 : topological_space (comm_ring (has_nnnorm fun_info))) : t0_space (comm_ring (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_44399 (h1 : filter name) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_44400 (h0 : topological_space (is_R_or_C num)) : preirreducible_space (is_R_or_C num) := sorry --non-trivial
lemma new_lemma_44401 (h0 : topological_space (normed_group (semiring (semiring (semiring num))))) : locally_compact_space (normed_group (semiring (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_44402 (h0 : topological_space (linear_ordered_add_comm_group (random_gen to_additive.value_type))) : path_connected_space (linear_ordered_add_comm_group (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_44403 (h0 : topological_space (has_bot (has_add (has_Inf linarith.comp)))) : totally_separated_space (has_bot (has_add (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_44404 (h0 : ring (left_cancel_monoid (semiring unsigned))) : strong_rank_condition (left_cancel_monoid (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_44405 (h0 : topological_space (add_cancel_monoid (option (option pos)))) : normal_space (add_cancel_monoid (option (option pos))) := sorry --non-trivial
lemma new_lemma_44406 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (normed_comm_ring.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (normed_comm_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_44407 (h0 : topological_space (option (semiring empty))) : preirreducible_space (option (semiring empty)) := sorry --non-trivial
lemma new_lemma_44408 (h0 : functor.add_const (group linarith.comp) (has_Inf linarith.comp)) : @group.fg.{0} linarith.comp (@functor.add_const.run.{0 0} (group.{0} linarith.comp) (has_Inf.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_44409 (h0 : complete_lattice (ordered_comm_group (option (option empty)))) : is_compactly_generated (ordered_comm_group (option (option empty))) := sorry --non-trivial
lemma new_lemma_44410 (h0 : fin has_zero.zero) : @locally_compact_space.{0} (normed_lattice_add_comm_group.{0} name) (@matrix.vec_empty.{0} (topological_space.{0} (normed_lattice_add_comm_group.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_44411 (h0 : functor.add_const (functor.add_const Prop unsigned) unsigned) : functor.add_const.run (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_44412 (h1 : preorder char) (h2 : set char) : set.is_pwo h2 := sorry --non-trivial
lemma new_lemma_44413 (h0 : group (canonically_linear_ordered_monoid ennreal)) : is_simple_group (canonically_linear_ordered_monoid ennreal) := sorry --non-trivial
lemma new_lemma_44414 (h0 : topological_space (linear_ordered_comm_ring (semiring num))) : discrete_topology (linear_ordered_comm_ring (semiring num)) := sorry --non-trivial
lemma new_lemma_44415 (h0 : group (add_left_cancel_semigroup unsigned)) : is_cyclic (add_left_cancel_semigroup unsigned) := sorry --non-trivial
lemma new_lemma_44416 (h0 : ring (ordered_comm_ring (has_add (has_Inf linarith.comp)))) : is_domain (ordered_comm_ring (has_add (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_44417 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (monoid_with_zero.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (monoid_with_zero.{0} empty))  := sorry --non-trivial
lemma new_lemma_44418 (h0 : topological_space (boolean_algebra.core (has_add Type))) : preirreducible_space (boolean_algebra.core (has_add Type)) := sorry --non-trivial
lemma new_lemma_44419 (h0 : has_mem.mem (semiring linarith.comp) has_emptyc.emptyc) : @path_connected_space.{0} (semiring.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (semiring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_44420 (h0 : ordered_comm_monoid (add_cancel_monoid (option (option name)))) : has_exists_mul_of_le (add_cancel_monoid (option (option name))) := sorry --non-trivial
lemma new_lemma_44421 (h0 : functor.add_const (topological_space (has_pos_part linarith.comp)) linarith.comp) : @discrete_topology.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_44422 (h0 : topological_space (has_norm unsigned)) : totally_disconnected_space (has_norm unsigned) := sorry --non-trivial
lemma new_lemma_44423 (h0 : topological_space (semigroup (boolean_algebra.core environment.implicit_infer_kind))) : totally_separated_space (semigroup (boolean_algebra.core environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_44424 (h0 : functor.add_const (ordered_add_comm_monoid (has_add name)) (has_neg (has_neg (has_Inf Type)))) : @archimedean.{0} (has_add.{0} name) (@functor.add_const.run.{0 1} (ordered_add_comm_monoid.{0} (has_add.{0} name)) (has_neg.{1} (has_neg.{1} (has_Inf.{1} Type))) h0)  := sorry --non-trivial
lemma new_lemma_44425 (h0 : topological_space (comm_semigroup (has_bot (has_pos_part pos)))) : preirreducible_space (comm_semigroup (has_bot (has_pos_part pos))) := sorry --non-trivial
lemma new_lemma_44426 (h0 : not (function.extfun Type group -> false)) : @normalizer_condition.{0} (with_one.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (with_one.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_44427 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_top.{0} string_imp) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_top.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_44428 (h0 : functor.add_const (add_group (normed_comm_ring name)) environment.implicit_infer_kind) : @is_add_cyclic.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (add_group.{0} (normed_comm_ring.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_44429 (h0 : functor.add_const (function.extfun Type ordered_add_comm_monoid) num) : @archimedean.{0} (simple_graph.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_add_comm_monoid.{0}) num h0) (simple_graph.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_44430 (h0 : filter (add_cancel_monoid (semiring unsigned))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_44431 (h0 : monoid (measurable_equiv ennreal (sum nnreal unit))) (h1 : conj_classes (measurable_equiv ennreal (sum nnreal unit))) : conj_classes.carrier h1 ennreal.ennreal_equiv_sum := sorry --non-trivial
lemma new_lemma_44432 (h0 : topological_space (finset (option (option pos)))) : regular_space (finset (option (option pos))) := sorry --non-trivial
lemma new_lemma_44433 (h0 : group (ordered_comm_group (option (semiring empty)))) : normalizer_condition (ordered_comm_group (option (semiring empty))) := sorry --non-trivial
lemma new_lemma_44434 (h0 : ring (sub_neg_monoid (boolean_algebra (has_add Type)))) : is_principal_ideal_ring (sub_neg_monoid (boolean_algebra (has_add Type))) := sorry --non-trivial
lemma new_lemma_44435 (h0 : topological_space (measurable_space.dynkin_system (has_norm linarith.comp))) : t0_space (measurable_space.dynkin_system (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_44436 (h0 : not (has_mem.mem add_group has_emptyc.emptyc -> false)) : @is_add_cyclic.{0} num (@function.extfun_app.{2 1} Type add_group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) add_group.{0} (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) add_group.{0} (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type)))) h0)) num)  := sorry --non-trivial
lemma new_lemma_44437 (h0 : ordered_comm_monoid (boolean_algebra (finset pos))) : has_exists_mul_of_le (boolean_algebra (finset pos)) := sorry --non-trivial
lemma new_lemma_44438 (h0 : uniform_space (has_nndist empty)) : complete_space (has_nndist empty) := sorry --non-trivial
lemma new_lemma_44439 (h0 : functor.add_const (cancel_comm_monoid_with_zero (bin_tree num)) empty) : @unique_factorization_monoid.{0} (bin_tree.{0} num) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (bin_tree.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_44440 (h0 : finset (add_comm_monoid real)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_44441 (h0 : filter (semiring (ordered_cancel_add_comm_monoid empty))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_44442 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @sequential_space.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_44443 (h0 : functor.add_const (function.extfun Type ring) linarith.comp) : @rank_condition.{0} linarith.comp (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) linarith.comp h0) linarith.comp)  := sorry --non-trivial
lemma new_lemma_44444 (h0 : topological_space (cancel_monoid (has_add pos))) : irreducible_space (cancel_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_44445 (h0 : functor.add_const (complete_lattice (canonically_ordered_comm_semiring pos)) Type) : @is_atomistic.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.add_const.run.{0 1} (complete_lattice.{0} (canonically_ordered_comm_semiring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_44446 (h0 : cancel_comm_monoid_with_zero (ordered_ring unsigned)) : unique_factorization_monoid (ordered_ring unsigned) := sorry --non-trivial
lemma new_lemma_44447 (h0 : function.extfun (Type 1) group) : @normalizer_condition.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} h0 (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_44448 (h0 : topological_space (has_add fun_info)) : path_connected_space (has_add fun_info) := sorry --non-trivial
lemma new_lemma_44449 (h0 : topological_space (measurable_space (has_top (has_norm linarith.comp_source)))) : totally_separated_space (measurable_space (has_top (has_norm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_44450 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_44451 (h0 : functor.add_const (topological_space (partial_order unsigned)) unsigned) : @irreducible_space.{0} (partial_order.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (partial_order.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_44452 (h0 : topological_space (has_neg_part Type)) : path_connected_space (has_neg_part Type) := sorry --non-trivial
lemma new_lemma_44453 (h1 : group (add_monoid to_additive.value_type)) : is_cyclic (add_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_44454 (h0 : cancel_comm_monoid_with_zero (canonically_ordered_comm_semiring empty)) : unique_factorization_monoid (canonically_ordered_comm_semiring empty) := sorry --non-trivial
lemma new_lemma_44455 (h0 : functor.add_const (topological_space (comm_group linarith.comp)) environment.implicit_infer_kind) : @locally_compact_space.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_44456 (h0 : functor.add_const (cancel_comm_monoid_with_zero (ring Type)) (comm_group (has_add pos))) : @unique_factorization_monoid.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (cancel_comm_monoid_with_zero.{1} (ring.{1} Type)) (comm_group.{0} (has_add.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_44457 (h0 : function.extfun Type topological_space) : t1_space ennreal := sorry --non-trivial
lemma new_lemma_44458 (h0 : topological_space (has_bot (option empty))) : path_connected_space (has_bot (option empty)) := sorry --non-trivial
lemma new_lemma_44459 (h0 : filter (has_to_string Type)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_44460 (h0 : group (bin_tree (semiring empty))) : group.fg (bin_tree (semiring empty)) := sorry --non-trivial
lemma new_lemma_44461 (h0 : topological_space (linear_ordered_field unsigned)) : regular_space (linear_ordered_field unsigned) := sorry --non-trivial
lemma new_lemma_44462 (h0 : topological_space (distrib fun_info)) (h1 : preorder (distrib fun_info)) : order_topology (distrib fun_info) := sorry --non-trivial
lemma new_lemma_44463 (h0 : monoid (metric_space num)) : monoid.fg (metric_space num) := sorry --non-trivial
lemma new_lemma_44464 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_44465 (h0 : group (with_bot fun_info)) : group.fg (with_bot fun_info) := sorry --non-trivial
lemma new_lemma_44466 (h2 h3 : multiset (add_comm_semigroup fun_info)) : multiset.disjoint h2 h3 := sorry --non-trivial
lemma new_lemma_44467 (h0 : topological_space (has_pos_part (has_inv (random_gen linarith.comp_source)))) : totally_separated_space (has_pos_part (has_inv (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_44468 (h0 : topological_space (dlist (denumerable linarith.ineq))) : t0_space (dlist (denumerable linarith.ineq)) := sorry --non-trivial
lemma new_lemma_44469 (h0 : uniform_space (semigroup (finset (has_pos_part Type)))) : separated_space (semigroup (finset (has_pos_part Type))) := sorry --non-trivial
lemma new_lemma_44470 (h0 : functor.add_const (group (comm_group name)) unsigned) : @normalizer_condition.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (group.{0} (comm_group.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_44471 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_44472 (h0 : topological_space (sub_neg_monoid linarith.comp)) : loc_path_connected_space (sub_neg_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_44473 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (has_bot congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_44474 (h1 : topological_space (has_ssubset string_imp)) : totally_disconnected_space (has_ssubset string_imp) := sorry --non-trivial
lemma new_lemma_44475 (h0 : topological_space (bin_tree (semiring (semiring (semiring (semiring empty)))))) : preirreducible_space (bin_tree (semiring (semiring (semiring (semiring empty))))) := sorry --non-trivial
lemma new_lemma_44476 (h0 : ring (has_top (random_gen (random_gen linarith.comp_source)))) : rank_condition (has_top (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_44477 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_nndist.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_nndist.{0} num))  := sorry --non-trivial
lemma new_lemma_44478 (h0 : group (add_right_cancel_monoid unsigned)) : normalizer_condition (add_right_cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_44479 (h0 : functor.add_const (group (normed_comm_ring Type)) environment.implicit_infer_kind) : @is_simple_group.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (normed_comm_ring.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_44480 (h0 : uniform_space (add_cancel_monoid (has_pos_part environment.implicit_infer_kind))) : complete_space (add_cancel_monoid (has_pos_part environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_44481 (h1 : add_group (random_gen fun_info)) : is_add_cyclic (random_gen fun_info) := sorry --non-trivial
lemma new_lemma_44482 (h0 : list (has_add linarith.comp)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_44483 (h1 : filter (with_zero fun_info)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_44484 (h0 : filter (normed_comm_ring name)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_44485 (h0 : function.extfun Type (functor.add_const (list (normed_linear_ordered_group empty)))) : palindrome (functor.add_const.run (function.extfun_app h0 num)) := sorry --non-trivial
lemma new_lemma_44486 (h0 : functor.add_const (uniform_space (has_nndist linarith.comp)) pos) : @separated_space.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_nndist.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_44487 (h0 : functor.comp topological_space add_comm_monoid environment.implicit_infer_kind) : @sequential_space.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} add_comm_monoid.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_44488 (h1 : uniform_space (with_bot (random_gen linarith.ineq))) : complete_space (with_bot (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_44489 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (has_union.{0} linarith.comp) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (has_union.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_44490 (h0 : complete_lattice (ordered_cancel_add_comm_monoid empty)) : is_atomistic (ordered_cancel_add_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_44491 (h0 : functor.add_const (function.extfun Type complete_lattice) environment.implicit_infer_kind) : @complete_lattice.is_Sup_finite_compact.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) environment.implicit_infer_kind h0) (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_44492 (h0 : uniform_space (simple_graph (has_add (boolean_algebra.core linarith.comp)))) : separated_space (simple_graph (has_add (boolean_algebra.core linarith.comp))) := sorry --non-trivial
lemma new_lemma_44493 (h1 : function.extfun Type topological_space) : @irreducible_space.{0} (semiring.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (semiring.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_44494 (h0 : functor.add_const (complete_lattice (has_add name)) linarith.comp) : @is_compactly_generated.{0} (has_add.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_add.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_44495 (h1 : complete_lattice (add_comm_semigroup std_gen)) : complete_lattice.is_Sup_finite_compact (add_comm_semigroup std_gen) := sorry --non-trivial
lemma new_lemma_44496 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (bin_tree.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (bin_tree.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_44497 (h0 : add_monoid (linear_ordered_comm_ring unsigned)) : add_monoid.fg (linear_ordered_comm_ring unsigned) := sorry --non-trivial
lemma new_lemma_44498 (h0 : topological_space (has_to_string (has_to_string environment.implicit_infer_kind))) : loc_path_connected_space (has_to_string (has_to_string environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_44499 (h0 : ring (denumerable (has_nnnorm char))) : rank_condition (denumerable (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_44500 (h0 : functor.comp add_group complete_semilattice_Sup unsigned) : @is_add_cyclic.{0} (complete_semilattice_Sup.{0} unsigned) (@functor.comp.run.{0 0 0} add_group.{0} complete_semilattice_Sup.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_44501 (h0 : functor.add_const (topological_space (has_zero name)) linarith.comp) : @topological_space.separable_space.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_44502 (h0 : uniform_space (add_cancel_monoid (has_add unsigned))) : separated_space (add_cancel_monoid (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_44503 (h0 : function.extfun Type ring) : @rank_condition.{0} (complete_semilattice_Sup.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (complete_semilattice_Sup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_44504 (h0 : functor.add_const (ring (partial_order num)) num) : @is_domain.{0} (partial_order.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (partial_order.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_44505 (h0 : function.extfun Type (functor.add_const (ring (linear_order unsigned)))) : @rank_condition.{0} (linear_order.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (linear_order.{0} unsigned)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} (linear_order.{0} unsigned))) h0 empty))  := sorry --non-trivial
lemma new_lemma_44506 (h1 : has_lt (simple_graph (normed_field string_imp))) : no_max_order (simple_graph (normed_field string_imp)) := sorry --non-trivial
lemma new_lemma_44507 (h0 : group (measure_theory.measure_space (semiring congr_arg_kind))) : is_cyclic (measure_theory.measure_space (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_44508 (h0 : topological_space (has_neg (has_Inf linarith.comp))) : normal_space (has_neg (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_44509 (h0 : not (ring (add_cancel_comm_monoid string.iterator_imp) -> false)) : @strong_rank_condition.{0} (add_cancel_comm_monoid.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (ring.{0} (add_cancel_comm_monoid.{0} string.iterator_imp)) h0)  := sorry --non-trivial
lemma new_lemma_44510 (h0 : measurable_space char) (h2 : Prop) : measurable_set (id (fun (h1 : char), h2)) := sorry --non-trivial
lemma new_lemma_44511 (h0 : topological_space (preorder congr_arg_kind)) : locally_compact_space (preorder congr_arg_kind) := sorry --non-trivial
lemma new_lemma_44512 (h0 : functor.add_const (ring (finset linarith.comp)) (ring environment.implicit_infer_kind)) : @rank_condition.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (finset.{0} linarith.comp)) (ring.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_44513 (h0 : not (topological_space (plift unsigned) -> false)) : @totally_disconnected_space.{1} (plift.{1} unsigned) (@classical.by_contradiction'.{2} (topological_space.{1} (plift.{1} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_44514 (h1 : function.extfun Type topological_space) : @locally_compact_space.{0} (fintype.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (fintype.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_44515 (h1 : ring (denumerable (has_ssubset (has_nnnorm fun_info)))) : is_domain (denumerable (has_ssubset (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_44516 (h0 : complete_lattice (comm_semigroup real)) : is_compactly_generated (comm_semigroup real) := sorry --non-trivial
lemma new_lemma_44517 (h0 : functor.add_const (filter (cancel_monoid ennreal)) pos) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_44518 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (has_bot.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_bot.{0} name))  := sorry --non-trivial
lemma new_lemma_44519 (h0 : functor.add_const (topological_space (free_add_monoid unsigned)) unsigned) : @discrete_topology.{0} (free_add_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_44520 (h0 : functor.add_const (uniform_space (generalized_boolean_algebra linarith.comp)) (finset pos)) : @complete_space.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (generalized_boolean_algebra.{0} linarith.comp)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_44521 (h0 : add_monoid (add_comm_monoid (has_neg real))) : add_monoid.fg (add_comm_monoid (has_neg real)) := sorry --non-trivial
lemma new_lemma_44522 (h0 : uniform_space (has_compl (mul_one_class fun_info))) : complete_space (has_compl (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_44523 (h0 : topological_space (dlist (has_nnnorm linarith.comp_source))) : path_connected_space (dlist (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_44524 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (has_to_string.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_to_string.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_44525 (h0 : functor.add_const (ring (ordered_ring num)) unsigned) : @is_domain.{0} (ordered_ring.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (ordered_ring.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_44526 (h0 : topological_space (ordered_comm_monoid (has_Inf Type))) : normal_space (ordered_comm_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_44527 (h0 : topological_space (left_cancel_semigroup (semiring congr_arg_kind))) : t1_space (left_cancel_semigroup (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_44528 (h0 : add_monoid (complete_distrib_lattice name)) : add_monoid.fg (complete_distrib_lattice name) := sorry --non-trivial
lemma new_lemma_44529 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (has_add.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_add.{0} name))  := sorry --non-trivial
lemma new_lemma_44530 (h0 : ring (has_nnnorm char)) (h1 : group (has_ssubset (random_gen (ring_topology (has_nnnorm char))))) : is_cyclic (has_ssubset (random_gen (ring_topology (has_nnnorm char)))) := sorry --non-trivial
lemma new_lemma_44531 (h0 : metric_space (add_right_cancel_monoid unsigned) -> metric_space (add_right_cancel_monoid unsigned) -> Prop) : is_refl (metric_space (add_right_cancel_monoid unsigned)) h0 := sorry --non-trivial
lemma new_lemma_44532 (h0 : ordered_comm_monoid (has_nndist (option (option unsigned)))) : has_exists_mul_of_le (has_nndist (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_44533 (h0 : complete_lattice (canonically_linear_ordered_monoid (has_Inf real))) : is_compactly_generated (canonically_linear_ordered_monoid (has_Inf real)) := sorry --non-trivial
lemma new_lemma_44534 (h0 : group (uniform_space (has_nnnorm char))) : is_cyclic (uniform_space (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_44535 (h0 : functor.add_const (ordered_comm_monoid (has_add unsigned)) pos) : @has_exists_mul_of_le.{0} (has_add.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_add.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_44536 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (monoid ennreal)) := sorry --non-trivial
lemma new_lemma_44537 (h1 : function.extfun Type ring) : @rank_condition.{0} (has_ssubset.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} h1 (has_ssubset.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_44538 (h0 : cancel_comm_monoid_with_zero (has_neg_part (semigroup Type))) : unique_factorization_monoid (has_neg_part (semigroup Type)) := sorry --non-trivial
lemma new_lemma_44539 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (filter.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (filter.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_44540 (h0 : functor.add_const (topological_space (boolean_algebra pos)) (comm_group name)) : @totally_disconnected_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} pos)) (comm_group.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_44541 (h2 : ring (topological_space to_additive.value_type)) : is_domain (topological_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_44542 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} num (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) num)  := sorry --non-trivial
lemma new_lemma_44543 (h0 : group (finset congr_arg_kind)) : normalizer_condition (finset congr_arg_kind) := sorry --non-trivial
lemma new_lemma_44544 (h0 : topological_space (add_cancel_monoid (finset Type))) : discrete_topology (add_cancel_monoid (finset Type)) := sorry --non-trivial
lemma new_lemma_44545 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (distrib_lattice.{0} string_imp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (distrib_lattice.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_44546 (h0 : functor.add_const (topological_space (has_nndist unsigned)) environment.implicit_infer_kind) : @discrete_topology.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_44547 (h0 : list (complete_distrib_lattice (has_Inf (ring Type)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_44548 (h1 : topological_space (random_gen (denumerable to_additive.value_type))) : t0_space (random_gen (denumerable to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_44549 (h0 : functor.add_const (topological_space (has_add Type)) linarith.comp) : @sequential_space.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_add.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_44550 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @totally_separated_space.{0} (has_norm.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (has_norm.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_44551 (h0 : functor.comp topological_space complete_distrib_lattice environment.implicit_infer_kind) : @path_connected_space.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} complete_distrib_lattice.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_44552 (h0 : add_group (random_gen (random_gen linarith.comp_source))) : is_add_cyclic (random_gen (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_44553 (h1 : topological_space (with_one to_additive.value_type)) : locally_compact_space (with_one to_additive.value_type) := sorry --non-trivial
lemma new_lemma_44554 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (canonically_linear_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_linear_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_44555 (h0 : filter (add_cancel_monoid (finset (finset linarith.comp)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_44556 (h0 : measurable_space (with_zero string_imp)) (h1 : measure_theory.measure (with_zero string_imp)) : measure_theory.has_no_atoms h1 := sorry --non-trivial
lemma new_lemma_44557 (h0 : functor.add_const (group (ordered_comm_ring pos)) pos) : @is_simple_group.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (ordered_comm_ring.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_44558 (h0 : topological_space (dlist (random_gen (random_gen string_imp)))) : t0_space (dlist (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_44559 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : monoid.fg ennreal := sorry --non-trivial
lemma new_lemma_44560 (h0 : topological_space (normed_linear_ordered_group (semiring empty))) : normal_space (normed_linear_ordered_group (semiring empty)) := sorry --non-trivial
lemma new_lemma_44561 (h0 : functor.comp topological_space complete_distrib_lattice pos) : @totally_disconnected_space.{0} (complete_distrib_lattice.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} complete_distrib_lattice.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_44562 (h0 : add_group (simple_graph (ring (ring Type)))) : is_add_cyclic (simple_graph (ring (ring Type))) := sorry --non-trivial
lemma new_lemma_44563 (h0 : group (has_to_string congr_arg_kind)) : group.fg (has_to_string congr_arg_kind) := sorry --non-trivial
lemma new_lemma_44564 (h0 : complete_lattice (has_nndist pos)) : is_compactly_generated (has_nndist pos) := sorry --non-trivial
lemma new_lemma_44565 (h0 : list (boolean_algebra (has_neg Type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_44566 (h0 : topological_space (linear_ordered_field unsigned)) : discrete_topology (linear_ordered_field unsigned) := sorry --non-trivial
lemma new_lemma_44567 (h0 : function.extfun Type ring) : @is_domain.{0} (ordered_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (ordered_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_44568 (h0 : ring (id fun_info)) : strong_rank_condition (id fun_info) := sorry --non-trivial
lemma new_lemma_44569 (h0 : functor.add_const (add_group (ring environment.implicit_infer_kind)) (has_neg environment.implicit_infer_kind)) : @is_add_cyclic.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (add_group.{0} (ring.{0} environment.implicit_infer_kind)) (has_neg.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_44570 (h0 : list (with_one (has_inv (random_gen fun_info)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_44571 (h0 : functor.comp ring comm_group unsigned) : @is_domain.{0} (comm_group.{0} unsigned) (@functor.comp.run.{0 0 0} ring.{0} comm_group.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_44572 (h0 : ordered_add_comm_monoid (finset (has_Inf (ring (has_nndist (finset Type)))))) : archimedean (finset (has_Inf (ring (has_nndist (finset Type))))) := sorry --non-trivial
lemma new_lemma_44573 (h0 : functor.add_const (topological_space (has_neg pos)) (ring pos)) : @locally_compact_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} pos)) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_44574 (h0 : has_mem.mem (semiring linarith.comp_source) has_emptyc.emptyc) : @irreducible_space.{0} (semiring.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (semiring.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_44575 (h0 : topological_space (ordered_ring (semiring empty))) : preirreducible_space (ordered_ring (semiring empty)) := sorry --non-trivial
lemma new_lemma_44576 (h0 h1 : fun_info -> fun_info) : function.commute h0 h1 := sorry --non-trivial
lemma new_lemma_44577 (h0 : group (semiring (random_gen linarith.ineq))) : is_cyclic (semiring (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_44578 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (measure_theory.measure_space.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (measure_theory.measure_space.{0} num))  := sorry --non-trivial
lemma new_lemma_44579 (h0 : group real.angle) : group.fg real.angle := sorry --non-trivial
lemma new_lemma_44580 (h0 : prod (complete_semilattice_Sup congr_arg_kind) (complete_semilattice_Sup congr_arg_kind)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_44581 (h0 : list (partial_order (semiring (semiring empty)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_44582 (h0 : list (add_comm_monoid pos)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_44583 (h0 : topological_space (ring (option empty)) -> Prop) : @topological_space.separable_space.{0} (ring.{0} (option.{0} empty)) (@classical.epsilon.{1} (topological_space.{0} (ring.{0} (option.{0} empty))) (@nonempty_of_inhabited.{1} (topological_space.{0} (ring.{0} (option.{0} empty))) (@inhabited_topological_space.{0} (ring.{0} (option.{0} empty)))) h0)  := sorry --non-trivial
lemma new_lemma_44584 (h0 : add_group (canonically_ordered_comm_semiring (mul_zero_class pos))) : is_add_cyclic (canonically_ordered_comm_semiring (mul_zero_class pos)) := sorry --non-trivial
lemma new_lemma_44585 (h0 : cancel_comm_monoid_with_zero (canonically_ordered_comm_semiring (measurable_space name))) : unique_factorization_monoid (canonically_ordered_comm_semiring (measurable_space name)) := sorry --non-trivial
lemma new_lemma_44586 (h0 : uniform_space (finset (ring linarith.comp))) : separated_space (finset (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_44587 (h0 : topological_space (left_cancel_semigroup num)) : t1_space (left_cancel_semigroup num) := sorry --non-trivial
lemma new_lemma_44588 (h1 h2 : list enat) : list.is_infix h1 h2 := sorry --non-trivial
lemma new_lemma_44589 (h0 : function.extfun Type (prod (add_left_cancel_semigroup (semiring empty)))) : id_rel (function.extfun_app h0 (add_left_cancel_semigroup (semiring empty))) := sorry --non-trivial
lemma new_lemma_44590 (h0 : fin has_zero.zero) : @is_compactly_generated.{0} (has_nndist.{0} linarith.comp) (@matrix.vec_empty.{0} (complete_lattice.{0} (has_nndist.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_44591 (h0 : functor.comp topological_space has_neg linarith.comp) : @totally_separated_space.{0} (has_neg.{0} linarith.comp) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_44592 (h0 : not (group (has_sub congr_arg_kind) -> false)) : @is_cyclic.{0} (has_sub.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (group.{0} (has_sub.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_44593 (h0 : add_group (linear_ordered_semiring (semiring (semiring (semiring (has_one congr_arg_kind)))))) : is_add_cyclic (linear_ordered_semiring (semiring (semiring (semiring (has_one congr_arg_kind))))) := sorry --non-trivial
lemma new_lemma_44594 (h0 : not (topological_space (measurable_space fun_info) -> false)) : @totally_disconnected_space.{0} (measurable_space.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (measurable_space.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_44595 (h0 : list (complete_semilattice_Sup (random_gen (has_inv linarith.comp_source)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_44596 (h0 : functor.add_const (ring (finset num)) unsigned) : @is_domain.{0} (finset.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (finset.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_44597 (h0 : list (has_pos_part (has_add (has_neg name)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_44598 (h0 : complete_lattice (has_inter (option (option ennreal)))) : is_atomistic (has_inter (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_44599 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @sequential_space.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_44600 (h0 : set (linarith.ineq -> std_gen)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_44601 (h0 : functor.add_const (group (mul_zero_class num)) num) : @is_cyclic.{0} (mul_zero_class.{0} num) (@functor.add_const.run.{0 0} (group.{0} (mul_zero_class.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_44602 (h0 : topological_space (add_cancel_monoid (finset Type))) : t1_space (add_cancel_monoid (finset Type)) := sorry --non-trivial
lemma new_lemma_44603 (h0 : complete_lattice (semigroup (option empty))) : complete_lattice.is_Sup_finite_compact (semigroup (option empty)) := sorry --non-trivial
lemma new_lemma_44604 (h0 : topological_space (semi_normed_comm_ring (has_ssubset (has_ssubset linarith.comp_source)))) : t0_space (semi_normed_comm_ring (has_ssubset (has_ssubset linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_44605 (h1 : add_group (uniform_space linarith.comp_source)) : is_add_cyclic (uniform_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_44606 (h1 : ring (distrib (has_nnnorm char))) : is_domain (distrib (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_44607 (h0 : topological_space (has_norm congr_arg_kind)) : discrete_topology (has_norm congr_arg_kind) := sorry --non-trivial
lemma new_lemma_44608 (h0 : functor.add_const (group (boolean_algebra Type)) linarith.comp) : @is_simple_group.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (boolean_algebra.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_44609 (h0 : not (function.extfun Type topological_space -> false)) : @discrete_topology.{0} (semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_44610 (h0 : ring (has_ssubset string.iterator_imp)) : strong_rank_condition (has_ssubset string.iterator_imp) := sorry --non-trivial
lemma new_lemma_44611 (h0 : filter (semigroup (comm_group unsigned))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_44612 (h0 : not (semiring (with_one empty) -> false)) : @is_noetherian_ring.{0} (with_one.{0} empty) (@classical.by_contradiction'.{1} (semiring.{0} (with_one.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_44613 (h1 : has_coe enat Prop) (h2 : enat) : @coe_b.{1 1} enat Prop h1 h2  := sorry --non-trivial
lemma new_lemma_44614 (h0 : topological_space (ordered_comm_monoid (ring Type))) : t1_space (ordered_comm_monoid (ring Type)) := sorry --non-trivial
lemma new_lemma_44615 (h2 : topological_space (normed_field (normed_field (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm char))))))) : t0_space (normed_field (normed_field (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm char)))))) := sorry --non-trivial
lemma new_lemma_44616 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (random_gen.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (random_gen.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_44617 (h0 : add_group (comm_semigroup (sub_neg_monoid real))) : is_add_cyclic (comm_semigroup (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_44618 (h0 : complete_lattice (comm_group (comm_group ennreal))) : is_atomistic (comm_group (comm_group ennreal)) := sorry --non-trivial
lemma new_lemma_44619 (h0 : topological_space (filter num)) : loc_path_connected_space (filter num) := sorry --non-trivial
lemma new_lemma_44620 (h1 : ring (non_unital_non_assoc_semiring string.iterator_imp)) : strong_rank_condition (non_unital_non_assoc_semiring string.iterator_imp) := sorry --non-trivial
lemma new_lemma_44621 (h0 : add_monoid (ordered_comm_monoid pos)) : add_monoid.fg (ordered_comm_monoid pos) := sorry --non-trivial
lemma new_lemma_44622 (h0 : uniform_space (distrib_lattice (random_gen linarith.ineq))) : complete_space (distrib_lattice (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_44623 (h0 : functor.add_const (uniform_space (add_cancel_monoid Type)) pos) : @separated_space.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (add_cancel_monoid.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_44624 (h3 : topological_space (uniform_space (mul_one_class to_additive.value_type))) : t0_space (uniform_space (mul_one_class to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_44625 (h0 : topological_space (linear_ordered_comm_ring (semiring nnreal))) : totally_separated_space (linear_ordered_comm_ring (semiring nnreal)) := sorry --non-trivial
lemma new_lemma_44626 (h0 : filter (comm_ring (has_norm (has_norm (random_gen to_additive.value_type))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_44627 (h0 : functor.add_const (topological_space (boolean_algebra environment.implicit_infer_kind)) Type) : @topological_space.separable_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_44628 (h0 : filter (linear_ordered_field (option pos))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_44629 (h0 : prod (has_neg_part pos) (has_neg_part pos)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_44630 (h0 : functor.add_const (monoid (has_to_string name)) (has_neg (has_neg Type))) : @monoid.fg.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 1} (monoid.{0} (has_to_string.{0} name)) (has_neg.{1} (has_neg.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_44631 (h0 : topological_space (random_gen (has_ssubset (has_ssubset linarith.ineq)))) : t0_space (random_gen (has_ssubset (has_ssubset linarith.ineq))) := sorry --non-trivial
lemma new_lemma_44632 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (comm_group.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_44633 (h0 : topological_space (has_bot Type)) : sequential_space (has_bot Type) := sorry --non-trivial
lemma new_lemma_44634 (h0 : list (complete_distrib_lattice (option ennreal))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_44635 (h0 : functor.add_const (group (ordered_comm_monoid pos)) name) : @is_cyclic.{0} (ordered_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (ordered_comm_monoid.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_44636 (h0 : has_mem.mem (complete_semilattice_Sup congr_arg_kind) has_emptyc.emptyc) : @normalizer_condition.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type group.{0} (complete_semilattice_Sup.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_44637 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (dlist fun_info)) := sorry --non-trivial
lemma new_lemma_44638 (h0 : function.extfun Type (functor.add_const (uniform_space (add_group num)))) : @separated_space.{0} (add_group.{0} num) (@functor.add_const.run.{0 0} (uniform_space.{0} (add_group.{0} num)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (uniform_space.{0} (add_group.{0} num))) h0 empty))  := sorry --non-trivial
lemma new_lemma_44639 (h0 : list (linear_ordered_comm_monoid_with_zero empty)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_44640 (h0 : functor.add_const (complete_lattice (normed_linear_ordered_group congr_arg_kind)) congr_arg_kind) : @complete_lattice.is_Sup_finite_compact.{0} (normed_linear_ordered_group.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (normed_linear_ordered_group.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_44641 (h0 : uniform_space (as_linear_order empty)) : separated_space (as_linear_order empty) := sorry --non-trivial
lemma new_lemma_44642 (h0 : functor.add_const (topological_space (group_with_zero num)) num) : @loc_path_connected_space.{0} (group_with_zero.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (group_with_zero.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_44643 (h0 : monoid (ring (has_to_string (has_add (add_comm_monoid Type))))) : monoid.fg (ring (has_to_string (has_add (add_comm_monoid Type)))) := sorry --non-trivial
lemma new_lemma_44644 (h0 : filter (has_add ennreal)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_44645 (h0 : add_monoid (omega_complete_partial_order (has_bot unsigned))) : add_monoid.fg (omega_complete_partial_order (has_bot unsigned)) := sorry --non-trivial
lemma new_lemma_44646 (h0 : functor.add_const (group (linear_ordered_field pos)) unsigned) : @is_simple_group.{0} (linear_ordered_field.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (linear_ordered_field.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_44647 (h0 : functor.add_const (complete_lattice (canonically_ordered_comm_semiring pos)) name) : @is_atomistic.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (canonically_ordered_comm_semiring.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_44648 (h0 : topological_space (ordered_comm_monoid (option (option empty)))) : path_connected_space (ordered_comm_monoid (option (option empty))) := sorry --non-trivial
lemma new_lemma_44649 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_comm_ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_44650 (h0 : topological_space (comm_group (has_neg environment.implicit_infer_kind))) : preirreducible_space (comm_group (has_neg environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_44651 (h0 : finset (boolean_algebra (ring (finset linarith.comp)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_44652 (h0 : topological_space (has_emptyc (random_gen fun_info))) : totally_separated_space (has_emptyc (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_44653 (h0 : functor.add_const (complete_lattice (normed_comm_ring name)) linarith.comp) : @is_compactly_generated.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (normed_comm_ring.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_44654 (h0 : uniform_space (mul_one_class std_gen)) : complete_space (mul_one_class std_gen) := sorry --non-trivial
lemma new_lemma_44655 (h0 : topological_space (sub_neg_monoid (has_Inf real))) : sequential_space (sub_neg_monoid (has_Inf real)) := sorry --non-trivial
lemma new_lemma_44656 (h0 : ordered_comm_monoid (add_comm_monoid (ordered_comm_monoid name))) : has_exists_mul_of_le (add_comm_monoid (ordered_comm_monoid name)) := sorry --non-trivial
lemma new_lemma_44657 (h0 : topological_space (has_compl (comm_ring string_imp))) : t0_space (has_compl (comm_ring string_imp)) := sorry --non-trivial
lemma new_lemma_44658 (h0 : ring (ordered_comm_monoid fun_info)) : rank_condition (ordered_comm_monoid fun_info) := sorry --non-trivial
lemma new_lemma_44659 (h0 : topological_space (has_nndist (complete_distrib_lattice Type))) : totally_separated_space (has_nndist (complete_distrib_lattice Type)) := sorry --non-trivial
lemma new_lemma_44660 (h2 : ring ereal) : rank_condition ereal := sorry --non-trivial
lemma new_lemma_44661 (h0 : ring (has_compl (has_ssubset (has_nnnorm string_imp)))) : is_domain (has_compl (has_ssubset (has_nnnorm string_imp))) := sorry --non-trivial
lemma new_lemma_44662 (h0 : function.extfun Type group) : @group.fg.{0} (ordered_cancel_add_comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (ordered_cancel_add_comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_44663 (h0 : not (uniform_space (complete_semilattice_Sup unsigned) -> false)) : @separated_space.{0} (complete_semilattice_Sup.{0} unsigned) (@classical.by_contradiction'.{1} (uniform_space.{0} (complete_semilattice_Sup.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_44664 (h0 : ring (add_left_cancel_monoid (has_inv linarith.comp_source))) : strong_rank_condition (add_left_cancel_monoid (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_44665 (h0 : functor.add_const (topological_space (has_nndist pos)) linarith.comp) : @preconnected_space.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_44666 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_nndist.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_44667 (h0 : functor.add_const (complete_lattice (linear_order empty)) unsigned) : @complete_lattice.is_Sup_finite_compact.{0} (linear_order.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (linear_order.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_44668 (h0 : topological_space (ring congr_arg_kind)) : locally_compact_space (ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_44669 (h0 : functor.add_const (filter (cancel_monoid unsigned)) linarith.comp) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_44670 (h0 : functor.add_const (function.extfun Type monoid) environment.implicit_infer_kind) : @monoid.fg.{0} (has_nndist.{0} linarith.comp) (@function.extfun_app.{2 1} Type monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type monoid.{0}) environment.implicit_infer_kind h0) (has_nndist.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_44671 (h0 : ring (semigroup (measurable_space unsigned))) : rank_condition (semigroup (measurable_space unsigned)) := sorry --non-trivial
lemma new_lemma_44672 (h0 : ring (has_dist (option empty))) : is_domain (has_dist (option empty)) := sorry --non-trivial
lemma new_lemma_44673 (h0 : functor.add_const (ring (comm_group linarith.comp)) linarith.comp) : @is_domain.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (comm_group.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_44674 (h0 : ring (add_group (has_top num))) : rank_condition (add_group (has_top num)) := sorry --non-trivial
lemma new_lemma_44675 (h0 : topological_space (canonically_ordered_comm_semiring environment.implicit_infer_kind)) : regular_space (canonically_ordered_comm_semiring environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_44676 (h0 : functor.comp group cancel_monoid pos) : @is_cyclic.{0} (cancel_monoid.{0} pos) (@functor.comp.run.{0 0 0} group.{0} cancel_monoid.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_44677 (h1 : topological_space (mul_one_class ereal)) : totally_disconnected_space (mul_one_class ereal) := sorry --non-trivial
lemma new_lemma_44678 (h0 : not (functor.add_const Prop (semiring empty) -> false)) : functor.add_const.run (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_44679 (h0 : topological_space (has_add (has_nndist pos))) : regular_space (has_add (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_44680 (h0 : function.extfun nat fin) : @archimedean.{1} (comm_semigroup.{1} Type) (@matrix.vec_empty.{1} (ordered_add_comm_monoid.{1} (comm_semigroup.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_44681 (h0 : topological_space (comm_semigroup (sub_neg_monoid Type))) : locally_compact_space (comm_semigroup (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_44682 (h0 : functor.add_const (topological_space (complete_distrib_lattice Type)) linarith.comp) : @irreducible_space.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (complete_distrib_lattice.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_44683 (h0 : functor.add_const (list (has_nndist name)) (option unsigned)) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_44684 (h0 : uniform_space (semigroup (add_comm_monoid Type))) : complete_space (semigroup (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_44685 (h0 : topological_space (ordered_comm_monoid (has_Inf real))) : topological_space.separable_space (ordered_comm_monoid (has_Inf real)) := sorry --non-trivial
lemma new_lemma_44686 (h0 : finset (complete_linear_order num)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_44687 (h0 : functor.add_const (topological_space (has_star num)) num) : @preirreducible_space.{0} (has_star.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_44688 (h0 : topological_space (non_assoc_semiring num)) : t0_space (non_assoc_semiring num) := sorry --non-trivial
lemma new_lemma_44689 (h0 : function.extfun Type ring) : @is_domain.{0} (@id.{2} Type congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (@id.{2} Type congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_44690 (h0 : functor.add_const (topological_space (has_nndist environment.implicit_infer_kind)) (semigroup Type)) : @loc_path_connected_space.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (has_nndist.{0} environment.implicit_infer_kind)) (semigroup.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_44691 (h0 : finset (mul_zero_class pos)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_44692 (h0 h1 : multiset fun_info) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_44693 (h0 : functor.add_const (complete_lattice name) unsigned) : @is_compactly_generated.{0} name (@functor.add_const.run.{0 0} (complete_lattice.{0} name) unsigned h0)  := sorry --non-trivial
lemma new_lemma_44694 (h0 : not (ring (normed_field reducibility_hints) -> false)) : @strong_rank_condition.{0} (normed_field.{0} reducibility_hints) (@classical.by_contradiction'.{1} (ring.{0} (normed_field.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_44695 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_star num)) congr_arg_kind) : @unique_factorization_monoid.{0} (has_star.{0} num) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_star.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_44696 (h0 : complete_lattice ereal) : is_compactly_generated ereal := sorry --non-trivial
lemma new_lemma_44697 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (add_comm_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (add_comm_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_44698 (h0 : filter (linear_ordered_semiring (random_gen num))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_44699 (h0 : function.extfun Type group) : @is_cyclic.{0} (monoid.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_44700 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (preorder.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (preorder.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_44701 (h0 : fin has_zero.zero) : @t1_space.{1} (boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (boolean_algebra.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_44702 (h0 : functor.comp topological_space canonically_ordered_comm_semiring Type) : @regular_space.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} canonically_ordered_comm_semiring.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_44703 (h0 : filter (has_nnnorm fun_info)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_44704 (h0 : uniform_space (add_comm_monoid (option pos))) : separated_space (add_comm_monoid (option pos)) := sorry --non-trivial
lemma new_lemma_44705 (h0 : topological_space (normed_comm_ring ennreal)) : discrete_topology (normed_comm_ring ennreal) := sorry --non-trivial
lemma new_lemma_44706 (h0 : group (canonically_ordered_comm_semiring congr_arg_kind)) : is_cyclic (canonically_ordered_comm_semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_44707 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_44708 (h0 : function.extfun Type topological_space) : @normal_space.{0} (bin_tree.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (bin_tree.{0} num))  := sorry --non-trivial
lemma new_lemma_44709 (h0 : cancel_comm_monoid_with_zero (add_cancel_monoid linarith.comp)) : unique_factorization_monoid (add_cancel_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_44710 (h0 : monoid (has_to_string num)) : monoid.fg (has_to_string num) := sorry --non-trivial
lemma new_lemma_44711 (h0 : group (ordered_comm_ring (ring (ring linarith.comp)))) : normalizer_condition (ordered_comm_ring (ring (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_44712 (h0 : ring (group_with_zero ennreal)) : rank_condition (group_with_zero ennreal) := sorry --non-trivial
lemma new_lemma_44713 (h0 : functor.add_const (topological_space (boolean_algebra.core Type)) name) : @loc_path_connected_space.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.core.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_44714 (h0 : multiset (linear_ordered_comm_group_with_zero string_imp)) (h1 : not (multiset (linear_ordered_comm_group_with_zero string_imp) -> false)) : multiset.disjoint h0 (classical.by_contradiction' h1) := sorry --non-trivial
lemma new_lemma_44715 (h0 : not (function.extfun Type ring -> false)) : @strong_rank_condition.{0} (measure_theory.measure_space.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (measure_theory.measure_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_44716 (h0 : topological_space (mul_zero_one_class (has_top to_additive.value_type))) : discrete_topology (mul_zero_one_class (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_44717 (h2 : topological_space (has_emptyc (random_gen congr_arg_kind))) : locally_compact_space (has_emptyc (random_gen congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_44718 (h0 : finset (has_neg_part (has_add pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_44719 (h0 : complete_lattice (distrib_lattice (random_gen linarith.comp_source))) : complete_lattice.is_Sup_finite_compact (distrib_lattice (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_44720 (h0 : function.extfun Type topological_space) : @regular_space.{0} (boolean_algebra.core.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_44721 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (has_inv.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_inv.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_44722 (h1 h2 : multiset (has_div reducibility_hints)) : multiset.disjoint h1 h2 := sorry --non-trivial
lemma new_lemma_44723 (h0 : finset (ordered_ring unsigned)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_44724 (h0 : has_vadd unsigned (ring (option unsigned))) : has_faithful_vadd unsigned (ring (option unsigned)) := sorry --non-trivial
lemma new_lemma_44725 (h0 : fin has_zero.zero) : @rank_condition.{0} (canonically_linear_ordered_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (ring.{0} (canonically_linear_ordered_monoid.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_44726 (h0 : function.extfun Type group) : @normalizer_condition.{0} (denumerable.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} h0 (denumerable.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_44727 (h0 : cancel_comm_monoid_with_zero (id empty)) : unique_factorization_monoid (id empty) := sorry --non-trivial
lemma new_lemma_44728 (h0 : not (uniform_space (has_emptyc linarith.comp_source) -> false)) : @complete_space.{0} (has_emptyc.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_emptyc.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_44729 (h0 : functor.add_const (function.extfun (Type 1) complete_lattice) Type) : @is_atomistic.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) complete_lattice.{1}) Type h0) (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_44730 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_44731 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (linear_ordered_add_comm_group.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (linear_ordered_add_comm_group.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_44732 (h0 : topological_space (semiring (semiring unsigned))) : irreducible_space (semiring (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_44733 (h0 : topological_space (normed_comm_ring (has_add (has_add (has_add pos))))) : locally_compact_space (normed_comm_ring (has_add (has_add (has_add pos)))) := sorry --non-trivial
lemma new_lemma_44734 (h0 : function.extfun nat fin) : @is_add_cyclic.{0} (ring.{0} name) (@matrix.vec_empty.{0} (add_group.{0} (ring.{0} name)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_44735 (h0 : not (complete_lattice (has_lt (random_gen char)) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_lt.{0} (random_gen.{0} char)) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_lt.{0} (random_gen.{0} char))) h0)  := sorry --non-trivial
lemma new_lemma_44736 (h0 : not (function.extfun Type topological_space -> false)) : @totally_separated_space.{0} (random_gen.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (random_gen.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_44737 (h0 : function.extfun Type (prod (semigroup ennreal))) : id_rel (function.extfun_app h0 (semigroup ennreal)) := sorry --non-trivial
lemma new_lemma_44738 (h0 : semiring (add_cancel_monoid empty)) : is_noetherian_ring (add_cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_44739 (h0 : has_mem.mem uniform_space has_emptyc.emptyc) : @complete_space.{0} (complete_semilattice_Sup.{0} fun_info) (@function.extfun_app.{2 1} Type uniform_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) uniform_space.{0} h0) (complete_semilattice_Sup.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_44740 (h0 : topological_space (has_top (has_top num))) : discrete_topology (has_top (has_top num)) := sorry --non-trivial
lemma new_lemma_44741 (h0 : ulower (list pnat)) (h1 : pnat) : pnat.coprime (list.head (ulower.up h0)) h1 := sorry --non-trivial
lemma new_lemma_44742 (h0 : function.extfun Type topological_space) : @t0_space.{0} (complete_distrib_lattice.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_44743 (h1 : filter (has_add to_additive.value_type)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_44744 (h0 : not (monoid (with_one fun_info) -> false)) : @monoid.fg.{0} (with_one.{0} fun_info) (@classical.by_contradiction'.{1} (monoid.{0} (with_one.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_44745 (h0 : ordered_add_comm_monoid (generalized_boolean_algebra (sub_neg_monoid Type))) : archimedean (generalized_boolean_algebra (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_44746 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_domain.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ring.{1}) (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_44747 (h0 : topological_space (div_inv_monoid (random_gen (random_gen linarith.ineq)))) : totally_disconnected_space (div_inv_monoid (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_44748 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (cancel_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_44749 (h1 : complete_lattice (distrib (has_nnnorm char))) : is_compactly_generated (distrib (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_44750 (h0 : functor.add_const (topological_space (ordered_comm_ring name)) pos) : @topological_space.separable_space.{0} (ordered_comm_ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_44751 (h0 : group (normed_field (has_ssubset char))) : is_cyclic (normed_field (has_ssubset char)) := sorry --non-trivial
lemma new_lemma_44752 (h0 : complete_distrib_lattice unsigned -> complete_distrib_lattice unsigned -> complete_distrib_lattice unsigned) : is_idempotent (complete_distrib_lattice unsigned) h0 := sorry --non-trivial
lemma new_lemma_44753 (h0 : has_le (normed_group num)) (h1 : normed_group num) : is_max h1 := sorry --non-trivial
lemma new_lemma_44754 (h0 : cancel_comm_monoid_with_zero (simple_graph (semigroup pos))) : unique_factorization_monoid (simple_graph (semigroup pos)) := sorry --non-trivial
lemma new_lemma_44755 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (encodable.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (encodable.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_44756 (h0 : topological_space (has_nndist name)) : regular_space (has_nndist name) := sorry --non-trivial
lemma new_lemma_44757 (h0 : option (functor.add_const (topological_space (has_add ennreal)) unsigned)) (h1 : functor.add_const (topological_space (has_add ennreal)) unsigned) : @regular_space.{0} (has_add.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} ennreal)) unsigned (@option.get_or_else.{0} (functor.add_const.{0 0} (topological_space.{0} (has_add.{0} ennreal)) unsigned) h0 h1))  := sorry --non-trivial
lemma new_lemma_44758 (h0 : topological_space (has_add unsigned)) : totally_separated_space (has_add unsigned) := sorry --non-trivial
lemma new_lemma_44759 (h1 : add_group (topological_space (has_nnnorm string_imp))) (h2 : add_subgroup (topological_space (has_nnnorm string_imp))) : add_subgroup.is_commutative h2 := sorry --non-trivial
lemma new_lemma_44760 (h0 : topological_space (comm_semigroup (comm_semigroup (sub_neg_monoid real)))) : path_connected_space (comm_semigroup (comm_semigroup (sub_neg_monoid real))) := sorry --non-trivial
lemma new_lemma_44761 (h0 : not (has_mem.mem (random_gen linarith.comp_source) has_emptyc.emptyc -> false)) : @rank_condition.{0} (random_gen.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type ring.{0} (random_gen.{0} linarith.comp_source) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} linarith.comp_source) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_44762 (h0 : functor.add_const (function.extfun Type list) environment.implicit_infer_kind) : palindrome (function.extfun_app (functor.add_const.run h0) (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_44763 (h0 : monoid (option (has_star (semiring unsigned)))) : monoid.fg (option (has_star (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_44764 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} (simple_graph.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) (simple_graph.{0} pos))  := sorry --non-trivial
lemma new_lemma_44765 (h0 : functor.add_const (ring (comm_group pos)) unsigned) : @strong_rank_condition.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (comm_group.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_44766 (h0 : functor.add_const (function.extfun Type uniform_space) linarith.comp) : @complete_space.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) linarith.comp h0) (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_44767 (h0 : function.extfun Type (functor.add_const (topological_space (linear_ordered_comm_monoid_with_zero empty)))) : @loc_path_connected_space.{0} (linear_ordered_comm_monoid_with_zero.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_comm_monoid_with_zero.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (linear_ordered_comm_monoid_with_zero.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_44768 (h0 : cancel_comm_monoid_with_zero (mul_zero_class (semiring num))) : unique_factorization_monoid (mul_zero_class (semiring num)) := sorry --non-trivial
lemma new_lemma_44769 (h0 : finset (boolean_algebra (has_pos_part (has_Inf pos)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_44770 (h0 : functor.add_const (ordered_add_comm_monoid (add_cancel_monoid pos)) unsigned) : @archimedean.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (add_cancel_monoid.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_44771 (h0 : add_monoid (linear_ordered_semiring congr_arg_kind)) : add_monoid.fg (linear_ordered_semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_44772 (h0 : functor.add_const (function.extfun (Type 1) topological_space) Type) : @totally_disconnected_space.{1} (simple_graph.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) Type h0) (simple_graph.{1} Type))  := sorry --non-trivial
lemma new_lemma_44773 (h0 : topological_space (has_ssubset (add_comm_semigroup char))) : t0_space (has_ssubset (add_comm_semigroup char)) := sorry --non-trivial
lemma new_lemma_44774 (h0 : monoid (simple_graph (ring Type))) : monoid.fg (simple_graph (ring Type)) := sorry --non-trivial
lemma new_lemma_44775 (h0 : functor.add_const (topological_space (finset name)) Type) : @path_connected_space.{0} (finset.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (finset.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_44776 (h1 : not (function.extfun Type group -> false)) : @normalizer_condition.{0} linarith.comp (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h1) linarith.comp)  := sorry --non-trivial
lemma new_lemma_44777 (h0 : functor.add_const (complete_lattice (semigroup environment.implicit_infer_kind)) environment.implicit_infer_kind) : @is_compactly_generated.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (semigroup.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_44778 (h0 : topological_space (boolean_algebra Type)) : topological_space.separable_space (boolean_algebra Type) := sorry --non-trivial
lemma new_lemma_44779 (h0 : cancel_comm_monoid_with_zero (has_inter (option unsigned))) : unique_factorization_monoid (has_inter (option unsigned)) := sorry --non-trivial
lemma new_lemma_44780 (h0 : add_group (random_gen (with_bot (random_gen (random_gen (random_gen linarith.ineq)))))) : is_add_cyclic (random_gen (with_bot (random_gen (random_gen (random_gen linarith.ineq))))) := sorry --non-trivial
lemma new_lemma_44781 (h0 : ring (linear_ordered_comm_monoid_with_zero congr_arg_kind)) : is_domain (linear_ordered_comm_monoid_with_zero congr_arg_kind) := sorry --non-trivial
lemma new_lemma_44782 (h0 : group (has_star unsigned)) : is_cyclic (has_star unsigned) := sorry --non-trivial
lemma new_lemma_44783 (h0 : ordered_add_comm_monoid (ring unsigned)) : archimedean (ring unsigned) := sorry --non-trivial
lemma new_lemma_44784 (h0 : function.extfun (finset Type) (has_mem.mem linarith.comp_source)) : @complete_lattice.is_Sup_finite_compact.{0} linarith.comp_source (@finset.pi.empty.{1 0} Type complete_lattice.{0} linarith.comp_source (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) linarith.comp_source) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_44785 (h0 : topological_space (plift (semiring empty))) : t0_space (plift (semiring empty)) := sorry --non-trivial
lemma new_lemma_44786 (h0 : functor.add_const (uniform_space (cancel_monoid environment.implicit_infer_kind)) Type) : @complete_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (uniform_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_44787 (h0 : topological_space linarith.ineq) (h1 : linarith.ineq -> set linarith.ineq) : locally_finite h1 := sorry --non-trivial
lemma new_lemma_44788 (h0 : function.extfun Type topological_space) : @normal_space.{0} (normed_group.{0} (semiring.{0} congr_arg_kind)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_group.{0} (semiring.{0} congr_arg_kind)))  := sorry --non-trivial
lemma new_lemma_44789 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (canonically_ordered_comm_semiring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_44790 (h0 : uniform_space (semiring (has_top linarith.comp))) : complete_space (semiring (has_top linarith.comp)) := sorry --non-trivial
lemma new_lemma_44791 (h0 : function.extfun Type (functor.comp complete_lattice semigroup)) : @is_atomistic.{0} (semigroup.{0} (option.{0} pos)) (@functor.comp.run.{0 0 0} complete_lattice.{0} semigroup.{0} (option.{0} pos) (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} complete_lattice.{0} semigroup.{0}) h0 (option.{0} pos)))  := sorry --non-trivial
lemma new_lemma_44792 (h0 : topological_space (simple_graph std_gen)) : path_connected_space (simple_graph std_gen) := sorry --non-trivial
lemma new_lemma_44793 (h0 : functor.add_const (ring (comm_group linarith.comp)) name) : @is_principal_ideal_ring.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (comm_group.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_44794 (h0 : functor.add_const (ring (ring name)) (has_neg (has_neg_part (add_comm_monoid Type)))) : @is_domain.{0} (ring.{0} name) (@functor.add_const.run.{0 1} (ring.{0} (ring.{0} name)) (has_neg.{1} (has_neg_part.{1} (add_comm_monoid.{1} Type))) h0)  := sorry --non-trivial
lemma new_lemma_44795 (h0 : complete_lattice (ring (comm_group (finset pos)))) : is_compactly_generated (ring (comm_group (finset pos))) := sorry --non-trivial
lemma new_lemma_44796 (h0 : topological_space (canonically_ordered_comm_semiring ennreal)) : preirreducible_space (canonically_ordered_comm_semiring ennreal) := sorry --non-trivial
lemma new_lemma_44797 (h0 : not (filter (left_cancel_semigroup num) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_44798 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_44799 (h0 : functor.add_const (ring (boolean_algebra.core Type)) Type) : @rank_condition.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 1} (ring.{1} (boolean_algebra.core.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_44800 (h0 : functor.add_const (ring (ordered_comm_ring pos)) (has_neg (has_neg pos))) : @is_domain.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (ordered_comm_ring.{0} pos)) (has_neg.{0} (has_neg.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_44801 (h0 : topological_space (dlist (random_gen (random_gen (random_gen fun_info))))) : totally_separated_space (dlist (random_gen (random_gen (random_gen fun_info)))) := sorry --non-trivial
lemma new_lemma_44802 (h0 : function.extfun Type group) : @normalizer_condition.{0} (semiring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} h0 (semiring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_44803 (h0 : fin has_zero.zero) : @t1_space.{1} (has_bot.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (has_bot.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_44804 (h0 : ring (with_one congr_arg_kind)) : strong_rank_condition (with_one congr_arg_kind) := sorry --non-trivial
lemma new_lemma_44805 (h0 : ring (has_nnnorm (has_nnnorm char))) : strong_rank_condition (has_nnnorm (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_44806 (h0 : ring (comm_semigroup (has_neg (has_neg name)))) : rank_condition (comm_semigroup (has_neg (has_neg name))) := sorry --non-trivial
lemma new_lemma_44807 (h0 : functor.add_const (group (has_zero linarith.comp)) (ring environment.implicit_infer_kind)) : @is_simple_group.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (has_zero.{0} linarith.comp)) (ring.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_44808 (h0 : functor.add_const (semiring (has_neg Type)) name) : @is_noetherian_ring.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (semiring.{1} (has_neg.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_44809 (h0 : function.extfun Type group) : @group.fg.{0} (canonically_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type group.{0} h0 (canonically_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_44810 (h0 : topological_space (boolean_algebra.core (has_add (has_to_string unsigned)))) : path_connected_space (boolean_algebra.core (has_add (has_to_string unsigned))) := sorry --non-trivial
lemma new_lemma_44811 (h0 : cancel_comm_monoid_with_zero (simple_graph empty)) : unique_factorization_monoid (simple_graph empty) := sorry --non-trivial
lemma new_lemma_44812 (h0 : cancel_comm_monoid_with_zero (add_cancel_comm_monoid (option empty))) : unique_factorization_monoid (add_cancel_comm_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_44813 (h0 : functor.add_const (topological_space (add_comm_monoid Type)) pos) : @locally_compact_space.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_comm_monoid.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_44814 (h0 : not (topological_space (normed_group congr_arg_kind) -> false)) : @irreducible_space.{0} (normed_group.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_group.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_44815 (h0 : complete_lattice (has_norm (has_top (has_norm to_additive.value_type)))) : is_atomistic (has_norm (has_top (has_norm to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_44816 (h0 : topological_space (ring (option Type))) : totally_separated_space (ring (option Type)) := sorry --non-trivial
lemma new_lemma_44817 (h0 : topological_space (boolean_algebra (ring linarith.comp))) : normal_space (boolean_algebra (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_44818 (h0 : group (has_nndist (has_neg unsigned))) : is_simple_group (has_nndist (has_neg unsigned)) := sorry --non-trivial
lemma new_lemma_44819 (h0 : complete_lattice (add_comm_monoid empty)) : complete_lattice.is_Sup_finite_compact (add_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_44820 (h0 : complete_lattice (has_star (semiring congr_arg_kind))) : is_atomistic (has_star (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_44821 (h1 : complete_lattice congr_arg_kind) : is_atomistic congr_arg_kind := sorry --non-trivial
lemma new_lemma_44822 (h0 : functor.add_const (topological_space (has_Inf name)) (ordered_ring name)) : @discrete_topology.{0} (has_Inf.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} name)) (ordered_ring.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_44823 (h2 : has_mem.mem (has_emptyc linarith.ineq) has_emptyc.emptyc) : @totally_disconnected_space.{0} (has_emptyc.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_emptyc.{0} linarith.ineq) h2)  := sorry --non-trivial
lemma new_lemma_44824 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (has_neg num)) := sorry --non-trivial
lemma new_lemma_44825 (h0 : add_monoid (canonically_linear_ordered_monoid num)) : add_monoid.fg (canonically_linear_ordered_monoid num) := sorry --non-trivial
lemma new_lemma_44826 (h0 : topological_space (normed_comm_ring empty)) : topological_space.separable_space (normed_comm_ring empty) := sorry --non-trivial
lemma new_lemma_44827 (h0 : filter (linear_ordered_comm_group num)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_44828 (h0 : not (function.extfun (finset Type) (has_mem.mem (measurable_space empty)) -> false)) : @irreducible_space.{0} (measurable_space.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (measurable_space.{0} empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (measurable_space.{0} empty)) (@classical.by_contradiction'.{0} (function.extfun.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (measurable_space.{0} empty))) h0) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_44829 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (add_left_cancel_semigroup.{0} empty) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (add_left_cancel_semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_44830 (h0 : group (has_norm (has_top (has_top (has_top num))))) : is_cyclic (has_norm (has_top (has_top (has_top num)))) := sorry --non-trivial
lemma new_lemma_44831 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (ordered_cancel_add_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (ordered_cancel_add_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_44832 (h0 : topological_space (non_unital_semiring (has_top (has_top (has_top linarith.comp_source))))) : totally_separated_space (non_unital_semiring (has_top (has_top (has_top linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_44833 (h0 : functor.add_const Prop (linear_ordered_semiring num)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_44834 (h0 : topological_space (non_assoc_semiring (semiring empty))) : topological_space.separable_space (non_assoc_semiring (semiring empty)) := sorry --non-trivial
lemma new_lemma_44835 (h0 : function.extfun Type ring) : @rank_condition.{0} (pseudo_metric_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (pseudo_metric_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_44836 (h0 : topological_space (has_to_string (has_Inf Type))) : locally_compact_space (has_to_string (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_44837 (h0 : topological_space (ring (mul_zero_class (normed_comm_ring environment.implicit_infer_kind)))) : t1_space (ring (mul_zero_class (normed_comm_ring environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_44838 (h0 : functor.add_const (function.extfun Type list) name) : palindrome (function.extfun_app (functor.add_const.run h0) (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_44839 (h1 : ring (distrib (has_ssubset char))) : is_domain (distrib (has_ssubset char)) := sorry --non-trivial
lemma new_lemma_44840 (h1 : function.extfun Type topological_space) : @t0_space.{0} (with_bot.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (with_bot.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_44841 (h0 : add_group (has_edist (option empty))) : is_add_cyclic (has_edist (option empty)) := sorry --non-trivial
lemma new_lemma_44842 (h0 : topological_space (has_norm (random_gen to_additive.value_type))) : locally_compact_space (has_norm (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_44843 (h0 : group (ordered_comm_monoid (has_Inf (has_Inf (has_Inf real))))) : normalizer_condition (ordered_comm_monoid (has_Inf (has_Inf (has_Inf real)))) := sorry --non-trivial
lemma new_lemma_44844 (h0 : add_group (has_well_founded empty)) : is_add_cyclic (has_well_founded empty) := sorry --non-trivial
lemma new_lemma_44845 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_top.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_top.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_44846 (h0 : ring (has_append (has_nnnorm (has_nnnorm (comm_ring reducibility_hints))))) : rank_condition (has_append (has_nnnorm (has_nnnorm (comm_ring reducibility_hints)))) := sorry --non-trivial
lemma new_lemma_44847 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (has_bot.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_bot.{0} num))  := sorry --non-trivial
lemma new_lemma_44848 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (normed_comm_ring pos)) := sorry --non-trivial
lemma new_lemma_44849 (h0 : not (filter (denumerable linarith.comp_source) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_44850 (h0 : topological_space (boolean_algebra (normed_comm_ring Type))) : discrete_topology (boolean_algebra (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_44851 (h0 : ordered_add_comm_monoid (normed_lattice_add_comm_group pos)) : archimedean (normed_lattice_add_comm_group pos) := sorry --non-trivial
lemma new_lemma_44852 (h0 : ring (normed_field (has_ssubset reducibility_hints))) : strong_rank_condition (normed_field (has_ssubset reducibility_hints)) := sorry --non-trivial
lemma new_lemma_44853 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_zero Type)) unsigned) : @unique_factorization_monoid.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (cancel_comm_monoid_with_zero.{1} (has_zero.{1} Type)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_44854 (h0 : has_le (semi_normed_comm_ring to_additive.value_type)) (h1 : bounded_order (semi_normed_comm_ring to_additive.value_type)) : is_simple_order (semi_normed_comm_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_44855 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (group_with_zero.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} h0 (group_with_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_44856 (h1 : ring (semiring (has_norm fun_info))) : strong_rank_condition (semiring (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_44857 (h0 : filter (has_add (mul_one_class (mul_one_class (ring Type))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_44858 (h0 : function.extfun nat fin) : @has_exists_mul_of_le.{0} (ordered_comm_monoid.{0} name) (@matrix.vec_empty.{0} (ordered_comm_monoid.{0} (ordered_comm_monoid.{0} name)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_44859 (h1 : topological_space (has_top linarith.comp_source)) : t0_space (has_top linarith.comp_source) := sorry --non-trivial
lemma new_lemma_44860 (h0 : topological_space (normed_lattice_add_comm_group (has_pos_part real))) : t1_space (normed_lattice_add_comm_group (has_pos_part real)) := sorry --non-trivial
lemma new_lemma_44861 (h0 : topological_space ereal) : t0_space ereal := sorry --non-trivial
lemma new_lemma_44862 (h0 : uniform_space (semigroup (has_neg Type))) : complete_space (semigroup (has_neg Type)) := sorry --non-trivial
lemma new_lemma_44863 (h0 : function.extfun Type group) : @is_cyclic.{0} (option.{0} name) (@function.extfun_app.{2 1} Type group.{0} h0 (option.{0} name))  := sorry --non-trivial
lemma new_lemma_44864 (h0 : fin has_zero.zero) : @preirreducible_space.{1} (has_bot.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (has_bot.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_44865 (h0 : not (topological_space (non_assoc_semiring empty) -> false)) : @totally_disconnected_space.{0} (non_assoc_semiring.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (non_assoc_semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_44866 (h0 : not (filter (random_gen string_imp) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_44867 (h0 : ring (distrib (mul_one_class to_additive.value_type))) : rank_condition (distrib (mul_one_class to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_44868 (h0 : fin has_zero.zero) : @normalizer_condition.{0} real (@matrix.vec_empty.{0} (group.{0} real) h0)  := sorry --non-trivial
lemma new_lemma_44869 (h0 : complete_lattice (linear_ordered_field (option unsigned))) : is_atomistic (linear_ordered_field (option unsigned)) := sorry --non-trivial
lemma new_lemma_44870 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (linear_ordered_comm_group.{0} empty) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (linear_ordered_comm_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_44871 (h0 : list (has_inv (random_gen (random_gen (random_gen (random_gen (random_gen string_imp))))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_44872 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (with_one.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_one.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_44873 (h0 : functor.add_const (monoid (left_cancel_semigroup unsigned)) congr_arg_kind) : @monoid.fg.{0} (left_cancel_semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (monoid.{0} (left_cancel_semigroup.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_44874 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (has_zero num)) := sorry --non-trivial
lemma new_lemma_44875 (h0 : topological_space (normed_linear_ordered_group unsigned)) : discrete_topology (normed_linear_ordered_group unsigned) := sorry --non-trivial
lemma new_lemma_44876 (h0 : uniform_space (mul_zero_class congr_arg_kind)) : complete_space (mul_zero_class congr_arg_kind) := sorry --non-trivial
lemma new_lemma_44877 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (free_add_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_44878 (h0 : complete_lattice (has_emptyc fun_info)) : is_compactly_generated (has_emptyc fun_info) := sorry --non-trivial
lemma new_lemma_44879 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @totally_disconnected_space.{0} (normed_group.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (normed_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_44880 (h1 : group (denumerable fun_info)) : normalizer_condition (denumerable fun_info) := sorry --non-trivial
lemma new_lemma_44881 (h0 : group pos) : group.fg pos := sorry --non-trivial
lemma new_lemma_44882 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (ordered_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (ordered_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_44883 (h0 : functor.add_const (finset (generalized_boolean_algebra name)) (has_Inf pos)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_44884 (h0 : function.extfun (Type 1) ordered_add_comm_monoid) : @archimedean.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_add_comm_monoid.{1} h0 (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_44885 (h0 : not (topological_space (non_assoc_semiring empty) -> false)) : @topological_space.separable_space.{0} (non_assoc_semiring.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (non_assoc_semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_44886 (h0 : not (uniform_space (add_group unsigned) -> false)) : @complete_space.{0} (add_group.{0} unsigned) (@classical.by_contradiction'.{1} (uniform_space.{0} (add_group.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_44887 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (canonically_linear_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_linear_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_44888 (h0 : uniform_space (has_norm (has_norm (has_top fun_info)))) : separated_space (has_norm (has_norm (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_44889 (h0 : filter (add_left_cancel_monoid (has_nnnorm fun_info))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_44890 (h0 : topological_space (non_assoc_semiring empty)) : t1_space (non_assoc_semiring empty) := sorry --non-trivial
lemma new_lemma_44891 (h0 : not (function.extfun Type complete_lattice -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (random_gen.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (random_gen.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_44892 (h0 : has_mem.mem (division_ring fun_info) has_emptyc.emptyc) : @path_connected_space.{0} (division_ring.{0} fun_info) (@finset.pi.empty.{1 0} Type topological_space.{0} (division_ring.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_44893 (h0 : complete_lattice (has_ssubset bool)) : complete_lattice.is_Sup_finite_compact (has_ssubset bool) := sorry --non-trivial
lemma new_lemma_44894 (h0 : topological_space fun_info) (h1 : set fun_info) : is_seq_compact h1 := sorry --non-trivial
lemma new_lemma_44895 (h1 : add_group (with_bot linarith.ineq)) : is_add_cyclic (with_bot linarith.ineq) := sorry --non-trivial
lemma new_lemma_44896 (h0 : functor.add_const (complete_lattice (ring pos)) (has_zero pos)) : @is_compactly_generated.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ring.{0} pos)) (has_zero.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_44897 (h0 : complete_lattice (linear_ordered_add_comm_group (random_gen linarith.comp_source))) : is_atomistic (linear_ordered_add_comm_group (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_44898 (h0 : functor.add_const (topological_space (filter unsigned)) (option (option (option empty)))) : @t1_space.{0} (filter.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (filter.{0} unsigned)) (option.{0} (option.{0} (option.{0} empty))) h0)  := sorry --non-trivial
lemma new_lemma_44899 (h1 : topological_space (comm_ring (comm_ring linarith.comp_source))) : t0_space (comm_ring (comm_ring linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_44900 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (denumerable.{0} string_imp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (denumerable.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_44901 (h0 : ring (semiring (has_norm linarith.comp_source))) : is_domain (semiring (has_norm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_44902 (h0 : monoid (semigroup (has_add (has_add name)))) : monoid.fg (semigroup (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_44903 (h0 : functor.add_const (functor.add_const Prop (has_neg name)) linarith.comp) : functor.add_const.run (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_44904 (h0 : topological_space (has_zero (finset (finset Type)))) : path_connected_space (has_zero (finset (finset Type))) := sorry --non-trivial
lemma new_lemma_44905 (h0 : ring (ring (finset linarith.comp))) : rank_condition (ring (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_44906 (h0 : complete_lattice (pseudo_metric_space (option unsigned))) : is_atomistic (pseudo_metric_space (option unsigned)) := sorry --non-trivial
lemma new_lemma_44907 (h0 : topological_space (random_gen empty)) : totally_separated_space (random_gen empty) := sorry --non-trivial
lemma new_lemma_44908 (h0 : topological_space (ring (ring pos))) : t1_space (ring (ring pos)) := sorry --non-trivial
lemma new_lemma_44909 (h0 : topological_space (uniform_space.core congr_arg_kind)) : discrete_topology (uniform_space.core congr_arg_kind) := sorry --non-trivial
lemma new_lemma_44910 (h0 : finset (has_zero (finset (finset name)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_44911 (h0 : topological_space (free_add_monoid unsigned)) : totally_disconnected_space (free_add_monoid unsigned) := sorry --non-trivial
lemma new_lemma_44912 (h0 : functor.add_const (ordered_add_comm_monoid (semigroup num)) num) : @archimedean.{0} (semigroup.{0} num) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (semigroup.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_44913 (h0 : not (function.extfun Type topological_space -> false)) : @totally_disconnected_space.{0} fun_info (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) fun_info)  := sorry --non-trivial
lemma new_lemma_44914 (h0 : functor.add_const (uniform_space (has_add Type)) linarith.comp) : @complete_space.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (has_add.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_44915 (h0 : has_mem.mem (normed_group unsigned) has_emptyc.emptyc) : @complete_space.{0} (normed_group.{0} unsigned) (@finset.pi.empty.{1 0} Type uniform_space.{0} (normed_group.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_44916 (h0 : function.extfun (Type 1) topological_space) : @totally_separated_space.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_44917 (h0 : functor.add_const (topological_space (comm_group Type)) Type) : @preirreducible_space.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (comm_group.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_44918 (h1 : set (add_comm_semigroup fun_info -> std_gen)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_44919 (h0 : functor.add_const (group (has_add name)) pos) : @group.fg.{0} (has_add.{0} name) (@functor.add_const.run.{0 0} (group.{0} (has_add.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_44920 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (complete_distrib_lattice.{0} pos) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (complete_distrib_lattice.{0} pos))  := sorry --non-trivial
lemma new_lemma_44921 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_44922 (h0 : not (function.extfun Type group -> false)) : @normalizer_condition.{0} (complete_semilattice_Sup.{0} empty) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (complete_semilattice_Sup.{0} empty))  := sorry --non-trivial
lemma new_lemma_44923 (h0 : topological_space (finset unsigned)) : regular_space (finset unsigned) := sorry --non-trivial
lemma new_lemma_44924 (h0 : functor.add_const (complete_lattice (normed_linear_ordered_group unsigned)) num) : @complete_lattice.is_Sup_finite_compact.{0} (normed_linear_ordered_group.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (normed_linear_ordered_group.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_44925 (h0 : group (add_semigroup empty)) : normalizer_condition (add_semigroup empty) := sorry --non-trivial
lemma new_lemma_44926 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (has_emptyc.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_emptyc.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_44927 (h0 : has_mem.mem (has_top linarith.comp) has_emptyc.emptyc) : @is_domain.{0} (has_top.{0} linarith.comp) (@finset.pi.empty.{1 0} Type ring.{0} (has_top.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_44928 (h0 : functor.add_const (ring (semigroup empty)) congr_arg_kind) : @is_domain.{0} (semigroup.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (semigroup.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_44929 (h0 : topological_space (option ennreal)) : loc_path_connected_space (option ennreal) := sorry --non-trivial
lemma new_lemma_44930 (h0 : functor.add_const (semiring (cancel_monoid Type)) Type) : @is_noetherian_ring.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 1} (semiring.{1} (cancel_monoid.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_44931 (h0 : functor.add_const (topological_space (has_neg_part unsigned)) name) : @preconnected_space.{0} (has_neg_part.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_44932 (h0 : functor.add_const (topological_space (has_add pos)) (has_Inf Type)) : @path_connected_space.{0} (has_add.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_add.{0} pos)) (has_Inf.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_44933 (h0 : functor.add_const (group (has_to_string (option name))) name) : @is_simple_group.{0} (has_to_string.{0} (option.{0} name)) (@functor.add_const.run.{0 0} (group.{0} (has_to_string.{0} (option.{0} name))) name h0)  := sorry --non-trivial
lemma new_lemma_44934 (h0 : functor.add_const (group (as_linear_order empty)) empty) : @group.fg.{0} (as_linear_order.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (as_linear_order.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_44935 (h0 : list (normed_comm_ring (comm_monoid (has_dist (has_dist (has_dist (comm_monoid (has_dist congr_arg_kind)))))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_44936 (h0 : functor.add_const (ring (simple_graph pos)) linarith.comp) : @rank_condition.{0} (simple_graph.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (simple_graph.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_44937 (h0 : group (left_cancel_semigroup (semiring unsigned))) : normalizer_condition (left_cancel_semigroup (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_44938 (h0 : topological_space (ordered_cancel_add_comm_monoid pos)) : path_connected_space (ordered_cancel_add_comm_monoid pos) := sorry --non-trivial
lemma new_lemma_44939 (h0 : add_monoid (left_cancel_monoid unsigned)) : add_monoid.fg (left_cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_44940 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @is_atomistic.{0} fun_info (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) complete_lattice.{0}) fun_info)  := sorry --non-trivial
lemma new_lemma_44941 (h0 : group (has_zero (ring (ring pos)))) : is_cyclic (has_zero (ring (ring pos))) := sorry --non-trivial
lemma new_lemma_44942 (h0 : topological_space (partial_order num)) : normal_space (partial_order num) := sorry --non-trivial
lemma new_lemma_44943 (h0 : ordered_add_comm_monoid (has_Sup (semiring (semiring unsigned)))) : archimedean (has_Sup (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_44944 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem group)) : @normalizer_condition.{0} (random_gen.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) group.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (random_gen.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_44945 (h0 : topological_space (generalized_boolean_algebra (has_Inf (has_Inf linarith.comp)))) : preirreducible_space (generalized_boolean_algebra (has_Inf (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_44946 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (preorder.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (preorder.{0} empty))  := sorry --non-trivial
lemma new_lemma_44947 (h0 : function.extfun Type topological_space) : @normal_space.{0} (normed_comm_ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_44948 (h0 : has_mem.mem (has_norm (has_top congr_arg_kind)) has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} (has_norm.{0} (has_top.{0} congr_arg_kind)) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (has_norm.{0} (has_top.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_44949 (h0 : functor.add_const (group (has_neg name)) name) : @is_cyclic.{0} (has_neg.{0} name) (@functor.add_const.run.{0 0} (group.{0} (has_neg.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_44950 (h0 : ring (encodable linarith.ineq)) : strong_rank_condition (encodable linarith.ineq) := sorry --non-trivial
lemma new_lemma_44951 (h0 : functor.add_const (topological_space (boolean_algebra pos)) Type) : @path_connected_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_44952 (h0 : complete_lattice (monoid (option unsigned))) : is_atomistic (monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_44953 (h0 : fin has_zero.zero) : @monoid.fg.{1} (canonically_linear_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (monoid.{1} (canonically_linear_ordered_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_44954 (h0 : topological_space ennreal) : path_connected_space ennreal := sorry --non-trivial
lemma new_lemma_44955 (h0 : group (generalized_boolean_algebra (has_add (has_pos_part linarith.comp)))) : is_simple_group (generalized_boolean_algebra (has_add (has_pos_part linarith.comp))) := sorry --non-trivial
lemma new_lemma_44956 (h0 : add_monoid (boolean_algebra.core (has_add environment.implicit_infer_kind))) : add_monoid.fg (boolean_algebra.core (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_44957 (h0 : topological_space (complete_semilattice_Sup num)) : totally_disconnected_space (complete_semilattice_Sup num) := sorry --non-trivial
lemma new_lemma_44958 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (has_nndist.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (has_nndist.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_44959 (h0 : uniform_space (measurable_space (semiring (semiring empty)))) : separated_space (measurable_space (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_44960 (h0 : uniform_space (boolean_algebra.core (linear_ordered_add_comm_group_with_top (finset Type)))) : complete_space (boolean_algebra.core (linear_ordered_add_comm_group_with_top (finset Type))) := sorry --non-trivial
lemma new_lemma_44961 (h0 : uniform_space (add_group congr_arg_kind)) : complete_space (add_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_44962 (h0 : uniform_space (linear_ordered_semiring (random_gen congr_arg_kind))) : complete_space (linear_ordered_semiring (random_gen congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_44963 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (has_inter.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_inter.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_44964 (h0 : monoid (complete_distrib_lattice environment.implicit_infer_kind)) : monoid.fg (complete_distrib_lattice environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_44965 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (normed_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type semiring.{0} h0 (normed_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_44966 (h0 : add_group (has_one (semiring (semiring (semiring empty))))) : is_add_cyclic (has_one (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_44967 (h0 : function.extfun Type group) : @is_simple_group.{0} (semigroup.{0} (has_add.{0} (has_add.{0} (boolean_algebra.core.{0} (has_add.{0} (has_add.{0} pos)))))) (@function.extfun_app.{2 1} Type group.{0} h0 (semigroup.{0} (has_add.{0} (has_add.{0} (boolean_algebra.core.{0} (has_add.{0} (has_add.{0} pos)))))))  := sorry --non-trivial
lemma new_lemma_44968 (h0 : topological_space (has_nndist (comm_group pos))) : preconnected_space (has_nndist (comm_group pos)) := sorry --non-trivial
lemma new_lemma_44969 (h0 : ring (with_one (random_gen (random_gen (random_gen (random_gen num)))))) : strong_rank_condition (with_one (random_gen (random_gen (random_gen (random_gen num))))) := sorry --non-trivial
lemma new_lemma_44970 (h0 : monoid (has_top (semiring (has_top (has_top (semiring num)))))) : monoid.fg (has_top (semiring (has_top (has_top (semiring num))))) := sorry --non-trivial
lemma new_lemma_44971 (h0 h1 : multiset (random_gen (mul_one_class char))) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_44972 (h2 : add_group reducibility_hints) : is_add_cyclic reducibility_hints := sorry --non-trivial
lemma new_lemma_44973 (h1 : complete_lattice (add_comm_semigroup (normed_field std_gen))) : complete_lattice.is_Sup_finite_compact (add_comm_semigroup (normed_field std_gen)) := sorry --non-trivial
lemma new_lemma_44974 (h2 : uniform_space (with_zero (has_bot to_additive.value_type))) : complete_space (with_zero (has_bot to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_44975 (h0 : functor.add_const (topological_space (ordered_comm_monoid linarith.comp)) Type) : @totally_separated_space.{0} (ordered_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (ordered_comm_monoid.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_44976 (h0 : add_monoid (add_comm_monoid (has_Inf pos))) : add_monoid.fg (add_comm_monoid (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_44977 (h0 : topological_space (ring (ring name))) : topological_space.separable_space (ring (ring name)) := sorry --non-trivial
lemma new_lemma_44978 (h0 : ring (with_one (random_gen (random_gen linarith.ineq)))) : is_domain (with_one (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_44979 (h0 : uniform_space (has_add (has_inv (has_ssubset fun_info)))) : complete_space (has_add (has_inv (has_ssubset fun_info))) := sorry --non-trivial
lemma new_lemma_44980 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (has_top.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_top.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_44981 (h0 : not (function.extfun Type complete_lattice -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (@id.{2} Type unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (@id.{2} Type unsigned))  := sorry --non-trivial
lemma new_lemma_44982 (h0 h1 : multiset (non_unital_non_assoc_semiring fun_info)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_44983 (h0 : functor.add_const (complete_lattice (canonically_linear_ordered_monoid name)) ennreal) : @is_atomistic.{0} (canonically_linear_ordered_monoid.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (canonically_linear_ordered_monoid.{0} name)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_44984 (h2 : ring (nondiscrete_normed_field reducibility_hints)) : is_domain (nondiscrete_normed_field reducibility_hints) := sorry --non-trivial
lemma new_lemma_44985 (h0 : not (uniform_space (has_compl fun_info) -> false)) : @complete_space.{0} (has_compl.{0} fun_info) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_compl.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_44986 (h0 : complete_lattice (has_add name)) : is_compactly_generated (has_add name) := sorry --non-trivial
lemma new_lemma_44987 (h0 : not (complete_lattice (has_union unsigned) -> false)) : @is_compactly_generated.{0} (has_union.{0} unsigned) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_union.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_44988 (h0 : add_group (sub_neg_monoid (has_neg name))) : is_add_cyclic (sub_neg_monoid (has_neg name)) := sorry --non-trivial
lemma new_lemma_44989 (h0 : complete_lattice (filter congr_arg_kind)) : is_compactly_generated (filter congr_arg_kind) := sorry --non-trivial
lemma new_lemma_44990 (h0 : not (topological_space (has_lt char) -> false)) : @path_connected_space.{0} (has_lt.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (has_lt.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_44991 (h0 : functor.add_const (list (ring name)) linarith.comp) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_44992 (h0 : ring (add_cancel_comm_monoid reducibility_hints)) : rank_condition (add_cancel_comm_monoid reducibility_hints) := sorry --non-trivial
lemma new_lemma_44993 (h0 : topological_space (has_inter empty)) : locally_compact_space (has_inter empty) := sorry --non-trivial
lemma new_lemma_44994 (h0 : finset (ordered_comm_ring (ring (has_Inf (finset (finset (has_Inf linarith.comp))))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_44995 (h0 : functor.add_const (topological_space (plift empty)) empty) : @totally_disconnected_space.{1} (plift.{1} empty) (@functor.add_const.run.{1 0} (topological_space.{1} (plift.{1} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_44996 (h0 : uniform_space (linear_ordered_comm_group_with_zero fun_info)) : complete_space (linear_ordered_comm_group_with_zero fun_info) := sorry --non-trivial
lemma new_lemma_44997 (h0 : ring (has_neg_part (finset (finset (finset (has_add name)))))) : rank_condition (has_neg_part (finset (finset (finset (has_add name))))) := sorry --non-trivial
lemma new_lemma_44998 (h0 : group (sub_neg_monoid real)) : group.fg (sub_neg_monoid real) := sorry --non-trivial
lemma new_lemma_44999 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @path_connected_space.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_45000 (h0 : topological_space (finset (finset Type))) : preconnected_space (finset (finset Type)) := sorry --non-trivial
lemma new_lemma_45001 (h0 : ring (has_neg_part (cancel_monoid pos))) : rank_condition (has_neg_part (cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_45002 (h0 : group (topological_space (random_gen (has_inv linarith.ineq)))) : is_cyclic (topological_space (random_gen (has_inv linarith.ineq))) := sorry --non-trivial
lemma new_lemma_45003 (h0 : set (add_comm_semigroup fun_info -> environment.implicit_infer_kind)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_45004 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (has_top.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (has_top.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_45005 (h4 : set (nondiscrete_normed_field environment.projection_info)) : set.finite h4 := sorry --non-trivial
lemma new_lemma_45006 (h0 : ring (linear_ordered_comm_group_with_zero to_additive.value_type)) : is_domain (linear_ordered_comm_group_with_zero to_additive.value_type) := sorry --non-trivial
lemma new_lemma_45007 (h0 : not (uniform_space (has_ssubset to_additive.value_type) -> false)) : @complete_space.{0} (has_ssubset.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_ssubset.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_45008 (h0 : topological_space (linear_ordered_add_comm_group (random_gen (has_inv linarith.comp_source)))) : locally_compact_space (linear_ordered_add_comm_group (random_gen (has_inv linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_45009 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (has_ssubset linarith.ineq)) := sorry --non-trivial
lemma new_lemma_45010 (h0 : not (has_le (distrib fun_info) -> false)) : @no_top_order.{0} (distrib.{0} fun_info) (@classical.by_contradiction'.{1} (has_le.{0} (distrib.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_45011 (h4 : filter (add_monoid to_additive.value_type)) : filter.ne_bot h4 := sorry --non-trivial
lemma new_lemma_45012 (h0 : functor.add_const (complete_lattice (boolean_algebra name)) environment.implicit_infer_kind) : @complete_lattice.is_Sup_finite_compact.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (boolean_algebra.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_45013 (h0 : group (normed_group (has_top fun_info))) : is_cyclic (normed_group (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_45014 (h0 : topological_space (canonically_ordered_comm_semiring ennreal)) : path_connected_space (canonically_ordered_comm_semiring ennreal) := sorry --non-trivial
lemma new_lemma_45015 (h0 : functor.add_const (topological_space (ordered_comm_ring linarith.comp)) linarith.comp) : @sequential_space.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_45016 (h0 : topological_space (sub_neg_monoid Type)) : path_connected_space (sub_neg_monoid Type) := sorry --non-trivial
lemma new_lemma_45017 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (has_emptyc.{0} (random_gen.{0} linarith.ineq)) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 topological_space.{0}) (has_emptyc.{0} (random_gen.{0} linarith.ineq)))  := sorry --non-trivial
lemma new_lemma_45018 (h0 : filter (semigroup (comm_group (comm_group pos)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_45019 (h0 : functor.add_const (filter (normed_comm_ring unsigned)) Type) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_45020 (h0 : functor.add_const (cancel_comm_monoid_with_zero (mul_zero_class pos)) pos) : @unique_factorization_monoid.{0} (mul_zero_class.{0} pos) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (mul_zero_class.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_45021 (h0 : topological_space (with_zero (random_gen fun_info))) : totally_disconnected_space (with_zero (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_45022 (h0 : complete_lattice (has_nnnorm (has_top (distrib_lattice string_imp)))) : is_compactly_generated (has_nnnorm (has_top (distrib_lattice string_imp))) := sorry --non-trivial
lemma new_lemma_45023 (h0 : topological_space (with_zero (random_gen (has_inv linarith.ineq)))) : path_connected_space (with_zero (random_gen (has_inv linarith.ineq))) := sorry --non-trivial
lemma new_lemma_45024 (h0 : functor.add_const (complete_lattice (comm_group Type)) unsigned) : @is_atomistic.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (comm_group.{1} Type)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_45025 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @sequential_space.{0} (complete_distrib_lattice.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_distrib_lattice.{0} pos))  := sorry --non-trivial
lemma new_lemma_45026 (h1 : ring (has_nnnorm reducibility_hints)) : rank_condition (has_nnnorm reducibility_hints) := sorry --non-trivial
lemma new_lemma_45027 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} (has_emptyc.{0} linarith.ineq) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (has_emptyc.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_45028 (h0 : topological_space (has_top (has_norm linarith.ineq))) : locally_compact_space (has_top (has_norm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_45029 (h0 : topological_space (is_R_or_C (semiring (semiring (semiring empty))))) : irreducible_space (is_R_or_C (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_45030 (h0 : complete_lattice (normed_linear_ordered_group unsigned)) : complete_lattice.is_Sup_finite_compact (normed_linear_ordered_group unsigned) := sorry --non-trivial
lemma new_lemma_45031 (h0 : topological_space (with_bot (random_gen (random_gen string_imp)))) : path_connected_space (with_bot (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_45032 (h0 : semiring (linear_ordered_comm_ring (has_star unsigned))) : is_noetherian_ring (linear_ordered_comm_ring (has_star unsigned)) := sorry --non-trivial
lemma new_lemma_45033 (h0 : topological_space (set.set_semiring (random_gen fun_info))) : locally_compact_space (set.set_semiring (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_45034 (h0 : topological_space (random_gen (has_nnnorm linarith.ineq))) : path_connected_space (random_gen (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_45035 (h0 : functor.add_const (finset (semigroup Type)) unsigned) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_45036 (h0 : functor.add_const (ring (comm_monoid num)) empty) : @rank_condition.{0} (comm_monoid.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (comm_monoid.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_45037 (h0 : functor.add_const (function.extfun Type ordered_add_comm_monoid) (has_neg linarith.comp)) : @archimedean.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_add_comm_monoid.{0}) (has_neg.{0} linarith.comp) h0) (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_45038 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (measurable_space.{0} num) (@function.extfun_app.{2 1} Type monoid.{0} h0 (measurable_space.{0} num))  := sorry --non-trivial
lemma new_lemma_45039 (h0 : topological_space (generalized_boolean_algebra (sub_neg_monoid (sub_neg_monoid pos)))) : regular_space (generalized_boolean_algebra (sub_neg_monoid (sub_neg_monoid pos))) := sorry --non-trivial
lemma new_lemma_45040 (h0 : functor.add_const (function.extfun (Type 1) topological_space) (has_Inf (finset (has_Inf linarith.comp)))) : @path_connected_space.{1} (has_neg.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) (has_Inf.{0} (finset.{0} (has_Inf.{0} linarith.comp))) h0) (has_neg.{1} Type))  := sorry --non-trivial
lemma new_lemma_45041 (h0 : ring (linear_ordered_semiring congr_arg_kind)) : strong_rank_condition (linear_ordered_semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_45042 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_add name)) (has_pos_part name)) : @unique_factorization_monoid.{0} (has_add.{0} name) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_add.{0} name)) (has_pos_part.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_45043 (h1 : topological_space (add_comm_semigroup enat)) : t0_space (add_comm_semigroup enat) := sorry --non-trivial
lemma new_lemma_45044 (h0 : functor.add_const (ordered_comm_monoid (cancel_monoid Type)) (has_add name)) : @has_exists_mul_of_le.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (ordered_comm_monoid.{1} (cancel_monoid.{1} Type)) (has_add.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_45045 (h0 : not (function.extfun Type topological_space -> false)) : @discrete_topology.{0} (has_top.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_top.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_45046 (h0 : ring (uniform_space to_additive.value_type)) : is_domain (uniform_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_45047 (h1 : not (topological_space (topological_space linarith.comp_source) -> false)) : @t0_space.{0} (topological_space.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (topological_space.{0} linarith.comp_source)) h1)  := sorry --non-trivial
lemma new_lemma_45048 (h0 : topological_space (normed_lattice_add_comm_group (has_neg (has_neg name)))) : discrete_topology (normed_lattice_add_comm_group (has_neg (has_neg name))) := sorry --non-trivial
lemma new_lemma_45049 (h0 : group (has_pos_part (has_pos_part (has_add Type)))) : normalizer_condition (has_pos_part (has_pos_part (has_add Type))) := sorry --non-trivial
lemma new_lemma_45050 (h0 : uniform_space (normed_lattice_add_comm_group (has_pos_part (has_add real)))) : complete_space (normed_lattice_add_comm_group (has_pos_part (has_add real))) := sorry --non-trivial
lemma new_lemma_45051 (h0 : add_group (ordered_comm_ring (has_add (has_add pos)))) : is_add_cyclic (ordered_comm_ring (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_45052 (h0 : group fun_info) (h1 : topological_space (has_div (mul_one_class (group_topology fun_info)))) : path_connected_space (has_div (mul_one_class (group_topology fun_info))) := sorry --non-trivial
lemma new_lemma_45053 (h0 : topological_space (has_to_string (comm_group name))) : preconnected_space (has_to_string (comm_group name)) := sorry --non-trivial
lemma new_lemma_45054 (h0 : group (comm_semigroup (comm_semigroup (ordered_comm_ring pos)))) : group.fg (comm_semigroup (comm_semigroup (ordered_comm_ring pos))) := sorry --non-trivial
lemma new_lemma_45055 (h0 : ring (boolean_algebra (comm_group (comm_group (comm_group unsigned))))) : strong_rank_condition (boolean_algebra (comm_group (comm_group (comm_group unsigned)))) := sorry --non-trivial
lemma new_lemma_45056 (h0 : has_lt (normed_comm_ring unsigned)) : no_max_order (normed_comm_ring unsigned) := sorry --non-trivial
lemma new_lemma_45057 (h1 : group (has_emptyc (with_bot (with_bot to_additive.value_type)))) : group.fg (has_emptyc (with_bot (with_bot to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_45058 (h0 : group (with_bot (has_norm fun_info))) : normalizer_condition (with_bot (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_45059 (h0 : topological_space (boolean_algebra.core (ring name))) : totally_separated_space (boolean_algebra.core (ring name)) := sorry --non-trivial
lemma new_lemma_45060 (h0 : not (topological_space (linear_ordered_semiring unsigned) -> false)) : @totally_disconnected_space.{0} (linear_ordered_semiring.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_semiring.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_45061 (h1 : has_lt (normed_field reducibility_hints)) : no_max_order (normed_field reducibility_hints) := sorry --non-trivial
lemma new_lemma_45062 (h0 : group (boolean_algebra (has_neg_part (has_neg_part unsigned)))) : group.fg (boolean_algebra (has_neg_part (has_neg_part unsigned))) := sorry --non-trivial
lemma new_lemma_45063 (h1 : has_mem.mem (has_top congr_arg_kind) has_emptyc.emptyc) : @totally_separated_space.{0} (has_top.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_top.{0} congr_arg_kind) h1)  := sorry --non-trivial
lemma new_lemma_45064 (h0 : uniform_space (has_nndist (option (option (option unsigned))))) : separated_space (has_nndist (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_45065 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (has_top.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (has_top.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_45066 (h0 : function.extfun Type ring) : @is_domain.{0} (denumerable.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} h0 (denumerable.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_45067 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (ordered_comm_ring.{0} real) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (ordered_comm_ring.{0} real))  := sorry --non-trivial
lemma new_lemma_45068 (h0 h1 : multiset (non_unital_non_assoc_semiring string_imp)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_45069 (h0 : group (has_neg Type)) : is_cyclic (has_neg Type) := sorry --non-trivial
lemma new_lemma_45070 (h0 : functor.add_const (ring (has_pos_part Type)) pos) : @is_principal_ideal_ring.{1} (has_pos_part.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_pos_part.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_45071 (h0 : group (has_add (has_nnnorm (has_nnnorm (has_nnnorm linarith.comp_source))))) : is_cyclic (has_add (has_nnnorm (has_nnnorm (has_nnnorm linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_45072 (h0 : topological_space (ring (finset (boolean_algebra.core name)))) : preirreducible_space (ring (finset (boolean_algebra.core name))) := sorry --non-trivial
lemma new_lemma_45073 (h0 : topological_space (has_neg (finset (finset (finset (finset linarith.comp)))))) : totally_disconnected_space (has_neg (finset (finset (finset (finset linarith.comp))))) := sorry --non-trivial
lemma new_lemma_45074 (h0 : monoid (measurable_space (has_top (has_top linarith.comp_source)))) : monoid.fg (measurable_space (has_top (has_top linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_45075 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_Inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} h0 (has_Inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_45076 (h0 : fin has_zero.zero) : @sequential_space.{0} (simple_graph.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (simple_graph.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_45077 (h0 : ring (semigroup congr_arg_kind)) : is_domain (semigroup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_45078 (h0 : functor.add_const (group (semiring empty)) empty) : @normalizer_condition.{0} (semiring.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (semiring.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_45079 (h0 : functor.add_const (topological_space (add_cancel_monoid environment.implicit_infer_kind)) unsigned) : @totally_disconnected_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_45080 (h0 : add_group (has_add (has_nnnorm (has_nnnorm (has_nnnorm linarith.ineq))))) : is_add_cyclic (has_add (has_nnnorm (has_nnnorm (has_nnnorm linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_45081 (h2 : not (topological_space (with_one num) -> false)) : @t0_space.{0} (with_one.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (with_one.{0} num)) h2)  := sorry --non-trivial
lemma new_lemma_45082 (h0 : function.extfun Type (functor.add_const (uniform_space (has_Sup unsigned)))) : @complete_space.{0} (has_Sup.{0} unsigned) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_Sup.{0} unsigned)) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (uniform_space.{0} (has_Sup.{0} unsigned))) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_45083 (h0 : filter (measurable_space (has_norm (has_norm (has_norm empty))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_45084 (h0 : topological_space (finset (has_pos_part (finset linarith.comp)))) : totally_disconnected_space (finset (has_pos_part (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_45085 (h0 : functor.add_const (topological_space (has_pos_part name)) Type) : @normal_space.{0} (has_pos_part.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (has_pos_part.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_45086 (h0 : has_neg (has_compl string.iterator_imp)) (h1 : measurable_space (has_compl string.iterator_imp)) : has_measurable_neg (has_compl string.iterator_imp) := sorry --non-trivial
lemma new_lemma_45087 (h0 : not (function.extfun Type group -> false)) : @normalizer_condition.{0} (semiring.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (semiring.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_45088 (h0 : topological_space (generalized_boolean_algebra (has_add (comm_semigroup real)))) : totally_separated_space (generalized_boolean_algebra (has_add (comm_semigroup real))) := sorry --non-trivial
lemma new_lemma_45089 (h0 : function.extfun Type (functor.comp topological_space has_zero)) : @totally_disconnected_space.{0} (has_zero.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} has_zero.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} has_zero.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_45090 (h0 : ring (has_edist (semiring (semiring unsigned)))) : strong_rank_condition (has_edist (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_45091 (h0 : function.extfun Type (functor.comp complete_lattice has_zero)) : @complete_lattice.is_Sup_finite_compact.{0} (has_zero.{0} pos) (@functor.comp.run.{0 0 0} complete_lattice.{0} has_zero.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} complete_lattice.{0} has_zero.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_45092 (h0 : complete_lattice (normed_group (has_top fun_info))) : complete_lattice.is_Sup_finite_compact (normed_group (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_45093 (h1 : list (multiset (has_div linarith.comp_source))) (h2 : nat) (h3 : multiset (has_div linarith.comp_source)) : multiset.disjoint (list.inth h1 h2) h3 := sorry --non-trivial
lemma new_lemma_45094 (h0 : functor.add_const (group (left_cancel_semigroup unsigned)) empty) : @is_cyclic.{0} (left_cancel_semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (left_cancel_semigroup.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_45095 (h0 : cancel_comm_monoid_with_zero (has_nndist (has_to_string unsigned))) : unique_factorization_monoid (has_nndist (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_45096 (h0 : fin has_zero.zero) : @totally_separated_space.{1} (add_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (add_comm_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_45097 (h0 : ring (has_to_string (has_add (ring name)))) : rank_condition (has_to_string (has_add (ring name))) := sorry --non-trivial
lemma new_lemma_45098 (h0 : topological_space (has_Inf (ordered_comm_monoid (has_pos_part Type)))) : preirreducible_space (has_Inf (ordered_comm_monoid (has_pos_part Type))) := sorry --non-trivial
lemma new_lemma_45099 (h0 : uniform_space (has_top (has_norm unsigned))) : separated_space (has_top (has_norm unsigned)) := sorry --non-trivial
lemma new_lemma_45100 (h0 : topological_space (with_bot (random_gen to_additive.value_type))) : path_connected_space (with_bot (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_45101 (h0 : add_group (complete_semilattice_Sup fun_info)) : is_add_cyclic (complete_semilattice_Sup fun_info) := sorry --non-trivial
lemma new_lemma_45102 (h0 h1 : multiset (has_ssubset linarith.ineq)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_45103 (h0 : topological_space (add_left_cancel_monoid (has_nnnorm (has_inv string_imp)))) : path_connected_space (add_left_cancel_monoid (has_nnnorm (has_inv string_imp))) := sorry --non-trivial
lemma new_lemma_45104 (h0 : topological_space (boolean_algebra.core (option (option (option (option num)))))) : irreducible_space (boolean_algebra.core (option (option (option (option num))))) := sorry --non-trivial
lemma new_lemma_45105 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (has_nndist.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_45106 (h0 : functor.add_const (topological_space (has_zero pos)) pos) : @locally_compact_space.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_45107 (h0 : not (filter (has_top to_additive.value_type) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_45108 (h0 : not (ring (add_monoid string_imp) -> false)) : @is_domain.{0} (add_monoid.{0} string_imp) (@classical.by_contradiction'.{1} (ring.{0} (add_monoid.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_45109 (h0 : not (has_mem.mem (function.extfun Type) has_emptyc.emptyc -> false)) : @is_add_cyclic.{0} (complete_semilattice_Sup.{0} fun_info) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@finset.pi.empty.{2 1} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{0} (@has_mem.mem.{2 2} ((Type → Type) → Type 1) (finset.{2} ((Type → Type) → Type 1)) (@finset.has_mem.{2} ((Type → Type) → Type 1)) (function.extfun.{2 1} Type) (@has_emptyc.emptyc.{2} (finset.{2} ((Type → Type) → Type 1)) (@finset.has_emptyc.{2} ((Type → Type) → Type 1)))) h0)) add_group.{0}) (complete_semilattice_Sup.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_45110 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (ring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} name))  := sorry --non-trivial
lemma new_lemma_45111 (h0 : topological_space (has_Sup (option empty))) : totally_disconnected_space (has_Sup (option empty)) := sorry --non-trivial
lemma new_lemma_45112 (h0 : functor.add_const (group (free_add_monoid empty)) num) : @is_cyclic.{0} (free_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (free_add_monoid.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_45113 (h0 : ring (canonically_linear_ordered_monoid (option (option unsigned)))) : strong_rank_condition (canonically_linear_ordered_monoid (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_45114 (h0 : topological_space (canonically_linear_ordered_monoid (has_Inf Type))) : normal_space (canonically_linear_ordered_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_45115 (h0 : function.extfun Type ring) : @rank_condition.{0} (semigroup.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_45116 (h0 : topological_space (generalized_boolean_algebra (has_Inf (sub_neg_monoid (has_pos_part real))))) : irreducible_space (generalized_boolean_algebra (has_Inf (sub_neg_monoid (has_pos_part real)))) := sorry --non-trivial
lemma new_lemma_45117 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (free_add_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (free_add_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_45118 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (ring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ring.{0} name))  := sorry --non-trivial
lemma new_lemma_45119 (h0 : fin has_zero.zero) : @unique_factorization_monoid.{0} (has_bot.{0} name) (@matrix.vec_empty.{0} (cancel_comm_monoid_with_zero.{0} (has_bot.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_45120 (h1 : not (group (with_bot linarith.comp) -> false)) : @normalizer_condition.{0} (with_bot.{0} linarith.comp) (@classical.by_contradiction'.{1} (group.{0} (with_bot.{0} linarith.comp)) h1)  := sorry --non-trivial
lemma new_lemma_45121 (h0 : measurable_space fun_info) (h1 : measure_theory.measure fun_info -> fun_info) (h2 : coe_sort (set.range h1)) : measure_theory.is_finite_measure (set.range_splitting h1 h2) := sorry --non-trivial
lemma new_lemma_45122 (h0 : topological_space (has_compl (has_nnnorm linarith.comp_source))) : path_connected_space (has_compl (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_45123 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (measurable_space fun_info)) := sorry --non-trivial
lemma new_lemma_45124 (h0 : topological_space (add_cancel_monoid unsigned)) : totally_separated_space (add_cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_45125 (h0 : functor.add_const (group (sub_neg_monoid linarith.comp)) pos) : @normalizer_condition.{0} (sub_neg_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (sub_neg_monoid.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_45126 (h0 : topological_space (add_group (semiring (semiring unsigned)))) : path_connected_space (add_group (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_45127 (h0 : functor.add_const (uniform_space (semigroup environment.implicit_infer_kind)) pos) : @complete_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (uniform_space.{0} (semigroup.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_45128 (h1 : has_mem.mem (has_emptyc to_additive.value_type) has_emptyc.emptyc) : @strong_rank_condition.{0} (has_emptyc.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type ring.{0} (has_emptyc.{0} to_additive.value_type) h1)  := sorry --non-trivial
lemma new_lemma_45129 (h0 : functor.add_const (add_monoid (has_add Type)) environment.implicit_infer_kind) : @add_monoid.fg.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (add_monoid.{1} (has_add.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_45130 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (has_neg.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_45131 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (with_bot.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type monoid.{0} h0 (with_bot.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_45132 (h0 : complete_lattice (has_div to_additive.value_type)) : is_compactly_generated (has_div to_additive.value_type) := sorry --non-trivial
lemma new_lemma_45133 (h0 : semiring (has_one (semiring congr_arg_kind))) : is_noetherian_ring (has_one (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_45134 (h0 : topological_space (linear_ordered_comm_ring (ordered_cancel_comm_monoid (option congr_arg_kind)))) : discrete_topology (linear_ordered_comm_ring (ordered_cancel_comm_monoid (option congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_45135 (h0 : topological_space (has_zero reducibility_hints)) : path_connected_space (has_zero reducibility_hints) := sorry --non-trivial
lemma new_lemma_45136 (h0 : functor.add_const (functor.add_const Prop ennreal) pos) : functor.add_const.run (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_45137 (h0 : function.extfun Type group) : @is_cyclic.{0} (random_gen.{0} string_imp) (@function.extfun_app.{2 1} Type group.{0} h0 (random_gen.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_45138 (h0 h1 : multiset (has_nnnorm (mul_one_class fun_info))) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_45139 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (with_bot.{0} fun_info) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 uniform_space.{0}) (with_bot.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_45140 (h0 : functor.add_const (topological_space (has_Inf linarith.comp)) (finset linarith.comp)) : @topological_space.separable_space.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} linarith.comp)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_45141 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem uniform_space)) : @separated_space.{0} (has_one.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) uniform_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) uniform_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_one.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_45142 (h1 : topological_space (measurable_space congr_arg_kind)) : totally_disconnected_space (measurable_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_45143 (h0 : uniform_space (ordered_comm_monoid (has_neg real))) : separated_space (ordered_comm_monoid (has_neg real)) := sorry --non-trivial
lemma new_lemma_45144 (h0 : ring (has_Inf (ring Type))) : strong_rank_condition (has_Inf (ring Type)) := sorry --non-trivial
lemma new_lemma_45145 (h0 : semiring (complete_linear_order (semiring num))) : is_noetherian_ring (complete_linear_order (semiring num)) := sorry --non-trivial
lemma new_lemma_45146 (h0 : add_group (has_bot (has_pos_part (has_add real)))) : is_add_cyclic (has_bot (has_pos_part (has_add real))) := sorry --non-trivial
lemma new_lemma_45147 (h0 : topological_space (with_bot (has_norm fun_info))) : path_connected_space (with_bot (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_45148 (h0 : ring (dlist (random_gen (random_gen fun_info)))) : rank_condition (dlist (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_45149 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} (has_norm.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_norm.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_45150 (h0 : group (random_gen (has_top linarith.comp_source))) : normalizer_condition (random_gen (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_45151 (h0 : uniform_space (comm_monoid (option empty))) : complete_space (comm_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_45152 (h0 : topological_space (has_compl (random_gen linarith.ineq))) : t0_space (has_compl (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_45153 (h1 : group (with_one (random_gen (random_gen to_additive.value_type)))) : normalizer_condition (with_one (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_45154 (h0 : uniform_space (sub_neg_monoid (has_add (has_Inf (has_Inf Type))))) : separated_space (sub_neg_monoid (has_add (has_Inf (has_Inf Type)))) := sorry --non-trivial
lemma new_lemma_45155 (h0 : functor.add_const (topological_space (generalized_boolean_algebra real)) real) : @locally_compact_space.{0} (generalized_boolean_algebra.{0} real) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} real)) real h0)  := sorry --non-trivial
lemma new_lemma_45156 (h0 : functor.add_const (topological_space (finset unsigned)) Type) : @sequential_space.{0} (finset.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (finset.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_45157 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (boolean_algebra.core ennreal)) := sorry --non-trivial
lemma new_lemma_45158 (h0 : topological_space (boolean_algebra linarith.comp)) : sequential_space (boolean_algebra linarith.comp) := sorry --non-trivial
lemma new_lemma_45159 (h0 : ring (has_nndist (has_add Type))) : is_principal_ideal_ring (has_nndist (has_add Type)) := sorry --non-trivial
lemma new_lemma_45160 (h0 : functor.add_const (complete_lattice (has_star num)) num) : @is_atomistic.{0} (has_star.{0} num) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_star.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_45161 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (measurable_space.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_group.{0} h0 (measurable_space.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_45162 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (normed_group.{0} char) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (normed_group.{0} char))  := sorry --non-trivial
lemma new_lemma_45163 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_Sup.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_Sup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_45164 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_emptyc.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_emptyc.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_45165 (h0 : functor.add_const (complete_lattice (comm_group num)) num) : @is_atomistic.{0} (comm_group.{0} num) (@functor.add_const.run.{0 0} (complete_lattice.{0} (comm_group.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_45166 (h0 : not (topological_space (metric_space num) -> false)) : @t0_space.{0} (metric_space.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (metric_space.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_45167 (h0 : functor.add_const (function.extfun (Type 1) topological_space) linarith.comp) : @sequential_space.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) linarith.comp h0) (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_45168 (h0 : functor.add_const (topological_space (ordered_comm_monoid linarith.comp)) linarith.comp) : @totally_disconnected_space.{0} (ordered_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_monoid.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_45169 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (ordered_comm_monoid.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_monoid.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_45170 (h1 : ring (has_norm linarith.comp)) : is_domain (has_norm linarith.comp) := sorry --non-trivial
lemma new_lemma_45171 (h0 : topological_space (free_add_monoid empty)) : topological_space.separable_space (free_add_monoid empty) := sorry --non-trivial
lemma new_lemma_45172 (h0 : complete_lattice (complete_semilattice_Sup unsigned)) : is_compactly_generated (complete_semilattice_Sup unsigned) := sorry --non-trivial
lemma new_lemma_45173 (h0 : function.extfun nat fin) : @regular_space.{1} (canonically_linear_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (canonically_linear_ordered_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_45174 (h0 : function.extfun nat fin) : @normalizer_condition.{0} (comm_semigroup.{0} (has_bot.{0} (has_bot.{0} (has_pos_part.{0} (has_bot.{0} pos))))) (@matrix.vec_empty.{0} (group.{0} (comm_semigroup.{0} (has_bot.{0} (has_bot.{0} (has_pos_part.{0} (has_bot.{0} pos)))))) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_45175 (h0 : complete_lattice (lex linarith.ineq)) : complete_lattice.is_Sup_finite_compact (lex linarith.ineq) := sorry --non-trivial
lemma new_lemma_45176 (h2 : complete_lattice (has_norm linarith.ineq)) : is_compactly_generated (has_norm linarith.ineq) := sorry --non-trivial
lemma new_lemma_45177 (h0 : functor.add_const (list (normed_group unsigned)) unsigned) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_45178 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @monoid.fg.{1} (comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) monoid.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 monoid.{1}) (comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_45179 (h0 : functor.add_const (topological_space (has_nndist unsigned)) Type) : @path_connected_space.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (has_nndist.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_45180 (h0 : has_lt (uniform_space string.iterator_imp)) : no_max_order (uniform_space string.iterator_imp) := sorry --non-trivial
lemma new_lemma_45181 (h0 : group (canonically_ordered_monoid (finset real))) : is_simple_group (canonically_ordered_monoid (finset real)) := sorry --non-trivial
lemma new_lemma_45182 (h0 : group (has_emptyc (random_gen empty))) : is_cyclic (has_emptyc (random_gen empty)) := sorry --non-trivial
lemma new_lemma_45183 (h0 : functor.add_const (topological_space (comm_group ennreal)) pos) : @totally_disconnected_space.{0} (comm_group.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} ennreal)) pos h0)  := sorry --non-trivial
lemma new_lemma_45184 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @irreducible_space.{0} (complete_distrib_lattice.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (complete_distrib_lattice.{0} pos))  := sorry --non-trivial
lemma new_lemma_45185 (h0 : set (semi_normed_comm_ring std_gen)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_45186 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (random_gen.{0} linarith.ineq) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (random_gen.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_45187 (h0 : topological_space (has_lt string.iterator_imp)) (h1 : preorder (has_lt string.iterator_imp)) : order_closed_topology (has_lt string.iterator_imp) := sorry --non-trivial
lemma new_lemma_45188 (h0 : filter (finset (has_add linarith.comp))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_45189 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (with_one.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (with_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_45190 (h0 : finset (has_neg (has_to_string (finset Type)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_45191 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : palindrome (function.extfun_app (function.extfun_app h0 list) (cancel_monoid Type)) := sorry --non-trivial
lemma new_lemma_45192 (h0 : fin has_zero.zero) : @totally_disconnected_space.{1} (has_pos_part.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (has_pos_part.{1} Type)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)))  := sorry --non-trivial
lemma new_lemma_45193 (h0 : complete_lattice (has_top (random_gen (random_gen linarith.ineq)))) : is_compactly_generated (has_top (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_45194 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (monoid_with_zero.{0} (option.{0} (option.{0} pos))) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (monoid_with_zero.{0} (option.{0} (option.{0} pos))))  := sorry --non-trivial
lemma new_lemma_45195 (h0 : functor.add_const (ring (has_neg linarith.comp)) pos) : @strong_rank_condition.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_neg.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_45196 (h0 : complete_lattice (with_one (has_inv (has_top fun_info)))) : is_atomistic (with_one (has_inv (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_45197 (h0 h2 : list enat) : list.is_infix h0 h2 := sorry --non-trivial
lemma new_lemma_45198 (h0 : topological_space (comm_ring (add_cancel_comm_monoid char))) : t0_space (comm_ring (add_cancel_comm_monoid char)) := sorry --non-trivial
lemma new_lemma_45199 (h0 : topological_space (finset congr_arg_kind)) : loc_path_connected_space (finset congr_arg_kind) := sorry --non-trivial
lemma new_lemma_45200 (h0 : ordered_add_comm_monoid (has_inter unsigned)) : archimedean (has_inter unsigned) := sorry --non-trivial
lemma new_lemma_45201 (h0 : topological_space (simple_graph name)) : preconnected_space (simple_graph name) := sorry --non-trivial
lemma new_lemma_45202 (h0 : group (plift (has_edist empty))) : normalizer_condition (plift (has_edist empty)) := sorry --non-trivial
lemma new_lemma_45203 (h0 : filter (has_nndist (has_pos_part (finset linarith.comp)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_45204 (h0 : topological_space (comm_group (semigroup Type))) : t0_space (comm_group (semigroup Type)) := sorry --non-trivial
lemma new_lemma_45205 (h0 : functor.comp topological_space has_zero (has_to_string pos)) : @locally_compact_space.{0} (has_zero.{0} (has_to_string.{0} pos)) (@functor.comp.run.{0 0 0} topological_space.{0} has_zero.{0} (has_to_string.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_45206 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (has_dist.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_dist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_45207 (h0 : filter (has_append string_imp)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_45208 (h0 : option num -> semiring num -> Prop) : relator.right_total h0 := sorry --non-trivial
lemma new_lemma_45209 (h0 : functor.add_const (topological_space (has_add Type)) Type) : @irreducible_space.{1} (has_add.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_add.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_45210 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (has_norm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_45211 (h0 : topological_space (has_lt (mul_one_class (has_lt enat)))) : path_connected_space (has_lt (mul_one_class (has_lt enat))) := sorry --non-trivial
lemma new_lemma_45212 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (generalized_boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (generalized_boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_45213 (h0 : functor.add_const (topological_space (has_nndist complex)) pos) : @t0_space.{0} (has_nndist.{0} complex) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} complex)) pos h0)  := sorry --non-trivial
lemma new_lemma_45214 (h0 : functor.add_const (finset (generalized_boolean_algebra name)) name) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_45215 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (add_left_cancel_semigroup.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_left_cancel_semigroup.{0} num))  := sorry --non-trivial
lemma new_lemma_45216 (h0 : topological_space (mul_one_class (mul_one_class enat))) : totally_disconnected_space (mul_one_class (mul_one_class enat)) := sorry --non-trivial
lemma new_lemma_45217 (h0 : complete_lattice (left_cancel_monoid (semiring (semiring empty)))) : is_atomistic (left_cancel_monoid (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_45218 (h0 : filter real.angle) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_45219 (h0 : function.extfun Type ring) : @is_domain.{0} (linear_ordered_cancel_comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_ordered_cancel_comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_45220 (h0 : has_mem.mem add_group has_emptyc.emptyc) : @is_add_cyclic.{0} fun_info (@function.extfun_app.{2 1} Type add_group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) add_group.{0} h0) fun_info)  := sorry --non-trivial
lemma new_lemma_45221 (h0 : filter (semigroup (has_Inf (has_Inf (has_add (has_add pos)))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_45222 (h0 : group (has_zero (ring linarith.comp))) : is_simple_group (has_zero (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_45223 (h0 : ring (has_nndist num)) : is_principal_ideal_ring (has_nndist num) := sorry --non-trivial
lemma new_lemma_45224 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (has_top string_imp)) := sorry --non-trivial
lemma new_lemma_45225 (h0 : group (with_bot (has_inv fun_info))) : normalizer_condition (with_bot (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_45226 (h0 : set (add_comm_semigroup (mul_one_class enat) -> char)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_45227 (h0 : group (measurable_space (has_inv (has_inv linarith.comp_source)))) : normalizer_condition (measurable_space (has_inv (has_inv linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_45228 (h0 : topological_space (dlist fun_info)) : irreducible_space (dlist fun_info) := sorry --non-trivial
lemma new_lemma_45229 (h0 : group (has_ssubset (comm_ring (has_top char)))) : group.fg (has_ssubset (comm_ring (has_top char))) := sorry --non-trivial
lemma new_lemma_45230 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_45231 (h0 : fin has_zero.zero) : @topological_space.separable_space.{0} pos (@matrix.vec_empty.{0} (topological_space.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_45232 (h0 : group (normed_group (has_ssubset char))) : is_cyclic (normed_group (has_ssubset char)) := sorry --non-trivial
lemma new_lemma_45233 (h0 : function.extfun (Type 1) topological_space) : @normal_space.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_45234 (h0 : topological_space (canonically_linear_ordered_monoid (has_add Type))) : normal_space (canonically_linear_ordered_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_45235 (h0 : functor.add_const (function.extfun Type monoid) name) : @monoid.fg.{0} (boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type monoid.{0}) name h0) (boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_45236 (h1 : set (string.iterator_imp -> normed_field fun_info)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_45237 (h0 : not (group (linear_ordered_add_comm_group to_additive.value_type) -> false)) : @group.fg.{0} (linear_ordered_add_comm_group.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (group.{0} (linear_ordered_add_comm_group.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_45238 (h0 : has_mem.mem (measurable_space linarith.comp_source) has_emptyc.emptyc) : @strong_rank_condition.{0} (measurable_space.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type ring.{0} (measurable_space.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_45239 (h0 : uniform_space (add_right_cancel_monoid (semiring congr_arg_kind))) : complete_space (add_right_cancel_monoid (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_45240 (h0 : not (ring (denumerable reducibility_hints) -> false)) : @strong_rank_condition.{0} (denumerable.{0} reducibility_hints) (@classical.by_contradiction'.{1} (ring.{0} (denumerable.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_45241 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (has_top.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (has_top.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_45242 (h0 : functor.add_const (ring (measurable_space.dynkin_system num)) unsigned) : @is_principal_ideal_ring.{0} (measurable_space.dynkin_system.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (measurable_space.dynkin_system.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_45243 (h0 : topological_space (non_assoc_semiring congr_arg_kind)) : t0_space (non_assoc_semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_45244 (h0 : ring (mul_zero_class (finset (has_add pos)))) : rank_condition (mul_zero_class (finset (has_add pos))) := sorry --non-trivial
lemma new_lemma_45245 (h0 : group (semiring (has_norm num))) : is_cyclic (semiring (has_norm num)) := sorry --non-trivial
lemma new_lemma_45246 (h0 : topological_space (add_comm_semigroup ereal)) (h1 : preorder (add_comm_semigroup ereal)) : order_closed_topology (add_comm_semigroup ereal) := sorry --non-trivial
lemma new_lemma_45247 (h0 : list (ordered_cancel_add_comm_monoid (option (option (option (option (option empty))))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_45248 (h0 : not (ring (metric_space empty) -> false)) : @is_principal_ideal_ring.{0} (metric_space.{0} empty) (@classical.by_contradiction'.{1} (ring.{0} (metric_space.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_45249 (h0 : functor.add_const (functor.add_const (topological_space Type) linarith.comp) linarith.comp) : @totally_disconnected_space.{1} Type (@functor.add_const.run.{1 0} (topological_space.{1} Type) linarith.comp (@functor.add_const.run.{1 0} (functor.add_const.{1 0} (topological_space.{1} Type) linarith.comp) linarith.comp h0))  := sorry --non-trivial
lemma new_lemma_45250 (h0 : has_neg (sub_neg_monoid Type)) (h1 : measurable_space (sub_neg_monoid Type)) : has_measurable_neg (sub_neg_monoid Type) := sorry --non-trivial
lemma new_lemma_45251 (h0 : topological_space (random_gen (has_top linarith.comp))) : path_connected_space (random_gen (has_top linarith.comp)) := sorry --non-trivial
lemma new_lemma_45252 (h0 : list (filter (semiring empty))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_45253 (h0 : functor.add_const (add_group (has_neg pos)) Type) : @is_add_cyclic.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 1} (add_group.{0} (has_neg.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_45254 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_semilattice_Sup.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_45255 (h0 : add_monoid (has_zero (finset Type))) : add_monoid.fg (has_zero (finset Type)) := sorry --non-trivial
lemma new_lemma_45256 (h0 : ring (has_dist (has_edist ennreal))) : rank_condition (has_dist (has_edist ennreal)) := sorry --non-trivial
lemma new_lemma_45257 (h0 : functor.add_const (topological_space (has_Inf linarith.comp)) pos) : @locally_compact_space.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_45258 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (pseudo_metric_space.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (pseudo_metric_space.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_45259 (h0 : functor.add_const (cancel_comm_monoid_with_zero (add_left_cancel_semigroup unsigned)) empty) : @unique_factorization_monoid.{0} (add_left_cancel_semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (add_left_cancel_semigroup.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_45260 (h0 : functor.add_const (function.extfun Type cancel_comm_monoid_with_zero) linarith.comp) : @unique_factorization_monoid.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type cancel_comm_monoid_with_zero.{0}) linarith.comp h0) (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_45261 (h0 : nat) (h1 : add_monoid (random_gen char)) (h2 : has_one (random_gen char) -> Prop) (h3 : Exists (fun (x : has_one (random_gen char)), h2 x)) : @char_p.{0} (random_gen.{0} char) h1 (@classical.some.{1} (has_one.{0} (random_gen.{0} char)) h2 h3) h0  := sorry --non-trivial
lemma new_lemma_45262 (h0 : functor.add_const (topological_space (has_to_string pos)) unsigned) : @topological_space.separable_space.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_45263 (h0 : functor.add_const (topological_space (comm_group linarith.comp)) environment.implicit_infer_kind) : @totally_disconnected_space.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_45264 (h0 : functor.comp topological_space has_add name) : @sequential_space.{0} (has_add.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} has_add.{0} name h0)  := sorry --non-trivial
lemma new_lemma_45265 (h0 : functor.add_const (uniform_space (boolean_algebra environment.implicit_infer_kind)) pos) : @separated_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (uniform_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_45266 (h0 : uniform_space (topological_space (has_nnnorm (linear_ordered_field char)))) : complete_space (topological_space (has_nnnorm (linear_ordered_field char))) := sorry --non-trivial
lemma new_lemma_45267 (h0 : group (has_nndist (finset (has_add name)))) : is_simple_group (has_nndist (finset (has_add name))) := sorry --non-trivial
lemma new_lemma_45268 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (group_with_zero.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (group_with_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_45269 (h0 : functor.add_const (function.extfun (Type 1) topological_space) pos) : @discrete_topology.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) pos h0) (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_45270 (h0 : topological_space (has_compl string_imp)) : locally_compact_space (has_compl string_imp) := sorry --non-trivial
lemma new_lemma_45271 (h1 : pseudo_metric_space (has_add (has_nnnorm string_imp))) (h2 : add_monoid (has_add (has_nnnorm string_imp))) : has_lipschitz_add (has_add (has_nnnorm string_imp)) := sorry --non-trivial
lemma new_lemma_45272 (h0 : cancel_comm_monoid_with_zero (normed_lattice_add_comm_group empty)) : unique_factorization_monoid (normed_lattice_add_comm_group empty) := sorry --non-trivial
lemma new_lemma_45273 (h0 : functor.add_const (complete_lattice (measurable_space.dynkin_system unsigned)) unsigned) : @complete_lattice.is_Sup_finite_compact.{0} (measurable_space.dynkin_system.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (measurable_space.dynkin_system.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_45274 (h0 : topological_space (has_nndist (option empty))) : path_connected_space (has_nndist (option empty)) := sorry --non-trivial
lemma new_lemma_45275 (h0 : functor.add_const (topological_space (free_add_monoid congr_arg_kind)) unsigned) : @totally_disconnected_space.{0} (free_add_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_45276 (h0 : ring (canonically_linear_ordered_monoid (has_Inf real))) : strong_rank_condition (canonically_linear_ordered_monoid (has_Inf real)) := sorry --non-trivial
lemma new_lemma_45277 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (pseudo_metric_space.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (pseudo_metric_space.{0} pos))  := sorry --non-trivial
lemma new_lemma_45278 (h0 : topological_space (has_neg (option (option (option (option (option (option ennreal)))))))) : preirreducible_space (has_neg (option (option (option (option (option (option ennreal))))))) := sorry --non-trivial
lemma new_lemma_45279 (h0 : functor.add_const (group (has_neg Type)) (has_nndist (has_neg (finset environment.implicit_infer_kind)))) : @group.fg.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (has_neg.{1} Type)) (has_nndist.{0} (has_neg.{0} (finset.{0} environment.implicit_infer_kind))) h0)  := sorry --non-trivial
lemma new_lemma_45280 (h0 : topological_space (ring (finset Type))) : totally_separated_space (ring (finset Type)) := sorry --non-trivial
lemma new_lemma_45281 (h0 : topological_space (ring (option (option pos)))) : discrete_topology (ring (option (option pos))) := sorry --non-trivial
lemma new_lemma_45282 (h0 : topological_space (boolean_algebra (has_add environment.implicit_infer_kind))) : regular_space (boolean_algebra (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_45283 (h0 : monoid (linear_ordered_comm_group unsigned)) : monoid.fg (linear_ordered_comm_group unsigned) := sorry --non-trivial
lemma new_lemma_45284 (h0 : ring (comm_ring (random_gen (semi_normed_ring linarith.comp_source)))) : strong_rank_condition (comm_ring (random_gen (semi_normed_ring linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_45285 (h0 : functor.add_const (ring (comm_group name)) ennreal) : @is_principal_ideal_ring.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (comm_group.{0} name)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_45286 (h0 : function.extfun Type (functor.add_const (topological_space (has_star empty)))) : @irreducible_space.{0} (has_star.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (has_star.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_45287 (h0 : add_group (add_comm_semigroup to_additive.value_type)) : is_add_cyclic (add_comm_semigroup to_additive.value_type) := sorry --non-trivial
lemma new_lemma_45288 (h0 : topological_space (add_comm_monoid (has_Inf Type))) : locally_compact_space (add_comm_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_45289 (h0 : topological_space (has_pos_part (ordered_comm_monoid real))) : preirreducible_space (has_pos_part (ordered_comm_monoid real)) := sorry --non-trivial
lemma new_lemma_45290 (h0 : functor.add_const (group (has_add unsigned)) name) : @is_simple_group.{0} (has_add.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (has_add.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_45291 (h0 : topological_space (generalized_boolean_algebra (sub_neg_monoid real))) : totally_disconnected_space (generalized_boolean_algebra (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_45292 (h2 : set (add_comm_semigroup char)) : set.finite h2 := sorry --non-trivial
lemma new_lemma_45293 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring name)) name) : @normal_space.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_45294 (h0 : function.extfun nat fin) : @unique_factorization_monoid.{0} (has_add.{0} pos) (@matrix.vec_empty.{0} (cancel_comm_monoid_with_zero.{0} (has_add.{0} pos)) (@function.extfun_app.{1 1} nat fin (@matrix.vec_empty.{0} (function.extfun.{1 1} nat fin) (@function.extfun_app.{1 1} nat fin (@matrix.vec_empty.{0} (function.extfun.{1 1} nat fin) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (@has_zero.zero.{0} nat nat.has_zero))) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_45295 (h0 : not (complete_lattice (mul_zero_class congr_arg_kind) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (mul_zero_class.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (complete_lattice.{0} (mul_zero_class.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_45296 (h0 : topological_space (complete_semilattice_Sup (has_ssubset linarith.comp_source))) : t0_space (complete_semilattice_Sup (has_ssubset linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_45297 (h0 : complete_lattice (mul_zero_class Type)) : complete_lattice.is_Sup_finite_compact (mul_zero_class Type) := sorry --non-trivial
lemma new_lemma_45298 (h0 : not (ring (uniform_space char) -> false)) : @strong_rank_condition.{0} (uniform_space.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (uniform_space.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_45299 (h0 : has_zero Type -> has_zero Type -> Prop) : transitive h0 := sorry --non-trivial
lemma new_lemma_45300 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (complete_semilattice_Sup.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_semilattice_Sup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_45301 (h0 : functor.add_const (function.extfun Type ring) (ring (ring (ring (ring Type))))) : @is_principal_ideal_ring.{0} (ring.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ring.{0}) (ring.{1} (ring.{1} (ring.{1} (ring.{1} Type)))) h0) (ring.{0} name))  := sorry --non-trivial
lemma new_lemma_45302 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (has_zero.{0} ennreal) (@function.extfun_app.{2 1} Type semiring.{0} h0 (has_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_45303 (h0 : not (has_mem.mem (has_emptyc num) has_emptyc.emptyc -> false)) : @separated_space.{0} (has_emptyc.{0} num) (@finset.pi.empty.{1 0} Type uniform_space.{0} (has_emptyc.{0} num) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_emptyc.{0} num) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_45304 (h0 : functor.add_const (function.extfun Type filter) name) : countable_Inter_filter (function.extfun_app (functor.add_const.run h0) (boolean_algebra.core pos)) := sorry --non-trivial
lemma new_lemma_45305 (h0 : has_mem.mem (has_top (has_norm congr_arg_kind)) has_emptyc.emptyc) : @totally_disconnected_space.{0} (has_top.{0} (has_norm.{0} congr_arg_kind)) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_top.{0} (has_norm.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_45306 (h1 : topological_space (random_gen linarith.ineq)) : t0_space (random_gen linarith.ineq) := sorry --non-trivial
lemma new_lemma_45307 (h0 : not (topological_space (has_sub congr_arg_kind) -> false)) : @topological_space.separable_space.{0} (has_sub.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (has_sub.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_45308 (h0 : function.extfun Type (functor.add_const (topological_space name))) : @irreducible_space.{0} name (@functor.add_const.run.{0 0} (topological_space.{0} name) (semiring.{0} num) (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} name)) h0 (semiring.{0} num)))  := sorry --non-trivial
lemma new_lemma_45309 (h0 : ring (canonically_ordered_monoid (finset (has_Inf linarith.comp)))) : rank_condition (canonically_ordered_monoid (finset (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_45310 (h0 : topological_space (has_add (sub_neg_monoid real))) : regular_space (has_add (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_45311 (h1 : measurable_space (nondiscrete_normed_field ereal)) (h2 : measure_theory.measure (nondiscrete_normed_field ereal)) : measure_theory.is_finite_measure h2 := sorry --non-trivial
lemma new_lemma_45312 (h0 : semiring (has_neg_part ennreal)) : is_noetherian_ring (has_neg_part ennreal) := sorry --non-trivial
lemma new_lemma_45313 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (pseudo_metric_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (pseudo_metric_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_45314 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (with_one.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (with_one.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_45315 (h1 : not (filter (add_monoid char) -> false)) : filter.ne_bot (classical.by_contradiction' h1) := sorry --non-trivial
lemma new_lemma_45316 (h1 : ring (has_append (comm_ring (random_gen (comm_ring reducibility_hints))))) : strong_rank_condition (has_append (comm_ring (random_gen (comm_ring reducibility_hints)))) := sorry --non-trivial
lemma new_lemma_45317 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @complete_space.{1} (normed_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 uniform_space.{1}) (normed_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_45318 (h0 : ring (free_add_monoid congr_arg_kind)) : is_principal_ideal_ring (free_add_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_45319 (h0 : functor.add_const (topological_space (finset Type)) Type) : @loc_path_connected_space.{1} (finset.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (finset.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_45320 (h0 : measurable_space (add_comm_semigroup (add_comm_semigroup char))) (h1 : measure_theory.measure (add_comm_semigroup (add_comm_semigroup char))) : measure_theory.is_finite_measure h1 := sorry --non-trivial
lemma new_lemma_45321 (h0 : topological_space (random_gen (with_bot string_imp))) : totally_disconnected_space (random_gen (with_bot string_imp)) := sorry --non-trivial
lemma new_lemma_45322 (h0 : function.extfun Type group) : @normalizer_condition.{0} (distrib_lattice.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} h0 (distrib_lattice.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_45323 (h0 : uniform_space (finset (option pos))) : complete_space (finset (option pos)) := sorry --non-trivial
lemma new_lemma_45324 (h0 : not (topological_space (topological_space (metric_space to_additive.value_type)) -> false)) : @totally_disconnected_space.{0} (topological_space.{0} (metric_space.{0} to_additive.value_type)) (@classical.by_contradiction'.{1} (topological_space.{0} (topological_space.{0} (metric_space.{0} to_additive.value_type))) h0)  := sorry --non-trivial
lemma new_lemma_45325 (h0 : topological_space (measurable_space (semiring (semiring empty)))) : preirreducible_space (measurable_space (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_45326 (h1 : function.extfun Type topological_space) : @irreducible_space.{0} (semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_45327 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (topological_space.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (topological_space.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_45328 (h0 : topological_space (has_to_string (has_add (has_pos_part name)))) : preconnected_space (has_to_string (has_add (has_pos_part name))) := sorry --non-trivial
lemma new_lemma_45329 (h0 : functor.add_const (monoid (semigroup Type)) pos) : @monoid.fg.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (monoid.{1} (semigroup.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_45330 (h0 : group (cancel_monoid (finset environment.implicit_infer_kind))) : normalizer_condition (cancel_monoid (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_45331 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (semiring.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_45332 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @totally_separated_space.{0} (has_Inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (has_Inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_45333 (h0 : ring (has_compl (has_nnnorm (has_nnnorm linarith.ineq)))) : is_domain (has_compl (has_nnnorm (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_45334 (h0 : group (has_pos_part (ring (has_add pos)))) : group.fg (has_pos_part (ring (has_add pos))) := sorry --non-trivial
lemma new_lemma_45335 (h0 : uniform_space (distrib_lattice (has_inv (has_inv (has_inv (has_inv linarith.comp_source)))))) : complete_space (distrib_lattice (has_inv (has_inv (has_inv (has_inv linarith.comp_source))))) := sorry --non-trivial
lemma new_lemma_45336 (h0 : functor.add_const (topological_space (has_nndist pos)) (finset Type)) : @totally_separated_space.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_nndist.{0} pos)) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_45337 (h0 : functor.add_const (complete_lattice (has_Sup congr_arg_kind)) congr_arg_kind) : @is_compactly_generated.{0} (has_Sup.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_Sup.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_45338 (h0 : filter (id (has_top linarith.comp))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_45339 (h0 : add_group (has_star (semiring num))) : is_add_cyclic (has_star (semiring num)) := sorry --non-trivial
lemma new_lemma_45340 (h0 : functor.add_const (uniform_space (generalized_boolean_algebra name)) (ring pos)) : @complete_space.{0} (generalized_boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (generalized_boolean_algebra.{0} name)) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_45341 (h0 : functor.add_const (complete_lattice (ordered_ring unsigned)) num) : @is_compactly_generated.{0} (ordered_ring.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ordered_ring.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_45342 (h0 : group (with_one (random_gen (has_nnnorm (has_nnnorm (has_nnnorm (has_top linarith.ineq))))))) : group.fg (with_one (random_gen (has_nnnorm (has_nnnorm (has_nnnorm (has_top linarith.ineq)))))) := sorry --non-trivial
lemma new_lemma_45343 (h0 : topological_space (topological_space char)) : t0_space (topological_space char) := sorry --non-trivial
lemma new_lemma_45344 (h0 : functor.add_const (function.extfun Type ring) pos) : @rank_condition.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) pos h0) (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_45345 (h0 : has_mem.mem group has_emptyc.emptyc) : @normalizer_condition.{0} (has_emptyc.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} h0) (has_emptyc.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_45346 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_45347 (h0 : not (topological_space (normed_group (random_gen (random_gen (has_top (has_nnnorm fun_info))))) -> false)) : @locally_compact_space.{0} (normed_group.{0} (random_gen.{0} (random_gen.{0} (has_top.{0} (has_nnnorm.{0} fun_info))))) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_group.{0} (random_gen.{0} (random_gen.{0} (has_top.{0} (has_nnnorm.{0} fun_info)))))) h0)  := sorry --non-trivial
lemma new_lemma_45348 (h0 : filter (finset (ring Type))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_45349 (h0 : add_group (has_le linarith.ineq)) : is_add_cyclic (has_le linarith.ineq) := sorry --non-trivial
lemma new_lemma_45350 (h0 : function.extfun Type group) : @group.fg.{0} string_imp (@function.extfun_app.{2 1} Type group.{0} h0 string_imp)  := sorry --non-trivial
lemma new_lemma_45351 (h0 : functor.add_const (topological_space (has_add pos)) pos) : @t0_space.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_45352 (h0 : function.extfun Type topological_space) : @normal_space.{0} (has_add.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} real))  := sorry --non-trivial
lemma new_lemma_45353 (h0 : monoid (random_gen (has_norm (has_norm fun_info)))) : monoid.fg (random_gen (has_norm (has_norm fun_info))) := sorry --non-trivial
lemma new_lemma_45354 (h1 : topological_space (random_gen linarith.ineq)) : locally_compact_space (random_gen linarith.ineq) := sorry --non-trivial
lemma new_lemma_45355 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_zero pos)) (has_neg Type)) : @unique_factorization_monoid.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 1} (cancel_comm_monoid_with_zero.{0} (has_zero.{0} pos)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_45356 (h0 : uniform_space (has_dist (option (option (option (option unsigned)))))) : complete_space (has_dist (option (option (option (option unsigned))))) := sorry --non-trivial
lemma new_lemma_45357 (h0 : complete_lattice (uniform_space enat)) : complete_lattice.is_Sup_finite_compact (uniform_space enat) := sorry --non-trivial
lemma new_lemma_45358 (h0 : ring (complete_distrib_lattice (ordered_comm_monoid (has_scalar Type Type)))) : rank_condition (complete_distrib_lattice (ordered_comm_monoid (has_scalar Type Type))) := sorry --non-trivial
lemma new_lemma_45359 (h0 : add_group (has_pos_part num)) : is_add_cyclic (has_pos_part num) := sorry --non-trivial
lemma new_lemma_45360 (h0 : topological_space (boolean_algebra (has_add name))) : loc_path_connected_space (boolean_algebra (has_add name)) := sorry --non-trivial
lemma new_lemma_45361 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (semiring.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semiring.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_45362 (h0 : functor.add_const (topological_space (boolean_algebra.core environment.implicit_infer_kind)) linarith.comp) : @topological_space.separable_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_45363 (h0 : cancel_comm_monoid_with_zero (canonically_ordered_monoid (has_Inf (has_bot real)))) : unique_factorization_monoid (canonically_ordered_monoid (has_Inf (has_bot real))) := sorry --non-trivial
lemma new_lemma_45364 (h1 : topological_space (semiring (random_gen to_additive.value_type))) : totally_separated_space (semiring (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_45365 (h0 : topological_space (add_group congr_arg_kind)) : locally_compact_space (add_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_45366 (h0 : finset (sub_neg_monoid empty)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_45367 (h1 : prod fun_info fun_info) : set.diagonal fun_info h1 := sorry --non-trivial
lemma new_lemma_45368 (h0 : uniform_space (preorder (option unsigned))) : complete_space (preorder (option unsigned)) := sorry --non-trivial
lemma new_lemma_45369 (h0 : add_monoid (has_neg (has_add Type))) : add_monoid.fg (has_neg (has_add Type)) := sorry --non-trivial
lemma new_lemma_45370 (h0 : semiring (measurable_space.dynkin_system (semiring empty))) : is_noetherian_ring (measurable_space.dynkin_system (semiring empty)) := sorry --non-trivial
lemma new_lemma_45371 (h0 : functor.add_const (topological_space (semigroup congr_arg_kind)) empty) : @totally_disconnected_space.{0} (semigroup.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_45372 (h0 : ordered_comm_monoid (has_nndist (finset (normed_comm_ring (finset linarith.comp))))) : has_exists_mul_of_le (has_nndist (finset (normed_comm_ring (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_45373 (h0 : functor.add_const (topological_space (ordered_comm_ring linarith.comp)) pos) : @preirreducible_space.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_45374 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (linear_ordered_field.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_field.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_45375 (h0 : topological_space (normed_comm_ring (normed_comm_ring name))) : irreducible_space (normed_comm_ring (normed_comm_ring name)) := sorry --non-trivial
lemma new_lemma_45376 (h2 : add_group (add_monoid fun_info)) : is_add_cyclic (add_monoid fun_info) := sorry --non-trivial
lemma new_lemma_45377 (h0 : monoid (has_neg linarith.comp)) : monoid.fg (has_neg linarith.comp) := sorry --non-trivial
lemma new_lemma_45378 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (canonically_linear_ordered_monoid name)) := sorry --non-trivial
lemma new_lemma_45379 (h0 : functor.add_const (functor.add_const Prop (ring linarith.comp)) environment.implicit_infer_kind) : functor.add_const.run (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_45380 (h2 : uniform_space (denumerable reducibility_hints)) : complete_space (denumerable reducibility_hints) := sorry --non-trivial
lemma new_lemma_45381 (h1 : not (complete_lattice (add_cancel_comm_monoid string_imp) -> false)) : @is_compactly_generated.{0} (add_cancel_comm_monoid.{0} string_imp) (@classical.by_contradiction'.{1} (complete_lattice.{0} (add_cancel_comm_monoid.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_45382 (h0 : topological_space (add_group (semiring (semiring (semiring (semiring linarith.comp)))))) : irreducible_space (add_group (semiring (semiring (semiring (semiring linarith.comp))))) := sorry --non-trivial
lemma new_lemma_45383 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_45384 (h0 : topological_space (finset (has_pos_part (has_neg linarith.comp)))) : irreducible_space (finset (has_pos_part (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_45385 (h0 : topological_space (add_left_cancel_monoid fun_info)) : path_connected_space (add_left_cancel_monoid fun_info) := sorry --non-trivial
lemma new_lemma_45386 (h0 : not (function.extfun (finset Type) (has_mem.mem (with_one empty)) -> false)) : @is_add_cyclic.{0} (with_one.{0} empty) (@finset.pi.empty.{1 0} Type add_group.{0} (with_one.{0} empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_one.{0} empty)) (@classical.by_contradiction'.{0} (function.extfun.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_one.{0} empty))) h0) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_45387 (h0 : add_group (monoid unsigned)) : is_add_cyclic (monoid unsigned) := sorry --non-trivial
lemma new_lemma_45388 (h0 : topological_space (ring (ring linarith.comp))) : totally_separated_space (ring (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_45389 (h0 : functor.add_const (monoid (normed_comm_ring name)) (cancel_monoid (cancel_monoid environment.implicit_infer_kind))) : @monoid.fg.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (monoid.{0} (normed_comm_ring.{0} name)) (cancel_monoid.{0} (cancel_monoid.{0} environment.implicit_infer_kind)) h0)  := sorry --non-trivial
lemma new_lemma_45390 (h0 : fin has_zero.zero) : @is_noetherian_ring.{0} (canonically_ordered_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (semiring.{0} (canonically_ordered_monoid.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_45391 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (with_bot.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (with_bot.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_45392 (h0 : ring (ordered_comm_ring (has_add (has_add (has_nndist pos))))) : is_domain (ordered_comm_ring (has_add (has_add (has_nndist pos)))) := sorry --non-trivial
lemma new_lemma_45393 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (add_comm_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_comm_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_45394 (h0 : add_group (metric_space (has_norm linarith.comp))) : is_add_cyclic (metric_space (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_45395 (h0 : topological_space (non_unital_non_assoc_semiring linarith.ineq)) : t0_space (non_unital_non_assoc_semiring linarith.ineq) := sorry --non-trivial
lemma new_lemma_45396 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (has_union.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_union.{0} empty))  := sorry --non-trivial
lemma new_lemma_45397 (h0 : filter (mul_zero_class pos)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_45398 (h0 : preorder (linear_ordered_field congr_arg_kind)) (h1 : topological_space (linear_ordered_field congr_arg_kind)) : Inf_convergence_class (linear_ordered_field congr_arg_kind) := sorry --non-trivial
lemma new_lemma_45399 (h0 : functor.add_const (list (semigroup pos)) (has_neg (has_neg (has_neg linarith.comp)))) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_45400 (h0 : ring (with_one (has_inv (random_gen (random_gen (comm_ring to_additive.value_type)))))) : is_domain (with_one (has_inv (random_gen (random_gen (comm_ring to_additive.value_type))))) := sorry --non-trivial
lemma new_lemma_45401 (h0 : group (denumerable linarith.ineq)) : is_cyclic (denumerable linarith.ineq) := sorry --non-trivial
lemma new_lemma_45402 (h0 : complete_lattice (distrib to_additive.value_type)) : complete_lattice.is_Sup_finite_compact (distrib to_additive.value_type) := sorry --non-trivial
lemma new_lemma_45403 (h0 : topological_space (has_pos_part (has_neg (has_neg real)))) : totally_separated_space (has_pos_part (has_neg (has_neg real))) := sorry --non-trivial
lemma new_lemma_45404 (h0 : topological_space (has_compl (random_gen string_imp))) : path_connected_space (has_compl (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_45405 (h0 : functor.add_const (group (comm_group pos)) ennreal) : @is_simple_group.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (comm_group.{0} pos)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_45406 (h0 : functor.add_const (topological_space (has_zero pos)) pos) : @path_connected_space.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_45407 (h0 : group (cancel_monoid (semigroup (semigroup name)))) : is_simple_group (cancel_monoid (semigroup (semigroup name))) := sorry --non-trivial
lemma new_lemma_45408 (h0 : ring (semi_normed_ring (denumerable char))) : rank_condition (semi_normed_ring (denumerable char)) := sorry --non-trivial
lemma new_lemma_45409 (h0 : functor.add_const (topological_space (canonically_ordered_monoid pos)) linarith.comp) : @preirreducible_space.{0} (canonically_ordered_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_monoid.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_45410 (h0 : topological_space (with_bot (has_top linarith.ineq))) : path_connected_space (with_bot (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_45411 (h0 : add_group (add_comm_monoid (finset (has_neg_part Type)))) : is_add_cyclic (add_comm_monoid (finset (has_neg_part Type))) := sorry --non-trivial
lemma new_lemma_45412 (h0 : ring (has_nnnorm (boolean_algebra.core linarith.ineq))) : is_domain (has_nnnorm (boolean_algebra.core linarith.ineq)) := sorry --non-trivial
lemma new_lemma_45413 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (ring.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_45414 (h0 : ring (has_to_string (ring name))) : strong_rank_condition (has_to_string (ring name)) := sorry --non-trivial
lemma new_lemma_45415 (h0 : functor.add_const (semiring (has_zero linarith.comp)) Type) : @is_noetherian_ring.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 1} (semiring.{0} (has_zero.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_45416 (h0 : semiring (comm_monoid unsigned)) : is_noetherian_ring (comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_45417 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_compactly_generated.{0} (random_gen.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (random_gen.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_45418 (h0 : function.extfun Type ring) : @is_domain.{0} (canonically_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (canonically_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_45419 (h0 : topological_space (has_neg_part (has_to_string ennreal))) : totally_separated_space (has_neg_part (has_to_string ennreal)) := sorry --non-trivial
lemma new_lemma_45420 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (ring pos)) := sorry --non-trivial
lemma new_lemma_45421 (h0 : set.set_semiring (linear_ordered_cancel_comm_monoid empty)) (h1 : functor.add_const (linear_ordered_cancel_comm_monoid empty) unsigned) : set.set_semiring.down h0 (functor.add_const.run h1) := sorry --non-trivial
lemma new_lemma_45422 (h1 : ring (has_compl std_gen)) : strong_rank_condition (has_compl std_gen) := sorry --non-trivial
lemma new_lemma_45423 (h0 : functor.add_const (add_group (add_comm_monoid linarith.comp)) pos) : @is_add_cyclic.{0} (add_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_group.{0} (add_comm_monoid.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_45424 (h0 : topological_space (has_add (has_add congr_arg_kind))) : normal_space (has_add (has_add congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_45425 (h0 : complete_lattice (has_nnnorm (random_gen to_additive.value_type))) : complete_lattice.is_Sup_finite_compact (has_nnnorm (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_45426 (h0 : semiring (ring pos)) : is_noetherian_ring (ring pos) := sorry --non-trivial
lemma new_lemma_45427 (h0 : functor.add_const (topological_space (option congr_arg_kind)) num) : @t0_space.{0} (option.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_45428 (h0 : topological_space (topological_space reducibility_hints)) : t0_space (topological_space reducibility_hints) := sorry --non-trivial
lemma new_lemma_45429 (h0 : group (has_neg (has_to_string (has_to_string Type)))) : is_cyclic (has_neg (has_to_string (has_to_string Type))) := sorry --non-trivial
lemma new_lemma_45430 (h0 : functor.add_const (topological_space (ordered_comm_ring name)) linarith.comp) : @loc_path_connected_space.{0} (ordered_comm_ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_45431 (h0 : topological_space (boolean_algebra (has_pos_part (finset pos)))) : normal_space (boolean_algebra (has_pos_part (finset pos))) := sorry --non-trivial
lemma new_lemma_45432 (h0 : not (uniform_space (plift congr_arg_kind) -> false)) : @complete_space.{1} (plift.{1} congr_arg_kind) (@classical.by_contradiction'.{2} (uniform_space.{1} (plift.{1} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_45433 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (finset.{0} ennreal) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (finset.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_45434 (h0 : functor.add_const (topological_space (has_to_string Type)) linarith.comp) : @sequential_space.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_to_string.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_45435 (h0 : topological_space (linear_ordered_comm_group (option unsigned))) : path_connected_space (linear_ordered_comm_group (option unsigned)) := sorry --non-trivial
lemma new_lemma_45436 (h0 : uniform_space (semiring (has_top (random_gen num)))) : separated_space (semiring (has_top (random_gen num))) := sorry --non-trivial
lemma new_lemma_45437 (h0 : functor.add_const (topological_space (add_cancel_monoid Type)) name) : @regular_space.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_cancel_monoid.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_45438 (h0 : group (has_top (has_norm (random_gen num)))) : is_cyclic (has_top (has_norm (random_gen num))) := sorry --non-trivial
lemma new_lemma_45439 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @archimedean.{0} (complete_distrib_lattice.{0} num) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) ordered_add_comm_monoid.{0}) (complete_distrib_lattice.{0} num))  := sorry --non-trivial
lemma new_lemma_45440 (h0 : ordered_add_comm_monoid (has_pos_part name)) : archimedean (has_pos_part name) := sorry --non-trivial
lemma new_lemma_45441 (h0 : ring (add_left_cancel_semigroup congr_arg_kind)) : rank_condition (add_left_cancel_semigroup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_45442 (h0 : filter (comm_group (option (option (option (comm_group (option (option (option (option (option pos))))))))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_45443 (h0 : ring (has_add (has_add pos))) : strong_rank_condition (has_add (has_add pos)) := sorry --non-trivial
lemma new_lemma_45444 (h0 : has_mem.mem (with_one (has_norm fun_info)) has_emptyc.emptyc) : filter.ne_bot (finset.pi.empty filter (with_one (has_norm fun_info)) h0) := sorry --non-trivial
lemma new_lemma_45445 (h0 : functor.add_const (topological_space (has_pos_part linarith.comp)) pos) : @irreducible_space.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_45446 (h0 : functor.comp ring mul_zero_class ennreal) : @is_principal_ideal_ring.{0} (mul_zero_class.{0} ennreal) (@functor.comp.run.{0 0 0} ring.{0} mul_zero_class.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_45447 (h0 : topological_space (semigroup (canonically_ordered_comm_semiring (comm_group (has_neg_part num))))) : normal_space (semigroup (canonically_ordered_comm_semiring (comm_group (has_neg_part num)))) := sorry --non-trivial
lemma new_lemma_45448 (h1 : group (random_gen linarith.ineq)) : normalizer_condition (random_gen linarith.ineq) := sorry --non-trivial
lemma new_lemma_45449 (h0 : list (has_zero (finset (finset (finset name))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_45450 (h0 : uniform_space (complete_distrib_lattice Type)) : separated_space (complete_distrib_lattice Type) := sorry --non-trivial
lemma new_lemma_45451 (h0 : add_comm_group (with_bot linarith.comp_source)) (h1 : has_norm (with_bot linarith.comp_source)) : normed_group.core (with_bot linarith.comp_source) := sorry --non-trivial
lemma new_lemma_45452 (h0 : functor.add_const (finset (has_Inf linarith.comp)) linarith.comp) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_45453 (h0 : not (group (has_ssubset to_additive.value_type) -> false)) : @is_cyclic.{0} (has_ssubset.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (group.{0} (has_ssubset.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_45454 (h1 : add_group (has_ssubset linarith.comp_source)) : is_add_cyclic (has_ssubset linarith.comp_source) := sorry --non-trivial
lemma new_lemma_45455 (h1 : monoid (id string_imp)) : monoid.fg (id string_imp) := sorry --non-trivial
lemma new_lemma_45456 (h0 : ring (ordered_cancel_comm_monoid char)) : is_domain (ordered_cancel_comm_monoid char) := sorry --non-trivial
lemma new_lemma_45457 (h0 : cancel_comm_monoid_with_zero (has_zero (has_neg pos))) : unique_factorization_monoid (has_zero (has_neg pos)) := sorry --non-trivial
lemma new_lemma_45458 (h0 : fin has_zero.zero) : @complete_space.{0} (canonically_linear_ordered_monoid.{0} real) (@matrix.vec_empty.{0} (uniform_space.{0} (canonically_linear_ordered_monoid.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_45459 (h0 : group (add_left_cancel_monoid (has_nnnorm linarith.ineq))) : is_cyclic (add_left_cancel_monoid (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_45460 (h0 : filter (with_zero to_additive.value_type)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_45461 (h0 : complete_lattice (has_zero (has_neg_part unsigned))) : is_compactly_generated (has_zero (has_neg_part unsigned)) := sorry --non-trivial
lemma new_lemma_45462 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (with_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (with_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_45463 (h0 : functor.add_const (complete_lattice (linear_ordered_comm_monoid_with_zero empty)) empty) : @is_atomistic.{0} (linear_ordered_comm_monoid_with_zero.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (linear_ordered_comm_monoid_with_zero.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_45464 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @is_cyclic.{0} (monoid.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) group.{0}) (monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_45465 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (has_neg.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_45466 (h0 : ring (ordered_cancel_add_comm_monoid (option ennreal))) : is_domain (ordered_cancel_add_comm_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_45467 (h0 : functor.add_const (add_monoid (has_Inf Type)) Type) : @add_monoid.fg.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 1} (add_monoid.{1} (has_Inf.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_45468 (h0 : group (canonically_ordered_comm_semiring (ring linarith.comp))) : group.fg (canonically_ordered_comm_semiring (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_45469 (h0 : ring (generalized_boolean_algebra (has_add (sub_neg_monoid Type)))) : is_principal_ideal_ring (generalized_boolean_algebra (has_add (sub_neg_monoid Type))) := sorry --non-trivial
lemma new_lemma_45470 (h0 : monoid (pseudo_metric_space (option unsigned))) : monoid.fg (pseudo_metric_space (option unsigned)) := sorry --non-trivial
lemma new_lemma_45471 (h0 : topological_space (option unsigned)) : irreducible_space (option unsigned) := sorry --non-trivial
lemma new_lemma_45472 (h0 : ring (non_unital_non_assoc_semiring (mul_one_class reducibility_hints))) : is_domain (non_unital_non_assoc_semiring (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_45473 (h0 : topological_space (has_add (ordered_ring (has_Inf name)))) : sequential_space (has_add (ordered_ring (has_Inf name))) := sorry --non-trivial
lemma new_lemma_45474 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (add_right_cancel_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_45475 (h0 : filter (boolean_algebra.core (comm_group unsigned))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_45476 (h0 : complete_lattice (normed_group (random_gen (random_gen linarith.ineq)))) : is_atomistic (normed_group (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_45477 (h0 : functor.add_const (topological_space (normed_comm_ring num)) pos) : @loc_path_connected_space.{0} (normed_comm_ring.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} num)) pos h0)  := sorry --non-trivial
lemma new_lemma_45478 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (canonically_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type add_group.{0} h0 (canonically_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_45479 (h0 : Prop -> has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm char)))))))) (h1 : coe_sort (set.range h0)) : set.range_splitting h0 h1 := sorry --non-trivial
lemma new_lemma_45480 (h1 : topological_space (nondiscrete_normed_field ereal)) : t0_space (nondiscrete_normed_field ereal) := sorry --non-trivial
lemma new_lemma_45481 (h0 : group (generalized_boolean_algebra (has_neg Type))) : is_simple_group (generalized_boolean_algebra (has_neg Type)) := sorry --non-trivial
lemma new_lemma_45482 (h0 : topological_space (add_cancel_monoid ennreal)) : loc_path_connected_space (add_cancel_monoid ennreal) := sorry --non-trivial
lemma new_lemma_45483 (h0 : functor.add_const (group (has_zero environment.implicit_infer_kind)) Type) : @is_simple_group.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (group.{0} (has_zero.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_45484 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (mul_zero_class (has_neg_part ennreal))) := sorry --non-trivial
lemma new_lemma_45485 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (ordered_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_45486 (h0 : function.extfun Type group) : @is_simple_group.{0} (has_neg.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (has_neg.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_45487 (h0 : functor.add_const (complete_lattice (ordered_comm_ring Type)) pos) : @is_atomistic.{1} (ordered_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (ordered_comm_ring.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_45488 (h0 : functor.add_const (cancel_comm_monoid_with_zero (add_group unsigned)) congr_arg_kind) : @unique_factorization_monoid.{0} (add_group.{0} unsigned) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (add_group.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_45489 (h0 : functor.add_const (function.extfun (Type 1) group) Type) : @group.fg.{1} (normed_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) group.{1}) Type h0) (normed_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_45490 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (add_comm_monoid empty)) := sorry --non-trivial
lemma new_lemma_45491 (h0 : complete_lattice (left_cancel_monoid (semiring (semiring unsigned)))) : is_compactly_generated (left_cancel_monoid (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_45492 (h0 : not (uniform_space (measurable_space.dynkin_system linarith.comp) -> false)) : @complete_space.{0} (measurable_space.dynkin_system.{0} linarith.comp) (@classical.by_contradiction'.{1} (uniform_space.{0} (measurable_space.dynkin_system.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_45493 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (linear_ordered_comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_45494 (h0 : topological_space (semigroup (semiring (option unsigned)))) : totally_separated_space (semigroup (semiring (option unsigned))) := sorry --non-trivial
lemma new_lemma_45495 (h0 : function.extfun Type group) : @is_cyclic.{0} (random_gen.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} h0 (random_gen.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_45496 (h0 : complete_lattice (complete_distrib_lattice Type)) : is_compactly_generated (complete_distrib_lattice Type) := sorry --non-trivial
lemma new_lemma_45497 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (with_bot unsigned)) := sorry --non-trivial
lemma new_lemma_45498 (h0 : functor.add_const (topological_space (semiring unsigned)) empty) : @loc_path_connected_space.{0} (semiring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (semiring.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_45499 (h0 : functor.add_const (topological_space (has_edist unsigned)) unsigned) : @discrete_topology.{0} (has_edist.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_edist.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_45500 (h0 : topological_space (has_compl (mul_one_class enat))) : t1_space (has_compl (mul_one_class enat)) := sorry --non-trivial
lemma new_lemma_45501 (h0 : set (simple_graph enat)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_45502 (h0 : functor.add_const (function.extfun nat fin) Type) : @group.fg.{0} (normed_lattice_add_comm_group.{0} pos) (@matrix.vec_empty.{0} (group.{0} (normed_lattice_add_comm_group.{0} pos)) (@function.extfun_app.{1 1} nat fin (@functor.add_const.run.{0 1} (function.extfun.{1 1} nat fin) Type h0) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_45503 (h0 : complete_lattice (has_to_string (ring linarith.comp))) : complete_lattice.is_Sup_finite_compact (has_to_string (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_45504 (h0 : functor.add_const (topological_space (semigroup unsigned)) environment.implicit_infer_kind) : @regular_space.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_45505 (h0 : function.extfun Type group) : @is_cyclic.{0} (linear_order.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (linear_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_45506 (h0 : ring (has_inv (random_gen char))) : is_domain (has_inv (random_gen char)) := sorry --non-trivial
lemma new_lemma_45507 (h1 : complete_lattice (non_unital_non_assoc_semiring ereal)) : is_compactly_generated (non_unital_non_assoc_semiring ereal) := sorry --non-trivial
lemma new_lemma_45508 (h0 : not (uniform_space (linear_ordered_comm_ring congr_arg_kind) -> false)) : @separated_space.{0} (linear_ordered_comm_ring.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (uniform_space.{0} (linear_ordered_comm_ring.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_45509 (h0 : group (free_add_monoid (option unsigned))) : normalizer_condition (free_add_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_45510 (h0 : functor.add_const (topological_space (cancel_monoid empty)) ennreal) : @locally_compact_space.{0} (cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} empty)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_45511 (h0 : list (linear_ordered_field (option (option (option (option (option empty))))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_45512 (h0 : list (semiring (semiring congr_arg_kind))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_45513 (h0 : functor.add_const (function.extfun Type filter) (ring (ring Type))) : filter.ne_bot (function.extfun_app (functor.add_const.run h0) (comm_group name)) := sorry --non-trivial
lemma new_lemma_45514 (h0 : topological_space (ordered_comm_monoid (ring (boolean_algebra.core (ordered_comm_monoid Type))))) : t0_space (ordered_comm_monoid (ring (boolean_algebra.core (ordered_comm_monoid Type)))) := sorry --non-trivial
lemma new_lemma_45515 (h0 : function.extfun Type (functor.comp topological_space semigroup)) : @sequential_space.{0} (semigroup.{0} (has_nndist.{0} pos)) (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} semigroup.{0}) h0 (has_nndist.{0} pos)))  := sorry --non-trivial
lemma new_lemma_45516 (h0 : topological_space (monoid unsigned)) : preirreducible_space (monoid unsigned) := sorry --non-trivial
lemma new_lemma_45517 (h0 : semiring (add_comm_monoid (has_add linarith.comp))) : is_noetherian_ring (add_comm_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_45518 (h0 : functor.add_const (group (normed_linear_ordered_group unsigned)) empty) : @normalizer_condition.{0} (normed_linear_ordered_group.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (normed_linear_ordered_group.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_45519 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @normal_space.{1} (has_neg_part.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} has_neg_part.{1} Type (@function.extfun_app.{3 2} (Type 1) (functor.comp.{1 1 1} topological_space.{1} has_neg_part.{1}) (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 (functor.comp.{1 1 1} topological_space.{1} has_neg_part.{1})) Type))  := sorry --non-trivial
lemma new_lemma_45520 (h0 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} (has_norm.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_norm.{0} empty))  := sorry --non-trivial
lemma new_lemma_45521 (h0 : functor.add_const (add_group (has_neg environment.implicit_infer_kind)) pos) : @is_add_cyclic.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (add_group.{0} (has_neg.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_45522 (h0 : not (complete_lattice (dlist linarith.ineq) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (dlist.{0} linarith.ineq) (@classical.by_contradiction'.{1} (complete_lattice.{0} (dlist.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_45523 (h0 : set (has_compl (mul_one_class (mul_one_class char)))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_45524 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_top.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_top.{0} empty))  := sorry --non-trivial
lemma new_lemma_45525 (h0 : complete_lattice (has_compl (metric_space char))) : is_compactly_generated (has_compl (metric_space char)) := sorry --non-trivial
lemma new_lemma_45526 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_union.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_union.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_45527 (h0 : topological_space (boolean_algebra (comm_group unsigned))) : discrete_topology (boolean_algebra (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_45528 (h0 : functor.add_const (ordered_add_comm_monoid znum) unsigned) : @archimedean.{0} znum (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} znum) unsigned h0)  := sorry --non-trivial
lemma new_lemma_45529 (h0 : functor.add_const (uniform_space (bin_tree empty)) unsigned) : @separated_space.{0} (bin_tree.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (bin_tree.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_45530 (h2 : complete_lattice (denumerable (comm_ring linarith.comp_source))) : complete_lattice.is_Sup_finite_compact (denumerable (comm_ring linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_45531 (h0 : functor.add_const (topological_space (add_comm_monoid name)) pos) : @topological_space.separable_space.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_45532 (h0 : functor.add_const (group Type) (has_neg Type)) : @group.fg.{1} Type (@functor.add_const.run.{1 1} (group.{1} Type) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_45533 (h0 : topological_space (canonically_ordered_comm_semiring (has_add name))) : t0_space (canonically_ordered_comm_semiring (has_add name)) := sorry --non-trivial
lemma new_lemma_45534 (h0 : group (complete_linear_order (semiring (semiring unsigned)))) : group.fg (complete_linear_order (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_45535 (h0 : functor.add_const (filter (mul_zero_class ennreal)) name) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_45536 (h0 : topological_space (non_assoc_semiring (semiring unsigned))) : totally_separated_space (non_assoc_semiring (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_45537 (h0 : ordered_add_comm_monoid (canonically_ordered_monoid (has_Inf (has_Inf (sub_neg_monoid Type))))) : archimedean (canonically_ordered_monoid (has_Inf (has_Inf (sub_neg_monoid Type)))) := sorry --non-trivial
lemma new_lemma_45538 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_emptyc.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_emptyc.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_45539 (h0 : not (topological_space (has_one congr_arg_kind) -> false)) : @normal_space.{0} (has_one.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (has_one.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_45540 (h0 : topological_space (add_cancel_monoid (comm_group pos))) : totally_separated_space (add_cancel_monoid (comm_group pos)) := sorry --non-trivial
lemma new_lemma_45541 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_45542 (h0 : add_group (boolean_algebra (has_neg_part (has_add environment.implicit_infer_kind)))) : is_add_cyclic (boolean_algebra (has_neg_part (has_add environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_45543 (h0 : topological_space (finset unsigned)) : loc_path_connected_space (finset unsigned) := sorry --non-trivial
lemma new_lemma_45544 (h0 : complete_lattice (ring (ring Type))) : is_compactly_generated (ring (ring Type)) := sorry --non-trivial
lemma new_lemma_45545 (h0 : topological_space (boolean_algebra (has_neg real))) : t0_space (boolean_algebra (has_neg real)) := sorry --non-trivial
lemma new_lemma_45546 (h0 : functor.add_const (topological_space (cancel_monoid pos)) linarith.comp) : @locally_compact_space.{0} (cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_45547 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (distrib_lattice.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (distrib_lattice.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_45548 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_add.{0} real) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_add.{0} real))  := sorry --non-trivial
lemma new_lemma_45549 (h0 : cancel_comm_monoid_with_zero (has_neg (option (option (option (option (option ennreal))))))) : unique_factorization_monoid (has_neg (option (option (option (option (option ennreal)))))) := sorry --non-trivial
lemma new_lemma_45550 (h0 : simple_graph unsigned -> simple_graph unsigned -> Prop) : is_total_preorder (simple_graph unsigned) h0 := sorry --non-trivial
lemma new_lemma_45551 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @irreducible_space.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_45552 (h0 : topological_space (semi_normed_ring (mul_one_class linarith.ineq))) : t0_space (semi_normed_ring (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_45553 (h0 : list (ordered_cancel_add_comm_monoid (option empty))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_45554 (h0 : ordered_add_comm_monoid (option (option (option pos)))) : archimedean (option (option (option pos))) := sorry --non-trivial
lemma new_lemma_45555 (h0 : function.extfun (Type 1) (functor.add_const (uniform_space (comm_group linarith.comp)))) : @complete_space.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 1} (uniform_space.{0} (comm_group.{0} linarith.comp)) Type (@function.extfun_app.{3 1} (Type 1) (functor.add_const.{0 1} (uniform_space.{0} (comm_group.{0} linarith.comp))) h0 Type))  := sorry --non-trivial
lemma new_lemma_45556 (h0 : functor.add_const (group (semigroup Type)) (has_add pos)) : @is_cyclic.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (semigroup.{1} Type)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_45557 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (complete_linear_order.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_linear_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_45558 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (ordered_ring.{0} (semiring.{0} (semiring.{0} (semiring.{0} unsigned)))) (@function.extfun_app.{2 1} Type ring.{0} h0 (ordered_ring.{0} (semiring.{0} (semiring.{0} (semiring.{0} unsigned)))))  := sorry --non-trivial
lemma new_lemma_45559 (h0 : functor.add_const (topological_space (ordered_ring congr_arg_kind)) (semiring num)) : @preirreducible_space.{0} (ordered_ring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} congr_arg_kind)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_45560 (h0 : fin has_zero.zero) : @preirreducible_space.{0} (ordered_comm_ring.{0} name) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_ring.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_45561 (h0 : ordered_add_comm_monoid (group_with_zero (option empty))) : archimedean (group_with_zero (option empty)) := sorry --non-trivial
lemma new_lemma_45562 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (add_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (add_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_45563 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (add_cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_45564 (h0 : complete_lattice (random_gen (semiring (metric_space empty)))) : complete_lattice.is_Sup_finite_compact (random_gen (semiring (metric_space empty))) := sorry --non-trivial
lemma new_lemma_45565 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (add_cancel_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (add_cancel_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_45566 (h0 : filter (boolean_algebra (finset (finset pos)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_45567 (h0 : monoid (semigroup (mul_one_class pos))) : monoid.fg (semigroup (mul_one_class pos)) := sorry --non-trivial
lemma new_lemma_45568 (h0 : functor.add_const (topological_space (has_add linarith.comp)) (has_neg Type)) : @normal_space.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_add.{0} linarith.comp)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_45569 (h0 : group (semiring (random_gen (random_gen congr_arg_kind)))) : is_cyclic (semiring (random_gen (random_gen congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_45570 (h1 : nat -> add_group (distrib ereal) -> add_group (distrib ereal)) (h2 : nat) (h3 : add_group (distrib ereal)) : is_add_cyclic (distrib ereal) := sorry --non-trivial
lemma new_lemma_45571 (h0 : complete_lattice (ring empty)) : is_compactly_generated (ring empty) := sorry --non-trivial
lemma new_lemma_45572 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (ordered_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_45573 (h2 : ring (with_one num)) : is_domain (with_one num) := sorry --non-trivial
lemma new_lemma_45574 (h0 : functor.add_const (complete_lattice (normed_comm_ring linarith.comp)) Type) : @is_compactly_generated.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (complete_lattice.{0} (normed_comm_ring.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_45575 (h0 : finset (monoid ennreal)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_45576 (h0 : function.extfun Type group) : @is_cyclic.{0} (ordered_comm_ring.{0} name) (@function.extfun_app.{2 1} Type group.{0} h0 (ordered_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_45577 (h0 : group (has_emptyc (with_bot (with_bot (with_bot (with_bot to_additive.value_type)))))) : normalizer_condition (has_emptyc (with_bot (with_bot (with_bot (with_bot to_additive.value_type))))) := sorry --non-trivial
lemma new_lemma_45578 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (with_one.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (with_one.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_45579 (h0 : functor.add_const (ring (has_add linarith.comp)) name) : @strong_rank_condition.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_add.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_45580 (h0 : group (boolean_algebra (has_pos_part Type))) : group.fg (boolean_algebra (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_45581 (h1 : filter (fintype (random_gen char))) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_45582 (h0 : monoid (has_to_string (option ennreal))) : monoid.fg (has_to_string (option ennreal)) := sorry --non-trivial
lemma new_lemma_45583 (h0 : functor.comp topological_space has_nndist environment.implicit_infer_kind) : @t1_space.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_45584 (h1 : function.extfun Type group) : @is_cyclic.{0} to_additive.value_type (@function.extfun_app.{2 1} Type group.{0} h1 to_additive.value_type)  := sorry --non-trivial
lemma new_lemma_45585 (h0 : topological_space (simple_graph (mul_one_class linarith.ineq))) : totally_disconnected_space (simple_graph (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_45586 (h0 : complete_lattice (normed_group (has_inv (random_gen (has_top to_additive.value_type))))) : is_compactly_generated (normed_group (has_inv (random_gen (has_top to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_45587 (h0 : functor.add_const (topological_space (semigroup name)) environment.implicit_infer_kind) : @discrete_topology.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_45588 (h0 : group (has_to_string (has_to_string (has_nndist pos)))) : normalizer_condition (has_to_string (has_to_string (has_nndist pos))) := sorry --non-trivial
lemma new_lemma_45589 (h0 : group (add_group (has_norm (semiring (semiring (semiring congr_arg_kind)))))) : is_cyclic (add_group (has_norm (semiring (semiring (semiring congr_arg_kind))))) := sorry --non-trivial
lemma new_lemma_45590 (h0 : not (has_neg (with_bot congr_arg_kind) -> false)) (h1 : measurable_space (with_bot congr_arg_kind)) : @has_measurable_neg.{0} (with_bot.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (has_neg.{0} (with_bot.{0} congr_arg_kind)) h0) h1  := sorry --non-trivial
lemma new_lemma_45591 (h0 : group (finset ennreal)) : normalizer_condition (finset ennreal) := sorry --non-trivial
lemma new_lemma_45592 (h0 : complete_lattice (has_div string.iterator_imp)) : complete_lattice.is_Sup_finite_compact (has_div string.iterator_imp) := sorry --non-trivial
lemma new_lemma_45593 (h0 : topological_space (normed_group (random_gen (has_inv (has_inv linarith.ineq))))) : totally_separated_space (normed_group (random_gen (has_inv (has_inv linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_45594 (h0 : not (topological_space (simple_graph char) -> false)) : @path_connected_space.{0} (simple_graph.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (simple_graph.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_45595 (h0 : list (with_bot (random_gen to_additive.value_type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_45596 (h0 : topological_space (boolean_algebra (has_add Type))) : preirreducible_space (boolean_algebra (has_add Type)) := sorry --non-trivial
lemma new_lemma_45597 (h0 : complete_lattice (uniform_space (has_nnnorm enat))) : complete_lattice.is_Sup_finite_compact (uniform_space (has_nnnorm enat)) := sorry --non-trivial
lemma new_lemma_45598 (h0 : group (boolean_algebra (has_neg (finset linarith.comp)))) : is_simple_group (boolean_algebra (has_neg (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_45599 (h0 : function.extfun Type topological_space) : @t0_space.{0} (add_left_cancel_semigroup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_left_cancel_semigroup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_45600 (h0 : ring (has_compl (has_nnnorm fun_info))) : rank_condition (has_compl (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_45601 (h0 : ordered_add_comm_monoid (boolean_algebra (has_neg real))) : archimedean (boolean_algebra (has_neg real)) := sorry --non-trivial
lemma new_lemma_45602 (h2 : topological_space (random_gen to_additive.value_type)) : totally_disconnected_space (random_gen to_additive.value_type) := sorry --non-trivial
lemma new_lemma_45603 (h0 : topological_space (denumerable (random_gen (has_nnnorm linarith.comp_source)))) : t0_space (denumerable (random_gen (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_45604 (h0 : topological_space (semi_normed_ring (has_compl (mul_one_class reducibility_hints)))) : totally_disconnected_space (semi_normed_ring (has_compl (mul_one_class reducibility_hints))) := sorry --non-trivial
lemma new_lemma_45605 (h1 : uniform_space (has_append linarith.comp_source)) : complete_space (has_append linarith.comp_source) := sorry --non-trivial
lemma new_lemma_45606 (h0 : semiring (has_nndist (has_add (has_Inf (has_add (has_add (has_Inf name))))))) : is_noetherian_ring (has_nndist (has_add (has_Inf (has_add (has_add (has_Inf name)))))) := sorry --non-trivial
lemma new_lemma_45607 (h0 : topological_space (has_star (option empty))) : normal_space (has_star (option empty)) := sorry --non-trivial
lemma new_lemma_45608 (h0 : fin has_zero.zero) : @t0_space.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_45609 (h0 : finset (monoid_with_zero pos) -> finset (monoid_with_zero pos) -> Prop) : is_symm (finset (monoid_with_zero pos)) h0 := sorry --non-trivial
lemma new_lemma_45610 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (has_nndist.{0} num) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (has_nndist.{0} num))  := sorry --non-trivial
lemma new_lemma_45611 (h0 : functor.add_const (ring (has_add pos)) environment.implicit_infer_kind) : @strong_rank_condition.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_add.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_45612 (h0 : ordered_add_comm_monoid (non_assoc_semiring unsigned)) : archimedean (non_assoc_semiring unsigned) := sorry --non-trivial
lemma new_lemma_45613 (h2 : measurable_space (nondiscrete_normed_field (add_comm_semigroup linarith.ineq))) (h3 : measure_theory.measure (nondiscrete_normed_field (add_comm_semigroup linarith.ineq))) : measure_theory.is_finite_measure h3 := sorry --non-trivial
lemma new_lemma_45614 (h0 : function.extfun Type (functor.add_const (group (partial_order unsigned)))) : @normalizer_condition.{0} (partial_order.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (partial_order.{0} unsigned)) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (group.{0} (partial_order.{0} unsigned))) h0 num))  := sorry --non-trivial
lemma new_lemma_45615 (h0 : functor.add_const (topological_space (has_add (mul_one_class linarith.comp))) (mul_one_class pos)) : @preirreducible_space.{0} (has_add.{0} (mul_one_class.{0} linarith.comp)) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} (mul_one_class.{0} linarith.comp))) (mul_one_class.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_45616 (h0 : finset (non_unital_non_assoc_semiring string_imp)) (h1 : finset.nonempty h0) (h2 : non_unital_non_assoc_semiring string_imp -> topological_space (simple_graph char)) : @totally_disconnected_space.{0} (simple_graph.{0} char) (@finset.sup'.{0 0} (topological_space.{0} (simple_graph.{0} char)) (non_unital_non_assoc_semiring.{0} string_imp) (@lattice.to_semilattice_sup.{0} (topological_space.{0} (simple_graph.{0} char)) (@conditionally_complete_lattice.to_lattice.{0} (topological_space.{0} (simple_graph.{0} char)) (@complete_lattice.to_conditionally_complete_lattice.{0} (topological_space.{0} (simple_graph.{0} char)) (@topological_space.complete_lattice.{0} (simple_graph.{0} char))))) h0 h1 h2)  := sorry --non-trivial
lemma new_lemma_45617 (h0 : complete_lattice (has_ssubset (has_nnnorm (has_nnnorm linarith.ineq)))) : is_compactly_generated (has_ssubset (has_nnnorm (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_45618 (h0 : not (function.extfun Type topological_space -> false)) : @preirreducible_space.{0} (with_bot.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (with_bot.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_45619 (h0 : ordered_comm_monoid (comm_group (has_to_string (finset Type)))) : has_exists_mul_of_le (comm_group (has_to_string (finset Type))) := sorry --non-trivial
lemma new_lemma_45620 (h0 : function.extfun Type topological_space) : @normal_space.{0} (has_neg_part.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_45621 (h0 : topological_space (has_add (semigroup (finset (mul_zero_class pos))))) : preirreducible_space (has_add (semigroup (finset (mul_zero_class pos)))) := sorry --non-trivial
lemma new_lemma_45622 (h0 : functor.add_const (group (has_neg pos)) (comm_group Type)) : @normalizer_condition.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (has_neg.{0} pos)) (comm_group.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_45623 (h0 : functor.add_const (topological_space (group_with_zero ennreal)) num) : @locally_compact_space.{0} (group_with_zero.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (group_with_zero.{0} ennreal)) num h0)  := sorry --non-trivial
lemma new_lemma_45624 (h0 : functor.add_const (filter (boolean_algebra.core unsigned)) pos) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_45625 (h0 : monoid (order_dual (has_Inf (has_Inf linarith.comp)))) : monoid.fg (order_dual (has_Inf (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_45626 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (bin_tree.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (bin_tree.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_45627 (h0 : functor.add_const (filter (semigroup pos)) (has_to_string (has_to_string Type))) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_45628 (h0 : topological_space (with_one (semiring congr_arg_kind))) : preirreducible_space (with_one (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_45629 (h0 : group (has_norm (has_norm linarith.comp))) : group.fg (has_norm (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_45630 (h0 : filter (ring (has_nndist (complete_distrib_lattice environment.implicit_infer_kind)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_45631 (h0 : uniform_space (ordered_comm_monoid (has_Inf linarith.comp))) : complete_space (ordered_comm_monoid (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_45632 (h0 : add_group (has_append char)) : is_add_cyclic (has_append char) := sorry --non-trivial
lemma new_lemma_45633 (h0 : not (function.extfun Type topological_space -> false)) : @discrete_topology.{0} (linear_ordered_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (linear_ordered_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_45634 (h0 : ring (has_nnnorm (mul_one_class fun_info))) : is_domain (has_nnnorm (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_45635 (h0 : functor.add_const (topological_space (cancel_monoid name)) name) : @locally_compact_space.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_45636 (h0 : list (measurable_space to_additive.value_type)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_45637 (h0 : functor.add_const (functor.add_const (topological_space pos) Type) linarith.comp) : @topological_space.separable_space.{0} pos (@functor.add_const.run.{0 1} (topological_space.{0} pos) Type (@functor.add_const.run.{0 0} (functor.add_const.{0 1} (topological_space.{0} pos) Type) linarith.comp h0))  := sorry --non-trivial
lemma new_lemma_45638 (h0 : monoid (pseudo_metric_space ennreal) -> monoid (pseudo_metric_space ennreal) -> Prop) : is_symm (monoid (pseudo_metric_space ennreal)) h0 := sorry --non-trivial
lemma new_lemma_45639 (h0 : ring (dlist (has_nnnorm char))) : rank_condition (dlist (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_45640 (h0 : filter (complete_semilattice_Sup (semiring (semiring unsigned)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_45641 (h0 : topological_space (option (option ennreal))) : topological_space.separable_space (option (option ennreal)) := sorry --non-trivial
lemma new_lemma_45642 (h0 : function.extfun Type ring) : @is_domain.{0} (has_norm.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_norm.{0} num))  := sorry --non-trivial
lemma new_lemma_45643 (h0 : topological_space (sub_neg_monoid (has_neg pos))) : loc_path_connected_space (sub_neg_monoid (has_neg pos)) := sorry --non-trivial
lemma new_lemma_45644 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_star.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_star.{0} empty))  := sorry --non-trivial
lemma new_lemma_45645 (h0 : add_monoid (add_cancel_comm_monoid empty)) : add_monoid.fg (add_cancel_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_45646 (h0 : topological_space (mul_zero_class (has_top empty))) : t1_space (mul_zero_class (has_top empty)) := sorry --non-trivial
lemma new_lemma_45647 (h0 : functor.add_const (topological_space (has_to_string Type)) (has_neg Type)) : @t1_space.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_to_string.{1} Type)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_45648 (h0 : not (has_mem.mem (random_gen linarith.comp_source) has_emptyc.emptyc -> false)) : @locally_compact_space.{0} (random_gen.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (random_gen.{0} linarith.comp_source) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} linarith.comp_source) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_45649 (h0 : functor.add_const (topological_space (ordered_ring unsigned)) num) : @t1_space.{0} (ordered_ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_45650 (h0 : functor.add_const (ring (ring pos)) (finset (has_neg linarith.comp))) : @rank_condition.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (ring.{0} pos)) (finset.{0} (has_neg.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_45651 (h0 : uniform_space (normed_field (mul_one_class (mul_one_class char)))) : complete_space (normed_field (mul_one_class (mul_one_class char))) := sorry --non-trivial
lemma new_lemma_45652 (h0 : topological_space (ordered_comm_monoid (ring pos))) : path_connected_space (ordered_comm_monoid (ring pos)) := sorry --non-trivial
lemma new_lemma_45653 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (normed_lattice_add_comm_group.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_lattice_add_comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_45654 (h0 : has_mem.mem (has_top congr_arg_kind) has_emptyc.emptyc) : @is_cyclic.{0} (has_top.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type group.{0} (has_top.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_45655 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (linear_ordered_comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (linear_ordered_comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_45656 (h1 : monoid Type) : monoid.fg Type := sorry --non-trivial
lemma new_lemma_45657 (h0 : group_with_zero (option (option ennreal)) -> group_with_zero (option (option ennreal)) -> Prop) : is_symm (group_with_zero (option (option ennreal))) h0 := sorry --non-trivial
lemma new_lemma_45658 (h0 : uniform_space (has_union (metric_space (semiring (semiring congr_arg_kind))))) : separated_space (has_union (metric_space (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_45659 (h0 : filter (cancel_monoid (has_neg_part name))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_45660 (h0 : topological_space (monoid (option pos))) : path_connected_space (monoid (option pos)) := sorry --non-trivial
lemma new_lemma_45661 (h0 : topological_space (ordered_comm_monoid (has_Inf (has_Inf real)))) : preconnected_space (ordered_comm_monoid (has_Inf (has_Inf real))) := sorry --non-trivial
lemma new_lemma_45662 (h0 : uniform_space (filter unsigned)) : complete_space (filter unsigned) := sorry --non-trivial
lemma new_lemma_45663 (h0 : filter (add_comm_monoid (has_add (add_comm_monoid (has_add (has_add (has_add pos))))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_45664 (h0 : uniform_space (has_nndist (option (option (option empty))))) : complete_space (has_nndist (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_45665 (h0 : functor.add_const (topological_space (add_cancel_monoid unsigned)) name) : @t1_space.{0} (add_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_45666 (h0 : group (semigroup (has_neg linarith.comp))) : is_simple_group (semigroup (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_45667 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (measurable_space.{0} linarith.comp) (@function.extfun_app.{2 1} Type semiring.{0} h0 (measurable_space.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_45668 (h0 : functor.add_const (topological_space (id empty)) empty) : @loc_path_connected_space.{0} (@id.{2} Type empty) (@functor.add_const.run.{0 0} (topological_space.{0} (@id.{2} Type empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_45669 (h0 : ordered_add_comm_monoid (canonically_ordered_comm_semiring (option name))) : archimedean (canonically_ordered_comm_semiring (option name)) := sorry --non-trivial
lemma new_lemma_45670 (h0 : add_group char) : is_simple_add_group char := sorry --non-trivial
lemma new_lemma_45671 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (generalized_boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (generalized_boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_45672 (h0 : topological_space (normed_comm_ring congr_arg_kind)) : preirreducible_space (normed_comm_ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_45673 (h0 : function.extfun Type ring) : @rank_condition.{0} (normed_linear_ordered_group.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (normed_linear_ordered_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_45674 (h3 : has_lt (add_comm_semigroup (simple_graph linarith.ineq))) : no_max_order (add_comm_semigroup (simple_graph linarith.ineq)) := sorry --non-trivial
lemma new_lemma_45675 (h1 : monoid (has_emptyc (random_gen (random_gen fun_info)))) : monoid.fg (has_emptyc (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_45676 (h1 : ring (add_cancel_comm_monoid char)) : is_domain (add_cancel_comm_monoid char) := sorry --non-trivial
lemma new_lemma_45677 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (has_union.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_union.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_45678 (h0 : list (canonically_ordered_comm_semiring (has_add ennreal))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_45679 (h0 : add_group (add_comm_semigroup (mul_one_class (mul_one_class reducibility_hints)))) : is_add_cyclic (add_comm_semigroup (mul_one_class (mul_one_class reducibility_hints))) := sorry --non-trivial
lemma new_lemma_45680 (h1 : not (ring num -> false)) : @rank_condition.{0} num (@classical.by_contradiction'.{1} (ring.{0} num) h1)  := sorry --non-trivial
lemma new_lemma_45681 (h0 : not (function.extfun Type ring -> false)) : @strong_rank_condition.{0} (measure_theory.measure_space.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (measure_theory.measure_space.{0} num))  := sorry --non-trivial
lemma new_lemma_45682 (h0 : functor.add_const (semiring (has_nndist environment.implicit_infer_kind)) (finset linarith.comp)) : @is_noetherian_ring.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (semiring.{0} (has_nndist.{0} environment.implicit_infer_kind)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_45683 (h0 : functor.add_const (ring empty) empty) : @is_domain.{0} empty (@functor.add_const.run.{0 0} (ring.{0} empty) empty h0)  := sorry --non-trivial
lemma new_lemma_45684 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (omega_complete_partial_order empty)) := sorry --non-trivial
lemma new_lemma_45685 (h0 : topological_space (boolean_algebra (mul_one_class Type))) : topological_space.separable_space (boolean_algebra (mul_one_class Type)) := sorry --non-trivial
lemma new_lemma_45686 (h0 : not (complete_lattice (non_unital_non_assoc_semiring string.iterator_imp) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (non_unital_non_assoc_semiring.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (complete_lattice.{0} (non_unital_non_assoc_semiring.{0} string.iterator_imp)) h0)  := sorry --non-trivial
lemma new_lemma_45687 (h0 : functor.comp ring ring name) : @strong_rank_condition.{0} (ring.{0} name) (@functor.comp.run.{0 0 0} ring.{0} ring.{0} name h0)  := sorry --non-trivial
lemma new_lemma_45688 (h0 : ring (comm_group (has_to_string (has_add (has_to_string unsigned))))) : is_principal_ideal_ring (comm_group (has_to_string (has_add (has_to_string unsigned)))) := sorry --non-trivial
lemma new_lemma_45689 (h0 : topological_space (mul_zero_class pos)) : locally_compact_space (mul_zero_class pos) := sorry --non-trivial
lemma new_lemma_45690 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (canonically_linear_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_linear_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_45691 (h0 : topological_space (semiring (has_norm empty))) : normal_space (semiring (has_norm empty)) := sorry --non-trivial
lemma new_lemma_45692 (h0 : topological_space (normed_field linarith.comp_source)) : t0_space (normed_field linarith.comp_source) := sorry --non-trivial
lemma new_lemma_45693 (h1 : group (normed_field (random_gen char))) : is_cyclic (normed_field (random_gen char)) := sorry --non-trivial
lemma new_lemma_45694 (h0 : group (complete_semilattice_Sup (random_gen (random_gen (random_gen string_imp))))) : normalizer_condition (complete_semilattice_Sup (random_gen (random_gen (random_gen string_imp)))) := sorry --non-trivial
lemma new_lemma_45695 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_45696 (h0 : complete_lattice (with_bot (has_inv fun_info))) : complete_lattice.is_Sup_finite_compact (with_bot (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_45697 (h0 : function.extfun Type ring) : @rank_condition.{0} (distrib_lattice.{0} linarith.ineq) (@function.extfun_app.{2 1} Type ring.{0} h0 (distrib_lattice.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_45698 (h0 : functor.add_const (topological_space (cancel_monoid name)) pos) : @loc_path_connected_space.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_45699 (h0 : has_neg (simple_graph linarith.comp_source)) (h1 : measurable_space (simple_graph linarith.comp_source)) : has_measurable_neg (simple_graph linarith.comp_source) := sorry --non-trivial
lemma new_lemma_45700 (h0 : uniform_space (complete_semilattice_Sup linarith.comp)) : complete_space (complete_semilattice_Sup linarith.comp) := sorry --non-trivial
lemma new_lemma_45701 (h0 : topological_space (distrib_lattice (comm_ring to_additive.value_type))) : totally_disconnected_space (distrib_lattice (comm_ring to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_45702 (h0 : finset char) (h1 : finset.nonempty h0) (h2 : char -> Prop) : @finset.inf'.{0 0} Prop char (@lattice.to_semilattice_inf.{0} Prop (@conditionally_complete_lattice.to_lattice.{0} Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice))) h0 h1 h2  := sorry --non-trivial
lemma new_lemma_45703 (h0 : function.extfun Type ring) : @is_domain.{0} (uniform_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (uniform_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_45704 (h0 : functor.add_const (topological_space (has_zero pos)) (has_neg linarith.comp)) : @t1_space.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} pos)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_45705 (h0 : topological_space (has_add name)) : t0_space (has_add name) := sorry --non-trivial
lemma new_lemma_45706 (h0 : functor.add_const (ordered_add_comm_monoid environment.implicit_infer_kind) name) : @archimedean.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} environment.implicit_infer_kind) name h0)  := sorry --non-trivial
lemma new_lemma_45707 (h0 : group (distrib_lattice (has_nnnorm linarith.ineq))) : group.fg (distrib_lattice (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_45708 (h0 : topological_space (comm_group (finset environment.implicit_infer_kind))) : irreducible_space (comm_group (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_45709 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_inv.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inv.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_45710 (h0 : functor.add_const (topological_space (has_pos_part linarith.comp)) (ring linarith.comp)) : @regular_space.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} linarith.comp)) (ring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_45711 (h0 : functor.add_const (topological_space (finset ennreal)) Type) : @t0_space.{0} (finset.{0} ennreal) (@functor.add_const.run.{0 1} (topological_space.{0} (finset.{0} ennreal)) Type h0)  := sorry --non-trivial
lemma new_lemma_45712 (h0 : functor.add_const (filter (normed_comm_ring ennreal)) unsigned) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_45713 (h0 : add_monoid (has_top (has_top (has_top (has_top empty))))) : add_monoid.fg (has_top (has_top (has_top (has_top empty)))) := sorry --non-trivial
lemma new_lemma_45714 (h0 : ring (boolean_algebra.core (has_to_string Type))) : rank_condition (boolean_algebra.core (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_45715 (h0 : ordered_comm_monoid (simple_graph (finset Type))) : has_exists_mul_of_le (simple_graph (finset Type)) := sorry --non-trivial
lemma new_lemma_45716 (h0 : complete_lattice (monoid_with_zero (option unsigned))) : is_atomistic (monoid_with_zero (option unsigned)) := sorry --non-trivial
lemma new_lemma_45717 (h0 : function.extfun (finset Type) (has_mem.mem (measurable_space empty))) : @path_connected_space.{0} (measurable_space.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (measurable_space.{0} empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (measurable_space.{0} empty)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_45718 (h0 : not (function.extfun Type add_monoid -> false)) : @add_monoid.fg.{0} (left_cancel_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_monoid.{0}) h0) (left_cancel_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_45719 (h0 : not (topological_space (non_unital_non_assoc_semiring (mul_one_class fun_info)) -> false)) : @path_connected_space.{0} (non_unital_non_assoc_semiring.{0} (mul_one_class.{0} fun_info)) (@classical.by_contradiction'.{1} (topological_space.{0} (non_unital_non_assoc_semiring.{0} (mul_one_class.{0} fun_info))) h0)  := sorry --non-trivial
lemma new_lemma_45720 (h0 : functor.add_const (group (add_comm_monoid name)) linarith.comp) : @is_simple_group.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (group.{0} (add_comm_monoid.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_45721 (h0 : filter (linear_ordered_semiring char)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_45722 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (complete_semilattice_Sup.{0} linarith.ineq) (@function.extfun_app.{2 1} Type add_group.{0} h0 (complete_semilattice_Sup.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_45723 (h0 : functor.add_const (function.extfun Type group) Type) : @normalizer_condition.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type group.{0}) Type h0) (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_45724 (h0 : topological_space (has_Inf (finset pos))) : preconnected_space (has_Inf (finset pos)) := sorry --non-trivial
lemma new_lemma_45725 (h0 : topological_space (complete_semilattice_Sup (has_top linarith.ineq))) : totally_disconnected_space (complete_semilattice_Sup (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_45726 (h0 : not (filter (mul_zero_class empty) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_45727 (h0 : add_monoid (linear_ordered_comm_monoid_with_zero (option empty))) : add_monoid.fg (linear_ordered_comm_monoid_with_zero (option empty)) := sorry --non-trivial
lemma new_lemma_45728 (h0 : functor.add_const (complete_lattice (normed_linear_ordered_group num)) empty) : @is_compactly_generated.{0} (normed_linear_ordered_group.{0} num) (@functor.add_const.run.{0 0} (complete_lattice.{0} (normed_linear_ordered_group.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_45729 (h0 : functor.add_const (list (finset pos)) name) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_45730 (h0 : congr_arg_kind -> Prop) (h1 : filter congr_arg_kind) : filter.frequently h0 h1 := sorry --non-trivial
lemma new_lemma_45731 (h0 : topological_space (random_gen (has_ssubset (has_nnnorm reducibility_hints)))) : t0_space (random_gen (has_ssubset (has_nnnorm reducibility_hints))) := sorry --non-trivial
lemma new_lemma_45732 (h0 : uniform_space (normed_group (random_gen string_imp))) : complete_space (normed_group (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_45733 (h0 : function.extfun Type (functor.add_const (topological_space (semiring num)))) : @t1_space.{0} (semiring.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (semiring.{0} num)) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (semiring.{0} num))) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_45734 (h0 : topological_space (left_cancel_semigroup unsigned)) : loc_path_connected_space (left_cancel_semigroup unsigned) := sorry --non-trivial
lemma new_lemma_45735 (h0 : fin has_zero.zero) : id (matrix.vec_empty (matrix.vec_empty (id h0))) := sorry --non-trivial
lemma new_lemma_45736 (h0 : topological_space (add_comm_monoid unsigned)) : totally_disconnected_space (add_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_45737 (h0 : ring (normed_comm_ring Type)) : is_domain (normed_comm_ring Type) := sorry --non-trivial
lemma new_lemma_45738 (h0 : not (uniform_space (div_inv_monoid (has_nnnorm linarith.ineq)) -> false)) : @complete_space.{0} (div_inv_monoid.{0} (has_nnnorm.{0} linarith.ineq)) (@classical.by_contradiction'.{1} (uniform_space.{0} (div_inv_monoid.{0} (has_nnnorm.{0} linarith.ineq))) h0)  := sorry --non-trivial
lemma new_lemma_45739 (h0 : topological_space (measurable_space.dynkin_system (option unsigned))) : locally_compact_space (measurable_space.dynkin_system (option unsigned)) := sorry --non-trivial
lemma new_lemma_45740 (h0 : ring (complete_semilattice_Sup (semiring empty))) : strong_rank_condition (complete_semilattice_Sup (semiring empty)) := sorry --non-trivial
lemma new_lemma_45741 (h0 : functor.add_const (functor.add_const (filter Type) linarith.comp) Type) : filter.ne_bot (functor.add_const.run (functor.add_const.run h0)) := sorry --non-trivial
lemma new_lemma_45742 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (non_assoc_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (non_assoc_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_45743 (h0 : functor.add_const (topological_space (cancel_monoid name)) unsigned) : @sequential_space.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_45744 (h0 : functor.comp topological_space has_nndist pos) : @normal_space.{0} (has_nndist.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_45745 (h0 : topological_space (linear_ordered_semiring unsigned)) : preirreducible_space (linear_ordered_semiring unsigned) := sorry --non-trivial
lemma new_lemma_45746 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @preirreducible_space.{0} (has_top.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_top.{0} empty))  := sorry --non-trivial
lemma new_lemma_45747 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @preconnected_space.{0} (has_to_string.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (has_to_string.{0} name))  := sorry --non-trivial
lemma new_lemma_45748 (h0 : function.extfun Type group) : @is_cyclic.{0} (left_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (left_cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_45749 (h1 : not (complete_lattice (linear_ordered_comm_group_with_zero string_imp) -> false)) : @is_compactly_generated.{0} (linear_ordered_comm_group_with_zero.{0} string_imp) (@classical.by_contradiction'.{1} (complete_lattice.{0} (linear_ordered_comm_group_with_zero.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_45750 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (mul_zero_class.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (mul_zero_class.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_45751 (h0 : topological_space (has_bot (finset Type))) : totally_separated_space (has_bot (finset Type)) := sorry --non-trivial
lemma new_lemma_45752 (h0 : complete_lattice (normed_field (comm_ring char))) : complete_lattice.is_Sup_finite_compact (normed_field (comm_ring char)) := sorry --non-trivial
lemma new_lemma_45753 (h0 : topological_space (cancel_monoid (option name))) : normal_space (cancel_monoid (option name)) := sorry --non-trivial
lemma new_lemma_45754 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (canonically_ordered_comm_semiring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_45755 (h0 : topological_space (measurable_space.dynkin_system (metric_space (semiring unsigned)))) : normal_space (measurable_space.dynkin_system (metric_space (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_45756 (h0 : topological_space (add_comm_semigroup string.iterator_imp)) : topological_space.first_countable_topology (add_comm_semigroup string.iterator_imp) := sorry --non-trivial
lemma new_lemma_45757 (h0 : ordered_add_comm_monoid (has_nndist (has_nndist pos))) : archimedean (has_nndist (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_45758 (h0 : functor.add_const (filter (ring Type)) linarith.comp) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_45759 (h0 : topological_space (option (option ennreal))) : totally_separated_space (option (option ennreal)) := sorry --non-trivial
lemma new_lemma_45760 (h0 : not (complete_lattice (mul_zero_class congr_arg_kind) -> false)) : @is_compactly_generated.{0} (mul_zero_class.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (complete_lattice.{0} (mul_zero_class.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_45761 (h0 : group (normed_group (complete_semilattice_Sup congr_arg_kind))) : is_cyclic (normed_group (complete_semilattice_Sup congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_45762 (h0 : function.extfun (finset ((Type -> Type) -> Type 1)) (has_mem.mem (function.extfun Type))) : @is_atomistic.{0} (with_bot.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@finset.pi.empty.{2 1} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) (function.extfun.{2 1} Type) (@function.extfun_app.{3 0} (finset.{2} ((Type → Type) → Type 1)) (@has_mem.mem.{2 2} ((Type → Type) → Type 1) (finset.{2} ((Type → Type) → Type 1)) (@finset.has_mem.{2} ((Type → Type) → Type 1)) (function.extfun.{2 1} Type)) h0 (@has_emptyc.emptyc.{2} (finset.{2} ((Type → Type) → Type 1)) (@finset.has_emptyc.{2} ((Type → Type) → Type 1))))) complete_lattice.{0}) (with_bot.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_45763 (h0 : group (has_top (random_gen (has_ssubset fun_info)))) : group.fg (has_top (random_gen (has_ssubset fun_info))) := sorry --non-trivial
lemma new_lemma_45764 (h0 : topological_space (boolean_algebra (ring pos))) : preconnected_space (boolean_algebra (ring pos)) := sorry --non-trivial
lemma new_lemma_45765 (h0 : topological_space (has_add (boolean_algebra (has_add (has_Inf (has_Inf Type)))))) : discrete_topology (has_add (boolean_algebra (has_add (has_Inf (has_Inf Type))))) := sorry --non-trivial
lemma new_lemma_45766 (h0 : function.extfun Type topological_space) : path_connected_space real := sorry --non-trivial
lemma new_lemma_45767 (h0 : add_monoid (has_bot (option (option (option empty))))) : add_monoid.fg (has_bot (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_45768 (h0 : finset (ring (has_Inf pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_45769 (h0 : topological_space (add_semigroup ennreal)) : locally_compact_space (add_semigroup ennreal) := sorry --non-trivial
lemma new_lemma_45770 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (is_R_or_C.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (is_R_or_C.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_45771 (h0 : group (linear_ordered_semiring (semiring unsigned))) : is_cyclic (linear_ordered_semiring (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_45772 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (with_one.{0} linarith.ineq) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (with_one.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_45773 (h0 : add_group (simple_graph to_additive.value_type)) : is_add_cyclic (simple_graph to_additive.value_type) := sorry --non-trivial
lemma new_lemma_45774 (h0 : topological_space linarith.comp_source) (h1 : preorder linarith.comp_source) : order_topology linarith.comp_source := sorry --non-trivial
lemma new_lemma_45775 (h0 : functor.add_const (topological_space (comm_semigroup pos)) (has_neg real)) : @preirreducible_space.{0} (comm_semigroup.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_semigroup.{0} pos)) (has_neg.{0} real) h0)  := sorry --non-trivial
lemma new_lemma_45776 (h0 : add_group (has_neg (normed_comm_ring (boolean_algebra.core name)))) : is_add_cyclic (has_neg (normed_comm_ring (boolean_algebra.core name))) := sorry --non-trivial
lemma new_lemma_45777 (h0 : topological_space (metric_space congr_arg_kind)) : irreducible_space (metric_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_45778 (h0 : add_group (mul_one_class (mul_one_class (mul_one_class ereal)))) : is_add_cyclic (mul_one_class (mul_one_class (mul_one_class ereal))) := sorry --non-trivial
lemma new_lemma_45779 (h0 : complete_lattice (denumerable (has_top (has_inv linarith.ineq)))) : complete_lattice.is_Sup_finite_compact (denumerable (has_top (has_inv linarith.ineq))) := sorry --non-trivial
lemma new_lemma_45780 (h0 : topological_space (boolean_algebra (comm_group (comm_group name)))) : t1_space (boolean_algebra (comm_group (comm_group name))) := sorry --non-trivial
lemma new_lemma_45781 (h0 : topological_space (comm_group (finset (ring environment.implicit_infer_kind)))) : topological_space.separable_space (comm_group (finset (ring environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_45782 (h0 : filter (add_comm_monoid (has_add (ring linarith.comp)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_45783 (h0 : functor.add_const (function.extfun Type semiring) pos) : @is_noetherian_ring.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type semiring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type semiring.{0}) pos h0) (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_45784 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (boolean_algebra.core.{0} (finset.{0} pos)) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.core.{0} (finset.{0} pos)))  := sorry --non-trivial
lemma new_lemma_45785 (h0 : functor.add_const (group (finset name)) name) : @is_simple_group.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (group.{0} (finset.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_45786 (h0 : topological_space (complete_semilattice_Sup (has_inv (has_inv (with_bot string_imp))))) : locally_compact_space (complete_semilattice_Sup (has_inv (has_inv (with_bot string_imp)))) := sorry --non-trivial
lemma new_lemma_45787 (h0 : topological_space (measure_theory.measure_space unsigned)) : t0_space (measure_theory.measure_space unsigned) := sorry --non-trivial
lemma new_lemma_45788 (h0 : complete_lattice (normed_field (random_gen (comm_ring (random_gen (random_gen char)))))) : is_compactly_generated (normed_field (random_gen (comm_ring (random_gen (random_gen char))))) := sorry --non-trivial
lemma new_lemma_45789 (h0 : functor.add_const (function.extfun Type filter) linarith.comp) : countable_Inter_filter (function.extfun_app (functor.add_const.run h0) (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_45790 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (has_sub.{0} num) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (has_sub.{0} num))  := sorry --non-trivial
lemma new_lemma_45791 (h0 : topological_space (boolean_algebra Type)) : irreducible_space (boolean_algebra Type) := sorry --non-trivial
lemma new_lemma_45792 (h2 : ring (has_inv fun_info)) : strong_rank_condition (has_inv fun_info) := sorry --non-trivial
lemma new_lemma_45793 (h0 : complete_lattice (measurable_space (has_top (has_top (has_top fun_info))))) : complete_lattice.is_Sup_finite_compact (measurable_space (has_top (has_top (has_top fun_info)))) := sorry --non-trivial
lemma new_lemma_45794 (h1 : complete_lattice (has_compl (random_gen (random_gen (random_gen string_imp))))) : is_compactly_generated (has_compl (random_gen (random_gen (random_gen string_imp)))) := sorry --non-trivial
lemma new_lemma_45795 (h0 : has_mem.mem (with_bot (has_norm empty)) has_emptyc.emptyc) : @is_cyclic.{0} (with_bot.{0} (has_norm.{0} empty)) (@finset.pi.empty.{1 0} Type group.{0} (with_bot.{0} (has_norm.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_45796 (h0 : not (complete_lattice (fintype to_additive.value_type) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (fintype.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (complete_lattice.{0} (fintype.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_45797 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_atomistic.{0} (has_star.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (has_star.{0} num))  := sorry --non-trivial
lemma new_lemma_45798 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (list.ret (function.extfun_app (function.extfun_app h0 boolean_algebra) linarith.comp)) := sorry --non-trivial
lemma new_lemma_45799 (h0 : topological_space (ordered_comm_monoid real)) : locally_compact_space (ordered_comm_monoid real) := sorry --non-trivial
lemma new_lemma_45800 (h0 : ring (add_comm_semigroup fun_info)) : rank_condition (add_comm_semigroup fun_info) := sorry --non-trivial
lemma new_lemma_45801 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (finset.{0} (option.{0} unsigned)) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (finset.{0} (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_45802 (h0 : topological_space (has_neg (has_add linarith.comp))) : sequential_space (has_neg (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_45803 (h0 : semiring (plift (semiring (semiring (semiring unsigned))))) : is_noetherian_ring (plift (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_45804 (h1 : add_group (mul_one_class (normed_field (normed_field (normed_field (add_comm_semigroup char)))))) : is_add_cyclic (mul_one_class (normed_field (normed_field (normed_field (add_comm_semigroup char))))) := sorry --non-trivial
lemma new_lemma_45805 (h0 : finset (bin_tree (semiring (semiring empty)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_45806 (h0 : prod (add_right_cancel_monoid num) (add_right_cancel_monoid num)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_45807 (h0 : function.extfun Type (functor.add_const (topological_space (ordered_ring empty)))) : @t1_space.{0} (ordered_ring.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} empty)) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (ordered_ring.{0} empty))) h0 num))  := sorry --non-trivial
lemma new_lemma_45808 (h0 : filter (finset (finset (finset linarith.comp)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_45809 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_45810 (h0 : group (mul_zero_class (cancel_monoid ennreal))) : is_simple_group (mul_zero_class (cancel_monoid ennreal)) := sorry --non-trivial
lemma new_lemma_45811 (h0 : function.extfun (finset Type) (has_mem.mem fun_info)) : @irreducible_space.{0} fun_info (@finset.pi.empty.{1 0} Type topological_space.{0} fun_info (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) fun_info) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_45812 (h1 : function.extfun Type ring) : @strong_rank_condition.{0} (measurable_space.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} h1 (measurable_space.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_45813 (h0 : cancel_comm_monoid_with_zero (add_comm_monoid Type)) : unique_factorization_monoid (add_comm_monoid Type) := sorry --non-trivial
lemma new_lemma_45814 (h0 : topological_space (simple_graph (has_neg (finset linarith.comp)))) : preirreducible_space (simple_graph (has_neg (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_45815 (h0 : ring (complete_semilattice_Sup (has_ssubset to_additive.value_type))) : is_domain (complete_semilattice_Sup (has_ssubset to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_45816 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (normed_comm_ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (normed_comm_ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_45817 (h1 : not (add_group (semi_normed_ring linarith.comp_source) -> false)) : @is_add_cyclic.{0} (semi_normed_ring.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (add_group.{0} (semi_normed_ring.{0} linarith.comp_source)) h1)  := sorry --non-trivial
lemma new_lemma_45818 (h0 : functor.add_const (ordered_add_comm_monoid (has_Inf linarith.comp)) Type) : @archimedean.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 1} (ordered_add_comm_monoid.{0} (has_Inf.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_45819 (h0 : topological_space (has_bot (has_add real))) : normal_space (has_bot (has_add real)) := sorry --non-trivial
lemma new_lemma_45820 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} (has_sub.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (has_sub.{0} empty))  := sorry --non-trivial
lemma new_lemma_45821 (h0 : topological_space (complete_distrib_lattice (ring linarith.comp))) : preirreducible_space (complete_distrib_lattice (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_45822 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (normed_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_45823 (h0 : group (add_cancel_monoid name)) : is_cyclic (add_cancel_monoid name) := sorry --non-trivial
lemma new_lemma_45824 (h0 : functor.add_const (group (add_comm_monoid Type)) (has_nndist pos)) : @group.fg.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (add_comm_monoid.{1} Type)) (has_nndist.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_45825 (h0 : add_group (has_norm (has_inv (has_inv linarith.comp_source)))) : is_add_cyclic (has_norm (has_inv (has_inv linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_45826 (h0 : topological_space (has_Inf (has_add (has_add (has_add linarith.comp))))) : regular_space (has_Inf (has_add (has_add (has_add linarith.comp)))) := sorry --non-trivial
lemma new_lemma_45827 (h0 : topological_space (has_norm (random_gen fun_info))) : totally_separated_space (has_norm (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_45828 (h0 : not (uniform_space (with_bot congr_arg_kind) -> false)) : @complete_space.{0} (with_bot.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (uniform_space.{0} (with_bot.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_45829 (h1 : group (semiring congr_arg_kind)) : is_cyclic (semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_45830 (h0 : functor.add_const (functor.add_const (topological_space bool) empty) unsigned) : totally_separated_space bool := sorry --non-trivial
lemma new_lemma_45831 (h0 : topological_space (has_nndist (has_Inf linarith.comp))) : normal_space (has_nndist (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_45832 (h0 : functor.add_const (uniform_space (free_add_monoid unsigned)) unsigned) : @complete_space.{0} (free_add_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (uniform_space.{0} (free_add_monoid.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_45833 (h0 : topological_space (uniform_space to_additive.value_type)) (h1 : preorder (uniform_space to_additive.value_type)) : order_topology (uniform_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_45834 (h0 : functor.add_const (list (canonically_ordered_comm_semiring pos)) unsigned) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_45835 (h0 : complete_lattice (has_ssubset (mul_one_class (random_gen reducibility_hints)))) : complete_lattice.is_Sup_finite_compact (has_ssubset (mul_one_class (random_gen reducibility_hints))) := sorry --non-trivial
lemma new_lemma_45836 (h0 : complete_lattice (add_right_cancel_monoid unsigned)) : is_compactly_generated (add_right_cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_45837 (h0 : function.extfun nat fin) : @is_compactly_generated.{0} (normed_lattice_add_comm_group.{0} name) (@matrix.vec_empty.{0} (complete_lattice.{0} (normed_lattice_add_comm_group.{0} name)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_45838 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_inter.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (has_inter.{0} empty))  := sorry --non-trivial
lemma new_lemma_45839 (h1 : topological_space (comm_ring string_imp)) : locally_compact_space (comm_ring string_imp) := sorry --non-trivial
lemma new_lemma_45840 (h0 : topological_space (has_ssubset (has_top linarith.ineq))) : irreducible_space (has_ssubset (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_45841 (h0 : fin has_zero.zero) : @topological_space.separable_space.{1} (complete_distrib_lattice.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (complete_distrib_lattice.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_45842 (h0 : function.extfun Type add_monoid) (h1 : function.extfun Type has_one) : @char_zero.{0} (measure_theory.measure_space.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (measure_theory.measure_space.{0} unsigned)) (@function.extfun_app.{2 1} Type has_one.{0} h1 (measure_theory.measure_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_45843 (h0 : not (uniform_space (has_top empty) -> false)) : @separated_space.{0} (has_top.{0} empty) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_top.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_45844 (h0 : ring (has_top linarith.ineq)) : rank_condition (has_top linarith.ineq) := sorry --non-trivial
lemma new_lemma_45845 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_45846 (h0 : functor.add_const Prop (semigroup name)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_45847 (h0 : topological_space (add_comm_monoid (add_comm_monoid name))) : preconnected_space (add_comm_monoid (add_comm_monoid name)) := sorry --non-trivial
lemma new_lemma_45848 (h0 : functor.add_const (topological_space (comm_group pos)) pos) : @totally_disconnected_space.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_45849 (h0 : monoid (normed_group linarith.comp_source)) : monoid.fg (normed_group linarith.comp_source) := sorry --non-trivial
lemma new_lemma_45850 (h0 : functor.add_const (group (has_zero pos)) Type) : @is_simple_group.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (has_zero.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_45851 (h1 : has_coe (add_comm_semigroup (add_comm_semigroup (add_comm_semigroup enat))) Prop) (h2 : add_comm_semigroup (add_comm_semigroup (add_comm_semigroup enat))) : @coe_b.{1 1} (add_comm_semigroup.{0} (add_comm_semigroup.{0} (add_comm_semigroup.{0} enat))) Prop h1 h2  := sorry --non-trivial
lemma new_lemma_45852 (h0 : topological_space (random_gen complex)) : t0_space (random_gen complex) := sorry --non-trivial
lemma new_lemma_45853 (h0 : uniform_space (canonically_ordered_monoid (has_Inf (has_neg name)))) : complete_space (canonically_ordered_monoid (has_Inf (has_neg name))) := sorry --non-trivial
lemma new_lemma_45854 (h0 : group (ordered_comm_ring (finset (finset Type)))) : group.fg (ordered_comm_ring (finset (finset Type))) := sorry --non-trivial
lemma new_lemma_45855 (h0 : topological_space (ordered_comm_ring (has_nndist linarith.comp))) : totally_separated_space (ordered_comm_ring (has_nndist linarith.comp)) := sorry --non-trivial
lemma new_lemma_45856 (h0 : functor.add_const (list Type) (ring Type)) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_45857 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring ennreal)) pos) : @locally_compact_space.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} ennreal)) pos h0)  := sorry --non-trivial
lemma new_lemma_45858 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (has_top.{0} unsigned) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (has_top.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_45859 (h0 : ordered_add_comm_monoid (boolean_algebra.core (has_add linarith.comp))) : archimedean (boolean_algebra.core (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_45860 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @t0_space.{0} (has_pos_part.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (has_pos_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_45861 (h0 : topological_space (has_neg_part (cancel_monoid ennreal))) : path_connected_space (has_neg_part (cancel_monoid ennreal)) := sorry --non-trivial
lemma new_lemma_45862 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (linear_ordered_semiring.{0} num) (@function.extfun_app.{2 1} Type monoid.{0} h0 (linear_ordered_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_45863 (h0 : topological_space (has_neg (option pos))) : locally_compact_space (has_neg (option pos)) := sorry --non-trivial
lemma new_lemma_45864 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_45865 (h0 h1 : multiset (mul_one_class fun_info)) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_45866 (h0 : complete_lattice (with_one (has_norm empty))) : is_compactly_generated (with_one (has_norm empty)) := sorry --non-trivial
lemma new_lemma_45867 (h0 : has_mem.mem (metric_space (has_top empty)) has_emptyc.emptyc) : @normal_space.{0} (metric_space.{0} (has_top.{0} empty)) (@finset.pi.empty.{1 0} Type topological_space.{0} (metric_space.{0} (has_top.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_45868 (h0 : topological_space (add_group empty)) : topological_space.separable_space (add_group empty) := sorry --non-trivial
lemma new_lemma_45869 (h0 : ring (has_to_string (has_add environment.implicit_infer_kind))) : is_principal_ideal_ring (has_to_string (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_45870 (h0 : functor.add_const (add_monoid (complete_distrib_lattice num)) (option (option empty))) : @add_monoid.fg.{0} (complete_distrib_lattice.{0} num) (@functor.add_const.run.{0 0} (add_monoid.{0} (complete_distrib_lattice.{0} num)) (option.{0} (option.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_45871 (h0 : functor.add_const (topological_space (ring linarith.comp)) (ring Type)) : @sequential_space.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (ring.{0} linarith.comp)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_45872 (h0 : group (has_neg_part (has_add (has_add pos)))) : is_simple_group (has_neg_part (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_45873 (h0 : group (add_comm_monoid (has_neg linarith.comp))) : normalizer_condition (add_comm_monoid (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_45874 (h0 h1 : list ereal) : list.is_infix h0 h1 := sorry --non-trivial
lemma new_lemma_45875 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (normed_comm_ring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_45876 (h0 : prod (has_star congr_arg_kind) (has_star congr_arg_kind)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_45877 (h0 : functor.comp topological_space semigroup unsigned) : @topological_space.separable_space.{0} (semigroup.{0} unsigned) (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_45878 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (free_add_monoid congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_45879 (h0 : functor.add_const (ring (ring linarith.comp)) Type) : @is_domain.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (ring.{0} (ring.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_45880 (h0 : list (random_gen string_imp)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_45881 (h0 : ring (finset (has_add (has_add name)))) : rank_condition (finset (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_45882 (h0 : complete_lattice (id (semiring (semiring empty)))) : complete_lattice.is_Sup_finite_compact (id (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_45883 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @normal_space.{0} (measurable_space.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (measurable_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_45884 (h0 : functor.add_const (uniform_space (comm_group environment.implicit_infer_kind)) Type) : @complete_space.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (uniform_space.{0} (comm_group.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_45885 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (option.{0} num) (@function.extfun_app.{2 1} Type monoid.{0} h0 (option.{0} num))  := sorry --non-trivial
lemma new_lemma_45886 (h0 : topological_space (add_group congr_arg_kind)) : normal_space (add_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_45887 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (sub_neg_monoid.{0} name) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (sub_neg_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_45888 (h1 : complete_lattice (semi_normed_comm_ring to_additive.value_type)) : is_compactly_generated (semi_normed_comm_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_45889 (h0 : ring (canonically_ordered_monoid name)) : strong_rank_condition (canonically_ordered_monoid name) := sorry --non-trivial
lemma new_lemma_45890 (h0 : topological_space (with_one (with_one (random_gen to_additive.value_type)))) : irreducible_space (with_one (with_one (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_45891 (h0 : topological_space (has_zero (option (option ennreal)))) : preconnected_space (has_zero (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_45892 (h0 : functor.add_const (topological_space (generalized_boolean_algebra pos)) pos) : @regular_space.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_45893 (h0 : group real.angle) : is_cyclic real.angle := sorry --non-trivial
lemma new_lemma_45894 (h0 : uniform_space (ordered_comm_ring Type)) : complete_space (ordered_comm_ring Type) := sorry --non-trivial
lemma new_lemma_45895 (h1 : topological_space (nondiscrete_normed_field (normed_field linarith.ineq))) (h2 : set (nondiscrete_normed_field (normed_field linarith.ineq))) : is_path_connected h2 := sorry --non-trivial
lemma new_lemma_45896 (h0 : add_group (complete_semilattice_Sup (has_top fun_info))) : is_add_cyclic (complete_semilattice_Sup (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_45897 (h0 : functor.add_const (topological_space (add_group num)) (semiring (semiring (semiring (semiring empty))))) : @path_connected_space.{0} (add_group.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (add_group.{0} num)) (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} empty)))) h0)  := sorry --non-trivial
lemma new_lemma_45898 (h0 : topological_space (normed_group linarith.ineq)) : totally_separated_space (normed_group linarith.ineq) := sorry --non-trivial
lemma new_lemma_45899 (h3 : group (with_one num)) : is_cyclic (with_one num) := sorry --non-trivial
lemma new_lemma_45900 (h0 : function.extfun Type (functor.comp topological_space finset)) : @t1_space.{0} (finset.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} finset.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} finset.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_45901 (h0 : topological_space (has_nndist (option pos))) : preconnected_space (has_nndist (option pos)) := sorry --non-trivial
lemma new_lemma_45902 (h0 : functor.add_const (add_group (cancel_monoid pos)) linarith.comp) : @is_add_cyclic.{0} (cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (cancel_monoid.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_45903 (h0 : functor.add_const (topological_space (has_star unsigned)) congr_arg_kind) : @t1_space.{0} (has_star.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_45904 (h1 h2 : multiset (nondiscrete_normed_field (has_zero linarith.ineq))) : multiset.subset h1 h2 := sorry --non-trivial
lemma new_lemma_45905 (h0 : topological_space (add_right_cancel_monoid congr_arg_kind)) : discrete_topology (add_right_cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_45906 (h0 : ring (mul_one_class empty)) : is_principal_ideal_ring (mul_one_class empty) := sorry --non-trivial
lemma new_lemma_45907 (h0 : group (semigroup (has_Inf (has_Inf (has_pos_part linarith.comp))))) : is_simple_group (semigroup (has_Inf (has_Inf (has_pos_part linarith.comp)))) := sorry --non-trivial
lemma new_lemma_45908 (h0 : functor.add_const (topological_space (comm_group ennreal)) unsigned) : @regular_space.{0} (comm_group.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_45909 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_45910 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (random_gen.{0} string_imp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (random_gen.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_45911 (h3 : has_neg reducibility_hints) (h4 : measurable_space reducibility_hints) : has_measurable_neg reducibility_hints := sorry --non-trivial
lemma new_lemma_45912 (h1 : group (normed_group (random_gen string_imp))) : normalizer_condition (normed_group (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_45913 (h0 : functor.add_const (filter (ring pos)) (has_pos_part Type)) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_45914 (h0 : filter (metric_space (semiring (semiring unsigned)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_45915 (h0 : topological_space (random_gen num)) : path_connected_space (random_gen num) := sorry --non-trivial
lemma new_lemma_45916 (h0 : functor.add_const (group (monoid_with_zero name)) unsigned) : @is_cyclic.{0} (monoid_with_zero.{0} name) (@functor.add_const.run.{0 0} (group.{0} (monoid_with_zero.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_45917 (h0 : fin has_zero.zero) : @locally_compact_space.{0} (canonically_ordered_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (canonically_ordered_monoid.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_45918 (h0 : functor.add_const (list (has_zero Type)) environment.implicit_infer_kind) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_45919 (h0 : cancel_comm_monoid_with_zero (has_add (ring (option (option (has_zero (has_zero ennreal))))))) : unique_factorization_monoid (has_add (ring (option (option (has_zero (has_zero ennreal)))))) := sorry --non-trivial
lemma new_lemma_45920 (h0 : not (group (ordered_cancel_add_comm_monoid congr_arg_kind) -> false)) : @normalizer_condition.{0} (ordered_cancel_add_comm_monoid.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (group.{0} (ordered_cancel_add_comm_monoid.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_45921 (h0 : functor.add_const (functor.add_const (finset (add_left_cancel_semigroup unsigned)) empty) num) : finset.nonempty (functor.add_const.run (functor.add_const.run h0)) := sorry --non-trivial
lemma new_lemma_45922 (h0 : functor.add_const (function.extfun Type topological_space) (has_to_string environment.implicit_infer_kind)) : @irreducible_space.{0} (has_nndist.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (has_to_string.{0} environment.implicit_infer_kind) h0) (has_nndist.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_45923 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_45924 (h0 : fin has_zero.zero) : @is_compactly_generated.{0} (ring.{0} linarith.comp) (@matrix.vec_empty.{0} (complete_lattice.{0} (ring.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_45925 (h0 : not (topological_space (left_cancel_semigroup empty) -> false)) : @topological_space.separable_space.{0} (left_cancel_semigroup.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (left_cancel_semigroup.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_45926 (h0 : topological_space (pseudo_metric_space (option empty))) : path_connected_space (pseudo_metric_space (option empty)) := sorry --non-trivial
lemma new_lemma_45927 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (has_neg_part.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg_part.{0} name))  := sorry --non-trivial
lemma new_lemma_45928 (h0 : add_group (topological_space reducibility_hints)) : is_add_cyclic (topological_space reducibility_hints) := sorry --non-trivial
lemma new_lemma_45929 (h0 : topological_space (pseudo_metric_space (finset environment.implicit_infer_kind))) : discrete_topology (pseudo_metric_space (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_45930 (h0 : topological_space (semigroup (has_nndist Type))) : totally_disconnected_space (semigroup (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_45931 (h0 : topological_space (semiring (random_gen linarith.comp_source))) : totally_disconnected_space (semiring (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_45932 (h0 : uniform_space (ring (comm_group pos))) : complete_space (ring (comm_group pos)) := sorry --non-trivial
lemma new_lemma_45933 (h0 : finset (order_dual num)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_45934 (h0 : topological_space (boolean_algebra (finset (finset (finset linarith.comp))))) : loc_path_connected_space (boolean_algebra (finset (finset (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_45935 (h0 : topological_space (cancel_monoid empty)) : totally_disconnected_space (cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_45936 (h0 : ring (complete_linear_order num)) : strong_rank_condition (complete_linear_order num) := sorry --non-trivial
lemma new_lemma_45937 (h0 : cancel_comm_monoid_with_zero (omega_complete_partial_order congr_arg_kind)) : unique_factorization_monoid (omega_complete_partial_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_45938 (h0 : functor.add_const (ordered_add_comm_monoid (has_nndist pos)) (ring pos)) : @archimedean.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_nndist.{0} pos)) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_45939 (h0 : semiring (omega_complete_partial_order empty)) : is_noetherian_ring (omega_complete_partial_order empty) := sorry --non-trivial
lemma new_lemma_45940 (h0 : ring (has_ssubset environment.projection_info)) : strong_rank_condition (has_ssubset environment.projection_info) := sorry --non-trivial
lemma new_lemma_45941 (h0 : functor.add_const (topological_space (ordered_comm_group unsigned)) empty) : @path_connected_space.{0} (ordered_comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_group.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_45942 (h0 : functor.add_const (group (ring pos)) linarith.comp) : @group.fg.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (ring.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_45943 (h6 : add_group (random_gen to_additive.value_type)) : is_add_cyclic (random_gen to_additive.value_type) := sorry --non-trivial
lemma new_lemma_45944 (h0 : ring (ring (has_nndist (boolean_algebra name)))) : is_principal_ideal_ring (ring (has_nndist (boolean_algebra name))) := sorry --non-trivial
lemma new_lemma_45945 (h0 : cancel_comm_monoid_with_zero (add_left_cancel_semigroup num)) : unique_factorization_monoid (add_left_cancel_semigroup num) := sorry --non-trivial
lemma new_lemma_45946 (h0 : topological_space (distrib (has_ssubset to_additive.value_type))) : path_connected_space (distrib (has_ssubset to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_45947 (h0 : topological_space (canonically_ordered_comm_semiring (finset Type))) : normal_space (canonically_ordered_comm_semiring (finset Type)) := sorry --non-trivial
lemma new_lemma_45948 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (has_to_string.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_to_string.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_45949 (h0 : ring (distrib_lattice (with_bot fun_info))) : rank_condition (distrib_lattice (with_bot fun_info)) := sorry --non-trivial
lemma new_lemma_45950 (h0 : group (finset (option (option (option (option ennreal)))))) : normalizer_condition (finset (option (option (option (option ennreal))))) := sorry --non-trivial
lemma new_lemma_45951 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (left_cancel_monoid num)) := sorry --non-trivial
lemma new_lemma_45952 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (semiring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_45953 (h0 : add_monoid (normed_comm_ring (has_to_string (has_to_string unsigned)))) : add_monoid.fg (normed_comm_ring (has_to_string (has_to_string unsigned))) := sorry --non-trivial
lemma new_lemma_45954 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (complete_distrib_lattice.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_distrib_lattice.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_45955 (h0 : ring (measure_theory.measure_space (semiring empty))) : is_domain (measure_theory.measure_space (semiring empty)) := sorry --non-trivial
lemma new_lemma_45956 (h0 : monoid (cancel_monoid (option (option ennreal)))) : monoid.fg (cancel_monoid (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_45957 (h0 : topological_space (measurable_space linarith.comp_source)) : totally_separated_space (measurable_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_45958 (h2 : topological_space (semi_normed_ring fun_info)) : totally_disconnected_space (semi_normed_ring fun_info) := sorry --non-trivial
lemma new_lemma_45959 (h0 : add_monoid (plift (option num))) : add_monoid.fg (plift (option num)) := sorry --non-trivial
lemma new_lemma_45960 (h0 : add_group (topological_space (add_semigroup (random_gen string_imp)))) : is_add_cyclic (topological_space (add_semigroup (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_45961 (h0 : functor.add_const (topological_space (preorder num)) num) : @discrete_topology.{0} (preorder.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (preorder.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_45962 (h0 : functor.add_const (topological_space (has_inter unsigned)) empty) : @discrete_topology.{0} (has_inter.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_inter.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_45963 (h0 : finset (simple_graph (has_neg name))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_45964 (h0 : ring (normed_field (mul_one_class (mul_one_class (has_nnnorm reducibility_hints))))) : strong_rank_condition (normed_field (mul_one_class (mul_one_class (has_nnnorm reducibility_hints)))) := sorry --non-trivial
lemma new_lemma_45965 (h0 : uniform_space (canonically_ordered_comm_semiring (finset pos))) : separated_space (canonically_ordered_comm_semiring (finset pos)) := sorry --non-trivial
lemma new_lemma_45966 (h0 : add_monoid (normed_lattice_add_comm_group (has_add (has_Inf (has_add pos))))) : add_monoid.fg (normed_lattice_add_comm_group (has_add (has_Inf (has_add pos)))) := sorry --non-trivial
lemma new_lemma_45967 (h0 : add_group (normed_lattice_add_comm_group (has_neg real))) : is_add_cyclic (normed_lattice_add_comm_group (has_neg real)) := sorry --non-trivial
lemma new_lemma_45968 (h0 : functor.add_const (list (add_cancel_monoid Type)) (has_neg Type)) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_45969 (h0 : linear_ordered_field (ring ennreal) -> linear_ordered_field (ring ennreal) -> Prop) : is_symm (linear_ordered_field (ring ennreal)) h0 := sorry --non-trivial
lemma new_lemma_45970 (h0 : topological_space (add_right_cancel_monoid empty)) : loc_path_connected_space (add_right_cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_45971 (h0 : topological_space (distrib string.iterator_imp)) : totally_disconnected_space (distrib string.iterator_imp) := sorry --non-trivial
lemma new_lemma_45972 (h0 : topological_space (monoid fun_info)) : totally_disconnected_space (monoid fun_info) := sorry --non-trivial
lemma new_lemma_45973 (h0 : uniform_space (has_union (semiring linarith.comp))) : complete_space (has_union (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_45974 (h0 : ring (complete_linear_order congr_arg_kind)) : is_principal_ideal_ring (complete_linear_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_45975 (h0 : fin has_zero.zero) : @group.fg.{0} real (@matrix.vec_empty.{0} (group.{0} real) h0)  := sorry --non-trivial
lemma new_lemma_45976 (h0 : uniform_space (monoid congr_arg_kind)) : complete_space (monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_45977 (h0 : functor.add_const (topological_space (option pos)) ennreal) : @normal_space.{0} (option.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} pos)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_45978 (h0 : functor.add_const (filter (complete_distrib_lattice pos)) Type) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_45979 (h0 : not (complete_lattice (non_assoc_semiring unsigned) -> false)) : @is_compactly_generated.{0} (non_assoc_semiring.{0} unsigned) (@classical.by_contradiction'.{1} (complete_lattice.{0} (non_assoc_semiring.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_45980 (h0 : not (topological_space (has_compl fun_info) -> false)) : @totally_disconnected_space.{0} (has_compl.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (has_compl.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_45981 (h0 : topological_space (has_div (has_compl enat))) : path_connected_space (has_div (has_compl enat)) := sorry --non-trivial
lemma new_lemma_45982 (h0 : add_group (comm_monoid empty)) : is_add_cyclic (comm_monoid empty) := sorry --non-trivial
lemma new_lemma_45983 (h0 : functor.add_const (topological_space (has_dist unsigned)) empty) : @totally_disconnected_space.{0} (has_dist.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_dist.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_45984 (h0 : list (has_add (has_neg pos))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_45985 (h0 : ring (ring congr_arg_kind)) : strong_rank_condition (ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_45986 (h0 : topological_space (canonically_ordered_comm_semiring (finset (group_with_zero Type)))) : preconnected_space (canonically_ordered_comm_semiring (finset (group_with_zero Type))) := sorry --non-trivial
lemma new_lemma_45987 (h1 : not (topological_space (semiring linarith.comp) -> false)) : @discrete_topology.{0} (semiring.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (semiring.{0} linarith.comp)) h1)  := sorry --non-trivial
lemma new_lemma_45988 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_45989 (h0 : topological_space (id (has_norm unsigned))) : irreducible_space (id (has_norm unsigned)) := sorry --non-trivial
lemma new_lemma_45990 (h0 : ring (random_gen (semiring linarith.comp_source))) : rank_condition (random_gen (semiring linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_45991 (h0 : complete_lattice (with_bot linarith.comp)) : complete_lattice.is_Sup_finite_compact (with_bot linarith.comp) := sorry --non-trivial
lemma new_lemma_45992 (h0 : topological_space (has_nndist num)) : preirreducible_space (has_nndist num) := sorry --non-trivial
lemma new_lemma_45993 (h0 : functor.add_const (ring auto.case_option) num) : @is_domain.{0} auto.case_option (@functor.add_const.run.{0 0} (ring.{0} auto.case_option) num h0)  := sorry --non-trivial
lemma new_lemma_45994 (h0 : ring (random_gen (has_norm (has_norm linarith.comp)))) : strong_rank_condition (random_gen (has_norm (has_norm linarith.comp))) := sorry --non-trivial
lemma new_lemma_45995 (h0 : topological_space (comm_group (semigroup unsigned))) : path_connected_space (comm_group (semigroup unsigned)) := sorry --non-trivial
lemma new_lemma_45996 (h0 : add_group (simple_graph (finset name))) : is_add_cyclic (simple_graph (finset name)) := sorry --non-trivial
lemma new_lemma_45997 (h0 : functor.add_const (ring (measurable_space.dynkin_system unsigned)) unsigned) : @rank_condition.{0} (measurable_space.dynkin_system.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (measurable_space.dynkin_system.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_45998 (h0 : not (ring (distrib (random_gen to_additive.value_type)) -> false)) : @strong_rank_condition.{0} (distrib.{0} (random_gen.{0} to_additive.value_type)) (@classical.by_contradiction'.{1} (ring.{0} (distrib.{0} (random_gen.{0} to_additive.value_type))) h0)  := sorry --non-trivial
lemma new_lemma_45999 (h0 : topological_space (cancel_monoid num)) : totally_separated_space (cancel_monoid num) := sorry --non-trivial
lemma new_lemma_46000 (h0 : topological_space (has_neg_part (has_add Type))) : t1_space (has_neg_part (has_add Type)) := sorry --non-trivial
lemma new_lemma_46001 (h0 : topological_space (has_to_string (has_neg Type))) : totally_disconnected_space (has_to_string (has_neg Type)) := sorry --non-trivial
lemma new_lemma_46002 (h0 : complete_lattice (has_add (option (option (option (option ennreal)))))) : complete_lattice.is_Sup_finite_compact (has_add (option (option (option (option ennreal))))) := sorry --non-trivial
lemma new_lemma_46003 (h0 : not (function.extfun Type topological_space -> false)) : @topological_space.separable_space.{0} (left_cancel_semigroup.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (left_cancel_semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_46004 (h0 : functor.add_const (topological_space (has_nndist linarith.comp)) Type) : @path_connected_space.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_nndist.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_46005 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_neg_part.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_neg_part.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_46006 (h0 : ordered_comm_monoid (has_add (has_add (has_add pos)))) : has_exists_mul_of_le (has_add (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_46007 (h0 : function.extfun Type ring) : @is_domain.{0} (has_edist.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_edist.{0} empty))  := sorry --non-trivial
lemma new_lemma_46008 (h0 : semiring empty -> semiring empty -> Prop) : transitive h0 := sorry --non-trivial
lemma new_lemma_46009 (h0 : finset (has_neg_part environment.implicit_infer_kind)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_46010 (h0 : complete_lattice (ring name)) : complete_lattice.is_Sup_finite_compact (ring name) := sorry --non-trivial
lemma new_lemma_46011 (h0 : functor.add_const (monoid (has_neg Type)) pos) : @monoid.fg.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (monoid.{1} (has_neg.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_46012 (h0 : function.extfun Type group) : @is_cyclic.{0} (comm_group.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_46013 (h0 : ordered_add_comm_monoid (measurable_space string_imp)) : archimedean (measurable_space string_imp) := sorry --non-trivial
lemma new_lemma_46014 (h0 : functor.add_const (ring (has_zero environment.implicit_infer_kind)) linarith.comp) : @is_domain.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (has_zero.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_46015 (h0 : uniform_space (ordered_comm_monoid (ring (ring pos)))) : complete_space (ordered_comm_monoid (ring (ring pos))) := sorry --non-trivial
lemma new_lemma_46016 (h0 : semiring (measurable_space.dynkin_system (semiring (semiring (has_norm empty))))) : is_noetherian_ring (measurable_space.dynkin_system (semiring (semiring (has_norm empty)))) := sorry --non-trivial
lemma new_lemma_46017 (h0 : topological_space (complete_linear_order (semiring (has_top congr_arg_kind)))) : topological_space.separable_space (complete_linear_order (semiring (has_top congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_46018 (h1 : topological_space (has_norm (has_norm fun_info))) : totally_separated_space (has_norm (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_46019 (h0 : not (topological_space (semiring num) -> false)) : @discrete_topology.{0} (semiring.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (semiring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_46020 (h0 : set (add_comm_semigroup (normed_field (mul_one_class fun_info)) -> char)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_46021 (h0 : functor.add_const (topological_space auto.case_option) num) : @irreducible_space.{0} auto.case_option (@functor.add_const.run.{0 0} (topological_space.{0} auto.case_option) num h0)  := sorry --non-trivial
lemma new_lemma_46022 (h0 : topological_space (has_dist (option num))) : normal_space (has_dist (option num)) := sorry --non-trivial
lemma new_lemma_46023 (h0 : topological_space (denumerable (denumerable linarith.ineq))) : path_connected_space (denumerable (denumerable linarith.ineq)) := sorry --non-trivial
lemma new_lemma_46024 (h0 : topological_space (has_add (has_Inf (has_pos_part (has_pos_part Type))))) : t1_space (has_add (has_Inf (has_pos_part (has_pos_part Type)))) := sorry --non-trivial
lemma new_lemma_46025 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (complete_semilattice_Sup.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} h0 (complete_semilattice_Sup.{0} empty))  := sorry --non-trivial
lemma new_lemma_46026 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_46027 (h0 : topological_space (pseudo_emetric_space num)) : t0_space (pseudo_emetric_space num) := sorry --non-trivial
lemma new_lemma_46028 (h0 : topological_space (complete_distrib_lattice (normed_comm_ring name))) : path_connected_space (complete_distrib_lattice (normed_comm_ring name)) := sorry --non-trivial
lemma new_lemma_46029 (h0 : complete_lattice (finset (normed_comm_ring (normed_comm_ring Type)))) : is_compactly_generated (finset (normed_comm_ring (normed_comm_ring Type))) := sorry --non-trivial
lemma new_lemma_46030 (h0 : topological_space (add_comm_monoid (has_to_string Type))) : topological_space.separable_space (add_comm_monoid (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_46031 (h0 : functor.add_const (prod (bin_tree empty) (bin_tree empty)) unsigned) : id_rel (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_46032 (h1 : topological_space (semiring to_additive.value_type)) : irreducible_space (semiring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_46033 (h0 : boolean_algebra.core (comm_group (has_add Type)) -> boolean_algebra.core (comm_group (has_add Type)) -> Prop) : well_founded h0 := sorry --non-trivial
lemma new_lemma_46034 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (has_union.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_union.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_46035 (h0 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} (with_bot.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h0) (with_bot.{0} empty))  := sorry --non-trivial
lemma new_lemma_46036 (h0 : functor.add_const (topological_space (normed_comm_ring Type)) pos) : @locally_compact_space.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (normed_comm_ring.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_46037 (h0 : functor.add_const (topological_space (add_cancel_monoid name)) name) : @path_connected_space.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_46038 (h0 : function.extfun Type (functor.comp topological_space boolean_algebra.core)) : @irreducible_space.{0} (boolean_algebra.core.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind)) (@functor.comp.run.{0 0 0} topological_space.{0} boolean_algebra.core.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} boolean_algebra.core.{0}) h0 (complete_distrib_lattice.{0} environment.implicit_infer_kind)))  := sorry --non-trivial
lemma new_lemma_46039 (h0 : semiring (add_comm_semigroup char)) (h1 : ideal (add_comm_semigroup char)) : ideal.is_prime h1 := sorry --non-trivial
lemma new_lemma_46040 (h0 : topological_space (boolean_algebra (finset (has_neg (ring (finset (boolean_algebra Type))))))) : path_connected_space (boolean_algebra (finset (has_neg (ring (finset (boolean_algebra Type)))))) := sorry --non-trivial
lemma new_lemma_46041 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @t1_space.{1} (canonically_linear_ordered_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (canonically_linear_ordered_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_46042 (h0 : ring (semigroup (simple_graph char))) : rank_condition (semigroup (simple_graph char)) := sorry --non-trivial
lemma new_lemma_46043 (h0 : functor.add_const (topological_space (simple_graph empty)) unsigned) : @totally_separated_space.{0} (simple_graph.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (simple_graph.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_46044 (h0 : monoid (has_top (random_gen linarith.ineq))) : monoid.fg (has_top (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_46045 (h0 : functor.add_const (functor.add_const (group linarith.comp) linarith.comp) linarith.comp) : @is_simple_group.{0} linarith.comp (@functor.add_const.run.{0 0} (group.{0} linarith.comp) linarith.comp (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (group.{0} linarith.comp) linarith.comp) linarith.comp h0))  := sorry --non-trivial
lemma new_lemma_46046 (h0 : functor.add_const (topological_space (has_neg name)) name) : @normal_space.{0} (has_neg.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_46047 (h0 : uniform_space (has_norm fun_info)) : separated_space (has_norm fun_info) := sorry --non-trivial
lemma new_lemma_46048 (h0 : functor.add_const (topological_space (comm_group Type)) name) : @preirreducible_space.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (comm_group.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_46049 (h0 : topological_space (has_nnnorm (random_gen (random_gen fun_info)))) : t0_space (has_nnnorm (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_46050 (h0 : group (ordered_comm_monoid (has_add linarith.comp))) : is_cyclic (ordered_comm_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_46051 (h0 : topological_space (comm_semigroup (has_pos_part (comm_semigroup (has_Inf pos))))) : preirreducible_space (comm_semigroup (has_pos_part (comm_semigroup (has_Inf pos)))) := sorry --non-trivial
lemma new_lemma_46052 (h0 : topological_space (boolean_algebra.core (ring (ring pos)))) : preconnected_space (boolean_algebra.core (ring (ring pos))) := sorry --non-trivial
lemma new_lemma_46053 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (has_bot name)) := sorry --non-trivial
lemma new_lemma_46054 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : list.head (function.extfun_app (function.extfun_app h1 list) Prop) := sorry --non-trivial
lemma new_lemma_46055 (h0 : function.extfun nat fin) : @monoid.fg.{0} (canonically_ordered_comm_semiring.{0} pos) (@matrix.vec_empty.{0} (monoid.{0} (canonically_ordered_comm_semiring.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_46056 (h0 : group (canonically_ordered_monoid name)) : is_simple_group (canonically_ordered_monoid name) := sorry --non-trivial
lemma new_lemma_46057 (h0 : function.extfun nat fin) : @add_monoid.fg.{0} (has_Inf.{0} name) (@matrix.vec_empty.{0} (add_monoid.{0} (has_Inf.{0} name)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_46058 (h0 : ring (comm_ring (has_norm (has_top to_additive.value_type)))) : is_domain (comm_ring (has_norm (has_top to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_46059 (h0 : functor.add_const (group (linear_ordered_comm_monoid_with_zero unsigned)) unsigned) : @normalizer_condition.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_46060 (h0 : fin has_zero.zero) (h1 : fin (nat.succ (matrix.vec_empty h0)) -> fin has_zero.zero) (h2 : fin (matrix.vec_empty h0)) : matrix.vec_empty (matrix.vec_tail h1 h2) := sorry --non-trivial
lemma new_lemma_46061 (h0 : functor.add_const (function.extfun Type group) linarith.comp) : @normalizer_condition.{0} (finset.{0} (ring.{0} linarith.comp)) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) linarith.comp h0) (finset.{0} (ring.{0} linarith.comp)))  := sorry --non-trivial
lemma new_lemma_46062 (h0 : uniform_space (ordered_comm_group (comm_monoid unsigned))) : separated_space (ordered_comm_group (comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_46063 (h0 : list (filter congr_arg_kind)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_46064 (h0 : not (function.extfun Type topological_space -> false)) : @totally_disconnected_space.{0} (has_union.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_union.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_46065 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (add_group.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_46066 (h0 : functor.add_const (topological_space (has_Inf linarith.comp)) Type) : @path_connected_space.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_Inf.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_46067 (h0 : function.extfun Type group) : @normalizer_condition.{0} (comm_group.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} h0 (comm_group.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_46068 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (complete_linear_order.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (complete_linear_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_46069 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (has_pos_part.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_pos_part.{0} name))  := sorry --non-trivial
lemma new_lemma_46070 (h0 : ring (ordered_comm_ring (comm_semigroup real))) : is_domain (ordered_comm_ring (comm_semigroup real)) := sorry --non-trivial
lemma new_lemma_46071 (h0 : uniform_space (has_sub empty)) : separated_space (has_sub empty) := sorry --non-trivial
lemma new_lemma_46072 (h0 : functor.add_const (uniform_space (ring linarith.comp)) pos) : @complete_space.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (ring.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_46073 (h0 : functor.comp group normed_comm_ring name) : @normalizer_condition.{0} (normed_comm_ring.{0} name) (@functor.comp.run.{0 0 0} group.{0} normed_comm_ring.{0} name h0)  := sorry --non-trivial
lemma new_lemma_46074 (h0 : group (denumerable linarith.comp_source)) : is_cyclic (denumerable linarith.comp_source) := sorry --non-trivial
lemma new_lemma_46075 (h0 : complete_lattice (comm_semigroup (has_bot pos))) : is_compactly_generated (comm_semigroup (has_bot pos)) := sorry --non-trivial
lemma new_lemma_46076 (h0 : has_zero (monoid congr_arg_kind) -> has_zero (monoid congr_arg_kind) -> Prop) : is_symm (has_zero (monoid congr_arg_kind)) h0 := sorry --non-trivial
lemma new_lemma_46077 (h0 : set (set (mul_one_class reducibility_hints))) (h1 : set (mul_one_class reducibility_hints)) : filter.generate_sets h0 h1 := sorry --non-trivial
lemma new_lemma_46078 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (bin_tree.{0} num) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (bin_tree.{0} num))  := sorry --non-trivial
lemma new_lemma_46079 (h0 : add_group (rel (option unsigned) unsigned)) : is_add_cyclic (rel (option unsigned) unsigned) := sorry --non-trivial
lemma new_lemma_46080 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_to_string.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_46081 (h0 : has_mem.mem (normed_group num) has_emptyc.emptyc) : @separated_space.{0} (normed_group.{0} num) (@finset.pi.empty.{1 0} Type uniform_space.{0} (normed_group.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_46082 (h0 : list (dlist (random_gen (has_ssubset (random_gen to_additive.value_type))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_46083 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_one.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_one.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_46084 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @t0_space.{0} (has_union.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) topological_space.{0}) (has_union.{0} empty))  := sorry --non-trivial
lemma new_lemma_46085 (h0 : functor.add_const (topological_space (plift name)) unsigned) : @discrete_topology.{1} (plift.{1} name) (@functor.add_const.run.{1 0} (topological_space.{1} (plift.{1} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_46086 (h0 : group (boolean_algebra.core (has_neg Type))) : normalizer_condition (boolean_algebra.core (has_neg Type)) := sorry --non-trivial
lemma new_lemma_46087 (h4 : complete_lattice (random_gen (random_gen fun_info))) : is_compactly_generated (random_gen (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_46088 (h0 : group (measurable_space (random_gen (has_norm (has_inv linarith.ineq))))) : normalizer_condition (measurable_space (random_gen (has_norm (has_inv linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_46089 (h0 : topological_space (has_star (option (option (option unsigned))))) : t1_space (has_star (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_46090 (h1 : add_monoid (with_one (has_top fun_info))) : add_monoid.fg (with_one (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_46091 (h0 : filter (has_top (comm_ring (comm_ring linarith.ineq)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_46092 (h0 : list (linear_ordered_add_comm_group (random_gen (dlist linarith.ineq)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_46093 (h0 : ring (finset (has_bot Type))) : rank_condition (finset (has_bot Type)) := sorry --non-trivial
lemma new_lemma_46094 (h0 : function.extfun (Type 1) ring) : @is_domain.{1} (has_neg_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (has_neg_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_46095 (h0 : pnat) (h1 : ulower pnat) : pnat.coprime h0 (ulower.up (id h1)) := sorry --non-trivial
lemma new_lemma_46096 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (filter.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (filter.{0} empty))  := sorry --non-trivial
lemma new_lemma_46097 (h1 : not (monoid (measurable_space congr_arg_kind) -> false)) : @monoid.fg.{0} (measurable_space.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (monoid.{0} (measurable_space.{0} congr_arg_kind)) h1)  := sorry --non-trivial
lemma new_lemma_46098 (h0 : topological_space (random_gen linarith.ineq)) : path_connected_space (random_gen linarith.ineq) := sorry --non-trivial
lemma new_lemma_46099 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (with_one.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_one.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_46100 (h0 : topological_space (semigroup (comm_group name))) : t1_space (semigroup (comm_group name)) := sorry --non-trivial
lemma new_lemma_46101 (h0 : topological_space (normed_lattice_add_comm_group (has_add (finset pos)))) : loc_path_connected_space (normed_lattice_add_comm_group (has_add (finset pos))) := sorry --non-trivial
lemma new_lemma_46102 (h0 : cancel_comm_monoid_with_zero (has_one (semiring unsigned))) : unique_factorization_monoid (has_one (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_46103 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (add_right_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_right_cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_46104 (h0 : add_zero_class (plift empty)) (h1 : add_group (add_submonoid (plift empty))) : is_add_cyclic (add_submonoid (plift empty)) := sorry --non-trivial
lemma new_lemma_46105 (h1 : add_group (with_bot (has_top fun_info))) : is_add_cyclic (with_bot (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_46106 (h0 : ring (has_add (monoid_with_zero linarith.comp))) : rank_condition (has_add (monoid_with_zero linarith.comp)) := sorry --non-trivial
lemma new_lemma_46107 (h0 : functor.add_const (monoid (has_nndist pos)) (finset (finset Type))) : @monoid.fg.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 1} (monoid.{0} (has_nndist.{0} pos)) (finset.{1} (finset.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_46108 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (has_bot.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (has_bot.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_46109 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (measurable_space.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type monoid.{0} h0 (measurable_space.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_46110 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_46111 (h0 : complete_lattice (canonically_ordered_monoid (has_add real))) : complete_lattice.is_Sup_finite_compact (canonically_ordered_monoid (has_add real)) := sorry --non-trivial
lemma new_lemma_46112 (h0 : group (dlist (comm_ring linarith.comp_source))) : group.fg (dlist (comm_ring linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_46113 (h1 : group (has_append fun_info)) : is_cyclic (has_append fun_info) := sorry --non-trivial
lemma new_lemma_46114 (h0 : functor.add_const (topological_space (semigroup Type)) Type) : @path_connected_space.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (semigroup.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_46115 (h0 : ring (has_top (random_gen (random_gen (random_gen (random_gen linarith.ineq)))))) : strong_rank_condition (has_top (random_gen (random_gen (random_gen (random_gen linarith.ineq))))) := sorry --non-trivial
lemma new_lemma_46116 (h0 : ring (add_comm_monoid (option ennreal))) : rank_condition (add_comm_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_46117 (h0 : complete_lattice (comm_group (option name))) : is_atomistic (comm_group (option name)) := sorry --non-trivial
lemma new_lemma_46118 (h0 : functor.comp topological_space boolean_algebra.core pos) : @preconnected_space.{0} (boolean_algebra.core.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} boolean_algebra.core.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_46119 (h0 : function.extfun (finset Type) (has_mem.mem (has_top linarith.comp_source))) : @totally_disconnected_space.{0} (has_top.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_top.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_top.{0} linarith.comp_source)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_46120 (h0 : function.extfun Type (functor.comp ring has_neg)) : @rank_condition.{0} (has_neg.{0} name) (@functor.comp.run.{0 0 0} ring.{0} has_neg.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} ring.{0} has_neg.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_46121 (h0 : topological_space (distrib (has_nnnorm (has_nnnorm (random_gen (has_nnnorm fun_info)))))) : totally_disconnected_space (distrib (has_nnnorm (has_nnnorm (random_gen (has_nnnorm fun_info))))) := sorry --non-trivial
lemma new_lemma_46122 (h0 : filter (with_one (has_top empty))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_46123 (h0 : group (has_neg_part (has_neg_part pos))) : is_cyclic (has_neg_part (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_46124 (h0 : topological_space (has_ssubset (mul_one_class char))) : t0_space (has_ssubset (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_46125 (h0 : add_monoid (normed_comm_ring (option (option empty)))) : add_monoid.fg (normed_comm_ring (option (option empty))) := sorry --non-trivial
lemma new_lemma_46126 (h0 : functor.add_const (ring (comm_group Type)) (comm_group Type)) : @strong_rank_condition.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 1} (ring.{1} (comm_group.{1} Type)) (comm_group.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_46127 (h0 : ordered_comm_monoid (boolean_algebra.core (option pos))) : has_exists_mul_of_le (boolean_algebra.core (option pos)) := sorry --non-trivial
lemma new_lemma_46128 (h0 : prod (add_cancel_monoid pos) (add_cancel_monoid pos)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_46129 (h0 : topological_space (boolean_algebra.core (has_add (has_add Type)))) : t1_space (boolean_algebra.core (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_46130 (h0 : functor.add_const (topological_space (has_neg name)) linarith.comp) : @loc_path_connected_space.{0} (has_neg.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_46131 (h0 : topological_space (linear_ordered_semiring (random_gen fun_info))) : discrete_topology (linear_ordered_semiring (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_46132 (h0 : topological_space (has_neg (has_add (comm_group name)))) : loc_path_connected_space (has_neg (has_add (comm_group name))) := sorry --non-trivial
lemma new_lemma_46133 (h0 : has_mem.mem (measurable_space empty) has_emptyc.emptyc) : @irreducible_space.{0} (measurable_space.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (measurable_space.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_46134 (h0 : ring (semi_normed_comm_ring (mul_one_class string.iterator_imp))) : strong_rank_condition (semi_normed_comm_ring (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_46135 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (complete_distrib_lattice.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (complete_distrib_lattice.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_46136 (h0 : set (mul_one_class enat -> char)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_46137 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (boolean_algebra.core.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_46138 (h0 : functor.add_const (topological_space (cancel_monoid name)) (semigroup (has_add name))) : @totally_disconnected_space.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} name)) (semigroup.{0} (has_add.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_46139 (h0 : ring (has_zero (has_add Type))) : rank_condition (has_zero (has_add Type)) := sorry --non-trivial
lemma new_lemma_46140 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} linarith.comp_source (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_46141 (h0 : ordered_add_comm_monoid (cancel_monoid (cancel_monoid Type))) : archimedean (cancel_monoid (cancel_monoid Type)) := sorry --non-trivial
lemma new_lemma_46142 (h0 : topological_space (cancel_monoid (has_add pos))) : t1_space (cancel_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_46143 (h0 : list (bin_tree (semiring (semiring empty)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_46144 (h0 : topological_space (ordered_comm_monoid (has_to_string pos))) : sequential_space (ordered_comm_monoid (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_46145 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (boolean_algebra.core.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} pos))  := sorry --non-trivial
lemma new_lemma_46146 (h0 : functor.add_const (topological_space (ring pos)) (ring (ring linarith.comp))) : @loc_path_connected_space.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} pos)) (ring.{0} (ring.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_46147 (h0 : functor.add_const (add_monoid (has_pos_part linarith.comp)) (ordered_ring linarith.comp)) : @add_monoid.fg.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_pos_part.{0} linarith.comp)) (ordered_ring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_46148 (h0 : monoid (has_dist (comm_monoid (comm_monoid (comm_monoid (comm_monoid unsigned)))))) : monoid.fg (has_dist (comm_monoid (comm_monoid (comm_monoid (comm_monoid unsigned))))) := sorry --non-trivial
lemma new_lemma_46149 (h0 : add_monoid (simple_graph (has_add Type))) : add_monoid.fg (simple_graph (has_add Type)) := sorry --non-trivial
lemma new_lemma_46150 (h0 : has_lt (mul_one_class (add_comm_semigroup char))) : no_max_order (mul_one_class (add_comm_semigroup char)) := sorry --non-trivial
lemma new_lemma_46151 (h0 : ring (has_union (has_norm (has_norm num)))) : rank_condition (has_union (has_norm (has_norm num))) := sorry --non-trivial
lemma new_lemma_46152 (h0 : topological_space (semi_normed_ring linarith.comp_source)) (h1 : preorder (semi_normed_ring linarith.comp_source)) : order_topology (semi_normed_ring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_46153 (h0 : function.extfun (Type 1) topological_space) : @totally_separated_space.{1} (plift.{1} empty) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (plift.{1} empty))  := sorry --non-trivial
lemma new_lemma_46154 (h0 : functor.add_const (topological_space (boolean_algebra environment.implicit_infer_kind)) linarith.comp) : @totally_separated_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_46155 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @t0_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (boolean_algebra.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_46156 (h0 : topological_space (has_add ennreal)) : totally_disconnected_space (has_add ennreal) := sorry --non-trivial
lemma new_lemma_46157 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_Inf.{0} real) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_Inf.{0} real))  := sorry --non-trivial
lemma new_lemma_46158 (h0 : functor.add_const (complete_lattice (filter empty)) empty) : is_atomistic (filter empty) := sorry --non-trivial
lemma new_lemma_46159 (h0 : functor.add_const (add_group (has_nndist pos)) (has_pos_part pos)) : @is_add_cyclic.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (has_nndist.{0} pos)) (has_pos_part.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_46160 (h0 : function.extfun Type ring) : @is_domain.{0} (add_comm_monoid.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_comm_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_46161 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} environment.implicit_infer_kind (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) environment.implicit_infer_kind)  := sorry --non-trivial
lemma new_lemma_46162 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_neg.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_46163 (h0 : ordered_add_comm_monoid (partial_order unsigned)) : archimedean (partial_order unsigned) := sorry --non-trivial
lemma new_lemma_46164 (h0 : ring (bin_tree (option (option empty)))) : is_domain (bin_tree (option (option empty))) := sorry --non-trivial
lemma new_lemma_46165 (h0 : topological_space (normed_comm_ring (normed_comm_ring linarith.comp))) : topological_space.separable_space (normed_comm_ring (normed_comm_ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_46166 (h0 : complete_lattice (has_inv (with_bot (random_gen (with_bot string_imp))))) : is_compactly_generated (has_inv (with_bot (random_gen (with_bot string_imp)))) := sorry --non-trivial
lemma new_lemma_46167 (h0 : not (topological_space (linear_ordered_semiring empty) -> false)) : @discrete_topology.{0} (linear_ordered_semiring.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_46168 (h0 : uniform_space (normed_group (complete_semilattice_Sup num))) : separated_space (normed_group (complete_semilattice_Sup num)) := sorry --non-trivial
lemma new_lemma_46169 (h0 : functor.add_const (topological_space (boolean_algebra.core name)) name) : @totally_disconnected_space.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_46170 (h0 : group (distrib_lattice (has_nnnorm (has_nnnorm (random_gen fun_info))))) : group.fg (distrib_lattice (has_nnnorm (has_nnnorm (random_gen fun_info)))) := sorry --non-trivial
lemma new_lemma_46171 (h0 : functor.add_const (function.extfun Type topological_space) environment.implicit_infer_kind) : @preirreducible_space.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) environment.implicit_infer_kind h0) (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_46172 (h0 : functor.add_const (ring (linear_ordered_comm_monoid_with_zero empty)) empty) : @is_principal_ideal_ring.{0} (linear_ordered_comm_monoid_with_zero.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (linear_ordered_comm_monoid_with_zero.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_46173 (h0 : complete_lattice (normed_group string_imp)) : complete_lattice.is_Sup_finite_compact (normed_group string_imp) := sorry --non-trivial
lemma new_lemma_46174 (h0 : topological_space (boolean_algebra (finset linarith.comp))) : discrete_topology (boolean_algebra (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_46175 (h0 : filter (has_nndist (finset environment.implicit_infer_kind))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_46176 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (ordered_comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (ordered_comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_46177 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (left_cancel_monoid.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (uniform_space.{0} (left_cancel_monoid.{0} empty))) (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 (functor.add_const.{0 0} (uniform_space.{0} (left_cancel_monoid.{0} empty)))) empty))  := sorry --non-trivial
lemma new_lemma_46178 (h0 : complete_lattice (add_comm_monoid Type)) : is_atomistic (add_comm_monoid Type) := sorry --non-trivial
lemma new_lemma_46179 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (boolean_algebra.core.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (boolean_algebra.core.{0} empty))  := sorry --non-trivial
lemma new_lemma_46180 (h0 : functor.add_const (complete_lattice (has_zero ennreal)) unsigned) : @is_atomistic.{0} (has_zero.{0} ennreal) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_zero.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_46181 (h0 : functor.add_const (topological_space (has_nndist pos)) linarith.comp) : @loc_path_connected_space.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_46182 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (ring.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_46183 (h2 : topological_space (semi_normed_comm_ring linarith.ineq)) : path_connected_space (semi_normed_comm_ring linarith.ineq) := sorry --non-trivial
lemma new_lemma_46184 (h0 : functor.add_const (fin has_zero.zero) (has_Inf linarith.comp)) : @unique_factorization_monoid.{0} (has_bot.{0} real) (@matrix.vec_empty.{0} (cancel_comm_monoid_with_zero.{0} (has_bot.{0} real)) (@functor.add_const.run.{0 0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (has_Inf.{0} linarith.comp) h0))  := sorry --non-trivial
lemma new_lemma_46185 (h0 : set (has_lt enat)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_46186 (h0 : has_le (non_unital_non_assoc_semiring std_gen)) (h1 : bounded_order (non_unital_non_assoc_semiring std_gen)) : is_simple_order (non_unital_non_assoc_semiring std_gen) := sorry --non-trivial
lemma new_lemma_46187 (h0 : topological_space (comm_monoid (semiring empty))) : preirreducible_space (comm_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_46188 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (preorder.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (preorder.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_46189 (h0 : functor.add_const (ring (add_comm_monoid pos)) pos) : @rank_condition.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (add_comm_monoid.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_46190 (h0 : topological_space (ordered_comm_ring pos)) : regular_space (ordered_comm_ring pos) := sorry --non-trivial
lemma new_lemma_46191 (h0 : fin has_zero.zero) : @is_principal_ideal_ring.{0} (normed_lattice_add_comm_group.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ring.{0}) h0) (normed_lattice_add_comm_group.{0} name))  := sorry --non-trivial
lemma new_lemma_46192 (h0 : fin has_zero.zero) : @normalizer_condition.{0} (ordered_comm_ring.{0} real) (@matrix.vec_empty.{0} (group.{0} (ordered_comm_ring.{0} real)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_46193 (h0 : uniform_space (with_bot (has_emptyc (has_emptyc to_additive.value_type)))) : complete_space (with_bot (has_emptyc (has_emptyc to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_46194 (h3 : complete_lattice (has_ssubset linarith.ineq)) : is_compactly_generated (has_ssubset linarith.ineq) := sorry --non-trivial
lemma new_lemma_46195 (h0 : function.extfun Type topological_space) : @t1_space.{0} (add_comm_monoid.{0} (has_nndist.{0} (has_neg_part.{0} (comm_group.{0} (comm_group.{0} (comm_group.{0} name)))))) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} (has_nndist.{0} (has_neg_part.{0} (comm_group.{0} (comm_group.{0} (comm_group.{0} name)))))))  := sorry --non-trivial
lemma new_lemma_46196 (h0 : functor.add_const (add_monoid (semigroup empty)) empty) : @add_monoid.fg.{0} (semigroup.{0} empty) (@functor.add_const.run.{0 0} (add_monoid.{0} (semigroup.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_46197 (h1 : function.extfun Type topological_space) : @totally_separated_space.{0} linarith.comp (@function.extfun_app.{2 1} Type topological_space.{0} h1 linarith.comp)  := sorry --non-trivial
lemma new_lemma_46198 (h0 : function.extfun (finset Type) (has_mem.mem (random_gen num))) : @strong_rank_condition.{0} (random_gen.{0} num) (@finset.pi.empty.{1 0} Type ring.{0} (random_gen.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_46199 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (option.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (option.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_46200 (h1 : uniform_space (complete_semilattice_Sup congr_arg_kind)) : complete_space (complete_semilattice_Sup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_46201 (h0 : not (group (linear_ordered_comm_ring congr_arg_kind) -> false)) : @is_cyclic.{0} (linear_ordered_comm_ring.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (group.{0} (linear_ordered_comm_ring.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_46202 (h0 : functor.add_const (prod pos pos) pos) : id_rel (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_46203 (h0 : topological_space (left_cancel_monoid num)) : locally_compact_space (left_cancel_monoid num) := sorry --non-trivial
lemma new_lemma_46204 (h2 : measurable_space (has_top linarith.comp_source)) (h3 : not (measure_theory.measure (has_top linarith.comp_source) -> false)) : measure_theory.is_probability_measure (classical.by_contradiction' h3) := sorry --non-trivial
lemma new_lemma_46205 (h0 : list (has_neg (has_add (finset pos)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_46206 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (complete_distrib_lattice.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_46207 (h0 : not (uniform_space (div_inv_monoid (has_nnnorm fun_info)) -> false)) : @complete_space.{0} (div_inv_monoid.{0} (has_nnnorm.{0} fun_info)) (@classical.by_contradiction'.{1} (uniform_space.{0} (div_inv_monoid.{0} (has_nnnorm.{0} fun_info))) h0)  := sorry --non-trivial
lemma new_lemma_46208 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (has_norm.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_norm.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_46209 (h0 : filter (finset (option empty))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_46210 (h0 : topological_space (has_top (random_gen (random_gen fun_info)))) : discrete_topology (has_top (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_46211 (h0 : topological_space (with_bot (random_gen linarith.ineq))) : t0_space (with_bot (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_46212 (h0 : topological_space (as_linear_order (semiring (option empty)))) : totally_disconnected_space (as_linear_order (semiring (option empty))) := sorry --non-trivial
lemma new_lemma_46213 (h0 : not (ring (has_compl linarith.comp_source) -> false)) : @strong_rank_condition.{0} (has_compl.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (has_compl.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_46214 (h0 : topological_space (has_to_string (option ennreal))) : discrete_topology (has_to_string (option ennreal)) := sorry --non-trivial
lemma new_lemma_46215 (h0 : functor.add_const (cancel_comm_monoid_with_zero (finset ennreal)) ennreal) : @unique_factorization_monoid.{0} (finset.{0} ennreal) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (finset.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_46216 (h1 : not (topological_space (complete_semilattice_Sup linarith.comp) -> false)) : @irreducible_space.{0} (complete_semilattice_Sup.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (complete_semilattice_Sup.{0} linarith.comp)) h1)  := sorry --non-trivial
lemma new_lemma_46217 (h1 : not (topological_space (denumerable char) -> false)) : @totally_disconnected_space.{0} (denumerable.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (denumerable.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_46218 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (random_gen.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 topological_space.{0}) (random_gen.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_46219 (h0 : function.extfun (finset Type) (has_mem.mem real.angle)) : @separated_space.{0} real.angle (@finset.pi.empty.{1 0} Type uniform_space.{0} real.angle (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) real.angle) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_46220 (h0 : group (has_pos_part (has_add linarith.comp))) : is_simple_group (has_pos_part (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_46221 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (has_norm.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_norm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_46222 (h0 : topological_space (random_gen (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm linarith.ineq)))))) : path_connected_space (random_gen (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm linarith.ineq))))) := sorry --non-trivial
lemma new_lemma_46223 (h0 : functor.add_const (filter (comm_group unsigned)) name) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_46224 (h0 : function.extfun Type group) : @normalizer_condition.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_46225 (h0 : monoid (complete_distrib_lattice (has_bot pos))) : monoid.fg (complete_distrib_lattice (has_bot pos)) := sorry --non-trivial
lemma new_lemma_46226 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @locally_compact_space.{0} (add_comm_monoid.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (add_comm_monoid.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_46227 (h0 : semiring (id (semiring (semiring unsigned)))) : is_noetherian_ring (id (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_46228 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_neg.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} name))  := sorry --non-trivial
lemma new_lemma_46229 (h0 : ring (ordered_ring unsigned)) : is_principal_ideal_ring (ordered_ring unsigned) := sorry --non-trivial
lemma new_lemma_46230 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (bin_tree empty)) := sorry --non-trivial
lemma new_lemma_46231 (h0 : topological_space (semiring (has_inv (random_gen linarith.comp_source)))) : irreducible_space (semiring (has_inv (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_46232 (h0 : functor.add_const (topological_space (left_cancel_monoid congr_arg_kind)) unsigned) : @totally_separated_space.{0} (left_cancel_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_46233 (h0 : function.extfun Type (functor.add_const (ring (has_bot empty)))) : @is_domain.{0} (has_bot.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (has_bot.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} (has_bot.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_46234 (h0 : complete_lattice (has_bot real)) : complete_lattice.is_Sup_finite_compact (has_bot real) := sorry --non-trivial
lemma new_lemma_46235 (h0 : topological_space (has_compl (mul_one_class (mul_one_class reducibility_hints)))) : path_connected_space (has_compl (mul_one_class (mul_one_class reducibility_hints))) := sorry --non-trivial
lemma new_lemma_46236 (h0 : topological_space (boolean_algebra.core name)) : discrete_topology (boolean_algebra.core name) := sorry --non-trivial
lemma new_lemma_46237 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (left_cancel_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_46238 (h0 : function.extfun Type group) : @is_simple_group.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_46239 (h0 : not (ring (distrib_lattice char) -> false)) : @rank_condition.{0} (distrib_lattice.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (distrib_lattice.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_46240 (h0 : functor.add_const (add_monoid (complete_distrib_lattice pos)) (ring environment.implicit_infer_kind)) : @add_monoid.fg.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (add_monoid.{0} (complete_distrib_lattice.{0} pos)) (ring.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_46241 (h0 : fin has_zero.zero) : @complete_lattice.is_Sup_finite_compact.{0} (canonically_ordered_monoid.{0} real) (@matrix.vec_empty.{0} (complete_lattice.{0} (canonically_ordered_monoid.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_46242 (h0 : not (group (topological_space fun_info) -> false)) : @is_cyclic.{0} (topological_space.{0} fun_info) (@classical.by_contradiction'.{1} (group.{0} (topological_space.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_46243 (h0 : group (add_cancel_monoid (semigroup Type))) : normalizer_condition (add_cancel_monoid (semigroup Type)) := sorry --non-trivial
lemma new_lemma_46244 (h2 : topological_space environment.projection_info) : totally_disconnected_space environment.projection_info := sorry --non-trivial
lemma new_lemma_46245 (h0 : filter (normed_comm_ring (mul_zero_class name))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_46246 (h0 : functor.add_const (topological_space (has_nndist linarith.comp)) Type) : @preconnected_space.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_nndist.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_46247 (h0 : list (complete_linear_order (semiring (semiring empty)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_46248 (h0 : add_monoid (normed_comm_ring (has_to_string (finset pos)))) : add_monoid.fg (normed_comm_ring (has_to_string (finset pos))) := sorry --non-trivial
lemma new_lemma_46249 (h0 : monoid (normed_group (has_norm congr_arg_kind))) : monoid.fg (normed_group (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_46250 (h0 : functor.add_const (ordered_comm_monoid (has_add (has_to_string linarith.comp))) pos) : @has_exists_mul_of_le.{0} (has_add.{0} (has_to_string.{0} linarith.comp)) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_add.{0} (has_to_string.{0} linarith.comp))) pos h0)  := sorry --non-trivial
lemma new_lemma_46251 (h0 : topological_space (has_zero (finset (finset (finset linarith.comp))))) : topological_space.separable_space (has_zero (finset (finset (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_46252 (h4 : complete_lattice (has_lt linarith.ineq)) : is_compactly_generated (has_lt linarith.ineq) := sorry --non-trivial
lemma new_lemma_46253 (h0 : fin has_zero.zero) : @is_noetherian_ring.{1} (ordered_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (semiring.{1} (ordered_comm_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_46254 (h0 : not (function.extfun Type multiset -> false)) : multiset.nodup (function.extfun_app (classical.by_contradiction' h0) (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_46255 (h0 : functor.add_const (topological_space (has_bot pos)) Type) : @normal_space.{0} (has_bot.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_bot.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_46256 (h0 : functor.add_const (group (left_cancel_monoid empty)) num) : @is_cyclic.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (left_cancel_monoid.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_46257 (h1 : ring (topological_space (has_ssubset char))) : is_domain (topological_space (has_ssubset char)) := sorry --non-trivial
lemma new_lemma_46258 (h0 : ring (has_to_string std_gen)) : strong_rank_condition (has_to_string std_gen) := sorry --non-trivial
lemma new_lemma_46259 (h0 : not (ring (non_assoc_semiring empty) -> false)) : @is_principal_ideal_ring.{0} (non_assoc_semiring.{0} empty) (@classical.by_contradiction'.{1} (ring.{0} (non_assoc_semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_46260 (h0 : not (function.extfun Type semiring -> false)) : @is_noetherian_ring.{0} (add_group.{0} empty) (@function.extfun_app.{2 1} Type semiring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type semiring.{0}) h0) (add_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_46261 (h0 : functor.add_const (monoid (cancel_monoid Type)) environment.implicit_infer_kind) : @monoid.fg.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (monoid.{1} (cancel_monoid.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_46262 (h0 : uniform_space (linear_ordered_cancel_comm_monoid congr_arg_kind)) : complete_space (linear_ordered_cancel_comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_46263 (h0 : topological_space (has_to_string (ordered_comm_monoid real))) : t1_space (has_to_string (ordered_comm_monoid real)) := sorry --non-trivial
lemma new_lemma_46264 (h0 : topological_space (distrib_lattice (has_nnnorm (has_nnnorm linarith.ineq)))) : totally_disconnected_space (distrib_lattice (has_nnnorm (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_46265 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_46266 (h0 : topological_space (has_dist (option (option (option (option unsigned)))))) : t1_space (has_dist (option (option (option (option unsigned))))) := sorry --non-trivial
lemma new_lemma_46267 (h0 : not (ring (has_compl (mul_one_class char)) -> false)) : @is_domain.{0} (has_compl.{0} (mul_one_class.{0} char)) (@classical.by_contradiction'.{1} (ring.{0} (has_compl.{0} (mul_one_class.{0} char))) h0)  := sorry --non-trivial
lemma new_lemma_46268 (h0 : nat) (h1 : fin (nat.succ (id h0)) -> Prop) (h2 : fin (id h0)) : matrix.vec_tail h1 h2 := sorry --non-trivial
lemma new_lemma_46269 (h0 : filter (linear_ordered_field unsigned)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_46270 (h0 : monoid (as_linear_order empty)) : monoid.fg (as_linear_order empty) := sorry --non-trivial
lemma new_lemma_46271 (h0 : topological_space (pseudo_metric_space num)) : topological_space.separable_space (pseudo_metric_space num) := sorry --non-trivial
lemma new_lemma_46272 (h0 : functor.add_const (ring (semigroup ennreal)) name) : @rank_condition.{0} (semigroup.{0} ennreal) (@functor.add_const.run.{0 0} (ring.{0} (semigroup.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_46273 (h1 : ring (normed_field (has_append reducibility_hints))) : rank_condition (normed_field (has_append reducibility_hints)) := sorry --non-trivial
lemma new_lemma_46274 (h0 : functor.add_const (complete_lattice (pseudo_metric_space empty)) (option unsigned)) : @is_atomistic.{0} (pseudo_metric_space.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (pseudo_metric_space.{0} empty)) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_46275 (h0 : functor.add_const (filter (linear_ordered_field pos)) pos) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_46276 (h0 : group (has_Inf (has_Inf pos))) : group.fg (has_Inf (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_46277 (h0 : has_mem.mem (with_bot linarith.comp_source) has_emptyc.emptyc) : @complete_space.{0} (with_bot.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type uniform_space.{0} (with_bot.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_46278 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (with_bot.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (with_bot.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_46279 (h0 : not (topological_space (with_bot linarith.comp_source) -> false)) : @irreducible_space.{0} (with_bot.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (with_bot.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_46280 (h0 : has_zero (pseudo_metric_space congr_arg_kind) -> has_zero (pseudo_metric_space congr_arg_kind) -> Prop) : is_symm (has_zero (pseudo_metric_space congr_arg_kind)) h0 := sorry --non-trivial
lemma new_lemma_46281 (h0 : complete_lattice (has_nnnorm (has_lt (has_lt linarith.comp_source)))) : complete_lattice.is_Sup_finite_compact (has_nnnorm (has_lt (has_lt linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_46282 (h0 : complete_lattice (canonically_ordered_comm_semiring (has_add Type))) : is_atomistic (canonically_ordered_comm_semiring (has_add Type)) := sorry --non-trivial
lemma new_lemma_46283 (h0 : topological_space (semiring (random_gen linarith.ineq))) : irreducible_space (semiring (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_46284 (h0 : functor.add_const (monoid (semigroup Type)) name) : @monoid.fg.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (monoid.{1} (semigroup.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_46285 (h0 : group (ordered_comm_monoid (has_nnnorm linarith.comp_source))) : is_cyclic (ordered_comm_monoid (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_46286 (h0 : functor.add_const (topological_space (has_Inf pos)) pos) : @t0_space.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_46287 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (random_gen.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (random_gen.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_46288 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_inter.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_inter.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_46289 (h0 : functor.add_const (topological_space (has_to_string environment.implicit_infer_kind)) pos) : @sequential_space.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_46290 (h0 : topological_space (non_assoc_semiring (semiring num))) : path_connected_space (non_assoc_semiring (semiring num)) := sorry --non-trivial
lemma new_lemma_46291 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (canonically_ordered_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (monoid.{0} (canonically_ordered_add_monoid.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (monoid.{0} (canonically_ordered_add_monoid.{0} empty))) (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 (functor.add_const.{0 0} (monoid.{0} (canonically_ordered_add_monoid.{0} empty)))) empty))  := sorry --non-trivial
lemma new_lemma_46292 (h0 : add_monoid (comm_group (has_neg_part ennreal))) : add_monoid.fg (comm_group (has_neg_part ennreal)) := sorry --non-trivial
lemma new_lemma_46293 (h0 : ring (boolean_algebra (semigroup unsigned))) : rank_condition (boolean_algebra (semigroup unsigned)) := sorry --non-trivial
lemma new_lemma_46294 (h0 : function.extfun Type (functor.comp ring add_comm_monoid)) : @strong_rank_condition.{0} (add_comm_monoid.{0} pos) (@functor.comp.run.{0 0 0} ring.{0} add_comm_monoid.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} ring.{0} add_comm_monoid.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_46295 (h1 : group (has_emptyc (random_gen to_additive.value_type))) : group.fg (has_emptyc (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_46296 (h0 : complete_lattice (sub_neg_monoid real)) : is_atomistic (sub_neg_monoid real) := sorry --non-trivial
lemma new_lemma_46297 (h0 : group (normed_comm_ring Type)) : is_simple_group (normed_comm_ring Type) := sorry --non-trivial
lemma new_lemma_46298 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} znum (@function.extfun_app.{2 1} Type topological_space.{0} h0 znum)  := sorry --non-trivial
lemma new_lemma_46299 (h0 : add_monoid (has_one (has_top (has_top num)))) : add_monoid.fg (has_one (has_top (has_top num))) := sorry --non-trivial
lemma new_lemma_46300 (h0 : ring (linear_order unsigned)) : is_domain (linear_order unsigned) := sorry --non-trivial
lemma new_lemma_46301 (h0 : group (boolean_algebra (has_neg Type))) : is_simple_group (boolean_algebra (has_neg Type)) := sorry --non-trivial
lemma new_lemma_46302 (h0 : topological_space (canonically_ordered_comm_semiring (cancel_monoid pos))) : path_connected_space (canonically_ordered_comm_semiring (cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_46303 (h0 : uniform_space (add_cancel_monoid (has_nndist ennreal))) : separated_space (add_cancel_monoid (has_nndist ennreal)) := sorry --non-trivial
lemma new_lemma_46304 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (measurable_space.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (measurable_space.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_46305 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (has_union linarith.comp)) := sorry --non-trivial
lemma new_lemma_46306 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (has_neg_part.{0} pos) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (has_neg_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_46307 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (partial_order.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (partial_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_46308 (h0 : functor.add_const (complete_lattice (canonically_ordered_add_monoid unsigned)) congr_arg_kind) : @is_compactly_generated.{0} (canonically_ordered_add_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (canonically_ordered_add_monoid.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_46309 (h0 : group (measurable_space (has_ssubset (has_ssubset (has_ssubset linarith.ineq))))) : group.fg (measurable_space (has_ssubset (has_ssubset (has_ssubset linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_46310 (h0 : fin has_zero.zero) : @irreducible_space.{1} (has_bot.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (has_bot.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_46311 (h0 : group (linear_order empty)) : is_simple_group (linear_order empty) := sorry --non-trivial
lemma new_lemma_46312 (h0 : finset (has_neg (finset environment.implicit_infer_kind))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_46313 (h0 : comm_semiring (has_ssubset string_imp)) (h1 : not (polynomial (has_ssubset string_imp) -> false)) : polynomial.is_primitive (classical.by_contradiction' h1) := sorry --non-trivial
lemma new_lemma_46314 (h1 : ring (ordered_comm_semiring char)) : is_domain (ordered_comm_semiring char) := sorry --non-trivial
lemma new_lemma_46315 (h0 : functor.add_const (ordered_add_comm_monoid (has_to_string unsigned)) num) : @archimedean.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_to_string.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_46316 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (has_bot.{0} name) (@function.extfun_app.{2 1} Type monoid.{0} h0 (has_bot.{0} name))  := sorry --non-trivial
lemma new_lemma_46317 (h0 : add_monoid (has_add ennreal)) : add_monoid.fg (has_add ennreal) := sorry --non-trivial
lemma new_lemma_46318 (h0 : complete_lattice (add_cancel_monoid (option (option (option empty))))) : complete_lattice.is_Sup_finite_compact (add_cancel_monoid (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_46319 (h0 : topological_space (complete_distrib_lattice (option (option (option (option (option unsigned))))))) : t0_space (complete_distrib_lattice (option (option (option (option (option unsigned)))))) := sorry --non-trivial
lemma new_lemma_46320 (h0 : topological_space (has_neg (has_neg Type))) : totally_disconnected_space (has_neg (has_neg Type)) := sorry --non-trivial
lemma new_lemma_46321 (h0 : function.extfun (Type 1) (functor.comp topological_space has_zero)) : @loc_path_connected_space.{1} (has_zero.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} has_zero.{1} Type (@function.extfun_app.{3 2} (Type 1) (functor.comp.{1 1 1} topological_space.{1} has_zero.{1}) h0 Type))  := sorry --non-trivial
lemma new_lemma_46322 (h0 : functor.add_const (add_group (generalized_boolean_algebra linarith.comp)) pos) : @is_add_cyclic.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_group.{0} (generalized_boolean_algebra.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_46323 (h0 : group (denumerable (random_gen (random_gen char)))) : is_cyclic (denumerable (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_46324 (h0 : semiring (has_add (boolean_algebra (finset (has_neg (finset pos)))))) : is_noetherian_ring (has_add (boolean_algebra (finset (has_neg (finset pos))))) := sorry --non-trivial
lemma new_lemma_46325 (h0 : functor.add_const (topological_space (cancel_monoid linarith.comp)) Type) : @path_connected_space.{0} (cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (cancel_monoid.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_46326 (h0 : topological_space (id (semiring congr_arg_kind))) : t0_space (id (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_46327 (h0 : list (ring num)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_46328 (h0 : functor.add_const (function.extfun (Type 1) uniform_space) pos) : @separated_space.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) uniform_space.{1}) pos h0) (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_46329 (h0 : filter (linear_ordered_add_comm_group (random_gen reducibility_hints))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_46330 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (semiring.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_46331 (h0 : complete_lattice (finset (has_neg_part (boolean_algebra.core pos)))) : complete_lattice.is_Sup_finite_compact (finset (has_neg_part (boolean_algebra.core pos))) := sorry --non-trivial
lemma new_lemma_46332 (h0 : topological_space (measurable_space (with_bot (with_bot to_additive.value_type)))) : totally_separated_space (measurable_space (with_bot (with_bot to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_46333 (h1 : topological_space to_additive.value_type) : path_connected_space to_additive.value_type := sorry --non-trivial
lemma new_lemma_46334 (h0 : topological_space (sub_neg_monoid (has_neg linarith.comp))) : regular_space (sub_neg_monoid (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_46335 (h0 : function.extfun Type ring) : @is_domain.{0} (option.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (option.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_46336 (h0 : topological_space (option (option empty))) : loc_path_connected_space (option (option empty)) := sorry --non-trivial
lemma new_lemma_46337 (h0 : fin has_zero.zero) : @path_connected_space.{0} (complete_distrib_lattice.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (complete_distrib_lattice.{0} pos)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_46338 (h0 : topological_space (has_one linarith.comp)) : path_connected_space (has_one linarith.comp) := sorry --non-trivial
lemma new_lemma_46339 (h0 : functor.add_const (ring (pseudo_metric_space num)) linarith.comp) : @rank_condition.{0} (pseudo_metric_space.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (pseudo_metric_space.{0} num)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_46340 (h0 : functor.comp topological_space ring linarith.comp) : @sequential_space.{0} (ring.{0} linarith.comp) (@functor.comp.run.{0 0 0} topological_space.{0} ring.{0} linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_46341 (h0 : fin has_zero.zero) : @is_domain.{0} (canonically_ordered_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (ring.{0} (canonically_ordered_monoid.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_46342 (h0 : function.extfun Type (functor.comp topological_space has_to_string)) : @locally_compact_space.{0} (has_to_string.{0} unsigned) (@functor.comp.run.{0 0 0} topological_space.{0} has_to_string.{0} unsigned (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} has_to_string.{0}) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_46343 (h0 : functor.add_const (topological_space (mul_zero_class empty)) empty) : @locally_compact_space.{0} (mul_zero_class.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_46344 (h0 : functor.add_const (function.extfun Type add_monoid) pos) : @add_monoid.fg.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type add_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_monoid.{0}) pos h0) (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_46345 (h0 : functor.add_const (uniform_space (has_zero pos)) linarith.comp) : @separated_space.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_zero.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_46346 (h0 : functor.add_const (group (has_zero linarith.comp)) Type) : @is_cyclic.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 1} (group.{0} (has_zero.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_46347 (h0 : group (non_assoc_semiring (semiring (semiring (semiring (semiring (semiring empty))))))) : is_cyclic (non_assoc_semiring (semiring (semiring (semiring (semiring (semiring empty)))))) := sorry --non-trivial
lemma new_lemma_46348 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (has_to_string.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_to_string.{0} num))  := sorry --non-trivial
lemma new_lemma_46349 (h0 : topological_space (has_to_string (has_edist (has_to_string pos)))) : topological_space.separable_space (has_to_string (has_edist (has_to_string pos))) := sorry --non-trivial
lemma new_lemma_46350 (h0 : finset (boolean_algebra Type)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_46351 (h0 : ring (has_nnnorm (random_gen (random_gen string_imp)))) : rank_condition (has_nnnorm (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_46352 (h0 : finset (has_neg environment.implicit_infer_kind)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_46353 (h0 : topological_space (has_inter (option empty))) : t0_space (has_inter (option empty)) := sorry --non-trivial
lemma new_lemma_46354 (h0 : nat) (h1 : option nat) : nat.min_sq_fac_prop h0 h1 := sorry --non-trivial
lemma new_lemma_46355 (h0 : has_mem.mem monoid has_emptyc.emptyc) : @monoid.fg.{0} (measurable_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type monoid.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) monoid.{0} h0) (measurable_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_46356 (h0 : add_group (has_emptyc (has_inv linarith.comp_source))) : is_add_cyclic (has_emptyc (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_46357 (h0 : topological_space (has_zero (add_comm_monoid Type))) : preirreducible_space (has_zero (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_46358 (h0 : fin has_zero.zero) : @monotonic_sequence_limit.{0} Prop (@complete_semilattice_Inf.to_partial_order.{0} Prop (@complete_lattice.to_complete_semilattice_Inf.{0} Prop Prop.complete_lattice)) (@matrix.vec_empty.{0} (@order_hom.{0 0} nat Prop (@partial_order.to_preorder.{0} nat (@ordered_cancel_add_comm_monoid.to_partial_order.{0} nat (@ordered_semiring.to_ordered_cancel_add_comm_monoid.{0} nat nat.ordered_semiring))) (@partial_order.to_preorder.{0} Prop (@complete_semilattice_Inf.to_partial_order.{0} Prop (@complete_lattice.to_complete_semilattice_Inf.{0} Prop Prop.complete_lattice)))) h0)  := sorry --non-trivial
lemma new_lemma_46359 (h0 : functor.add_const (add_monoid (has_nndist name)) Type) : @add_monoid.fg.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 1} (add_monoid.{0} (has_nndist.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_46360 (h0 : function.extfun (Type 1) topological_space) : @sequential_space.{1} (comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_46361 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (with_bot.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (with_bot.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_46362 (h2 : measurable_space (nondiscrete_normed_field reducibility_hints)) (h3 : measure_theory.measure (nondiscrete_normed_field reducibility_hints)) : measure_theory.is_finite_measure h3 := sorry --non-trivial
lemma new_lemma_46363 (h0 : functor.add_const (filter (normed_comm_ring Type)) Type) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_46364 (h0 : add_group (semi_normed_comm_ring (mul_one_class char))) : is_add_cyclic (semi_normed_comm_ring (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_46365 (h0 : uniform_space (add_left_cancel_monoid char)) : complete_space (add_left_cancel_monoid char) := sorry --non-trivial
lemma new_lemma_46366 (h0 : add_monoid (monoid empty)) : add_monoid.fg (monoid empty) := sorry --non-trivial
lemma new_lemma_46367 (h0 : function.extfun (finset Type) (has_mem.mem (measurable_space congr_arg_kind))) : @path_connected_space.{0} (measurable_space.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (measurable_space.{0} congr_arg_kind) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (measurable_space.{0} congr_arg_kind)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_46368 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} linarith.ineq (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 linarith.ineq)  := sorry --non-trivial
lemma new_lemma_46369 (h0 : not (topological_space (id congr_arg_kind) -> false)) : @irreducible_space.{0} (@id.{2} Type congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (@id.{2} Type congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_46370 (h0 : function.extfun Type (prod (canonically_ordered_comm_semiring unsigned))) : id_rel (function.extfun_app h0 (canonically_ordered_comm_semiring unsigned)) := sorry --non-trivial
lemma new_lemma_46371 (h0 : not (semiring (has_sub unsigned) -> false)) : @is_noetherian_ring.{0} (has_sub.{0} unsigned) (@classical.by_contradiction'.{1} (semiring.{0} (has_sub.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_46372 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (linear_ordered_field.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (linear_ordered_field.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_46373 (h0 : function.extfun Type (functor.comp topological_space boolean_algebra.core)) : @preirreducible_space.{0} (boolean_algebra.core.{0} (has_nndist.{0} environment.implicit_infer_kind)) (@functor.comp.run.{0 0 0} topological_space.{0} boolean_algebra.core.{0} (has_nndist.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} boolean_algebra.core.{0}) h0 (has_nndist.{0} environment.implicit_infer_kind)))  := sorry --non-trivial
lemma new_lemma_46374 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (has_bot linarith.comp)) := sorry --non-trivial
lemma new_lemma_46375 (h0 : uniform_space (generalized_boolean_algebra pos)) : complete_space (generalized_boolean_algebra pos) := sorry --non-trivial
lemma new_lemma_46376 (h0 : functor.add_const (topological_space (has_Inf Type)) linarith.comp) : @normal_space.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_Inf.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_46377 (h0 : topological_space (complete_distrib_lattice (has_neg Type))) : t0_space (complete_distrib_lattice (has_neg Type)) := sorry --non-trivial
lemma new_lemma_46378 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (canonically_linear_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_linear_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_46379 (h0 : ring (has_bot (has_neg pos))) : rank_condition (has_bot (has_neg pos)) := sorry --non-trivial
lemma new_lemma_46380 (h0 : list (ring linarith.comp)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_46381 (h0 : add_monoid (add_right_cancel_monoid (has_top unsigned))) : add_monoid.fg (add_right_cancel_monoid (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_46382 (h0 : fin has_zero.zero) : @totally_disconnected_space.{0} (complete_distrib_lattice.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (complete_distrib_lattice.{0} real)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)))  := sorry --non-trivial
lemma new_lemma_46383 (h0 : topological_space std_gen) (h1 : set std_gen) : is_path_connected h1 := sorry --non-trivial
lemma new_lemma_46384 (h0 : not (filter (option empty) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_46385 (h0 : finset (has_zero (boolean_algebra linarith.comp))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_46386 (h0 : functor.add_const (topological_space (add_cancel_monoid pos)) (option unsigned)) : @t1_space.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} pos)) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_46387 (h0 : function.extfun Type topological_space) : @t1_space.{0} (ordered_comm_group.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_group.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_46388 (h0 : list (ordered_cancel_add_comm_monoid (has_dist (linear_ordered_field (has_dist (comm_monoid unsigned)))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_46389 (h0 : functor.add_const (topological_space (ordered_comm_monoid Type)) pos) : @loc_path_connected_space.{1} (ordered_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ordered_comm_monoid.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_46390 (h0 : uniform_space (has_neg_part (option (option pos)))) : complete_space (has_neg_part (option (option pos))) := sorry --non-trivial
lemma new_lemma_46391 (h0 : functor.add_const (filter (finset linarith.comp)) (has_pos_part (has_Inf pos))) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_46392 (h0 : functor.add_const (function.extfun Type topological_space) real) : @t1_space.{0} (add_comm_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) real h0) (add_comm_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_46393 (h0 : functor.add_const (functor.add_const Prop Type) (boolean_algebra unsigned)) : functor.add_const.run (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_46394 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (ordered_comm_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (ordered_comm_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_46395 (h0 : topological_space (ordered_ring empty)) : t0_space (ordered_ring empty) := sorry --non-trivial
lemma new_lemma_46396 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (semiring.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semiring.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_46397 (h0 : topological_space (has_zero (finset Type))) : t1_space (has_zero (finset Type)) := sorry --non-trivial
lemma new_lemma_46398 (h0 : not (group (linear_ordered_add_comm_group to_additive.value_type) -> false)) : @is_cyclic.{0} (linear_ordered_add_comm_group.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (group.{0} (linear_ordered_add_comm_group.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_46399 (h0 : functor.add_const (topological_space (sub_neg_monoid linarith.comp)) (has_neg linarith.comp)) : @regular_space.{0} (sub_neg_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (sub_neg_monoid.{0} linarith.comp)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_46400 (h0 : functor.add_const (functor.add_const (add_group Type) pos) Type) : @is_add_cyclic.{1} Type (@functor.add_const.run.{1 0} (add_group.{1} Type) pos (@functor.add_const.run.{1 1} (functor.add_const.{1 0} (add_group.{1} Type) pos) Type h0))  := sorry --non-trivial
lemma new_lemma_46401 (h0 : ring (normed_comm_ring (mul_one_class (has_add (mul_one_class pos))))) : is_domain (normed_comm_ring (mul_one_class (has_add (mul_one_class pos)))) := sorry --non-trivial
lemma new_lemma_46402 (h0 : topological_space (semi_normed_ring string.iterator_imp)) : totally_disconnected_space (semi_normed_ring string.iterator_imp) := sorry --non-trivial
lemma new_lemma_46403 (h0 : add_group (has_div linarith.comp_source)) : is_add_cyclic (has_div linarith.comp_source) := sorry --non-trivial
lemma new_lemma_46404 (h0 : functor.add_const (function.extfun Type ring) name) : @is_domain.{0} (semigroup.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) name h0) (semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_46405 (h0 : uniform_space (has_neg_part unsigned)) : complete_space (has_neg_part unsigned) := sorry --non-trivial
lemma new_lemma_46406 (h0 : ring (pseudo_metric_space unsigned)) : rank_condition (pseudo_metric_space unsigned) := sorry --non-trivial
lemma new_lemma_46407 (h0 : finset (comm_group (has_nndist (finset Type)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_46408 (h0 : filter (complete_semilattice_Sup linarith.comp)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_46409 (h0 : complete_lattice (has_nndist congr_arg_kind)) : is_atomistic (has_nndist congr_arg_kind) := sorry --non-trivial
lemma new_lemma_46410 (h0 : functor.add_const (topological_space (has_zero linarith.comp)) Type) : @preconnected_space.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_zero.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_46411 (h0 : functor.add_const (topological_space (ordered_comm_semiring congr_arg_kind)) num) : @loc_path_connected_space.{0} (ordered_comm_semiring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_semiring.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_46412 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (normed_group.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (normed_group.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_46413 (h0 : ring (linear_ordered_semiring (has_top fun_info))) : rank_condition (linear_ordered_semiring (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_46414 (h0 : ring (has_star (semiring (semiring congr_arg_kind)))) : is_principal_ideal_ring (has_star (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_46415 (h0 : semiring (linear_ordered_add_comm_group_with_top unsigned)) : is_noetherian_ring (linear_ordered_add_comm_group_with_top unsigned) := sorry --non-trivial
lemma new_lemma_46416 (h0 : group (finset (mul_zero_class pos))) : is_simple_group (finset (mul_zero_class pos)) := sorry --non-trivial
lemma new_lemma_46417 (h0 : ring (boolean_algebra.core (comm_group (has_neg_part Type)))) : strong_rank_condition (boolean_algebra.core (comm_group (has_neg_part Type))) := sorry --non-trivial
lemma new_lemma_46418 (h0 : ordered_add_comm_monoid (has_add (has_add (has_Inf Type)))) : archimedean (has_add (has_add (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_46419 (h0 : filter (has_add (mul_one_class (mul_one_class (ordered_comm_group linarith.comp))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_46420 (h0 : not (function.extfun Type topological_space -> false)) : @discrete_topology.{0} (linear_ordered_semiring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (linear_ordered_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_46421 (h0 : uniform_space (canonically_linear_ordered_monoid (has_add pos))) : separated_space (canonically_linear_ordered_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_46422 (h0 : functor.add_const (uniform_space (has_to_string Type)) (has_neg_part pos)) : @complete_space.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (has_to_string.{1} Type)) (has_neg_part.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_46423 (h0 : topological_space (has_nnnorm (random_gen linarith.ineq))) : locally_compact_space (has_nnnorm (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_46424 (h0 : functor.add_const (function.extfun (Type 1) topological_space) linarith.comp) : @totally_disconnected_space.{1} (has_zero.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) linarith.comp h0) (has_zero.{1} Type))  := sorry --non-trivial
lemma new_lemma_46425 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (normed_group.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (normed_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_46426 (h0 : function.extfun Type group) : @normalizer_condition.{0} (linear_ordered_semiring.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (linear_ordered_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_46427 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (has_edist.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_edist.{0} num))  := sorry --non-trivial
lemma new_lemma_46428 (h0 : function.extfun (Type 1) topological_space) : @totally_disconnected_space.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_46429 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (sub_neg_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (sub_neg_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_46430 (h1 : topological_space (has_nnnorm (add_cancel_comm_monoid string_imp))) : path_connected_space (has_nnnorm (add_cancel_comm_monoid string_imp)) := sorry --non-trivial
lemma new_lemma_46431 (h0 : ordered_comm_monoid (has_add (has_add pos))) : has_exists_mul_of_le (has_add (has_add pos)) := sorry --non-trivial
lemma new_lemma_46432 (h0 : not (topological_space (has_add linarith.comp_source) -> false)) : @totally_disconnected_space.{0} (has_add.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (has_add.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_46433 (h0 : not (topological_space (random_gen (semiring linarith.comp)) -> false)) : @irreducible_space.{0} (random_gen.{0} (semiring.{0} linarith.comp)) (@classical.by_contradiction'.{1} (topological_space.{0} (random_gen.{0} (semiring.{0} linarith.comp))) h0)  := sorry --non-trivial
lemma new_lemma_46434 (h0 : topological_space (has_compl (semi_normed_ring linarith.ineq))) : totally_disconnected_space (has_compl (semi_normed_ring linarith.ineq)) := sorry --non-trivial
lemma new_lemma_46435 (h0 : fin has_zero.zero) : @add_monoid.fg.{0} (sub_neg_monoid.{0} pos) (@matrix.vec_empty.{0} (add_monoid.{0} (sub_neg_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_46436 (h0 : monoid (linear_ordered_add_comm_group (has_top linarith.ineq))) : monoid.fg (linear_ordered_add_comm_group (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_46437 (h0 : topological_space (plift (option unsigned))) : topological_space.separable_space (plift (option unsigned)) := sorry --non-trivial
lemma new_lemma_46438 (h0 : topological_space (finset (has_add name))) : normal_space (finset (has_add name)) := sorry --non-trivial
lemma new_lemma_46439 (h0 : group (has_neg_part (semigroup ennreal))) : is_cyclic (has_neg_part (semigroup ennreal)) := sorry --non-trivial
lemma new_lemma_46440 (h1 : topological_space char) (h2 : set char) : is_path_connected h2 := sorry --non-trivial
lemma new_lemma_46441 (h3 : option (complete_lattice (add_comm_semigroup std_gen))) (h4 : coe_sort (option.is_some h3)) : @complete_lattice.is_Sup_finite_compact.{0} (add_comm_semigroup.{0} std_gen) (@option.get.{0} (complete_lattice.{0} (add_comm_semigroup.{0} std_gen)) h3 h4)  := sorry --non-trivial
lemma new_lemma_46442 (h0 : functor.add_const (topological_space (generalized_boolean_algebra pos)) (has_bot Type)) : @totally_disconnected_space.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (generalized_boolean_algebra.{0} pos)) (has_bot.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_46443 (h0 : functor.add_const (topological_space (finset Type)) Type) : @totally_disconnected_space.{1} (finset.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (finset.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_46444 (h0 : function.extfun Type topological_space) : @regular_space.{0} (canonically_linear_ordered_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_linear_ordered_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_46445 (h0 : complete_lattice (has_zero (cancel_monoid (has_well_founded (mul_zero_class unsigned))))) : is_atomistic (has_zero (cancel_monoid (has_well_founded (mul_zero_class unsigned)))) := sorry --non-trivial
lemma new_lemma_46446 (h0 : functor.add_const (ring (has_bot empty)) empty) : @strong_rank_condition.{0} (has_bot.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (has_bot.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_46447 (h0 : functor.add_const (topological_space (boolean_algebra pos)) pos) : @preconnected_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_46448 (h0 : topological_space (has_neg_part pos)) : preconnected_space (has_neg_part pos) := sorry --non-trivial
lemma new_lemma_46449 (h0 : functor.add_const (group (add_comm_monoid pos)) Type) : @normalizer_condition.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (add_comm_monoid.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_46450 (h0 : topological_space (boolean_algebra.core linarith.comp)) : t0_space (boolean_algebra.core linarith.comp) := sorry --non-trivial
lemma new_lemma_46451 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (add_comm_monoid.{0} (normed_comm_ring.{0} name)) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (add_comm_monoid.{0} (normed_comm_ring.{0} name)))  := sorry --non-trivial
lemma new_lemma_46452 (h0 : functor.add_const (topological_space (has_Inf name)) name) : @discrete_topology.{0} (has_Inf.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_46453 (h0 : complete_lattice (random_gen (has_inv (has_top linarith.comp_source)))) : is_atomistic (random_gen (has_inv (has_top linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_46454 (h0 : complete_lattice (ordered_comm_monoid (has_Inf (has_Inf linarith.comp)))) : complete_lattice.is_Sup_finite_compact (ordered_comm_monoid (has_Inf (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_46455 (h0 : topological_space (linear_ordered_add_comm_group (random_gen (random_gen (random_gen fun_info))))) : irreducible_space (linear_ordered_add_comm_group (random_gen (random_gen (random_gen fun_info)))) := sorry --non-trivial
lemma new_lemma_46456 (h0 : functor.add_const (ring (ordered_comm_monoid Type)) name) : @rank_condition.{1} (ordered_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (ordered_comm_monoid.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_46457 (h0 : list (has_to_string (has_add (has_neg pos)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_46458 (h0 : group (has_add (option unsigned))) : is_cyclic (has_add (option unsigned)) := sorry --non-trivial
lemma new_lemma_46459 (h0 : complete_lattice (complete_semilattice_Sup (has_top (semiring empty)))) : is_atomistic (complete_semilattice_Sup (has_top (semiring empty))) := sorry --non-trivial
lemma new_lemma_46460 (h0 : complete_lattice (normed_group (has_norm fun_info))) : is_atomistic (normed_group (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_46461 (h0 : preorder (mul_one_class fun_info)) (h2 : Prop) : set.is_pwo (id (fun (h1 : mul_one_class fun_info), h2)) := sorry --non-trivial
lemma new_lemma_46462 (h0 : ring (canonically_ordered_monoid (ordered_comm_monoid (has_Inf pos)))) : is_domain (canonically_ordered_monoid (ordered_comm_monoid (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_46463 (h0 : functor.add_const (function.extfun Type monoid) Type) : @monoid.fg.{0} (has_to_string.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type monoid.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type monoid.{0}) Type h0) (has_to_string.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_46464 (h0 : list (canonically_ordered_comm_semiring (complete_lattice Type))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_46465 (h0 : not (topological_space (measurable_space Type) -> false)) : @t0_space.{1} (measurable_space.{1} Type) (@classical.by_contradiction'.{2} (topological_space.{1} (measurable_space.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_46466 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (ordered_comm_ring.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} h0 (ordered_comm_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_46467 (h0 : ring (distrib_lattice (id to_additive.value_type))) : is_domain (distrib_lattice (id to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_46468 (h0 : ring (linear_ordered_add_comm_group (linear_ordered_add_comm_group linarith.comp_source))) : is_domain (linear_ordered_add_comm_group (linear_ordered_add_comm_group linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_46469 (h0 : add_monoid (linear_ordered_comm_group num)) : add_monoid.fg (linear_ordered_comm_group num) := sorry --non-trivial
lemma new_lemma_46470 (h0 : filter (has_neg (option ennreal))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_46471 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (@id.{2} Type num) (@function.extfun_app.{2 1} Type monoid.{0} h0 (@id.{2} Type num))  := sorry --non-trivial
lemma new_lemma_46472 (h0 : topological_space (normed_comm_ring (boolean_algebra.core name))) : irreducible_space (normed_comm_ring (boolean_algebra.core name)) := sorry --non-trivial
lemma new_lemma_46473 (h0 : not (has_mem.mem (semiring linarith.comp_source) has_emptyc.emptyc -> false)) : @complete_space.{0} (semiring.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type uniform_space.{0} (semiring.{0} linarith.comp_source) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} linarith.comp_source) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_46474 (h0 : complete_lattice (linear_ordered_comm_ring (ordered_cancel_comm_monoid empty))) : is_atomistic (linear_ordered_comm_ring (ordered_cancel_comm_monoid empty)) := sorry --non-trivial
lemma new_lemma_46475 (h0 : topological_space (monoid (semiring (semiring (semiring congr_arg_kind))))) : totally_disconnected_space (monoid (semiring (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_46476 (h0 : topological_space (has_union (semiring (semiring (semiring (semiring empty)))))) : t0_space (has_union (semiring (semiring (semiring (semiring empty))))) := sorry --non-trivial
lemma new_lemma_46477 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (has_Inf.{0} name) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (has_Inf.{0} name))  := sorry --non-trivial
lemma new_lemma_46478 (h0 : function.extfun (Type 1) topological_space) : @locally_compact_space.{1} (has_pos_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_pos_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_46479 (h0 : filter (canonically_ordered_comm_semiring empty)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_46480 (h0 : ring (normed_comm_ring (has_nndist (finset (finset pos))))) : rank_condition (normed_comm_ring (has_nndist (finset (finset pos)))) := sorry --non-trivial
lemma new_lemma_46481 (h0 : functor.add_const Prop (has_neg (has_add ennreal))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_46482 (h0 : function.extfun nat fin) : @monoid.fg.{0} (ordered_comm_ring.{0} pos) (@matrix.vec_empty.{0} (monoid.{0} (ordered_comm_ring.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_46483 (h3 : set (linarith.ineq -> fun_info)) : set.separates_points h3 := sorry --non-trivial
lemma new_lemma_46484 (h0 : topological_space (canonically_linear_ordered_monoid linarith.comp)) : locally_compact_space (canonically_linear_ordered_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_46485 (h0 : linear_ordered_field (option ennreal) -> linear_ordered_field (option ennreal) -> Prop) : is_symm (linear_ordered_field (option ennreal)) h0 := sorry --non-trivial
lemma new_lemma_46486 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (has_star unsigned)) := sorry --non-trivial
lemma new_lemma_46487 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_46488 (h0 : functor.add_const (list (ring name)) (has_neg Type)) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_46489 (h0 : add_group (uniform_space (mul_one_class to_additive.value_type))) : is_add_cyclic (uniform_space (mul_one_class to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_46490 (h0 : ring (has_add (has_neg_part (semigroup name)))) : is_principal_ideal_ring (has_add (has_neg_part (semigroup name))) := sorry --non-trivial
lemma new_lemma_46491 (h0 : topological_space (has_nndist name)) : irreducible_space (has_nndist name) := sorry --non-trivial
lemma new_lemma_46492 (h3 : set (has_append to_additive.value_type)) : set.subsingleton h3 := sorry --non-trivial
lemma new_lemma_46493 (h0 : not (ring (linear_ordered_add_comm_group fun_info) -> false)) : @strong_rank_condition.{0} (linear_ordered_add_comm_group.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (linear_ordered_add_comm_group.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_46494 (h0 : functor.add_const (topological_space (preorder congr_arg_kind)) num) : @totally_separated_space.{0} (preorder.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (preorder.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_46495 (h0 : functor.add_const (ordered_comm_monoid (ring environment.implicit_infer_kind)) linarith.comp) : @has_exists_mul_of_le.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (ring.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_46496 (h0 : group (add_cancel_monoid (has_neg (has_neg linarith.comp)))) : is_simple_group (add_cancel_monoid (has_neg (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_46497 (h0 : has_mem.mem (has_top linarith.comp_source) has_emptyc.emptyc) : @strong_rank_condition.{0} (has_top.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type ring.{0} (has_top.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_46498 (h0 : complete_lattice (measurable_space (random_gen (random_gen (random_gen (random_gen string_imp)))))) : is_atomistic (measurable_space (random_gen (random_gen (random_gen (random_gen string_imp))))) := sorry --non-trivial
lemma new_lemma_46499 (h0 : ordered_add_comm_monoid (semigroup (finset linarith.comp))) : archimedean (semigroup (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_46500 (h0 : group (metric_space linarith.comp_source)) : is_cyclic (metric_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_46501 (h0 : ordered_add_comm_monoid (has_add pos)) : archimedean (has_add pos) := sorry --non-trivial
lemma new_lemma_46502 (h1 : group (div_inv_monoid (has_nnnorm linarith.comp_source))) : is_cyclic (div_inv_monoid (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_46503 (h0 : list (cancel_monoid congr_arg_kind)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_46504 (h1 : ring (random_gen to_additive.value_type)) : rank_condition (random_gen to_additive.value_type) := sorry --non-trivial
lemma new_lemma_46505 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @topological_space.separable_space.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_46506 (h0 : ring (generalized_boolean_algebra Type)) : is_domain (generalized_boolean_algebra Type) := sorry --non-trivial
lemma new_lemma_46507 (h0 : function.extfun (finset Type) (has_mem.mem empty)) : @is_domain.{0} empty (@finset.pi.empty.{1 0} Type ring.{0} empty (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) empty) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_46508 (h0 : topological_space (boolean_algebra (finset Type))) : locally_compact_space (boolean_algebra (finset Type)) := sorry --non-trivial
lemma new_lemma_46509 (h0 : not (topological_space (has_nnnorm char) -> false)) : @t0_space.{0} (has_nnnorm.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (has_nnnorm.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_46510 (h0 : functor.add_const (function.extfun Type uniform_space) pos) : @complete_space.{0} (has_nndist.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) pos h0) (has_nndist.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_46511 (h0 : list (has_pos_part (boolean_algebra (has_pos_part (has_neg Type))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_46512 (h0 : group (has_inter num)) : is_cyclic (has_inter num) := sorry --non-trivial
lemma new_lemma_46513 (h0 : ordered_comm_monoid (has_pos_part (has_add (has_neg linarith.comp)))) : has_exists_mul_of_le (has_pos_part (has_add (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_46514 (h0 : list (has_dist num)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_46515 (h1 : ring (add_comm_semigroup char)) : is_domain (add_comm_semigroup char) := sorry --non-trivial
lemma new_lemma_46516 (h0 : function.extfun Type group) : @normalizer_condition.{0} (normed_group.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} h0 (normed_group.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_46517 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (topological_space.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (topological_space.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_46518 (h0 : functor.add_const (function.extfun Type topological_space) (has_add pos)) : @preirreducible_space.{0} (finset.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (has_add.{0} pos) h0) (finset.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_46519 (h0 : topological_space (ring (has_pos_part (finset (finset (finset (has_pos_part linarith.comp))))))) : discrete_topology (ring (has_pos_part (finset (finset (finset (has_pos_part linarith.comp)))))) := sorry --non-trivial
lemma new_lemma_46520 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_46521 (h0 : ordered_comm_monoid (has_nndist (boolean_algebra name))) : has_exists_mul_of_le (has_nndist (boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_46522 (h0 : functor.add_const (topological_space (add_cancel_monoid Type)) (has_neg pos)) : @path_connected_space.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_cancel_monoid.{1} Type)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_46523 (h0 : topological_space (cancel_monoid (finset name))) : normal_space (cancel_monoid (finset name)) := sorry --non-trivial
lemma new_lemma_46524 (h0 : topological_space (has_add environment.implicit_infer_kind)) : totally_disconnected_space (has_add environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_46525 (h0 : list (topological_space (denumerable (with_one (random_gen (random_gen (random_gen (random_gen char)))))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_46526 (h0 : add_group (boolean_algebra (ring (has_neg Type)))) : is_add_cyclic (boolean_algebra (ring (has_neg Type))) := sorry --non-trivial
lemma new_lemma_46527 (h0 : functor.add_const (topological_space (has_neg pos)) (ring pos)) : @topological_space.separable_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} pos)) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_46528 (h0 : functor.add_const (topological_space (ordered_comm_ring Type)) Type) : @totally_disconnected_space.{1} (ordered_comm_ring.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (ordered_comm_ring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_46529 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (sub_neg_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (sub_neg_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_46530 (h0 : ring (semigroup (comm_group (has_add (has_neg_part Type))))) : rank_condition (semigroup (comm_group (has_add (has_neg_part Type)))) := sorry --non-trivial
lemma new_lemma_46531 (h0 : topological_space (additive ereal)) (h1 : set (additive ereal)) : is_preconnected h1 := sorry --non-trivial
lemma new_lemma_46532 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_46533 (h0 : set (set std_gen)) (h1 : std_gen -> char) (h2 : coe_sort (set.range h1)) : set.sInter h0 (set.range_splitting h1 h2) := sorry --non-trivial
lemma new_lemma_46534 (h1 : complete_lattice (semi_normed_comm_ring std_gen)) : is_compactly_generated (semi_normed_comm_ring std_gen) := sorry --non-trivial
lemma new_lemma_46535 (h0 : topological_space (finset environment.implicit_infer_kind)) : totally_disconnected_space (finset environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_46536 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_principal_ideal_ring.{1} (simple_graph.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ring.{1}) (simple_graph.{1} Type))  := sorry --non-trivial
lemma new_lemma_46537 (h0 : ring (with_one (random_gen (random_gen fun_info)))) : strong_rank_condition (with_one (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_46538 (h0 : fin has_zero.zero) : @locally_compact_space.{0} (ring.{0} (has_neg.{0} name)) (@matrix.vec_empty.{0} (topological_space.{0} (ring.{0} (has_neg.{0} name))) h0)  := sorry --non-trivial
lemma new_lemma_46539 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (canonically_linear_ordered_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (canonically_linear_ordered_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_46540 (h0 : ring (linear_ordered_semiring (random_gen (random_gen (has_norm num))))) : is_domain (linear_ordered_semiring (random_gen (random_gen (has_norm num)))) := sorry --non-trivial
lemma new_lemma_46541 (h0 : uniform_space (complete_distrib_lattice (option unsigned))) : complete_space (complete_distrib_lattice (option unsigned)) := sorry --non-trivial
lemma new_lemma_46542 (h0 : ring (normed_field (random_gen (random_gen char)))) : is_domain (normed_field (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_46543 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (has_add.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_add.{0} name))  := sorry --non-trivial
lemma new_lemma_46544 (h0 : has_mem.mem (measurable_space (has_norm congr_arg_kind)) has_emptyc.emptyc) : @strong_rank_condition.{0} (measurable_space.{0} (has_norm.{0} congr_arg_kind)) (@finset.pi.empty.{1 0} Type ring.{0} (measurable_space.{0} (has_norm.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_46545 (h0 : functor.add_const (ring (has_neg_part name)) (comm_group (comm_group (comm_group Type)))) : @is_principal_ideal_ring.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 1} (ring.{0} (has_neg_part.{0} name)) (comm_group.{1} (comm_group.{1} (comm_group.{1} Type))) h0)  := sorry --non-trivial
lemma new_lemma_46546 (h0 : functor.add_const (topological_space (has_add pos)) unsigned) : @preconnected_space.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_46547 (h0 : topological_space (has_nndist (has_neg (comm_group pos)))) : totally_disconnected_space (has_nndist (has_neg (comm_group pos))) := sorry --non-trivial
lemma new_lemma_46548 (h0 : ordered_add_comm_monoid (cancel_monoid (option (option empty)))) : archimedean (cancel_monoid (option (option empty))) := sorry --non-trivial
lemma new_lemma_46549 (h0 : functor.add_const (ring (with_zero congr_arg_kind)) unsigned) : @is_principal_ideal_ring.{0} (with_zero.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ring.{0} (with_zero.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_46550 (h0 : complete_lattice (finset (has_neg_part (has_add environment.implicit_infer_kind)))) : is_atomistic (finset (has_neg_part (has_add environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_46551 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (distrib_lattice linarith.ineq)) := sorry --non-trivial
lemma new_lemma_46552 (h0 : filter (fintype (has_ssubset (has_nnnorm (has_nnnorm (has_nnnorm fun_info)))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_46553 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (has_emptyc.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (has_emptyc.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_46554 (h0 : group (ordered_comm_monoid (ordered_comm_monoid (ordered_comm_monoid Type)))) : normalizer_condition (ordered_comm_monoid (ordered_comm_monoid (ordered_comm_monoid Type))) := sorry --non-trivial
lemma new_lemma_46555 (h0 : uniform_space (simple_graph to_additive.value_type)) : complete_space (simple_graph to_additive.value_type) := sorry --non-trivial
lemma new_lemma_46556 (h0 : not (complete_lattice (measurable_space congr_arg_kind) -> false)) : is_atomistic (measurable_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_46557 (h0 : functor.add_const (function.extfun (Type 1) topological_space) (comm_group Type)) : @totally_separated_space.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) (comm_group.{1} Type) h0) (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_46558 (h0 : topological_space (random_gen (semiring congr_arg_kind))) : discrete_topology (random_gen (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_46559 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (@id.{2} Type num) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (@id.{2} Type num))  := sorry --non-trivial
lemma new_lemma_46560 (h0 : functor.add_const (group (boolean_algebra name)) Type) : @is_simple_group.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 1} (group.{0} (boolean_algebra.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_46561 (h0 : topological_space (left_cancel_semigroup (option congr_arg_kind))) : totally_separated_space (left_cancel_semigroup (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_46562 (h0 : topological_space (has_neg (has_add Type))) : loc_path_connected_space (has_neg (has_add Type)) := sorry --non-trivial
lemma new_lemma_46563 (h0 : not (monoid (non_assoc_semiring unsigned) -> false)) : @monoid.fg.{0} (non_assoc_semiring.{0} unsigned) (@classical.by_contradiction'.{1} (monoid.{0} (non_assoc_semiring.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_46564 (h0 : uniform_space (distrib (mul_one_class (has_ssubset (random_gen (distrib reducibility_hints)))))) : complete_space (distrib (mul_one_class (has_ssubset (random_gen (distrib reducibility_hints))))) := sorry --non-trivial
lemma new_lemma_46565 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (simple_graph.{0} name) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (simple_graph.{0} name))  := sorry --non-trivial
lemma new_lemma_46566 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} (sub_neg_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) (sub_neg_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_46567 (h0 : functor.add_const (topological_space (has_add (has_neg linarith.comp))) pos) : @totally_separated_space.{0} (has_add.{0} (has_neg.{0} linarith.comp)) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} (has_neg.{0} linarith.comp))) pos h0)  := sorry --non-trivial
lemma new_lemma_46568 (h0 : cancel_comm_monoid_with_zero (comm_group (has_to_string Type))) : unique_factorization_monoid (comm_group (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_46569 (h0 : function.extfun nat fin) : @loc_path_connected_space.{1} (has_Inf.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (has_Inf.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_46570 (h0 : monoid (has_neg (has_neg (has_neg Type)))) : monoid.fg (has_neg (has_neg (has_neg Type))) := sorry --non-trivial
lemma new_lemma_46571 (h0 : group (measurable_space (has_top num))) : normalizer_condition (measurable_space (has_top num)) := sorry --non-trivial
lemma new_lemma_46572 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @preirreducible_space.{1} (simple_graph.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (simple_graph.{1} Type))  := sorry --non-trivial
lemma new_lemma_46573 (h0 : not (ring (denumerable int) -> false)) : @rank_condition.{0} (denumerable.{0} int) (@classical.by_contradiction'.{1} (ring.{0} (denumerable.{0} int)) h0)  := sorry --non-trivial
lemma new_lemma_46574 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (simple_graph linarith.comp)) := sorry --non-trivial
lemma new_lemma_46575 (h0 : topological_space (add_right_cancel_monoid (semiring (semiring (add_group congr_arg_kind))))) : normal_space (add_right_cancel_monoid (semiring (semiring (add_group congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_46576 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (comm_semigroup.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (comm_semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_46577 (h0 : ring (comm_monoid (option empty))) : is_domain (comm_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_46578 (h0 : functor.add_const (topological_space (has_nndist linarith.comp)) Type) : @totally_separated_space.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_nndist.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_46579 (h0 : topological_space (with_bot empty)) : totally_separated_space (with_bot empty) := sorry --non-trivial
lemma new_lemma_46580 (h0 : functor.add_const (function.extfun Type ordered_comm_monoid) (mul_zero_class (has_neg (has_add Type)))) : @has_exists_mul_of_le.{0} (cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) (mul_zero_class.{1} (has_neg.{1} (has_add.{1} Type))) h0) (cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_46581 (h0 : function.extfun (group Type -> false) (fun (x : group Type -> false), false)) : @normalizer_condition.{1} Type (@classical.by_contradiction'.{2} (group.{1} Type) (@function.extfun_app.{0 0} (group.{1} Type → false) (λ (x : group.{1} Type → false), false) h0))  := sorry --non-trivial
lemma new_lemma_46582 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (with_bot.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 complete_lattice.{0}) (with_bot.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_46583 (h0 : complete_lattice (complete_semilattice_Sup empty)) : is_compactly_generated (complete_semilattice_Sup empty) := sorry --non-trivial
lemma new_lemma_46584 (h0 : fin has_zero.zero) : @totally_disconnected_space.{0} (ordered_comm_monoid.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_46585 : nonempty (mul_one_class (comm_semigroup ereal)) := sorry --non-trivial
lemma new_lemma_46586 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_46587 (h0 : functor.comp topological_space has_neg_part (ring unsigned)) : @t0_space.{0} (has_neg_part.{0} (ring.{0} unsigned)) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg_part.{0} (ring.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_46588 (h0 : topological_space (complete_distrib_lattice (comm_group unsigned))) : t1_space (complete_distrib_lattice (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_46589 (h0 : not (filter (semi_normed_ring to_additive.value_type) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_46590 (h0 : topological_space (canonically_ordered_comm_semiring (finset Type))) : preconnected_space (canonically_ordered_comm_semiring (finset Type)) := sorry --non-trivial
lemma new_lemma_46591 (h0 : functor.add_const (filter (add_comm_monoid pos)) linarith.comp) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_46592 (h1 : complete_lattice (semi_normed_comm_ring string_imp)) : complete_lattice.is_Sup_finite_compact (semi_normed_comm_ring string_imp) := sorry --non-trivial
lemma new_lemma_46593 (h0 : functor.add_const (ordered_add_comm_monoid (normed_comm_ring Type)) (has_to_string (finset linarith.comp))) : @archimedean.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (ordered_add_comm_monoid.{1} (normed_comm_ring.{1} Type)) (has_to_string.{0} (finset.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_46594 (h0 : has_mem.mem (semiring fun_info) has_emptyc.emptyc) : @irreducible_space.{0} (semiring.{0} fun_info) (@finset.pi.empty.{1 0} Type topological_space.{0} (semiring.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_46595 (h0 : add_group (has_to_string (has_nndist name))) : is_add_cyclic (has_to_string (has_nndist name)) := sorry --non-trivial
lemma new_lemma_46596 (h0 : functor.add_const (complete_lattice (ring linarith.comp)) Type) : @is_compactly_generated.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (complete_lattice.{0} (ring.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_46597 (h0 : not (function.extfun Type ring -> false)) : @strong_rank_condition.{0} (with_one.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (with_one.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_46598 (h0 : topological_space (has_edist (semiring (semiring unsigned)))) : irreducible_space (has_edist (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_46599 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (has_sub.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (has_sub.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_46600 (h0 : add_group (random_gen (comm_ring linarith.ineq))) : is_add_cyclic (random_gen (comm_ring linarith.ineq)) := sorry --non-trivial
lemma new_lemma_46601 (h0 : function.extfun Type ring) : @is_domain.{0} (normed_linear_ordered_group.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (normed_linear_ordered_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_46602 (h0 : group (has_zero (has_neg_part unsigned))) : normalizer_condition (has_zero (has_neg_part unsigned)) := sorry --non-trivial
lemma new_lemma_46603 (h0 : list environment.implicit_infer_kind) : palindrome h0 := sorry --non-trivial
lemma new_lemma_46604 (h0 : ring (complete_distrib_lattice num)) : is_principal_ideal_ring (complete_distrib_lattice num) := sorry --non-trivial
lemma new_lemma_46605 (h0 : group (linear_ordered_comm_group congr_arg_kind)) : is_cyclic (linear_ordered_comm_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_46606 (h0 : functor.add_const (functor.add_const (finset linarith.comp) pos) Type) : finset.nonempty (functor.add_const.run (functor.add_const.run h0)) := sorry --non-trivial
lemma new_lemma_46607 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @rank_condition.{0} (dlist.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) ring.{0}) (dlist.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_46608 (h0 : topological_space (canonically_ordered_comm_semiring (has_Inf pos))) : t0_space (canonically_ordered_comm_semiring (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_46609 (h0 : ring (random_gen (random_gen (has_nnnorm (has_nnnorm fun_info))))) : rank_condition (random_gen (random_gen (has_nnnorm (has_nnnorm fun_info)))) := sorry --non-trivial
lemma new_lemma_46610 (h0 : ring ereal) : invariant_basis_number ereal := sorry --non-trivial
lemma new_lemma_46611 (h0 : functor.add_const (semiring (normed_comm_ring pos)) (finset linarith.comp)) : @is_noetherian_ring.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (semiring.{0} (normed_comm_ring.{0} pos)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_46612 (h0 : functor.add_const (ring (has_nndist unsigned)) linarith.comp) : @strong_rank_condition.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (has_nndist.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_46613 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (partial_order.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (partial_order.{0} num))  := sorry --non-trivial
lemma new_lemma_46614 (h0 : topological_space (has_Inf (has_Inf name))) : discrete_topology (has_Inf (has_Inf name)) := sorry --non-trivial
lemma new_lemma_46615 (h0 : add_group (canonically_ordered_monoid real)) : is_add_cyclic (canonically_ordered_monoid real) := sorry --non-trivial
lemma new_lemma_46616 (h0 : functor.add_const (complete_lattice (has_bot real)) real) : @is_atomistic.{0} (has_bot.{0} real) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_bot.{0} real)) real h0)  := sorry --non-trivial
lemma new_lemma_46617 (h0 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} (semiring.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_46618 (h0 : uniform_space (canonically_ordered_comm_semiring (mul_zero_class pos))) : separated_space (canonically_ordered_comm_semiring (mul_zero_class pos)) := sorry --non-trivial
lemma new_lemma_46619 (h0 : functor.add_const (ring (normed_linear_ordered_group unsigned)) (option empty)) : @is_domain.{0} (normed_linear_ordered_group.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (normed_linear_ordered_group.{0} unsigned)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_46620 (h0 : topological_space (ring (has_neg_part linarith.comp))) : irreducible_space (ring (has_neg_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_46621 (h0 : functor.add_const (add_group (has_nndist unsigned)) environment.implicit_infer_kind) : @is_add_cyclic.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 0} (add_group.{0} (has_nndist.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_46622 (h1 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} num (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h1) complete_lattice.{0}) num)  := sorry --non-trivial
lemma new_lemma_46623 (h0 : topological_space (ordered_ring empty)) : t1_space (ordered_ring empty) := sorry --non-trivial
lemma new_lemma_46624 (h0 : functor.add_const (topological_space (bin_tree num)) congr_arg_kind) : @path_connected_space.{0} (bin_tree.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (bin_tree.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_46625 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (ordered_cancel_add_comm_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_cancel_add_comm_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_46626 (h0 : functor.add_const (monoid (simple_graph linarith.comp)) name) : @monoid.fg.{0} (simple_graph.{0} linarith.comp) (@functor.add_const.run.{0 0} (monoid.{0} (simple_graph.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_46627 (h0 : topological_space (random_gen (has_top (random_gen linarith.comp_source)))) : totally_separated_space (random_gen (has_top (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_46628 (h0 : uniform_space (boolean_algebra (has_add Type))) : separated_space (boolean_algebra (has_add Type)) := sorry --non-trivial
lemma new_lemma_46629 (h0 : topological_space (add_comm_semigroup enat)) (h3 : char -> add_comm_semigroup (add_comm_semigroup enat) -> preorder (add_comm_semigroup enat)) (h5 : prod char (add_comm_semigroup (add_comm_semigroup enat))) : @order_topology.{0} (add_comm_semigroup.{0} enat) h0 (@function.uncurry.{0 0 0} char (add_comm_semigroup.{0} (add_comm_semigroup.{0} enat)) (preorder.{0} (add_comm_semigroup.{0} enat)) h3 h5)  := sorry --non-trivial
lemma new_lemma_46630 (h0 : not (topological_space (semiring congr_arg_kind) -> false)) : @t0_space.{0} (semiring.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (semiring.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_46631 (h0 : function.extfun Type ring) : @is_domain.{0} (has_top.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_top.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_46632 (h0 : ring (add_cancel_monoid congr_arg_kind)) : is_principal_ideal_ring (add_cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_46633 (h1 : function.extfun Type topological_space) : @discrete_topology.{0} linarith.comp (@function.extfun_app.{2 1} Type topological_space.{0} h1 linarith.comp)  := sorry --non-trivial
lemma new_lemma_46634 (h0 : group (has_neg_part (cancel_monoid name))) : group.fg (has_neg_part (cancel_monoid name)) := sorry --non-trivial
lemma new_lemma_46635 (h0 : topological_space (with_bot linarith.comp_source)) : path_connected_space (with_bot linarith.comp_source) := sorry --non-trivial
lemma new_lemma_46636 (h0 : uniform_space (has_edist congr_arg_kind)) : complete_space (has_edist congr_arg_kind) := sorry --non-trivial
lemma new_lemma_46637 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_46638 (h0 : uniform_space (ordered_comm_ring char)) : complete_space (ordered_comm_ring char) := sorry --non-trivial
lemma new_lemma_46639 (h0 : topological_space (complete_linear_order unsigned)) : t1_space (complete_linear_order unsigned) := sorry --non-trivial
lemma new_lemma_46640 (h0 : topological_space (has_le string.iterator_imp)) (h1 : add_group (has_le string.iterator_imp)) : topological_add_group (has_le string.iterator_imp) := sorry --non-trivial
lemma new_lemma_46641 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_46642 (h0 : ordered_comm_monoid (boolean_algebra.core (finset ennreal))) : has_exists_mul_of_le (boolean_algebra.core (finset ennreal)) := sorry --non-trivial
lemma new_lemma_46643 (h0 : set (set (mul_one_class string.iterator_imp))) (h1 : set (mul_one_class string.iterator_imp)) : measurable_space.dynkin_system.generate_has h0 h1 := sorry --non-trivial
lemma new_lemma_46644 (h0 : topological_space (has_pos_part (sub_neg_monoid linarith.comp))) : regular_space (has_pos_part (sub_neg_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_46645 (h0 : not (topological_space (has_add fun_info) -> false)) (h1 : preorder (has_add fun_info)) : @order_topology.{0} (has_add.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (has_add.{0} fun_info)) h0) h1  := sorry --non-trivial
lemma new_lemma_46646 (h0 : functor.add_const (topological_space (bin_tree unsigned)) congr_arg_kind) : @discrete_topology.{0} (bin_tree.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (bin_tree.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_46647 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (linear_ordered_comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (linear_ordered_comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_46648 (h0 : not (topological_space (has_top empty) -> false)) : @path_connected_space.{0} (has_top.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (has_top.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_46649 (h0 : semiring (with_bot (has_top (has_top empty)))) : is_noetherian_ring (with_bot (has_top (has_top empty))) := sorry --non-trivial
lemma new_lemma_46650 (h0 : ring (has_div (mul_one_class linarith.ineq))) : strong_rank_condition (has_div (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_46651 (h1 : topological_space (ordered_comm_semiring to_additive.value_type)) : t0_space (ordered_comm_semiring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_46652 (h0 : uniform_space (topological_space (has_inv linarith.ineq))) : complete_space (topological_space (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_46653 (h0 : set (nondiscrete_normed_field (normed_field char))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_46654 (h0 : topological_space (sub_neg_monoid (finset Type))) : sequential_space (sub_neg_monoid (finset Type)) := sorry --non-trivial
lemma new_lemma_46655 (h1 : function.extfun Type list) : list.nodup (function.extfun_app h1 (has_norm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_46656 (h0 : topological_space (has_Inf (has_neg Type))) : irreducible_space (has_Inf (has_neg Type)) := sorry --non-trivial
lemma new_lemma_46657 (h0 : complete_lattice (has_zero (add_cancel_monoid (has_zero name)))) : is_compactly_generated (has_zero (add_cancel_monoid (has_zero name))) := sorry --non-trivial
lemma new_lemma_46658 (h0 : fin has_zero.zero) : @normal_space.{0} (complete_distrib_lattice.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (complete_distrib_lattice.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_46659 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @preconnected_space.{0} (comm_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (comm_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_46660 (h0 : uniform_space (canonically_linear_ordered_monoid pos)) : complete_space (canonically_linear_ordered_monoid pos) := sorry --non-trivial
lemma new_lemma_46661 (h1 : ring (normed_group to_additive.value_type)) : is_domain (normed_group to_additive.value_type) := sorry --non-trivial
lemma new_lemma_46662 (h0 : topological_space (has_neg (has_neg Type))) : locally_compact_space (has_neg (has_neg Type)) := sorry --non-trivial
lemma new_lemma_46663 (h0 : topological_space (ordered_comm_ring Type)) : topological_space.separable_space (ordered_comm_ring Type) := sorry --non-trivial
lemma new_lemma_46664 (h0 : not (topological_space (has_top num) -> false)) : @t0_space.{0} (has_top.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (has_top.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_46665 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (has_nndist.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_nndist.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_46666 (h0 : set (has_lt std_gen)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_46667 (h0 : topological_space (metric_space num)) : t1_space (metric_space num) := sorry --non-trivial
lemma new_lemma_46668 (h0 : function.extfun Type (functor.comp topological_space cancel_monoid)) : @preirreducible_space.{0} (cancel_monoid.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} cancel_monoid.{0} ennreal (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} cancel_monoid.{0}) h0 ennreal))  := sorry --non-trivial
lemma new_lemma_46669 (h0 : complete_lattice (normed_linear_ordered_group linarith.ineq)) : is_compactly_generated (normed_linear_ordered_group linarith.ineq) := sorry --non-trivial
lemma new_lemma_46670 (h0 : cancel_comm_monoid_with_zero (has_zero (boolean_algebra.core name))) : unique_factorization_monoid (has_zero (boolean_algebra.core name)) := sorry --non-trivial
lemma new_lemma_46671 (h0 : complete_lattice (linear_ordered_comm_monoid_with_zero unsigned)) : is_atomistic (linear_ordered_comm_monoid_with_zero unsigned) := sorry --non-trivial
lemma new_lemma_46672 (h0 : topological_space (has_edist (option (option (option unsigned))))) : locally_compact_space (has_edist (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_46673 (h0 : list (linear_ordered_comm_group (option empty))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_46674 (h0 : fin has_zero.zero) : @regular_space.{0} (has_pos_part.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_pos_part.{0} real))  := sorry --non-trivial
lemma new_lemma_46675 (h0 : topological_space ereal) (h1 : has_sup ereal) : has_continuous_sup ereal := sorry --non-trivial
lemma new_lemma_46676 (h0 : ordered_comm_monoid (complete_distrib_lattice (sub_neg_monoid (ordered_comm_monoid pos)))) : has_exists_mul_of_le (complete_distrib_lattice (sub_neg_monoid (ordered_comm_monoid pos))) := sorry --non-trivial
lemma new_lemma_46677 (h0 : not (has_mem.mem (has_norm linarith.comp) has_emptyc.emptyc -> false)) : @is_atomistic.{0} (has_norm.{0} linarith.comp) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (has_norm.{0} linarith.comp) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_norm.{0} linarith.comp) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_46678 (h0 : uniform_space (has_neg (complete_distrib_lattice environment.implicit_infer_kind))) : complete_space (has_neg (complete_distrib_lattice environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_46679 (h0 : function.extfun Type (functor.comp ring semigroup)) : @rank_condition.{0} (semigroup.{0} (normed_comm_ring.{0} environment.implicit_infer_kind)) (@functor.comp.run.{0 0 0} ring.{0} semigroup.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} ring.{0} semigroup.{0}) h0 (normed_comm_ring.{0} environment.implicit_infer_kind)))  := sorry --non-trivial
lemma new_lemma_46680 (h0 : topological_space (ring (has_zero (has_to_string unsigned)))) : topological_space.separable_space (ring (has_zero (has_to_string unsigned))) := sorry --non-trivial
lemma new_lemma_46681 (h0 : ring (distrib_lattice linarith.ineq)) : is_domain (distrib_lattice linarith.ineq) := sorry --non-trivial
lemma new_lemma_46682 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (linear_ordered_semiring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_46683 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (simple_graph.{0} pos) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (simple_graph.{0} pos))  := sorry --non-trivial
lemma new_lemma_46684 (h0 : functor.add_const (group (measurable_space.dynkin_system unsigned)) empty) : @normalizer_condition.{0} (measurable_space.dynkin_system.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (measurable_space.dynkin_system.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_46685 (h0 : function.extfun Type topological_space) : normal_space real := sorry --non-trivial
lemma new_lemma_46686 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (linear_ordered_field.{0} empty) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (linear_ordered_field.{0} empty))  := sorry --non-trivial
lemma new_lemma_46687 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (has_dist empty)) := sorry --non-trivial
lemma new_lemma_46688 (h0 : ring (finset ennreal)) : strong_rank_condition (finset ennreal) := sorry --non-trivial
lemma new_lemma_46689 (h1 : topological_space (random_gen (random_gen string_imp))) : locally_compact_space (random_gen (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_46690 (h0 : topological_space (add_comm_monoid (finset pos))) : discrete_topology (add_comm_monoid (finset pos)) := sorry --non-trivial
lemma new_lemma_46691 (h0 : ring (random_gen (comm_ring to_additive.value_type))) : is_domain (random_gen (comm_ring to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_46692 (h0 : monoid (canonically_ordered_monoid (canonically_ordered_monoid real))) : monoid.fg (canonically_ordered_monoid (canonically_ordered_monoid real)) := sorry --non-trivial
lemma new_lemma_46693 (h0 : monoid (mul_zero_class (has_add ennreal))) : monoid.fg (mul_zero_class (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_46694 (h0 : add_group (comm_semigroup (has_neg (has_bot real)))) : is_add_cyclic (comm_semigroup (has_neg (has_bot real))) := sorry --non-trivial
lemma new_lemma_46695 (h0 : add_monoid (filter empty)) : add_monoid.fg (filter empty) := sorry --non-trivial
lemma new_lemma_46696 (h0 : functor.add_const (topological_space (ordered_ring num)) num) : @locally_compact_space.{0} (ordered_ring.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_46697 (h0 : functor.add_const (function.extfun Type complete_lattice) environment.implicit_infer_kind) : @is_compactly_generated.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) environment.implicit_infer_kind h0) (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_46698 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (left_cancel_semigroup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (left_cancel_semigroup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_46699 (h0 : functor.add_const (group (semigroup name)) environment.implicit_infer_kind) : @is_cyclic.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (group.{0} (semigroup.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_46700 (h0 : functor.add_const (list (has_nndist name)) pos) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_46701 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (normed_linear_ordered_group.{0} (semiring.{0} empty)) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (normed_linear_ordered_group.{0} (semiring.{0} empty)))  := sorry --non-trivial
lemma new_lemma_46702 (h0 : complete_lattice (measurable_space (has_top linarith.comp_source))) : complete_lattice.is_Sup_finite_compact (measurable_space (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_46703 (h0 : ring (add_comm_semigroup (add_comm_semigroup string.iterator_imp))) : strong_rank_condition (add_comm_semigroup (add_comm_semigroup string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_46704 (h0 : functor.add_const (topological_space (option congr_arg_kind)) congr_arg_kind) : @totally_separated_space.{0} (option.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_46705 (h0 : has_mem.mem (random_gen linarith.comp_source) has_emptyc.emptyc) : @rank_condition.{0} (random_gen.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type ring.{0} (random_gen.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_46706 (h0 : functor.comp add_group has_neg_part pos) : @is_add_cyclic.{0} (has_neg_part.{0} pos) (@functor.comp.run.{0 0 0} add_group.{0} has_neg_part.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_46707 (h0 : functor.add_const (ordered_add_comm_monoid (has_to_string Type)) linarith.comp) : @archimedean.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (ordered_add_comm_monoid.{1} (has_to_string.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_46708 (h0 : function.extfun Type group) : @group.fg.{0} (@id.{2} Type congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (@id.{2} Type congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_46709 (h0 : functor.add_const (uniform_space (semigroup Type)) (normed_comm_ring (has_pos_part (has_to_string Type)))) : @complete_space.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 1} (uniform_space.{1} (semigroup.{1} Type)) (normed_comm_ring.{1} (has_pos_part.{1} (has_to_string.{1} Type))) h0)  := sorry --non-trivial
lemma new_lemma_46710 (h0 : fin has_zero.zero) : @irreducible_space.{0} (has_bot.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_bot.{0} real))  := sorry --non-trivial
lemma new_lemma_46711 (h0 : topological_space (bin_tree (semiring num))) : t1_space (bin_tree (semiring num)) := sorry --non-trivial
lemma new_lemma_46712 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (sub_neg_monoid.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (sub_neg_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_46713 (h0 : cancel_comm_monoid_with_zero (normed_comm_ring (comm_group (comm_group unsigned)))) : unique_factorization_monoid (normed_comm_ring (comm_group (comm_group unsigned))) := sorry --non-trivial
lemma new_lemma_46714 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (ordered_comm_ring.{0} real) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (ordered_comm_ring.{0} real))  := sorry --non-trivial
lemma new_lemma_46715 (h1 : ring (normed_field std_gen)) : strong_rank_condition (normed_field std_gen) := sorry --non-trivial
lemma new_lemma_46716 (h0 : set (has_nnnorm reducibility_hints)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_46717 (h0 : functor.add_const (topological_space (add_cancel_monoid Type)) environment.implicit_infer_kind) : @t0_space.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_cancel_monoid.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_46718 (h0 : uniform_space (with_bot (semiring (semiring (has_top (semiring (semiring unsigned))))))) : complete_space (with_bot (semiring (semiring (has_top (semiring (semiring unsigned)))))) := sorry --non-trivial
lemma new_lemma_46719 (h0 : topological_space (has_sub empty)) : t1_space (has_sub empty) := sorry --non-trivial
lemma new_lemma_46720 (h0 : topological_space (boolean_algebra (has_to_string unsigned))) : discrete_topology (boolean_algebra (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_46721 (h0 : functor.add_const (cancel_comm_monoid_with_zero (normed_lattice_add_comm_group pos)) real) : @unique_factorization_monoid.{0} (normed_lattice_add_comm_group.{0} pos) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (normed_lattice_add_comm_group.{0} pos)) real h0)  := sorry --non-trivial
lemma new_lemma_46722 (h0 : function.extfun Type topological_space) (h1 : linarith.ineq -> linear_ordered_comm_ring string_imp) : @dense_range.{0 0} (linear_ordered_comm_ring.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_ring.{0} string_imp)) linarith.ineq h1  := sorry --non-trivial
lemma new_lemma_46723 (h0 : complete_lattice (cancel_monoid (option unsigned))) : complete_lattice.is_Sup_finite_compact (cancel_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_46724 (h0 : topological_space (has_zero (finset linarith.comp))) : t1_space (has_zero (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_46725 (h0 : function.extfun Type (functor.add_const (topological_space (has_zero unsigned)))) : @totally_disconnected_space.{0} (has_zero.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} unsigned)) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (has_zero.{0} unsigned))) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_46726 (h0 : topological_space (add_comm_semigroup char)) (h1 : preorder (add_comm_semigroup char)) : order_topology (add_comm_semigroup char) := sorry --non-trivial
lemma new_lemma_46727 (h0 : add_group (has_top (distrib_lattice (denumerable to_additive.value_type)))) : is_add_cyclic (has_top (distrib_lattice (denumerable to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_46728 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @t0_space.{1} (comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_46729 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_46730 (h0 : topological_space (measurable_space.dynkin_system empty)) : loc_path_connected_space (measurable_space.dynkin_system empty) := sorry --non-trivial
lemma new_lemma_46731 (h0 : topological_space (has_zero name)) : discrete_topology (has_zero name) := sorry --non-trivial
lemma new_lemma_46732 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (semiring.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} num))))) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semiring.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} num))))))  := sorry --non-trivial
lemma new_lemma_46733 (h0 : fin has_zero.zero) : @has_exists_mul_of_le.{0} (has_add.{0} linarith.comp) (@matrix.vec_empty.{0} (ordered_comm_monoid.{0} (has_add.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_46734 (h0 : complete_lattice (linear_order empty)) : is_atomistic (linear_order empty) := sorry --non-trivial
lemma new_lemma_46735 (h0 : ring (random_gen string_imp)) : is_domain (random_gen string_imp) := sorry --non-trivial
lemma new_lemma_46736 (h0 : functor.add_const (complete_lattice (has_pos_part pos)) pos) : @complete_lattice.is_Sup_finite_compact.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_pos_part.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_46737 (h0 : functor.add_const (topological_space (ring linarith.comp)) environment.implicit_infer_kind) : @path_connected_space.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_46738 (h0 : topological_space (has_one (has_norm unsigned))) : locally_compact_space (has_one (has_norm unsigned)) := sorry --non-trivial
lemma new_lemma_46739 (h0 : function.extfun Type topological_space) : @t1_space.{0} (ordered_cancel_add_comm_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_cancel_add_comm_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_46740 (h0 : ring (complete_distrib_lattice congr_arg_kind)) : is_domain (complete_distrib_lattice congr_arg_kind) := sorry --non-trivial
lemma new_lemma_46741 (h0 : topological_space (semigroup (add_left_cancel_semigroup unsigned))) : t1_space (semigroup (add_left_cancel_semigroup unsigned)) := sorry --non-trivial
lemma new_lemma_46742 (h0 : topological_space (has_emptyc (has_top (has_norm linarith.comp_source)))) : locally_compact_space (has_emptyc (has_top (has_norm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_46743 (h0 : topological_space (canonically_ordered_monoid (has_add (has_Inf linarith.comp)))) : locally_compact_space (canonically_ordered_monoid (has_add (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_46744 (h0 : function.extfun nat fin) : @discrete_topology.{0} (ordered_comm_ring.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_ring.{0} pos)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))))  := sorry --non-trivial
lemma new_lemma_46745 (h0 : add_group (complete_semilattice_Sup (random_gen (random_gen linarith.comp_source)))) : is_add_cyclic (complete_semilattice_Sup (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_46746 (h0 : add_group (has_dist (option (option unsigned)))) : is_add_cyclic (has_dist (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_46747 (h0 : topological_space (finset (semigroup linarith.comp))) : loc_path_connected_space (finset (semigroup linarith.comp)) := sorry --non-trivial
lemma new_lemma_46748 (h0 : list (complete_semilattice_Sup (random_gen (has_ssubset fun_info)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_46749 (h0 : topological_space (with_bot (has_norm empty))) : totally_disconnected_space (with_bot (has_norm empty)) := sorry --non-trivial
lemma new_lemma_46750 (h0 : function.extfun Type (functor.add_const (function.extfun Type group))) : @group.fg.{0} (mul_zero_class.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) pos (@function.extfun_app.{2 2} Type (functor.add_const.{1 0} (function.extfun.{2 1} Type group.{0})) h0 pos)) (mul_zero_class.{0} name))  := sorry --non-trivial
lemma new_lemma_46751 (h0 : functor.add_const (topological_space (has_Inf Type)) (finset Type)) : @irreducible_space.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_Inf.{1} Type)) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_46752 (h0 : functor.add_const (add_monoid (boolean_algebra environment.implicit_infer_kind)) environment.implicit_infer_kind) : @add_monoid.fg.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (add_monoid.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_46753 (h0 : functor.add_const (list (measurable_space.dynkin_system unsigned)) unsigned) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_46754 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_zero.{0} name) (@function.extfun_app.{2 1} Type group.{0} h0 (has_zero.{0} name))  := sorry --non-trivial
lemma new_lemma_46755 (h0 : finset (has_bot (option (option empty)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_46756 (h0 : semiring (semigroup (add_cancel_monoid pos))) : is_noetherian_ring (semigroup (add_cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_46757 (h0 : topological_space (has_nndist (boolean_algebra.core Type))) : normal_space (has_nndist (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_46758 (h0 : topological_space (measurable_space (has_union linarith.comp))) : preirreducible_space (measurable_space (has_union linarith.comp)) := sorry --non-trivial
lemma new_lemma_46759 (h0 : functor.add_const (topological_space (ordered_ring num)) empty) : @preirreducible_space.{0} (ordered_ring.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_46760 (h7 : ring (rel linarith.ineq (add_comm_semigroup ereal))) : rank_condition (rel linarith.ineq (add_comm_semigroup ereal)) := sorry --non-trivial
lemma new_lemma_46761 (h0 : functor.comp topological_space finset (has_add Type)) : @topological_space.separable_space.{1} (finset.{1} (has_add.{1} Type)) (@functor.comp.run.{1 1 1} topological_space.{1} finset.{1} (has_add.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_46762 (h0 : ordered_comm_monoid (boolean_algebra (has_Inf (has_Inf (has_add (has_Inf Type)))))) : has_exists_mul_of_le (boolean_algebra (has_Inf (has_Inf (has_add (has_Inf Type))))) := sorry --non-trivial
lemma new_lemma_46763 (h0 : functor.add_const (function.extfun (Type 1) filter) (ring (has_neg linarith.comp))) : filter.ne_bot (function.extfun_app (functor.add_const.run h0) (finset Type)) := sorry --non-trivial
lemma new_lemma_46764 (h0 : list (list (has_ssubset fun_info))) : list.nodup (list.head h0) := sorry --non-trivial
lemma new_lemma_46765 (h0 : filter (has_nndist (has_add Type))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_46766 (h0 : not (semiring (partial_order empty) -> false)) : @is_noetherian_ring.{0} (partial_order.{0} empty) (@classical.by_contradiction'.{1} (semiring.{0} (partial_order.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_46767 (h0 : complete_lattice (add_left_cancel_monoid (has_nnnorm linarith.comp_source))) : is_compactly_generated (add_left_cancel_monoid (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_46768 (h1 : not (filter (random_gen fun_info) -> false)) : filter.ne_bot (classical.by_contradiction' h1) := sorry --non-trivial
lemma new_lemma_46769 (h0 : topological_space (has_to_string (has_add (has_add linarith.comp)))) : totally_separated_space (has_to_string (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_46770 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_star.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_star.{0} num))  := sorry --non-trivial
lemma new_lemma_46771 (h0 : ordered_add_comm_monoid (add_comm_monoid (has_to_string (has_to_string pos)))) : archimedean (add_comm_monoid (has_to_string (has_to_string pos))) := sorry --non-trivial
lemma new_lemma_46772 (h0 : complete_lattice (normed_comm_ring name)) : is_compactly_generated (normed_comm_ring name) := sorry --non-trivial
lemma new_lemma_46773 (h0 : topological_space (has_add (has_add linarith.comp))) : preirreducible_space (has_add (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_46774 (h0 : functor.add_const (topological_space (complete_distrib_lattice Type)) environment.implicit_infer_kind) : @t1_space.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (complete_distrib_lattice.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_46775 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (ordered_ring.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (ordered_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_46776 (h0 : functor.add_const (topological_space (boolean_algebra pos)) (has_neg (has_add (has_neg Type)))) : @normal_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.{0} pos)) (has_neg.{1} (has_add.{1} (has_neg.{1} Type))) h0)  := sorry --non-trivial
lemma new_lemma_46777 (h0 : functor.comp group add_cancel_monoid Type) : @normalizer_condition.{1} (add_cancel_monoid.{1} Type) (@functor.comp.run.{1 1 1} group.{1} add_cancel_monoid.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_46778 (h0 : topological_space (ring Type)) : irreducible_space (ring Type) := sorry --non-trivial
lemma new_lemma_46779 (h0 : functor.add_const (complete_lattice (add_cancel_monoid Type)) (has_neg Type)) : @complete_lattice.is_Sup_finite_compact.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 1} (complete_lattice.{1} (add_cancel_monoid.{1} Type)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_46780 (h0 : ring (has_to_string environment.implicit_infer_kind)) : strong_rank_condition (has_to_string environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_46781 (h0 : topological_space (semigroup (has_neg (mul_one_class environment.implicit_infer_kind)))) : locally_compact_space (semigroup (has_neg (mul_one_class environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_46782 (h0 : group (fintype empty)) : normalizer_condition (fintype empty) := sorry --non-trivial
lemma new_lemma_46783 (h0 h1 : multiset (linear_ordered_comm_group_with_zero string.iterator_imp)) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_46784 (h1 : add_group (semi_normed_comm_ring linarith.comp_source) -> Prop) (h2 : Exists (fun (x : add_group (semi_normed_comm_ring linarith.comp_source)), h1 x)) : @is_add_cyclic.{0} (semi_normed_comm_ring.{0} linarith.comp_source) (@classical.some.{1} (add_group.{0} (semi_normed_comm_ring.{0} linarith.comp_source)) h1 h2)  := sorry --non-trivial
lemma new_lemma_46785 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @is_noetherian_ring.{0} (add_right_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) semiring.{0}) (add_right_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_46786 (h0 : fin has_zero.zero) : @strong_rank_condition.{1} (has_add.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (has_add.{1} Type)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_46787 (h0 : topological_space (measure_theory.measure_space (semiring unsigned))) : discrete_topology (measure_theory.measure_space (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_46788 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (non_assoc_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (non_assoc_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_46789 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (semigroup.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_46790 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (linear_ordered_field.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (linear_ordered_field.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_46791 (h0 : functor.add_const (filter (boolean_algebra.core Type)) Type) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_46792 (h1 : string.iterator_imp -> Prop) (h2 : string.iterator_imp) : set_of h1 h2 := sorry --non-trivial
lemma new_lemma_46793 (h0 : uniform_space (has_Inf (has_nndist Type))) : separated_space (has_Inf (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_46794 (h0 : function.extfun nat fin) : @locally_compact_space.{0} (sub_neg_monoid.{0} name) (@matrix.vec_empty.{0} (topological_space.{0} (sub_neg_monoid.{0} name)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_46795 (h0 : add_group (has_sub congr_arg_kind)) : is_add_cyclic (has_sub congr_arg_kind) := sorry --non-trivial
lemma new_lemma_46796 (h0 : complete_lattice (has_neg (boolean_algebra linarith.comp))) : is_compactly_generated (has_neg (boolean_algebra linarith.comp)) := sorry --non-trivial
lemma new_lemma_46797 (h0 : topological_space (semigroup num)) : irreducible_space (semigroup num) := sorry --non-trivial
lemma new_lemma_46798 (h0 : topological_space (with_one (has_norm num))) : normal_space (with_one (has_norm num)) := sorry --non-trivial
lemma new_lemma_46799 (h0 : not (function.extfun Type topological_space -> false)) : @discrete_topology.{0} (measurable_space.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (measurable_space.{0} num))  := sorry --non-trivial
lemma new_lemma_46800 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring pos)) Type) : @locally_compact_space.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (canonically_ordered_comm_semiring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_46801 (h0 : functor.add_const (function.extfun Type ordered_comm_monoid) environment.implicit_infer_kind) : @has_exists_mul_of_le.{0} (add_comm_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) environment.implicit_infer_kind h0) (add_comm_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_46802 (h0 : add_group (has_sub num)) : is_add_cyclic (has_sub num) := sorry --non-trivial
lemma new_lemma_46803 (h0 : functor.add_const (function.extfun (Type 1) topological_space) (ring Type)) : @sequential_space.{1} Type (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) (ring.{1} Type) h0) Type)  := sorry --non-trivial
lemma new_lemma_46804 (h0 : monoid (ordered_comm_ring real)) : monoid.fg (ordered_comm_ring real) := sorry --non-trivial
lemma new_lemma_46805 (h0 : functor.add_const (function.extfun (Type 1) add_group) linarith.comp) : @is_add_cyclic.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) add_group.{1}) linarith.comp h0) (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_46806 (h0 : functor.add_const (topological_space (semigroup pos)) Type) : @topological_space.separable_space.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (semigroup.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_46807 (h0 : functor.add_const (topological_space (has_Inf pos)) linarith.comp) : @totally_disconnected_space.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_46808 (h0 : functor.add_const (add_group (has_add name)) name) : @is_add_cyclic.{0} (has_add.{0} name) (@functor.add_const.run.{0 0} (add_group.{0} (has_add.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_46809 (h0 : function.extfun Type group) : @normalizer_condition.{0} (normed_comm_ring.{0} (option.{0} unsigned)) (@function.extfun_app.{2 1} Type group.{0} h0 (normed_comm_ring.{0} (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_46810 (h0 : complete_lattice (has_emptyc (has_top (random_gen linarith.ineq)))) : is_compactly_generated (has_emptyc (has_top (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_46811 (h0 : cancel_comm_monoid_with_zero (has_to_string (has_pos_part (ring (has_pos_part pos))))) : unique_factorization_monoid (has_to_string (has_pos_part (ring (has_pos_part pos)))) := sorry --non-trivial
lemma new_lemma_46812 (h1 : list (with_bot to_additive.value_type)) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_46813 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (has_zero.{0} pos) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (has_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_46814 (h0 : functor.add_const (ordered_add_comm_monoid (finset linarith.comp)) (ring linarith.comp)) : @archimedean.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (finset.{0} linarith.comp)) (ring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_46815 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (mul_zero_class.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (mul_zero_class.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_46816 (h0 : functor.add_const (topological_space (comm_group name)) linarith.comp) : @totally_disconnected_space.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_46817 (h0 : functor.add_const (semiring (ring linarith.comp)) name) : @is_noetherian_ring.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (semiring.{0} (ring.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_46818 (h0 : topological_space (normed_comm_ring (semiring congr_arg_kind))) : locally_compact_space (normed_comm_ring (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_46819 (h0 : uniform_space (has_emptyc fun_info)) : separated_space (has_emptyc fun_info) := sorry --non-trivial
lemma new_lemma_46820 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (linear_ordered_cancel_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_cancel_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_46821 (h0 : topological_space (has_star (semiring (semiring (semiring unsigned)))) -> Prop) (h1 : Exists (fun (x : topological_space (has_star (semiring (semiring (semiring unsigned))))), h0 x)) : @totally_disconnected_space.{0} (has_star.{0} (semiring.{0} (semiring.{0} (semiring.{0} unsigned)))) (@classical.some.{1} (topological_space.{0} (has_star.{0} (semiring.{0} (semiring.{0} (semiring.{0} unsigned))))) h0 h1)  := sorry --non-trivial
lemma new_lemma_46822 (h0 : filter (random_gen (random_gen linarith.comp_source))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_46823 (h0 : functor.add_const (topological_space (cancel_monoid unsigned)) linarith.comp) : @normal_space.{0} (cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_46824 (h0 : list (finset (option (option empty)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_46825 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (ordered_comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_46826 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (ring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ring.{0} name))  := sorry --non-trivial
lemma new_lemma_46827 (h0 : functor.add_const (topological_space (has_to_string linarith.comp)) linarith.comp) : @path_connected_space.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_46828 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (canonically_linear_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_linear_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_46829 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (mul_zero_class.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (mul_zero_class.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_46830 (h0 : list (sub_neg_monoid linarith.comp)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_46831 (h0 : group (measurable_space.dynkin_system (semiring unsigned))) : is_cyclic (measurable_space.dynkin_system (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_46832 (h0 : topological_space (add_comm_monoid empty)) : t0_space (add_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_46833 (h0 : cancel_comm_monoid_with_zero (ordered_cancel_add_comm_monoid (option pos))) : unique_factorization_monoid (ordered_cancel_add_comm_monoid (option pos)) := sorry --non-trivial
lemma new_lemma_46834 (h0 : functor.add_const (topological_space (has_zero unsigned)) linarith.comp) : @regular_space.{0} (has_zero.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_46835 (h0 : ring (add_left_cancel_semigroup congr_arg_kind)) : is_principal_ideal_ring (add_left_cancel_semigroup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_46836 (h0 : ring (has_bot (ordered_comm_ring pos))) : rank_condition (has_bot (ordered_comm_ring pos)) := sorry --non-trivial
lemma new_lemma_46837 (h0 : ring (has_emptyc (has_top congr_arg_kind))) : is_domain (has_emptyc (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_46838 (h0 : functor.add_const (complete_lattice (normed_comm_ring name)) (has_add pos)) : @is_compactly_generated.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (normed_comm_ring.{0} name)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_46839 (h0 : functor.add_const (complete_lattice (has_to_string Type)) (cancel_monoid (cancel_monoid Type))) : @is_atomistic.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 1} (complete_lattice.{1} (has_to_string.{1} Type)) (cancel_monoid.{1} (cancel_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_46840 (h0 : functor.add_const (complete_lattice (has_add pos)) num) : @is_compactly_generated.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_add.{0} pos)) num h0)  := sorry --non-trivial
lemma new_lemma_46841 (h0 : group (topological_space (has_nnnorm (has_nnnorm char)))) : is_cyclic (topological_space (has_nnnorm (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_46842 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_add.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_46843 (h0 : has_mem.mem (has_emptyc num) has_emptyc.emptyc) : @add_monoid.fg.{0} (has_emptyc.{0} num) (@finset.pi.empty.{1 0} Type add_monoid.{0} (has_emptyc.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_46844 (h0 : function.extfun (Type 1) (functor.comp group semigroup)) : @normalizer_condition.{1} (semigroup.{1} Type) (@functor.comp.run.{1 1 1} group.{1} semigroup.{1} Type (@function.extfun_app.{3 2} (Type 1) (functor.comp.{1 1 1} group.{1} semigroup.{1}) h0 Type))  := sorry --non-trivial
lemma new_lemma_46845 (h0 : function.extfun (finset Type) (has_mem.mem (has_one congr_arg_kind))) : @separated_space.{0} (has_one.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type uniform_space.{0} (has_one.{0} congr_arg_kind) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_one.{0} congr_arg_kind)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_46846 (h0 : topological_space (comm_semigroup (ordered_comm_monoid real))) : totally_disconnected_space (comm_semigroup (ordered_comm_monoid real)) := sorry --non-trivial
lemma new_lemma_46847 (h0 : functor.add_const (group (has_zero pos)) environment.implicit_infer_kind) : @is_cyclic.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_zero.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_46848 (h0 : topological_space (canonically_ordered_comm_semiring (has_neg name))) : t1_space (canonically_ordered_comm_semiring (has_neg name)) := sorry --non-trivial
lemma new_lemma_46849 (h0 : topological_space (linear_ordered_semiring congr_arg_kind)) : topological_space.separable_space (linear_ordered_semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_46850 (h0 : topological_space (canonically_ordered_comm_semiring (boolean_algebra.core linarith.comp))) : t1_space (canonically_ordered_comm_semiring (boolean_algebra.core linarith.comp)) := sorry --non-trivial
lemma new_lemma_46851 (h0 : cancel_comm_monoid_with_zero (has_neg_part (has_to_string Type))) : unique_factorization_monoid (has_neg_part (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_46852 (h0 : topological_space (finset (has_to_string ennreal))) : totally_disconnected_space (finset (has_to_string ennreal)) := sorry --non-trivial
lemma new_lemma_46853 (h0 : topological_space (with_one fun_info)) : totally_disconnected_space (with_one fun_info) := sorry --non-trivial
lemma new_lemma_46854 (h0 : functor.add_const (topological_space (add_comm_monoid linarith.comp)) linarith.comp) : @normal_space.{0} (add_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_46855 (h0 : topological_space (canonically_ordered_comm_semiring num)) : locally_compact_space (canonically_ordered_comm_semiring num) := sorry --non-trivial
lemma new_lemma_46856 (h1 : ring (has_compl linarith.comp_source)) : rank_condition (has_compl linarith.comp_source) := sorry --non-trivial
lemma new_lemma_46857 (h0 : add_group (has_to_string (option unsigned))) : is_add_cyclic (has_to_string (option unsigned)) := sorry --non-trivial
lemma new_lemma_46858 (h0 : function.extfun (finset Type) (has_mem.mem num)) : @is_cyclic.{0} num (@finset.pi.empty.{1 0} Type group.{0} num (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) num) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_46859 (h0 : topological_space (ring (has_neg_part (has_add unsigned)))) : totally_disconnected_space (ring (has_neg_part (has_add unsigned))) := sorry --non-trivial
lemma new_lemma_46860 (h0 : set (add_comm_semigroup enat -> add_comm_semigroup string.iterator_imp)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_46861 (h0 : uniform_space (has_inter unsigned)) : separated_space (has_inter unsigned) := sorry --non-trivial
lemma new_lemma_46862 (h0 : functor.add_const (function.extfun Type list) linarith.comp) : palindrome (function.extfun_app (functor.add_const.run h0) (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_46863 (h0 : ring (complete_semilattice_Sup (has_top (has_top to_additive.value_type)))) : is_domain (complete_semilattice_Sup (has_top (has_top to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_46864 (h0 : topological_space (group_with_zero (option empty))) : irreducible_space (group_with_zero (option empty)) := sorry --non-trivial
lemma new_lemma_46865 (h0 : function.extfun Type has_mul) (h1 : con unsigned -> con unsigned -> Prop) : transitive h1 := sorry --non-trivial
lemma new_lemma_46866 (h0 : not (ring (normed_field (mul_one_class string_imp)) -> false)) : @is_domain.{0} (normed_field.{0} (mul_one_class.{0} string_imp)) (@classical.by_contradiction'.{1} (ring.{0} (normed_field.{0} (mul_one_class.{0} string_imp))) h0)  := sorry --non-trivial
lemma new_lemma_46867 (h0 : not (filter (has_add fun_info) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_46868 (h0 : functor.add_const (ring (mul_zero_class unsigned)) congr_arg_kind) : @is_principal_ideal_ring.{0} (mul_zero_class.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (mul_zero_class.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_46869 (h0 : topological_space (has_to_string (has_add linarith.comp))) : t0_space (has_to_string (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_46870 (h0 : topological_space (has_emptyc (has_emptyc fun_info))) : t0_space (has_emptyc (has_emptyc fun_info)) := sorry --non-trivial
lemma new_lemma_46871 (h0 : topological_space (has_add (has_pos_part Type))) : discrete_topology (has_add (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_46872 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (linear_ordered_semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_46873 (h0 : functor.add_const (list (cancel_monoid linarith.comp)) linarith.comp) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_46874 (h1 : not (ring (with_zero to_additive.value_type) -> false)) : @strong_rank_condition.{0} (with_zero.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (with_zero.{0} to_additive.value_type)) h1)  := sorry --non-trivial
lemma new_lemma_46875 (h0 : topological_space (has_nnnorm (has_nnnorm char))) : totally_disconnected_space (has_nnnorm (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_46876 (h0 : function.extfun Type topological_space) : @t1_space.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_46877 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @totally_separated_space.{0} (ring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (ring.{0} name))  := sorry --non-trivial
lemma new_lemma_46878 (h0 : topological_space (add_semigroup unsigned)) : normal_space (add_semigroup unsigned) := sorry --non-trivial
lemma new_lemma_46879 (h0 : not (topological_space (has_lt to_additive.value_type) -> false)) : @totally_disconnected_space.{0} (has_lt.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (has_lt.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_46880 (h0 : functor.add_const (complete_lattice (mul_zero_class empty)) unsigned) : @is_atomistic.{0} (mul_zero_class.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (mul_zero_class.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_46881 (h0 : group (has_top (has_top linarith.comp_source))) : group.fg (has_top (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_46882 (h0 : topological_space (linear_ordered_comm_group ennreal)) : irreducible_space (linear_ordered_comm_group ennreal) := sorry --non-trivial
lemma new_lemma_46883 (h0 : ring (complete_distrib_lattice (random_gen (has_nnnorm linarith.ineq)))) : rank_condition (complete_distrib_lattice (random_gen (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_46884 (h0 : topological_space (finset (semigroup Type))) : topological_space.separable_space (finset (semigroup Type)) := sorry --non-trivial
lemma new_lemma_46885 (h0 : list (has_add (has_add pos))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_46886 (h0 : topological_space (topological_space (random_gen fun_info))) : locally_compact_space (topological_space (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_46887 (h0 : finset (linear_ordered_cancel_comm_monoid unsigned)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_46888 (h0 : functor.add_const (add_monoid (has_add pos)) (mul_one_class (has_add (has_neg linarith.comp)))) : @add_monoid.fg.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_add.{0} pos)) (mul_one_class.{0} (has_add.{0} (has_neg.{0} linarith.comp))) h0)  := sorry --non-trivial
lemma new_lemma_46889 (h0 : group (has_neg (has_nndist linarith.comp))) : group.fg (has_neg (has_nndist linarith.comp)) := sorry --non-trivial
lemma new_lemma_46890 (h0 : functor.add_const (functor.add_const (list pos) (has_add linarith.comp)) name) : palindrome (functor.add_const.run (functor.add_const.run h0)) := sorry --non-trivial
lemma new_lemma_46891 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_add_cyclic.{1} (canonically_ordered_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_group.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 add_group.{1}) (canonically_ordered_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_46892 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_Inf pos)) Type) : @unique_factorization_monoid.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 1} (cancel_comm_monoid_with_zero.{0} (has_Inf.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_46893 (h0 : functor.add_const (topological_space (complete_linear_order empty)) congr_arg_kind) : @totally_disconnected_space.{0} (complete_linear_order.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_linear_order.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_46894 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @preconnected_space.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_46895 (h0 : add_group (filter congr_arg_kind)) : is_add_cyclic (filter congr_arg_kind) := sorry --non-trivial
lemma new_lemma_46896 (h0 : functor.add_const (topological_space (add_comm_monoid environment.implicit_infer_kind)) Type) : @path_connected_space.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (add_comm_monoid.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_46897 (h1 : complete_lattice (with_bot string_imp)) : is_atomistic (with_bot string_imp) := sorry --non-trivial
lemma new_lemma_46898 (h0 : add_group (linear_ordered_comm_group_with_zero (mul_one_class ereal))) : is_add_cyclic (linear_ordered_comm_group_with_zero (mul_one_class ereal)) := sorry --non-trivial
lemma new_lemma_46899 (h0 : topological_space (generalized_boolean_algebra (ring (has_add Type)))) : topological_space.separable_space (generalized_boolean_algebra (ring (has_add Type))) := sorry --non-trivial
lemma new_lemma_46900 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @irreducible_space.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (complete_semilattice_Sup.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_46901 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (normed_linear_ordered_group.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_linear_ordered_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_46902 (h0 : functor.add_const (topological_space (has_neg_part unsigned)) pos) : @normal_space.{0} (has_neg_part.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_46903 (h0 : monoid (normed_group unsigned)) : monoid.fg (normed_group unsigned) := sorry --non-trivial
lemma new_lemma_46904 (h1 : has_neg (has_lt linarith.ineq)) (h2 : measurable_space (has_lt linarith.ineq)) : has_measurable_neg (has_lt linarith.ineq) := sorry --non-trivial
lemma new_lemma_46905 (h0 : ring (has_to_string (finset (has_neg (finset environment.implicit_infer_kind))))) : rank_condition (has_to_string (finset (has_neg (finset environment.implicit_infer_kind)))) := sorry --non-trivial
lemma new_lemma_46906 (h0 : functor.add_const (group (has_neg pos)) pos) : @is_simple_group.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_neg.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_46907 (h0 : topological_space (has_add (sub_neg_monoid real))) : preirreducible_space (has_add (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_46908 (h0 : group (add_group (semiring (has_top linarith.comp)))) : is_cyclic (add_group (semiring (has_top linarith.comp))) := sorry --non-trivial
lemma new_lemma_46909 (h0 : functor.comp (functor.comp topological_space canonically_linear_ordered_monoid) with_top nnreal) : @totally_disconnected_space.{0} (canonically_linear_ordered_monoid.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} canonically_linear_ordered_monoid.{0} ennreal (@functor.comp.run.{0 0 0} (functor.comp.{0 0 0} topological_space.{0} canonically_linear_ordered_monoid.{0}) with_top.{0} nnreal h0))  := sorry --non-trivial
lemma new_lemma_46910 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (has_add.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_add.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_46911 (h0 : ordered_comm_monoid (has_add (finset pos))) : has_exists_mul_of_le (has_add (finset pos)) := sorry --non-trivial
lemma new_lemma_46912 (h0 : functor.add_const (function.extfun (Type 1) add_monoid) Type) : @add_monoid.fg.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_monoid.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) add_monoid.{1}) Type h0) (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_46913 (h0 : topological_space (bin_tree (semiring empty))) : loc_path_connected_space (bin_tree (semiring empty)) := sorry --non-trivial
lemma new_lemma_46914 (h0 : add_group (normed_field reducibility_hints)) : is_add_cyclic (normed_field reducibility_hints) := sorry --non-trivial
lemma new_lemma_46915 (h0 : complete_lattice (comm_group Type)) : is_compactly_generated (comm_group Type) := sorry --non-trivial
lemma new_lemma_46916 (h0 : group (with_one to_additive.value_type)) : normalizer_condition (with_one to_additive.value_type) := sorry --non-trivial
lemma new_lemma_46917 (h0 : list (has_nnnorm (has_nnnorm (has_ssubset linarith.ineq)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_46918 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (linear_ordered_comm_group.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_group.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_46919 (h0 : functor.add_const (add_group (linear_order empty)) (semiring (semiring empty))) : @is_add_cyclic.{0} (linear_order.{0} empty) (@functor.add_const.run.{0 0} (add_group.{0} (linear_order.{0} empty)) (semiring.{0} (semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_46920 (h0 : functor.comp cancel_comm_monoid_with_zero has_nndist name) : @unique_factorization_monoid.{0} (has_nndist.{0} name) (@functor.comp.run.{0 0 0} cancel_comm_monoid_with_zero.{0} has_nndist.{0} name (@functor.comp.run.{0 0 0} cancel_comm_monoid_with_zero.{0} has_nndist.{0} name (@functor.comp.run.{0 0 0} cancel_comm_monoid_with_zero.{0} has_nndist.{0} name (@functor.comp.run.{0 0 0} cancel_comm_monoid_with_zero.{0} has_nndist.{0} name (@functor.comp.run.{0 0 0} cancel_comm_monoid_with_zero.{0} has_nndist.{0} name (@functor.comp.run.{0 0 0} cancel_comm_monoid_with_zero.{0} has_nndist.{0} name (@functor.comp.run.{0 0 0} cancel_comm_monoid_with_zero.{0} has_nndist.{0} name (@functor.comp.run.{0 0 0} cancel_comm_monoid_with_zero.{0} has_nndist.{0} name (@functor.comp.run.{0 0 0} cancel_comm_monoid_with_zero.{0} has_nndist.{0} name (@functor.comp.run.{0 0 0} cancel_comm_monoid_with_zero.{0} has_nndist.{0} name (@functor.comp.run.{0 0 0} cancel_comm_monoid_with_zero.{0} has_nndist.{0} name (@functor.comp.run.{0 0 0} cancel_comm_monoid_with_zero.{0} has_nndist.{0} name (@functor.comp.run.{0 0 0} cancel_comm_monoid_with_zero.{0} has_nndist.{0} name (@functor.comp.run.{0 0 0} cancel_comm_monoid_with_zero.{0} has_nndist.{0} name (@functor.comp.run.{0 0 0} cancel_comm_monoid_with_zero.{0} has_nndist.{0} name (@functor.comp.run.{0 0 0} cancel_comm_monoid_with_zero.{0} has_nndist.{0} name (@functor.comp.run.{0 0 0} cancel_comm_monoid_with_zero.{0} has_nndist.{0} name (@functor.comp.run.{0 0 0} cancel_comm_monoid_with_zero.{0} has_nndist.{0} name (@functor.comp.run.{0 0 0} cancel_comm_monoid_with_zero.{0} has_nndist.{0} name (@functor.comp.run.{0 0 0} cancel_comm_monoid_with_zero.{0} has_nndist.{0} name (@functor.comp.run.{0 0 0} cancel_comm_monoid_with_zero.{0} has_nndist.{0} name (@functor.comp.run.{0 0 0} cancel_comm_monoid_with_zero.{0} has_nndist.{0} name (@functor.comp.run.{0 0 0} cancel_comm_monoid_with_zero.{0} has_nndist.{0} name (@functor.comp.run.{0 0 0} cancel_comm_monoid_with_zero.{0} has_nndist.{0} name (@functor.comp.run.{0 0 0} cancel_comm_monoid_with_zero.{0} has_nndist.{0} name (@functor.comp.run.{0 0 0} cancel_comm_monoid_with_zero.{0} has_nndist.{0} name (@functor.comp.run.{0 0 0} cancel_comm_monoid_with_zero.{0} has_nndist.{0} name (@functor.comp.run.{0 0 0} cancel_comm_monoid_with_zero.{0} has_nndist.{0} name (@functor.comp.run.{0 0 0} cancel_comm_monoid_with_zero.{0} has_nndist.{0} name (@functor.comp.run.{0 0 0} cancel_comm_monoid_with_zero.{0} has_nndist.{0} name h0))))))))))))))))))))))))))))))  := sorry --non-trivial
lemma new_lemma_46921 (h0 : functor.add_const (ring (canonically_ordered_monoid pos)) name) : @rank_condition.{0} (canonically_ordered_monoid.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (canonically_ordered_monoid.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_46922 (h0 : add_group (has_neg (has_add (has_neg_part (has_add pos))))) : is_add_cyclic (has_neg (has_add (has_neg_part (has_add pos)))) := sorry --non-trivial
lemma new_lemma_46923 (h2 : complete_lattice (distrib_lattice linarith.comp_source)) : complete_lattice.is_Sup_finite_compact (distrib_lattice linarith.comp_source) := sorry --non-trivial
lemma new_lemma_46924 (h0 : topological_space (has_div (mul_one_class (mul_one_class linarith.ineq)))) : totally_disconnected_space (has_div (mul_one_class (mul_one_class linarith.ineq))) := sorry --non-trivial
lemma new_lemma_46925 (h0 : ring (add_cancel_comm_monoid (random_gen (has_nnnorm (has_nnnorm linarith.ineq))))) : rank_condition (add_cancel_comm_monoid (random_gen (has_nnnorm (has_nnnorm linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_46926 (h0 : not (complete_lattice (has_top fun_info) -> false)) : @is_atomistic.{0} (has_top.{0} fun_info) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_top.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_46927 (h0 : functor.add_const (list (normed_comm_ring unsigned)) Type) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_46928 (h0 : functor.add_const (topological_space (add_group congr_arg_kind)) unsigned) : @totally_separated_space.{0} (add_group.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (add_group.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_46929 (h0 : topological_space (ring (has_to_string unsigned))) : t1_space (ring (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_46930 (h0 : topological_space (mul_zero_class (has_add Type))) : sequential_space (mul_zero_class (has_add Type)) := sorry --non-trivial
lemma new_lemma_46931 (h0 : functor.add_const (uniform_space (semigroup Type)) linarith.comp) : @complete_space.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (semigroup.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_46932 (h0 : group (boolean_algebra.core Type)) : is_simple_group (boolean_algebra.core Type) := sorry --non-trivial
lemma new_lemma_46933 (h0 : fin has_zero.zero) : locally_compact_space ennreal := sorry --non-trivial
lemma new_lemma_46934 (h0 : complete_lattice (uniform_space (mul_one_class string_imp))) : complete_lattice.is_Sup_finite_compact (uniform_space (mul_one_class string_imp)) := sorry --non-trivial
lemma new_lemma_46935 (h0 : functor.add_const (add_group (comm_group Type)) (has_neg (has_neg linarith.comp))) : @is_add_cyclic.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (add_group.{1} (comm_group.{1} Type)) (has_neg.{0} (has_neg.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_46936 (h0 : functor.add_const (group (has_nndist empty)) congr_arg_kind) : @group.fg.{0} (has_nndist.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (has_nndist.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_46937 (h0 : functor.add_const (topological_space (finset Type)) ennreal) : @irreducible_space.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (finset.{1} Type)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_46938 (h0 : topological_space (cancel_monoid (has_neg_part Type))) : regular_space (cancel_monoid (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_46939 (h0 : topological_space (add_group (has_norm unsigned))) : preirreducible_space (add_group (has_norm unsigned)) := sorry --non-trivial
lemma new_lemma_46940 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (add_group.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (add_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_46941 (h0 : functor.add_const (complete_lattice (has_to_string environment.implicit_infer_kind)) linarith.comp) : @is_compactly_generated.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_to_string.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_46942 (h0 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} (distrib_lattice.{0} fun_info) (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h0) (distrib_lattice.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_46943 (h0 : ring (has_norm (has_top (has_top (semiring (semiring congr_arg_kind)))))) : strong_rank_condition (has_norm (has_top (has_top (semiring (semiring congr_arg_kind))))) := sorry --non-trivial
lemma new_lemma_46944 (h0 : functor.add_const (group (add_cancel_monoid unsigned)) Type) : @is_simple_group.{0} (add_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 1} (group.{0} (add_cancel_monoid.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_46945 (h0 : not (ring (metric_space linarith.comp) -> false)) : @rank_condition.{0} (metric_space.{0} linarith.comp) (@classical.by_contradiction'.{1} (ring.{0} (metric_space.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_46946 (h1 : function.extfun Type topological_space) : @irreducible_space.{0} (has_top.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (has_top.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_46947 (h0 : topological_space (normed_comm_ring pos)) : topological_space.separable_space (normed_comm_ring pos) := sorry --non-trivial
lemma new_lemma_46948 (h0 : functor.add_const (prod (is_R_or_C empty) (is_R_or_C empty)) unsigned) : id_rel (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_46949 (h0 : group (has_to_string (has_neg_part (add_comm_monoid Type)))) : normalizer_condition (has_to_string (has_neg_part (add_comm_monoid Type))) := sorry --non-trivial
lemma new_lemma_46950 (h0 : has_mem.mem to_additive.value_type has_emptyc.emptyc) : @complete_space.{0} to_additive.value_type (@finset.pi.empty.{1 0} Type uniform_space.{0} to_additive.value_type h0)  := sorry --non-trivial
lemma new_lemma_46951 (h0 : complete_lattice (has_to_string name)) : complete_lattice.is_Sup_finite_compact (has_to_string name) := sorry --non-trivial
lemma new_lemma_46952 (h0 : topological_space (non_assoc_semiring unsigned)) : t1_space (non_assoc_semiring unsigned) := sorry --non-trivial
lemma new_lemma_46953 (h0 : topological_space (has_bot (has_Inf (ordered_comm_monoid real)))) : preirreducible_space (has_bot (has_Inf (ordered_comm_monoid real))) := sorry --non-trivial
lemma new_lemma_46954 (h0 : ring (has_bot (option (option (option (option unsigned)))))) : is_principal_ideal_ring (has_bot (option (option (option (option unsigned))))) := sorry --non-trivial
lemma new_lemma_46955 (h0 : topological_space (has_compl (random_gen linarith.ineq))) : path_connected_space (has_compl (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_46956 (h0 : functor.add_const (complete_lattice Type) (finset (has_pos_part linarith.comp))) : @is_compactly_generated.{1} Type (@functor.add_const.run.{1 0} (complete_lattice.{1} Type) (finset.{0} (has_pos_part.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_46957 (h0 : functor.add_const (topological_space (boolean_algebra name)) name) : @discrete_topology.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_46958 (h0 : functor.add_const (ring (complete_distrib_lattice empty)) empty) : @is_principal_ideal_ring.{0} (complete_distrib_lattice.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (complete_distrib_lattice.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_46959 (h0 : functor.add_const (functor.add_const (function.extfun Type monoid) name) linarith.comp) : @monoid.fg.{0} (boolean_algebra.core.{0} name) (@function.extfun_app.{2 1} Type monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type monoid.{0}) name (@functor.add_const.run.{1 0} (functor.add_const.{1 0} (function.extfun.{2 1} Type monoid.{0}) name) linarith.comp h0)) (boolean_algebra.core.{0} name))  := sorry --non-trivial
lemma new_lemma_46960 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @locally_compact_space.{1} (complete_distrib_lattice.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (complete_distrib_lattice.{1} Type))  := sorry --non-trivial
lemma new_lemma_46961 (h1 : ring (fintype (random_gen char))) : strong_rank_condition (fintype (random_gen char)) := sorry --non-trivial
lemma new_lemma_46962 (h0 : topological_space (measure_theory.measure_space (semiring empty))) : normal_space (measure_theory.measure_space (semiring empty)) := sorry --non-trivial
lemma new_lemma_46963 (h0 : function.extfun Type (functor.comp cancel_comm_monoid_with_zero pseudo_metric_space)) : @unique_factorization_monoid.{0} (pseudo_metric_space.{0} (boolean_algebra.core.{0} name)) (@functor.comp.run.{0 0 0} cancel_comm_monoid_with_zero.{0} pseudo_metric_space.{0} (boolean_algebra.core.{0} name) (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} cancel_comm_monoid_with_zero.{0} pseudo_metric_space.{0}) h0 (boolean_algebra.core.{0} name)))  := sorry --non-trivial
lemma new_lemma_46964 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (measurable_space.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (measurable_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_46965 (h0 : functor.comp topological_space ring Type) : @loc_path_connected_space.{1} (ring.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} ring.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_46966 (h0 : linear_ordered_field (option num) -> linear_ordered_field (option num) -> Prop) : reflexive h0 := sorry --non-trivial
lemma new_lemma_46967 (h1 : topological_space (nondiscrete_normed_field (mul_one_class linarith.ineq))) (h2 : add_group (nondiscrete_normed_field (mul_one_class linarith.ineq))) : topological_add_group (nondiscrete_normed_field (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_46968 (h0 : ring (dlist (random_gen (random_gen linarith.ineq)))) : rank_condition (dlist (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_46969 (h0 : topological_space (random_gen (random_gen (mul_one_class reducibility_hints)))) : totally_disconnected_space (random_gen (random_gen (mul_one_class reducibility_hints))) := sorry --non-trivial
lemma new_lemma_46970 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @totally_disconnected_space.{0} (normed_group.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) topological_space.{0}) (normed_group.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_46971 (h0 : Prop) : not h0 := sorry --non-trivial
lemma new_lemma_46972 (h0 : functor.add_const (ring (ordered_comm_ring name)) linarith.comp) : @rank_condition.{0} (ordered_comm_ring.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (ordered_comm_ring.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_46973 (h0 : group (has_Inf (has_neg (has_neg (has_neg linarith.comp))))) : group.fg (has_Inf (has_neg (has_neg (has_neg linarith.comp)))) := sorry --non-trivial
lemma new_lemma_46974 (h0 : topological_space (has_Inf (has_add Type))) : preconnected_space (has_Inf (has_add Type)) := sorry --non-trivial
lemma new_lemma_46975 (h0 : list (has_Inf (finset (has_Inf linarith.comp)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_46976 (h0 : functor.add_const (topological_space (finset environment.implicit_infer_kind)) Type) : @locally_compact_space.{0} (finset.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (finset.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_46977 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (semigroup.{0} ennreal) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (semigroup.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_46978 (h0 : functor.add_const (list (option empty)) congr_arg_kind) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_46979 (h1 : not (topological_space (random_gen char) -> false)) : @t0_space.{0} (random_gen.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (random_gen.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_46980 (h0 : functor.add_const (semiring (comm_group unsigned)) linarith.comp) : @is_noetherian_ring.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (semiring.{0} (comm_group.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_46981 (h0 : ordered_add_comm_monoid (has_Inf (ring name))) : archimedean (has_Inf (ring name)) := sorry --non-trivial
lemma new_lemma_46982 (h0 : has_mul (monoid_with_zero num)) (h1 : con (monoid_with_zero num)) (h2 : topological_space (con.quotient h1)) : totally_disconnected_space (con.quotient h1) := sorry --non-trivial
lemma new_lemma_46983 (h0 : ring (has_zero (comm_group pos))) : is_domain (has_zero (comm_group pos)) := sorry --non-trivial
lemma new_lemma_46984 (h0 : not (group (has_ssubset (random_gen linarith.ineq)) -> false)) : @is_cyclic.{0} (has_ssubset.{0} (random_gen.{0} linarith.ineq)) (@classical.by_contradiction'.{1} (group.{0} (has_ssubset.{0} (random_gen.{0} linarith.ineq))) h0)  := sorry --non-trivial
lemma new_lemma_46985 (h0 : monoid (has_neg_part (has_add (has_add environment.implicit_infer_kind)))) : monoid.fg (has_neg_part (has_add (has_add environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_46986 (h0 : functor.add_const (ring (has_bot unsigned)) (option (option empty))) : @strong_rank_condition.{0} (has_bot.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (has_bot.{0} unsigned)) (option.{0} (option.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_46987 (h5 : ring (comm_ring linarith.comp_source)) : rank_condition (comm_ring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_46988 (h0 : complete_lattice (has_norm (random_gen (has_norm linarith.comp_source)))) : is_atomistic (has_norm (random_gen (has_norm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_46989 (h0 : filter (normed_comm_ring (ring (has_add (has_add (finset (has_add (has_add (has_add (has_add pos)))))))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_46990 (h0 : ring (has_top (has_nnnorm (random_gen string_imp)))) : is_domain (has_top (has_nnnorm (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_46991 (h0 : topological_space to_additive.value_type -> Prop) (h1 : Exists (fun (x : topological_space to_additive.value_type), h0 x)) : @path_connected_space.{0} to_additive.value_type (@classical.some.{1} (topological_space.{0} to_additive.value_type) h0 h1)  := sorry --non-trivial
lemma new_lemma_46992 (h0 : functor.add_const (monoid (has_neg linarith.comp)) (ring Type)) : @monoid.fg.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 1} (monoid.{0} (has_neg.{0} linarith.comp)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_46993 (h0 : functor.add_const (functor.add_const (monoid unsigned) pos) (finset (ring (ring Type)))) : @monoid.fg.{0} unsigned (@functor.add_const.run.{0 0} (monoid.{0} unsigned) pos (@functor.add_const.run.{0 1} (functor.add_const.{0 0} (monoid.{0} unsigned) pos) (finset.{1} (ring.{1} (ring.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_46994 (h0 : functor.add_const (topological_space (complete_distrib_lattice unsigned)) name) : @loc_path_connected_space.{0} (complete_distrib_lattice.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_46995 (h0 : functor.add_const (topological_space (cancel_monoid unsigned)) unsigned) : @preirreducible_space.{0} (cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_46996 (h0 : topological_space (add_cancel_monoid (has_pos_part (ring linarith.comp)))) : loc_path_connected_space (add_cancel_monoid (has_pos_part (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_46997 (h0 : topological_space (id (semiring unsigned))) : discrete_topology (id (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_46998 (h0 : topological_space (has_add (ring name))) : path_connected_space (has_add (ring name)) := sorry --non-trivial
lemma new_lemma_46999 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_nnnorm.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_nnnorm.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_47000 (h0 : add_group (has_nnnorm (group_with_zero string_imp))) : is_add_cyclic (has_nnnorm (group_with_zero string_imp)) := sorry --non-trivial
lemma new_lemma_47001 (h0 : topological_space (with_bot linarith.comp)) : discrete_topology (with_bot linarith.comp) := sorry --non-trivial
lemma new_lemma_47002 (h0 : ring (semigroup (has_add environment.implicit_infer_kind))) : rank_condition (semigroup (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_47003 (h0 : functor.add_const (monoid (mul_zero_class num)) empty) : @monoid.fg.{0} (mul_zero_class.{0} num) (@functor.add_const.run.{0 0} (monoid.{0} (mul_zero_class.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_47004 (h0 : add_monoid (with_bot (semiring (semiring (semiring empty))))) : add_monoid.fg (with_bot (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_47005 (h0 : fin has_zero.zero) : @is_compactly_generated.{0} (finset.{0} name) (@matrix.vec_empty.{0} (complete_lattice.{0} (finset.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_47006 (h0 : not (function.extfun Type monoid -> false)) : @monoid.fg.{0} (has_top.{0} fun_info) (@function.extfun_app.{2 1} Type monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type monoid.{0}) h0) (has_top.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_47007 (h0 : topological_space (add_cancel_monoid (comm_group unsigned))) : path_connected_space (add_cancel_monoid (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_47008 (h0 : function.extfun (Type 1) uniform_space) : @complete_space.{1} (complete_distrib_lattice.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} h0 (complete_distrib_lattice.{1} Type))  := sorry --non-trivial
lemma new_lemma_47009 (h0 : complete_lattice (add_comm_semigroup (tree (ordered_ring linarith.ineq)))) : complete_lattice.is_Sup_finite_compact (add_comm_semigroup (tree (ordered_ring linarith.ineq))) := sorry --non-trivial
lemma new_lemma_47010 (h0 : functor.comp topological_space mul_zero_class ennreal) : @totally_separated_space.{0} (mul_zero_class.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} ennreal)) name (@functor.comp.run.{0 0 0} topological_space.{0} mul_zero_class.{0} ennreal h0))  := sorry --non-trivial
lemma new_lemma_47011 (h0 : not (group (has_emptyc num) -> false)) : @normalizer_condition.{0} (has_emptyc.{0} num) (@classical.by_contradiction'.{1} (group.{0} (has_emptyc.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_47012 (h0 : ring (uniform_space (mul_one_class linarith.ineq))) : strong_rank_condition (uniform_space (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_47013 (h0 : topological_space (preorder unsigned)) : locally_compact_space (preorder unsigned) := sorry --non-trivial
lemma new_lemma_47014 (h0 : ring (mul_zero_class (normed_comm_ring Type))) : strong_rank_condition (mul_zero_class (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_47015 (h0 : functor.add_const (complete_lattice (semigroup pos)) Type) : @is_atomistic.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 1} (complete_lattice.{0} (semigroup.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_47016 (h0 : ring (normed_group (semiring empty))) : strong_rank_condition (normed_group (semiring empty)) := sorry --non-trivial
lemma new_lemma_47017 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_ordered_comm_semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_47018 (h0 : list (linear_ordered_comm_group (option (option ennreal)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_47019 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_47020 (h0 : topological_space (canonically_ordered_comm_semiring (has_add name))) : preconnected_space (canonically_ordered_comm_semiring (has_add name)) := sorry --non-trivial
lemma new_lemma_47021 (h0 : topological_space (semi_normed_comm_ring linarith.ineq)) : path_connected_space (semi_normed_comm_ring linarith.ineq) := sorry --non-trivial
lemma new_lemma_47022 (h0 : functor.add_const (complete_lattice (has_to_string name)) linarith.comp) : @is_compactly_generated.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_to_string.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_47023 (h0 : fin has_zero.zero) : @complete_lattice.is_Sup_finite_compact.{0} (ordered_comm_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (complete_lattice.{0} (ordered_comm_monoid.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_47024 (h0 : topological_space (plift (semiring empty))) : totally_disconnected_space (plift (semiring empty)) := sorry --non-trivial
lemma new_lemma_47025 (h0 : prod (left_cancel_semigroup empty) (left_cancel_semigroup empty)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_47026 (h0 : function.extfun Type (functor.add_const (topological_space znum))) : @locally_compact_space.{0} znum (@functor.add_const.run.{0 0} (topological_space.{0} znum) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} znum)) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_47027 (h0 : functor.comp ordered_add_comm_monoid has_to_string environment.implicit_infer_kind) : @archimedean.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} ordered_add_comm_monoid.{0} has_to_string.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_47028 (h0 : function.extfun Type ring) : @is_domain.{0} (normed_lattice_add_comm_group.{0} real) (@function.extfun_app.{2 1} Type ring.{0} h0 (normed_lattice_add_comm_group.{0} real))  := sorry --non-trivial
lemma new_lemma_47029 (h0 : functor.add_const (topological_space (has_neg_part name)) pos) : @locally_compact_space.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_47030 (h0 : topological_space (boolean_algebra (boolean_algebra.core environment.implicit_infer_kind))) : normal_space (boolean_algebra (boolean_algebra.core environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_47031 (h0 : topological_space (add_left_cancel_semigroup (option (option unsigned)))) : irreducible_space (add_left_cancel_semigroup (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_47032 (h0 : topological_space (add_cancel_monoid (add_cancel_monoid linarith.comp))) : t0_space (add_cancel_monoid (add_cancel_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_47033 (h0 : topological_space (finset (has_nndist linarith.comp))) : preconnected_space (finset (has_nndist linarith.comp)) := sorry --non-trivial
lemma new_lemma_47034 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_cyclic.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 group.{1}) (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_47035 (h0 : functor.comp uniform_space comm_group environment.implicit_infer_kind) : @separated_space.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} uniform_space.{0} comm_group.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_47036 (h0 : not (complete_lattice (has_star num) -> false)) : @is_compactly_generated.{0} (has_star.{0} num) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_star.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_47037 (h0 : ring (has_div (mul_one_class string.iterator_imp))) : rank_condition (has_div (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_47038 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (partial_order.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (partial_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_47039 (h0 : topological_space (finset (option (option unsigned)))) : irreducible_space (finset (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_47040 (h1 : not (monoid (random_gen string_imp) -> false)) : @monoid.fg.{0} (random_gen.{0} string_imp) (@classical.by_contradiction'.{1} (monoid.{0} (random_gen.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_47041 (h0 : functor.add_const (functor.add_const (finset Type) linarith.comp) linarith.comp) : finset.nonempty (functor.add_const.run (functor.add_const.run h0)) := sorry --non-trivial
lemma new_lemma_47042 (h0 : ring (measurable_space (has_norm (has_norm (normed_ring linarith.comp))))) : strong_rank_condition (measurable_space (has_norm (has_norm (normed_ring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_47043 (h1 : has_mem.mem (has_top fun_info) has_emptyc.emptyc) : @rank_condition.{0} (has_top.{0} fun_info) (@finset.pi.empty.{1 0} Type ring.{0} (has_top.{0} fun_info) h1)  := sorry --non-trivial
lemma new_lemma_47044 (h0 : topological_space (has_div string_imp)) (h1 : preorder (has_div string_imp)) : order_closed_topology (has_div string_imp) := sorry --non-trivial
lemma new_lemma_47045 (h0 : functor.add_const (topological_space (finset environment.implicit_infer_kind)) linarith.comp) : @totally_disconnected_space.{0} (finset.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_47046 (h0 : topological_space (ordered_comm_ring (has_Inf (has_pos_part pos)))) : preirreducible_space (ordered_comm_ring (has_Inf (has_pos_part pos))) := sorry --non-trivial
lemma new_lemma_47047 (h0 : ring (add_right_cancel_monoid (has_top empty))) : is_domain (add_right_cancel_monoid (has_top empty)) := sorry --non-trivial
lemma new_lemma_47048 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (has_bot.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_bot.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_47049 (h0 : functor.add_const (ring (linear_ordered_field pos)) pos) : @is_domain.{0} (linear_ordered_field.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (linear_ordered_field.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_47050 (h0 : uniform_space (complete_semilattice_Sup unsigned)) : complete_space (complete_semilattice_Sup unsigned) := sorry --non-trivial
lemma new_lemma_47051 (h0 : not (cancel_comm_monoid_with_zero (id unsigned) -> false)) : @unique_factorization_monoid.{0} (@id.{2} Type unsigned) (@classical.by_contradiction'.{1} (cancel_comm_monoid_with_zero.{0} (@id.{2} Type unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_47052 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_nndist.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_nndist.{0} name))  := sorry --non-trivial
lemma new_lemma_47053 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (canonically_linear_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_linear_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_47054 (h0 : fin has_zero.zero) : @is_simple_group.{0} (generalized_boolean_algebra.{0} pos) (@matrix.vec_empty.{0} (group.{0} (generalized_boolean_algebra.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_47055 (h0 : field (semi_normed_comm_ring char)) : is_alg_closed (semi_normed_comm_ring char) := sorry --non-trivial
lemma new_lemma_47056 (h0 : has_lt (mul_one_class (mul_one_class char))) : no_max_order (mul_one_class (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_47057 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (linear_ordered_field.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (linear_ordered_field.{0} num))  := sorry --non-trivial
lemma new_lemma_47058 (h0 : not (multiset (distrib (has_ssubset fun_info)) -> false)) (h1 : multiset (distrib (has_ssubset fun_info))) : multiset.disjoint (classical.by_contradiction' h0) h1 := sorry --non-trivial
lemma new_lemma_47059 (h0 : functor.add_const (group (add_cancel_monoid Type)) pos) : @is_simple_group.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (add_cancel_monoid.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_47060 (h0 : mul_one_class fun_info -> mul_one_class fun_info -> Prop) (h1 : set (mul_one_class fun_info)) : directed_on h0 h1 := sorry --non-trivial
lemma new_lemma_47061 (h0 : fun_info -> fun_info -> Prop) : is_trans fun_info h0 := sorry --non-trivial
lemma new_lemma_47062 (h1 : ring (distrib_lattice fun_info)) : strong_rank_condition (distrib_lattice fun_info) := sorry --non-trivial
lemma new_lemma_47063 (h0 : functor.add_const (topological_space (has_add unsigned)) pos) : @topological_space.separable_space.{0} (has_add.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_47064 (h0 : complete_lattice (sub_neg_monoid (has_add linarith.comp))) : is_compactly_generated (sub_neg_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_47065 (h0 : complete_lattice (comm_monoid (option (option (option empty))))) : complete_lattice.is_Sup_finite_compact (comm_monoid (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_47066 (h0 : functor.add_const (topological_space (has_zero pos)) Type) : @discrete_topology.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_zero.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_47067 (h0 : functor.add_const (topological_space (generalized_boolean_algebra name)) pos) : @sequential_space.{0} (generalized_boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_47068 (h0 : topological_space (partial_order (semiring (semiring (semiring num))))) : irreducible_space (partial_order (semiring (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_47069 (h0 : ring (add_comm_monoid (finset (has_to_string (add_comm_monoid pos))))) : is_domain (add_comm_monoid (finset (has_to_string (add_comm_monoid pos)))) := sorry --non-trivial
lemma new_lemma_47070 (h0 : not (topological_space (linear_ordered_semiring num) -> false)) : @totally_separated_space.{0} (linear_ordered_semiring.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_semiring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_47071 (h0 : complete_lattice (simple_graph (mul_one_class char))) : is_compactly_generated (simple_graph (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_47072 (h0 : add_group (has_to_string unsigned)) : is_add_cyclic (has_to_string unsigned) := sorry --non-trivial
lemma new_lemma_47073 (h0 : functor.add_const (complete_lattice (finset Type)) (mul_zero_class pos)) : @complete_lattice.is_Sup_finite_compact.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (finset.{1} Type)) (mul_zero_class.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_47074 (h0 : topological_space (has_bot (ordered_comm_monoid (has_neg Type)))) : normal_space (has_bot (ordered_comm_monoid (has_neg Type))) := sorry --non-trivial
lemma new_lemma_47075 (h0 : add_monoid (has_pos_part (sub_neg_monoid Type))) : add_monoid.fg (has_pos_part (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_47076 (h0 : functor.add_const (topological_space (boolean_algebra pos)) environment.implicit_infer_kind) : @t0_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_47077 (h0 : nat) (h1 h2 : fin h0) (h3 : setoid (fin.le h1 h2)) : id (quotient h3) := sorry --non-trivial
lemma new_lemma_47078 (h0 : functor.add_const (topological_space (has_Inf Type)) name) : @loc_path_connected_space.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_Inf.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_47079 (h1 : function.extfun Type monoid) : @monoid.fg.{0} (semiring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type monoid.{0} h1 (semiring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_47080 (h1 : ring (has_top fun_info)) : rank_condition (has_top fun_info) := sorry --non-trivial
lemma new_lemma_47081 (h0 : functor.add_const (filter (semigroup environment.implicit_infer_kind)) (finset Type)) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_47082 (h0 : topological_space (pseudo_metric_space (option (option empty)))) : t1_space (pseudo_metric_space (option (option empty))) := sorry --non-trivial
lemma new_lemma_47083 (h0 : list (has_norm (has_inv (has_top (has_inv linarith.comp_source))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_47084 (h0 : topological_space (has_lt (has_union std_gen))) : path_connected_space (has_lt (has_union std_gen)) := sorry --non-trivial
lemma new_lemma_47085 (h0 : topological_space (has_to_string (has_add (has_neg_part Type)))) : irreducible_space (has_to_string (has_add (has_neg_part Type))) := sorry --non-trivial
lemma new_lemma_47086 (h0 : functor.add_const (cancel_comm_monoid_with_zero (linear_order empty)) unsigned) : @unique_factorization_monoid.{0} (linear_order.{0} empty) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (linear_order.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_47087 (h0 : ring (generalized_boolean_algebra (finset pos))) : strong_rank_condition (generalized_boolean_algebra (finset pos)) := sorry --non-trivial
lemma new_lemma_47088 (h0 : group (add_comm_monoid (has_add (ring linarith.comp)))) : is_simple_group (add_comm_monoid (has_add (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_47089 (h0 : function.extfun Type group) : @group.fg.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} h0 (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_47090 (h0 : function.extfun (finset Type) (has_mem.mem (semiring fun_info))) : @strong_rank_condition.{0} (semiring.{0} fun_info) (@finset.pi.empty.{1 0} Type ring.{0} (semiring.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_47091 (h0 : topological_space (uniform_space (has_lt char))) : path_connected_space (uniform_space (has_lt char)) := sorry --non-trivial
lemma new_lemma_47092 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (option.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (option.{0} pos))  := sorry --non-trivial
lemma new_lemma_47093 (h0 : topological_space (complete_semilattice_Sup (semiring unsigned))) : locally_compact_space (complete_semilattice_Sup (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_47094 (h0 : function.extfun nat fin) : @is_add_cyclic.{0} (has_bot.{0} pos) (@matrix.vec_empty.{0} (add_group.{0} (has_bot.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_47095 (h0 : functor.add_const (topological_space (group_with_zero ennreal)) num) : @loc_path_connected_space.{0} (group_with_zero.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (group_with_zero.{0} ennreal)) num h0)  := sorry --non-trivial
lemma new_lemma_47096 (h0 : complete_lattice (linear_ordered_add_comm_group to_additive.value_type)) : is_compactly_generated (linear_ordered_add_comm_group to_additive.value_type) := sorry --non-trivial
lemma new_lemma_47097 (h0 : add_group (has_zero (has_neg_part (has_neg_part name)))) : is_add_cyclic (has_zero (has_neg_part (has_neg_part name))) := sorry --non-trivial
lemma new_lemma_47098 (h0 : topological_space (has_nndist (comm_group (has_to_string unsigned)))) : loc_path_connected_space (has_nndist (comm_group (has_to_string unsigned))) := sorry --non-trivial
lemma new_lemma_47099 (h0 : topological_space (has_top (random_gen (random_gen (with_bot to_additive.value_type))))) : locally_compact_space (has_top (random_gen (random_gen (with_bot to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_47100 (h0 : generalized_boolean_algebra real -> generalized_boolean_algebra real -> generalized_boolean_algebra real) : left_cancelative h0 := sorry --non-trivial
lemma new_lemma_47101 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (add_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_47102 (h0 : function.extfun Type group) : @normalizer_condition.{0} (as_linear_order.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (as_linear_order.{0} num))  := sorry --non-trivial
lemma new_lemma_47103 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} (distrib_lattice.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (distrib_lattice.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_47104 (h0 : ring (linear_ordered_comm_group_with_zero (mul_one_class char))) : rank_condition (linear_ordered_comm_group_with_zero (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_47105 (h0 : topological_space (has_zero linarith.comp)) : irreducible_space (has_zero linarith.comp) := sorry --non-trivial
lemma new_lemma_47106 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (cancel_monoid.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (cancel_monoid.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_47107 (h0 : ordered_add_comm_monoid (linear_ordered_comm_group ennreal)) : archimedean (linear_ordered_comm_group ennreal) := sorry --non-trivial
lemma new_lemma_47108 (h0 : list (has_to_string (ring pos))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_47109 (h0 : group (boolean_algebra pos)) : normalizer_condition (boolean_algebra pos) := sorry --non-trivial
lemma new_lemma_47110 (h0 : functor.comp semiring has_add (has_nndist ennreal)) : @is_noetherian_ring.{0} (has_add.{0} (has_nndist.{0} ennreal)) (@functor.comp.run.{0 0 0} semiring.{0} has_add.{0} (has_nndist.{0} ennreal) h0)  := sorry --non-trivial
lemma new_lemma_47111 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (complete_semilattice_Sup char)) := sorry --non-trivial
lemma new_lemma_47112 (h0 : group (semiring (semiring congr_arg_kind))) : group.fg (semiring (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_47113 (h0 : not (function.extfun Type topological_space -> false)) : @totally_separated_space.{0} (has_top.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_top.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_47114 (h0 : functor.comp topological_space pseudo_metric_space name) : @totally_disconnected_space.{0} (pseudo_metric_space.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} pseudo_metric_space.{0} name h0)  := sorry --non-trivial
lemma new_lemma_47115 (h0 : not (complete_lattice (has_append char) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_append.{0} char) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_append.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_47116 (h0 : function.extfun (finset Type -> Prop) (function.extfun (finset Type))) : @totally_disconnected_space.{0} congr_arg_kind (@finset.pi.empty.{1 0} Type topological_space.{0} congr_arg_kind (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) congr_arg_kind) (@function.extfun_app.{2 0} (finset.{1} Type → Prop) (function.extfun.{2 0} (finset.{1} Type)) h0 (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) congr_arg_kind)) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_47117 (h0 : topological_space (cancel_monoid (option unsigned))) : totally_separated_space (cancel_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_47118 (h0 : ordered_comm_monoid (generalized_boolean_algebra (finset (ring pos)))) : has_exists_mul_of_le (generalized_boolean_algebra (finset (ring pos))) := sorry --non-trivial
lemma new_lemma_47119 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem group)) : @is_cyclic.{0} (has_emptyc.{0} num) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) group.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_emptyc.{0} num))  := sorry --non-trivial
lemma new_lemma_47120 (h0 : ring (linear_ordered_semiring (random_gen to_additive.value_type))) : strong_rank_condition (linear_ordered_semiring (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_47121 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (add_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_47122 (h0 : functor.add_const (topological_space (has_to_string linarith.comp)) environment.implicit_infer_kind) : @loc_path_connected_space.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_47123 (h0 : complete_lattice (semi_normed_comm_ring (mul_one_class (mul_one_class enat)))) : is_compactly_generated (semi_normed_comm_ring (mul_one_class (mul_one_class enat))) := sorry --non-trivial
lemma new_lemma_47124 (h2 : ring (div_inv_monoid to_additive.value_type)) : rank_condition (div_inv_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_47125 (h0 : has_add (normed_field std_gen)) (h1 h2 : multiset (add_con (normed_field std_gen))) : multiset.disjoint h1 h2 := sorry --non-trivial
lemma new_lemma_47126 (h0 : ring (random_gen (topological_space (has_nnnorm (distrib linarith.comp_source))))) : is_domain (random_gen (topological_space (has_nnnorm (distrib linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_47127 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @loc_path_connected_space.{1} (has_Inf.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (has_Inf.{1} Type)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_47128 (h0 : topological_space (semigroup (semiring (semiring empty)))) : discrete_topology (semigroup (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_47129 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (canonically_ordered_comm_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_47130 (h0 : functor.add_const (ring (has_neg environment.implicit_infer_kind)) environment.implicit_infer_kind) : @is_domain.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (has_neg.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_47131 (h0 : monoid (complete_semilattice_Sup linarith.comp_source)) : monoid.fg (complete_semilattice_Sup linarith.comp_source) := sorry --non-trivial
lemma new_lemma_47132 (h0 : functor.add_const (list (boolean_algebra name)) name) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_47133 (h0 : topological_space (sub_neg_monoid (has_Inf (has_pos_part Type)))) : normal_space (sub_neg_monoid (has_Inf (has_pos_part Type))) := sorry --non-trivial
lemma new_lemma_47134 (h0 : function.extfun Type group) : @is_cyclic.{0} real (@function.extfun_app.{2 1} Type group.{0} h0 real)  := sorry --non-trivial
lemma new_lemma_47135 (h0 : functor.add_const (group (has_zero pos)) (finset Type)) : @normalizer_condition.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (has_zero.{0} pos)) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_47136 (h0 : topological_space (with_bot (comm_ring (comm_ring (random_gen (comm_ring fun_info)))))) : path_connected_space (with_bot (comm_ring (comm_ring (random_gen (comm_ring fun_info))))) := sorry --non-trivial
lemma new_lemma_47137 (h0 : ring (monoid (option (option unsigned)))) : is_domain (monoid (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_47138 (h0 : semiring (linear_ordered_cancel_comm_monoid congr_arg_kind)) : is_noetherian_ring (linear_ordered_cancel_comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_47139 (h0 : ring (complete_linear_order (semiring num))) : strong_rank_condition (complete_linear_order (semiring num)) := sorry --non-trivial
lemma new_lemma_47140 (h0 : complete_lattice (comm_group (has_add (has_add (has_add name))))) : is_atomistic (comm_group (has_add (has_add (has_add name)))) := sorry --non-trivial
lemma new_lemma_47141 (h0 : functor.add_const (function.extfun (Type 1) group) name) : @group.fg.{1} (boolean_algebra.core.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) group.{1}) name h0) (boolean_algebra.core.{1} Type))  := sorry --non-trivial
lemma new_lemma_47142 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_47143 (h2 : topological_space (simple_graph to_additive.value_type)) : totally_disconnected_space (simple_graph to_additive.value_type) := sorry --non-trivial
lemma new_lemma_47144 (h0 : complete_lattice (has_neg (has_Inf linarith.comp))) : is_compactly_generated (has_neg (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_47145 (h0 : topological_space empty) : locally_compact_space empty := sorry --non-trivial
lemma new_lemma_47146 (h0 : topological_space (has_Inf (boolean_algebra.core (has_Inf (has_Inf (has_add pos)))))) : topological_space.separable_space (has_Inf (boolean_algebra.core (has_Inf (has_Inf (has_add pos))))) := sorry --non-trivial
lemma new_lemma_47147 (h0 : topological_space (with_bot (has_inv linarith.ineq))) : t0_space (with_bot (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_47148 (h0 : add_group (semigroup (mul_one_class Type))) : is_add_cyclic (semigroup (mul_one_class Type)) := sorry --non-trivial
lemma new_lemma_47149 (h0 : topological_space (comm_group (cancel_monoid ennreal))) : regular_space (comm_group (cancel_monoid ennreal)) := sorry --non-trivial
lemma new_lemma_47150 (h0 : group (normed_comm_ring (comm_group name))) : is_cyclic (normed_comm_ring (comm_group name)) := sorry --non-trivial
lemma new_lemma_47151 (h0 : topological_space (normed_comm_ring (has_add (has_add (has_add pos))))) : totally_disconnected_space (normed_comm_ring (has_add (has_add (has_add pos)))) := sorry --non-trivial
lemma new_lemma_47152 (h1 : monoid (with_bot (has_norm linarith.ineq))) : monoid.fg (with_bot (has_norm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_47153 (h0 : functor.add_const (ring (has_nndist linarith.comp)) Type) : @is_principal_ideal_ring.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 1} (ring.{0} (has_nndist.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_47154 (h0 : functor.add_const (function.extfun Type topological_space) (ring (ring Type))) : @locally_compact_space.{0} (comm_group.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) (ring.{1} (ring.{1} Type)) h0) (comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_47155 (h0 : filter (with_bot (semiring (semiring congr_arg_kind)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_47156 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @totally_separated_space.{0} (semiring.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} fun_info)))))) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (semiring.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} fun_info)))))))  := sorry --non-trivial
lemma new_lemma_47157 (h0 : preorder (has_well_founded unsigned)) (h1 : group (locally_finite_order (has_well_founded unsigned))) : normalizer_condition (locally_finite_order (has_well_founded unsigned)) := sorry --non-trivial
lemma new_lemma_47158 (h1 : group (has_emptyc (has_top congr_arg_kind))) : normalizer_condition (has_emptyc (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_47159 (h0 h1 : multiset (has_lt char)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_47160 (h0 : topological_space (canonically_linear_ordered_monoid (has_add Type))) : topological_space.separable_space (canonically_linear_ordered_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_47161 (h0 : group (finset Type)) : group.fg (finset Type) := sorry --non-trivial
lemma new_lemma_47162 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (@id.{2} Type fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (@id.{2} Type fun_info))  := sorry --non-trivial
lemma new_lemma_47163 (h0 : filter (has_add (option (option ennreal)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_47164 (h0 : preorder (non_assoc_semiring empty)) (h1 : function.extfun (non_assoc_semiring empty) (fun (x : non_assoc_semiring empty), Prop)) : bdd_below (function.extfun_app h1) := sorry --non-trivial
lemma new_lemma_47165 (h0 : group (semiring (has_norm num))) : group.fg (semiring (has_norm num)) := sorry --non-trivial
lemma new_lemma_47166 (h0 : complete_lattice (boolean_algebra (sub_neg_monoid real))) : is_atomistic (boolean_algebra (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_47167 (h0 : group (canonically_linear_ordered_monoid (has_neg real))) : is_cyclic (canonically_linear_ordered_monoid (has_neg real)) := sorry --non-trivial
lemma new_lemma_47168 (h0 : topological_space (has_add (sub_neg_monoid Type))) : locally_compact_space (has_add (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_47169 (h0 : functor.add_const (topological_space pos) (option pos)) : @topological_space.separable_space.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) (option.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_47170 (h0 : uniform_space (semi_normed_ring linarith.ineq)) : complete_space (semi_normed_ring linarith.ineq) := sorry --non-trivial
lemma new_lemma_47171 (h0 : not (complete_lattice (has_union unsigned) -> false)) : @is_atomistic.{0} (has_union.{0} unsigned) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_union.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_47172 (h0 : topological_space (has_neg_part (has_nndist unsigned))) : discrete_topology (has_neg_part (has_nndist unsigned)) := sorry --non-trivial
lemma new_lemma_47173 (h1 : not (topological_space (has_append char) -> false)) : @totally_disconnected_space.{0} (has_append.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (has_append.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_47174 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (metric_space.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (metric_space.{0} num))  := sorry --non-trivial
lemma new_lemma_47175 (h0 : uniform_space (boolean_algebra.core (has_zero num))) : separated_space (boolean_algebra.core (has_zero num)) := sorry --non-trivial
lemma new_lemma_47176 (h0 : complete_lattice (has_norm (random_gen num))) : is_atomistic (has_norm (random_gen num)) := sorry --non-trivial
lemma new_lemma_47177 (h0 : ordered_comm_monoid (boolean_algebra real)) : has_exists_mul_of_le (boolean_algebra real) := sorry --non-trivial
lemma new_lemma_47178 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (add_cancel_monoid ennreal)) := sorry --non-trivial
lemma new_lemma_47179 (h0 : monoid (measurable_space (has_top (random_gen (random_gen linarith.comp_source))))) : monoid.fg (measurable_space (has_top (random_gen (random_gen linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_47180 (h0 : function.extfun Type group) : @normalizer_condition.{0} (boolean_algebra.core.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (boolean_algebra.core.{0} empty))  := sorry --non-trivial
lemma new_lemma_47181 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (has_inv.{0} linarith.ineq) (@function.extfun_app.{2 1} Type monoid.{0} h0 (has_inv.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_47182 (h0 : topological_space (ring (has_Inf (has_to_string (ring linarith.comp))))) : preirreducible_space (ring (has_Inf (has_to_string (ring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_47183 (h0 : functor.add_const (uniform_space (left_cancel_semigroup congr_arg_kind)) congr_arg_kind) : @separated_space.{0} (left_cancel_semigroup.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (uniform_space.{0} (left_cancel_semigroup.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_47184 (h0 : topological_space (has_Inf (has_Inf pos))) : sequential_space (has_Inf (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_47185 (h1 : add_group (semi_normed_ring (mul_one_class (semi_normed_ring reducibility_hints)))) : is_add_cyclic (semi_normed_ring (mul_one_class (semi_normed_ring reducibility_hints))) := sorry --non-trivial
lemma new_lemma_47186 (h0 : not (complete_lattice (mul_zero_class num) -> false)) : @is_atomistic.{0} (mul_zero_class.{0} num) (@classical.by_contradiction'.{1} (complete_lattice.{0} (mul_zero_class.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_47187 (h0 : uniform_space (linear_ordered_semiring (has_nnnorm linarith.ineq))) : complete_space (linear_ordered_semiring (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_47188 (h0 : complete_lattice (add_cancel_comm_monoid string.iterator_imp)) : is_compactly_generated (add_cancel_comm_monoid string.iterator_imp) := sorry --non-trivial
lemma new_lemma_47189 (h0 : topological_space (add_comm_monoid (has_add environment.implicit_infer_kind))) : normal_space (add_comm_monoid (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_47190 (h0 : functor.add_const (monoid (canonically_ordered_comm_semiring Type)) name) : @monoid.fg.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.add_const.run.{1 0} (monoid.{1} (canonically_ordered_comm_semiring.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_47191 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (boolean_algebra.core.{0} unsigned) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (boolean_algebra.core.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_47192 (h0 : not (topological_space (has_emptyc (has_inv linarith.ineq)) -> false)) : @totally_disconnected_space.{0} (has_emptyc.{0} (has_inv.{0} linarith.ineq)) (@classical.by_contradiction'.{1} (topological_space.{0} (has_emptyc.{0} (has_inv.{0} linarith.ineq))) h0)  := sorry --non-trivial
lemma new_lemma_47193 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_47194 (h0 : functor.add_const (ordered_add_comm_monoid (has_add linarith.comp)) (has_nndist pos)) : @archimedean.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_add.{0} linarith.comp)) (has_nndist.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_47195 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (canonically_ordered_comm_semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_47196 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (simple_graph.{0} linarith.comp) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (simple_graph.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_47197 (h0 : list (mul_zero_class (add_comm_monoid Type))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_47198 (h0 : list (add_comm_monoid ennreal)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_47199 (h0 : semiring (ordered_cancel_add_comm_monoid empty)) : is_noetherian_ring (ordered_cancel_add_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_47200 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (measurable_space.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measurable_space.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_47201 (h0 : add_monoid (normed_comm_ring (has_add (finset pos)))) : add_monoid.fg (normed_comm_ring (has_add (finset pos))) := sorry --non-trivial
lemma new_lemma_47202 (h0 : functor.add_const (topological_space (has_nndist environment.implicit_infer_kind)) name) : @preirreducible_space.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_47203 (h0 : group (ring (ring (ring Type)))) : group.fg (ring (ring (ring Type))) := sorry --non-trivial
lemma new_lemma_47204 (h0 : topological_space (sub_neg_monoid (has_neg pos))) : irreducible_space (sub_neg_monoid (has_neg pos)) := sorry --non-trivial
lemma new_lemma_47205 (h0 : functor.add_const (topological_space (ordered_comm_ring linarith.comp)) name) : @preirreducible_space.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_47206 (h0 : complete_lattice (has_one (semiring (has_norm empty)))) : complete_lattice.is_Sup_finite_compact (has_one (semiring (has_norm empty))) := sorry --non-trivial
lemma new_lemma_47207 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_47208 (h0 : set (prod string.iterator_imp string.iterator_imp)) (h1 : add_group (semi_normed_comm_ring (plift (symmetric_rel h0)))) : is_add_cyclic (semi_normed_comm_ring (plift (symmetric_rel h0))) := sorry --non-trivial
lemma new_lemma_47209 (h0 : group (has_top (has_norm (has_norm linarith.comp_source)))) : normalizer_condition (has_top (has_norm (has_norm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_47210 (h0 : functor.add_const (topological_space (left_cancel_monoid empty)) num) : @totally_separated_space.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_47211 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (generalized_boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (generalized_boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_47212 (h0 : topological_space (canonically_ordered_monoid (has_neg pos))) : normal_space (canonically_ordered_monoid (has_neg pos)) := sorry --non-trivial
lemma new_lemma_47213 (h0 : functor.add_const (topological_space (ordered_comm_ring pos)) linarith.comp) : @discrete_topology.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_47214 (h0 : topological_space (normed_lattice_add_comm_group (has_add (has_Inf Type)))) : totally_separated_space (normed_lattice_add_comm_group (has_add (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_47215 (h0 : functor.comp ring boolean_algebra name) : @strong_rank_condition.{0} (boolean_algebra.{0} name) (@functor.comp.run.{0 0 0} ring.{0} boolean_algebra.{0} name h0)  := sorry --non-trivial
lemma new_lemma_47216 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (ordered_cancel_add_comm_monoid.{0} (option.{0} ennreal)) (@function.extfun_app.{2 1} Type monoid.{0} h0 (ordered_cancel_add_comm_monoid.{0} (option.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_47217 (h0 : measurable_space (nondiscrete_normed_field (add_comm_semigroup (add_comm_semigroup enat)))) (h1 : measure_theory.measure (nondiscrete_normed_field (add_comm_semigroup (add_comm_semigroup enat)))) : measure_theory.is_finite_measure h1 := sorry --non-trivial
lemma new_lemma_47218 (h0 : topological_space (ring (has_add linarith.comp))) : normal_space (ring (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_47219 (h0 : complete_lattice (finset (finset (finset (finset (has_nndist pos)))))) : complete_lattice.is_Sup_finite_compact (finset (finset (finset (finset (has_nndist pos))))) := sorry --non-trivial
lemma new_lemma_47220 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (filter.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (filter.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_47221 (h0 : topological_space (non_unital_non_assoc_semiring (has_ssubset char))) : t0_space (non_unital_non_assoc_semiring (has_ssubset char)) := sorry --non-trivial
lemma new_lemma_47222 (h0 : function.extfun (Type 1) filter) : filter.ne_bot (function.extfun_app h0 (plift congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_47223 (h0 : monoid (cancel_monoid linarith.comp)) : monoid.fg (cancel_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_47224 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (preorder.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (preorder.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_47225 (h0 : not (ring (semi_normed_comm_ring (comm_ring fun_info)) -> false)) : @rank_condition.{0} (semi_normed_comm_ring.{0} (comm_ring.{0} fun_info)) (@classical.by_contradiction'.{1} (ring.{0} (semi_normed_comm_ring.{0} (comm_ring.{0} fun_info))) h0)  := sorry --non-trivial
lemma new_lemma_47226 (h0 : ring (has_zero (comm_group (comm_group Type)))) : is_domain (has_zero (comm_group (comm_group Type))) := sorry --non-trivial
lemma new_lemma_47227 (h0 : fin has_zero.zero) : @is_compactly_generated.{0} (has_pos_part.{0} pos) (@matrix.vec_empty.{0} (complete_lattice.{0} (has_pos_part.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_47228 (h1 : topological_space (topological_space reducibility_hints)) : t0_space (topological_space reducibility_hints) := sorry --non-trivial
lemma new_lemma_47229 (h1 : not (group (complete_semilattice_Sup linarith.comp) -> false)) : @normalizer_condition.{0} (complete_semilattice_Sup.{0} linarith.comp) (@classical.by_contradiction'.{1} (group.{0} (complete_semilattice_Sup.{0} linarith.comp)) h1)  := sorry --non-trivial
lemma new_lemma_47230 (h0 : topological_space (has_ssubset (mul_one_class (mul_one_class (has_div fun_info))))) : path_connected_space (has_ssubset (mul_one_class (mul_one_class (has_div fun_info)))) := sorry --non-trivial
lemma new_lemma_47231 (h0 : functor.add_const (ring (linear_ordered_cancel_comm_monoid empty)) empty) : @is_principal_ideal_ring.{0} (linear_ordered_cancel_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (linear_ordered_cancel_comm_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_47232 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (with_bot.{0} linarith.comp) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (with_bot.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_47233 (h0 : not (ring (complete_linear_order unsigned) -> false)) : @is_domain.{0} (complete_linear_order.{0} unsigned) (@classical.by_contradiction'.{1} (ring.{0} (complete_linear_order.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_47234 (h0 : topological_space (boolean_algebra.core (option (option (option (option ennreal)))))) : locally_compact_space (boolean_algebra.core (option (option (option (option ennreal))))) := sorry --non-trivial
lemma new_lemma_47235 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @t1_space.{0} (has_neg.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (has_neg.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_47236 (h0 : functor.add_const (list (ring ennreal)) unsigned) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_47237 (h0 : filter (comm_group (finset (has_neg linarith.comp)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_47238 (h0 : functor.const Prop (has_inner empty num)) : functor.const.run h0 := sorry --non-trivial
lemma new_lemma_47239 (h0 : add_group (linear_ordered_comm_group_with_zero enat)) : is_add_cyclic (linear_ordered_comm_group_with_zero enat) := sorry --non-trivial
lemma new_lemma_47240 (h0 : functor.add_const (group (has_zero Type)) (has_neg (ring Type))) : @normalizer_condition.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 1} (group.{1} (has_zero.{1} Type)) (has_neg.{1} (ring.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_47241 (h0 : not (topological_space (has_ssubset fun_info) -> false)) : @locally_compact_space.{0} (has_ssubset.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (has_ssubset.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_47242 (h0 : ring (has_neg (boolean_algebra (ring linarith.comp)))) : is_principal_ideal_ring (has_neg (boolean_algebra (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_47243 (h0 : functor.add_const (add_group (bin_tree num)) unsigned) : @is_add_cyclic.{0} (bin_tree.{0} num) (@functor.add_const.run.{0 0} (add_group.{0} (bin_tree.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_47244 (h0 : function.extfun Type topological_space) : @t0_space.{0} (filter.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (filter.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_47245 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @preirreducible_space.{0} (finset.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (finset.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_47246 (h0 : topological_space (mul_one_class fun_info)) (h1 : set (mul_one_class fun_info)) : is_path_connected h1 := sorry --non-trivial
lemma new_lemma_47247 (h0 : topological_space (mul_zero_class (has_add (finset name)))) : irreducible_space (mul_zero_class (has_add (finset name))) := sorry --non-trivial
lemma new_lemma_47248 (h0 : topological_space (has_ssubset linarith.comp_source)) : totally_disconnected_space (has_ssubset linarith.comp_source) := sorry --non-trivial
lemma new_lemma_47249 (h0 : functor.add_const (semiring (linear_order num)) unsigned) : @is_noetherian_ring.{0} (linear_order.{0} num) (@functor.add_const.run.{0 0} (semiring.{0} (linear_order.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_47250 (h0 : not (topological_space (with_bot linarith.ineq) -> false)) : @locally_compact_space.{0} (with_bot.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (with_bot.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_47251 (h0 : group (comm_group (has_nndist Type))) : normalizer_condition (comm_group (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_47252 (h0 : measurable_space (normed_field linarith.comp_source)) (h1 : filter (normed_field linarith.comp_source)) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_47253 (h0 : topological_space (boolean_algebra.core (finset (has_add name)))) : loc_path_connected_space (boolean_algebra.core (finset (has_add name))) := sorry --non-trivial
lemma new_lemma_47254 (h0 : not (group (with_one num) -> false)) : @is_cyclic.{0} (with_one.{0} num) (@classical.by_contradiction'.{1} (group.{0} (with_one.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_47255 (h0 : ordered_add_comm_monoid (has_pos_part (has_add (has_add linarith.comp)))) : archimedean (has_pos_part (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_47256 (h0 : topological_space (add_comm_monoid (has_neg linarith.comp))) : sequential_space (add_comm_monoid (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_47257 (h0 : topological_space (has_to_string environment.implicit_infer_kind)) : discrete_topology (has_to_string environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_47258 (h0 : topological_space (boolean_algebra (boolean_algebra (has_add (has_Inf Type))))) : locally_compact_space (boolean_algebra (boolean_algebra (has_add (has_Inf Type)))) := sorry --non-trivial
lemma new_lemma_47259 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (semiring.{0} num) (@function.extfun_app.{2 1} Type semiring.{0} h0 (semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_47260 (h0 : finset (normed_comm_ring (has_add pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_47261 (h0 : not (group Type -> false)) : @group.fg.{1} Type (@classical.by_contradiction'.{2} (group.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_47262 (h0 : topological_space (canonically_ordered_comm_semiring unsigned)) : locally_compact_space (canonically_ordered_comm_semiring unsigned) := sorry --non-trivial
lemma new_lemma_47263 (h0 : topological_space (normed_lattice_add_comm_group Type)) : preconnected_space (normed_lattice_add_comm_group Type) := sorry --non-trivial
lemma new_lemma_47264 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_47265 (h0 : function.extfun (Type 1) complete_lattice) : @complete_lattice.is_Sup_finite_compact.{1} (plift.{1} unsigned) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} h0 (plift.{1} unsigned))  := sorry --non-trivial
lemma new_lemma_47266 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (add_cancel_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_cancel_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_47267 (h0 : group (metric_space (random_gen empty))) : normalizer_condition (metric_space (random_gen empty)) := sorry --non-trivial
lemma new_lemma_47268 (h0 : prod (left_cancel_monoid (semiring empty)) (left_cancel_monoid (semiring empty))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_47269 (h0 : not (group (plift unsigned) -> false)) : @is_cyclic.{1} (plift.{1} unsigned) (@classical.by_contradiction'.{2} (group.{1} (plift.{1} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_47270 (h0 : not (topological_space (non_unital_non_assoc_semiring (metric_space to_additive.value_type)) -> false)) : @path_connected_space.{0} (non_unital_non_assoc_semiring.{0} (metric_space.{0} to_additive.value_type)) (@classical.by_contradiction'.{1} (topological_space.{0} (non_unital_non_assoc_semiring.{0} (metric_space.{0} to_additive.value_type))) h0)  := sorry --non-trivial
lemma new_lemma_47271 (h0 : group (random_gen (random_gen (random_gen (comm_ring linarith.comp_source))))) : is_cyclic (random_gen (random_gen (random_gen (comm_ring linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_47272 (h0 : functor.add_const (topological_space (boolean_algebra Type)) linarith.comp) : @locally_compact_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_47273 (h0 : add_group (as_linear_order (option empty))) : is_add_cyclic (as_linear_order (option empty)) := sorry --non-trivial
lemma new_lemma_47274 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @preirreducible_space.{0} (ordered_comm_ring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (ordered_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_47275 (h0 : topological_space (with_one (random_gen (random_gen (random_gen linarith.ineq))))) : totally_separated_space (with_one (random_gen (random_gen (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_47276 (h0 : topological_space (has_norm (semiring linarith.comp))) : normal_space (has_norm (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_47277 (h0 : complete_lattice (non_unital_non_assoc_semiring ereal)) : is_compactly_generated (non_unital_non_assoc_semiring ereal) := sorry --non-trivial
lemma new_lemma_47278 (h0 : group (add_group num)) : group.fg (add_group num) := sorry --non-trivial
lemma new_lemma_47279 (h0 : filter (has_nndist (finset (finset pos)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_47280 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (comm_semigroup.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (comm_semigroup.{0} real))  := sorry --non-trivial
lemma new_lemma_47281 (h0 : functor.add_const (ordered_add_comm_monoid (has_nndist pos)) (has_add pos)) : @archimedean.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_nndist.{0} pos)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_47282 (h0 : ring (boolean_algebra linarith.comp)) : is_domain (boolean_algebra linarith.comp) := sorry --non-trivial
lemma new_lemma_47283 (h0 : topological_space (has_bot (has_add pos))) : normal_space (has_bot (has_add pos)) := sorry --non-trivial
lemma new_lemma_47284 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_norm.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_norm.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_47285 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (cancel_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_47286 (h0 : functor.add_const (group (comm_group name)) linarith.comp) : @normalizer_condition.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (group.{0} (comm_group.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_47287 (h0 : ring (has_to_string ennreal)) : rank_condition (has_to_string ennreal) := sorry --non-trivial
lemma new_lemma_47288 (h0 : topological_space (has_add (sub_neg_monoid (has_add real)))) : loc_path_connected_space (has_add (sub_neg_monoid (has_add real))) := sorry --non-trivial
lemma new_lemma_47289 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @regular_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semigroup.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_47290 (h0 : semiring (canonically_ordered_comm_semiring (option (option unsigned)))) : is_noetherian_ring (canonically_ordered_comm_semiring (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_47291 (h3 : complete_lattice (semi_normed_ring to_additive.value_type)) : complete_lattice.is_Sup_finite_compact (semi_normed_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_47292 (h0 : preorder char) (h1 : topological_space (locally_finite_order char)) : t0_space (locally_finite_order char) := sorry --non-trivial
lemma new_lemma_47293 (h0 : functor.add_const (topological_space (has_zero Type)) environment.implicit_infer_kind) : @t0_space.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_zero.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_47294 (h0 : functor.add_const (group (normed_comm_ring Type)) (finset (ring pos))) : @group.fg.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (normed_comm_ring.{1} Type)) (finset.{0} (ring.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_47295 (h0 : functor.add_const (list nnreal) unsigned) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_47296 (h0 : functor.add_const (list (free_add_monoid congr_arg_kind)) congr_arg_kind) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_47297 (h0 : ring (normed_comm_ring (semigroup (has_neg_part name)))) : strong_rank_condition (normed_comm_ring (semigroup (has_neg_part name))) := sorry --non-trivial
lemma new_lemma_47298 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @is_atomistic.{0} (complete_semilattice_Sup.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) complete_lattice.{0}) (complete_semilattice_Sup.{0} num))  := sorry --non-trivial
lemma new_lemma_47299 (h1 : set string_imp) : set.finite h1 := sorry --non-trivial
lemma new_lemma_47300 (h0 : ring (add_cancel_monoid (has_pos_part (has_Inf linarith.comp)))) : rank_condition (add_cancel_monoid (has_pos_part (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_47301 (h0 : topological_space (semiring (random_gen linarith.comp_source))) : t0_space (semiring (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_47302 (h0 : functor.add_const (ring (bin_tree empty)) empty) : @is_domain.{0} (bin_tree.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (bin_tree.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_47303 (h0 : uniform_space (semiring (has_norm linarith.comp))) : separated_space (semiring (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_47304 (h0 : topological_space (monoid_with_zero pos)) : loc_path_connected_space (monoid_with_zero pos) := sorry --non-trivial
lemma new_lemma_47305 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (comm_group.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_group.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_47306 (h0 : has_mem.mem (semiring num) has_emptyc.emptyc) : @separated_space.{0} (semiring.{0} num) (@finset.pi.empty.{1 0} Type uniform_space.{0} (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_47307 (h0 : topological_space (boolean_algebra (ring (normed_comm_ring Type)))) : path_connected_space (boolean_algebra (ring (normed_comm_ring Type))) := sorry --non-trivial
lemma new_lemma_47308 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (has_emptyc.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_emptyc.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_47309 (h0 : topological_space (has_emptyc linarith.comp_source)) : t0_space (has_emptyc linarith.comp_source) := sorry --non-trivial
lemma new_lemma_47310 (h0 : set (set name)) : is_countably_spanning h0 := sorry --non-trivial
lemma new_lemma_47311 (h0 : functor.add_const (topological_space (has_to_string pos)) (has_pos_part Type)) : @normal_space.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_to_string.{0} pos)) (has_pos_part.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_47312 (h0 : function.extfun (monoid empty) (fun (x : monoid empty), Prop)) (h1 : monoid empty) : set.set_semiring.down (function.extfun_app h0) h1 := sorry --non-trivial
lemma new_lemma_47313 (h0 : cancel_comm_monoid_with_zero (monoid (option (option (option ennreal))))) : unique_factorization_monoid (monoid (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_47314 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (has_add.{0} real) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_add.{0} real))  := sorry --non-trivial
lemma new_lemma_47315 (h0 : functor.add_const (topological_space (canonically_ordered_add_monoid unsigned)) congr_arg_kind) : @locally_compact_space.{0} (canonically_ordered_add_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_add_monoid.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_47316 (h0 : complete_lattice (has_zero (finset pos))) : complete_lattice.is_Sup_finite_compact (has_zero (finset pos)) := sorry --non-trivial
lemma new_lemma_47317 (h0 : functor.add_const (ordered_comm_monoid (has_pos_part Type)) (ring Type)) : @has_exists_mul_of_le.{1} (has_pos_part.{1} Type) (@functor.add_const.run.{1 1} (ordered_comm_monoid.{1} (has_pos_part.{1} Type)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_47318 (h0 : functor.add_const (filter (has_neg_part name)) name) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_47319 (h0 : linarith.comp -> linarith.comp -> Prop) : total h0 := sorry --non-trivial
lemma new_lemma_47320 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (ring.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_47321 (h0 : not (function.extfun Type complete_lattice -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (with_one.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (with_one.{0} num))  := sorry --non-trivial
lemma new_lemma_47322 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (finset.{0} name) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (finset.{0} name))  := sorry --non-trivial
lemma new_lemma_47323 (h1 : add_group (denumerable (has_nnnorm (has_nnnorm linarith.ineq)))) : is_add_cyclic (denumerable (has_nnnorm (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_47324 (h0 : not (ring (with_bot fun_info) -> false)) : @is_domain.{0} (with_bot.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (with_bot.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_47325 (h0 : functor.add_const (topological_space (semigroup Type)) name) : @loc_path_connected_space.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (semigroup.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_47326 (h0 : functor.add_const (topological_space (ordered_comm_monoid pos)) Type) : @discrete_topology.{0} (ordered_comm_monoid.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (ordered_comm_monoid.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_47327 (h0 : ring (linear_ordered_comm_group_with_zero (has_repr char))) : is_domain (linear_ordered_comm_group_with_zero (has_repr char)) := sorry --non-trivial
lemma new_lemma_47328 (h0 : function.extfun Type group) : @group.fg.{0} (has_neg_part.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (has_neg_part.{0} empty))  := sorry --non-trivial
lemma new_lemma_47329 (h0 : functor.add_const (topological_space Type) (has_add (has_add pos))) : @t0_space.{1} Type (@functor.add_const.run.{1 0} (topological_space.{1} Type) (has_add.{0} (has_add.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_47330 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (ring pos)) := sorry --non-trivial
lemma new_lemma_47331 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (canonically_linear_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (canonically_linear_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_47332 (h0 : topological_space (cancel_monoid (option congr_arg_kind))) : irreducible_space (cancel_monoid (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_47333 (h0 : function.extfun Type (functor.add_const (ring empty))) : @is_principal_ideal_ring.{0} empty (@functor.add_const.run.{0 0} (ring.{0} empty) (option.{0} unsigned) (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} empty)) h0 (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_47334 (h0 : topological_space (generalized_boolean_algebra (has_Inf pos))) : sequential_space (generalized_boolean_algebra (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_47335 (h0 : functor.add_const (add_monoid (generalized_boolean_algebra pos)) linarith.comp) : @add_monoid.fg.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (add_monoid.{0} (generalized_boolean_algebra.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_47336 (h0 : not (uniform_space (plift unsigned) -> false)) : @complete_space.{1} (plift.{1} unsigned) (@classical.by_contradiction'.{2} (uniform_space.{1} (plift.{1} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_47337 (h0 : filter (boolean_algebra.core (has_neg_part Type))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_47338 (h0 : complete_lattice (has_add (option (option ennreal)))) : is_atomistic (has_add (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_47339 (h0 : topological_space (has_norm (semiring (semiring (has_top empty))))) : normal_space (has_norm (semiring (semiring (has_top empty)))) := sorry --non-trivial
lemma new_lemma_47340 (h0 : functor.add_const (topological_space (semigroup Type)) Type) : @locally_compact_space.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (semigroup.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_47341 (h0 : has_mem.mem (with_one (random_gen num)) has_emptyc.emptyc) : @normalizer_condition.{0} (with_one.{0} (random_gen.{0} num)) (@finset.pi.empty.{1 0} Type group.{0} (with_one.{0} (random_gen.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_47342 (h0 : topological_space (sub_neg_monoid (finset Type))) : irreducible_space (sub_neg_monoid (finset Type)) := sorry --non-trivial
lemma new_lemma_47343 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @complete_space.{0} (canonically_linear_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) uniform_space.{0}) (canonically_linear_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_47344 (h0 : Prop) (h1 : decidable h0) : as_true h0 := sorry --non-trivial
lemma new_lemma_47345 (h0 : topological_space (simple_graph ereal)) : path_connected_space (simple_graph ereal) := sorry --non-trivial
lemma new_lemma_47346 (h0 : filter (pseudo_metric_space pos)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_47347 (h0 : function.extfun Type (functor.add_const (topological_space (has_Sup unsigned)))) : @loc_path_connected_space.{0} (has_Sup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Sup.{0} unsigned)) congr_arg_kind (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (has_Sup.{0} unsigned))) h0 congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_47348 (h0 : topological_space (canonically_linear_ordered_monoid linarith.comp)) : irreducible_space (canonically_linear_ordered_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_47349 (h0 : group (has_norm (measurable_space num))) : normalizer_condition (has_norm (measurable_space num)) := sorry --non-trivial
lemma new_lemma_47350 (h1 : functor.add_const (group (has_top to_additive.value_type)) linarith.ineq) : @normalizer_condition.{0} (has_top.{0} to_additive.value_type) (@functor.add_const.run.{0 0} (group.{0} (has_top.{0} to_additive.value_type)) linarith.ineq h1)  := sorry --non-trivial
lemma new_lemma_47351 (h0 : functor.add_const (function.extfun Type topological_space) (has_Inf (has_add (has_zero (has_neg Type))))) : @totally_disconnected_space.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) (has_Inf.{1} (has_add.{1} (has_zero.{1} (has_neg.{1} Type)))) h0) (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_47352 (h0 : ring (boolean_algebra (has_Inf (has_pos_part pos)))) : strong_rank_condition (boolean_algebra (has_Inf (has_pos_part pos))) := sorry --non-trivial
lemma new_lemma_47353 (h0 : group (semi_normed_comm_ring (has_nnnorm (has_top fun_info)))) : group.fg (semi_normed_comm_ring (has_nnnorm (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_47354 (h1 : topological_space (normed_field linarith.ineq)) : t0_space (normed_field linarith.ineq) := sorry --non-trivial
lemma new_lemma_47355 (h0 : function.extfun (Type 1) add_monoid) : @add_monoid.fg.{1} (generalized_boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_monoid.{1} h0 (generalized_boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_47356 (h0 : topological_space (ordered_comm_group num)) : normal_space (ordered_comm_group num) := sorry --non-trivial
lemma new_lemma_47357 (h0 : functor.add_const (topological_space (has_to_string Type)) pos) : @totally_disconnected_space.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_to_string.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_47358 (h0 : monoid (add_right_cancel_monoid (semiring empty))) : monoid.fg (add_right_cancel_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_47359 (h0 : add_group (div_inv_monoid linarith.ineq)) : is_add_cyclic (div_inv_monoid linarith.ineq) := sorry --non-trivial
lemma new_lemma_47360 (h0 : functor.add_const (uniform_space linarith.comp) (has_pos_part pos)) : @complete_space.{0} linarith.comp (@functor.add_const.run.{0 0} (uniform_space.{0} linarith.comp) (has_pos_part.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_47361 (h0 : topological_space (monoid (option (option (option num))))) : irreducible_space (monoid (option (option (option num)))) := sorry --non-trivial
lemma new_lemma_47362 (h1 : ring (has_compl (random_gen (random_gen (random_gen (random_gen char)))))) : strong_rank_condition (has_compl (random_gen (random_gen (random_gen (random_gen char))))) := sorry --non-trivial
lemma new_lemma_47363 (h0 : complete_lattice (monoid_with_zero pos)) : is_compactly_generated (monoid_with_zero pos) := sorry --non-trivial
lemma new_lemma_47364 (h0 : group (has_zero (has_add name))) : is_simple_group (has_zero (has_add name)) := sorry --non-trivial
lemma new_lemma_47365 (h0 : not (uniform_space (has_top linarith.ineq) -> false)) : @complete_space.{0} (has_top.{0} linarith.ineq) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_top.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_47366 (h0 : function.extfun (finset Type) (has_mem.mem (random_gen linarith.comp))) : @strong_rank_condition.{0} (random_gen.{0} linarith.comp) (@finset.pi.empty.{1 0} Type ring.{0} (random_gen.{0} linarith.comp) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} linarith.comp)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_47367 (h0 : functor.add_const (monoid (has_to_string Type)) (finset (ring Type))) : @monoid.fg.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 1} (monoid.{1} (has_to_string.{1} Type)) (finset.{1} (ring.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_47368 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (boolean_algebra.core.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (boolean_algebra.core.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_47369 (h0 : functor.add_const (ring (ring name)) Type) : @strong_rank_condition.{0} (ring.{0} name) (@functor.add_const.run.{0 1} (ring.{0} (ring.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_47370 (h0 : not (complete_lattice (semiring num) -> false)) : @is_compactly_generated.{0} (semiring.{0} num) (@classical.by_contradiction'.{1} (complete_lattice.{0} (semiring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_47371 (h0 : topological_space (linear_ordered_field (option (option (option ennreal))))) : loc_path_connected_space (linear_ordered_field (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_47372 (h0 : topological_space (is_R_or_C num)) : t1_space (is_R_or_C num) := sorry --non-trivial
lemma new_lemma_47373 (h0 : complete_lattice (metric_space (has_norm empty))) : is_compactly_generated (metric_space (has_norm empty)) := sorry --non-trivial
lemma new_lemma_47374 (h0 : functor.add_const (add_group (filter unsigned)) (option empty)) : @is_add_cyclic.{0} (filter.{0} unsigned) (@functor.add_const.run.{0 0} (add_group.{0} (filter.{0} unsigned)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_47375 (h0 : topological_space (ring (has_neg (has_Inf (boolean_algebra (ordered_ring Type)))))) : t0_space (ring (has_neg (has_Inf (boolean_algebra (ordered_ring Type))))) := sorry --non-trivial
lemma new_lemma_47376 (h0 : complete_lattice (has_union (semiring (left_cancel_monoid num)))) : is_atomistic (has_union (semiring (left_cancel_monoid num))) := sorry --non-trivial
lemma new_lemma_47377 (h0 : uniform_space (add_cancel_monoid (has_neg (has_to_string (has_top (finset (has_add Type))))))) : separated_space (add_cancel_monoid (has_neg (has_to_string (has_top (finset (has_add Type)))))) := sorry --non-trivial
lemma new_lemma_47378 (h0 : functor.add_const (filter (has_zero Type)) linarith.comp) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_47379 (h0 : topological_space (measurable_space congr_arg_kind)) : discrete_topology (measurable_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_47380 (h0 : topological_space (boolean_algebra.core linarith.comp)) : normal_space (boolean_algebra.core linarith.comp) := sorry --non-trivial
lemma new_lemma_47381 (h0 : cancel_comm_monoid_with_zero (comm_group (semigroup name))) : unique_factorization_monoid (comm_group (semigroup name)) := sorry --non-trivial
lemma new_lemma_47382 (h0 : ring (distrib (set string_imp))) : is_domain (distrib (set string_imp)) := sorry --non-trivial
lemma new_lemma_47383 (h0 : not (complete_lattice (with_bot linarith.ineq) -> false)) : @is_compactly_generated.{0} (with_bot.{0} linarith.ineq) (@classical.by_contradiction'.{1} (complete_lattice.{0} (with_bot.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_47384 (h0 : functor.add_const (topological_space (add_comm_monoid environment.implicit_infer_kind)) Type) : @preconnected_space.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (add_comm_monoid.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_47385 (h0 : functor.add_const (function.extfun Type ring) (has_Inf linarith.comp)) : @is_principal_ideal_ring.{0} (ordered_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) (has_Inf.{0} linarith.comp) h0) (ordered_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_47386 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @topological_space.separable_space.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_47387 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_47388 (h0 : ordered_comm_monoid (pseudo_metric_space (option (option pos)))) : has_exists_mul_of_le (pseudo_metric_space (option (option pos))) := sorry --non-trivial
lemma new_lemma_47389 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (has_add.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_add.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_47390 (h0 : topological_space (normed_group (has_one linarith.comp))) : irreducible_space (normed_group (has_one linarith.comp)) := sorry --non-trivial
lemma new_lemma_47391 (h0 : functor.add_const (ordered_add_comm_monoid (canonically_ordered_comm_semiring linarith.comp)) Type) : @archimedean.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@functor.add_const.run.{0 1} (ordered_add_comm_monoid.{0} (canonically_ordered_comm_semiring.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_47392 (h0 : uniform_space (non_unital_non_assoc_semiring (semi_normed_comm_ring to_additive.value_type))) : complete_space (non_unital_non_assoc_semiring (semi_normed_comm_ring to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_47393 (h0 : functor.add_const (topological_space (has_neg name)) name) : @loc_path_connected_space.{0} (has_neg.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_47394 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (has_neg_part.{0} name) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (has_neg_part.{0} name))  := sorry --non-trivial
lemma new_lemma_47395 (h0 : has_mem.mem (normed_group fun_info) has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} (normed_group.{0} fun_info) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (normed_group.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_47396 (h0 : monoid (add_comm_monoid environment.implicit_infer_kind)) : monoid.fg (add_comm_monoid environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_47397 (h0 : ring (complete_semilattice_Sup (random_gen linarith.comp_source))) : is_domain (complete_semilattice_Sup (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_47398 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (has_neg.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_47399 (h0 : ring (left_cancel_semigroup (semiring congr_arg_kind))) : strong_rank_condition (left_cancel_semigroup (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_47400 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (canonically_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (canonically_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_47401 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_47402 (h0 : not (uniform_space (add_group linarith.comp) -> false)) : @separated_space.{0} (add_group.{0} linarith.comp) (@classical.by_contradiction'.{1} (uniform_space.{0} (add_group.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_47403 (h0 : functor.add_const (add_monoid (has_Inf linarith.comp)) Type) : @add_monoid.fg.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 1} (add_monoid.{0} (has_Inf.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_47404 (h0 : group (linear_ordered_comm_group num)) : group.fg (linear_ordered_comm_group num) := sorry --non-trivial
lemma new_lemma_47405 (h3 : set (string.iterator_imp -> string.iterator_imp)) : set.separates_points h3 := sorry --non-trivial
lemma new_lemma_47406 (h0 : functor.add_const (topological_space (boolean_algebra.core linarith.comp)) (finset linarith.comp)) : @discrete_topology.{0} (boolean_algebra.core.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} linarith.comp)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_47407 (h0 : not (complete_lattice (has_sub num) -> false)) : @is_atomistic.{0} (has_sub.{0} num) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_sub.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_47408 (h0 : topological_space (has_nndist num)) : normal_space (has_nndist num) := sorry --non-trivial
lemma new_lemma_47409 (h0 : monoid (has_nndist (comm_group (comm_group (comm_group pos))))) : monoid.fg (has_nndist (comm_group (comm_group (comm_group pos)))) := sorry --non-trivial
lemma new_lemma_47410 (h0 : functor.add_const (ring (finset pos)) environment.implicit_infer_kind) : @rank_condition.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (finset.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_47411 (h1 : topological_space fun_info) : noncompact_space fun_info := sorry --non-trivial
lemma new_lemma_47412 (h0 : add_group (has_inter ennreal)) : is_add_cyclic (has_inter ennreal) := sorry --non-trivial
lemma new_lemma_47413 (h0 : functor.add_const (topological_space (has_add environment.implicit_infer_kind)) (has_add linarith.comp)) : @t0_space.{0} (has_add.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} environment.implicit_infer_kind)) (has_add.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_47414 (h0 : functor.add_const (add_monoid znum) (option empty)) : @add_monoid.fg.{0} znum (@functor.add_const.run.{0 0} (add_monoid.{0} znum) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_47415 (h0 : cancel_comm_monoid_with_zero (has_union (semiring num))) : unique_factorization_monoid (has_union (semiring num)) := sorry --non-trivial
lemma new_lemma_47416 (h0 : group (partial_order (semiring empty))) : is_cyclic (partial_order (semiring empty)) := sorry --non-trivial
lemma new_lemma_47417 (h0 : functor.add_const (topological_space (ring pos)) Type) : @path_connected_space.{0} (ring.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (ring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_47418 (h0 : topological_space (add_left_cancel_monoid linarith.comp_source)) : path_connected_space (add_left_cancel_monoid linarith.comp_source) := sorry --non-trivial
lemma new_lemma_47419 (h0 : functor.add_const (topological_space (boolean_algebra.core pos)) linarith.comp) : @regular_space.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_47420 (h0 : functor.add_const (topological_space (has_zero name)) linarith.comp) : @preconnected_space.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_47421 (h0 : topological_space (has_nndist (comm_group pos))) : t0_space (has_nndist (comm_group pos)) := sorry --non-trivial
lemma new_lemma_47422 (h0 : functor.add_const (monoid (finset name)) (ring linarith.comp)) : @monoid.fg.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (monoid.{0} (finset.{0} name)) (ring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_47423 (h0 : topological_space (normed_comm_ring (has_pos_part (has_pos_part linarith.comp)))) : discrete_topology (normed_comm_ring (has_pos_part (has_pos_part linarith.comp))) := sorry --non-trivial
lemma new_lemma_47424 (h0 : has_mem.mem (has_emptyc linarith.comp_source) has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} (has_emptyc.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (has_emptyc.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_47425 (h0 : uniform_space (free_add_monoid (semiring congr_arg_kind))) : separated_space (free_add_monoid (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_47426 (h0 : not (has_mem.mem (with_bot fun_info) has_emptyc.emptyc -> false)) : @normalizer_condition.{0} (with_bot.{0} fun_info) (@finset.pi.empty.{1 0} Type group.{0} (with_bot.{0} fun_info) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_bot.{0} fun_info) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_47427 (h0 : functor.add_const (uniform_space (has_nndist Type)) pos) : @complete_space.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (has_nndist.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_47428 (h0 : function.extfun nat fin) : @is_compactly_generated.{1} (comm_semigroup.{1} Type) (@matrix.vec_empty.{1} (complete_lattice.{1} (comm_semigroup.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_47429 (h0 : topological_space (measurable_space (linear_ordered_semiring congr_arg_kind))) : totally_separated_space (measurable_space (linear_ordered_semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_47430 (h0 : topological_space (has_emptyc (has_top linarith.ineq))) : path_connected_space (has_emptyc (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_47431 (h0 : functor.add_const (topological_space (has_neg pos)) unsigned) : @preirreducible_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_47432 (h0 : topological_space (id (random_gen string_imp))) : totally_separated_space (id (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_47433 (h0 : function.extfun Type topological_space) : @t1_space.{0} (has_edist.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_edist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_47434 (h0 : list (id (has_inv (random_gen fun_info)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_47435 (h0 : functor.add_const (function.extfun Type topological_space) (ring name)) : @preirreducible_space.{0} (has_zero.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (ring.{0} name) h0) (has_zero.{0} name))  := sorry --non-trivial
lemma new_lemma_47436 (h0 : group (has_add (normed_comm_ring (has_add pos)))) : is_cyclic (has_add (normed_comm_ring (has_add pos))) := sorry --non-trivial
lemma new_lemma_47437 (h0 : functor.add_const (ring (add_left_cancel_semigroup num)) empty) : @rank_condition.{0} (add_left_cancel_semigroup.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (add_left_cancel_semigroup.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_47438 (h0 : filter (has_neg (comm_group unsigned))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_47439 (h0 : complete_lattice (normed_lattice_add_comm_group name)) : complete_lattice.is_Sup_finite_compact (normed_lattice_add_comm_group name) := sorry --non-trivial
lemma new_lemma_47440 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (group_with_zero.{0} ennreal) (@function.extfun_app.{2 1} Type add_group.{0} h0 (group_with_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_47441 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @regular_space.{0} (normed_lattice_add_comm_group.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_lattice_add_comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_47442 (h0 : semiring (bin_tree (partial_order congr_arg_kind))) : is_noetherian_ring (bin_tree (partial_order congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_47443 (h0 : topological_space (has_Inf (has_Inf linarith.comp))) : locally_compact_space (has_Inf (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_47444 (h0 : topological_space (ordered_comm_group empty) -> Prop) (h1 : Exists (fun (x : topological_space (ordered_comm_group empty)), h0 x)) : @irreducible_space.{0} (ordered_comm_group.{0} empty) (@classical.some.{1} (topological_space.{0} (ordered_comm_group.{0} empty)) h0 h1)  := sorry --non-trivial
lemma new_lemma_47445 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (canonically_ordered_comm_semiring.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (canonically_ordered_comm_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_47446 (h0 : not (ring (topological_space string.iterator_imp) -> false)) : @is_domain.{0} (topological_space.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (ring.{0} (topological_space.{0} string.iterator_imp)) h0)  := sorry --non-trivial
lemma new_lemma_47447 (h0 : function.extfun Type (functor.add_const (function.extfun Type add_group))) : @is_add_cyclic.{0} (add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type add_group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_group.{0}) linarith.comp (@function.extfun_app.{2 2} Type (functor.add_const.{1 0} (function.extfun.{2 1} Type add_group.{0})) h0 linarith.comp)) (add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_47448 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @totally_separated_space.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_47449 (h0 : not (ring unsigned -> false)) : @rank_condition.{0} unsigned (@classical.by_contradiction'.{1} (ring.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_47450 (h0 : add_monoid (has_nndist (ring (ring environment.implicit_infer_kind)))) : add_monoid.fg (has_nndist (ring (ring environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_47451 (h1 : add_group (ordered_comm_ring char)) : is_add_cyclic (ordered_comm_ring char) := sorry --non-trivial
lemma new_lemma_47452 (h0 : topological_space (complete_distrib_lattice (has_add ennreal))) : topological_space.separable_space (complete_distrib_lattice (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_47453 (h0 : ring (has_add (option unsigned))) : is_domain (has_add (option unsigned)) := sorry --non-trivial
lemma new_lemma_47454 (h0 : topological_space (normed_field (random_gen (random_gen char)))) : t0_space (normed_field (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_47455 (h0 : functor.add_const (topological_space (has_add name)) linarith.comp) : @irreducible_space.{0} (has_add.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_47456 (h0 : functor.add_const (topological_space (has_dist unsigned)) empty) : @locally_compact_space.{0} (has_dist.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_dist.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_47457 (h0 : topological_space (has_Inf (has_neg (has_add (has_add linarith.comp))))) : locally_compact_space (has_Inf (has_neg (has_add (has_add linarith.comp)))) := sorry --non-trivial
lemma new_lemma_47458 (h0 : ring (has_pos_part (has_neg (ordered_ring (has_add pos))))) : rank_condition (has_pos_part (has_neg (ordered_ring (has_add pos)))) := sorry --non-trivial
lemma new_lemma_47459 (h0 : topological_space (ordered_comm_ring (has_pos_part linarith.comp))) : totally_disconnected_space (ordered_comm_ring (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_47460 (h0 : group (comm_group (comm_group unsigned))) : is_simple_group (comm_group (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_47461 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (add_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_47462 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (finset.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} real))  := sorry --non-trivial
lemma new_lemma_47463 (h0 : not (topological_space (has_append char) -> false)) : @totally_disconnected_space.{0} (has_append.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (has_append.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_47464 (h0 : function.extfun Type topological_space) : @t1_space.{0} (mul_zero_class.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (mul_zero_class.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_47465 (h0 : functor.add_const (function.extfun (Type 1) group) linarith.comp) : @is_cyclic.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) group.{1}) linarith.comp h0) (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_47466 (h0 : topological_space (finset (has_nndist linarith.comp))) : totally_separated_space (finset (has_nndist linarith.comp)) := sorry --non-trivial
lemma new_lemma_47467 (h0 : group (simple_graph (has_to_string linarith.comp))) : normalizer_condition (simple_graph (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_47468 (h0 : topological_space (mul_one_class fun_info)) (h1 h2 : set (mul_one_class fun_info)) : is_path_connected (set.diff h1 h2) := sorry --non-trivial
lemma new_lemma_47469 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (distrib_lattice.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (distrib_lattice.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_47470 (h0 : topological_space (has_star (semiring (semiring unsigned)))) : t0_space (has_star (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_47471 (h0 : topological_space (boolean_algebra ennreal)) : discrete_topology (boolean_algebra ennreal) := sorry --non-trivial
lemma new_lemma_47472 (h0 : topological_space (measurable_space (random_gen (random_gen (random_gen linarith.ineq))))) : locally_compact_space (measurable_space (random_gen (random_gen (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_47473 (h0 : ring (has_top (semiring (semiring congr_arg_kind)))) : rank_condition (has_top (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_47474 (h0 : topological_space (has_edist empty)) : totally_disconnected_space (has_edist empty) := sorry --non-trivial
lemma new_lemma_47475 (h0 : topological_space (has_union (semiring (semiring (semiring empty))))) : preirreducible_space (has_union (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_47476 (h0 : ordered_add_comm_monoid (comm_group (option (option ennreal)))) : archimedean (comm_group (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_47477 (h0 : function.extfun Type (functor.add_const (fin has_zero.zero))) : @irreducible_space.{1} (ordered_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@matrix.vec_empty.{2} (function.extfun.{3 2} (Type 1) topological_space.{1}) (@functor.add_const.run.{0 0} (fin (@has_zero.zero.{0} nat nat.has_zero)) real (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (fin (@has_zero.zero.{0} nat nat.has_zero))) h0 real))) (ordered_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_47478 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_47479 (h0 : ordered_add_comm_monoid (omega_complete_partial_order congr_arg_kind)) : archimedean (omega_complete_partial_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_47480 (h0 : topological_space (has_to_string (has_add linarith.comp))) : regular_space (has_to_string (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_47481 (h0 : topological_space (generalized_boolean_algebra (has_Inf linarith.comp))) : preirreducible_space (generalized_boolean_algebra (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_47482 (h0 : topological_space (boolean_algebra.core (has_add name))) : locally_compact_space (boolean_algebra.core (has_add name)) := sorry --non-trivial
lemma new_lemma_47483 (h0 : group (canonically_ordered_monoid (finset (finset linarith.comp)))) : is_simple_group (canonically_ordered_monoid (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_47484 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (preorder unsigned)) := sorry --non-trivial
lemma new_lemma_47485 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (has_dist num)) := sorry --non-trivial
lemma new_lemma_47486 (h0 : functor.add_const (topological_space (has_nndist ennreal)) unsigned) : @preirreducible_space.{0} (has_nndist.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_47487 (h0 : functor.add_const (topological_space (has_pos_part Type)) pos) : @loc_path_connected_space.{1} (has_pos_part.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_pos_part.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_47488 (h0 : topological_space (has_to_string (has_add pos))) : locally_compact_space (has_to_string (has_add pos)) := sorry --non-trivial
lemma new_lemma_47489 (h0 : ring (semi_normed_ring (random_gen linarith.ineq))) : strong_rank_condition (semi_normed_ring (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_47490 (h0 : ring (comm_group name)) : is_domain (comm_group name) := sorry --non-trivial
lemma new_lemma_47491 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (finset.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (finset.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_47492 (h0 : fin has_zero.zero) : @id.{1} Prop (@ulower.up.{0} Prop encodable.Prop (@id.{1} (@ulower.{0} Prop encodable.Prop) (@matrix.vec_empty.{0} (@ulower.{0} Prop encodable.Prop) h0)))  := sorry --non-trivial
lemma new_lemma_47493 (h0 : functor.add_const (topological_space (has_to_string linarith.comp)) Type) : @loc_path_connected_space.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_to_string.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_47494 (h0 : not (filter (has_nnnorm fun_info) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_47495 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @preconnected_space.{0} (has_Inf.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (has_Inf.{0} pos)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_47496 (h0 : functor.add_const (topological_space (ordered_ring congr_arg_kind)) empty) : @topological_space.separable_space.{0} (ordered_ring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_47497 (h0 : group (ring (add_cancel_monoid linarith.comp))) : group.fg (ring (add_cancel_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_47498 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_bot.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_bot.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_47499 (h0 : functor.comp add_group has_neg name) : @is_add_cyclic.{0} (has_neg.{0} name) (@functor.comp.run.{0 0 0} add_group.{0} has_neg.{0} name h0)  := sorry --non-trivial
lemma new_lemma_47500 (h0 : topological_space (has_pos_part (has_pos_part pos))) : totally_disconnected_space (has_pos_part (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_47501 (h0 : functor.add_const (ring (cancel_monoid Type)) ennreal) : @is_principal_ideal_ring.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (cancel_monoid.{1} Type)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_47502 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (left_cancel_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (left_cancel_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_47503 (h0 : topological_space (is_R_or_C unsigned)) : topological_space.separable_space (is_R_or_C unsigned) := sorry --non-trivial
lemma new_lemma_47504 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @t1_space.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_47505 (h0 : ereal -> Prop) (h1 : filter ereal) : filter.eventually h0 h1 := sorry --non-trivial
lemma new_lemma_47506 (h0 : functor.add_const (function.extfun Type topological_space) environment.implicit_infer_kind) : @preirreducible_space.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) environment.implicit_infer_kind h0) (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_47507 (h0 : not (topological_space (metric_space linarith.comp) -> false)) : @irreducible_space.{0} (metric_space.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (metric_space.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_47508 (h0 : topological_space (non_unital_non_assoc_semiring (uniform_space linarith.ineq))) : t0_space (non_unital_non_assoc_semiring (uniform_space linarith.ineq)) := sorry --non-trivial
lemma new_lemma_47509 (h0 : topological_space (comm_semigroup (sub_neg_monoid real))) : irreducible_space (comm_semigroup (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_47510 (h0 : functor.add_const (topological_space (has_neg_part name)) unsigned) : @path_connected_space.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_47511 (h0 : has_mem.mem (complete_semilattice_Sup congr_arg_kind) has_emptyc.emptyc) : @strong_rank_condition.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type ring.{0} (complete_semilattice_Sup.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_47512 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (semigroup linarith.comp)) := sorry --non-trivial
lemma new_lemma_47513 (h0 : topological_space (mul_one_class (add_comm_semigroup (add_comm_semigroup string.iterator_imp)))) (h1 : set (mul_one_class (add_comm_semigroup (add_comm_semigroup string.iterator_imp)))) : is_path_connected h1 := sorry --non-trivial
lemma new_lemma_47514 (h0 : functor.add_const (ring (add_cancel_monoid linarith.comp)) linarith.comp) : @is_domain.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (add_cancel_monoid.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_47515 (h0 : function.extfun Type (prod (group_with_zero num))) : id_rel (function.extfun_app h0 (group_with_zero num)) := sorry --non-trivial
lemma new_lemma_47516 (h0 : complete_lattice (has_norm (has_norm (random_gen congr_arg_kind)))) : is_atomistic (has_norm (has_norm (random_gen congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_47517 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem ring)) : @rank_condition.{0} num (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) ring.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) num)  := sorry --non-trivial
lemma new_lemma_47518 (h0 : topological_space (add_left_cancel_semigroup (option empty))) : irreducible_space (add_left_cancel_semigroup (option empty)) := sorry --non-trivial
lemma new_lemma_47519 (h0 : complete_lattice (boolean_algebra (finset linarith.comp))) : is_atomistic (boolean_algebra (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_47520 (h0 : has_mem.mem add_group has_emptyc.emptyc) : @is_add_cyclic.{0} linarith.comp (@function.extfun_app.{2 1} Type add_group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) add_group.{0} h0) linarith.comp)  := sorry --non-trivial
lemma new_lemma_47521 (h0 : complete_lattice (with_bot (has_top num))) : is_compactly_generated (with_bot (has_top num)) := sorry --non-trivial
lemma new_lemma_47522 (h0 : functor.add_const (topological_space (boolean_algebra Type)) (finset linarith.comp)) : @t1_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.{1} Type)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_47523 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @sequential_space.{0} (sub_neg_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (sub_neg_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_47524 (h0 : complete_lattice (normed_group (has_top (has_top (has_top (has_top linarith.comp_source)))))) : is_atomistic (normed_group (has_top (has_top (has_top (has_top linarith.comp_source))))) := sorry --non-trivial
lemma new_lemma_47525 (h0 : ring (as_linear_order (option empty))) : is_principal_ideal_ring (as_linear_order (option empty)) := sorry --non-trivial
lemma new_lemma_47526 (h0 : not (topological_space (semiring linarith.comp) -> false)) : @normal_space.{0} (semiring.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (semiring.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_47527 (h0 : add_monoid (boolean_algebra (finset (has_pos_part linarith.comp)))) : add_monoid.fg (boolean_algebra (finset (has_pos_part linarith.comp))) := sorry --non-trivial
lemma new_lemma_47528 (h0 : semiring (has_add (has_to_string (option (option (option pos)))))) : is_noetherian_ring (has_add (has_to_string (option (option (option pos))))) := sorry --non-trivial
lemma new_lemma_47529 (h0 : functor.add_const (ordered_add_comm_monoid (semigroup environment.implicit_infer_kind)) (finset linarith.comp)) : @archimedean.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (semigroup.{0} environment.implicit_infer_kind)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_47530 (h0 : functor.add_const (ring (boolean_algebra linarith.comp)) (finset linarith.comp)) : @is_principal_ideal_ring.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.{0} linarith.comp)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_47531 (h0 : add_group (ring (has_neg (has_Inf (has_neg linarith.comp))))) : is_add_cyclic (ring (has_neg (has_Inf (has_neg linarith.comp)))) := sorry --non-trivial
lemma new_lemma_47532 (h0 : functor.add_const (ring (ordered_comm_ring name)) pos) : @is_principal_ideal_ring.{0} (ordered_comm_ring.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (ordered_comm_ring.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_47533 (h0 : group (option num)) : normalizer_condition (option num) := sorry --non-trivial
lemma new_lemma_47534 (h0 : function.extfun nat fin) : @totally_disconnected_space.{1} (sub_neg_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (sub_neg_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_47535 (h0 : topological_space (plift (semiring empty))) : topological_space.separable_space (plift (semiring empty)) := sorry --non-trivial
lemma new_lemma_47536 (h0 : ring (canonically_ordered_comm_semiring (finset ennreal))) : is_principal_ideal_ring (canonically_ordered_comm_semiring (finset ennreal)) := sorry --non-trivial
lemma new_lemma_47537 (h0 : filter (linear_ordered_comm_ring (semiring (semiring (semiring (semiring (semiring unsigned))))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_47538 (h0 : list (semigroup (has_to_string (comm_group unsigned)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_47539 (h0 : functor.comp topological_space has_neg name) : @preconnected_space.{0} (has_neg.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} name h0)  := sorry --non-trivial
lemma new_lemma_47540 (h0 : functor.add_const (filter (add_cancel_monoid pos)) (has_pos_part linarith.comp)) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_47541 (h0 : topological_space (has_emptyc (has_norm (has_norm (has_norm linarith.ineq))))) : path_connected_space (has_emptyc (has_norm (has_norm (has_norm linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_47542 (h0 : topological_space string.iterator_imp) (h1 : has_sub string.iterator_imp) : has_continuous_sub string.iterator_imp := sorry --non-trivial
lemma new_lemma_47543 (h0 : group (has_to_string (complete_semilattice_Sup linarith.comp))) : is_simple_group (has_to_string (complete_semilattice_Sup linarith.comp)) := sorry --non-trivial
lemma new_lemma_47544 (h0 : function.extfun Type ring) : @rank_condition.{0} (linear_ordered_field.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_ordered_field.{0} pos))  := sorry --non-trivial
lemma new_lemma_47545 (h1 : complete_lattice (linear_ordered_comm_group_with_zero string_imp)) : is_compactly_generated (linear_ordered_comm_group_with_zero string_imp) := sorry --non-trivial
lemma new_lemma_47546 (h0 : topological_space (topological_space (random_gen reducibility_hints))) : totally_disconnected_space (topological_space (random_gen reducibility_hints)) := sorry --non-trivial
lemma new_lemma_47547 (h0 : ring (pseudo_metric_space (option pos))) : strong_rank_condition (pseudo_metric_space (option pos)) := sorry --non-trivial
lemma new_lemma_47548 (h1 : function.extfun Type topological_space) : @totally_separated_space.{0} (normed_group.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (normed_group.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_47549 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (simple_graph congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_47550 (h0 : ring (normed_lattice_add_comm_group (has_add Type))) : is_principal_ideal_ring (normed_lattice_add_comm_group (has_add Type)) := sorry --non-trivial
lemma new_lemma_47551 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (finset.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (finset.{0} name))  := sorry --non-trivial
lemma new_lemma_47552 (h0 : uniform_space (non_unital_non_assoc_semiring (mul_one_class to_additive.value_type))) : complete_space (non_unital_non_assoc_semiring (mul_one_class to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_47553 (h0 : group (dlist fun_info)) : is_cyclic (dlist fun_info) := sorry --non-trivial
lemma new_lemma_47554 (h0 : function.extfun Type measurable_space) (h1 : set (has_inv linarith.comp_source)) : @measurable_set.{0} (has_inv.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type measurable_space.{0} (@id.{2} (function.extfun.{2 1} Type measurable_space.{0}) h0) (has_inv.{0} linarith.comp_source)) h1  := sorry --non-trivial
lemma new_lemma_47555 (h0 : functor.add_const (ordered_comm_monoid (complete_distrib_lattice pos)) num) : @has_exists_mul_of_le.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (complete_distrib_lattice.{0} pos)) num h0)  := sorry --non-trivial
lemma new_lemma_47556 (h0 : uniform_space (has_inv (has_nnnorm linarith.ineq))) : complete_space (has_inv (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_47557 (h0 : function.extfun Type group) : @is_simple_group.{0} (has_nndist.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} h0 (has_nndist.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_47558 (h0 : not (ring (topological_space to_additive.value_type) -> false)) : @is_domain.{0} (topological_space.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (topological_space.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_47559 (h0 : uniform_space (has_ssubset linarith.comp_source) -> Prop) (h1 : Exists (fun (x : uniform_space (has_ssubset linarith.comp_source)), h0 x)) : @complete_space.{0} (has_ssubset.{0} linarith.comp_source) (@classical.some.{1} (uniform_space.{0} (has_ssubset.{0} linarith.comp_source)) h0 h1)  := sorry --non-trivial
lemma new_lemma_47560 (h0 : topological_space (has_to_string (has_to_string Type))) : sequential_space (has_to_string (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_47561 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @sequential_space.{0} (has_neg.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_neg.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_47562 (h0 : functor.add_const (monoid (add_cancel_monoid pos)) (has_to_string environment.implicit_infer_kind)) : @monoid.fg.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (monoid.{0} (add_cancel_monoid.{0} pos)) (has_to_string.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_47563 (h0 : functor.add_const (group (has_neg_part Type)) pos) : @is_simple_group.{1} (has_neg_part.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (has_neg_part.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_47564 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (ring.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (ring.{0} name))  := sorry --non-trivial
lemma new_lemma_47565 (h0 : topological_space (measurable_space (semiring (semiring (semiring empty))))) : discrete_topology (measurable_space (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_47566 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (left_cancel_semigroup.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (left_cancel_semigroup.{0} num))  := sorry --non-trivial
lemma new_lemma_47567 (h0 : functor.add_const (add_group (has_add Type)) environment.implicit_infer_kind) : @is_add_cyclic.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (add_group.{1} (has_add.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_47568 (h0 : topological_space (normed_group (random_gen to_additive.value_type))) : totally_disconnected_space (normed_group (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_47569 (h0 : functor.add_const (topological_space (ordered_ring num)) congr_arg_kind) : @preirreducible_space.{0} (ordered_ring.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_47570 (h0 : add_group (complete_semilattice_Sup (has_norm (random_gen empty)))) : is_add_cyclic (complete_semilattice_Sup (has_norm (random_gen empty))) := sorry --non-trivial
lemma new_lemma_47571 (h0 : functor.add_const (ring (has_dist empty)) empty) : @strong_rank_condition.{0} (has_dist.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (has_dist.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_47572 (h0 : uniform_space (distrib (comm_ring char))) : complete_space (distrib (comm_ring char)) := sorry --non-trivial
lemma new_lemma_47573 (h0 : ring (has_inv (random_gen fun_info))) : strong_rank_condition (has_inv (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_47574 (h0 : topological_space (ordered_comm_ring (has_Inf (sub_neg_monoid (has_pos_part Type))))) : discrete_topology (ordered_comm_ring (has_Inf (sub_neg_monoid (has_pos_part Type)))) := sorry --non-trivial
lemma new_lemma_47575 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_47576 (h0 : uniform_space (ordered_comm_ring (has_neg (has_neg (has_neg linarith.comp))))) : separated_space (ordered_comm_ring (has_neg (has_neg (has_neg linarith.comp)))) := sorry --non-trivial
lemma new_lemma_47577 (h0 : uniform_space (add_cancel_monoid (has_bot empty))) : separated_space (add_cancel_monoid (has_bot empty)) := sorry --non-trivial
lemma new_lemma_47578 (h1 : function.extfun Type topological_space) : @locally_compact_space.{0} (with_one.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (with_one.{0} num))  := sorry --non-trivial
lemma new_lemma_47579 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (measurable_space.dynkin_system.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (measurable_space.dynkin_system.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_47580 (h0 : topological_space (has_nndist (has_add (finset name)))) : topological_space.separable_space (has_nndist (has_add (finset name))) := sorry --non-trivial
lemma new_lemma_47581 (h0 : part char -> part char -> Prop) : is_total (part char) h0 := sorry --non-trivial
lemma new_lemma_47582 (h0 : functor.add_const (ordered_add_comm_monoid (comm_group pos)) (has_to_string Type)) : @archimedean.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 1} (ordered_add_comm_monoid.{0} (comm_group.{0} pos)) (has_to_string.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_47583 (h0 : topological_space (add_semigroup congr_arg_kind)) : path_connected_space (add_semigroup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_47584 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (free_add_monoid.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (free_add_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_47585 (h0 : filter (semigroup linarith.comp)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_47586 (h0 : group (boolean_algebra (has_add (has_add name)))) : group.fg (boolean_algebra (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_47587 (h1 : topological_space (id (with_bot (random_gen (with_bot string_imp))))) : locally_compact_space (id (with_bot (random_gen (with_bot string_imp)))) := sorry --non-trivial
lemma new_lemma_47588 (h0 : functor.add_const (topological_space (complete_distrib_lattice linarith.comp)) (has_neg pos)) : @irreducible_space.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} linarith.comp)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_47589 (h0 : functor.add_const (topological_space (finset linarith.comp)) Type) : @normal_space.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (finset.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_47590 (h0 : group (random_gen (id linarith.comp))) : normalizer_condition (random_gen (id linarith.comp)) := sorry --non-trivial
lemma new_lemma_47591 (h0 : functor.add_const (list (normed_comm_ring linarith.comp)) Type) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_47592 (h0 : topological_space (canonically_linear_ordered_add_monoid (add_comm_monoid name))) : topological_space.separable_space (canonically_linear_ordered_add_monoid (add_comm_monoid name)) := sorry --non-trivial
lemma new_lemma_47593 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (ordered_cancel_add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (ordered_cancel_add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_47594 (h0 : ring (finset (ring (normed_comm_ring (has_Inf environment.implicit_infer_kind))))) : is_domain (finset (ring (normed_comm_ring (has_Inf environment.implicit_infer_kind)))) := sorry --non-trivial
lemma new_lemma_47595 (h0 : topological_space (has_to_string (has_neg Type))) : preirreducible_space (has_to_string (has_neg Type)) := sorry --non-trivial
lemma new_lemma_47596 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @monoid.fg.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) monoid.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 monoid.{1}) (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_47597 (h0 : has_lt (non_unital_non_assoc_semiring (mul_one_class to_additive.value_type))) : no_max_order (non_unital_non_assoc_semiring (mul_one_class to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_47598 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (sub_neg_monoid.{0} (has_Inf.{0} name)) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (sub_neg_monoid.{0} (has_Inf.{0} name)))  := sorry --non-trivial
lemma new_lemma_47599 (h1 : group (metric_space to_additive.value_type)) : is_cyclic (metric_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_47600 (h0 : functor.add_const (finset (cancel_monoid name)) (add_comm_monoid (has_add (add_comm_monoid pos)))) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_47601 (h0 : functor.add_const (functor.comp group canonically_ordered_comm_semiring Type) unsigned) : @is_simple_group.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.comp.run.{1 1 1} group.{1} canonically_ordered_comm_semiring.{1} Type (@functor.add_const.run.{1 0} (functor.comp.{1 1 1} group.{1} canonically_ordered_comm_semiring.{1} Type) unsigned h0))  := sorry --non-trivial
lemma new_lemma_47602 (h0 : monoid (complete_distrib_lattice (has_add name))) : monoid.fg (complete_distrib_lattice (has_add name)) := sorry --non-trivial
lemma new_lemma_47603 (h0 : ring (ordered_comm_monoid to_additive.value_type)) : rank_condition (ordered_comm_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_47604 (h0 : topological_space (semigroup (normed_comm_ring pos))) : sequential_space (semigroup (normed_comm_ring pos)) := sorry --non-trivial
lemma new_lemma_47605 (h0 : ring (finset (option empty))) : rank_condition (finset (option empty)) := sorry --non-trivial
lemma new_lemma_47606 (h0 : ring (has_append (add_cancel_comm_monoid (mul_one_class char)))) : strong_rank_condition (has_append (add_cancel_comm_monoid (mul_one_class char))) := sorry --non-trivial
lemma new_lemma_47607 (h2 : ring (nondiscrete_normed_field linarith.ineq)) : is_domain (nondiscrete_normed_field linarith.ineq) := sorry --non-trivial
lemma new_lemma_47608 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @path_connected_space.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_47609 (h0 h1 : string.iterator_imp -> enat) : set.separates_points (set.Ioc h0 h1) := sorry --non-trivial
lemma new_lemma_47610 (h1 : not (topological_space linarith.comp -> false)) : @totally_disconnected_space.{0} linarith.comp (@classical.by_contradiction'.{1} (topological_space.{0} linarith.comp) h1)  := sorry --non-trivial
lemma new_lemma_47611 (h0 : add_group (complete_distrib_lattice (option pos))) : is_add_cyclic (complete_distrib_lattice (option pos)) := sorry --non-trivial
lemma new_lemma_47612 (h0 : topological_space (omega_complete_partial_order unsigned)) : loc_path_connected_space (omega_complete_partial_order unsigned) := sorry --non-trivial
lemma new_lemma_47613 (h0 : topological_space (monoid_with_zero ennreal)) : path_connected_space (monoid_with_zero ennreal) := sorry --non-trivial
lemma new_lemma_47614 (h2 : group (has_emptyc num)) : normalizer_condition (has_emptyc num) := sorry --non-trivial
lemma new_lemma_47615 (h0 : not (complete_lattice (has_top (semiring congr_arg_kind)) -> false)) : @is_atomistic.{0} (has_top.{0} (semiring.{0} congr_arg_kind)) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_top.{0} (semiring.{0} congr_arg_kind))) h0)  := sorry --non-trivial
lemma new_lemma_47616 (h0 : ring (has_append (has_lt linarith.comp_source))) : is_domain (has_append (has_lt linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_47617 (h0 : topological_space (has_to_string (add_comm_monoid Type))) : path_connected_space (has_to_string (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_47618 (h0 : ring (left_cancel_monoid unsigned)) : is_principal_ideal_ring (left_cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_47619 (h0 : set (has_div environment.projection_info)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_47620 (h0 : add_monoid (cancel_monoid (option empty))) : add_monoid.fg (cancel_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_47621 (h1 : add_group (has_emptyc congr_arg_kind)) : is_add_cyclic (has_emptyc congr_arg_kind) := sorry --non-trivial
lemma new_lemma_47622 (h0 : functor.add_const (ring (option unsigned)) num) : @is_domain.{0} (option.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (option.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_47623 (h0 : has_mem.mem (with_bot fun_info) has_emptyc.emptyc) : @is_domain.{0} (with_bot.{0} fun_info) (@finset.pi.empty.{1 0} Type ring.{0} (with_bot.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_47624 (h0 : functor.add_const (function.extfun Type ring) Type) : @rank_condition.{0} (has_nndist.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ring.{0}) Type h0) (has_nndist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_47625 (h0 : ring (ring (has_add environment.implicit_infer_kind))) : rank_condition (ring (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_47626 (h0 : group (add_left_cancel_semigroup empty)) : group.fg (add_left_cancel_semigroup empty) := sorry --non-trivial
lemma new_lemma_47627 (h0 : not (function.extfun Type topological_space -> false)) : @irreducible_space.{0} (add_group.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (add_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_47628 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} (non_assoc_semiring.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (non_assoc_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_47629 (h0 : functor.add_const (topological_space (has_neg_part name)) Type) : @preconnected_space.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg_part.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_47630 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_top.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_top.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_47631 (h0 : complete_lattice (ordered_cancel_add_comm_monoid congr_arg_kind)) : complete_lattice.is_Sup_finite_compact (ordered_cancel_add_comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_47632 (h0 : topological_space (has_neg_part (option unsigned))) : irreducible_space (has_neg_part (option unsigned)) := sorry --non-trivial
lemma new_lemma_47633 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_neg_part Type)) name) : @unique_factorization_monoid.{1} (has_neg_part.{1} Type) (@functor.add_const.run.{1 0} (cancel_comm_monoid_with_zero.{1} (has_neg_part.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_47634 (h0 : monoid (metric_space (has_norm linarith.comp))) : monoid.fg (metric_space (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_47635 (h0 : topological_space (has_to_string pos)) : loc_path_connected_space (has_to_string pos) := sorry --non-trivial
lemma new_lemma_47636 (h0 : topological_space (ordered_ring (has_neg congr_arg_kind))) : normal_space (ordered_ring (has_neg congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_47637 (h0 : uniform_space (ordered_comm_ring (has_pos_part real))) : separated_space (ordered_comm_ring (has_pos_part real)) := sorry --non-trivial
lemma new_lemma_47638 (h0 : topological_space (boolean_algebra.core (finset ennreal))) : topological_space.separable_space (boolean_algebra.core (finset ennreal)) := sorry --non-trivial
lemma new_lemma_47639 (h0 : topological_space (has_zero (semigroup environment.implicit_infer_kind))) : t1_space (has_zero (semigroup environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_47640 (h0 : topological_space (simple_graph fun_info)) : totally_disconnected_space (simple_graph fun_info) := sorry --non-trivial
lemma new_lemma_47641 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (has_to_string.{0} ennreal) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (has_to_string.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_47642 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (simple_graph.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (simple_graph.{0} name))  := sorry --non-trivial
lemma new_lemma_47643 (h0 : filter (semigroup (has_to_string (has_to_string num)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_47644 (h0 : add_monoid (normed_lattice_add_comm_group (has_add (has_Inf pos)))) : add_monoid.fg (normed_lattice_add_comm_group (has_add (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_47645 (h0 : functor.add_const (topological_space (mul_zero_class pos)) Type) : @sequential_space.{0} (mul_zero_class.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (mul_zero_class.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_47646 (h0 : function.extfun Type group) : @group.fg.{0} (finset.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (finset.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_47647 (h1 : string_imp -> string_imp -> bool) : is_dec_refl h1 := sorry --non-trivial
lemma new_lemma_47648 (h1 : topological_space (has_norm (has_inv char))) : totally_disconnected_space (has_norm (has_inv char)) := sorry --non-trivial
lemma new_lemma_47649 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (linear_ordered_semiring.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (linear_ordered_semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_47650 (h0 : functor.add_const (complete_lattice (has_neg name)) (mul_zero_class pos)) : @complete_lattice.is_Sup_finite_compact.{0} (has_neg.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_neg.{0} name)) (mul_zero_class.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_47651 (h0 : functor.comp topological_space mul_zero_class pos) : @normal_space.{0} (mul_zero_class.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} mul_zero_class.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_47652 (h0 : ring (filter num)) : is_principal_ideal_ring (filter num) := sorry --non-trivial
lemma new_lemma_47653 (h0 : cancel_comm_monoid_with_zero (group_with_zero (option ennreal))) : unique_factorization_monoid (group_with_zero (option ennreal)) := sorry --non-trivial
lemma new_lemma_47654 (h0 : topological_space (add_left_cancel_semigroup (option unsigned))) : loc_path_connected_space (add_left_cancel_semigroup (option unsigned)) := sorry --non-trivial
lemma new_lemma_47655 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @totally_disconnected_space.{0} (has_emptyc.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) topological_space.{0}) (has_emptyc.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_47656 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @normal_space.{0} (has_neg.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (has_neg.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_47657 (h0 : list (has_zero (has_neg pos))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_47658 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (finset.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (finset.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_47659 (h0 : topological_space (complete_semilattice_Sup (has_inv char))) : totally_disconnected_space (complete_semilattice_Sup (has_inv char)) := sorry --non-trivial
lemma new_lemma_47660 (h0 : ring (has_Sup congr_arg_kind)) : is_principal_ideal_ring (has_Sup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_47661 (h0 : ring (add_cancel_monoid (measurable_space linarith.comp))) : strong_rank_condition (add_cancel_monoid (measurable_space linarith.comp)) := sorry --non-trivial
lemma new_lemma_47662 (h0 : group (linear_ordered_comm_monoid_with_zero (option empty))) : group.fg (linear_ordered_comm_monoid_with_zero (option empty)) := sorry --non-trivial
lemma new_lemma_47663 (h0 : ring (boolean_algebra.core (option (option unsigned)))) : is_principal_ideal_ring (boolean_algebra.core (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_47664 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_compactly_generated.{0} (has_ssubset.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (has_ssubset.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_47665 (h0 : add_monoid (linear_ordered_comm_monoid_with_zero congr_arg_kind)) : add_monoid.fg (linear_ordered_comm_monoid_with_zero congr_arg_kind) := sorry --non-trivial
lemma new_lemma_47666 (h0 : functor.add_const (topological_space (as_linear_order empty)) empty) : @normal_space.{0} (as_linear_order.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (as_linear_order.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_47667 (h0 : add_group (bin_tree num)) : is_add_cyclic (bin_tree num) := sorry --non-trivial
lemma new_lemma_47668 (h0 : uniform_space (semigroup (has_pos_part (has_pos_part pos)))) : complete_space (semigroup (has_pos_part (has_pos_part pos))) := sorry --non-trivial
lemma new_lemma_47669 (h0 : not (topological_space environment.projection_info -> false)) : @totally_separated_space.{0} environment.projection_info (@classical.by_contradiction'.{1} (topological_space.{0} environment.projection_info) h0)  := sorry --non-trivial
lemma new_lemma_47670 (h0 : topological_space (bin_tree (semiring congr_arg_kind))) : normal_space (bin_tree (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_47671 (h0 : ring (measurable_space (semiring unsigned))) : is_domain (measurable_space (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_47672 (h0 : functor.add_const (semiring (finset name)) (has_neg linarith.comp)) : @is_noetherian_ring.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (semiring.{0} (finset.{0} name)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_47673 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (linear_ordered_semiring.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_47674 (h0 : topological_space (boolean_algebra.core (boolean_algebra name))) : normal_space (boolean_algebra.core (boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_47675 (h0 : semiring (measure_theory.measure_space (semiring (semiring empty)))) : is_noetherian_ring (measure_theory.measure_space (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_47676 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (comm_group.{0} name) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (comm_group.{0} name))  := sorry --non-trivial
lemma new_lemma_47677 (h0 : ring enat) (h1 : set (ring.positive_cone enat)) : set.finite h1 := sorry --non-trivial
lemma new_lemma_47678 (h0 : complete_lattice (denumerable (distrib (random_gen linarith.comp_source)))) : is_compactly_generated (denumerable (distrib (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_47679 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (distrib_lattice.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 topological_space.{0}) (distrib_lattice.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_47680 (h0 : function.extfun (finset Type) (has_mem.mem (with_bot empty))) : @locally_compact_space.{0} (with_bot.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_bot.{0} empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_bot.{0} empty)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_47681 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (ring pos)) := sorry --non-trivial
lemma new_lemma_47682 (h1 : set (has_le std_gen)) : set.finite h1 := sorry --non-trivial
lemma new_lemma_47683 (h1 : add_group (has_emptyc linarith.comp_source)) : is_add_cyclic (has_emptyc linarith.comp_source) := sorry --non-trivial
lemma new_lemma_47684 (h0 : not (uniform_space (complete_linear_order congr_arg_kind) -> false)) : @complete_space.{0} (complete_linear_order.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (uniform_space.{0} (complete_linear_order.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_47685 (h0 : list (random_gen (comm_ring (comm_ring to_additive.value_type)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_47686 (h0 : topological_space (id linarith.comp)) : discrete_topology (id linarith.comp) := sorry --non-trivial
lemma new_lemma_47687 (h1 : ring (with_one (has_top (has_norm fun_info)))) : strong_rank_condition (with_one (has_top (has_norm fun_info))) := sorry --non-trivial
lemma new_lemma_47688 (h0 : filter (has_add char)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_47689 (h0 : linarith.comp_source -> linarith.comp_source -> Prop) : is_antisymm linarith.comp_source h0 := sorry --non-trivial
lemma new_lemma_47690 (h0 : semiring (complete_distrib_lattice (option (option (option (option (option ennreal))))))) : is_noetherian_ring (complete_distrib_lattice (option (option (option (option (option ennreal)))))) := sorry --non-trivial
lemma new_lemma_47691 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_47692 (h0 : fin has_zero.zero) : @totally_separated_space.{0} (simple_graph.{0} (has_add.{0} linarith.comp)) (@matrix.vec_empty.{0} (topological_space.{0} (simple_graph.{0} (has_add.{0} linarith.comp))) h0)  := sorry --non-trivial
lemma new_lemma_47693 (h0 : complete_lattice (preorder (option (option (option empty))))) : is_compactly_generated (preorder (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_47694 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (ordered_cancel_add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_cancel_add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_47695 (h0 : functor.add_const (topological_space (generalized_boolean_algebra pos)) name) : @irreducible_space.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_47696 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @add_monoid.fg.{0} (add_right_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) add_monoid.{0}) (add_right_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_47697 (h0 : filter (has_inter (option ennreal))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_47698 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @group.fg.{0} (@id.{2} Type to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) group.{0}) (@id.{2} Type to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_47699 (h0 : topological_space (semigroup (has_Inf pos))) : t0_space (semigroup (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_47700 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (comm_semigroup.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (comm_semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_47701 (h0 : complete_lattice (has_edist unsigned)) : complete_lattice.is_Sup_finite_compact (has_edist unsigned) := sorry --non-trivial
lemma new_lemma_47702 (h0 : ordered_add_comm_monoid (add_semigroup congr_arg_kind)) : archimedean (add_semigroup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_47703 (h0 : fin has_zero.zero) : @complete_space.{0} (has_pos_part.{0} real) (@function.extfun_app.{2 1} Type uniform_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type uniform_space.{0}) h0) (has_pos_part.{0} real))  := sorry --non-trivial
lemma new_lemma_47704 (h1 : not (topological_space (normed_field linarith.ineq) -> false)) : @totally_disconnected_space.{0} (normed_field.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_field.{0} linarith.ineq)) h1)  := sorry --non-trivial
lemma new_lemma_47705 (h0 : functor.add_const (ordered_add_comm_monoid (boolean_algebra linarith.comp)) Type) : @archimedean.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 1} (ordered_add_comm_monoid.{0} (boolean_algebra.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_47706 (h0 : ring (comm_ring (has_nnnorm (has_nnnorm (denumerable reducibility_hints))))) : is_domain (comm_ring (has_nnnorm (has_nnnorm (denumerable reducibility_hints)))) := sorry --non-trivial
lemma new_lemma_47707 (h0 : uniform_space (has_zero name)) : separated_space (has_zero name) := sorry --non-trivial
lemma new_lemma_47708 (h0 : not (topological_space (linear_ordered_semiring unsigned) -> false)) : @irreducible_space.{0} (linear_ordered_semiring.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_semiring.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_47709 (h0 : functor.add_const (complete_lattice (ordered_cancel_add_comm_monoid empty)) unsigned) : @is_compactly_generated.{0} (ordered_cancel_add_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ordered_cancel_add_comm_monoid.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_47710 (h0 : group (complete_semilattice_Sup (random_gen (random_gen char)))) : group.fg (complete_semilattice_Sup (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_47711 (h0 : ring (semigroup (option unsigned))) : strong_rank_condition (semigroup (option unsigned)) := sorry --non-trivial
lemma new_lemma_47712 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (boolean_algebra.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (boolean_algebra.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_47713 (h0 : semiring (has_union num)) : is_noetherian_ring (has_union num) := sorry --non-trivial
lemma new_lemma_47714 (h0 : fin has_zero.zero) : @is_add_cyclic.{0} (ordered_comm_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (add_group.{0} (ordered_comm_monoid.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_47715 (h0 : ring (has_neg (ring (has_zero pos)))) : is_domain (has_neg (ring (has_zero pos))) := sorry --non-trivial
lemma new_lemma_47716 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (normed_lattice_add_comm_group.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_lattice_add_comm_group.{0} name))  := sorry --non-trivial
lemma new_lemma_47717 (h0 : functor.add_const (list (complete_distrib_lattice Type)) linarith.comp) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_47718 (h0 : ring (semigroup (has_neg (ring pos)))) : rank_condition (semigroup (has_neg (ring pos))) := sorry --non-trivial
lemma new_lemma_47719 (h0 : topological_space (has_one (has_norm empty))) : discrete_topology (has_one (has_norm empty)) := sorry --non-trivial
lemma new_lemma_47720 (h0 : functor.add_const (topological_space (add_group unsigned)) num) : @t0_space.{0} (add_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_group.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_47721 (h1 : ring (has_div reducibility_hints)) : rank_condition (has_div reducibility_hints) := sorry --non-trivial
lemma new_lemma_47722 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (simple_graph pos)) := sorry --non-trivial
lemma new_lemma_47723 (h0 : fin has_zero.zero) : @has_exists_mul_of_le.{0} (ordered_comm_monoid.{0} (has_Inf.{0} (boolean_algebra.core.{0} pos))) (@matrix.vec_empty.{0} (ordered_comm_monoid.{0} (ordered_comm_monoid.{0} (has_Inf.{0} (boolean_algebra.core.{0} pos)))) h0)  := sorry --non-trivial
lemma new_lemma_47724 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (free_add_monoid.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (free_add_monoid.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_47725 (h0 : add_monoid (normed_lattice_add_comm_group (has_add (has_bot Type)))) : add_monoid.fg (normed_lattice_add_comm_group (has_add (has_bot Type))) := sorry --non-trivial
lemma new_lemma_47726 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (normed_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_47727 (h0 : topological_space Type) : path_connected_space Type := sorry --non-trivial
lemma new_lemma_47728 (h2 : group fun_info) : group.fg fun_info := sorry --non-trivial
lemma new_lemma_47729 (h0 : semiring (has_pos_part (has_neg linarith.comp))) : is_noetherian_ring (has_pos_part (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_47730 (h0 : function.extfun Type (functor.comp add_monoid mul_zero_class)) : @add_monoid.fg.{0} (mul_zero_class.{0} name) (@functor.add_const.run.{0 0} (add_monoid.{0} (mul_zero_class.{0} name)) name (@functor.comp.run.{0 0 0} add_monoid.{0} mul_zero_class.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} add_monoid.{0} mul_zero_class.{0}) h0 name)))  := sorry --non-trivial
lemma new_lemma_47731 (h0 : functor.add_const (group (has_pos_part pos)) (has_neg Type)) : @group.fg.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (has_pos_part.{0} pos)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_47732 (h0 : not (add_group (preorder congr_arg_kind) -> false)) : @is_add_cyclic.{0} (preorder.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (add_group.{0} (preorder.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_47733 (h0 : topological_space (monoid (option (has_dist (option (option (option (option (option unsigned))))))))) : irreducible_space (monoid (option (has_dist (option (option (option (option (option unsigned)))))))) := sorry --non-trivial
lemma new_lemma_47734 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (linear_ordered_field.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} h0 (linear_ordered_field.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_47735 (h0 : topological_space (comm_group Type)) : preconnected_space (comm_group Type) := sorry --non-trivial
lemma new_lemma_47736 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (finset pos)) := sorry --non-trivial
lemma new_lemma_47737 (h0 : functor.add_const (topological_space (has_add name)) (has_neg linarith.comp)) : @irreducible_space.{0} (has_add.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} name)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_47738 (h0 : functor.add_const (topological_space (has_neg_part name)) name) : @normal_space.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_47739 (h0 : not (ring (has_lt char) -> false)) : @strong_rank_condition.{0} (has_lt.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (has_lt.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_47740 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (is_R_or_C.{0} empty) (@function.extfun_app.{2 1} Type semiring.{0} h0 (is_R_or_C.{0} empty))  := sorry --non-trivial
lemma new_lemma_47741 (h0 : functor.add_const (topological_space (has_to_string name)) name) : @t1_space.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_47742 (h0 : finset (add_group (semiring (semiring unsigned)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_47743 (h0 : ring (has_Sup unsigned)) : rank_condition (has_Sup unsigned) := sorry --non-trivial
lemma new_lemma_47744 (h0 : has_mem.mem (linear_ordered_semiring empty) has_emptyc.emptyc) : @strong_rank_condition.{0} (linear_ordered_semiring.{0} empty) (@finset.pi.empty.{1 0} Type ring.{0} (linear_ordered_semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_47745 (h0 : complete_lattice (partial_order unsigned)) : is_atomistic (partial_order unsigned) := sorry --non-trivial
lemma new_lemma_47746 (h0 : has_mem.mem monoid has_emptyc.emptyc) : @monoid.fg.{0} (has_norm.{0} fun_info) (@function.extfun_app.{2 1} Type monoid.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) monoid.{0} h0) (has_norm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_47747 (h0 : topological_space (ordered_comm_ring (has_add (has_Inf Type)))) : irreducible_space (ordered_comm_ring (has_add (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_47748 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} (encodable.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (encodable.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_47749 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (has_nndist.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_47750 (h0 : fin has_zero.zero) : @locally_compact_space.{0} (ordered_comm_ring.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_ring.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_47751 (h0 : group (sub_neg_monoid name)) : is_simple_group (sub_neg_monoid name) := sorry --non-trivial
lemma new_lemma_47752 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (finset.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (finset.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_47753 (h0 : group (ordered_comm_group congr_arg_kind)) : normalizer_condition (ordered_comm_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_47754 (h0 : group (normed_field (normed_field char))) : is_cyclic (normed_field (normed_field char)) := sorry --non-trivial
lemma new_lemma_47755 (h0 : ordered_add_comm_monoid (boolean_algebra environment.implicit_infer_kind)) : archimedean (boolean_algebra environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_47756 (h0 : uniform_space (add_cancel_monoid (finset (ring linarith.comp)))) : separated_space (add_cancel_monoid (finset (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_47757 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} complex (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) complex)  := sorry --non-trivial
lemma new_lemma_47758 (h0 : add_monoid (ordered_comm_ring (has_Inf (has_add real)))) : add_monoid.fg (ordered_comm_ring (has_Inf (has_add real))) := sorry --non-trivial
lemma new_lemma_47759 (h0 : add_group (has_star (semiring (semiring num)))) : is_add_cyclic (has_star (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_47760 (h0 : complete_lattice (linear_ordered_comm_monoid_with_zero num)) : is_atomistic (linear_ordered_comm_monoid_with_zero num) := sorry --non-trivial
lemma new_lemma_47761 (h0 : functor.add_const (list (ring unsigned)) linarith.comp) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_47762 (h0 : not (group (has_one num) -> false)) : @normalizer_condition.{0} (has_one.{0} num) (@classical.by_contradiction'.{1} (group.{0} (has_one.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_47763 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_atomistic.{0} (has_emptyc.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (has_emptyc.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_47764 (h0 : topological_space (left_cancel_semigroup (semiring unsigned))) : totally_separated_space (left_cancel_semigroup (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_47765 (h0 : topological_space (has_neg name)) : irreducible_space (has_neg name) := sorry --non-trivial
lemma new_lemma_47766 (h0 : functor.add_const (topological_space (normed_comm_ring pos)) (has_Inf linarith.comp)) : @topological_space.separable_space.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} pos)) (has_Inf.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_47767 (h1 : not (topological_space (fintype fun_info) -> false)) : @totally_disconnected_space.{0} (fintype.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (fintype.{0} fun_info)) h1)  := sorry --non-trivial
lemma new_lemma_47768 (h1 : list fun_info) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_47769 (h0 : ordered_add_comm_monoid (ordered_comm_monoid (has_Inf pos))) : archimedean (ordered_comm_monoid (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_47770 (h0 : function.extfun Type group) : @normalizer_condition.{0} (left_cancel_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (left_cancel_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_47771 (h0 : complete_lattice (non_unital_non_assoc_semiring (metric_space char))) : complete_lattice.is_Sup_finite_compact (non_unital_non_assoc_semiring (metric_space char)) := sorry --non-trivial
lemma new_lemma_47772 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (bin_tree.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (bin_tree.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_47773 (h0 : ordered_comm_monoid (has_neg Type)) : has_exists_mul_of_le (has_neg Type) := sorry --non-trivial
lemma new_lemma_47774 (h1 : not (add_group (has_append char) -> false)) : @is_add_cyclic.{0} (has_append.{0} char) (@classical.by_contradiction'.{1} (add_group.{0} (has_append.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_47775 (h0 : functor.add_const (topological_space (has_zero Type)) (has_neg Type)) : @t1_space.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_zero.{1} Type)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_47776 (h0 : topological_space (has_nndist linarith.comp)) : t1_space (has_nndist linarith.comp) := sorry --non-trivial
lemma new_lemma_47777 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_47778 (h0 : functor.add_const (ordered_add_comm_monoid (left_cancel_monoid unsigned)) (semiring (semiring unsigned))) : @archimedean.{0} (left_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (left_cancel_monoid.{0} unsigned)) (semiring.{0} (semiring.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_47779 (h0 : group (normed_comm_ring environment.implicit_infer_kind)) : is_cyclic (normed_comm_ring environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_47780 (h0 : function.extfun Type group) : @is_cyclic.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} num)))))) (@function.extfun_app.{2 1} Type group.{0} h0 (random_gen.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} num)))))))  := sorry --non-trivial
lemma new_lemma_47781 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (canonically_linear_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_linear_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_47782 (h0 : group (has_to_string (has_to_string pos))) : group.fg (has_to_string (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_47783 (h0 : list (complete_lattice (has_div (semi_normed_comm_ring (normed_field std_gen))))) (h1 : nat) (h2 : has_lt.lt h1 (list.length h0)) : @complete_lattice.is_Sup_finite_compact.{0} (has_div.{0} (semi_normed_comm_ring.{0} (normed_field.{0} std_gen))) (@list.nth_le.{0} (complete_lattice.{0} (has_div.{0} (semi_normed_comm_ring.{0} (normed_field.{0} std_gen)))) h0 h1 h2)  := sorry --non-trivial
lemma new_lemma_47784 (h0 : ring (normed_linear_ordered_group congr_arg_kind)) : strong_rank_condition (normed_linear_ordered_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_47785 (h0 : set (mul_one_class std_gen -> enat)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_47786 (h0 : complete_lattice (has_neg pos)) : is_atomistic (has_neg pos) := sorry --non-trivial
lemma new_lemma_47787 (h0 : functor.add_const (function.extfun Type ordered_comm_monoid) (has_Inf linarith.comp)) : @has_exists_mul_of_le.{0} (has_pos_part.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) (has_Inf.{0} linarith.comp) h0) (has_pos_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_47788 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (has_dist.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_dist.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_47789 (h0 : filter nnreal) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_47790 (h0 : topological_space (generalized_boolean_algebra (has_neg (has_neg (has_neg (has_neg name)))))) : normal_space (generalized_boolean_algebra (has_neg (has_neg (has_neg (has_neg name))))) := sorry --non-trivial
lemma new_lemma_47791 (h0 : not (has_mem.mem complete_lattice has_emptyc.emptyc -> false)) : @complete_lattice.is_Sup_finite_compact.{0} linarith.comp_source (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) complete_lattice.{0} (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type)))) h0)) linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_47792 (h0 : topological_space (has_nnnorm string.iterator_imp)) (h1 : preorder (has_nnnorm string.iterator_imp)) : order_closed_topology (has_nnnorm string.iterator_imp) := sorry --non-trivial
lemma new_lemma_47793 (h0 : semiring (has_to_string (option (option unsigned)))) : is_noetherian_ring (has_to_string (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_47794 (h0 : functor.add_const (topological_space (is_R_or_C num)) unsigned) : @totally_disconnected_space.{0} (is_R_or_C.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (is_R_or_C.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_47795 (h0 : topological_space (has_add (has_bot Type))) : preirreducible_space (has_add (has_bot Type)) := sorry --non-trivial
lemma new_lemma_47796 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_zero.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_zero.{0} num))  := sorry --non-trivial
lemma new_lemma_47797 (h0 : function.extfun (finset Type) (has_mem.mem (semiring num))) : @normal_space.{0} (semiring.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (semiring.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_47798 (h0 : not (topological_space (encodable to_additive.value_type) -> false)) : @path_connected_space.{0} (encodable.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (encodable.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_47799 (h0 : functor.add_const (ring (semigroup name)) name) : @strong_rank_condition.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (semigroup.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_47800 (h0 : topological_space (has_norm (has_top (semiring num)))) : totally_disconnected_space (has_norm (has_top (semiring num))) := sorry --non-trivial
lemma new_lemma_47801 (h0 : has_top (semiring (semiring (semiring empty))) -> has_top (semiring (semiring (semiring empty))) -> Prop) : is_strict_order (has_top (semiring (semiring (semiring empty)))) h0 := sorry --non-trivial
lemma new_lemma_47802 (h0 : functor.add_const (group (boolean_algebra Type)) Type) : @normalizer_condition.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 1} (group.{1} (boolean_algebra.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_47803 (h0 : complete_lattice (add_comm_monoid (has_neg (has_neg linarith.comp)))) : complete_lattice.is_Sup_finite_compact (add_comm_monoid (has_neg (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_47804 (h0 : topological_space (has_sub (semiring (semiring empty)))) : discrete_topology (has_sub (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_47805 (h0 : topological_space (measure_theory.measure_space empty)) : path_connected_space (measure_theory.measure_space empty) := sorry --non-trivial
lemma new_lemma_47806 (h0 : topological_space (has_neg (has_add (finset linarith.comp)))) : topological_space.separable_space (has_neg (has_add (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_47807 (h0 : function.extfun Type topological_space) (h1 : function.extfun Type preorder) : @order_closed_topology.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} pos)) (@function.extfun_app.{2 1} Type preorder.{0} h1 (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_47808 (h0 : group (complete_semilattice_Sup (has_ssubset string_imp))) : is_cyclic (complete_semilattice_Sup (has_ssubset string_imp)) := sorry --non-trivial
lemma new_lemma_47809 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (with_bot.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (with_bot.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_47810 (h0 : functor.add_const (semiring (semiring unsigned)) unsigned) : @is_noetherian_ring.{0} (semiring.{0} unsigned) (@functor.add_const.run.{0 0} (semiring.{0} (semiring.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_47811 (h0 : functor.add_const (topological_space (finset environment.implicit_infer_kind)) pos) : @loc_path_connected_space.{0} (finset.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_47812 (h0 : monoid (dlist (comm_ring (has_inv to_additive.value_type)))) : monoid.fg (dlist (comm_ring (has_inv to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_47813 (h0 : topological_space (has_inv (measurable_space linarith.comp_source))) : path_connected_space (has_inv (measurable_space linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_47814 (h0 : topological_space (id (semiring (semiring (semiring congr_arg_kind))))) : discrete_topology (id (semiring (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_47815 (h1 : topological_space (has_add fun_info)) : path_connected_space (has_add fun_info) := sorry --non-trivial
lemma new_lemma_47816 (h0 : ring (has_add (has_add (has_Inf real)))) : is_domain (has_add (has_add (has_Inf real))) := sorry --non-trivial
lemma new_lemma_47817 (h0 : uniform_space (add_monoid (has_nnnorm linarith.comp_source))) : complete_space (add_monoid (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_47818 (h0 : has_mem.mem (with_bot num) has_emptyc.emptyc) : @irreducible_space.{0} (with_bot.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_bot.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_47819 (h0 : topological_space (add_monoid fun_info)) : t0_space (add_monoid fun_info) := sorry --non-trivial
lemma new_lemma_47820 (h0 : functor.add_const (function.extfun Type add_monoid) (has_add Type)) : @add_monoid.fg.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_monoid.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type add_monoid.{0}) (has_add.{1} Type) h0) (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_47821 (h0 : ring (normed_comm_ring (has_add (has_add (has_add Type))))) : is_principal_ideal_ring (normed_comm_ring (has_add (has_add (has_add Type)))) := sorry --non-trivial
lemma new_lemma_47822 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (ordered_cancel_add_comm_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_cancel_add_comm_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_47823 (h0 : functor.add_const (ring (boolean_algebra name)) Type) : @is_domain.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 1} (ring.{0} (boolean_algebra.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_47824 (h0 : topological_space (ring (ordered_comm_monoid linarith.comp))) : regular_space (ring (ordered_comm_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_47825 (h0 : topological_space (non_assoc_semiring (semiring unsigned))) : irreducible_space (non_assoc_semiring (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_47826 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_inf.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_inf.{0} num))  := sorry --non-trivial
lemma new_lemma_47827 (h0 : ring (semiring (semiring linarith.comp))) : strong_rank_condition (semiring (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_47828 (h0 : functor.add_const (group (left_cancel_monoid unsigned)) empty) : @normalizer_condition.{0} (left_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (left_cancel_monoid.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_47829 (h1 : topological_space linarith.ineq) (h2 : preorder linarith.ineq) : order_topology linarith.ineq := sorry --non-trivial
lemma new_lemma_47830 (h0 : empty) : @rank_condition.{0} (has_ssubset.{0} (random_gen.{0} (has_ssubset.{0} to_additive.value_type))) (@empty.elim.{1} (ring.{0} (has_ssubset.{0} (random_gen.{0} (has_ssubset.{0} to_additive.value_type)))) h0)  := sorry --non-trivial
lemma new_lemma_47831 (h0 h1 : multiset char) : multiset.le h0 h1 := sorry --non-trivial
lemma new_lemma_47832 (h0 : complete_lattice (measurable_space (has_norm empty))) : is_compactly_generated (measurable_space (has_norm empty)) := sorry --non-trivial
lemma new_lemma_47833 (h0 : topological_space (boolean_algebra environment.implicit_infer_kind)) : t1_space (boolean_algebra environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_47834 (h0 : cancel_comm_monoid_with_zero (has_pos_part linarith.comp)) : unique_factorization_monoid (has_pos_part linarith.comp) := sorry --non-trivial
lemma new_lemma_47835 (h0 : topological_space (with_bot linarith.ineq)) : discrete_topology (with_bot linarith.ineq) := sorry --non-trivial
lemma new_lemma_47836 (h0 : topological_space (canonically_ordered_add_monoid std_gen)) : t0_space (canonically_ordered_add_monoid std_gen) := sorry --non-trivial
lemma new_lemma_47837 (h0 : topological_space (random_gen (has_inv char))) : t0_space (random_gen (has_inv char)) := sorry --non-trivial
lemma new_lemma_47838 (h0 : add_group (denumerable reducibility_hints)) : is_add_cyclic (denumerable reducibility_hints) := sorry --non-trivial
lemma new_lemma_47839 (h0 : ordered_comm_monoid (simple_graph (finset (has_Inf pos)))) : has_exists_mul_of_le (simple_graph (finset (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_47840 (h0 : topological_space (free_add_monoid congr_arg_kind)) : preirreducible_space (free_add_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_47841 (h0 : functor.add_const (complete_lattice (has_nndist empty)) (option empty)) : @complete_lattice.is_Sup_finite_compact.{0} (has_nndist.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_nndist.{0} empty)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_47842 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @totally_disconnected_space.{0} (normed_comm_ring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (normed_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_47843 (h0 : group (has_neg (has_add (has_add (has_add Type))))) : is_cyclic (has_neg (has_add (has_add (has_add Type)))) := sorry --non-trivial
lemma new_lemma_47844 (h1 : ring (comm_ring (metric_space (metric_space linarith.comp_source)))) : is_domain (comm_ring (metric_space (metric_space linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_47845 (h0 : ring (add_left_cancel_semigroup (option (canonically_ordered_add_monoid unsigned)))) : rank_condition (add_left_cancel_semigroup (option (canonically_ordered_add_monoid unsigned))) := sorry --non-trivial
lemma new_lemma_47846 (h0 : functor.add_const (complete_lattice (has_neg environment.implicit_infer_kind)) Type) : @complete_lattice.is_Sup_finite_compact.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (complete_lattice.{0} (has_neg.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_47847 (h0 : topological_space (comm_ring (has_nnnorm string.iterator_imp))) : t0_space (comm_ring (has_nnnorm string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_47848 (h0 h1 : multiset (normed_field reducibility_hints)) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_47849 (h0 : cancel_comm_monoid_with_zero (canonically_ordered_comm_semiring Type)) : unique_factorization_monoid (canonically_ordered_comm_semiring Type) := sorry --non-trivial
lemma new_lemma_47850 (h0 : function.extfun (filter Prop -> false) (fun (x : filter Prop -> false), false)) : @filter.Limsup.{0} Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice) (@classical.by_contradiction'.{1} (filter.{0} Prop) (@function.extfun_app.{0 0} (filter.{0} Prop → false) (λ (x : filter.{0} Prop → false), false) h0))  := sorry --non-trivial
lemma new_lemma_47851 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} fun_info (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) fun_info)  := sorry --non-trivial
lemma new_lemma_47852 (h1 : topological_space (distrib_lattice linarith.ineq)) : totally_disconnected_space (distrib_lattice linarith.ineq) := sorry --non-trivial
lemma new_lemma_47853 (h0 : topological_space (has_nnnorm (has_nnnorm (comm_ring reducibility_hints)))) : t0_space (has_nnnorm (has_nnnorm (comm_ring reducibility_hints))) := sorry --non-trivial
lemma new_lemma_47854 (h0 : filter (id (has_norm (semiring (semiring unsigned))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_47855 (h0 : fin has_zero.zero) : @complete_space.{0} (has_bot.{0} name) (@matrix.vec_empty.{0} (uniform_space.{0} (has_bot.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_47856 (h0 : functor.add_const (complete_lattice (left_cancel_semigroup num)) num) : @is_compactly_generated.{0} (left_cancel_semigroup.{0} num) (@functor.add_const.run.{0 0} (complete_lattice.{0} (left_cancel_semigroup.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_47857 (h0 : functor.add_const (topological_space (canonically_ordered_monoid pos)) pos) : @totally_disconnected_space.{0} (canonically_ordered_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_monoid.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_47858 (h0 : topological_space (boolean_algebra name)) : path_connected_space (boolean_algebra name) := sorry --non-trivial
lemma new_lemma_47859 (h1 : not (topological_space (comm_ring char) -> false)) : @path_connected_space.{0} (comm_ring.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (comm_ring.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_47860 (h0 : function.extfun nat fin) : @loc_path_connected_space.{1} (add_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (add_comm_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_47861 (h1 : function.extfun Type complete_lattice) : @is_atomistic.{0} (has_norm.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h1 (has_norm.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_47862 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} num (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) num)  := sorry --non-trivial
lemma new_lemma_47863 (h0 : functor.add_const (group (has_nndist Type)) name) : @normalizer_condition.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (has_nndist.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_47864 (h0 : group (has_emptyc (has_norm (has_top num)))) : normalizer_condition (has_emptyc (has_norm (has_top num))) := sorry --non-trivial
lemma new_lemma_47865 (h0 : functor.add_const (topological_space (boolean_algebra environment.implicit_infer_kind)) pos) : @t0_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_47866 (h0 : finset (ring (has_neg linarith.comp))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_47867 (h0 : function.extfun Type ring) : @is_domain.{0} (has_bot.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_bot.{0} name))  := sorry --non-trivial
lemma new_lemma_47868 (h0 : ordered_add_comm_monoid (has_bot (ordered_comm_monoid (sub_neg_monoid real)))) : archimedean (has_bot (ordered_comm_monoid (sub_neg_monoid real))) := sorry --non-trivial
lemma new_lemma_47869 (h0 : cancel_comm_monoid_with_zero (semigroup (add_comm_monoid ennreal))) : unique_factorization_monoid (semigroup (add_comm_monoid ennreal)) := sorry --non-trivial
lemma new_lemma_47870 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (complete_distrib_lattice.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_distrib_lattice.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_47871 (h0 : not (group (has_nnnorm (has_top to_additive.value_type)) -> false)) : @group.fg.{0} (has_nnnorm.{0} (has_top.{0} to_additive.value_type)) (@classical.by_contradiction'.{1} (group.{0} (has_nnnorm.{0} (has_top.{0} to_additive.value_type))) h0)  := sorry --non-trivial
lemma new_lemma_47872 (h1 : filter (dlist fun_info)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_47873 (h0 : group (add_semigroup unsigned)) : group.fg (add_semigroup unsigned) := sorry --non-trivial
lemma new_lemma_47874 (h0 : function.extfun Type topological_space) : @normal_space.{0} (add_comm_monoid.{0} (option.{0} unsigned)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_47875 (h0 : not (semiring (partial_order congr_arg_kind) -> false)) : @is_noetherian_ring.{0} (partial_order.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (semiring.{0} (partial_order.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_47876 (h0 : list (denumerable (has_ssubset to_additive.value_type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_47877 (h0 : topological_space (ordered_comm_ring (has_Inf (has_Inf pos)))) : totally_disconnected_space (ordered_comm_ring (has_Inf (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_47878 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @preconnected_space.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_47879 (h0 : semiring (has_neg (finset (finset (has_nndist (has_to_string (has_zero Type))))))) : is_noetherian_ring (has_neg (finset (finset (has_nndist (has_to_string (has_zero Type)))))) := sorry --non-trivial
lemma new_lemma_47880 (h0 : topological_space (has_neg_part (comm_group Type))) : irreducible_space (has_neg_part (comm_group Type)) := sorry --non-trivial
lemma new_lemma_47881 (h0 : topological_space (measurable_space congr_arg_kind)) : path_connected_space (measurable_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_47882 (h0 : functor.add_const (ring (boolean_algebra name)) name) : @is_principal_ideal_ring.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_47883 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (add_cancel_monoid.{0} (option.{0} (option.{0} (option.{0} ennreal)))) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (add_cancel_monoid.{0} (option.{0} (option.{0} (option.{0} ennreal)))))  := sorry --non-trivial
lemma new_lemma_47884 (h0 : function.extfun Type (functor.comp topological_space semigroup)) : @irreducible_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} environment.implicit_infer_kind (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} semigroup.{0}) h0 environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_47885 (h0 : topological_space (complete_linear_order (semiring num))) : discrete_topology (complete_linear_order (semiring num)) := sorry --non-trivial
lemma new_lemma_47886 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (normed_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_47887 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (has_top.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_top.{0} empty))  := sorry --non-trivial
lemma new_lemma_47888 (h0 : functor.comp topological_space has_zero pos) : @path_connected_space.{0} (has_zero.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} has_zero.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_47889 (h0 : functor.add_const (topological_space (ordered_ring num)) (semiring num)) : @t1_space.{0} (ordered_ring.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} num)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_47890 (h0 : add_monoid (plift unsigned)) : add_monoid.fg (plift unsigned) := sorry --non-trivial
lemma new_lemma_47891 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring Type)) Type) : @path_connected_space.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (canonically_ordered_comm_semiring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_47892 (h0 : functor.add_const (uniform_space (group_with_zero num)) unsigned) : @separated_space.{0} (group_with_zero.{0} num) (@functor.add_const.run.{0 0} (uniform_space.{0} (group_with_zero.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_47893 (h0 : functor.add_const (topological_space (has_edist empty)) empty) : @totally_separated_space.{0} (has_edist.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_edist.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_47894 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_principal_ideal_ring.{1} (has_zero.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ring.{1}) (has_zero.{1} Type))  := sorry --non-trivial
lemma new_lemma_47895 (h0 : list (complete_distrib_lattice (has_neg_part environment.implicit_infer_kind))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_47896 (h0 : uniform_space (ordered_cancel_add_comm_monoid (pseudo_metric_space (option pos)))) : separated_space (ordered_cancel_add_comm_monoid (pseudo_metric_space (option pos))) := sorry --non-trivial
lemma new_lemma_47897 (h0 : ordered_comm_monoid (pseudo_metric_space (option ennreal))) : has_exists_mul_of_le (pseudo_metric_space (option ennreal)) := sorry --non-trivial
lemma new_lemma_47898 (h0 : has_mem.mem linarith.ineq has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} linarith.ineq (@finset.pi.empty.{1 0} Type complete_lattice.{0} linarith.ineq h0)  := sorry --non-trivial
lemma new_lemma_47899 (h0 : finset (finset (add_cancel_monoid Type))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_47900 (h0 : group (has_bot (has_neg pos))) : group.fg (has_bot (has_neg pos)) := sorry --non-trivial
lemma new_lemma_47901 (h0 : not (ring (has_nnnorm linarith.comp_source) -> false)) : @is_domain.{0} (has_nnnorm.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (has_nnnorm.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_47902 (h0 : set (partial_order linarith.comp_source)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_47903 (h0 : topological_space (has_pos_part (ring (has_neg Type)))) : path_connected_space (has_pos_part (ring (has_neg Type))) := sorry --non-trivial
lemma new_lemma_47904 (h0 : fin has_zero.zero) : @preconnected_space.{0} (canonically_ordered_monoid.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (canonically_ordered_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_47905 (h0 : topological_space (semigroup (has_neg pos))) : irreducible_space (semigroup (has_neg pos)) := sorry --non-trivial
lemma new_lemma_47906 (h0 : functor.add_const (group (canonically_ordered_comm_semiring pos)) linarith.comp) : @is_simple_group.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (canonically_ordered_comm_semiring.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_47907 (h0 : not (topological_space (random_gen (has_ssubset linarith.comp_source)) -> false)) : @t0_space.{0} (random_gen.{0} (has_ssubset.{0} linarith.comp_source)) (@classical.by_contradiction'.{1} (topological_space.{0} (random_gen.{0} (has_ssubset.{0} linarith.comp_source))) h0)  := sorry --non-trivial
lemma new_lemma_47908 (h0 : functor.add_const (topological_space (normed_comm_ring name)) name) : @loc_path_connected_space.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_47909 (h0 : complete_lattice (ordered_comm_monoid (has_Inf (has_Inf real)))) : complete_lattice.is_Sup_finite_compact (ordered_comm_monoid (has_Inf (has_Inf real))) := sorry --non-trivial
lemma new_lemma_47910 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (has_bot.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_bot.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_47911 (h0 : complete_lattice (has_inter (option ennreal))) : is_compactly_generated (has_inter (option ennreal)) := sorry --non-trivial
lemma new_lemma_47912 (h0 : topological_space (finset (has_add (has_add Type)))) : t1_space (finset (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_47913 (h0 : topological_space (boolean_algebra (has_add (has_add (boolean_algebra.core name))))) : normal_space (boolean_algebra (has_add (has_add (boolean_algebra.core name)))) := sorry --non-trivial
lemma new_lemma_47914 (h0 : topological_space (has_nndist (mul_one_class environment.implicit_infer_kind))) : t1_space (has_nndist (mul_one_class environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_47915 (h3 : group (normed_field to_additive.value_type)) : is_cyclic (normed_field to_additive.value_type) := sorry --non-trivial
lemma new_lemma_47916 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @discrete_topology.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_47917 (h0 : ring (normed_lattice_add_comm_group linarith.comp)) : is_domain (normed_lattice_add_comm_group linarith.comp) := sorry --non-trivial
lemma new_lemma_47918 (h0 : ordered_comm_monoid (normed_comm_ring (has_neg_part (finset Type)))) : has_exists_mul_of_le (normed_comm_ring (has_neg_part (finset Type))) := sorry --non-trivial
lemma new_lemma_47919 (h0 : topological_space (complete_semilattice_Sup (random_gen fun_info))) : irreducible_space (complete_semilattice_Sup (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_47920 (h0 : functor.comp topological_space has_nndist pos) : @loc_path_connected_space.{0} (has_nndist.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_47921 (h0 : uniform_space (denumerable (has_nnnorm (random_gen char)))) : complete_space (denumerable (has_nnnorm (random_gen char))) := sorry --non-trivial
lemma new_lemma_47922 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (monoid_with_zero.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (monoid_with_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_47923 (h0 : topological_space (boolean_algebra.core (finset name))) : locally_compact_space (boolean_algebra.core (finset name)) := sorry --non-trivial
lemma new_lemma_47924 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (normed_group.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (normed_group.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_47925 (h0 : topological_space (add_comm_monoid (has_to_string Type))) : locally_compact_space (add_comm_monoid (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_47926 (h0 : topological_space (ring unsigned)) : preirreducible_space (ring unsigned) := sorry --non-trivial
lemma new_lemma_47927 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (semiring.{0} (has_top.{0} (has_norm.{0} (has_top.{0} (has_top.{0} fun_info))))) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (semiring.{0} (has_top.{0} (has_norm.{0} (has_top.{0} (has_top.{0} fun_info))))))  := sorry --non-trivial
lemma new_lemma_47928 (h0 : group (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm linarith.comp_source))))) : group.fg (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_47929 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_neg_part.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg_part.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_47930 (h0 : not (has_mem.mem group has_emptyc.emptyc -> false)) : @is_cyclic.{0} (has_norm.{0} num) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) group.{0} (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type)))) h0)) (has_norm.{0} num))  := sorry --non-trivial
lemma new_lemma_47931 (h0 : topological_space (comm_semigroup (sub_neg_monoid name))) : topological_space.separable_space (comm_semigroup (sub_neg_monoid name)) := sorry --non-trivial
lemma new_lemma_47932 (h0 : topological_space (ring (comm_group Type))) : locally_compact_space (ring (comm_group Type)) := sorry --non-trivial
lemma new_lemma_47933 (h1 : topological_space (fintype string_imp)) : path_connected_space (fintype string_imp) := sorry --non-trivial
lemma new_lemma_47934 (h0 : ring (denumerable (random_gen (has_nnnorm string_imp)))) : strong_rank_condition (denumerable (random_gen (has_nnnorm string_imp))) := sorry --non-trivial
lemma new_lemma_47935 (h0 : finset (non_assoc_semiring (ordered_cancel_comm_monoid unsigned))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_47936 (h0 : topological_space (has_Inf (ring (ring (ring linarith.comp))))) : totally_separated_space (has_Inf (ring (ring (ring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_47937 (h1 : ring (encodable linarith.comp_source)) : strong_rank_condition (encodable linarith.comp_source) := sorry --non-trivial
lemma new_lemma_47938 (h0 : not (topological_space (metric_space empty) -> false)) : @locally_compact_space.{0} (metric_space.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (metric_space.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_47939 (h0 : semiring (canonically_linear_ordered_monoid pos)) : is_noetherian_ring (canonically_linear_ordered_monoid pos) := sorry --non-trivial
lemma new_lemma_47940 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (distrib_lattice.{0} (random_gen.{0} linarith.comp_source)) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (distrib_lattice.{0} (random_gen.{0} linarith.comp_source)))  := sorry --non-trivial
lemma new_lemma_47941 (h0 : has_mem.mem (with_one to_additive.value_type) has_emptyc.emptyc) : @complete_space.{0} (with_one.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type uniform_space.{0} (with_one.{0} to_additive.value_type) h0)  := sorry --non-trivial
lemma new_lemma_47942 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_47943 (h0 : topological_space (linear_ordered_comm_monoid_with_zero (has_bot congr_arg_kind))) : preirreducible_space (linear_ordered_comm_monoid_with_zero (has_bot congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_47944 (h0 : ordered_add_comm_monoid (has_add Type)) : archimedean (has_add Type) := sorry --non-trivial
lemma new_lemma_47945 (h0 : topological_space (add_comm_monoid (has_add (has_add name)))) : locally_compact_space (add_comm_monoid (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_47946 (h0 : functor.add_const (topological_space (boolean_algebra linarith.comp)) (finset pos)) : @loc_path_connected_space.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} linarith.comp)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_47947 (h0 : topological_space (semi_normed_comm_ring (random_gen char))) : locally_compact_space (semi_normed_comm_ring (random_gen char)) := sorry --non-trivial
lemma new_lemma_47948 (h0 : topological_space (add_right_cancel_monoid num)) : totally_separated_space (add_right_cancel_monoid num) := sorry --non-trivial
lemma new_lemma_47949 (h1 : topological_space (comm_ring (has_nnnorm linarith.ineq))) : path_connected_space (comm_ring (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_47950 (h0 : functor.add_const (group (is_R_or_C unsigned)) (semiring empty)) : @is_cyclic.{0} (is_R_or_C.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (is_R_or_C.{0} unsigned)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_47951 (h0 : topological_space (ordered_comm_ring (boolean_algebra.core (has_Inf Type)))) : loc_path_connected_space (ordered_comm_ring (boolean_algebra.core (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_47952 (h0 : function.extfun (Type 1) ordered_add_comm_monoid) : @archimedean.{1} (normed_lattice_add_comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_add_comm_monoid.{1} h0 (normed_lattice_add_comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_47953 (h0 : topological_space (has_nndist (finset (finset pos)))) : locally_compact_space (has_nndist (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_47954 (h0 : ring (distrib_lattice (has_nnnorm linarith.ineq))) : is_domain (distrib_lattice (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_47955 (h0 : topological_space (add_comm_monoid (has_add pos))) : irreducible_space (add_comm_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_47956 (h0 : topological_space (dlist (has_ssubset fun_info))) : locally_compact_space (dlist (has_ssubset fun_info)) := sorry --non-trivial
lemma new_lemma_47957 (h0 : topological_space (add_group (semiring unsigned))) : t0_space (add_group (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_47958 (h0 : functor.add_const (functor.add_const (list pos) name) pos) : palindrome (functor.add_const.run (functor.add_const.run h0)) := sorry --non-trivial
lemma new_lemma_47959 (h0 : topological_space (cancel_monoid (boolean_algebra pos))) : locally_compact_space (cancel_monoid (boolean_algebra pos)) := sorry --non-trivial
lemma new_lemma_47960 (h0 : function.extfun Type (functor.add_const (topological_space (has_star unsigned)))) : @totally_separated_space.{0} (has_star.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} unsigned)) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (has_star.{0} unsigned))) h0 num))  := sorry --non-trivial
lemma new_lemma_47961 (h0 : measurable_space (uniform_space reducibility_hints)) (h1 : filter (uniform_space reducibility_hints)) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_47962 (h0 : add_group (topological_space (random_gen linarith.ineq))) : is_add_cyclic (topological_space (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_47963 (h0 : finset (has_bot (option (option unsigned)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_47964 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (has_to_string.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_47965 (h1 : topological_space (denumerable (has_top to_additive.value_type))) : t0_space (denumerable (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_47966 (h0 : not (topological_space (normed_group (has_norm linarith.comp_source)) -> false)) : @totally_disconnected_space.{0} (normed_group.{0} (has_norm.{0} linarith.comp_source)) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_group.{0} (has_norm.{0} linarith.comp_source))) h0)  := sorry --non-trivial
lemma new_lemma_47967 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_atomistic.{0} (has_emptyc.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (has_emptyc.{0} num))  := sorry --non-trivial
lemma new_lemma_47968 (h0 : ring (canonically_linear_ordered_monoid (has_Inf (has_Inf real)))) : rank_condition (canonically_linear_ordered_monoid (has_Inf (has_Inf real))) := sorry --non-trivial
lemma new_lemma_47969 (h0 : ring (canonically_linear_ordered_monoid (has_Inf (has_Inf pos)))) : strong_rank_condition (canonically_linear_ordered_monoid (has_Inf (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_47970 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (canonically_ordered_comm_semiring.{0} (option.{0} (option.{0} empty))) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (canonically_ordered_comm_semiring.{0} (option.{0} (option.{0} empty))))  := sorry --non-trivial
lemma new_lemma_47971 (h0 : functor.add_const (ring (normed_comm_ring pos)) environment.implicit_infer_kind) : @rank_condition.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (normed_comm_ring.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_47972 (h0 : list (boolean_algebra (has_to_string environment.implicit_infer_kind))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_47973 (h0 : add_group (dlist (has_inv (has_inv (has_inv (has_inv string_imp)))))) : is_add_cyclic (dlist (has_inv (has_inv (has_inv (has_inv string_imp))))) := sorry --non-trivial
lemma new_lemma_47974 (h0 : group (id linarith.comp_source)) : group.fg (id linarith.comp_source) := sorry --non-trivial
lemma new_lemma_47975 (h0 : topological_space (has_zero (has_add linarith.comp))) : t1_space (has_zero (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_47976 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (canonically_ordered_add_monoid (option unsigned))) := sorry --non-trivial
lemma new_lemma_47977 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (@id.{2} Type to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 topological_space.{0}) (@id.{2} Type to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_47978 (h0 : functor.add_const (topological_space (has_zero environment.implicit_infer_kind)) (has_pos_part pos)) : @discrete_topology.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} environment.implicit_infer_kind)) (has_pos_part.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_47979 (h0 : functor.add_const (topological_space (ring pos)) (has_add (has_add name))) : @irreducible_space.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} pos)) (has_add.{0} (has_add.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_47980 (h0 : group (has_add (has_add (has_Inf real)))) : is_simple_group (has_add (has_add (has_Inf real))) := sorry --non-trivial
lemma new_lemma_47981 (h0 : functor.add_const (group (add_cancel_monoid Type)) name) : @normalizer_condition.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (add_cancel_monoid.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_47982 (h0 : topological_space (id empty)) : topological_space.separable_space (id empty) := sorry --non-trivial
lemma new_lemma_47983 (h0 : function.extfun Type (functor.add_const (topological_space (boolean_algebra.core linarith.comp)))) : @preirreducible_space.{0} (boolean_algebra.core.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} linarith.comp)) pos (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (boolean_algebra.core.{0} linarith.comp))) h0 pos))  := sorry --non-trivial
lemma new_lemma_47984 (h1 : set (add_comm_semigroup (mul_one_class (mul_one_class ereal)))) : set.finite h1 := sorry --non-trivial
lemma new_lemma_47985 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (ordered_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_47986 (h0 : topological_space (cancel_monoid (normed_comm_ring Type))) : topological_space.separable_space (cancel_monoid (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_47987 (h0 : function.extfun (finset Type) (has_mem.mem (complete_lattice to_additive.value_type))) : @totally_separated_space.{0} (complete_lattice.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type topological_space.{0} (complete_lattice.{0} to_additive.value_type) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (complete_lattice.{0} to_additive.value_type)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_47988 (h0 : uniform_space (add_group unsigned)) : separated_space (add_group unsigned) := sorry --non-trivial
lemma new_lemma_47989 (h0 : topological_space (add_cancel_monoid (has_add environment.implicit_infer_kind))) : loc_path_connected_space (add_cancel_monoid (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_47990 (h0 : group (distrib_lattice (random_gen string_imp))) : group.fg (distrib_lattice (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_47991 (h0 : topological_space (finset Type)) : t0_space (finset Type) := sorry --non-trivial
lemma new_lemma_47992 (h0 : uniform_space (metric_space (has_norm (semiring linarith.comp)))) : complete_space (metric_space (has_norm (semiring linarith.comp))) := sorry --non-trivial
lemma new_lemma_47993 (h0 : functor.add_const (add_monoid (preorder empty)) empty) : @add_monoid.fg.{0} (preorder.{0} empty) (@functor.add_const.run.{0 0} (add_monoid.{0} (preorder.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_47994 (h0 : topological_space (has_pos_part (has_pos_part (has_Inf (comm_semigroup real))))) : path_connected_space (has_pos_part (has_pos_part (has_Inf (comm_semigroup real)))) := sorry --non-trivial
lemma new_lemma_47995 (h0 : not (ring (normed_group char) -> false)) : @rank_condition.{0} (normed_group.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (normed_group.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_47996 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (distrib_lattice to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_47997 (h1 : has_lt string.iterator_imp) : no_max_order string.iterator_imp := sorry --non-trivial
lemma new_lemma_47998 (h0 : ring (has_nndist (has_add name))) : is_principal_ideal_ring (has_nndist (has_add name)) := sorry --non-trivial
lemma new_lemma_47999 (h0 : functor.add_const (function.extfun (Type 1) ordered_comm_monoid) linarith.comp) : @has_exists_mul_of_le.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_comm_monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ordered_comm_monoid.{1}) linarith.comp h0) (has_add.{1} Type))  := sorry --non-trivial
