import imports
lemma new_lemma_160000 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (add_semigroup.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_semigroup.{0} num))  := sorry --non-trivial
lemma new_lemma_160001 (h1 : add_group (semi_normed_ring to_additive.value_type)) : is_add_cyclic (semi_normed_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_160002 (h0 : complete_lattice (preorder (semiring empty))) : complete_lattice.is_Sup_finite_compact (preorder (semiring empty)) := sorry --non-trivial
lemma new_lemma_160003 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (has_neg_part.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_160004 (h0 : uniform_space (linear_ordered_add_comm_group to_additive.value_type)) : complete_space (linear_ordered_add_comm_group to_additive.value_type) := sorry --non-trivial
lemma new_lemma_160005 (h0 : complete_lattice (dlist (random_gen fun_info))) : is_compactly_generated (dlist (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_160006 (h0 : topological_space (linear_ordered_field (option (option ennreal)))) : preconnected_space (linear_ordered_field (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_160007 (h0 : functor.add_const (uniform_space (semiring (semiring (semiring (semiring (semiring empty)))))) empty) : @separated_space.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} empty))))) (@functor.add_const.run.{0 0} (uniform_space.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} empty)))))) empty h0)  := sorry --non-trivial
lemma new_lemma_160008 (h0 : topological_space (has_star (semiring (semiring (semiring (semiring congr_arg_kind)))))) : discrete_topology (has_star (semiring (semiring (semiring (semiring congr_arg_kind))))) := sorry --non-trivial
lemma new_lemma_160009 (h0 : functor.add_const (group (has_edist unsigned)) unsigned) : @normalizer_condition.{0} (has_edist.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (has_edist.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_160010 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (omega_complete_partial_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (omega_complete_partial_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_160011 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (has_to_string.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_to_string.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_160012 (h0 : not (has_mem.mem (topological_space linarith.ineq) has_emptyc.emptyc -> false)) : @rank_condition.{0} (topological_space.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type ring.{0} (topological_space.{0} linarith.ineq) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (topological_space.{0} linarith.ineq) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_160013 (h0 : list (has_Inf (has_add Type))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_160014 (h0 : group (has_to_string (option (option pos)))) : is_cyclic (has_to_string (option (option pos))) := sorry --non-trivial
lemma new_lemma_160015 (h0 : group (option pos)) : normalizer_condition (option pos) := sorry --non-trivial
lemma new_lemma_160016 (h0 : filter (linear_ordered_comm_group (option ennreal))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_160017 (h0 : functor.add_const (ordered_comm_monoid (comm_group environment.implicit_infer_kind)) Type) : @has_exists_mul_of_le.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (comm_group.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_160018 (h1 : group (measurable_space linarith.ineq)) : normalizer_condition (measurable_space linarith.ineq) := sorry --non-trivial
lemma new_lemma_160019 (h0 : ring (has_div std_gen)) : strong_rank_condition (has_div std_gen) := sorry --non-trivial
lemma new_lemma_160020 (h0 : not (uniform_space (add_cancel_comm_monoid char) -> false)) : @complete_space.{0} (add_cancel_comm_monoid.{0} char) (@classical.by_contradiction'.{1} (uniform_space.{0} (add_cancel_comm_monoid.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_160021 (h0 : topological_space (normed_comm_ring (finset pos))) : totally_disconnected_space (normed_comm_ring (finset pos)) := sorry --non-trivial
lemma new_lemma_160022 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @group.fg.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 group.{1}) (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_160023 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} (canonically_linear_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) (canonically_linear_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_160024 (h0 : topological_space (has_norm (linear_ordered_semiring unsigned))) : locally_compact_space (has_norm (linear_ordered_semiring unsigned)) := sorry --non-trivial
lemma new_lemma_160025 (h0 : topological_space (has_add (sub_neg_monoid linarith.comp))) : sequential_space (has_add (sub_neg_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_160026 (h0 : semiring (add_cancel_monoid (option pos))) : is_noetherian_ring (add_cancel_monoid (option pos)) := sorry --non-trivial
lemma new_lemma_160027 (h0 : not (topological_space to_additive.value_type -> false)) : @totally_disconnected_space.{0} to_additive.value_type (@classical.by_contradiction'.{1} (topological_space.{0} to_additive.value_type) h0)  := sorry --non-trivial
lemma new_lemma_160028 (h0 : topological_space (has_star (semiring (semiring unsigned)))) : totally_separated_space (has_star (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_160029 (h0 : group (has_nndist linarith.comp)) : normalizer_condition (has_nndist linarith.comp) := sorry --non-trivial
lemma new_lemma_160030 (h0 : topological_space (has_add (has_bot (has_Inf real)))) : regular_space (has_add (has_bot (has_Inf real))) := sorry --non-trivial
lemma new_lemma_160031 (h0 : complete_lattice (semiring (has_top (has_top to_additive.value_type)))) : is_atomistic (semiring (has_top (has_top to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_160032 (h3 : has_mem.mem (semiring num) has_emptyc.emptyc) : @is_domain.{0} (semiring.{0} num) (@finset.pi.empty.{1 0} Type ring.{0} (semiring.{0} num) h3)  := sorry --non-trivial
lemma new_lemma_160033 (h0 : add_comm_semigroup (add_comm_semigroup fun_info) -> add_comm_semigroup (add_comm_semigroup fun_info)) (h1 : add_comm_semigroup (add_comm_semigroup fun_info)) : function.is_fixed_pt h0 h1 := sorry --non-trivial
lemma new_lemma_160034 (h0 : uniform_space (boolean_algebra (has_neg (has_neg (has_neg name))))) : complete_space (boolean_algebra (has_neg (has_neg (has_neg name)))) := sorry --non-trivial
lemma new_lemma_160035 (h0 : topological_space (mul_zero_class (finset pos))) : preirreducible_space (mul_zero_class (finset pos)) := sorry --non-trivial
lemma new_lemma_160036 (h1 : ring (metric_space (metric_space (metric_space reducibility_hints)))) : is_domain (metric_space (metric_space (metric_space reducibility_hints))) := sorry --non-trivial
lemma new_lemma_160037 (h0 : complete_lattice (has_emptyc num)) : complete_lattice.is_Sup_finite_compact (has_emptyc num) := sorry --non-trivial
lemma new_lemma_160038 (h0 : cancel_comm_monoid_with_zero (bin_tree num)) : unique_factorization_monoid (bin_tree num) := sorry --non-trivial
lemma new_lemma_160039 (h0 : topological_space (comm_group (has_to_string Type))) : preirreducible_space (comm_group (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_160040 (h0 : not (add_group (has_union linarith.comp) -> false)) : @is_add_cyclic.{0} (has_union.{0} linarith.comp) (@classical.by_contradiction'.{1} (add_group.{0} (has_union.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_160041 (h0 : complete_lattice (has_nnnorm (mul_one_class enat))) : complete_lattice.is_Sup_finite_compact (has_nnnorm (mul_one_class enat)) := sorry --non-trivial
lemma new_lemma_160042 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} (complete_semilattice_Sup.{0} fun_info) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (complete_semilattice_Sup.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_160043 (h1 : complete_lattice (with_one (has_nnnorm char))) : is_compactly_generated (with_one (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_160044 (h0 : ring (canonically_ordered_monoid linarith.comp)) : is_principal_ideal_ring (canonically_ordered_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_160045 (h0 : topological_space (comm_semigroup (sub_neg_monoid (sub_neg_monoid (sub_neg_monoid pos))))) : t1_space (comm_semigroup (sub_neg_monoid (sub_neg_monoid (sub_neg_monoid pos)))) := sorry --non-trivial
lemma new_lemma_160046 (h0 : has_mem.mem add_group has_emptyc.emptyc) : @is_add_cyclic.{0} (has_emptyc.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type add_group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) add_group.{0} h0) (has_emptyc.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_160047 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (partial_order.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (partial_order.{0} num))  := sorry --non-trivial
lemma new_lemma_160048 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (has_to_string.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_to_string.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_160049 (h0 : functor.add_const (topological_space (ring Type)) (finset pos)) : @totally_disconnected_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ring.{1} Type)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_160050 (h0 : topological_space (preorder empty)) : t0_space (preorder empty) := sorry --non-trivial
lemma new_lemma_160051 (h0 : functor.add_const (topological_space (has_Inf name)) Type) : @totally_separated_space.{0} (has_Inf.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (has_Inf.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_160052 (h1 : topological_space (semiring to_additive.value_type)) : totally_disconnected_space (semiring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_160053 (h0 : complete_lattice (has_add (random_gen linarith.ineq))) : is_compactly_generated (has_add (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_160054 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (has_sub.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_sub.{0} empty))  := sorry --non-trivial
lemma new_lemma_160055 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (linear_ordered_field.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (linear_ordered_field.{0} pos))  := sorry --non-trivial
lemma new_lemma_160056 (h0 : function.extfun Type topological_space) : @normal_space.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_160057 (h0 : functor.add_const (topological_space (complete_distrib_lattice linarith.comp)) linarith.comp) : @totally_disconnected_space.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_160058 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (encodable.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (encodable.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_160059 (h0 : add_group (has_nnnorm string_imp)) : is_add_cyclic (has_nnnorm string_imp) := sorry --non-trivial
lemma new_lemma_160060 (h0 : functor.add_const (ordered_comm_monoid (semigroup name)) linarith.comp) : @has_exists_mul_of_le.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (semigroup.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_160061 (h0 : filter (has_ssubset (random_gen fun_info))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_160062 (h0 : uniform_space (ring (normed_comm_ring (has_add environment.implicit_infer_kind)))) : separated_space (ring (normed_comm_ring (has_add environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_160063 (h0 : filter (measure_theory.measure_space congr_arg_kind)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_160064 (h0 : filter (boolean_algebra.core Type)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_160065 (h0 : topological_space (has_top (has_norm linarith.ineq))) : irreducible_space (has_top (has_norm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_160066 (h0 : function.extfun Type ring) : @rank_condition.{0} (canonically_linear_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type ring.{0} h0 (canonically_linear_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_160067 (h0 : topological_space (has_inv (has_ssubset (has_nnnorm fun_info)))) : locally_compact_space (has_inv (has_ssubset (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_160068 (h0 : group (pseudo_metric_space (option (option unsigned)))) : normalizer_condition (pseudo_metric_space (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_160069 (h0 : topological_space (has_nndist (option unsigned))) : t0_space (has_nndist (option unsigned)) := sorry --non-trivial
lemma new_lemma_160070 (h0 : function.extfun (Type 1) topological_space) : @discrete_topology.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_160071 (h0 : functor.add_const (topological_space (has_to_string ennreal)) ennreal) : @loc_path_connected_space.{0} (has_to_string.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_160072 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (complete_distrib_lattice.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_distrib_lattice.{0} pos))  := sorry --non-trivial
lemma new_lemma_160073 (h0 : filter (sub_neg_monoid (finset (finset (finset (finset linarith.comp)))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_160074 (h0 : has_mem.mem ring has_emptyc.emptyc) : @rank_condition.{0} (linear_ordered_semiring.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} h0) (linear_ordered_semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_160075 (h0 : function.extfun Type topological_space) : @t0_space.{0} (@id.{2} Type unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (@id.{2} Type unsigned))  := sorry --non-trivial
lemma new_lemma_160076 (h0 : topological_space (mul_zero_class (semiring (semiring num)))) : topological_space.separable_space (mul_zero_class (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_160077 (h0 : topological_space (sub_neg_monoid pos)) : preirreducible_space (sub_neg_monoid pos) := sorry --non-trivial
lemma new_lemma_160078 (h0 : group (has_neg (has_neg Type))) : is_simple_group (has_neg (has_neg Type)) := sorry --non-trivial
lemma new_lemma_160079 (h0 : set (has_nnnorm (normed_field (has_emptyc linarith.ineq)))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_160080 (h0 : monoid (has_zero (semigroup linarith.comp))) : monoid.fg (has_zero (semigroup linarith.comp)) := sorry --non-trivial
lemma new_lemma_160081 (h0 : ring (ordered_comm_ring (has_add (has_add pos)))) : rank_condition (ordered_comm_ring (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_160082 (h0 : set (non_unital_non_assoc_semiring (mul_one_class (mul_one_class (mul_one_class (mul_one_class enat)))))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_160083 (h0 : fin has_zero.zero) : @monoid.fg.{1} (has_pos_part.{1} Type) (@matrix.vec_empty.{1} (monoid.{1} (has_pos_part.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_160084 (h0 : ring (complete_distrib_lattice (option ennreal))) : rank_condition (complete_distrib_lattice (option ennreal)) := sorry --non-trivial
lemma new_lemma_160085 (h1 : topological_space (with_one num)) : totally_disconnected_space (with_one num) := sorry --non-trivial
lemma new_lemma_160086 (h0 : functor.add_const (complete_lattice (monoid unsigned)) num) : @complete_lattice.is_Sup_finite_compact.{0} (monoid.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (monoid.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_160087 (h0 : ring (distrib_lattice (random_gen (random_gen (has_top string_imp))))) : is_domain (distrib_lattice (random_gen (random_gen (has_top string_imp)))) := sorry --non-trivial
lemma new_lemma_160088 (h0 : topological_space (sub_neg_monoid pos)) : t0_space (sub_neg_monoid pos) := sorry --non-trivial
lemma new_lemma_160089 (h0 : add_monoid (comm_group (option pos))) : add_monoid.fg (comm_group (option pos)) := sorry --non-trivial
lemma new_lemma_160090 (h0 : ring (finset (mul_one_class (has_neg linarith.comp)))) : is_domain (finset (mul_one_class (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_160091 (h0 : functor.add_const (topological_space (has_nndist unsigned)) num) : @t0_space.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_160092 (h1 : std_gen -> std_gen) (h2 : set std_gen) (h3 : std_gen) : set.preimage h1 h2 h3 := sorry --non-trivial
lemma new_lemma_160093 (h0 : functor.add_const (list (ring pos)) pos) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_160094 (h0 : uniform_space (has_nnnorm environment.projection_info)) : complete_space (has_nnnorm environment.projection_info) := sorry --non-trivial
lemma new_lemma_160095 (h0 : functor.add_const (topological_space (has_nndist name)) name) : @totally_separated_space.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_160096 (h0 : group (add_cancel_monoid pos)) : is_cyclic (add_cancel_monoid pos) := sorry --non-trivial
lemma new_lemma_160097 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_emptyc.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_emptyc.{0} num))  := sorry --non-trivial
lemma new_lemma_160098 (h0 : function.extfun Type (functor.comp topological_space comm_group)) : @regular_space.{0} (comm_group.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} comm_group.{0} ennreal (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} comm_group.{0}) h0 ennreal))  := sorry --non-trivial
lemma new_lemma_160099 (h0 : functor.add_const (topological_space (monoid_with_zero ennreal)) ennreal) : @irreducible_space.{0} (monoid_with_zero.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (monoid_with_zero.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_160100 (h0 : add_monoid (has_neg (has_add name))) : add_monoid.fg (has_neg (has_add name)) := sorry --non-trivial
lemma new_lemma_160101 (h1 : topological_space (random_gen linarith.comp_source)) : totally_separated_space (random_gen linarith.comp_source) := sorry --non-trivial
lemma new_lemma_160102 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_emptyc.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_emptyc.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_160103 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (canonically_ordered_comm_semiring.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (canonically_ordered_comm_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_160104 (h0 : functor.add_const (function.extfun Type ordered_comm_monoid) Type) : @has_exists_mul_of_le.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) Type h0) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_160105 (h5 : uniform_space (semi_normed_ring string_imp)) : complete_space (semi_normed_ring string_imp) := sorry --non-trivial
lemma new_lemma_160106 (h0 : functor.add_const (topological_space (boolean_algebra.core Type)) name) : @preconnected_space.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.core.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_160107 (h0 : ring (comm_ring (random_gen fun_info))) : strong_rank_condition (comm_ring (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_160108 (h0 : add_monoid (generalized_boolean_algebra (ring Type))) : add_monoid.fg (generalized_boolean_algebra (ring Type)) := sorry --non-trivial
lemma new_lemma_160109 (h0 : functor.add_const (uniform_space (ordered_comm_ring linarith.comp)) name) : @separated_space.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (ordered_comm_ring.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_160110 (h0 : topological_space (normed_group linarith.comp)) : totally_separated_space (normed_group linarith.comp) := sorry --non-trivial
lemma new_lemma_160111 (h0 : functor.add_const (topological_space (has_inter unsigned)) num) : @path_connected_space.{0} (has_inter.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_inter.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_160112 (h0 : ring (add_group fun_info)) : rank_condition (add_group fun_info) := sorry --non-trivial
lemma new_lemma_160113 (h0 : function.extfun Type topological_space) : @normal_space.{0} (ordered_cancel_add_comm_monoid.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_cancel_add_comm_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_160114 (h0 : ring (monoid_with_zero pos)) : strong_rank_condition (monoid_with_zero pos) := sorry --non-trivial
lemma new_lemma_160115 (h0 : group (has_add (has_to_string (finset name)))) : group.fg (has_add (has_to_string (finset name))) := sorry --non-trivial
lemma new_lemma_160116 (h0 : topological_space (ordered_ring (option empty))) : preirreducible_space (ordered_ring (option empty)) := sorry --non-trivial
lemma new_lemma_160117 (h0 : functor.add_const Prop (ordered_comm_ring (finset (finset linarith.comp)))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_160118 (h1 : topological_space (id (random_gen linarith.ineq))) : totally_separated_space (id (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_160119 (h0 : topological_space (add_right_cancel_monoid (semiring (semiring empty)))) : normal_space (add_right_cancel_monoid (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_160120 (h1 : add_group (normed_field (mul_one_class (simple_graph (mul_one_class ereal))))) : is_add_cyclic (normed_field (mul_one_class (simple_graph (mul_one_class ereal)))) := sorry --non-trivial
lemma new_lemma_160121 (h0 : group (has_top (has_nnnorm (has_nnnorm (has_nnnorm char))))) : is_cyclic (has_top (has_nnnorm (has_nnnorm (has_nnnorm char)))) := sorry --non-trivial
lemma new_lemma_160122 (h0 : topological_space (has_zero (has_add pos))) : regular_space (has_zero (has_add pos)) := sorry --non-trivial
lemma new_lemma_160123 (h0 : add_group (normed_group (has_one linarith.comp))) : is_add_cyclic (normed_group (has_one linarith.comp)) := sorry --non-trivial
lemma new_lemma_160124 (h0 : topological_space (ordered_cancel_add_comm_monoid ennreal)) : discrete_topology (ordered_cancel_add_comm_monoid ennreal) := sorry --non-trivial
lemma new_lemma_160125 (h0 : complete_lattice (left_cancel_semigroup (semiring empty))) : is_atomistic (left_cancel_semigroup (semiring empty)) := sorry --non-trivial
lemma new_lemma_160126 (h0 : add_monoid (boolean_algebra (ring (ring linarith.comp)))) : add_monoid.fg (boolean_algebra (ring (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_160127 (h0 : add_monoid (has_pos_part name)) : add_monoid.fg (has_pos_part name) := sorry --non-trivial
lemma new_lemma_160128 (h0 : topological_space (normed_lattice_add_comm_group (has_bot real))) : loc_path_connected_space (normed_lattice_add_comm_group (has_bot real)) := sorry --non-trivial
lemma new_lemma_160129 (h0 : monoid (has_emptyc fun_info)) : monoid.fg (has_emptyc fun_info) := sorry --non-trivial
lemma new_lemma_160130 (h1 : complete_lattice (has_ssubset fun_info)) : complete_lattice.is_Sup_finite_compact (has_ssubset fun_info) := sorry --non-trivial
lemma new_lemma_160131 (h0 : topological_space (linear_ordered_field (option (option ennreal)))) : t0_space (linear_ordered_field (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_160132 (h0 : add_monoid (has_to_string (ring (ring (add_left_cancel_monoid linarith.comp))))) : add_monoid.fg (has_to_string (ring (ring (add_left_cancel_monoid linarith.comp)))) := sorry --non-trivial
lemma new_lemma_160133 (h0 : topological_space (has_neg_part (has_add pos))) : loc_path_connected_space (has_neg_part (has_add pos)) := sorry --non-trivial
lemma new_lemma_160134 (h0 : Prop) (h1 : h0 -> h0 -> Prop) : quot h1 := sorry --non-trivial
lemma new_lemma_160135 (h0 : topological_space (has_nndist (has_nndist environment.implicit_infer_kind))) : path_connected_space (has_nndist (has_nndist environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_160136 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @topological_space.separable_space.{0} (has_pos_part.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (has_pos_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_160137 (h0 : set (has_ssubset to_additive.value_type)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_160138 (h0 : ring (has_nndist (ring pos))) : is_domain (has_nndist (ring pos)) := sorry --non-trivial
lemma new_lemma_160139 (h0 : topological_space (option (option (option (option pos))))) : totally_disconnected_space (option (option (option (option pos)))) := sorry --non-trivial
lemma new_lemma_160140 (h0 : ring (canonically_ordered_add_monoid congr_arg_kind)) : strong_rank_condition (canonically_ordered_add_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_160141 (h0 : fin has_zero.zero) : @unique_factorization_monoid.{0} (add_comm_monoid.{0} name) (@matrix.vec_empty.{0} (cancel_comm_monoid_with_zero.{0} (add_comm_monoid.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_160142 (h0 : cancel_comm_monoid_with_zero (normed_lattice_add_comm_group (has_add real))) : unique_factorization_monoid (normed_lattice_add_comm_group (has_add real)) := sorry --non-trivial
lemma new_lemma_160143 (h0 : pnat) (h1 : units pnat) (h2 : ulower pnat) : pnat.coprime (divp h0 h1) (ulower.up h2) := sorry --non-trivial
lemma new_lemma_160144 (h0 : function.extfun (finset Type) (has_mem.mem (has_norm congr_arg_kind))) : @totally_disconnected_space.{0} (has_norm.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_norm.{0} congr_arg_kind) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_norm.{0} congr_arg_kind)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_160145 (h0 : topological_space (has_nndist (finset (finset name)))) : irreducible_space (has_nndist (finset (finset name))) := sorry --non-trivial
lemma new_lemma_160146 (h0 : topological_space (finset (has_nndist Type))) : locally_compact_space (finset (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_160147 (h0 : functor.add_const (function.extfun Type uniform_space) num) : @complete_space.{0} (has_dist.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) num h0) (has_dist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_160148 (h0 : functor.comp ring boolean_algebra name) : @is_domain.{0} (boolean_algebra.{0} name) (@functor.comp.run.{0 0 0} ring.{0} boolean_algebra.{0} name h0)  := sorry --non-trivial
lemma new_lemma_160149 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (left_cancel_semigroup congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_160150 (h0 : functor.add_const (topological_space (add_group unsigned)) (semiring unsigned)) : @totally_separated_space.{0} (add_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_group.{0} unsigned)) (semiring.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_160151 (h0 : functor.add_const (ring (comm_group Type)) pos) : @is_domain.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (comm_group.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_160152 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_160153 (h0 : uniform_space (denumerable (random_gen char))) : complete_space (denumerable (random_gen char)) := sorry --non-trivial
lemma new_lemma_160154 (h0 : list (ring (ordered_ring linarith.comp))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_160155 (h0 : functor.add_const (topological_space (has_neg unsigned)) environment.implicit_infer_kind) : @t1_space.{0} (has_neg.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_160156 (h0 : group (plift empty)) : normalizer_condition (plift empty) := sorry --non-trivial
lemma new_lemma_160157 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (as_linear_order.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (as_linear_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_160158 (h0 : functor.add_const (topological_space (normed_comm_ring ennreal)) (option ennreal)) : @t0_space.{0} (normed_comm_ring.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} ennreal)) (option.{0} ennreal) h0)  := sorry --non-trivial
lemma new_lemma_160159 (h0 : functor.add_const (add_group (linear_ordered_cancel_comm_monoid num)) empty) : @is_add_cyclic.{0} (linear_ordered_cancel_comm_monoid.{0} num) (@functor.add_const.run.{0 0} (add_group.{0} (linear_ordered_cancel_comm_monoid.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_160160 (h0 : functor.add_const (topological_space (has_to_string environment.implicit_infer_kind)) Type) : @preirreducible_space.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (has_to_string.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_160161 (h0 : functor.add_const (add_monoid (linear_ordered_comm_ring num)) unsigned) : @add_monoid.fg.{0} (linear_ordered_comm_ring.{0} num) (@functor.add_const.run.{0 0} (add_monoid.{0} (linear_ordered_comm_ring.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_160162 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @normalizer_condition.{1} (simple_graph.{1} Type) (@matrix.vec_empty.{1} (group.{1} (simple_graph.{1} Type)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_160163 (h0 : topological_space (canonically_linear_ordered_monoid linarith.comp)) : preirreducible_space (canonically_linear_ordered_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_160164 (h0 : functor.add_const (finset (add_left_cancel_semigroup unsigned)) (semiring unsigned)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_160165 (h0 : complete_lattice (complete_semilattice_Sup (random_gen num))) : complete_lattice.is_Sup_finite_compact (complete_semilattice_Sup (random_gen num)) := sorry --non-trivial
lemma new_lemma_160166 (h0 : filter (add_monoid char)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_160167 (h0 : functor.add_const (topological_space (add_comm_monoid Type)) environment.implicit_infer_kind) : @regular_space.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_comm_monoid.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_160168 (h0 : topological_space (has_nndist (option name))) : regular_space (has_nndist (option name)) := sorry --non-trivial
lemma new_lemma_160169 (h0 : semiring (has_neg (has_neg linarith.comp))) : is_noetherian_ring (has_neg (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_160170 (h0 : multiset (simple_graph fun_info) -> Prop) (h1 : Exists (fun (x : multiset (simple_graph fun_info)), h0 x)) (h2 : multiset (simple_graph fun_info)) : multiset.subset (classical.some h1) h2 := sorry --non-trivial
lemma new_lemma_160171 (h0 : topological_space (complete_distrib_lattice (add_cancel_monoid (comm_group pos)))) : t0_space (complete_distrib_lattice (add_cancel_monoid (comm_group pos))) := sorry --non-trivial
lemma new_lemma_160172 (h0 : function.extfun Type ring) : @rank_condition.{0} (boolean_algebra.core.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (boolean_algebra.core.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_160173 (h0 : topological_space (comm_semigroup (sub_neg_monoid (has_bot real)))) : path_connected_space (comm_semigroup (sub_neg_monoid (has_bot real))) := sorry --non-trivial
lemma new_lemma_160174 (h5 : topological_space (has_ssubset char)) : path_connected_space (has_ssubset char) := sorry --non-trivial
lemma new_lemma_160175 (h0 : functor.add_const (prod nnreal nnreal) empty) : id_rel (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_160176 (h0 : topological_space (has_Sup congr_arg_kind)) : discrete_topology (has_Sup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_160177 (h0 : filter (generalized_boolean_algebra (has_Inf pos))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_160178 (h0 : topological_space (comm_ring (comm_ring (random_gen (comm_ring (comm_ring (comm_ring (comm_ring char)))))))) : t0_space (comm_ring (comm_ring (random_gen (comm_ring (comm_ring (comm_ring (comm_ring char))))))) := sorry --non-trivial
lemma new_lemma_160179 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_160180 (h1 : topological_space (semi_normed_comm_ring (random_gen char))) : path_connected_space (semi_normed_comm_ring (random_gen char)) := sorry --non-trivial
lemma new_lemma_160181 (h0 : fin has_zero.zero) : @unique_factorization_monoid.{0} (sub_neg_monoid.{0} real) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type cancel_comm_monoid_with_zero.{0}) h0) (sub_neg_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_160182 (h0 : topological_space (has_nndist linarith.comp)) : locally_compact_space (has_nndist linarith.comp) := sorry --non-trivial
lemma new_lemma_160183 (h0 : add_monoid (has_one (semiring unsigned))) : add_monoid.fg (has_one (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_160184 (h0 : ring (semi_normed_comm_ring (has_ssubset (random_gen char)))) : is_domain (semi_normed_comm_ring (has_ssubset (random_gen char))) := sorry --non-trivial
lemma new_lemma_160185 (h0 : topological_space (canonically_ordered_monoid (has_Inf (has_pos_part real)))) : normal_space (canonically_ordered_monoid (has_Inf (has_pos_part real))) := sorry --non-trivial
lemma new_lemma_160186 (h0 : topological_space (simple_graph name)) : loc_path_connected_space (simple_graph name) := sorry --non-trivial
lemma new_lemma_160187 (h0 : functor.add_const (complete_lattice (ring ennreal)) ennreal) : @is_atomistic.{0} (ring.{0} ennreal) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ring.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_160188 (h0 : functor.add_const (complete_lattice (linear_ordered_comm_monoid_with_zero empty)) unsigned) : @complete_lattice.is_Sup_finite_compact.{0} (linear_ordered_comm_monoid_with_zero.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (linear_ordered_comm_monoid_with_zero.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_160189 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (left_cancel_semigroup empty)) := sorry --non-trivial
lemma new_lemma_160190 (h0 : fin has_zero.zero) : @archimedean.{0} (ordered_comm_monoid.{0} pos) (@matrix.vec_empty.{0} (ordered_add_comm_monoid.{0} (ordered_comm_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_160191 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (ordered_cancel_add_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_160192 (h0 : not (function.extfun Type ring -> false)) : @strong_rank_condition.{0} (metric_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (metric_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_160193 (h0 : function.extfun Type topological_space) : @t0_space.{0} (add_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_160194 (h0 : ring (add_monoid (has_nnnorm (has_append linarith.comp_source)))) : rank_condition (add_monoid (has_nnnorm (has_append linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_160195 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (random_gen.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (random_gen.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_160196 (h0 : functor.comp topological_space cancel_monoid linarith.comp) : @loc_path_connected_space.{0} (cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} linarith.comp)) name (@functor.comp.run.{0 0 0} topological_space.{0} cancel_monoid.{0} linarith.comp h0))  := sorry --non-trivial
lemma new_lemma_160197 (h0 : topological_space (ordered_comm_monoid (has_Inf Type))) : t0_space (ordered_comm_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_160198 (h0 : topological_space (metric_space congr_arg_kind)) : path_connected_space (metric_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_160199 (h0 : ring (complete_distrib_lattice name)) : strong_rank_condition (complete_distrib_lattice name) := sorry --non-trivial
lemma new_lemma_160200 (h0 : group (boolean_algebra.core (ring (ring pos)))) : normalizer_condition (boolean_algebra.core (ring (ring pos))) := sorry --non-trivial
lemma new_lemma_160201 (h1 : complete_lattice (topological_space reducibility_hints)) : complete_lattice.is_Sup_finite_compact (topological_space reducibility_hints) := sorry --non-trivial
lemma new_lemma_160202 (h0 : filter (boolean_algebra.core (has_add environment.implicit_infer_kind))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_160203 (h0 : topological_space (comm_semigroup (has_Inf pos))) : totally_disconnected_space (comm_semigroup (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_160204 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_160205 (h0 : functor.add_const (group (has_Sup empty)) empty) : @normalizer_condition.{0} (has_Sup.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (has_Sup.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_160206 (h0 : not (function.extfun Type topological_space -> false)) : @totally_disconnected_space.{0} (semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_160207 (h0 : functor.add_const (ring (has_zero environment.implicit_infer_kind)) environment.implicit_infer_kind) : @is_principal_ideal_ring.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (has_zero.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_160208 (h0 : monoid (linear_ordered_add_comm_group (has_top (has_top (has_top fun_info))))) : monoid.fg (linear_ordered_add_comm_group (has_top (has_top (has_top fun_info)))) := sorry --non-trivial
lemma new_lemma_160209 (h0 : set Prop) (h1 : set.is_wf h0) (h2 : set.nonempty h0) : @id.{1} Prop (@set.is_wf.min.{0} Prop (@complete_semilattice_Inf.to_partial_order.{0} Prop (@complete_lattice.to_complete_semilattice_Inf.{0} Prop Prop.complete_lattice)) h0 h1 h2)  := sorry --non-trivial
lemma new_lemma_160210 (h0 : fin has_zero.zero) : @has_exists_mul_of_le.{0} (ordered_comm_ring.{0} pos) (@matrix.vec_empty.{0} (ordered_comm_monoid.{0} (ordered_comm_ring.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_160211 (h1 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h1 (encodable to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_160212 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (simple_graph.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (simple_graph.{0} pos))  := sorry --non-trivial
lemma new_lemma_160213 (h0 : complete_lattice (ring (finset Type))) : complete_lattice.is_Sup_finite_compact (ring (finset Type)) := sorry --non-trivial
lemma new_lemma_160214 (h0 : semiring (add_comm_monoid (has_add (has_add environment.implicit_infer_kind)))) (h1 : ideal (add_comm_monoid (has_add (has_add environment.implicit_infer_kind)))) : ideal.fg h1 := sorry --non-trivial
lemma new_lemma_160215 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring linarith.comp)) linarith.comp) : @preconnected_space.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_160216 (h0 : topological_space (normed_field (metric_space to_additive.value_type))) : totally_disconnected_space (normed_field (metric_space to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_160217 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @preirreducible_space.{1} (has_add.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (has_add.{1} Type)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_160218 (h0 : filter (plift empty)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_160219 (h0 : topological_space (comm_monoid (option (option empty)))) : irreducible_space (comm_monoid (option (option empty))) := sorry --non-trivial
lemma new_lemma_160220 (h0 : uniform_space (with_bot (has_top linarith.comp_source))) : complete_space (with_bot (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_160221 (h0 : functor.add_const (prod (has_Sup empty) (has_Sup empty)) (semiring empty)) : id_rel (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_160222 (h0 : add_monoid (option (semiring num))) : add_monoid.fg (option (semiring num)) := sorry --non-trivial
lemma new_lemma_160223 (h0 : topological_space (boolean_algebra (ring linarith.comp))) : discrete_topology (boolean_algebra (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_160224 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_to_string.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_160225 (h0 : functor.add_const (add_monoid (has_to_string pos)) (ring (ring Type))) : @add_monoid.fg.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 1} (add_monoid.{0} (has_to_string.{0} pos)) (ring.{1} (ring.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_160226 (h0 : topological_space znum) : irreducible_space znum := sorry --non-trivial
lemma new_lemma_160227 (h0 : fin has_zero.zero) : @complete_space.{1} (canonically_linear_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (uniform_space.{1} (canonically_linear_ordered_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_160228 (h0 : uniform_space (option (option name))) : complete_space (option (option name)) := sorry --non-trivial
lemma new_lemma_160229 (h0 : complete_lattice (boolean_algebra (add_cancel_monoid environment.implicit_infer_kind))) : is_atomistic (boolean_algebra (add_cancel_monoid environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_160230 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @normalizer_condition.{1} (canonically_ordered_comm_semiring.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 group.{1}) (canonically_ordered_comm_semiring.{1} Type))  := sorry --non-trivial
lemma new_lemma_160231 (h0 : group (finset (has_add (has_add (has_add Type))))) : is_cyclic (finset (has_add (has_add (has_add Type)))) := sorry --non-trivial
lemma new_lemma_160232 (h0 : not (topological_space (measure_theory.measure_space string.iterator_imp) -> false)) : @totally_disconnected_space.{0} (measure_theory.measure_space.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (topological_space.{0} (measure_theory.measure_space.{0} string.iterator_imp)) h0)  := sorry --non-trivial
lemma new_lemma_160233 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (complete_distrib_lattice.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} num))  := sorry --non-trivial
lemma new_lemma_160234 (h0 : functor.comp topological_space has_neg_part Type) : @preconnected_space.{1} (has_neg_part.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} has_neg_part.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_160235 (h0 : topological_space (has_add (has_Inf (has_Inf pos)))) : totally_separated_space (has_add (has_Inf (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_160236 (h3 : not (topological_space (distrib linarith.ineq) -> false)) : @path_connected_space.{0} (distrib.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (distrib.{0} linarith.ineq)) h3)  := sorry --non-trivial
lemma new_lemma_160237 (h0 : topological_space (with_one empty)) : totally_separated_space (with_one empty) := sorry --non-trivial
lemma new_lemma_160238 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (has_bot.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_bot.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_160239 (h0 : uniform_space (linear_ordered_comm_ring (semiring congr_arg_kind))) : complete_space (linear_ordered_comm_ring (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_160240 (h0 : functor.add_const (function.extfun Type topological_space) (ring linarith.comp)) : @topological_space.separable_space.{0} (simple_graph.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (ring.{0} linarith.comp) h0) (simple_graph.{0} pos))  := sorry --non-trivial
lemma new_lemma_160241 (h0 : not (function.extfun Type topological_space -> false)) : @discrete_topology.{0} (has_top.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_top.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_160242 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_edist.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_edist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_160243 (h0 : topological_space (has_div (mul_one_class linarith.ineq))) : totally_disconnected_space (has_div (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_160244 (h0 : finset (has_add (add_cancel_monoid Type))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_160245 (h0 : topological_space (linear_ordered_semiring empty)) : path_connected_space (linear_ordered_semiring empty) := sorry --non-trivial
lemma new_lemma_160246 (h0 : add_group (complete_linear_order unsigned)) : is_add_cyclic (complete_linear_order unsigned) := sorry --non-trivial
lemma new_lemma_160247 (h0 : function.extfun nat fin) : @is_simple_group.{0} (canonically_ordered_monoid.{0} real) (@matrix.vec_empty.{0} (group.{0} (canonically_ordered_monoid.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_160248 (h0 : group (add_cancel_monoid Type)) : is_cyclic (add_cancel_monoid Type) := sorry --non-trivial
lemma new_lemma_160249 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) real) := sorry --non-trivial
lemma new_lemma_160250 (h0 : list (generalized_boolean_algebra (has_add Type))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_160251 (h0 : ring (add_cancel_monoid (comm_group environment.implicit_infer_kind))) : rank_condition (add_cancel_monoid (comm_group environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_160252 (h0 : topological_space (has_add (has_bot (sub_neg_monoid pos)))) : path_connected_space (has_add (has_bot (sub_neg_monoid pos))) := sorry --non-trivial
lemma new_lemma_160253 (h0 : group (complete_linear_order (semiring num))) : is_cyclic (complete_linear_order (semiring num)) := sorry --non-trivial
lemma new_lemma_160254 (h0 : functor.add_const (complete_lattice (left_cancel_semigroup unsigned)) congr_arg_kind) : @is_atomistic.{0} (left_cancel_semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (left_cancel_semigroup.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_160255 (h0 : topological_space (has_inter (option (option empty)))) : normal_space (has_inter (option (option empty))) := sorry --non-trivial
lemma new_lemma_160256 (h3 : not (topological_space (topological_space char) -> false)) : @totally_disconnected_space.{0} (topological_space.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (topological_space.{0} char)) h3)  := sorry --non-trivial
lemma new_lemma_160257 (h0 : functor.add_const (uniform_space (filter empty)) empty) : @separated_space.{0} (filter.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (filter.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_160258 (h0 : functor.add_const (function.extfun (Type 1) cancel_comm_monoid_with_zero) (ring (has_neg Type))) : @unique_factorization_monoid.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1}) (ring.{1} (has_neg.{1} Type)) h0) (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_160259 (h0 : group (ordered_comm_monoid char)) : is_cyclic (ordered_comm_monoid char) := sorry --non-trivial
lemma new_lemma_160260 (h0 h1 : pnat) (h2 : list pnat) : pnat.coprime h0 (pnat.mod h1 (list.head h2)) := sorry --non-trivial
lemma new_lemma_160261 (h0 : topological_space (has_one (semiring (semiring (semiring empty))))) : preirreducible_space (has_one (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_160262 (h0 : congr_arg_kind -> bin_tree num -> Prop) : relator.bi_total h0 := sorry --non-trivial
lemma new_lemma_160263 (h0 : has_mem.mem (metric_space linarith.comp) has_emptyc.emptyc) : @is_atomistic.{0} (metric_space.{0} linarith.comp) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (metric_space.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_160264 (h0 : list (linear_ordered_comm_monoid_with_zero num)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_160265 (h0 : add_monoid (with_one fun_info)) : add_monoid.fg (with_one fun_info) := sorry --non-trivial
lemma new_lemma_160266 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (measure_theory.measure_space.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measure_theory.measure_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_160267 (h0 : topological_space (comm_group ennreal)) : regular_space (comm_group ennreal) := sorry --non-trivial
lemma new_lemma_160268 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (has_to_string.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_to_string.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_160269 (h0 : filter (measure_theory.measure_space unsigned)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_160270 (h0 : functor.add_const (ring (add_comm_monoid name)) (has_to_string Type)) : @strong_rank_condition.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 1} (ring.{0} (add_comm_monoid.{0} name)) (has_to_string.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_160271 (h0 : topological_space (comm_group (comm_group pos))) : path_connected_space (comm_group (comm_group pos)) := sorry --non-trivial
lemma new_lemma_160272 (h0 : ring (semigroup (has_neg (boolean_algebra (ring (ring (ring (has_to_string Type)))))))) : is_domain (semigroup (has_neg (boolean_algebra (ring (ring (ring (has_to_string Type))))))) := sorry --non-trivial
lemma new_lemma_160273 (h0 : topological_space (finset (add_comm_monoid environment.implicit_infer_kind))) : irreducible_space (finset (add_comm_monoid environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_160274 (h0 : group (boolean_algebra.core Type)) : is_cyclic (boolean_algebra.core Type) := sorry --non-trivial
lemma new_lemma_160275 (h0 : functor.add_const (group (has_nndist Type)) (has_Inf Type)) : @normalizer_condition.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 1} (group.{1} (has_nndist.{1} Type)) (has_Inf.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_160276 (h0 : uniform_space (complete_semilattice_Sup (has_norm linarith.comp_source))) : complete_space (complete_semilattice_Sup (has_norm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_160277 (h0 : ordered_comm_monoid (has_Inf (has_add pos))) : has_exists_mul_of_le (has_Inf (has_add pos)) := sorry --non-trivial
lemma new_lemma_160278 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_160279 (h0 : function.extfun (finset Type) (has_mem.mem (semiring empty))) : @discrete_topology.{0} (semiring.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (semiring.{0} empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} empty)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_160280 (h0 : topological_space (has_append (has_nnnorm linarith.ineq))) : path_connected_space (has_append (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_160281 (h0 : fin has_zero.zero) : @t0_space.{0} (normed_lattice_add_comm_group.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (normed_lattice_add_comm_group.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_160282 (h0 : topological_space (encodable (has_ssubset (has_ssubset to_additive.value_type)))) : irreducible_space (encodable (has_ssubset (has_ssubset to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_160283 (h0 : uniform_space (random_gen (mul_one_class char))) : complete_space (random_gen (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_160284 (h0 : function.extfun Type topological_space) : @t0_space.{0} (linear_ordered_add_comm_group.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_add_comm_group.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_160285 (h0 : has_mem.mem (has_norm linarith.comp_source) has_emptyc.emptyc) : @t0_space.{0} (has_norm.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_norm.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_160286 (h0 : functor.add_const (function.extfun (Type 1) group) pos) : @normalizer_condition.{1} (simple_graph.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) group.{1}) pos h0) (simple_graph.{1} Type))  := sorry --non-trivial
lemma new_lemma_160287 (h0 : ring (complete_distrib_lattice ennreal)) : strong_rank_condition (complete_distrib_lattice ennreal) := sorry --non-trivial
lemma new_lemma_160288 (h4 : uniform_space (has_top (random_gen fun_info))) : complete_space (has_top (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_160289 (h0 : functor.add_const (function.extfun (Type 1) uniform_space) pos) : @complete_space.{1} (cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) uniform_space.{1}) pos h0) (cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_160290 (h0 : functor.add_const (topological_space (has_add linarith.comp)) linarith.comp) : @discrete_topology.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_160291 (h0 : functor.add_const (group (finset Type)) environment.implicit_infer_kind) : @is_simple_group.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (finset.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_160292 (h0 : uniform_space (has_pos_part (comm_semigroup (has_Inf real)))) : complete_space (has_pos_part (comm_semigroup (has_Inf real))) := sorry --non-trivial
lemma new_lemma_160293 (h0 : uniform_space (has_ssubset (has_lt string_imp))) : complete_space (has_ssubset (has_lt string_imp)) := sorry --non-trivial
lemma new_lemma_160294 (h0 : functor.add_const (ordered_add_comm_monoid (pseudo_metric_space name)) name) : @archimedean.{0} (pseudo_metric_space.{0} name) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (pseudo_metric_space.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_160295 (h0 : function.extfun Type group) : @group.fg.{0} (add_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (add_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_160296 (h0 : ring (non_assoc_semiring (semiring unsigned))) : rank_condition (non_assoc_semiring (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_160297 (h1 : ring (semi_normed_ring linarith.comp_source)) : rank_condition (semi_normed_ring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_160298 (h0 : topological_space (has_zero (has_pos_part (has_pos_part (finset Type))))) : path_connected_space (has_zero (has_pos_part (has_pos_part (finset Type)))) := sorry --non-trivial
lemma new_lemma_160299 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_bot.{0} real) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_bot.{0} real))  := sorry --non-trivial
lemma new_lemma_160300 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (has_nnnorm.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_nnnorm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_160301 (h0 : functor.add_const (topological_space (has_to_string Type)) (ring linarith.comp)) : @preirreducible_space.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_to_string.{1} Type)) (ring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_160302 (h1 : topological_space (has_norm string_imp)) : totally_separated_space (has_norm string_imp) := sorry --non-trivial
lemma new_lemma_160303 (h1 : filter (linear_ordered_add_comm_group linarith.ineq)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_160304 (h0 : group (semiring empty)) : is_cyclic (semiring empty) := sorry --non-trivial
lemma new_lemma_160305 (h0 : function.extfun Type group) : @group.fg.{0} (has_inter.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} h0 (has_inter.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_160306 (h0 : add_group (linear_ordered_semiring (semiring (has_norm empty)))) : is_add_cyclic (linear_ordered_semiring (semiring (has_norm empty))) := sorry --non-trivial
lemma new_lemma_160307 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (linear_ordered_field.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_field.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_160308 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (linear_order.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (linear_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_160309 (h0 : ring (has_zero (finset name))) : is_domain (has_zero (finset name)) := sorry --non-trivial
lemma new_lemma_160310 (h0 h1 : multiset (has_le linarith.comp_source)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_160311 (h0 : functor.add_const (uniform_space (finset linarith.comp)) Type) : @separated_space.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 1} (uniform_space.{0} (finset.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_160312 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (pseudo_metric_space unsigned)) := sorry --non-trivial
lemma new_lemma_160313 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (add_cancel_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_160314 (h0 : add_monoid (left_cancel_monoid (semiring empty))) : add_monoid.fg (left_cancel_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_160315 (h0 : topological_space (comm_monoid (option empty))) : irreducible_space (comm_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_160316 (h0 : functor.add_const (ring (add_cancel_monoid Type)) pos) : @rank_condition.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (add_cancel_monoid.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_160317 (h0 : filter (complete_semilattice_Sup char)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_160318 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (normed_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (normed_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_160319 (h0 : topological_space (semiring congr_arg_kind)) : discrete_topology (semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_160320 (h0 : ordered_comm_monoid (has_to_string ennreal)) : has_exists_mul_of_le (has_to_string ennreal) := sorry --non-trivial
lemma new_lemma_160321 (h0 : finset (ring (has_nndist (ring (has_add (ring pos)))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_160322 (h0 : topological_space (has_append string_imp) -> Prop) (h1 : Exists (fun (x : topological_space (has_append string_imp)), h0 x)) : @t0_space.{0} (has_append.{0} string_imp) (@classical.some.{1} (topological_space.{0} (has_append.{0} string_imp)) h0 h1)  := sorry --non-trivial
lemma new_lemma_160323 (h0 : function.extfun Type (functor.add_const (topological_space pos))) : @t1_space.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) ennreal (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} pos)) h0 ennreal))  := sorry --non-trivial
lemma new_lemma_160324 (h1 : has_lt enat) : no_max_order enat := sorry --non-trivial
lemma new_lemma_160325 (h1 : filter (normed_group to_additive.value_type)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_160326 (h0 : monoid (ring (has_Inf (ring (ring (has_Inf Type)))))) : monoid.fg (ring (has_Inf (ring (ring (has_Inf Type))))) := sorry --non-trivial
lemma new_lemma_160327 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @complete_space.{0} (with_bot.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) uniform_space.{0}) (with_bot.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_160328 (h0 : group (semiring linarith.ineq)) : normalizer_condition (semiring linarith.ineq) := sorry --non-trivial
lemma new_lemma_160329 (h0 : uniform_space (has_one (has_top empty))) : complete_space (has_one (has_top empty)) := sorry --non-trivial
lemma new_lemma_160330 (h0 : add_monoid (has_to_string ennreal)) : add_monoid.fg (has_to_string ennreal) := sorry --non-trivial
lemma new_lemma_160331 (h0 : fin has_zero.zero) : @strong_rank_condition.{1} (complete_distrib_lattice.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (complete_distrib_lattice.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_160332 (h0 : complete_lattice (complete_linear_order (semiring num))) : complete_lattice.is_Sup_finite_compact (complete_linear_order (semiring num)) := sorry --non-trivial
lemma new_lemma_160333 (h0 : ring (has_one (semiring (semiring unsigned)))) : is_domain (has_one (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_160334 (h0 : functor.add_const (function.extfun (Type 1) topological_space) (finset environment.implicit_infer_kind)) : @irreducible_space.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) (finset.{0} environment.implicit_infer_kind) h0) (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_160335 (h0 : functor.add_const (topological_space (boolean_algebra.core pos)) linarith.comp) : @irreducible_space.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_160336 (h0 : uniform_space (has_add (finset linarith.comp))) : separated_space (has_add (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_160337 (h0 : nat) (h1 : array h0 (fin has_zero.zero)) (h2 : fin h0) : matrix.vec_empty (array.read h1 (id (id h2))) := sorry --non-trivial
lemma new_lemma_160338 (h0 : ordered_add_comm_monoid (has_Inf name)) : archimedean (has_Inf name) := sorry --non-trivial
lemma new_lemma_160339 (h2 : not (add_group (distrib to_additive.value_type) -> false)) : @is_add_cyclic.{0} (distrib.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (add_group.{0} (distrib.{0} to_additive.value_type)) h2)  := sorry --non-trivial
lemma new_lemma_160340 (h0 : group (boolean_algebra (has_Inf Type))) : group.fg (boolean_algebra (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_160341 (h0 : complete_lattice (has_nndist (has_neg Type))) : complete_lattice.is_Sup_finite_compact (has_nndist (has_neg Type)) := sorry --non-trivial
lemma new_lemma_160342 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (boolean_algebra.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_160343 (h0 : prod (with_one (semiring num)) (with_one (semiring num))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_160344 (h0 : functor.add_const (ring (complete_distrib_lattice environment.implicit_infer_kind)) pos) : @is_principal_ideal_ring.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_160345 (h0 : prod (add_cancel_monoid Type) (add_cancel_monoid Type)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_160346 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (denumerable.{0} string_imp) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (denumerable.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_160347 (h0 : measurable_space (has_ssubset fun_info)) (h1 : filter (has_ssubset fun_info)) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_160348 (h0 : group (ordered_comm_group (semiring empty))) : normalizer_condition (ordered_comm_group (semiring empty)) := sorry --non-trivial
lemma new_lemma_160349 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (group_with_zero.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} h0 (group_with_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_160350 (h0 : function.extfun Type (functor.add_const (topological_space (is_R_or_C empty)))) : @totally_disconnected_space.{0} (is_R_or_C.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (is_R_or_C.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (is_R_or_C.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_160351 (h0 : functor.add_const (semiring (normed_linear_ordered_group congr_arg_kind)) num) : @is_noetherian_ring.{0} (normed_linear_ordered_group.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (semiring.{0} (normed_linear_ordered_group.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_160352 (h0 : function.extfun Type (functor.add_const (complete_lattice (mul_zero_class unsigned)))) : @is_compactly_generated.{0} (mul_zero_class.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (mul_zero_class.{0} unsigned)) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (complete_lattice.{0} (mul_zero_class.{0} unsigned))) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_160353 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (comm_ring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (comm_ring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_160354 (h1 : has_mem.mem add_group has_emptyc.emptyc) : @is_add_cyclic.{0} num (@function.extfun_app.{2 1} Type add_group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) add_group.{0} h1) num)  := sorry --non-trivial
lemma new_lemma_160355 (h0 : cancel_comm_monoid_with_zero (add_comm_monoid (option num))) : unique_factorization_monoid (add_comm_monoid (option num)) := sorry --non-trivial
lemma new_lemma_160356 (h0 : topological_space (has_neg_part Type)) : totally_disconnected_space (has_neg_part Type) := sorry --non-trivial
lemma new_lemma_160357 (h0 h1 : pnat) : pnat.coprime (id (id h0)) h1 := sorry --non-trivial
lemma new_lemma_160358 (h0 : complete_lattice (cancel_monoid (option (option ennreal)))) : complete_lattice.is_Sup_finite_compact (cancel_monoid (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_160359 (h0 : ordered_add_comm_monoid (has_neg linarith.comp)) : archimedean (has_neg linarith.comp) := sorry --non-trivial
lemma new_lemma_160360 (h0 : functor.add_const (topological_space (normed_comm_ring linarith.comp)) pos) : @locally_compact_space.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_160361 (h0 : group (has_add (ring pos))) : group.fg (has_add (ring pos)) := sorry --non-trivial
lemma new_lemma_160362 (h0 : uniform_space (mul_zero_class num)) : separated_space (mul_zero_class num) := sorry --non-trivial
lemma new_lemma_160363 (h0 : function.extfun Type (functor.add_const (monoid (ordered_ring empty)))) : @monoid.fg.{0} (ordered_ring.{0} empty) (@functor.add_const.run.{0 0} (monoid.{0} (ordered_ring.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (monoid.{0} (ordered_ring.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_160364 (h1 : group (has_inv string_imp)) : normalizer_condition (has_inv string_imp) := sorry --non-trivial
lemma new_lemma_160365 (h0 : complete_lattice (random_gen (random_gen reducibility_hints))) : complete_lattice.is_Sup_finite_compact (random_gen (random_gen reducibility_hints)) := sorry --non-trivial
lemma new_lemma_160366 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : countable_Inter_filter (function.extfun_app (function.extfun_app h0 filter) (has_neg ennreal)) := sorry --non-trivial
lemma new_lemma_160367 (h0 : functor.add_const (complete_lattice (ring name)) pos) : @is_compactly_generated.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ring.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_160368 (h0 : group (finset (has_Inf (finset (finset (normed_comm_ring linarith.comp)))))) : normalizer_condition (finset (has_Inf (finset (finset (normed_comm_ring linarith.comp))))) := sorry --non-trivial
lemma new_lemma_160369 (h0 : list (add_cancel_monoid (semiring empty))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_160370 (h0 : add_monoid (with_bot (semiring (has_top linarith.comp)))) : add_monoid.fg (with_bot (semiring (has_top linarith.comp))) := sorry --non-trivial
lemma new_lemma_160371 (h0 : uniform_space (canonically_ordered_add_monoid congr_arg_kind)) : complete_space (canonically_ordered_add_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_160372 (h0 : ring (distrib_lattice char)) : strong_rank_condition (distrib_lattice char) := sorry --non-trivial
lemma new_lemma_160373 (h0 : functor.add_const (add_group (has_zero environment.implicit_infer_kind)) Type) : @is_add_cyclic.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (add_group.{0} (has_zero.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_160374 (h0 : group (fintype linarith.ineq)) : is_cyclic (fintype linarith.ineq) := sorry --non-trivial
lemma new_lemma_160375 (h0 : cancel_comm_monoid_with_zero (finset (has_pos_part linarith.comp))) : unique_factorization_monoid (finset (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_160376 (h0 : add_group (has_compl (mul_one_class to_additive.value_type))) : is_add_cyclic (has_compl (mul_one_class to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_160377 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (ordered_comm_ring.{0} real) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (ordered_comm_ring.{0} real))  := sorry --non-trivial
lemma new_lemma_160378 (h0 : function.extfun Type (functor.comp ring has_nndist)) : @rank_condition.{0} (has_nndist.{0} pos) (@functor.comp.run.{0 0 0} ring.{0} has_nndist.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} ring.{0} has_nndist.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_160379 (h1 : complete_lattice (comm_ring char)) : is_compactly_generated (comm_ring char) := sorry --non-trivial
lemma new_lemma_160380 (h0 : functor.add_const Prop (ordered_comm_monoid (ring linarith.comp))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_160381 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (finset.{0} name) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (finset.{0} name))  := sorry --non-trivial
lemma new_lemma_160382 (h0 : ring (monoid ennreal)) : strong_rank_condition (monoid ennreal) := sorry --non-trivial
lemma new_lemma_160383 (h0 : functor.add_const (function.extfun (Type 1) ordered_comm_monoid) (has_neg_part name)) : @has_exists_mul_of_le.{1} (has_neg.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_comm_monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ordered_comm_monoid.{1}) (has_neg_part.{0} name) h0) (has_neg.{1} Type))  := sorry --non-trivial
lemma new_lemma_160384 (h0 : ordered_add_comm_monoid (boolean_algebra.core empty)) : archimedean (boolean_algebra.core empty) := sorry --non-trivial
lemma new_lemma_160385 (h0 : ring (has_norm (random_gen num))) : strong_rank_condition (has_norm (random_gen num)) := sorry --non-trivial
lemma new_lemma_160386 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (has_nndist.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (has_nndist.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_160387 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (metric_space.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (metric_space.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_160388 (h0 : add_group (has_nnnorm (has_compl (mul_one_class (distrib fun_info))))) : is_add_cyclic (has_nnnorm (has_compl (mul_one_class (distrib fun_info)))) := sorry --non-trivial
lemma new_lemma_160389 (h0 : functor.add_const (ring (normed_comm_ring Type)) linarith.comp) : @strong_rank_condition.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (normed_comm_ring.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_160390 (h1 : monoid (has_top (has_top fun_info))) : monoid.fg (has_top (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_160391 (h0 : functor.add_const (topological_space (partial_order num)) (semiring empty)) : @t1_space.{0} (partial_order.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (partial_order.{0} num)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_160392 (h0 : not (topological_space (has_star unsigned) -> false)) : @discrete_topology.{0} (has_star.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (has_star.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_160393 (h0 : not (uniform_space linarith.comp_source -> false)) : @complete_space.{0} linarith.comp_source (@classical.by_contradiction'.{1} (uniform_space.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_160394 (h0 : topological_space (normed_comm_ring (measurable_space (comm_group (finset name))))) : normal_space (normed_comm_ring (measurable_space (comm_group (finset name)))) := sorry --non-trivial
lemma new_lemma_160395 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_norm.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_norm.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_160396 (h0 : functor.add_const (topological_space (has_pos_part Type)) (has_neg pos)) : @path_connected_space.{1} (has_pos_part.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_pos_part.{1} Type)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_160397 (h0 : topological_space (has_Inf (ordered_ring (has_add Type)))) : t0_space (has_Inf (ordered_ring (has_add Type))) := sorry --non-trivial
lemma new_lemma_160398 (h0 : function.extfun (finset Type) (has_mem.mem (measurable_space num))) : @monoid.fg.{0} (measurable_space.{0} num) (@finset.pi.empty.{1 0} Type monoid.{0} (measurable_space.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (measurable_space.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_160399 (h0 : monoid (ring (finset (add_cancel_monoid linarith.comp)))) : monoid.fg (ring (finset (add_cancel_monoid linarith.comp))) := sorry --non-trivial
lemma new_lemma_160400 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (measure_theory.measure_space.{0} empty) (@function.extfun_app.{2 1} Type semiring.{0} h0 (measure_theory.measure_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_160401 (h0 : list (ring (option (option unsigned)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_160402 (h0 : topological_space (normed_comm_ring (has_add (has_add name)))) : loc_path_connected_space (normed_comm_ring (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_160403 (h0 : uniform_space (semigroup (has_nndist ennreal))) : separated_space (semigroup (has_nndist ennreal)) := sorry --non-trivial
lemma new_lemma_160404 (h0 : ring (has_div string_imp)) : rank_condition (has_div string_imp) := sorry --non-trivial
lemma new_lemma_160405 (h0 : ring (has_zero (has_add (has_add pos)))) : strong_rank_condition (has_zero (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_160406 (h0 : functor.add_const (semiring (semigroup pos)) (has_neg pos)) : @is_noetherian_ring.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (semiring.{0} (semigroup.{0} pos)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_160407 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_to_string.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_160408 (h1 : ring (normed_group (has_nnnorm string_imp))) : rank_condition (normed_group (has_nnnorm string_imp)) := sorry --non-trivial
lemma new_lemma_160409 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 nnreal) := sorry --non-trivial
lemma new_lemma_160410 (h0 : ring (normed_group (semiring empty))) : is_domain (normed_group (semiring empty)) := sorry --non-trivial
lemma new_lemma_160411 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_sub.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_sub.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_160412 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (@id.{2} Type to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (@id.{2} Type to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_160413 (h0 : monoid (with_bot (semiring (preorder (semiring (add_semigroup num)))))) : monoid.fg (with_bot (semiring (preorder (semiring (add_semigroup num))))) := sorry --non-trivial
lemma new_lemma_160414 (h0 : functor.add_const (list (has_add linarith.comp)) Type) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_160415 (h0 : functor.comp topological_space has_zero unsigned) : @topological_space.separable_space.{0} (has_zero.{0} unsigned) (@functor.comp.run.{0 0 0} topological_space.{0} has_zero.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_160416 (h0 : topological_space (has_neg_part (complete_distrib_lattice pos))) : topological_space.separable_space (has_neg_part (complete_distrib_lattice pos)) := sorry --non-trivial
lemma new_lemma_160417 (h1 : ring real.angle) : rank_condition real.angle := sorry --non-trivial
lemma new_lemma_160418 (h0 : ordered_add_comm_monoid (has_add (finset linarith.comp))) : archimedean (has_add (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_160419 (h1 : set (has_ssubset reducibility_hints)) : set.finite h1 := sorry --non-trivial
lemma new_lemma_160420 (h2 : topological_space (add_comm_semigroup enat)) : topological_space.first_countable_topology (add_comm_semigroup enat) := sorry --non-trivial
lemma new_lemma_160421 (h0 : not (ring (has_append linarith.comp_source) -> false)) : @strong_rank_condition.{0} (has_append.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (has_append.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_160422 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (left_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} h0 (left_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_160423 (h0 : functor.add_const (function.extfun (Type 1) add_monoid) pos) : @add_monoid.fg.{1} (ordered_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) add_monoid.{1}) pos h0) (ordered_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_160424 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (semigroup.{0} name) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_160425 (h1 : filter (add_left_cancel_monoid char)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_160426 (h0 : topological_space (ring (option (option empty)))) : t0_space (ring (option (option empty))) := sorry --non-trivial
lemma new_lemma_160427 (h0 : not (multiset (normed_field reducibility_hints) -> false)) (h1 : multiset (normed_field reducibility_hints)) : multiset.disjoint (classical.by_contradiction' h0) h1 := sorry --non-trivial
lemma new_lemma_160428 (h0 : filter (topological_space (linear_ordered_field ennreal))) : @locally_compact_space.{0} (linear_ordered_field.{0} ennreal) (@filter.Limsup.{0} (topological_space.{0} (linear_ordered_field.{0} ennreal)) (@complete_lattice.to_conditionally_complete_lattice.{0} (topological_space.{0} (linear_ordered_field.{0} ennreal)) (@topological_space.complete_lattice.{0} (linear_ordered_field.{0} ennreal))) h0)  := sorry --non-trivial
lemma new_lemma_160429 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_160430 (h0 : topological_space (comm_group (finset environment.implicit_infer_kind))) : preirreducible_space (comm_group (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_160431 (h0 : topological_space (with_bot (has_top (has_inv linarith.comp_source)))) : locally_compact_space (with_bot (has_top (has_inv linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_160432 (h0 : add_group (semigroup (has_neg_part pos))) : is_add_cyclic (semigroup (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_160433 (h0 : complete_lattice (plift (option num))) : is_compactly_generated (plift (option num)) := sorry --non-trivial
lemma new_lemma_160434 (h0 : complete_lattice (semigroup (complete_distrib_lattice pos))) : is_compactly_generated (semigroup (complete_distrib_lattice pos)) := sorry --non-trivial
lemma new_lemma_160435 (h0 : topological_space (has_add (finset pos))) : preconnected_space (has_add (finset pos)) := sorry --non-trivial
lemma new_lemma_160436 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (non_assoc_semiring.{0} empty) (@functor.add_const.run.{0 0} (monoid.{0} (non_assoc_semiring.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (monoid.{0} (non_assoc_semiring.{0} empty))) (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 (functor.add_const.{0 0} (monoid.{0} (non_assoc_semiring.{0} empty)))) empty))  := sorry --non-trivial
lemma new_lemma_160437 (h0 : topological_space (add_comm_monoid (normed_comm_ring unsigned))) : totally_separated_space (add_comm_monoid (normed_comm_ring unsigned)) := sorry --non-trivial
lemma new_lemma_160438 (h0 : functor.add_const (function.extfun Type ring) linarith.comp) : @rank_condition.{0} (ordered_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) linarith.comp h0) (ordered_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_160439 (h0 : topological_space (generalized_boolean_algebra (has_neg linarith.comp))) : loc_path_connected_space (generalized_boolean_algebra (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_160440 (h0 : functor.add_const (function.extfun Type uniform_space) pos) : @separated_space.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) pos h0) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_160441 (h0 : finset (finset (has_pos_part pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_160442 (h0 : functor.add_const (function.extfun (Type 1) monoid) (ring (has_neg Type))) : @monoid.fg.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) monoid.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) monoid.{1}) (ring.{1} (has_neg.{1} Type)) h0) (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_160443 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (sub_neg_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (sub_neg_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_160444 (h0 : topological_space (canonically_linear_ordered_monoid (sub_neg_monoid Type))) : regular_space (canonically_linear_ordered_monoid (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_160445 (h0 : complete_lattice (normed_group (random_gen (random_gen (random_gen (random_gen fun_info)))))) : is_compactly_generated (normed_group (random_gen (random_gen (random_gen (random_gen fun_info))))) := sorry --non-trivial
lemma new_lemma_160446 (h0 : cancel_comm_monoid_with_zero (has_nndist (has_nndist Type))) : unique_factorization_monoid (has_nndist (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_160447 (h0 : functor.add_const (topological_space (linear_order empty)) empty) : @loc_path_connected_space.{0} (linear_order.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_order.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_160448 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (measurable_space string_imp)) := sorry --non-trivial
lemma new_lemma_160449 (h0 : topological_space (add_comm_semigroup (mul_one_class (has_compl char)))) : path_connected_space (add_comm_semigroup (mul_one_class (has_compl char))) := sorry --non-trivial
lemma new_lemma_160450 (h0 : topological_space (generalized_boolean_algebra (has_Inf real))) : locally_compact_space (generalized_boolean_algebra (has_Inf real)) := sorry --non-trivial
lemma new_lemma_160451 (h0 : functor.add_const (function.extfun Type complete_lattice) (ring Type)) : @complete_lattice.is_Sup_finite_compact.{0} (add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type complete_lattice.{0}) (ring.{1} Type) h0) (add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_160452 (h0 : function.extfun Type (functor.add_const (monoid (linear_ordered_field num)))) : @monoid.fg.{0} (linear_ordered_field.{0} num) (@functor.add_const.run.{0 0} (monoid.{0} (linear_ordered_field.{0} num)) ennreal (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (monoid.{0} (linear_ordered_field.{0} num))) h0 ennreal))  := sorry --non-trivial
lemma new_lemma_160453 (h0 : topological_space (option unsigned)) : path_connected_space (option unsigned) := sorry --non-trivial
lemma new_lemma_160454 (h0 : topological_space (normed_group (has_inv to_additive.value_type))) : path_connected_space (normed_group (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_160455 (h1 : set (semi_normed_ring linarith.comp_source)) : set.finite h1 := sorry --non-trivial
lemma new_lemma_160456 (h0 : ring (has_nndist (has_add (finset (has_nndist (has_nndist (finset pos))))))) : rank_condition (has_nndist (has_add (finset (has_nndist (has_nndist (finset pos)))))) := sorry --non-trivial
lemma new_lemma_160457 (h0 : functor.add_const (topological_space (has_to_string unsigned)) linarith.comp) : @topological_space.separable_space.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_160458 (h0 : function.extfun Type ring) : @is_domain.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_160459 (h0 : group (measure_theory.measure_space (semiring (semiring (semiring congr_arg_kind))))) : group.fg (measure_theory.measure_space (semiring (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_160460 (h0 : group (uniform_space (random_gen (has_nnnorm reducibility_hints)))) : is_cyclic (uniform_space (random_gen (has_nnnorm reducibility_hints))) := sorry --non-trivial
lemma new_lemma_160461 (h0 : add_group (simple_graph (has_pos_part (has_Inf linarith.comp)))) : is_add_cyclic (simple_graph (has_pos_part (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_160462 (h2 : ring fun_info) : rank_condition fun_info := sorry --non-trivial
lemma new_lemma_160463 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (has_nndist.{0} (option.{0} unsigned)) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_nndist.{0} (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_160464 (h0 : functor.add_const (topological_space (finset name)) environment.implicit_infer_kind) : @sequential_space.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_160465 (h0 : add_monoid (normed_group unsigned)) : add_monoid.fg (normed_group unsigned) := sorry --non-trivial
lemma new_lemma_160466 (h0 : cancel_comm_monoid_with_zero (has_top unsigned)) : unique_factorization_monoid (has_top unsigned) := sorry --non-trivial
lemma new_lemma_160467 (h1 : add_group (normed_field std_gen)) : is_add_cyclic (normed_field std_gen) := sorry --non-trivial
lemma new_lemma_160468 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (comm_semigroup.{0} real) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (comm_semigroup.{0} real))  := sorry --non-trivial
lemma new_lemma_160469 (h0 : group (finset (has_nndist Type))) : is_cyclic (finset (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_160470 (h0 : functor.add_const (function.extfun Type ordered_add_comm_monoid) linarith.comp) : @archimedean.{0} (has_Inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_add_comm_monoid.{0}) linarith.comp h0) (has_Inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_160471 (h0 : functor.add_const (finset (complete_distrib_lattice Type)) name) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_160472 (h0 : complete_lattice (add_comm_monoid (ring name))) : is_compactly_generated (add_comm_monoid (ring name)) := sorry --non-trivial
lemma new_lemma_160473 (h0 : functor.add_const Prop (normed_comm_ring environment.implicit_infer_kind)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_160474 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (linear_order.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_160475 (h0 : semiring (has_pos_part (ring (has_Inf linarith.comp)))) : is_noetherian_ring (has_pos_part (ring (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_160476 (h0 : add_monoid (preorder (option (option empty)))) : add_monoid.fg (preorder (option (option empty))) := sorry --non-trivial
lemma new_lemma_160477 (h0 : functor.add_const (topological_space (boolean_algebra linarith.comp)) (finset linarith.comp)) : @regular_space.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} linarith.comp)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_160478 (h0 : complete_lattice (semiring (semiring unsigned))) : is_atomistic (semiring (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_160479 (h0 : topological_space (distrib_lattice (random_gen fun_info))) : path_connected_space (distrib_lattice (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_160480 (h0 : not (topological_space (mul_zero_class num) -> false)) : @topological_space.separable_space.{0} (mul_zero_class.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (mul_zero_class.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_160481 (h0 : functor.add_const (topological_space (boolean_algebra.core linarith.comp)) linarith.comp) : @t0_space.{0} (boolean_algebra.core.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_160482 (h1 : topological_space (has_add linarith.ineq)) : totally_disconnected_space (has_add linarith.ineq) := sorry --non-trivial
lemma new_lemma_160483 (h0 : complete_lattice (has_star congr_arg_kind)) : complete_lattice.is_Sup_finite_compact (has_star congr_arg_kind) := sorry --non-trivial
lemma new_lemma_160484 (h0 : topological_space (canonically_linear_ordered_monoid unsigned)) : t1_space (canonically_linear_ordered_monoid unsigned) := sorry --non-trivial
lemma new_lemma_160485 (h0 : add_group (linear_ordered_add_comm_group (comm_monoid_with_zero char))) : is_add_cyclic (linear_ordered_add_comm_group (comm_monoid_with_zero char)) := sorry --non-trivial
lemma new_lemma_160486 (h0 : functor.add_const (topological_space (measurable_space.dynkin_system num)) empty) : @locally_compact_space.{0} (measurable_space.dynkin_system.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (measurable_space.dynkin_system.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_160487 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (ordered_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_160488 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring name)) environment.implicit_infer_kind) : @t0_space.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_160489 (h0 : function.extfun (finset Type) (has_mem.mem (normed_group num))) : @totally_disconnected_space.{0} (normed_group.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (normed_group.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (normed_group.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_160490 (h0 : topological_space (finset (has_pos_part (has_neg (ring environment.implicit_infer_kind))))) : discrete_topology (finset (has_pos_part (has_neg (ring environment.implicit_infer_kind)))) := sorry --non-trivial
lemma new_lemma_160491 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_160492 (h0 : finset (has_pos_part (ordered_comm_monoid pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_160493 (h1 : ring (has_emptyc (random_gen congr_arg_kind))) : strong_rank_condition (has_emptyc (random_gen congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_160494 (h0 : cancel_comm_monoid_with_zero (left_cancel_monoid (semiring (semiring congr_arg_kind)))) : unique_factorization_monoid (left_cancel_monoid (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_160495 (h0 : functor.add_const (topological_space (has_to_string pos)) (has_neg linarith.comp)) : @locally_compact_space.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} pos)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_160496 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_union.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_union.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_160497 (h1 : group (with_bot linarith.ineq)) : is_cyclic (with_bot linarith.ineq) := sorry --non-trivial
lemma new_lemma_160498 (h0 : group (normed_linear_ordered_group empty)) : normalizer_condition (normed_linear_ordered_group empty) := sorry --non-trivial
lemma new_lemma_160499 (h0 : functor.add_const (topological_space (has_to_string Type)) name) : @irreducible_space.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_to_string.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_160500 (h0 : functor.add_const (function.extfun Type ordered_comm_monoid) pos) : @has_exists_mul_of_le.{0} (has_zero.{0} name) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) pos h0) (has_zero.{0} name))  := sorry --non-trivial
lemma new_lemma_160501 (h0 : functor.comp ring mul_zero_class unsigned) : @rank_condition.{0} (mul_zero_class.{0} unsigned) (@functor.comp.run.{0 0 0} ring.{0} mul_zero_class.{0} unsigned (@functor.comp.run.{0 0 0} ring.{0} mul_zero_class.{0} unsigned h0))  := sorry --non-trivial
lemma new_lemma_160502 (h0 : functor.add_const (list (has_Inf pos)) (ordered_ring pos)) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_160503 (h0 : function.extfun (Type 1) (functor.comp topological_space has_neg_part)) : @regular_space.{1} (has_neg_part.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} has_neg_part.{1} Type (@function.extfun_app.{3 2} (Type 1) (functor.comp.{1 1 1} topological_space.{1} has_neg_part.{1}) h0 Type))  := sorry --non-trivial
lemma new_lemma_160504 (h0 : add_group (additive (normed_field ereal))) (h1 : add_group (add_subgroup (additive (normed_field ereal)))) : is_add_cyclic (add_subgroup (additive (normed_field ereal))) := sorry --non-trivial
lemma new_lemma_160505 (h0 : function.extfun (finset Type) (has_mem.mem (measurable_space linarith.comp))) : @separated_space.{0} (measurable_space.{0} linarith.comp) (@finset.pi.empty.{1 0} Type uniform_space.{0} (measurable_space.{0} linarith.comp) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (measurable_space.{0} linarith.comp)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_160506 (h0 : filter (has_to_string (has_add (has_add Type)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_160507 (h1 : uniform_space (metric_space (comm_ring char))) : complete_space (metric_space (comm_ring char)) := sorry --non-trivial
lemma new_lemma_160508 (h0 : order_hom nat (uniform_space (random_gen linarith.ineq))) : @complete_space.{0} (random_gen.{0} linarith.ineq) (@monotonic_sequence_limit.{0} (uniform_space.{0} (random_gen.{0} linarith.ineq)) (@uniform_space.partial_order.{0} (random_gen.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_160509 (h0 : functor.add_const (topological_space (option congr_arg_kind)) (semiring empty)) : @preirreducible_space.{0} (option.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} congr_arg_kind)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_160510 (h0 : functor.add_const (ring (linear_ordered_cancel_comm_monoid num)) congr_arg_kind) : @rank_condition.{0} (linear_ordered_cancel_comm_monoid.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (linear_ordered_cancel_comm_monoid.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_160511 (h0 : fun_info -> fun_info -> fun_info) : associative h0 := sorry --non-trivial
lemma new_lemma_160512 (h0 : functor.add_const (list (finset ennreal)) unsigned) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_160513 (h0 : topological_space (semiring empty)) : locally_compact_space (semiring empty) := sorry --non-trivial
lemma new_lemma_160514 (h0 : functor.add_const (ordered_add_comm_monoid (complete_distrib_lattice name)) pos) : @archimedean.{0} (complete_distrib_lattice.{0} name) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (complete_distrib_lattice.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_160515 (h0 : topological_space (measure_theory.measure_space (semiring num))) (h1 : preorder (measure_theory.measure_space (semiring num))) : order_topology (measure_theory.measure_space (semiring num)) := sorry --non-trivial
lemma new_lemma_160516 (h0 : functor.add_const (group (add_cancel_monoid linarith.comp)) name) : @normalizer_condition.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (add_cancel_monoid.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_160517 (h0 : set (semi_normed_comm_ring string_imp)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_160518 (h0 : complete_lattice (has_neg_part unsigned)) : is_compactly_generated (has_neg_part unsigned) := sorry --non-trivial
lemma new_lemma_160519 (h0 : fin has_zero.zero) : @regular_space.{0} (has_Inf.{0} name) (@matrix.vec_empty.{0} (topological_space.{0} (has_Inf.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_160520 (h0 : complete_lattice (has_nnnorm (random_gen (has_nnnorm to_additive.value_type)))) : complete_lattice.is_Sup_finite_compact (has_nnnorm (random_gen (has_nnnorm to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_160521 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (measurable_space.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (measurable_space.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_160522 (h0 : function.extfun (Type 1) add_monoid) : @add_monoid.fg.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_monoid.{1} h0 (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_160523 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (has_neg.{0} linarith.comp) (@function.extfun_app.{2 1} Type semiring.{0} h0 (has_neg.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_160524 (h0 : topological_space (linear_ordered_comm_ring congr_arg_kind)) : irreducible_space (linear_ordered_comm_ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_160525 (h0 : ring (normed_group (semiring congr_arg_kind))) : rank_condition (normed_group (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_160526 (h0 : topological_space (measurable_space (has_union (has_union linarith.comp)))) : discrete_topology (measurable_space (has_union (has_union linarith.comp))) := sorry --non-trivial
lemma new_lemma_160527 (h0 : function.extfun Type (functor.comp ordered_comm_monoid normed_comm_ring)) : @has_exists_mul_of_le.{0} (normed_comm_ring.{0} name) (@functor.comp.run.{0 0 0} ordered_comm_monoid.{0} normed_comm_ring.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} ordered_comm_monoid.{0} normed_comm_ring.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_160528 (h1 : not (topological_space (normed_field string.iterator_imp) -> false)) : @t0_space.{0} (normed_field.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_field.{0} string.iterator_imp)) h1)  := sorry --non-trivial
lemma new_lemma_160529 (h0 : add_monoid (add_cancel_monoid (add_cancel_monoid (add_cancel_monoid pos)))) : add_monoid.fg (add_cancel_monoid (add_cancel_monoid (add_cancel_monoid pos))) := sorry --non-trivial
lemma new_lemma_160530 (h0 : function.extfun (finset ((Type -> Type) -> Type 1)) (has_mem.mem (function.extfun Type))) : @strong_rank_condition.{0} (has_top.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@finset.pi.empty.{2 1} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) (function.extfun.{2 1} Type) (@function.extfun_app.{3 0} (finset.{2} ((Type → Type) → Type 1)) (@has_mem.mem.{2 2} ((Type → Type) → Type 1) (finset.{2} ((Type → Type) → Type 1)) (@finset.has_mem.{2} ((Type → Type) → Type 1)) (function.extfun.{2 1} Type)) h0 (@has_emptyc.emptyc.{2} (finset.{2} ((Type → Type) → Type 1)) (@finset.has_emptyc.{2} ((Type → Type) → Type 1))))) ring.{0}) (has_top.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_160531 (h0 : complete_lattice (with_bot (has_top num))) : complete_lattice.is_Sup_finite_compact (with_bot (has_top num)) := sorry --non-trivial
lemma new_lemma_160532 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} (semi_normed_comm_ring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (semi_normed_comm_ring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_160533 (h0 : ring (has_union (has_one linarith.comp))) : is_domain (has_union (has_one linarith.comp)) := sorry --non-trivial
lemma new_lemma_160534 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (ring.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_160535 (h0 : not (function.extfun Type group -> false)) : @group.fg.{0} (linear_ordered_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (linear_ordered_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_160536 (h0 : uniform_space (cancel_monoid (comm_group (has_add Type)))) : separated_space (cancel_monoid (comm_group (has_add Type))) := sorry --non-trivial
lemma new_lemma_160537 (h3 : has_le linarith.ineq) (h4 : linarith.ineq) : is_bot h4 := sorry --non-trivial
lemma new_lemma_160538 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring Type)) linarith.comp) : @totally_separated_space.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (canonically_ordered_comm_semiring.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_160539 (h0 : topological_space (simple_graph (sub_neg_monoid linarith.comp))) : t0_space (simple_graph (sub_neg_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_160540 (h0 : ring (boolean_algebra.core (comm_group (add_cancel_monoid Type)))) : is_principal_ideal_ring (boolean_algebra.core (comm_group (add_cancel_monoid Type))) := sorry --non-trivial
lemma new_lemma_160541 (h0 : comm_ring linarith.comp_source) (h1 : ring (add_cancel_comm_monoid linarith.comp_source)) (h2 : algebra linarith.comp_source (add_cancel_comm_monoid linarith.comp_source)) : algebra.is_integral linarith.comp_source (add_cancel_comm_monoid linarith.comp_source) := sorry --non-trivial
lemma new_lemma_160542 (h0 : functor.add_const (function.extfun Type add_monoid) linarith.comp) : @add_monoid.fg.{0} (has_zero.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_monoid.{0}) linarith.comp h0) (has_zero.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_160543 (h0 : functor.add_const (complete_lattice (boolean_algebra pos)) Type) : @complete_lattice.is_Sup_finite_compact.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 1} (complete_lattice.{0} (boolean_algebra.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_160544 (h1 : topological_space (has_compl (random_gen (has_ssubset string_imp)))) : path_connected_space (has_compl (random_gen (has_ssubset string_imp))) := sorry --non-trivial
lemma new_lemma_160545 (h0 : functor.add_const (complete_lattice (boolean_algebra Type)) (has_add pos)) : @complete_lattice.is_Sup_finite_compact.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (boolean_algebra.{1} Type)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_160546 (h0 : topological_space (semiring (has_top linarith.comp))) : totally_disconnected_space (semiring (has_top linarith.comp)) := sorry --non-trivial
lemma new_lemma_160547 (h1 : not (add_group (normed_field char) -> false)) : @is_add_cyclic.{0} (normed_field.{0} char) (@classical.by_contradiction'.{1} (add_group.{0} (normed_field.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_160548 (h0 : functor.add_const (function.extfun Type uniform_space) (finset pos)) : @complete_space.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) (finset.{0} pos) h0) (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_160549 (h0 : semiring (canonically_ordered_monoid pos)) : is_noetherian_ring (canonically_ordered_monoid pos) := sorry --non-trivial
lemma new_lemma_160550 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (boolean_algebra.core.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_160551 (h0 : ring (has_norm (semiring unsigned))) : strong_rank_condition (has_norm (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_160552 (h0 : functor.add_const (add_monoid (left_cancel_monoid congr_arg_kind)) unsigned) : @add_monoid.fg.{0} (left_cancel_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (add_monoid.{0} (left_cancel_monoid.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_160553 (h0 : group (ordered_comm_ring linarith.comp)) : is_cyclic (ordered_comm_ring linarith.comp) := sorry --non-trivial
lemma new_lemma_160554 (h0 : functor.add_const (topological_space (add_comm_monoid pos)) (has_neg linarith.comp)) : @regular_space.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} pos)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_160555 (h1 : not (function.extfun Type topological_space -> false)) : @totally_separated_space.{0} (has_vadd.{0 0} linarith.comp_source num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h1) (has_vadd.{0 0} linarith.comp_source num))  := sorry --non-trivial
lemma new_lemma_160556 (h0 : functor.add_const (filter (semigroup linarith.comp)) (has_to_string environment.implicit_infer_kind)) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_160557 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (linear_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_160558 (h0 : function.extfun (Type 1) add_monoid) : @add_monoid.fg.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_monoid.{1} h0 (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_160559 (h0 : functor.add_const (topological_space (has_nndist pos)) pos) : @t1_space.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_160560 (h0 : complete_lattice (normed_lattice_add_comm_group (has_Inf (has_Inf (has_add Type))))) : is_compactly_generated (normed_lattice_add_comm_group (has_Inf (has_Inf (has_add Type)))) := sorry --non-trivial
lemma new_lemma_160561 (h0 : not (topological_space (measure_theory.measure_space empty) -> false)) : @topological_space.separable_space.{0} (measure_theory.measure_space.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (measure_theory.measure_space.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_160562 (h0 : topological_space (complete_distrib_lattice (has_Inf pos))) : t1_space (complete_distrib_lattice (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_160563 (h0 : functor.add_const (function.extfun (Type 1) group) (has_add Type)) : @is_cyclic.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) group.{1}) (has_add.{1} Type) h0) (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_160564 (h0 : topological_space (has_Inf (normed_comm_ring pos))) : sequential_space (has_Inf (normed_comm_ring pos)) := sorry --non-trivial
lemma new_lemma_160565 (h0 : list (simple_graph (has_pos_part (has_Inf Type)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_160566 (h0 : function.extfun Type group) : @normalizer_condition.{0} (semiring.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} h0 (semiring.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_160567 (h0 : add_group (linear_ordered_field (option (option (option ennreal))))) : is_add_cyclic (linear_ordered_field (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_160568 (h0 : add_monoid (canonically_linear_ordered_monoid (has_Inf Type))) : add_monoid.fg (canonically_linear_ordered_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_160569 (h0 : topological_space (has_sub empty)) : discrete_topology (has_sub empty) := sorry --non-trivial
lemma new_lemma_160570 (h0 : not (topological_space (measure_theory.measure_space unsigned) -> false)) : @totally_separated_space.{0} (measure_theory.measure_space.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (measure_theory.measure_space.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_160571 (h0 : functor.add_const (topological_space (finset environment.implicit_infer_kind)) environment.implicit_infer_kind) : @path_connected_space.{0} (finset.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_160572 (h0 : mul_one_class (mul_one_class (mul_one_class (mul_one_class (mul_one_class environment.projection_info))))) (h1 : topological_space environment.projection_info) : t0_space environment.projection_info := sorry --non-trivial
lemma new_lemma_160573 (h1 : complete_lattice (semi_normed_comm_ring char)) : complete_lattice.is_Sup_finite_compact (semi_normed_comm_ring char) := sorry --non-trivial
lemma new_lemma_160574 (h0 : ring (add_comm_monoid empty)) : is_principal_ideal_ring (add_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_160575 (h0 : add_group (with_bot (semiring (semiring (semiring (semiring empty)))))) : is_add_cyclic (with_bot (semiring (semiring (semiring (semiring empty))))) := sorry --non-trivial
lemma new_lemma_160576 (h0 : topological_space (has_zero (has_to_string (has_to_string pos)))) : path_connected_space (has_zero (has_to_string (has_to_string pos))) := sorry --non-trivial
lemma new_lemma_160577 (h0 : functor.add_const (cancel_comm_monoid_with_zero (comm_group environment.implicit_infer_kind)) Type) : @unique_factorization_monoid.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (cancel_comm_monoid_with_zero.{0} (comm_group.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_160578 (h0 : topological_space (distrib (distrib fun_info))) : totally_disconnected_space (distrib (distrib fun_info)) := sorry --non-trivial
lemma new_lemma_160579 (h0 : topological_space (boolean_algebra (boolean_algebra.core environment.implicit_infer_kind))) : locally_compact_space (boolean_algebra (boolean_algebra.core environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_160580 (h0 : complete_lattice (linear_ordered_add_comm_group (has_top (has_top fun_info)))) : is_compactly_generated (linear_ordered_add_comm_group (has_top (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_160581 (h0 : functor.add_const (topological_space (has_to_string name)) pos) : @t1_space.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_160582 (h0 : functor.add_const (function.extfun Type topological_space) (ring linarith.comp)) : @topological_space.separable_space.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (ring.{0} linarith.comp) h0) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_160583 (h2 h3 : multiset reducibility_hints) : multiset.subset h2 h3 := sorry --non-trivial
lemma new_lemma_160584 (h0 : fin has_zero.zero) : @rank_condition.{0} (canonically_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ring.{0}) h0) (canonically_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_160585 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_160586 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_norm.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} h0 (has_norm.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_160587 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (semiring to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_160588 (h0 : topological_space (semi_normed_ring (mul_one_class string.iterator_imp))) : t0_space (semi_normed_ring (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_160589 (h0 : functor.add_const (complete_lattice (canonically_linear_ordered_monoid unsigned)) pos) : @is_compactly_generated.{0} (canonically_linear_ordered_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (canonically_linear_ordered_monoid.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_160590 (h0 : topological_space (comm_group (has_add (semigroup (semigroup (comm_group unsigned)))))) : normal_space (comm_group (has_add (semigroup (semigroup (comm_group unsigned))))) := sorry --non-trivial
lemma new_lemma_160591 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (ordered_comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_160592 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (add_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (add_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_160593 (h0 : functor.add_const (topological_space (complete_distrib_lattice linarith.comp)) (finset linarith.comp)) : @preirreducible_space.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} linarith.comp)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_160594 (h0 : complete_lattice (simple_graph (mul_one_class string_imp))) : complete_lattice.is_Sup_finite_compact (simple_graph (mul_one_class string_imp)) := sorry --non-trivial
lemma new_lemma_160595 (h0 : functor.add_const (filter (mul_zero_class name)) environment.implicit_infer_kind) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_160596 (h0 : topological_space (has_neg ennreal)) : preirreducible_space (has_neg ennreal) := sorry --non-trivial
lemma new_lemma_160597 (h0 : pnat) (h1 : with_bot pnat) (h2 : list (with_bot pnat)) (h3 : ne (list.ilast' h1 h2) has_bot.bot) : pnat.coprime h0 (with_bot.unbot (list.ilast' h1 h2) h3) := sorry --non-trivial
lemma new_lemma_160598 (h0 : function.extfun Type group) : @group.fg.{0} (linear_ordered_cancel_comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (linear_ordered_cancel_comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_160599 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_ssubset.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_ssubset.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_160600 (h0 : function.extfun (Type 1) ring) : @is_principal_ideal_ring.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_160601 (h0 : not (monoid (has_norm unsigned) -> false)) : @monoid.fg.{0} (has_norm.{0} unsigned) (@classical.by_contradiction'.{1} (monoid.{0} (has_norm.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_160602 (h0 : topological_space (canonically_ordered_comm_semiring (normed_comm_ring name))) : t0_space (canonically_ordered_comm_semiring (normed_comm_ring name)) := sorry --non-trivial
lemma new_lemma_160603 (h0 : complete_lattice (filter num)) : is_compactly_generated (filter num) := sorry --non-trivial
lemma new_lemma_160604 (h1 : add_group (semi_normed_comm_ring fun_info)) : is_add_cyclic (semi_normed_comm_ring fun_info) := sorry --non-trivial
lemma new_lemma_160605 (h1 : function.extfun Type topological_space) : @irreducible_space.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (complete_semilattice_Sup.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_160606 (h0 : semiring (has_pos_part (has_add Type))) : is_noetherian_ring (has_pos_part (has_add Type)) := sorry --non-trivial
lemma new_lemma_160607 (h0 : functor.add_const (cancel_comm_monoid_with_zero (add_comm_monoid linarith.comp)) linarith.comp) : @unique_factorization_monoid.{0} (add_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (add_comm_monoid.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_160608 (h0 : functor.add_const (ring znum) (option (option empty))) : @strong_rank_condition.{0} znum (@functor.add_const.run.{0 0} (ring.{0} znum) (option.{0} (option.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_160609 (h0 : complete_lattice (linear_order (option empty))) : is_compactly_generated (linear_order (option empty)) := sorry --non-trivial
lemma new_lemma_160610 (h0 : not (finset (measure_theory.measure_space num) -> false)) : finset.nonempty (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_160611 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (bin_tree.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (bin_tree.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_160612 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (as_linear_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (as_linear_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_160613 (h0 : topological_space (has_add (has_Inf (has_pos_part Type)))) : irreducible_space (has_add (has_Inf (has_pos_part Type))) := sorry --non-trivial
lemma new_lemma_160614 (h0 : topological_space (add_left_cancel_monoid string_imp)) (h1 : preorder (add_left_cancel_monoid string_imp)) : order_topology (add_left_cancel_monoid string_imp) := sorry --non-trivial
lemma new_lemma_160615 (h0 : functor.add_const (group (measurable_space.dynkin_system unsigned)) empty) : @group.fg.{0} (measurable_space.dynkin_system.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (measurable_space.dynkin_system.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_160616 (h0 : add_monoid (linear_ordered_semiring (has_norm (has_norm linarith.comp)))) : add_monoid.fg (linear_ordered_semiring (has_norm (has_norm linarith.comp))) := sorry --non-trivial
lemma new_lemma_160617 (h0 : topological_space (with_one (has_nnnorm (has_nnnorm fun_info)))) : totally_disconnected_space (with_one (has_nnnorm (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_160618 (h0 : topological_space (comm_group (has_add environment.implicit_infer_kind))) : t0_space (comm_group (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_160619 (h0 : complete_lattice (pseudo_metric_space to_additive.value_type)) : complete_lattice.is_Sup_finite_compact (pseudo_metric_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_160620 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (has_zero.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_160621 (h0 : topological_space (nondiscrete_normed_field char)) (h1 : add_group (nondiscrete_normed_field char)) : topological_add_group (nondiscrete_normed_field char) := sorry --non-trivial
lemma new_lemma_160622 (h0 : prod (normed_group num) (normed_group num)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_160623 (h0 : list (semigroup (option (option name)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_160624 (h0 : not (fin has_zero.zero -> false)) : @Lim.{0} Prop sierpinski_space (@nonempty_of_inhabited.{1} Prop sort.inhabited.{0}) (@id.{1} (filter.{0} Prop) (@id.{1} (filter.{0} Prop) (@matrix.vec_empty.{0} (filter.{0} Prop) (@classical.by_contradiction'.{1} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))))  := sorry --non-trivial
lemma new_lemma_160625 (h0 : group (ordered_comm_ring pos)) : is_simple_group (ordered_comm_ring pos) := sorry --non-trivial
lemma new_lemma_160626 (h0 : ring (semi_normed_ring (has_lt (mul_one_class char)))) : rank_condition (semi_normed_ring (has_lt (mul_one_class char))) := sorry --non-trivial
lemma new_lemma_160627 (h0 : topological_space (boolean_algebra pos)) : path_connected_space (boolean_algebra pos) := sorry --non-trivial
lemma new_lemma_160628 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (left_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (left_cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_160629 (h0 : not (ring (bin_tree empty) -> false)) : @is_domain.{0} (bin_tree.{0} empty) (@classical.by_contradiction'.{1} (ring.{0} (bin_tree.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_160630 (h0 : function.extfun Type (functor.add_const (list ennreal))) : list.nodup (functor.add_const.run (function.extfun_app h0 ennreal)) := sorry --non-trivial
lemma new_lemma_160631 (h0 : group (ring unsigned)) : normalizer_condition (ring unsigned) := sorry --non-trivial
lemma new_lemma_160632 (h1 : group (linear_ordered_add_comm_group (random_gen char))) : is_cyclic (linear_ordered_add_comm_group (random_gen char)) := sorry --non-trivial
lemma new_lemma_160633 (h0 : topological_space (encodable (has_nnnorm fun_info))) : t0_space (encodable (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_160634 (h0 : topological_space (has_union congr_arg_kind)) : path_connected_space (has_union congr_arg_kind) := sorry --non-trivial
lemma new_lemma_160635 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (measurable_space.dynkin_system.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measurable_space.dynkin_system.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_160636 (h0 h1 : multiset (has_nnnorm ereal)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_160637 (h0 : add_group (cancel_monoid unsigned)) : is_add_cyclic (cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_160638 (h0 : has_mem.mem (random_gen linarith.comp_source) has_emptyc.emptyc) : @irreducible_space.{0} (random_gen.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (random_gen.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_160639 (h0 : topological_space (id linarith.ineq)) : path_connected_space (id linarith.ineq) := sorry --non-trivial
lemma new_lemma_160640 (h0 : ring (ordered_comm_ring (has_pos_part Type))) : strong_rank_condition (ordered_comm_ring (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_160641 (h1 : function.extfun Type topological_space) : @path_connected_space.{0} (linear_ordered_semiring.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (linear_ordered_semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_160642 (h0 : nat) (h1 : false) (h2 : fin h0) : vector.nth (false.elim h1) h2 := sorry --trivial
lemma new_lemma_160643 (h0 : function.extfun Type group) : @normalizer_condition.{0} (mul_zero_class.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} h0 (mul_zero_class.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_160644 (h0 : has_mem.mem (metric_space unsigned) has_emptyc.emptyc) : @locally_compact_space.{0} (metric_space.{0} unsigned) (@finset.pi.empty.{1 0} Type topological_space.{0} (metric_space.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_160645 (h0 : add_group (normed_comm_ring (has_neg Type))) : is_add_cyclic (normed_comm_ring (has_neg Type)) := sorry --non-trivial
lemma new_lemma_160646 (h1 : ring (normed_group congr_arg_kind)) : strong_rank_condition (normed_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_160647 (h0 : uniform_space (has_pos_part (has_Inf (has_Inf real)))) : separated_space (has_pos_part (has_Inf (has_Inf real))) := sorry --non-trivial
lemma new_lemma_160648 (h0 : functor.add_const (semiring (ordered_comm_ring Type)) pos) : @is_noetherian_ring.{1} (ordered_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (semiring.{1} (ordered_comm_ring.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_160649 (h0 : not (function.extfun (Type 1) list -> false)) : list.nodup (function.extfun_app (classical.by_contradiction' h0) (plift empty)) := sorry --non-trivial
lemma new_lemma_160650 (h0 : topological_space (has_top (has_norm congr_arg_kind))) : irreducible_space (has_top (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_160651 (h0 : group (semigroup (has_add (has_to_string pos)))) : is_simple_group (semigroup (has_add (has_to_string pos))) := sorry --non-trivial
lemma new_lemma_160652 (h0 : not (group (add_right_cancel_monoid empty) -> false)) : @is_cyclic.{0} (add_right_cancel_monoid.{0} empty) (@classical.by_contradiction'.{1} (group.{0} (add_right_cancel_monoid.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_160653 (h0 : complete_lattice (semigroup (option pos))) : complete_lattice.is_Sup_finite_compact (semigroup (option pos)) := sorry --non-trivial
lemma new_lemma_160654 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 name) := sorry --non-trivial
lemma new_lemma_160655 (h0 : group (has_neg (add_comm_monoid Type))) : is_cyclic (has_neg (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_160656 (h0 : topological_space (has_norm (semiring empty))) : locally_compact_space (has_norm (semiring empty)) := sorry --non-trivial
lemma new_lemma_160657 (h0 : topological_space (has_sub congr_arg_kind)) : irreducible_space (has_sub congr_arg_kind) := sorry --non-trivial
lemma new_lemma_160658 (h0 : cancel_comm_monoid_with_zero (canonically_ordered_comm_semiring (has_add (finset pos)))) : unique_factorization_monoid (canonically_ordered_comm_semiring (has_add (finset pos))) := sorry --non-trivial
lemma new_lemma_160659 (h0 : fin has_zero.zero) : @rank_condition.{1} (has_bot.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (has_bot.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_160660 (h0 : prod (has_top congr_arg_kind) (has_top congr_arg_kind)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_160661 (h0 : topological_space (has_zero (has_add (has_add ennreal)))) : totally_disconnected_space (has_zero (has_add (has_add ennreal))) := sorry --non-trivial
lemma new_lemma_160662 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} linarith.ineq (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) linarith.ineq)  := sorry --non-trivial
lemma new_lemma_160663 (h0 : ring (has_append (has_ssubset (has_ssubset (has_ssubset (has_ssubset (has_ssubset char))))))) : is_domain (has_append (has_ssubset (has_ssubset (has_ssubset (has_ssubset (has_ssubset char)))))) := sorry --non-trivial
lemma new_lemma_160664 (h0 : add_group (left_cancel_semigroup unsigned)) (h1 : option (add_group (left_cancel_semigroup unsigned))) : is_add_cyclic (left_cancel_semigroup unsigned) := sorry --non-trivial
lemma new_lemma_160665 (h0 : group (canonically_ordered_monoid (sub_neg_monoid pos))) : is_cyclic (canonically_ordered_monoid (sub_neg_monoid pos)) := sorry --non-trivial
lemma new_lemma_160666 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (linear_ordered_semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_160667 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (comm_semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_160668 (h1 : ring (div_inv_monoid fun_info)) : rank_condition (div_inv_monoid fun_info) := sorry --non-trivial
lemma new_lemma_160669 (h0 : group (semigroup (canonically_linear_ordered_monoid ennreal))) : normalizer_condition (semigroup (canonically_linear_ordered_monoid ennreal)) := sorry --non-trivial
lemma new_lemma_160670 (h0 : function.extfun Type topological_space) : @t0_space.{0} (group_with_zero.{0} (option.{0} ennreal)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (group_with_zero.{0} (option.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_160671 (h0 : not (topological_space (comm_ring string.iterator_imp) -> false)) : @path_connected_space.{0} (comm_ring.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (topological_space.{0} (comm_ring.{0} string.iterator_imp)) h0)  := sorry --non-trivial
lemma new_lemma_160672 (h0 : functor.add_const (topological_space (has_to_string linarith.comp)) environment.implicit_infer_kind) : @sequential_space.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_160673 (h1 : not (add_group (normed_field string_imp) -> false)) : @is_add_cyclic.{0} (normed_field.{0} string_imp) (@classical.by_contradiction'.{1} (add_group.{0} (normed_field.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_160674 (h0 : fin has_zero.zero) (h1 : decidable (matrix.vec_empty h0)) : as_false (matrix.vec_empty h0) := sorry --non-trivial
lemma new_lemma_160675 (h0 : not (ring (has_norm fun_info) -> false)) : @strong_rank_condition.{0} (has_norm.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (has_norm.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_160676 (h0 : functor.comp cancel_comm_monoid_with_zero has_neg linarith.comp) : @unique_factorization_monoid.{0} (has_neg.{0} linarith.comp) (@functor.comp.run.{0 0 0} cancel_comm_monoid_with_zero.{0} has_neg.{0} linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_160677 (h0 : group (canonically_ordered_comm_semiring (option (option (option unsigned))))) : is_cyclic (canonically_ordered_comm_semiring (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_160678 (h0 : group (comm_group (ring linarith.comp))) : normalizer_condition (comm_group (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_160679 (h0 : functor.comp topological_space canonically_ordered_comm_semiring name) : @t0_space.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} canonically_ordered_comm_semiring.{0} name h0)  := sorry --non-trivial
lemma new_lemma_160680 (h0 : functor.add_const (topological_space (boolean_algebra Type)) (boolean_algebra pos)) : @preconnected_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.{1} Type)) (boolean_algebra.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_160681 (h0 : function.extfun Type (functor.add_const (group (left_cancel_semigroup congr_arg_kind)))) : @normalizer_condition.{0} (left_cancel_semigroup.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (group.{0} (left_cancel_semigroup.{0} congr_arg_kind)) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (group.{0} (left_cancel_semigroup.{0} congr_arg_kind))) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_160682 (h0 : functor.add_const (add_group (boolean_algebra Type)) (has_to_string (has_add pos))) : @is_add_cyclic.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (add_group.{1} (boolean_algebra.{1} Type)) (has_to_string.{0} (has_add.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_160683 (h0 : not (function.extfun Type list -> false)) : list.nodup (function.extfun_app (classical.by_contradiction' h0) (has_star empty)) := sorry --non-trivial
lemma new_lemma_160684 (h0 : ring (random_gen (has_nnnorm (has_nnnorm fun_info)))) : is_domain (random_gen (has_nnnorm (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_160685 (h0 : complete_lattice (measurable_space (has_norm num))) : is_atomistic (measurable_space (has_norm num)) := sorry --non-trivial
lemma new_lemma_160686 (h0 : ring (left_cancel_semigroup (semiring unsigned))) : strong_rank_condition (left_cancel_semigroup (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_160687 (h0 : functor.add_const (topological_space (add_semigroup num)) empty) : @totally_disconnected_space.{0} (add_semigroup.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (add_semigroup.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_160688 (h0 : complete_lattice (linear_ordered_comm_group congr_arg_kind)) : is_compactly_generated (linear_ordered_comm_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_160689 (h0 : ring (complete_distrib_lattice linarith.ineq)) : is_domain (complete_distrib_lattice linarith.ineq) := sorry --non-trivial
lemma new_lemma_160690 (h0 : ring (has_pos_part (has_nndist linarith.comp))) : is_domain (has_pos_part (has_nndist linarith.comp)) := sorry --non-trivial
lemma new_lemma_160691 (h0 : finset (add_cancel_comm_monoid unsigned)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_160692 (h0 : group (normed_lattice_add_comm_group (has_add linarith.comp))) : is_cyclic (normed_lattice_add_comm_group (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_160693 (h1 : topological_space std_gen) : t0_space std_gen := sorry --non-trivial
lemma new_lemma_160694 (h0 : topological_space (non_unital_non_assoc_semiring (mul_one_class char))) : totally_disconnected_space (non_unital_non_assoc_semiring (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_160695 (h0 : functor.add_const (group (generalized_boolean_algebra Type)) pos) : @is_cyclic.{1} (generalized_boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (generalized_boolean_algebra.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_160696 (h0 : functor.add_const (complete_lattice (add_comm_monoid pos)) (has_to_string (has_to_string (has_to_string pos)))) : @is_compactly_generated.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_comm_monoid.{0} pos)) (has_to_string.{0} (has_to_string.{0} (has_to_string.{0} pos))) h0)  := sorry --non-trivial
lemma new_lemma_160697 (h0 : topological_space (has_ssubset (semigroup ereal))) : totally_disconnected_space (has_ssubset (semigroup ereal)) := sorry --non-trivial
lemma new_lemma_160698 (h0 : add_group (semi_normed_comm_ring std_gen)) : is_add_cyclic (semi_normed_comm_ring std_gen) := sorry --non-trivial
lemma new_lemma_160699 (h0 : ring (has_add (ring (complete_distrib_lattice name)))) : is_principal_ideal_ring (has_add (ring (complete_distrib_lattice name))) := sorry --non-trivial
lemma new_lemma_160700 (h0 : has_mem.mem (linear_ordered_add_comm_group (has_top linarith.ineq)) has_emptyc.emptyc) : @totally_disconnected_space.{0} (linear_ordered_add_comm_group.{0} (has_top.{0} linarith.ineq)) (@finset.pi.empty.{1 0} Type topological_space.{0} (linear_ordered_add_comm_group.{0} (has_top.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_160701 (h0 : fin has_zero.zero) : @t0_space.{1} (has_pos_part.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (has_pos_part.{1} Type)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)))  := sorry --non-trivial
lemma new_lemma_160702 (h0 : topological_space (has_neg (comm_group Type))) : discrete_topology (has_neg (comm_group Type)) := sorry --non-trivial
lemma new_lemma_160703 (h0 : topological_space (topological_space (has_nnnorm fun_info))) : path_connected_space (topological_space (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_160704 (h0 : complete_lattice (linear_ordered_comm_group_with_zero linarith.ineq)) : complete_lattice.is_Sup_finite_compact (linear_ordered_comm_group_with_zero linarith.ineq) := sorry --non-trivial
lemma new_lemma_160705 (h0 : complete_lattice (cancel_monoid (option (option (option ennreal))))) : is_atomistic (cancel_monoid (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_160706 (h0 : complete_lattice (has_add (has_add name))) : is_atomistic (has_add (has_add name)) := sorry --non-trivial
lemma new_lemma_160707 (h1 : order_hom nat (uniform_space string_imp)) : @complete_space.{0} string_imp (@monotonic_sequence_limit.{0} (uniform_space.{0} string_imp) (@uniform_space.partial_order.{0} string_imp) h1)  := sorry --non-trivial
lemma new_lemma_160708 (h0 : ring (has_append fun_info)) : is_domain (has_append fun_info) := sorry --non-trivial
lemma new_lemma_160709 (h0 : topological_space (canonically_linear_ordered_monoid (has_Inf (has_add real)))) : t0_space (canonically_linear_ordered_monoid (has_Inf (has_add real))) := sorry --non-trivial
lemma new_lemma_160710 (h0 : topological_space (has_add congr_arg_kind)) : totally_disconnected_space (has_add congr_arg_kind) := sorry --non-trivial
lemma new_lemma_160711 (h0 : finset (has_to_string (has_neg ennreal))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_160712 (h0 : topological_space (boolean_algebra (normed_comm_ring (finset linarith.comp)))) : irreducible_space (boolean_algebra (normed_comm_ring (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_160713 (h1 : add_group (with_bot string_imp)) : is_add_cyclic (with_bot string_imp) := sorry --non-trivial
lemma new_lemma_160714 (h0 : set (comm_monoid linarith.ineq)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_160715 (h0 : topological_space (has_zero (mul_zero_class pos))) : preirreducible_space (has_zero (mul_zero_class pos)) := sorry --non-trivial
lemma new_lemma_160716 (h0 : group (finset (has_neg (finset linarith.comp)))) : is_cyclic (finset (has_neg (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_160717 (h0 : group (semigroup (semigroup (boolean_algebra.core (semigroup Type))))) : is_simple_group (semigroup (semigroup (boolean_algebra.core (semigroup Type)))) := sorry --non-trivial
lemma new_lemma_160718 (h0 : ring (normed_field string_imp)) : strong_rank_condition (normed_field string_imp) := sorry --non-trivial
lemma new_lemma_160719 (h0 : functor.add_const (add_monoid (has_to_string pos)) linarith.comp) : @add_monoid.fg.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_to_string.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_160720 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_norm.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_norm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_160721 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_union.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_union.{0} empty))  := sorry --non-trivial
lemma new_lemma_160722 (h0 : not (filter (has_ssubset string_imp) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_160723 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (option.{0} ennreal) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (option.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_160724 (h0 : functor.add_const (function.extfun Type group) Type) : @is_cyclic.{0} (has_neg.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type group.{0}) Type h0) (has_neg.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_160725 (h2 : complete_lattice reducibility_hints) : is_compactly_generated reducibility_hints := sorry --non-trivial
lemma new_lemma_160726 (h0 : topological_space (add_cancel_monoid (has_neg pos))) : regular_space (add_cancel_monoid (has_neg pos)) := sorry --non-trivial
lemma new_lemma_160727 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_norm.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_norm.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_160728 (h0 : add_monoid (semigroup empty)) : add_monoid.fg (semigroup empty) := sorry --non-trivial
lemma new_lemma_160729 (h0 : functor.add_const (function.extfun Type ring) linarith.comp) : @is_principal_ideal_ring.{0} (ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) linarith.comp h0) (ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_160730 (h0 : topological_space (has_nnnorm (has_mul (has_nnnorm fun_info)))) : path_connected_space (has_nnnorm (has_mul (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_160731 (h0 : ring (has_div string.iterator_imp)) : rank_condition (has_div string.iterator_imp) := sorry --non-trivial
lemma new_lemma_160732 (h0 : functor.add_const (topological_space (semigroup Type)) pos) : @t0_space.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (semigroup.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_160733 (h0 : topological_space (metric_space (random_gen (has_norm (semiring empty))))) : preirreducible_space (metric_space (random_gen (has_norm (semiring empty)))) := sorry --non-trivial
lemma new_lemma_160734 (h0 : functor.add_const (topological_space (add_comm_monoid pos)) Type) : @discrete_topology.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (add_comm_monoid.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_160735 (h0 : functor.add_const (function.extfun Type monoid) linarith.comp) : @monoid.fg.{0} (semigroup.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type monoid.{0}) linarith.comp h0) (semigroup.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_160736 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_star.{0} (has_inner.{0 0} unsigned (has_inner.{0 0} unsigned (has_inner.{0 0} empty congr_arg_kind)))) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_star.{0} (has_inner.{0 0} unsigned (has_inner.{0 0} unsigned (has_inner.{0 0} empty congr_arg_kind)))))  := sorry --non-trivial
lemma new_lemma_160737 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @path_connected_space.{0} (semiring.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (semiring.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_160738 (h0 : functor.add_const (add_group (has_to_string pos)) pos) : @is_add_cyclic.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (has_to_string.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_160739 (h0 : functor.add_const (function.extfun Type add_group) pos) : @is_add_cyclic.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type add_group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_group.{0}) pos h0) (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_160740 (h0 : group char) : normalizer_condition char := sorry --non-trivial
lemma new_lemma_160741 (h0 : functor.add_const (topological_space (ring name)) pos) : @loc_path_connected_space.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_160742 (h0 : ring (normed_group (semiring num))) : is_principal_ideal_ring (normed_group (semiring num)) := sorry --non-trivial
lemma new_lemma_160743 (h0 : prod (mul_zero_class (has_nndist (option name))) (mul_zero_class (has_nndist (option name)))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_160744 (h0 : ring (has_ssubset string_imp)) : strong_rank_condition (has_ssubset string_imp) := sorry --non-trivial
lemma new_lemma_160745 (h0 : group (boolean_algebra.core unsigned)) : is_simple_group (boolean_algebra.core unsigned) := sorry --non-trivial
lemma new_lemma_160746 (h0 : topological_space (boolean_algebra.core empty)) : preirreducible_space (boolean_algebra.core empty) := sorry --non-trivial
lemma new_lemma_160747 (h0 : functor.add_const (topological_space (cancel_monoid num)) unsigned) : @normal_space.{0} (cancel_monoid.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_160748 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (has_inv.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_inv.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_160749 (h0 : group (has_bot (option unsigned))) : is_cyclic (has_bot (option unsigned)) := sorry --non-trivial
lemma new_lemma_160750 (h0 : topological_space (semigroup (comm_group Type))) : totally_separated_space (semigroup (comm_group Type)) := sorry --non-trivial
lemma new_lemma_160751 (h0 : topological_space (ring (has_neg_part name))) : preconnected_space (ring (has_neg_part name)) := sorry --non-trivial
lemma new_lemma_160752 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (as_linear_order.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (as_linear_order.{0} num))  := sorry --non-trivial
lemma new_lemma_160753 (h0 : functor.comp ring finset unsigned) : @strong_rank_condition.{0} (finset.{0} unsigned) (@functor.comp.run.{0 0 0} ring.{0} finset.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_160754 (h0 : topological_space (random_gen (has_norm num))) : locally_compact_space (random_gen (has_norm num)) := sorry --non-trivial
lemma new_lemma_160755 (h0 : topological_space (boolean_algebra (has_pos_part (ordered_comm_monoid Type)))) : regular_space (boolean_algebra (has_pos_part (ordered_comm_monoid Type))) := sorry --non-trivial
lemma new_lemma_160756 (h0 : uniform_space (has_zero (option pos))) : separated_space (has_zero (option pos)) := sorry --non-trivial
lemma new_lemma_160757 (h1 : add_group (normed_field (mul_one_class linarith.comp_source))) : is_add_cyclic (normed_field (mul_one_class linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_160758 (h0 : complete_lattice (has_div to_additive.value_type)) : complete_lattice.is_Sup_finite_compact (has_div to_additive.value_type) := sorry --non-trivial
lemma new_lemma_160759 (h0 : has_mem.mem (has_top linarith.comp) has_emptyc.emptyc) : @add_monoid.fg.{0} (has_top.{0} linarith.comp) (@finset.pi.empty.{1 0} Type add_monoid.{0} (has_top.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_160760 (h0 : functor.add_const (topological_space (finset environment.implicit_infer_kind)) Type) : @regular_space.{0} (finset.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (finset.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_160761 (h0 : functor.add_const (function.extfun Type ring) pos) : @is_domain.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) pos h0) (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_160762 (h0 : topological_space (has_Inf (has_add (has_add linarith.comp)))) : preconnected_space (has_Inf (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_160763 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_160764 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @complete_space.{1} (plift.{1} congr_arg_kind) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 uniform_space.{1}) (plift.{1} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_160765 (h0 : functor.comp topological_space semigroup name) : @regular_space.{0} (semigroup.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} name (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} name (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} name (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} name (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} name (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} name h0))))))  := sorry --non-trivial
lemma new_lemma_160766 (h1 : uniform_space (metric_space (has_one (has_norm linarith.comp)))) : separated_space (metric_space (has_one (has_norm linarith.comp))) := sorry --non-trivial
lemma new_lemma_160767 (h0 : topological_space (mul_zero_class (has_nndist environment.implicit_infer_kind))) : t1_space (mul_zero_class (has_nndist environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_160768 (h0 : functor.add_const (add_group (complete_distrib_lattice pos)) Type) : @is_add_cyclic.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 1} (add_group.{0} (complete_distrib_lattice.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_160769 (h0 : add_group (has_emptyc (has_norm linarith.comp))) : is_add_cyclic (has_emptyc (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_160770 (h0 : functor.add_const (monoid (has_add Type)) Type) : @monoid.fg.{1} (has_add.{1} Type) (@functor.add_const.run.{1 1} (monoid.{1} (has_add.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_160771 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} environment.implicit_infer_kind (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 environment.implicit_infer_kind)  := sorry --non-trivial
lemma new_lemma_160772 (h0 : topological_space (non_assoc_semiring (semiring (semiring unsigned)))) : preirreducible_space (non_assoc_semiring (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_160773 (h1 : set enat) : set.finite h1 := sorry --non-trivial
lemma new_lemma_160774 (h0 : list (omega_complete_partial_order (option (option empty)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_160775 (h0 : ordered_comm_monoid (distrib enat)) : has_exists_mul_of_le (distrib enat) := sorry --non-trivial
lemma new_lemma_160776 (h0 : topological_space (pseudo_metric_space (option (option unsigned)))) : loc_path_connected_space (pseudo_metric_space (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_160777 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} h0 (comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_160778 (h0 : has_mem.mem (random_gen string_imp) has_emptyc.emptyc) : @is_atomistic.{0} (random_gen.{0} string_imp) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (random_gen.{0} string_imp) h0)  := sorry --non-trivial
lemma new_lemma_160779 (h0 : functor.comp topological_space comm_group name) : @preconnected_space.{0} (comm_group.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} comm_group.{0} name h0)  := sorry --non-trivial
lemma new_lemma_160780 (h0 : functor.add_const (cancel_comm_monoid_with_zero (normed_linear_ordered_group congr_arg_kind)) num) : @unique_factorization_monoid.{0} (normed_linear_ordered_group.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (normed_linear_ordered_group.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_160781 (h0 : not (add_group (add_cancel_comm_monoid string_imp) -> false)) : @is_add_cyclic.{0} (add_cancel_comm_monoid.{0} string_imp) (@classical.by_contradiction'.{1} (add_group.{0} (add_cancel_comm_monoid.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_160782 (h3 : ring (add_left_cancel_monoid to_additive.value_type)) : is_domain (add_left_cancel_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_160783 (h0 : ring (normed_field (normed_field (has_nnnorm ereal)))) : rank_condition (normed_field (normed_field (has_nnnorm ereal))) := sorry --non-trivial
lemma new_lemma_160784 (h0 : topological_space (has_Inf pos)) : totally_separated_space (has_Inf pos) := sorry --non-trivial
lemma new_lemma_160785 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_add.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} name))  := sorry --non-trivial
lemma new_lemma_160786 (h0 : topological_space (with_one (random_gen (random_gen (random_gen (random_gen linarith.ineq)))))) : t0_space (with_one (random_gen (random_gen (random_gen (random_gen linarith.ineq))))) := sorry --non-trivial
lemma new_lemma_160787 (h0 : complete_lattice (comm_ring (random_gen (metric_space (random_gen char))))) : is_compactly_generated (comm_ring (random_gen (metric_space (random_gen char)))) := sorry --non-trivial
lemma new_lemma_160788 (h0 : topological_space (canonically_linear_ordered_monoid (has_Inf pos))) : regular_space (canonically_linear_ordered_monoid (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_160789 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (has_inv.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_inv.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_160790 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (linear_ordered_field.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (linear_ordered_field.{0} num))  := sorry --non-trivial
lemma new_lemma_160791 (h0 : function.extfun Type (functor.add_const (group (semigroup unsigned)))) : @group.fg.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (semigroup.{0} unsigned)) (option.{0} unsigned) (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (group.{0} (semigroup.{0} unsigned))) h0 (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_160792 (h0 : topological_space (simple_graph unsigned)) : totally_separated_space (simple_graph unsigned) := sorry --non-trivial
lemma new_lemma_160793 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (left_cancel_semigroup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (left_cancel_semigroup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_160794 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} (measurable_space.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (measurable_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_160795 (h0 : topological_space (semigroup (has_pos_part Type))) : normal_space (semigroup (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_160796 (h0 : filter (canonically_linear_ordered_monoid ennreal)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_160797 (h0 : group (has_neg_part name)) : is_simple_group (has_neg_part name) := sorry --non-trivial
lemma new_lemma_160798 (h0 : functor.add_const (topological_space (semigroup unsigned)) num) : @t0_space.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_160799 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @regular_space.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_160800 (h0 : functor.add_const (complete_lattice (normed_linear_ordered_group unsigned)) unsigned) : @complete_lattice.is_Sup_finite_compact.{0} (normed_linear_ordered_group.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (normed_linear_ordered_group.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_160801 (h0 : complete_lattice (normed_comm_ring (has_neg linarith.comp))) : is_compactly_generated (normed_comm_ring (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_160802 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : unique_factorization_monoid real := sorry --non-trivial
lemma new_lemma_160803 (h0 : filter (normed_comm_ring (semigroup pos))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_160804 (h0 : topological_space (ring (option empty)) -> Prop) (h1 : Exists (fun (x : topological_space (ring (option empty))), h0 x)) : @normal_space.{0} (ring.{0} (option.{0} empty)) (@classical.some.{1} (topological_space.{0} (ring.{0} (option.{0} empty))) h0 h1)  := sorry --non-trivial
lemma new_lemma_160805 (h0 : topological_space (normed_group (random_gen (random_gen fun_info)))) : totally_separated_space (normed_group (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_160806 (h0 : functor.add_const (fin has_zero.zero) (has_neg real)) : @add_monoid.fg.{0} (comm_semigroup.{0} name) (@matrix.vec_empty.{0} (add_monoid.{0} (comm_semigroup.{0} name)) (@functor.add_const.run.{0 0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (has_neg.{0} real) h0))  := sorry --non-trivial
lemma new_lemma_160807 (h0 : functor.add_const (ring (finset linarith.comp)) (has_neg (has_add Type))) : @is_principal_ideal_ring.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 1} (ring.{0} (finset.{0} linarith.comp)) (has_neg.{1} (has_add.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_160808 (h0 : functor.add_const (cancel_comm_monoid_with_zero (linear_order unsigned)) unsigned) : @unique_factorization_monoid.{0} (linear_order.{0} unsigned) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (linear_order.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_160809 (h0 : ring (has_pos_part (finset Type))) : is_principal_ideal_ring (has_pos_part (finset Type)) := sorry --non-trivial
lemma new_lemma_160810 (h0 : topological_space (has_union (semiring (semiring (semiring (semiring congr_arg_kind)))))) : discrete_topology (has_union (semiring (semiring (semiring (semiring congr_arg_kind))))) := sorry --non-trivial
lemma new_lemma_160811 (h0 : ring (group_with_zero pos)) : is_principal_ideal_ring (group_with_zero pos) := sorry --non-trivial
lemma new_lemma_160812 (h0 : complete_semilattice_Sup congr_arg_kind -> complete_semilattice_Sup congr_arg_kind -> Prop) : is_symm (complete_semilattice_Sup congr_arg_kind) h0 := sorry --non-trivial
lemma new_lemma_160813 (h0 : monoid (complete_distrib_lattice congr_arg_kind)) : monoid.fg (complete_distrib_lattice congr_arg_kind) := sorry --non-trivial
lemma new_lemma_160814 (h0 : topological_space (ordered_cancel_comm_monoid unsigned)) (h1 : set (ordered_cancel_comm_monoid unsigned)) : is_preirreducible h1 := sorry --non-trivial
lemma new_lemma_160815 (h0 : group (canonically_ordered_comm_semiring (option (option empty)))) : normalizer_condition (canonically_ordered_comm_semiring (option (option empty))) := sorry --non-trivial
lemma new_lemma_160816 (h0 : topological_space (add_cancel_monoid (has_neg Type))) : sequential_space (add_cancel_monoid (has_neg Type)) := sorry --non-trivial
lemma new_lemma_160817 (h0 : filter (boolean_algebra.core (cancel_monoid name))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_160818 (h0 : filter (canonically_ordered_comm_semiring ennreal)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_160819 (h0 : topological_space (ring (has_add Type))) : discrete_topology (ring (has_add Type)) := sorry --non-trivial
lemma new_lemma_160820 (h0 : complete_lattice (add_left_cancel_semigroup (option (option unsigned)))) : complete_lattice.is_Sup_finite_compact (add_left_cancel_semigroup (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_160821 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_nndist.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} empty))  := sorry --non-trivial
lemma new_lemma_160822 (h0 : monoid (has_norm (semiring (semiring congr_arg_kind)))) : monoid.fg (has_norm (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_160823 (h0 : topological_space (measurable_space.dynkin_system (ordered_ring (option unsigned)))) : totally_disconnected_space (measurable_space.dynkin_system (ordered_ring (option unsigned))) := sorry --non-trivial
lemma new_lemma_160824 (h1 : filter (with_one num)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_160825 (h0 : topological_space (ordered_comm_monoid (sub_neg_monoid real))) : discrete_topology (ordered_comm_monoid (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_160826 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_emptyc.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_emptyc.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_160827 (h0 : topological_space (normed_lattice_add_comm_group (has_Inf real))) : preconnected_space (normed_lattice_add_comm_group (has_Inf real)) := sorry --non-trivial
lemma new_lemma_160828 (h0 : group (normed_linear_ordered_group (option unsigned))) : is_cyclic (normed_linear_ordered_group (option unsigned)) := sorry --non-trivial
lemma new_lemma_160829 (h0 : group (with_bot (distrib (random_gen (random_gen linarith.ineq))))) : normalizer_condition (with_bot (distrib (random_gen (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_160830 (h0 : topological_space (add_group (has_norm (has_norm (has_top congr_arg_kind))))) : irreducible_space (add_group (has_norm (has_norm (has_top congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_160831 (h0 : topological_space (uniform_space (mul_one_class (random_gen to_additive.value_type)))) : totally_disconnected_space (uniform_space (mul_one_class (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_160832 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (has_nnnorm.{0} char) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_nnnorm.{0} char))  := sorry --non-trivial
lemma new_lemma_160833 (h0 : function.extfun Type (functor.comp topological_space comm_group)) : @path_connected_space.{0} (comm_group.{0} unsigned) (@functor.comp.run.{0 0 0} topological_space.{0} comm_group.{0} unsigned (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} comm_group.{0}) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_160834 (h0 h1 : multiset (nondiscrete_normed_field linarith.ineq)) : multiset.le h0 h1 := sorry --non-trivial
lemma new_lemma_160835 (h0 : topological_space (ring (add_comm_monoid pos))) : preconnected_space (ring (add_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_160836 (h0 : monoid (measurable_space (has_inv linarith.ineq))) : monoid.fg (measurable_space (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_160837 (h1 : not (topological_space (add_cancel_comm_monoid linarith.comp_source) -> false)) : @t0_space.{0} (add_cancel_comm_monoid.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (add_cancel_comm_monoid.{0} linarith.comp_source)) h1)  := sorry --non-trivial
lemma new_lemma_160838 (h0 : functor.comp semiring comm_group pos) : @is_noetherian_ring.{0} (comm_group.{0} pos) (@functor.comp.run.{0 0 0} semiring.{0} comm_group.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_160839 (h0 : functor.add_const (function.extfun Type uniform_space) (ring linarith.comp)) : @separated_space.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) (ring.{0} linarith.comp) h0) (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_160840 (h0 : not (topological_space (linear_ordered_comm_group to_additive.value_type) -> false)) : @t0_space.{0} (linear_ordered_comm_group.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_comm_group.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_160841 (h0 : not (topological_space (has_nnnorm (has_nnnorm reducibility_hints)) -> false)) : @path_connected_space.{0} (has_nnnorm.{0} (has_nnnorm.{0} reducibility_hints)) (@classical.by_contradiction'.{1} (topological_space.{0} (has_nnnorm.{0} (has_nnnorm.{0} reducibility_hints))) h0)  := sorry --non-trivial
lemma new_lemma_160842 (h0 : uniform_space (has_inter congr_arg_kind)) : separated_space (has_inter congr_arg_kind) := sorry --non-trivial
lemma new_lemma_160843 (h0 : topological_space (has_bot (sub_neg_monoid pos))) : preirreducible_space (has_bot (sub_neg_monoid pos)) := sorry --non-trivial
lemma new_lemma_160844 (h0 : topological_space (comm_group ennreal)) : path_connected_space (comm_group ennreal) := sorry --non-trivial
lemma new_lemma_160845 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_160846 (h0 : functor.add_const (function.extfun Type list) pos) : list.nodup (function.extfun_app (functor.add_const.run h0) (ring unsigned)) := sorry --non-trivial
lemma new_lemma_160847 (h0 : topological_space (has_pos_part Type)) : normal_space (has_pos_part Type) := sorry --non-trivial
lemma new_lemma_160848 (h0 : uniform_space (ring (ordered_ring Type))) : separated_space (ring (ordered_ring Type)) := sorry --non-trivial
lemma new_lemma_160849 (h0 : ring enat) : is_domain enat := sorry --non-trivial
lemma new_lemma_160850 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (canonically_linear_ordered_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_linear_ordered_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_160851 (h0 : function.extfun Type ring) : @is_domain.{0} (has_Inf.{0} real) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_Inf.{0} real))  := sorry --non-trivial
lemma new_lemma_160852 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_160853 (h0 : ring (id (has_top num))) : is_domain (id (has_top num)) := sorry --non-trivial
lemma new_lemma_160854 (h0 : function.extfun Type (functor.add_const (topological_space (ordered_cancel_add_comm_monoid empty)))) : @normal_space.{0} (ordered_cancel_add_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_cancel_add_comm_monoid.{0} empty)) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (ordered_cancel_add_comm_monoid.{0} empty))) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_160855 (h0 : topological_space (has_top (id unsigned))) : totally_separated_space (has_top (id unsigned)) := sorry --non-trivial
lemma new_lemma_160856 (h2 : has_mem.mem num has_emptyc.emptyc) : @irreducible_space.{0} num (@finset.pi.empty.{1 0} Type topological_space.{0} num h2)  := sorry --non-trivial
lemma new_lemma_160857 (h0 : topological_space (has_neg linarith.comp)) : irreducible_space (has_neg linarith.comp) := sorry --non-trivial
lemma new_lemma_160858 (h0 : complete_lattice (has_top to_additive.value_type)) : is_atomistic (has_top to_additive.value_type) := sorry --non-trivial
lemma new_lemma_160859 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (normed_lattice_add_comm_group.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (normed_lattice_add_comm_group.{0} name))  := sorry --non-trivial
lemma new_lemma_160860 (h0 : ring (add_monoid string_imp)) : rank_condition (add_monoid string_imp) := sorry --non-trivial
lemma new_lemma_160861 (h0 : add_monoid (has_star (option num))) : add_monoid.fg (has_star (option num)) := sorry --non-trivial
lemma new_lemma_160862 (h0 : add_group (normed_group (has_top to_additive.value_type))) : is_add_cyclic (normed_group (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_160863 (h0 : ring (measurable_space (has_norm (has_norm (has_top linarith.comp_source))))) : strong_rank_condition (measurable_space (has_norm (has_norm (has_top linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_160864 (h1 : ring (linear_ordered_comm_group_with_zero linarith.comp_source)) : rank_condition (linear_ordered_comm_group_with_zero linarith.comp_source) := sorry --non-trivial
lemma new_lemma_160865 (h0 : functor.add_const (topological_space (has_add linarith.comp)) environment.implicit_infer_kind) : @sequential_space.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_160866 (h0 : functor.add_const (topological_space (has_nndist environment.implicit_infer_kind)) Type) : @irreducible_space.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (has_nndist.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_160867 (h0 : sub_neg_monoid pos -> Prop) : zzz_forall h0 := sorry --non-trivial
lemma new_lemma_160868 (h0 : functor.add_const (function.extfun Type ring) congr_arg_kind) : @rank_condition.{0} nnreal (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) congr_arg_kind h0) nnreal)  := sorry --non-trivial
lemma new_lemma_160869 (h0 : functor.add_const (topological_space (plift congr_arg_kind)) num) : @locally_compact_space.{1} (plift.{1} congr_arg_kind) (@functor.add_const.run.{1 0} (topological_space.{1} (plift.{1} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_160870 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (has_ssubset.{0} (comm_ring.{0} linarith.ineq)) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_ssubset.{0} (comm_ring.{0} linarith.ineq)))  := sorry --non-trivial
lemma new_lemma_160871 (h0 : group (mul_zero_class unsigned)) : is_cyclic (mul_zero_class unsigned) := sorry --non-trivial
lemma new_lemma_160872 (h0 : uniform_space (normed_group (random_gen fun_info))) : complete_space (normed_group (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_160873 (h0 : functor.add_const (function.extfun (Type 1) ring) linarith.comp) : @rank_condition.{1} (simple_graph.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ring.{1}) linarith.comp h0) (simple_graph.{1} Type))  := sorry --non-trivial
lemma new_lemma_160874 (h0 : function.extfun (finset Type) (has_mem.mem (complete_semilattice_Sup empty))) : @is_compactly_generated.{0} (complete_semilattice_Sup.{0} empty) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (complete_semilattice_Sup.{0} empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (complete_semilattice_Sup.{0} empty)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_160875 (h0 : topological_space (ordered_cancel_add_comm_monoid num)) : preirreducible_space (ordered_cancel_add_comm_monoid num) := sorry --non-trivial
lemma new_lemma_160876 (h0 : cancel_comm_monoid_with_zero (cancel_monoid (boolean_algebra name))) : unique_factorization_monoid (cancel_monoid (boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_160877 (h0 : topological_space (ordered_comm_monoid (ring (boolean_algebra.core (has_add (has_add pos)))))) : totally_separated_space (ordered_comm_monoid (ring (boolean_algebra.core (has_add (has_add pos))))) := sorry --non-trivial
lemma new_lemma_160878 (h0 : ring (generalized_boolean_algebra (canonically_linear_ordered_monoid Type))) : is_domain (generalized_boolean_algebra (canonically_linear_ordered_monoid Type)) := sorry --non-trivial
lemma new_lemma_160879 (h0 : not (topological_space (has_top char) -> false)) : @path_connected_space.{0} (has_top.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (has_top.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_160880 (h0 : group (has_nndist real)) : is_simple_group (has_nndist real) := sorry --non-trivial
lemma new_lemma_160881 (h0 : topological_space (linear_ordered_field (option ennreal))) : regular_space (linear_ordered_field (option ennreal)) := sorry --non-trivial
lemma new_lemma_160882 (h0 : ring (complete_distrib_lattice Type)) : is_domain (complete_distrib_lattice Type) := sorry --non-trivial
lemma new_lemma_160883 (h0 : complete_lattice (fintype (linear_ordered_add_comm_group string_imp))) : is_compactly_generated (fintype (linear_ordered_add_comm_group string_imp)) := sorry --non-trivial
lemma new_lemma_160884 (h0 : monoid (has_emptyc (random_gen congr_arg_kind))) : monoid.fg (has_emptyc (random_gen congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_160885 (h0 : functor.add_const (list (simple_graph Type)) name) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_160886 (h0 : not (list (has_inv linarith.ineq) -> false)) : list.nodup (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_160887 (h0 : functor.add_const (function.extfun (Type 1) ring) Type) : @is_domain.{1} (add_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) ring.{1}) Type h0) (add_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_160888 (h0 : ring (topological_space (has_nnnorm fun_info))) : strong_rank_condition (topological_space (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_160889 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (sub_neg_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (sub_neg_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_160890 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (has_zero (canonically_ordered_comm_semiring name))) := sorry --non-trivial
lemma new_lemma_160891 (h0 : functor.add_const (topological_space (semigroup Type)) pos) : @t1_space.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (semigroup.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_160892 (h0 : uniform_space (comm_group (has_neg pos))) : complete_space (comm_group (has_neg pos)) := sorry --non-trivial
lemma new_lemma_160893 (h0 : functor.add_const (uniform_space (ordered_semiring congr_arg_kind)) unsigned) : @complete_space.{0} (ordered_semiring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (uniform_space.{0} (ordered_semiring.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_160894 (h0 : topological_space (has_norm (has_inv (has_top to_additive.value_type)))) : discrete_topology (has_norm (has_inv (has_top to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_160895 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_160896 (h0 : not (function.extfun Type topological_space -> false)) : @irreducible_space.{0} real.angle (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) real.angle)  := sorry --non-trivial
lemma new_lemma_160897 (h0 : ring (boolean_algebra (has_neg (ring linarith.comp)))) : rank_condition (boolean_algebra (has_neg (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_160898 (h0 : functor.comp group boolean_algebra name) : @is_simple_group.{0} (boolean_algebra.{0} name) (@functor.comp.run.{0 0 0} group.{0} boolean_algebra.{0} name h0)  := sorry --non-trivial
lemma new_lemma_160899 (h0 : topological_space (has_emptyc (random_gen (semiring (random_gen congr_arg_kind))))) : t0_space (has_emptyc (random_gen (semiring (random_gen congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_160900 (h0 : group (has_to_string (add_comm_monoid congr_arg_kind))) : is_simple_group (has_to_string (add_comm_monoid congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_160901 (h0 : semiring (finset congr_arg_kind)) : is_noetherian_ring (finset congr_arg_kind) := sorry --non-trivial
lemma new_lemma_160902 (h0 : functor.add_const (add_group (has_nndist unsigned)) pos) : @is_add_cyclic.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 0} (add_group.{0} (has_nndist.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_160903 (h0 : not (function.extfun Type complete_lattice -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_emptyc.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (has_emptyc.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_160904 (h0 : function.extfun nat fin) : @t0_space.{0} (comm_semigroup.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (comm_semigroup.{0} linarith.comp)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))))  := sorry --non-trivial
lemma new_lemma_160905 (h0 : ring (boolean_algebra (finset Type))) : is_domain (boolean_algebra (finset Type)) := sorry --non-trivial
lemma new_lemma_160906 (h0 : topological_space (boolean_algebra (finset linarith.comp))) : topological_space.separable_space (boolean_algebra (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_160907 (h0 : filter (finset name)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_160908 (h0 : add_group (semi_normed_ring (has_nnnorm (has_nnnorm char)))) : is_add_cyclic (semi_normed_ring (has_nnnorm (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_160909 (h0 : topological_space (comm_ring (comm_ring (random_gen linarith.ineq)))) : t0_space (comm_ring (comm_ring (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_160910 (h0 : function.extfun Type (functor.add_const (filter pos))) : filter.ne_bot (functor.add_const.run (function.extfun_app h0 (has_to_string pos))) := sorry --non-trivial
lemma new_lemma_160911 (h0 : functor.add_const (cancel_comm_monoid_with_zero (is_R_or_C empty)) empty) : @unique_factorization_monoid.{0} (is_R_or_C.{0} empty) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (is_R_or_C.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_160912 (h0 : uniform_space (boolean_algebra (semigroup Type))) : separated_space (boolean_algebra (semigroup Type)) := sorry --non-trivial
lemma new_lemma_160913 (h0 : ring (add_comm_monoid (has_add environment.implicit_infer_kind))) : is_principal_ideal_ring (add_comm_monoid (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_160914 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_160915 (h0 : topological_space (has_add (has_Inf Type))) : locally_compact_space (has_add (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_160916 (h0 : topological_space (has_neg unsigned)) : irreducible_space (has_neg unsigned) := sorry --non-trivial
lemma new_lemma_160917 (h0 : not (add_group (dlist linarith.comp_source) -> false)) : @is_add_cyclic.{0} (dlist.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (add_group.{0} (dlist.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_160918 (h0 : not (ring (random_gen congr_arg_kind) -> false)) : @rank_condition.{0} (random_gen.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (ring.{0} (random_gen.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_160919 (h0 : fin has_zero.zero) : @locally_compact_space.{1} (has_bot.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (has_bot.{1} Type)) (@function.extfun_app.{1 1} nat fin (@matrix.vec_empty.{0} (function.extfun.{1 1} nat fin) h0) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_160920 (h0 : functor.add_const (group (add_cancel_monoid Type)) pos) : @is_cyclic.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (add_cancel_monoid.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_160921 (h0 : function.extfun Type ring) : @is_domain.{0} (has_inter.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_inter.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_160922 (h0 : not (topological_space (has_top linarith.comp_source) -> false)) : @locally_compact_space.{0} (has_top.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (has_top.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_160923 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (add_comm_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_comm_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_160924 (h0 : functor.add_const (topological_space (has_zero unsigned)) pos) : @irreducible_space.{0} (has_zero.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_160925 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (dlist linarith.ineq)) := sorry --non-trivial
lemma new_lemma_160926 (h0 : string_imp -> string_imp -> Prop) (h1 : set string_imp) : set.unbounded h0 h1 := sorry --non-trivial
lemma new_lemma_160927 (h0 : function.extfun (Type 1) topological_space) : @t0_space.{1} (boolean_algebra.core.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (boolean_algebra.core.{1} Type))  := sorry --non-trivial
lemma new_lemma_160928 (h0 : function.extfun (finset Type) (has_mem.mem linarith.ineq)) : @rank_condition.{0} linarith.ineq (@finset.pi.empty.{1 0} Type ring.{0} linarith.ineq (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) linarith.ineq) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_160929 (h0 : group (metric_space (has_norm linarith.comp))) : normalizer_condition (metric_space (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_160930 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_160931 (h0 : functor.add_const (topological_space (linear_ordered_comm_monoid_with_zero unsigned)) empty) : @totally_separated_space.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_160932 (h0 : functor.add_const (topological_space (complete_distrib_lattice linarith.comp)) Type) : @t0_space.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (complete_distrib_lattice.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_160933 (h0 : monoid (mul_zero_class (finset (boolean_algebra.core name)))) : monoid.fg (mul_zero_class (finset (boolean_algebra.core name))) := sorry --non-trivial
lemma new_lemma_160934 (h0 : function.extfun (Type 1) group) : @is_cyclic.{1} (normed_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} h0 (normed_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_160935 (h0 : functor.add_const (add_group (has_zero Type)) environment.implicit_infer_kind) : @is_add_cyclic.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (add_group.{1} (has_zero.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_160936 (h0 : uniform_space (semigroup (has_neg_part unsigned))) : separated_space (semigroup (has_neg_part unsigned)) := sorry --non-trivial
lemma new_lemma_160937 (h1 : has_mem.mem (ordered_comm_semiring num) has_emptyc.emptyc) : @totally_disconnected_space.{0} (ordered_comm_semiring.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (ordered_comm_semiring.{0} num) h1)  := sorry --non-trivial
lemma new_lemma_160938 (h0 : topological_space (has_add (has_Inf Type))) : regular_space (has_add (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_160939 (h0 : not (function.extfun Type topological_space -> false)) : @discrete_topology.{0} (has_norm.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_norm.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_160940 (h0 : fin has_zero.zero) : @has_exists_mul_of_le.{0} (add_comm_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (ordered_comm_monoid.{0} (add_comm_monoid.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_160941 (h0 : monoid (filter (semiring empty))) : monoid.fg (filter (semiring empty)) := sorry --non-trivial
lemma new_lemma_160942 (h0 : group (has_neg name)) : group.fg (has_neg name) := sorry --non-trivial
lemma new_lemma_160943 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (semi_normed_comm_ring.{0} char) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semi_normed_comm_ring.{0} char))  := sorry --non-trivial
lemma new_lemma_160944 (h0 : fin has_zero.zero) : @archimedean.{0} (add_comm_monoid.{0} real) (@matrix.vec_empty.{0} (ordered_add_comm_monoid.{0} (add_comm_monoid.{0} real)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)))  := sorry --non-trivial
lemma new_lemma_160945 (h0 : not (uniform_space (uniform_space linarith.comp_source) -> false)) : @complete_space.{0} (uniform_space.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (uniform_space.{0} (uniform_space.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_160946 (h0 : function.extfun Type topological_space) : @normal_space.{0} (left_cancel_semigroup.{0} (semiring.{0} (semiring.{0} (semiring.{0} congr_arg_kind)))) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (left_cancel_semigroup.{0} (semiring.{0} (semiring.{0} (semiring.{0} congr_arg_kind)))))  := sorry --non-trivial
lemma new_lemma_160947 (h0 : fin has_zero.zero) : @complete_lattice.is_Sup_finite_compact.{0} (canonically_linear_ordered_monoid.{0} name) (@matrix.vec_empty.{0} (complete_lattice.{0} (canonically_linear_ordered_monoid.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_160948 (h0 : ring (boolean_algebra (has_add pos))) : is_domain (boolean_algebra (has_add pos)) := sorry --non-trivial
lemma new_lemma_160949 (h0 : function.extfun (finset Type) (has_mem.mem real.angle)) : @t0_space.{0} real.angle (@finset.pi.empty.{1 0} Type topological_space.{0} real.angle (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) real.angle) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_160950 (h1 : uniform_space linarith.ineq) : separated_space linarith.ineq := sorry --non-trivial
lemma new_lemma_160951 (h0 : topological_space fun_info) : irreducible_space fun_info := sorry --non-trivial
lemma new_lemma_160952 (h0 : functor.add_const (add_monoid (semigroup name)) (boolean_algebra linarith.comp)) : @add_monoid.fg.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (add_monoid.{0} (semigroup.{0} name)) (boolean_algebra.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_160953 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @regular_space.{0} (boolean_algebra.core.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.core.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_160954 (h1 : group (has_norm (has_top to_additive.value_type))) : normalizer_condition (has_norm (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_160955 (h0 : functor.add_const (topological_space (has_pos_part linarith.comp)) pos) : @totally_disconnected_space.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_160956 (h0 : functor.add_const (topological_space (has_add name)) (normed_comm_ring name)) : @topological_space.separable_space.{0} (has_add.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} name)) (normed_comm_ring.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_160957 (h0 : group (with_bot string_imp)) : normalizer_condition (with_bot string_imp) := sorry --non-trivial
lemma new_lemma_160958 (h0 : topological_space (has_add (has_neg_part (mul_zero_class pos)))) : totally_separated_space (has_add (has_neg_part (mul_zero_class pos))) := sorry --non-trivial
lemma new_lemma_160959 (h0 : group (fintype (random_gen to_additive.value_type))) : group.fg (fintype (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_160960 (h0 : fin has_zero.zero) : @path_connected_space.{0} (ordered_comm_ring.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_ring.{0} real)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_160961 (h0 : function.extfun Type (functor.add_const (group auto.case_option))) : @is_cyclic.{0} auto.case_option (@functor.add_const.run.{0 0} (group.{0} auto.case_option) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (group.{0} auto.case_option)) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_160962 (h0 : list (with_one (random_gen (random_gen (random_gen fun_info))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_160963 (h0 : topological_space (has_norm (random_gen string_imp))) : irreducible_space (has_norm (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_160964 (h0 : topological_space (comm_group (boolean_algebra.core name))) : irreducible_space (comm_group (boolean_algebra.core name)) := sorry --non-trivial
lemma new_lemma_160965 (h2 : set (fun_info -> fun_info)) : set.separates_points h2 := sorry --non-trivial
lemma new_lemma_160966 (h0 : monoid (boolean_algebra (has_bot name))) : monoid.fg (boolean_algebra (has_bot name)) := sorry --non-trivial
lemma new_lemma_160967 (h0 : filter (finset (add_comm_monoid (finset (finset name))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_160968 (h0 : uniform_space (has_zero (mul_one_class linarith.comp))) : separated_space (has_zero (mul_one_class linarith.comp)) := sorry --non-trivial
lemma new_lemma_160969 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (complete_semilattice_Sup.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_160970 (h0 : group (add_comm_monoid (has_bot real))) : group.fg (add_comm_monoid (has_bot real)) := sorry --non-trivial
lemma new_lemma_160971 (h0 : not (group (metric_space reducibility_hints) -> false)) : @is_cyclic.{0} (metric_space.{0} reducibility_hints) (@classical.by_contradiction'.{1} (group.{0} (metric_space.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_160972 (h0 : group (add_cancel_monoid Type)) : normalizer_condition (add_cancel_monoid Type) := sorry --non-trivial
lemma new_lemma_160973 (h0 h1 : multiset (has_lt linarith.ineq)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_160974 (h0 : topological_space (comm_group (has_add (comm_group (comm_group Type))))) : preconnected_space (comm_group (has_add (comm_group (comm_group Type)))) := sorry --non-trivial
lemma new_lemma_160975 (h0 : filter (canonically_ordered_add_monoid empty)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_160976 (h2 : uniform_space (mul_one_class string.iterator_imp)) : complete_space (mul_one_class string.iterator_imp) := sorry --non-trivial
lemma new_lemma_160977 (h0 : functor.add_const (topological_space (has_to_string Type)) Type) : @irreducible_space.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_to_string.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_160978 (h0 : std_gen -> std_gen) (h1 : functor.const (complete_lattice (nondiscrete_normed_field string.iterator_imp)) std_gen) : @complete_lattice.is_Sup_finite_compact.{0} (nondiscrete_normed_field.{0} string.iterator_imp) (@functor.const.map.{0 0 0} (complete_lattice.{0} (nondiscrete_normed_field.{0} string.iterator_imp)) std_gen std_gen h0 h1)  := sorry --non-trivial
lemma new_lemma_160979 (h0 : topological_space (boolean_algebra (finset environment.implicit_infer_kind))) : loc_path_connected_space (boolean_algebra (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_160980 (h0 : not (topological_space (add_group congr_arg_kind) -> false)) : @preirreducible_space.{0} (add_group.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (add_group.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_160981 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_union.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (has_union.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_160982 (h0 : filter (complete_distrib_lattice ennreal)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_160983 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @totally_disconnected_space.{1} (complete_distrib_lattice.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (complete_distrib_lattice.{1} Type))  := sorry --non-trivial
lemma new_lemma_160984 (h0 : group (linear_ordered_comm_ring unsigned)) : normalizer_condition (linear_ordered_comm_ring unsigned) := sorry --non-trivial
lemma new_lemma_160985 (h0 : topological_space (generalized_boolean_algebra (sub_neg_monoid pos))) : path_connected_space (generalized_boolean_algebra (sub_neg_monoid pos)) := sorry --non-trivial
lemma new_lemma_160986 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @sequential_space.{0} (has_add.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_add.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_160987 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (has_nndist.{0} ennreal) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (has_nndist.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_160988 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (has_inner.{0 0} linarith.comp environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_inner.{0 0} linarith.comp environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_160989 (h0 : functor.add_const (list (normed_comm_ring linarith.comp)) (has_to_string pos)) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_160990 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem ring)) : @is_domain.{0} unsigned (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) ring.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) unsigned)  := sorry --non-trivial
lemma new_lemma_160991 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_nndist.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_160992 (h0 : functor.add_const (group (semigroup name)) Type) : @is_simple_group.{0} (semigroup.{0} name) (@functor.add_const.run.{0 1} (group.{0} (semigroup.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_160993 (h0 : list (has_inv (random_gen (has_nnnorm to_additive.value_type)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_160994 (h0 : finset (simple_graph Type)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_160995 (h0 : topological_space (complete_distrib_lattice (has_pos_part Type))) : loc_path_connected_space (complete_distrib_lattice (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_160996 (h0 : group (add_cancel_monoid (has_add pos))) : normalizer_condition (add_cancel_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_160997 (h0 : group (has_norm (random_gen (random_gen char)))) : is_cyclic (has_norm (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_160998 (h6 : set ereal) : set.finite h6 := sorry --non-trivial
lemma new_lemma_160999 (h0 : group (cancel_monoid Type)) : normalizer_condition (cancel_monoid Type) := sorry --non-trivial
lemma new_lemma_161000 (h0 : functor.add_const (ring (has_zero Type)) (ring Type)) : @is_principal_ideal_ring.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 1} (ring.{1} (has_zero.{1} Type)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_161001 (h0 : not (ring (uniform_space string_imp) -> false)) : @rank_condition.{0} (uniform_space.{0} string_imp) (@classical.by_contradiction'.{1} (ring.{0} (uniform_space.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_161002 (h0 : topological_space (linear_ordered_field pos)) : totally_separated_space (linear_ordered_field pos) := sorry --non-trivial
lemma new_lemma_161003 (h1 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (with_one.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} h1 (with_one.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_161004 (h0 : topological_space (sub_neg_monoid (has_add (finset pos)))) : irreducible_space (sub_neg_monoid (has_add (finset pos))) := sorry --non-trivial
lemma new_lemma_161005 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (linear_ordered_cancel_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (linear_ordered_cancel_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_161006 (h0 : function.extfun (Type -> Type) (function.extfun Type) -> Prop) (h1 : Exists (fun (x : function.extfun (Type -> Type) (function.extfun Type)), h0 x)) : @preirreducible_space.{0} pnat (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.some.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0 h1) topological_space.{0}) pnat)  := sorry --non-trivial
lemma new_lemma_161007 (h0 : complete_lattice (boolean_algebra.core Type)) : is_atomistic (boolean_algebra.core Type) := sorry --non-trivial
lemma new_lemma_161008 (h0 : uniform_space reducibility_hints) : complete_space reducibility_hints := sorry --non-trivial
lemma new_lemma_161009 (h0 : functor.add_const (topological_space (bin_tree num)) congr_arg_kind) : @totally_disconnected_space.{0} (bin_tree.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (bin_tree.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_161010 (h0 : filter (add_cancel_monoid (normed_comm_ring unsigned))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_161011 (h0 : add_group (linear_ordered_cancel_comm_monoid empty)) : is_add_cyclic (linear_ordered_cancel_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_161012 (h0 : topological_space (has_zero (has_add (has_add Type)))) : locally_compact_space (has_zero (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_161013 (h0 : functor.add_const (ring (has_neg_part name)) (boolean_algebra Type)) : @is_domain.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 1} (ring.{0} (has_neg_part.{0} name)) (boolean_algebra.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_161014 (h0 : ring (has_add (has_Inf real))) : rank_condition (has_add (has_Inf real)) := sorry --non-trivial
lemma new_lemma_161015 (h0 : ring (finset (normed_comm_ring (has_Inf (has_Inf (has_pos_part (ring (has_Inf pos)))))))) : is_domain (finset (normed_comm_ring (has_Inf (has_Inf (has_pos_part (ring (has_Inf pos))))))) := sorry --non-trivial
lemma new_lemma_161016 (h1 h2 : multiset (nondiscrete_normed_field (normed_field enat))) : multiset.subset h1 h2 := sorry --non-trivial
lemma new_lemma_161017 (h0 : option (function.extfun Type add_group)) (h1 : function.extfun Type add_group) : @is_add_cyclic.{0} (add_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} (@option.get_or_else.{1} (function.extfun.{2 1} Type add_group.{0}) h0 h1) (add_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_161018 (h0 : functor.add_const (list (bin_tree congr_arg_kind)) unsigned) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_161019 (h0 : add_monoid (has_add (ring (has_neg pos)))) : add_monoid.fg (has_add (ring (has_neg pos))) := sorry --non-trivial
lemma new_lemma_161020 (h0 : semiring (has_union (semiring unsigned))) : is_noetherian_ring (has_union (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_161021 (h0 : uniform_space (has_top unsigned)) : complete_space (has_top unsigned) := sorry --non-trivial
lemma new_lemma_161022 (h0 : group (complete_distrib_lattice (finset pos))) : is_cyclic (complete_distrib_lattice (finset pos)) := sorry --non-trivial
lemma new_lemma_161023 (h1 : ring (topological_space (topological_space string_imp))) : rank_condition (topological_space (topological_space string_imp)) := sorry --non-trivial
lemma new_lemma_161024 (h0 : function.extfun Type (functor.add_const (complete_lattice (left_cancel_monoid empty)))) : @is_compactly_generated.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (left_cancel_monoid.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (complete_lattice.{0} (left_cancel_monoid.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_161025 (h0 : topological_space (has_Sup (semiring (semiring (semiring (semiring (semiring unsigned))))))) : t0_space (has_Sup (semiring (semiring (semiring (semiring (semiring unsigned)))))) := sorry --non-trivial
lemma new_lemma_161026 (h0 : topological_space (add_cancel_comm_monoid unsigned)) : normal_space (add_cancel_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_161027 (h0 : functor.add_const (ordered_add_comm_monoid (semigroup linarith.comp)) pos) : @archimedean.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (semigroup.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_161028 (h0 : add_monoid (has_add (option name))) : add_monoid.fg (has_add (option name)) := sorry --non-trivial
lemma new_lemma_161029 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (linear_ordered_comm_monoid_with_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_161030 (h0 : topological_space (ring (add_comm_monoid name))) : sequential_space (ring (add_comm_monoid name)) := sorry --non-trivial
lemma new_lemma_161031 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (has_inter.{0} num) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (has_inter.{0} num))  := sorry --non-trivial
lemma new_lemma_161032 (h0 : ring (has_edist (comm_monoid (complete_distrib_lattice empty)))) : is_principal_ideal_ring (has_edist (comm_monoid (complete_distrib_lattice empty))) := sorry --non-trivial
lemma new_lemma_161033 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (complete_distrib_lattice.{0} pos) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (complete_distrib_lattice.{0} pos))  := sorry --non-trivial
lemma new_lemma_161034 (h0 : functor.add_const (group (has_pos_part linarith.comp)) Type) : @normalizer_condition.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 1} (group.{0} (has_pos_part.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_161035 (h0 : topological_space (semiring (has_norm linarith.comp_source))) : totally_disconnected_space (semiring (has_norm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_161036 (h0 : topological_space (add_cancel_monoid (has_Inf Type))) : preirreducible_space (add_cancel_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_161037 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (normed_comm_ring unsigned)) := sorry --non-trivial
lemma new_lemma_161038 (h0 : ordered_comm_monoid (add_comm_monoid (has_bot name))) : has_exists_mul_of_le (add_comm_monoid (has_bot name)) := sorry --non-trivial
lemma new_lemma_161039 (h0 : not (complete_lattice (semiring to_additive.value_type) -> false)) : @is_atomistic.{0} (semiring.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (complete_lattice.{0} (semiring.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_161040 (h0 : group (has_to_string (comm_group Type))) : is_cyclic (has_to_string (comm_group Type)) := sorry --non-trivial
lemma new_lemma_161041 (h0 : ring (comm_group (has_to_string (finset (boolean_algebra (boolean_algebra unsigned)))))) : rank_condition (comm_group (has_to_string (finset (boolean_algebra (boolean_algebra unsigned))))) := sorry --non-trivial
lemma new_lemma_161042 (h0 : function.extfun Type (functor.add_const (complete_lattice linarith.comp))) : @complete_lattice.is_Sup_finite_compact.{0} linarith.comp (@functor.add_const.run.{0 0} (complete_lattice.{0} linarith.comp) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (complete_lattice.{0} linarith.comp)) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_161043 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_simple_group.{0} (has_bot.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_bot.{0} name))  := sorry --non-trivial
lemma new_lemma_161044 (h0 : functor.comp topological_space comm_group environment.implicit_infer_kind) : @sequential_space.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} comm_group.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_161045 (h2 : group (add_comm_monoid reducibility_hints)) : is_cyclic (add_comm_monoid reducibility_hints) := sorry --non-trivial
lemma new_lemma_161046 (h0 : topological_space (complete_distrib_lattice (has_add name))) : loc_path_connected_space (complete_distrib_lattice (has_add name)) := sorry --non-trivial
lemma new_lemma_161047 (h0 : not (complete_lattice linarith.comp_source -> false)) : @complete_lattice.is_Sup_finite_compact.{0} linarith.comp_source (@classical.by_contradiction'.{1} (complete_lattice.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_161048 (h0 : complete_lattice (has_pos_part (ring linarith.comp))) : is_compactly_generated (has_pos_part (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_161049 (h0 : filter (add_cancel_monoid (option (option (option num))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_161050 (h0 : functor.add_const (topological_space (finset pos)) Type) : @path_connected_space.{0} (finset.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (finset.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_161051 (h0 : function.extfun Type topological_space) : @t0_space.{0} (option.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (option.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_161052 (h0 : group (has_zero name)) : group.fg (has_zero name) := sorry --non-trivial
lemma new_lemma_161053 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @preirreducible_space.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_161054 (h0 : topological_space (complete_distrib_lattice name)) : loc_path_connected_space (complete_distrib_lattice name) := sorry --non-trivial
lemma new_lemma_161055 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_161056 (h0 : uniform_space (add_cancel_comm_monoid char)) : complete_space (add_cancel_comm_monoid char) := sorry --non-trivial
lemma new_lemma_161057 (h0 : add_group (has_neg (semigroup Type))) : is_add_cyclic (has_neg (semigroup Type)) := sorry --non-trivial
lemma new_lemma_161058 (h0 : topological_space (has_zero (comm_group (comm_group Type)))) : totally_disconnected_space (has_zero (comm_group (comm_group Type))) := sorry --non-trivial
lemma new_lemma_161059 (h0 : topological_space (sub_neg_monoid (has_Inf pos))) : preirreducible_space (sub_neg_monoid (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_161060 (h0 : topological_space (normed_comm_ring (has_nndist name))) : totally_disconnected_space (normed_comm_ring (has_nndist name)) := sorry --non-trivial
lemma new_lemma_161061 (h0 : semigroup Type -> Prop) : zzz_forall h0 := sorry --non-trivial
lemma new_lemma_161062 (h0 : functor.comp uniform_space has_to_string name) : @separated_space.{0} (has_to_string.{0} name) (@functor.comp.run.{0 0 0} uniform_space.{0} has_to_string.{0} name h0)  := sorry --non-trivial
lemma new_lemma_161063 (h0 : add_group (normed_group unsigned)) : is_add_cyclic (normed_group unsigned) := sorry --non-trivial
lemma new_lemma_161064 (h0 : topological_space (boolean_algebra (has_to_string (has_to_string linarith.comp)))) : topological_space.separable_space (boolean_algebra (has_to_string (has_to_string linarith.comp))) := sorry --non-trivial
lemma new_lemma_161065 (h0 : function.extfun Type (functor.comp topological_space normed_comm_ring)) : @totally_disconnected_space.{0} (normed_comm_ring.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} normed_comm_ring.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} normed_comm_ring.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_161066 (h0 : group (normed_group (semiring (semiring (semiring (semiring (semiring (semiring empty)))))))) : is_cyclic (normed_group (semiring (semiring (semiring (semiring (semiring (semiring empty))))))) := sorry --non-trivial
lemma new_lemma_161067 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (normed_lattice_add_comm_group.{0} pos) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (normed_lattice_add_comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_161068 (h0 : topological_space (has_norm (has_top (has_ssubset to_additive.value_type)))) : path_connected_space (has_norm (has_top (has_ssubset to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_161069 (h0 : complete_lattice (uniform_space (random_gen string.iterator_imp))) : complete_lattice.is_Sup_finite_compact (uniform_space (random_gen string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_161070 (h1 : ring (add_cancel_comm_monoid linarith.ineq)) : is_domain (add_cancel_comm_monoid linarith.ineq) := sorry --non-trivial
lemma new_lemma_161071 (h0 : function.extfun (((Type -> Type) -> Type 1) -> Type 1) (function.extfun ((Type -> Type) -> Type 1))) : @rank_condition.{0} (comm_ring.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) (@function.extfun_app.{3 3} (((Type → Type) → Type 1) → Type 1) (function.extfun.{3 2} ((Type → Type) → Type 1)) h0 (function.extfun.{2 2} (Type → Type))) (function.extfun.{2 1} Type)) ring.{0}) (comm_ring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_161072 (h0 : topological_space (normed_linear_ordered_group (semiring congr_arg_kind))) : loc_path_connected_space (normed_linear_ordered_group (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_161073 (h0 : function.extfun Type topological_space) : @t0_space.{0} (canonically_linear_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_linear_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_161074 (h3 : complete_lattice (has_nnnorm char)) : is_compactly_generated (has_nnnorm char) := sorry --non-trivial
lemma new_lemma_161075 (h1 : ring (linear_ordered_comm_group_with_zero (mul_one_class linarith.ineq))) : is_domain (linear_ordered_comm_group_with_zero (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_161076 (h1 : topological_space (fintype linarith.ineq)) : totally_disconnected_space (fintype linarith.ineq) := sorry --non-trivial
lemma new_lemma_161077 (h0 : functor.add_const (function.extfun Type ring) unsigned) : @rank_condition.{0} (semigroup.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) unsigned h0) (semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_161078 (h0 : ordered_comm_monoid (boolean_algebra.core (has_add unsigned))) : has_exists_mul_of_le (boolean_algebra.core (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_161079 (h0 : ring (distrib (random_gen (random_gen char)))) : is_domain (distrib (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_161080 (h0 : functor.add_const (topological_space (add_cancel_monoid pos)) Type) : @t1_space.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (add_cancel_monoid.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_161081 (h0 : semiring (add_semigroup (semiring (semiring (semiring (option empty)))))) : is_noetherian_ring (add_semigroup (semiring (semiring (semiring (option empty))))) := sorry --non-trivial
lemma new_lemma_161082 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_161083 (h0 : ring (comm_group Type)) : rank_condition (comm_group Type) := sorry --non-trivial
lemma new_lemma_161084 (h0 : set (has_ssubset (mul_one_class enat))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_161085 (h0 : topological_space (simple_graph (has_add Type))) : path_connected_space (simple_graph (has_add Type)) := sorry --non-trivial
lemma new_lemma_161086 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_norm.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_norm.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_161087 (h0 : finset (complete_distrib_lattice environment.implicit_infer_kind)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_161088 (h0 : group (has_emptyc (random_gen (random_gen (random_gen num))))) : normalizer_condition (has_emptyc (random_gen (random_gen (random_gen num)))) := sorry --non-trivial
lemma new_lemma_161089 (h0 : topological_space (add_comm_monoid (comm_group Type))) : t1_space (add_comm_monoid (comm_group Type)) := sorry --non-trivial
lemma new_lemma_161090 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (option.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (option.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_161091 (h0 : uniform_space (has_nndist pos)) : complete_space (has_nndist pos) := sorry --non-trivial
lemma new_lemma_161092 (h0 : topological_space (comm_group pos)) : irreducible_space (comm_group pos) := sorry --non-trivial
lemma new_lemma_161093 (h0 : functor.add_const (list (linear_ordered_cancel_comm_monoid empty)) empty) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_161094 (h0 : functor.add_const (group (cancel_monoid Type)) name) : @is_simple_group.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (cancel_monoid.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_161095 (h0 : topological_space (comm_ring (has_ssubset to_additive.value_type))) : locally_compact_space (comm_ring (has_ssubset to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_161096 (h0 : functor.add_const (ring (has_pos_part pos)) Type) : @is_principal_ideal_ring.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (has_pos_part.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_161097 (h0 : functor.add_const (topological_space (partial_order congr_arg_kind)) unsigned) : @loc_path_connected_space.{0} (partial_order.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (partial_order.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_161098 (h0 : functor.add_const (ring (ring name)) linarith.comp) : @is_principal_ideal_ring.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (ring.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_161099 (h2 : complete_lattice (has_norm num)) : is_compactly_generated (has_norm num) := sorry --non-trivial
lemma new_lemma_161100 (h0 : set (has_div (mul_one_class (mul_one_class string.iterator_imp)))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_161101 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} string_imp (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) string_imp)  := sorry --non-trivial
lemma new_lemma_161102 (h0 : ring (boolean_algebra.core (option (comm_monoid (option unsigned))))) : is_principal_ideal_ring (boolean_algebra.core (option (comm_monoid (option unsigned)))) := sorry --non-trivial
lemma new_lemma_161103 (h0 : group (partial_order (semiring unsigned))) : normalizer_condition (partial_order (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_161104 (h0 : topological_space (metric_space fun_info)) : t0_space (metric_space fun_info) := sorry --non-trivial
lemma new_lemma_161105 (h0 : function.extfun Type group) : @is_simple_group.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} h0 (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_161106 (h0 : semiring (id congr_arg_kind)) (h1 : list (omega_complete_partial_order (polynomial (id congr_arg_kind)))) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_161107 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} auto.case_option (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) auto.case_option)  := sorry --non-trivial
lemma new_lemma_161108 (h0 : functor.add_const (function.extfun Type semiring) unsigned) : @is_noetherian_ring.{0} (linear_ordered_field.{0} ennreal) (@function.extfun_app.{2 1} Type semiring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type semiring.{0}) unsigned h0) (linear_ordered_field.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_161109 (h0 : monoid (boolean_algebra (has_neg real))) : monoid.fg (boolean_algebra (has_neg real)) := sorry --non-trivial
lemma new_lemma_161110 (h0 : complete_lattice (has_nnnorm (has_nnnorm linarith.ineq))) : is_compactly_generated (has_nnnorm (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_161111 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (canonically_ordered_comm_semiring.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (canonically_ordered_comm_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_161112 (h0 : topological_space (topological_space (has_nnnorm linarith.ineq))) : locally_compact_space (topological_space (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_161113 (h0 : functor.add_const (function.extfun Type monoid) linarith.comp) : @monoid.fg.{0} (ordered_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type monoid.{0}) linarith.comp h0) (ordered_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_161114 (h0 : list (canonically_ordered_comm_semiring (option (option unsigned)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_161115 (h0 : fin has_zero.zero) : @topological_space.separable_space.{1} (ordered_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (ordered_comm_monoid.{1} Type)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))))  := sorry --non-trivial
lemma new_lemma_161116 (h0 : topological_space (semigroup Type)) : irreducible_space (semigroup Type) := sorry --non-trivial
lemma new_lemma_161117 (h0 : ring (has_add (has_neg (has_neg (has_Inf name))))) : rank_condition (has_add (has_neg (has_neg (has_Inf name)))) := sorry --non-trivial
lemma new_lemma_161118 (h0 h1 : multiset (has_nnnorm (mul_one_class reducibility_hints))) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_161119 (h0 : functor.add_const (filter (normed_comm_ring Type)) (has_add (has_add (has_add Type)))) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_161120 (h0 : filter (normed_group (has_top (has_top fun_info)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_161121 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (metric_space.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (metric_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_161122 (h0 : functor.comp topological_space cancel_monoid name) : @preconnected_space.{0} (cancel_monoid.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} cancel_monoid.{0} name h0)  := sorry --non-trivial
lemma new_lemma_161123 (h0 : group (has_dist (option (option unsigned)))) : is_cyclic (has_dist (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_161124 (h1 : topological_space (random_gen (random_gen char))) : t0_space (random_gen (random_gen char)) := sorry --non-trivial
lemma new_lemma_161125 (h0 : functor.comp topological_space pseudo_metric_space name) : @sequential_space.{0} (pseudo_metric_space.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} pseudo_metric_space.{0} name h0)  := sorry --non-trivial
lemma new_lemma_161126 (h0 : cancel_comm_monoid_with_zero (generalized_boolean_algebra (has_pos_part (ring linarith.comp)))) : unique_factorization_monoid (generalized_boolean_algebra (has_pos_part (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_161127 (h0 : functor.add_const (topological_space (normed_comm_ring Type)) (has_add linarith.comp)) : @normal_space.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (normed_comm_ring.{1} Type)) (has_add.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_161128 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (comm_ring char)) := sorry --non-trivial
lemma new_lemma_161129 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @irreducible_space.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_161130 (h0 : semiring (linear_order (option empty))) : is_noetherian_ring (linear_order (option empty)) := sorry --non-trivial
lemma new_lemma_161131 (h0 : topological_space (ring (finset (ring (has_neg (has_neg (has_neg linarith.comp))))))) : t0_space (ring (finset (ring (has_neg (has_neg (has_neg linarith.comp)))))) := sorry --non-trivial
lemma new_lemma_161132 (h0 : ring (has_bot (has_add (has_add real)))) : strong_rank_condition (has_bot (has_add (has_add real))) := sorry --non-trivial
lemma new_lemma_161133 (h0 : functor.add_const (topological_space (add_left_cancel_semigroup unsigned)) congr_arg_kind) : @normal_space.{0} (add_left_cancel_semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_left_cancel_semigroup.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_161134 (h0 : topological_space (has_neg_part (has_add Type))) : totally_separated_space (has_neg_part (has_add Type)) := sorry --non-trivial
lemma new_lemma_161135 (h0 : topological_space (measurable_space num)) : preirreducible_space (measurable_space num) := sorry --non-trivial
lemma new_lemma_161136 (h0 : topological_space (normed_lattice_add_comm_group name)) : totally_disconnected_space (normed_lattice_add_comm_group name) := sorry --non-trivial
lemma new_lemma_161137 (h1 : measurable_space char) (h2 : has_add char) (h3 : measure_theory.measure char) : measure_theory.measure.is_add_left_invariant h3 := sorry --non-trivial
lemma new_lemma_161138 (h0 : list (add_cancel_monoid environment.implicit_infer_kind)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_161139 (h0 : monoid (random_gen (random_gen (random_gen (random_gen linarith.comp_source))))) : monoid.fg (random_gen (random_gen (random_gen (random_gen linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_161140 (h0 : list (complete_linear_order num)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_161141 (h0 : cancel_comm_monoid_with_zero (add_cancel_monoid (option ennreal))) : unique_factorization_monoid (add_cancel_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_161142 (h0 : not (ring (semi_normed_comm_ring (random_gen linarith.comp_source)) -> false)) : @is_domain.{0} (semi_normed_comm_ring.{0} (random_gen.{0} linarith.comp_source)) (@classical.by_contradiction'.{1} (ring.{0} (semi_normed_comm_ring.{0} (random_gen.{0} linarith.comp_source))) h0)  := sorry --non-trivial
lemma new_lemma_161143 (h0 : complete_lattice (add_cancel_monoid (has_add pos))) : is_atomistic (add_cancel_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_161144 (h1 : ring (linear_ordered_comm_group_with_zero to_additive.value_type)) : strong_rank_condition (linear_ordered_comm_group_with_zero to_additive.value_type) := sorry --non-trivial
lemma new_lemma_161145 (h0 : not (function.extfun Type monoid -> false)) : @monoid.fg.{0} (has_union.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type monoid.{0}) h0) (has_union.{0} empty))  := sorry --non-trivial
lemma new_lemma_161146 (h0 : group (has_neg_part (has_well_founded ennreal))) : group.fg (has_neg_part (has_well_founded ennreal)) := sorry --non-trivial
lemma new_lemma_161147 (h0 : ring num -> ring num -> Prop) : is_per (ring num) h0 := sorry --non-trivial
lemma new_lemma_161148 (h0 : list (pseudo_metric_space (option (option (option empty))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_161149 (h0 : add_monoid (semigroup (has_add name))) : add_monoid.fg (semigroup (has_add name)) := sorry --non-trivial
lemma new_lemma_161150 (h0 : cancel_comm_monoid_with_zero (semigroup (has_add pos))) : unique_factorization_monoid (semigroup (has_add pos)) := sorry --non-trivial
lemma new_lemma_161151 (h0 : topological_space (finset (option unsigned))) : path_connected_space (finset (option unsigned)) := sorry --non-trivial
lemma new_lemma_161152 (h0 : topological_space (has_add (finset name))) : t0_space (has_add (finset name)) := sorry --non-trivial
lemma new_lemma_161153 (h0 : uniform_space (ordered_comm_monoid (has_pos_part (has_add Type)))) : complete_space (ordered_comm_monoid (has_pos_part (has_add Type))) := sorry --non-trivial
lemma new_lemma_161154 (h0 : ring (has_nnnorm (has_scalar string.iterator_imp environment.projection_info))) : is_domain (has_nnnorm (has_scalar string.iterator_imp environment.projection_info)) := sorry --non-trivial
lemma new_lemma_161155 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_161156 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_compl.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_compl.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_161157 (h0 : topological_space (has_to_string (has_add linarith.comp))) : loc_path_connected_space (has_to_string (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_161158 (h0 : complete_lattice (add_cancel_monoid (add_comm_monoid Type))) : complete_lattice.is_Sup_finite_compact (add_cancel_monoid (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_161159 (h3 : complete_lattice (topological_space (random_gen char))) : is_compactly_generated (topological_space (random_gen char)) := sorry --non-trivial
lemma new_lemma_161160 (h0 : has_mem.mem (normed_group (has_top linarith.comp_source)) has_emptyc.emptyc) : @is_cyclic.{0} (normed_group.{0} (has_top.{0} linarith.comp_source)) (@finset.pi.empty.{1 0} Type group.{0} (normed_group.{0} (has_top.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_161161 (h0 : topological_space (has_add (has_add (has_Inf Type)))) : irreducible_space (has_add (has_add (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_161162 (h0 : functor.add_const (filter (add_comm_monoid pos)) pos) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_161163 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} to_additive.value_type (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 to_additive.value_type)  := sorry --non-trivial
lemma new_lemma_161164 (h0 : function.extfun nat fin) : @loc_path_connected_space.{1} (simple_graph.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (simple_graph.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_161165 (h0 : list (partial_order unsigned)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_161166 (h0 : fin has_zero.zero) : @is_compactly_generated.{0} (has_bot.{0} pos) (@matrix.vec_empty.{0} (complete_lattice.{0} (has_bot.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_161167 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_161168 (h0 : group (add_comm_monoid (has_neg_part Type))) : normalizer_condition (add_comm_monoid (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_161169 (h0 : functor.add_const (group (boolean_algebra.core pos)) pos) : @is_simple_group.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.core.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_161170 (h1 : topological_space (encodable (has_nnnorm string_imp))) : totally_disconnected_space (encodable (has_nnnorm string_imp)) := sorry --non-trivial
lemma new_lemma_161171 (h0 : topological_space (complete_distrib_lattice (ordered_comm_monoid real))) : t1_space (complete_distrib_lattice (ordered_comm_monoid real)) := sorry --non-trivial
lemma new_lemma_161172 (h0 : functor.comp cancel_comm_monoid_with_zero has_add unsigned) : @unique_factorization_monoid.{0} (has_add.{0} unsigned) (@functor.comp.run.{0 0 0} cancel_comm_monoid_with_zero.{0} has_add.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_161173 (h0 : group (with_one (has_nnnorm (has_nnnorm fun_info)))) : is_cyclic (with_one (has_nnnorm (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_161174 (h0 : ring (non_unital_non_assoc_semiring (mul_one_class to_additive.value_type))) : strong_rank_condition (non_unital_non_assoc_semiring (mul_one_class to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_161175 (h0 : functor.add_const (list (has_Sup empty)) (semiring num)) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_161176 (h0 : add_group (complete_semilattice_Sup (has_top (has_top linarith.comp_source)))) : is_add_cyclic (complete_semilattice_Sup (has_top (has_top linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_161177 (h0 : not (function.extfun Type topological_space -> false)) : @discrete_topology.{0} (with_bot.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (with_bot.{0} empty))  := sorry --non-trivial
lemma new_lemma_161178 (h0 : functor.add_const (complete_lattice (comm_group Type)) Type) : @is_compactly_generated.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 1} (complete_lattice.{1} (comm_group.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_161179 (h0 : topological_space (has_add (random_gen fun_info))) : path_connected_space (has_add (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_161180 (h0 : group (finset (has_to_string pos))) : group.fg (finset (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_161181 (h0 : cancel_comm_monoid_with_zero (boolean_algebra.core (boolean_algebra.core Type))) : unique_factorization_monoid (boolean_algebra.core (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_161182 (h0 : add_group (has_bot (has_bot real))) : is_add_cyclic (has_bot (has_bot real)) := sorry --non-trivial
lemma new_lemma_161183 (h0 : group (normed_comm_ring (has_add (has_add pos)))) : is_simple_group (normed_comm_ring (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_161184 (h0 : functor.add_const (group (cancel_monoid environment.implicit_infer_kind)) name) : @is_cyclic.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (cancel_monoid.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_161185 (h0 : functor.add_const (ring (has_star num)) num) : @is_domain.{0} (has_star.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (has_star.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_161186 (h0 : functor.add_const (monoid (preorder empty)) unsigned) : @monoid.fg.{0} (preorder.{0} empty) (@functor.add_const.run.{0 0} (monoid.{0} (preorder.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_161187 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @is_add_cyclic.{0} (measurable_space.dynkin_system.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) add_group.{0}) (measurable_space.dynkin_system.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_161188 (h0 : group (ordered_comm_ring (finset linarith.comp))) : normalizer_condition (ordered_comm_ring (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_161189 (h0 : functor.add_const (cancel_comm_monoid_with_zero (bin_tree empty)) num) : @unique_factorization_monoid.{0} (bin_tree.{0} empty) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (bin_tree.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_161190 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (has_edist.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_edist.{0} empty))  := sorry --non-trivial
lemma new_lemma_161191 (h1 : uniform_space (has_compl linarith.comp_source)) : complete_space (has_compl linarith.comp_source) := sorry --non-trivial
lemma new_lemma_161192 (h0 h1 : multiset (simple_graph ereal)) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_161193 (h0 : topological_space (add_comm_semigroup linarith.ineq)) : t0_space (add_comm_semigroup linarith.ineq) := sorry --non-trivial
lemma new_lemma_161194 (h0 : functor.comp filter boolean_algebra.core name) : filter.ne_bot (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_161195 (h0 : uniform_space (ordered_comm_monoid linarith.comp)) : complete_space (ordered_comm_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_161196 (h0 : uniform_space (boolean_algebra (finset Type))) : separated_space (boolean_algebra (finset Type)) := sorry --non-trivial
lemma new_lemma_161197 (h0 : group (boolean_algebra (finset (comm_group pos)))) : group.fg (boolean_algebra (finset (comm_group pos))) := sorry --non-trivial
lemma new_lemma_161198 (h0 : not (has_mem.mem linarith.ineq has_emptyc.emptyc -> false)) : @strong_rank_condition.{0} linarith.ineq (@finset.pi.empty.{1 0} Type ring.{0} linarith.ineq (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) linarith.ineq (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_161199 (h0 : group (normed_comm_ring (semigroup (has_add Type)))) : group.fg (normed_comm_ring (semigroup (has_add Type))) := sorry --non-trivial
lemma new_lemma_161200 (h0 : functor.add_const (complete_lattice (uniform_space name)) Type) : complete_lattice.is_Sup_finite_compact (uniform_space name) := sorry --non-trivial
lemma new_lemma_161201 (h1 : nat) (h2 : topological_space (fin h1)) : topological_space.first_countable_topology (fin h1) := sorry --non-trivial
lemma new_lemma_161202 (h0 : ordered_add_comm_monoid (has_zero (has_add name))) : archimedean (has_zero (has_add name)) := sorry --non-trivial
lemma new_lemma_161203 (h0 : ordered_add_comm_monoid (ordered_ring (option empty))) : archimedean (ordered_ring (option empty)) := sorry --non-trivial
lemma new_lemma_161204 (h0 : complete_lattice (with_bot (random_gen linarith.ineq))) : is_atomistic (with_bot (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_161205 (h0 : function.extfun Type group) : @group.fg.{0} (filter.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (filter.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_161206 (h0 : topological_space (ring (ring (has_to_string environment.implicit_infer_kind)))) : t1_space (ring (ring (has_to_string environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_161207 (h0 : fin has_zero.zero) : @strong_rank_condition.{0} (generalized_boolean_algebra.{0} pos) (@matrix.vec_empty.{0} (ring.{0} (generalized_boolean_algebra.{0} pos)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_161208 (h0 : topological_space (has_one empty)) : irreducible_space (has_one empty) := sorry --non-trivial
lemma new_lemma_161209 (h0 : functor.add_const (topological_space (linear_order unsigned)) empty) : @totally_separated_space.{0} (linear_order.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_order.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_161210 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @preconnected_space.{1} (sub_neg_monoid.{1} (has_add.{1} (ring.{1} (has_add.{1} (has_add.{1} (has_add.{1} (has_add.{1} Type))))))) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (sub_neg_monoid.{1} (has_add.{1} (ring.{1} (has_add.{1} (has_add.{1} (has_add.{1} (has_add.{1} Type))))))))  := sorry --non-trivial
lemma new_lemma_161211 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (boolean_algebra.core.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} num))  := sorry --non-trivial
lemma new_lemma_161212 (h0 : topological_space (has_zero (has_add name))) : t0_space (has_zero (has_add name)) := sorry --non-trivial
lemma new_lemma_161213 (h0 : group (measure_theory.measure_space num)) : normalizer_condition (measure_theory.measure_space num) := sorry --non-trivial
lemma new_lemma_161214 (h0 : functor.comp ring linear_ordered_add_comm_group char) : @strong_rank_condition.{0} (linear_ordered_add_comm_group.{0} char) (@functor.comp.run.{0 0 0} ring.{0} linear_ordered_add_comm_group.{0} char h0)  := sorry --non-trivial
lemma new_lemma_161215 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @t1_space.{0} (has_Inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (has_Inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_161216 (h0 : uniform_space (has_Inf (ring linarith.comp))) : separated_space (has_Inf (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_161217 (h0 : functor.add_const (ordered_comm_monoid (boolean_algebra.core name)) linarith.comp) : @has_exists_mul_of_le.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (boolean_algebra.core.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_161218 (h0 : ring (normed_field (mul_one_class (mul_one_class (mul_one_class linarith.ineq))))) : strong_rank_condition (normed_field (mul_one_class (mul_one_class (mul_one_class linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_161219 (h0 : topological_space (left_cancel_monoid (semiring (semiring (semiring empty))))) : topological_space.separable_space (left_cancel_monoid (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_161220 (h0 : topological_space (monoid (option ennreal))) : t0_space (monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_161221 (h0 : function.extfun (finset Type) (has_mem.mem (with_bot num))) : @monoid.fg.{0} (with_bot.{0} num) (@finset.pi.empty.{1 0} Type monoid.{0} (with_bot.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_bot.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_161222 (h0 : ordered_add_comm_monoid (boolean_algebra.core (option unsigned))) : archimedean (boolean_algebra.core (option unsigned)) := sorry --non-trivial
lemma new_lemma_161223 (h1 : add_group (topological_space string_imp)) : is_add_cyclic (topological_space string_imp) := sorry --non-trivial
lemma new_lemma_161224 (h0 : function.extfun (Type 1) group) : @is_cyclic.{1} Type (@function.extfun_app.{3 2} (Type 1) group.{1} h0 Type)  := sorry --non-trivial
lemma new_lemma_161225 (h0 : complete_lattice (linear_ordered_cancel_comm_monoid empty)) : is_compactly_generated (linear_ordered_cancel_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_161226 (h0 : complete_lattice (has_dist num)) : complete_lattice.is_Sup_finite_compact (has_dist num) := sorry --non-trivial
lemma new_lemma_161227 (h0 : group (option (option pos))) : is_simple_group (option (option pos)) := sorry --non-trivial
lemma new_lemma_161228 (h0 : not (topological_space (with_bot to_additive.value_type) -> false)) : @irreducible_space.{0} (with_bot.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (with_bot.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_161229 (h0 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} (with_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h0) (with_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_161230 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (canonically_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_161231 (h0 : functor.add_const (group (boolean_algebra linarith.comp)) (ring linarith.comp)) : @group.fg.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.{0} linarith.comp)) (ring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_161232 (h0 : functor.add_const (topological_space (has_to_string linarith.comp)) (has_zero (has_zero Type))) : @path_connected_space.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_to_string.{0} linarith.comp)) (has_zero.{1} (has_zero.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_161233 (h0 : topological_space (boolean_algebra linarith.comp)) : t1_space (boolean_algebra linarith.comp) := sorry --non-trivial
lemma new_lemma_161234 (h0 : uniform_space (has_union (has_top (has_norm fun_info)))) : complete_space (has_union (has_top (has_norm fun_info))) := sorry --non-trivial
lemma new_lemma_161235 (h0 : functor.add_const (topological_space (comm_group unsigned)) unsigned) : @sequential_space.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_161236 (h0 : topological_space (has_bot (has_add (sub_neg_monoid (has_Inf (has_add (sub_neg_monoid pos))))))) : discrete_topology (has_bot (has_add (sub_neg_monoid (has_Inf (has_add (sub_neg_monoid pos)))))) := sorry --non-trivial
lemma new_lemma_161237 (h0 : function.extfun Type (functor.add_const (filter pos))) : filter.ne_bot (functor.add_const.run (function.extfun_app h0 unsigned)) := sorry --non-trivial
lemma new_lemma_161238 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (has_emptyc.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 uniform_space.{0}) (has_emptyc.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_161239 (h0 : functor.comp ring ring (normed_comm_ring environment.implicit_infer_kind)) : @rank_condition.{0} (ring.{0} (normed_comm_ring.{0} environment.implicit_infer_kind)) (@functor.comp.run.{0 0 0} ring.{0} ring.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_161240 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @sequential_space.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_161241 (h0 : functor.add_const (topological_space (boolean_algebra linarith.comp)) name) : @topological_space.separable_space.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_161242 (h0 : topological_space (comm_semigroup (sub_neg_monoid (sub_neg_monoid real)))) : discrete_topology (comm_semigroup (sub_neg_monoid (sub_neg_monoid real))) := sorry --non-trivial
lemma new_lemma_161243 (h0 : functor.add_const (group (has_Inf linarith.comp)) (has_neg Type)) : @group.fg.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 1} (group.{0} (has_Inf.{0} linarith.comp)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_161244 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (@id.{2} Type linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (@id.{2} Type linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_161245 (h0 : topological_space (has_div string.iterator_imp)) (h1 : add_group (has_div string.iterator_imp)) : topological_add_group (has_div string.iterator_imp) := sorry --non-trivial
lemma new_lemma_161246 (h0 : topological_space (linear_ordered_add_comm_group num)) : t0_space (linear_ordered_add_comm_group num) := sorry --non-trivial
lemma new_lemma_161247 (h0 : topological_space (semi_normed_comm_ring string_imp)) : totally_disconnected_space (semi_normed_comm_ring string_imp) := sorry --non-trivial
lemma new_lemma_161248 (h0 : topological_space (has_nndist (finset (finset (has_nndist pos))))) : path_connected_space (has_nndist (finset (finset (has_nndist pos)))) := sorry --non-trivial
lemma new_lemma_161249 (h0 : topological_space (has_one (has_norm linarith.comp))) : locally_compact_space (has_one (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_161250 (h0 : fin has_zero.zero) : @unique_factorization_monoid.{1} (ordered_comm_ring.{1} Type) (@matrix.vec_empty.{1} (cancel_comm_monoid_with_zero.{1} (ordered_comm_ring.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_161251 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (normed_lattice_add_comm_group.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (normed_lattice_add_comm_group.{0} name))  := sorry --non-trivial
lemma new_lemma_161252 (h1 : function.extfun Type topological_space) : @path_connected_space.{0} (dlist.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (dlist.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_161253 (h0 : uniform_space (normed_group (semiring (semiring (semiring empty))))) : separated_space (normed_group (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_161254 (h0 : not (ring (with_one to_additive.value_type) -> false)) : @strong_rank_condition.{0} (with_one.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (with_one.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_161255 (h0 : topological_space (ordered_comm_monoid (has_Inf linarith.comp))) : sequential_space (ordered_comm_monoid (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_161256 (h0 : set (semi_normed_comm_ring (mul_one_class (mul_one_class linarith.comp_source)))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_161257 (h1 : complete_lattice (has_append linarith.comp_source)) : is_compactly_generated (has_append linarith.comp_source) := sorry --non-trivial
lemma new_lemma_161258 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @discrete_topology.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_161259 (h0 : functor.add_const (topological_space unsigned) empty) : @normal_space.{0} unsigned (@functor.add_const.run.{0 0} (topological_space.{0} unsigned) empty h0)  := sorry --non-trivial
lemma new_lemma_161260 (h0 : not (ring (with_one linarith.comp_source) -> false)) : @is_domain.{0} (with_one.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (with_one.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_161261 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (normed_linear_ordered_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_linear_ordered_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_161262 (h0 : functor.add_const (ring (has_add linarith.comp)) pos) : @is_domain.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_add.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_161263 (h0 : group (has_Inf (has_add (has_add (has_add (ring linarith.comp)))))) : group.fg (has_Inf (has_add (has_add (has_add (ring linarith.comp))))) := sorry --non-trivial
lemma new_lemma_161264 (h0 : not (function.extfun Type ring -> false)) : @strong_rank_condition.{0} (with_one.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (with_one.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_161265 (h0 : function.extfun Type topological_space) : @normal_space.{0} (boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_161266 (h1 : uniform_space (id linarith.comp_source)) : complete_space (id linarith.comp_source) := sorry --non-trivial
lemma new_lemma_161267 (h1 : group (normed_field (comm_ring char))) : is_cyclic (normed_field (comm_ring char)) := sorry --non-trivial
lemma new_lemma_161268 (h0 : functor.add_const (ordered_comm_monoid (generalized_boolean_algebra linarith.comp)) name) : @has_exists_mul_of_le.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (generalized_boolean_algebra.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_161269 (h0 : functor.add_const (add_monoid name) num) : @add_monoid.fg.{0} name (@functor.add_const.run.{0 0} (add_monoid.{0} name) num h0)  := sorry --non-trivial
lemma new_lemma_161270 (h0 : function.extfun (Type 1) semiring) : @is_noetherian_ring.{1} (canonically_linear_ordered_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) semiring.{1} h0 (canonically_linear_ordered_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_161271 (h1 : not (ring (semi_normed_ring string_imp) -> false)) : @strong_rank_condition.{0} (semi_normed_ring.{0} string_imp) (@classical.by_contradiction'.{1} (ring.{0} (semi_normed_ring.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_161272 (h0 : functor.add_const (function.extfun Type topological_space) (has_neg (ordered_ring linarith.comp))) : @totally_separated_space.{0} (has_Inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (has_neg.{0} (ordered_ring.{0} linarith.comp)) h0) (has_Inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_161273 (h1 : set (has_neg fun_info -> mul_one_class char)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_161274 (h0 : functor.comp topological_space complete_distrib_lattice name) : @t1_space.{0} (complete_distrib_lattice.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} complete_distrib_lattice.{0} name h0)  := sorry --non-trivial
lemma new_lemma_161275 (h0 : topological_space (linear_ordered_semiring (semiring (semiring (semiring unsigned))))) : irreducible_space (linear_ordered_semiring (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_161276 (h0 : ring (ordered_comm_ring (has_add Type))) : strong_rank_condition (ordered_comm_ring (has_add Type)) := sorry --non-trivial
lemma new_lemma_161277 (h0 : topological_space (measure_theory.measure_space (semiring (semiring unsigned)))) : irreducible_space (measure_theory.measure_space (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_161278 (h0 : ring (has_inter (option unsigned))) : is_principal_ideal_ring (has_inter (option unsigned)) := sorry --non-trivial
lemma new_lemma_161279 (h0 : functor.add_const (ring (finset ennreal)) name) : @is_domain.{0} (finset.{0} ennreal) (@functor.add_const.run.{0 0} (ring.{0} (finset.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_161280 (h0 : functor.add_const (ring (semigroup name)) name) : @is_domain.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (semigroup.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_161281 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_neg.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} empty))  := sorry --non-trivial
lemma new_lemma_161282 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (mul_zero_class.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (mul_zero_class.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_161283 (h0 : functor.add_const (function.extfun Type list) pos) : list.nodup (function.extfun_app (functor.add_const.run h0) (has_zero linarith.comp)) := sorry --non-trivial
lemma new_lemma_161284 (h0 : uniform_space (add_cancel_monoid name)) : complete_space (add_cancel_monoid name) := sorry --non-trivial
lemma new_lemma_161285 (h0 : functor.add_const (complete_lattice (semigroup Type)) (has_neg_part name)) : @complete_lattice.is_Sup_finite_compact.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (semigroup.{1} Type)) (has_neg_part.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_161286 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @group.fg.{0} (with_bot.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) group.{0}) (with_bot.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_161287 (h0 : topological_space (has_add (mul_one_class Type))) : regular_space (has_add (mul_one_class Type)) := sorry --non-trivial
lemma new_lemma_161288 (h0 : functor.add_const (add_monoid (boolean_algebra.core name)) pos) : @add_monoid.fg.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (add_monoid.{0} (boolean_algebra.core.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_161289 (h0 : functor.add_const (topological_space (normed_comm_ring unsigned)) pos) : @t0_space.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_161290 (h2 : ring string.iterator_imp) : is_domain string.iterator_imp := sorry --non-trivial
lemma new_lemma_161291 (h0 : ring (has_compl (has_top linarith.ineq))) : is_domain (has_compl (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_161292 (h0 : topological_space (boolean_algebra (has_to_string environment.implicit_infer_kind))) : regular_space (boolean_algebra (has_to_string environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_161293 (h0 : not (function.extfun Type monoid -> false)) : @monoid.fg.{0} (measurable_space.{0} num) (@function.extfun_app.{2 1} Type monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type monoid.{0}) h0) (measurable_space.{0} num))  := sorry --non-trivial
lemma new_lemma_161294 (h0 : function.extfun (((Type -> Type) -> Type 1) -> Type 1) (function.extfun ((Type -> Type) -> Type 1))) : @group.fg.{0} (with_bot.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) (@function.extfun_app.{3 3} (((Type → Type) → Type 1) → Type 1) (function.extfun.{3 2} ((Type → Type) → Type 1)) h0 (function.extfun.{2 2} (Type → Type))) (function.extfun.{2 1} Type)) group.{0}) (with_bot.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_161295 (h0 : ring (simple_graph linarith.comp)) : is_principal_ideal_ring (simple_graph linarith.comp) := sorry --non-trivial
lemma new_lemma_161296 (h0 : functor.add_const (topological_space (ring Type)) Type) : @path_connected_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (ring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_161297 (h0 : add_group (with_bot (with_bot linarith.comp))) : is_add_cyclic (with_bot (with_bot linarith.comp)) := sorry --non-trivial
lemma new_lemma_161298 (h0 : ring (mul_one_class (pseudo_metric_space (mul_one_class string.iterator_imp)))) : strong_rank_condition (mul_one_class (pseudo_metric_space (mul_one_class string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_161299 (h0 : topological_space (id (semiring (semiring fun_info)))) : preirreducible_space (id (semiring (semiring fun_info))) := sorry --non-trivial
lemma new_lemma_161300 (h0 : functor.add_const (ordered_add_comm_monoid (has_neg name)) (has_add Type)) : @archimedean.{0} (has_neg.{0} name) (@functor.add_const.run.{0 1} (ordered_add_comm_monoid.{0} (has_neg.{0} name)) (has_add.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_161301 (h0 : cancel_comm_monoid_with_zero (add_cancel_monoid (has_to_string (has_to_string (has_to_string Type))))) : unique_factorization_monoid (add_cancel_monoid (has_to_string (has_to_string (has_to_string Type)))) := sorry --non-trivial
lemma new_lemma_161302 (h0 : topological_space (boolean_algebra.core (has_nndist (ordered_ring Type)))) : preirreducible_space (boolean_algebra.core (has_nndist (ordered_ring Type))) := sorry --non-trivial
lemma new_lemma_161303 (h0 : uniform_space (simple_graph (has_le (mul_one_class ereal)))) : complete_space (simple_graph (has_le (mul_one_class ereal))) := sorry --non-trivial
lemma new_lemma_161304 (h0 : cancel_comm_monoid_with_zero (add_cancel_monoid (option (option (option (option ennreal)))))) : unique_factorization_monoid (add_cancel_monoid (option (option (option (option ennreal))))) := sorry --non-trivial
lemma new_lemma_161305 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (generalized_boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (generalized_boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_161306 (h0 : add_group (comm_group (has_neg_part (has_neg_part (has_neg_part (boolean_algebra pos)))))) : is_add_cyclic (comm_group (has_neg_part (has_neg_part (has_neg_part (boolean_algebra pos))))) := sorry --non-trivial
lemma new_lemma_161307 (h0 : function.extfun Type group) : @is_cyclic.{0} (measure_theory.measure_space.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (measure_theory.measure_space.{0} num))  := sorry --non-trivial
lemma new_lemma_161308 (h0 : functor.add_const (topological_space (has_neg_part Type)) name) : @totally_separated_space.{1} (has_neg_part.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_neg_part.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_161309 (h0 : ring (simple_graph (boolean_algebra.core Type))) : is_principal_ideal_ring (simple_graph (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_161310 (h0 : cancel_comm_monoid_with_zero (ordered_comm_ring (has_add linarith.comp))) : unique_factorization_monoid (ordered_comm_ring (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_161311 (h1 : complete_lattice (has_top (denumerable string_imp))) : is_compactly_generated (has_top (denumerable string_imp)) := sorry --non-trivial
lemma new_lemma_161312 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (with_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (with_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_161313 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (linear_ordered_comm_ring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_comm_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_161314 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_dist.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (has_dist.{0} empty))  := sorry --non-trivial
lemma new_lemma_161315 (h0 : functor.add_const (topological_space (ordered_comm_group empty)) empty) : @locally_compact_space.{0} (ordered_comm_group.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_group.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_161316 (h0 : function.extfun Type group) : @normalizer_condition.{0} (sub_neg_monoid.{0} real) (@function.extfun_app.{2 1} Type group.{0} h0 (sub_neg_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_161317 (h0 : group (has_nnnorm string_imp)) : is_cyclic (has_nnnorm string_imp) := sorry --non-trivial
lemma new_lemma_161318 (h0 : not (group (topological_space (has_nnnorm (has_nnnorm (has_nnnorm reducibility_hints)))) -> false)) : @is_cyclic.{0} (topological_space.{0} (has_nnnorm.{0} (has_nnnorm.{0} (has_nnnorm.{0} reducibility_hints)))) (@classical.by_contradiction'.{1} (group.{0} (topological_space.{0} (has_nnnorm.{0} (has_nnnorm.{0} (has_nnnorm.{0} reducibility_hints))))) h0)  := sorry --non-trivial
lemma new_lemma_161319 (h0 : semiring (add_cancel_monoid (ring environment.implicit_infer_kind))) : is_noetherian_ring (add_cancel_monoid (ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_161320 (h0 : functor.add_const (topological_space (has_to_string pos)) pos) : @t1_space.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_161321 (h0 : filter (with_one (semiring (semiring (semiring unsigned))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_161322 (h0 : group (cancel_monoid name)) : normalizer_condition (cancel_monoid name) := sorry --non-trivial
lemma new_lemma_161323 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (semigroup.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_161324 (h0 : function.extfun Type topological_space) : @t0_space.{0} (@id.{2} Type to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (@id.{2} Type to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_161325 (h0 : semiring (linear_ordered_comm_ring (add_group linarith.comp))) : is_noetherian_ring (linear_ordered_comm_ring (add_group linarith.comp)) := sorry --non-trivial
lemma new_lemma_161326 (h0 : complete_lattice (with_bot linarith.ineq)) : is_atomistic (with_bot linarith.ineq) := sorry --non-trivial
lemma new_lemma_161327 (h0 : fin has_zero.zero) : @has_exists_mul_of_le.{0} (normed_lattice_add_comm_group.{0} pos) (@matrix.vec_empty.{0} (ordered_comm_monoid.{0} (normed_lattice_add_comm_group.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_161328 (h1 : function.extfun Type group) : @is_cyclic.{0} (complete_semilattice_Sup.{0} string_imp) (@function.extfun_app.{2 1} Type group.{0} h1 (complete_semilattice_Sup.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_161329 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_edist.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_edist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_161330 (h0 : list (comm_group (finset name))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_161331 (h0 : topological_space (ordered_comm_monoid (ordered_comm_monoid Type))) : loc_path_connected_space (ordered_comm_monoid (ordered_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_161332 (h0 : ring (has_div (has_compl char)) -> Prop) (h1 : Exists (fun (x : ring (has_div (has_compl char))), h0 x)) : @is_domain.{0} (has_div.{0} (has_compl.{0} char)) (@classical.some.{1} (ring.{0} (has_div.{0} (has_compl.{0} char))) h0 h1)  := sorry --non-trivial
lemma new_lemma_161333 (h0 : functor.add_const (monoid (normed_comm_ring pos)) Type) : @monoid.fg.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 1} (monoid.{0} (normed_comm_ring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_161334 (h0 : topological_space (boolean_algebra (has_to_string (finset linarith.comp)))) : t1_space (boolean_algebra (has_to_string (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_161335 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (linear_ordered_field.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_field.{0} pos))  := sorry --non-trivial
lemma new_lemma_161336 (h0 : add_group (normed_field string.iterator_imp)) : is_add_cyclic (normed_field string.iterator_imp) := sorry --non-trivial
lemma new_lemma_161337 (h0 : functor.add_const (ordered_add_comm_monoid (generalized_boolean_algebra pos)) linarith.comp) : @archimedean.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (generalized_boolean_algebra.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_161338 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (complete_semilattice_Sup.{0} (comm_ring.{0} (random_gen.{0} (has_norm.{0} linarith.ineq)))) (@function.extfun_app.{2 1} Type add_group.{0} h0 (complete_semilattice_Sup.{0} (comm_ring.{0} (random_gen.{0} (has_norm.{0} linarith.ineq)))))  := sorry --non-trivial
lemma new_lemma_161339 (h0 : ring (semi_normed_comm_ring (semi_normed_ring linarith.ineq))) : is_domain (semi_normed_comm_ring (semi_normed_ring linarith.ineq)) := sorry --non-trivial
lemma new_lemma_161340 (h0 : functor.add_const (uniform_space (boolean_algebra environment.implicit_infer_kind)) linarith.comp) : @separated_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (uniform_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_161341 (h0 : fin has_zero.zero) : @preirreducible_space.{0} (has_bot.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (has_bot.{0} real)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_161342 (h1 : add_group (mul_one_class (mul_one_class char))) : is_add_cyclic (mul_one_class (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_161343 (h0 : functor.add_const (ring (add_comm_monoid pos)) (finset environment.implicit_infer_kind)) : @is_principal_ideal_ring.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (add_comm_monoid.{0} pos)) (finset.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_161344 (h0 : list (normed_group (random_gen string_imp))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_161345 (h0 : topological_space (linear_ordered_add_comm_group (has_norm to_additive.value_type))) : discrete_topology (linear_ordered_add_comm_group (has_norm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_161346 (h0 : group (add_comm_monoid (ring (ring Type)))) : normalizer_condition (add_comm_monoid (ring (ring Type))) := sorry --non-trivial
lemma new_lemma_161347 (h0 : group (finset (option unsigned))) : is_cyclic (finset (option unsigned)) := sorry --non-trivial
lemma new_lemma_161348 (h0 : topological_space (add_group (semiring num))) : normal_space (add_group (semiring num)) := sorry --non-trivial
lemma new_lemma_161349 (h0 : functor.add_const (function.extfun (Type 1) finset) environment.implicit_infer_kind) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (semigroup Type)) := sorry --non-trivial
lemma new_lemma_161350 (h0 : topological_space (ring (has_neg_part environment.implicit_infer_kind))) : irreducible_space (ring (has_neg_part environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_161351 (h0 : functor.add_const (add_monoid (finset pos)) (has_to_string linarith.comp)) : @add_monoid.fg.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (add_monoid.{0} (finset.{0} pos)) (has_to_string.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_161352 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_star.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_star.{0} empty))  := sorry --non-trivial
lemma new_lemma_161353 (h0 : topological_space (normed_group (random_gen (random_gen linarith.comp_source)))) : totally_separated_space (normed_group (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_161354 (h0 : function.extfun Type topological_space) : @t0_space.{0} (@id.{2} Type string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (@id.{2} Type string_imp))  := sorry --non-trivial
lemma new_lemma_161355 (h0 : functor.add_const (function.extfun Type topological_space) (has_neg name)) : @regular_space.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (has_neg.{0} name) h0) (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_161356 (h0 : functor.add_const (add_monoid (ordered_comm_monoid name)) (ring Type)) : @add_monoid.fg.{0} (ordered_comm_monoid.{0} name) (@functor.add_const.run.{0 1} (add_monoid.{0} (ordered_comm_monoid.{0} name)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_161357 (h0 : ring (dlist (random_gen string_imp))) : strong_rank_condition (dlist (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_161358 (h0 : functor.add_const (semiring (add_cancel_monoid environment.implicit_infer_kind)) linarith.comp) : @is_noetherian_ring.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (semiring.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_161359 (h0 : uniform_space (has_add (has_inv (div_inv_monoid linarith.ineq)))) : complete_space (has_add (has_inv (div_inv_monoid linarith.ineq))) := sorry --non-trivial
lemma new_lemma_161360 (h1 : add_group (distrib_lattice char)) : is_add_cyclic (distrib_lattice char) := sorry --non-trivial
lemma new_lemma_161361 (h1 : complete_lattice (semiring linarith.comp_source)) : is_compactly_generated (semiring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_161362 (h0 : finset (add_cancel_comm_monoid empty)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_161363 (h0 : functor.comp topological_space cancel_monoid name) : @discrete_topology.{0} (cancel_monoid.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} cancel_monoid.{0} name h0)  := sorry --non-trivial
lemma new_lemma_161364 (h0 : ring (ring (comm_group (boolean_algebra environment.implicit_infer_kind)))) : strong_rank_condition (ring (comm_group (boolean_algebra environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_161365 (h0 : functor.comp uniform_space normed_comm_ring name) : @separated_space.{0} (normed_comm_ring.{0} name) (@functor.comp.run.{0 0 0} uniform_space.{0} normed_comm_ring.{0} name h0)  := sorry --non-trivial
lemma new_lemma_161366 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (add_comm_monoid.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_161367 (h0 : functor.add_const (group (has_add name)) (ring name)) : @group.fg.{0} (has_add.{0} name) (@functor.add_const.run.{0 0} (group.{0} (has_add.{0} name)) (ring.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_161368 (h0 : functor.comp topological_space comm_group name) : @t0_space.{0} (comm_group.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} comm_group.{0} name h0)  := sorry --non-trivial
lemma new_lemma_161369 (h0 : filter (topological_space pos)) : @regular_space.{0} pos (@filter.Limsup.{0} (topological_space.{0} pos) (@complete_lattice.to_conditionally_complete_lattice.{0} (topological_space.{0} pos) (@topological_space.complete_lattice.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_161370 (h0 : functor.add_const (topological_space (has_to_string environment.implicit_infer_kind)) linarith.comp) : @t0_space.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_161371 (h0 : functor.add_const (topological_space (boolean_algebra.core Type)) Type) : @sequential_space.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (boolean_algebra.core.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_161372 (h0 : monoid (boolean_algebra (has_Inf (has_Inf real)))) : monoid.fg (boolean_algebra (has_Inf (has_Inf real))) := sorry --non-trivial
lemma new_lemma_161373 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @preconnected_space.{1} (canonically_ordered_comm_semiring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (canonically_ordered_comm_semiring.{1} Type))  := sorry --non-trivial
lemma new_lemma_161374 (h0 : ring (denumerable (has_ssubset (has_inv fun_info)))) : rank_condition (denumerable (has_ssubset (has_inv fun_info))) := sorry --non-trivial
lemma new_lemma_161375 (h0 : topological_space (normed_comm_ring (has_add environment.implicit_infer_kind))) : normal_space (normed_comm_ring (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_161376 (h0 : list (has_norm (random_gen (random_gen (random_gen (random_gen (random_gen (random_gen char)))))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_161377 (h0 : filter (has_add (finset Type))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_161378 (h0 : not (function.extfun Type complete_lattice -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (bin_tree.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (bin_tree.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_161379 (h0 : topological_space (has_top num)) : t1_space (has_top num) := sorry --non-trivial
lemma new_lemma_161380 (h0 : ring (linear_ordered_add_comm_group (with_bot to_additive.value_type))) : is_domain (linear_ordered_add_comm_group (with_bot to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_161381 (h0 : list (ring (has_add name))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_161382 (h0 : function.extfun Type topological_space) : @t0_space.{0} (comm_group.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_group.{0} name))  := sorry --non-trivial
lemma new_lemma_161383 (h0 : functor.add_const (group (ring Type)) (ring environment.implicit_infer_kind)) : @normalizer_condition.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (ring.{1} Type)) (ring.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_161384 (h0 : functor.add_const (topological_space (ring unsigned)) linarith.comp) : @path_connected_space.{0} (ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_161385 (h0 : topological_space (ordered_comm_ring (ring (has_neg linarith.comp)))) : totally_separated_space (ordered_comm_ring (ring (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_161386 (h0 : function.extfun Type (functor.add_const (cancel_comm_monoid_with_zero (semigroup empty)))) : @unique_factorization_monoid.{0} (semigroup.{0} empty) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (semigroup.{0} empty)) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (cancel_comm_monoid_with_zero.{0} (semigroup.{0} empty))) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_161387 (h0 : functor.add_const (topological_space (has_neg unsigned)) unsigned) : @locally_compact_space.{0} (has_neg.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_161388 (h0 : functor.add_const (group (boolean_algebra pos)) Type) : @is_simple_group.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (boolean_algebra.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_161389 (h1 : uniform_space (has_lt reducibility_hints)) : complete_space (has_lt reducibility_hints) := sorry --non-trivial
lemma new_lemma_161390 (h0 : topological_space (boolean_algebra (has_add (has_add (has_add (has_add Type)))))) : t1_space (boolean_algebra (has_add (has_add (has_add (has_add Type))))) := sorry --non-trivial
lemma new_lemma_161391 (h0 : topological_space (has_emptyc num)) : locally_compact_space (has_emptyc num) := sorry --non-trivial
lemma new_lemma_161392 (h0 : not (add_group (semi_normed_comm_ring char) -> false)) : @is_add_cyclic.{0} (semi_normed_comm_ring.{0} char) (@classical.by_contradiction'.{1} (add_group.{0} (semi_normed_comm_ring.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_161393 (h1 : ring (dlist fun_info)) : is_domain (dlist fun_info) := sorry --non-trivial
lemma new_lemma_161394 (h0 : cancel_comm_monoid_with_zero (add_comm_monoid (has_pos_part (sub_neg_monoid real)))) : unique_factorization_monoid (add_comm_monoid (has_pos_part (sub_neg_monoid real))) := sorry --non-trivial
lemma new_lemma_161395 (h0 : group (partial_order (semiring num))) : group.fg (partial_order (semiring num)) := sorry --non-trivial
lemma new_lemma_161396 (h0 : ring (generalized_boolean_algebra (ordered_comm_monoid (has_Inf linarith.comp)))) : is_principal_ideal_ring (generalized_boolean_algebra (ordered_comm_monoid (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_161397 (h0 : complete_lattice (left_cancel_monoid unsigned)) : complete_lattice.is_Sup_finite_compact (left_cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_161398 (h0 : functor.add_const (function.extfun Type topological_space) environment.implicit_infer_kind) : @topological_space.separable_space.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) environment.implicit_infer_kind h0) (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_161399 (h0 : ring (dlist linarith.ineq)) : strong_rank_condition (dlist linarith.ineq) := sorry --non-trivial
lemma new_lemma_161400 (h0 : function.extfun nat fin) : @add_monoid.fg.{1} (canonically_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (add_monoid.{1} (canonically_ordered_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_161401 (h0 : list (linear_ordered_comm_group unsigned)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_161402 (h0 : list (topological_space (has_top (has_top (has_nnnorm (random_gen linarith.comp_source)))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_161403 (h0 : functor.comp topological_space finset pos) : @t1_space.{0} (finset.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} finset.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_161404 (h0 : functor.add_const (topological_space (boolean_algebra.core unsigned)) pos) : @irreducible_space.{0} (boolean_algebra.core.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_161405 (h0 : add_group (non_unital_non_assoc_semiring (random_gen to_additive.value_type))) : is_add_cyclic (non_unital_non_assoc_semiring (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_161406 (h0 : functor.add_const (function.extfun (Type 1) topological_space) linarith.comp) : @totally_disconnected_space.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) linarith.comp h0) (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_161407 (h0 : functor.comp uniform_space has_neg Type) : @complete_space.{1} (has_neg.{1} Type) (@functor.comp.run.{1 1 1} uniform_space.{1} has_neg.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_161408 (h0 : group (add_cancel_monoid (has_add (has_add pos)))) : normalizer_condition (add_cancel_monoid (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_161409 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (has_bot.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_bot.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_161410 (h0 : set (has_lt (mul_one_class enat))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_161411 (h0 : topological_space (has_nndist Type)) : topological_space.separable_space (has_nndist Type) := sorry --non-trivial
lemma new_lemma_161412 (h0 : functor.add_const (uniform_space (add_comm_monoid Type)) (boolean_algebra name)) : @separated_space.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (add_comm_monoid.{1} Type)) (boolean_algebra.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_161413 (h0 : functor.add_const Prop (semigroup (option (option (option (option pos)))))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_161414 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (has_inter.{0} ennreal) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (has_inter.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_161415 (h0 : topological_space (mul_zero_class (finset (finset Type)))) : irreducible_space (mul_zero_class (finset (finset Type))) := sorry --non-trivial
lemma new_lemma_161416 (h0 : group (boolean_algebra (has_add unsigned))) : group.fg (boolean_algebra (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_161417 (h0 : finset (ordered_cancel_add_comm_monoid (option empty))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_161418 (h0 : functor.add_const (topological_space (ordered_ring congr_arg_kind)) unsigned) : @irreducible_space.{0} (ordered_ring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_161419 (h0 : semiring (add_cancel_monoid (has_nndist pos))) : is_noetherian_ring (add_cancel_monoid (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_161420 (h0 : group (has_zero (comm_group (comm_group Type)))) : normalizer_condition (has_zero (comm_group (comm_group Type))) := sorry --non-trivial
lemma new_lemma_161421 (h0 : ring (topological_space (random_gen (has_ssubset to_additive.value_type)))) : is_domain (topological_space (random_gen (has_ssubset to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_161422 (h0 : add_group (nondiscrete_normed_field enat)) : is_add_cyclic (nondiscrete_normed_field enat) := sorry --non-trivial
lemma new_lemma_161423 (h0 : functor.add_const (group (complete_distrib_lattice Type)) (ring pos)) : @is_simple_group.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (complete_distrib_lattice.{1} Type)) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_161424 (h0 : monoid (has_emptyc linarith.comp_source)) : monoid.fg (has_emptyc linarith.comp_source) := sorry --non-trivial
lemma new_lemma_161425 (h0 : topological_space (is_R_or_C num)) : totally_separated_space (is_R_or_C num) := sorry --non-trivial
lemma new_lemma_161426 (h0 : topological_space (mul_one_class (mul_one_class std_gen))) : path_connected_space (mul_one_class (mul_one_class std_gen)) := sorry --non-trivial
lemma new_lemma_161427 (h0 : functor.add_const (topological_space (has_neg_part pos)) ennreal) : @discrete_topology.{0} (has_neg_part.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} pos)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_161428 (h0 : ring (simple_graph linarith.comp)) : rank_condition (simple_graph linarith.comp) := sorry --non-trivial
lemma new_lemma_161429 (h0 : complete_lattice (denumerable (has_nnnorm linarith.comp_source))) : complete_lattice.is_Sup_finite_compact (denumerable (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_161430 (h1 : topological_space (has_nnnorm string.iterator_imp)) : path_connected_space (has_nnnorm string.iterator_imp) := sorry --non-trivial
lemma new_lemma_161431 (h0 : ring (linear_ordered_cancel_comm_monoid (option (option unsigned)))) : is_principal_ideal_ring (linear_ordered_cancel_comm_monoid (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_161432 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (add_group.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (add_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_161433 (h0 : ring (comm_ring (mul_one_class linarith.comp_source))) : rank_condition (comm_ring (mul_one_class linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_161434 (h0 : functor.comp topological_space finset environment.implicit_infer_kind) : @irreducible_space.{0} (finset.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} finset.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_161435 (h0 : monoid (option (semiring (semiring unsigned)))) : monoid.fg (option (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_161436 (h0 : topological_space (preorder (semiring num))) : topological_space.separable_space (preorder (semiring num)) := sorry --non-trivial
lemma new_lemma_161437 (h0 : ring (linear_ordered_add_comm_group (denumerable fun_info))) : rank_condition (linear_ordered_add_comm_group (denumerable fun_info)) := sorry --non-trivial
lemma new_lemma_161438 (h0 : ordered_add_comm_monoid (measurable_space.dynkin_system (semiring empty))) : archimedean (measurable_space.dynkin_system (semiring empty)) := sorry --non-trivial
lemma new_lemma_161439 (h0 : not (complete_lattice (has_inv linarith.comp_source) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_inv.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_inv.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_161440 (h0 : functor.add_const (complete_lattice (has_to_string ennreal)) pos) : @is_compactly_generated.{0} (has_to_string.{0} ennreal) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_to_string.{0} ennreal)) pos h0)  := sorry --non-trivial
lemma new_lemma_161441 (h1 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (with_bot.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (with_bot.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_161442 (h0 : preorder std_gen) (h1 : set std_gen) : set.is_pwo h1 := sorry --non-trivial
lemma new_lemma_161443 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (linear_ordered_comm_monoid_with_zero.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (linear_ordered_comm_monoid_with_zero.{0} empty))  := sorry --non-trivial
lemma new_lemma_161444 (h0 : functor.add_const (functor.add_const Prop empty) empty) : functor.add_const.run (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_161445 (h0 : linarith.comp_source -> linarith.comp_source -> Prop) : reflexive h0 := sorry --non-trivial
lemma new_lemma_161446 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (option.{0} num) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (option.{0} num))  := sorry --non-trivial
lemma new_lemma_161447 (h0 h1 : multiset (has_compl char)) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_161448 (h0 : add_monoid (has_nndist (boolean_algebra.core environment.implicit_infer_kind))) : add_monoid.fg (has_nndist (boolean_algebra.core environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_161449 (h0 : complete_lattice (cancel_monoid (option (option num)))) : is_atomistic (cancel_monoid (option (option num))) := sorry --non-trivial
lemma new_lemma_161450 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (ring unsigned)) := sorry --non-trivial
lemma new_lemma_161451 (h0 : function.extfun Type group) : @is_cyclic.{0} (canonically_ordered_comm_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (canonically_ordered_comm_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_161452 (h0 : functor.add_const (semiring (has_zero environment.implicit_infer_kind)) (ring name)) : @is_noetherian_ring.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (semiring.{0} (has_zero.{0} environment.implicit_infer_kind)) (ring.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_161453 (h1 : not (ring (has_append to_additive.value_type) -> false)) : @strong_rank_condition.{0} (has_append.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (has_append.{0} to_additive.value_type)) h1)  := sorry --non-trivial
lemma new_lemma_161454 (h0 : group (normed_linear_ordered_group congr_arg_kind)) : is_cyclic (normed_linear_ordered_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_161455 (h0 : functor.add_const (group (ring pos)) (has_neg name)) : @is_simple_group.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (ring.{0} pos)) (has_neg.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_161456 (h0 : ordered_add_comm_monoid (has_zero (has_add ennreal))) : archimedean (has_zero (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_161457 (h0 : complete_lattice (has_div linarith.ineq)) : is_compactly_generated (has_div linarith.ineq) := sorry --non-trivial
lemma new_lemma_161458 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} nnreal (@function.extfun_app.{2 1} Type add_group.{0} h0 nnreal)  := sorry --non-trivial
lemma new_lemma_161459 (h0 : functor.add_const (ring (complete_linear_order congr_arg_kind)) num) : @is_principal_ideal_ring.{0} (complete_linear_order.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ring.{0} (complete_linear_order.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_161460 (h0 : complete_lattice (has_norm fun_info)) : is_compactly_generated (has_norm fun_info) := sorry --non-trivial
lemma new_lemma_161461 (h0 : add_group (topological_space (has_nnnorm (has_nnnorm fun_info)))) : is_add_cyclic (topological_space (has_nnnorm (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_161462 (h0 : functor.add_const (group (complete_distrib_lattice environment.implicit_infer_kind)) linarith.comp) : @is_cyclic.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_161463 (h0 : functor.add_const (topological_space (has_zero unsigned)) environment.implicit_infer_kind) : @discrete_topology.{0} (has_zero.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_161464 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_Inf.{0} real) (@function.extfun_app.{2 1} Type group.{0} h0 (has_Inf.{0} real))  := sorry --non-trivial
lemma new_lemma_161465 (h0 : ring (has_neg_part (has_neg_part unsigned))) : is_domain (has_neg_part (has_neg_part unsigned)) := sorry --non-trivial
lemma new_lemma_161466 (h0 : complete_lattice (with_one (semiring unsigned))) : complete_lattice.is_Sup_finite_compact (with_one (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_161467 (h0 : add_group (normed_group (random_gen (linear_ordered_add_comm_group to_additive.value_type)))) : is_add_cyclic (normed_group (random_gen (linear_ordered_add_comm_group to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_161468 (h0 : functor.add_const (topological_space (comm_group linarith.comp)) name) : @totally_disconnected_space.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_161469 (h0 : topological_space (normed_group (option (option empty)))) : irreducible_space (normed_group (option (option empty))) := sorry --non-trivial
lemma new_lemma_161470 (h0 : functor.add_const (ordered_add_comm_monoid (semigroup unsigned)) unsigned) : @archimedean.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (semigroup.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_161471 (h0 : function.extfun (finset Type) (has_mem.mem (normed_group congr_arg_kind))) : @normalizer_condition.{0} (normed_group.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type group.{0} (normed_group.{0} congr_arg_kind) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (normed_group.{0} congr_arg_kind)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_161472 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (has_add.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_add.{0} name))  := sorry --non-trivial
lemma new_lemma_161473 (h0 : ring (add_cancel_comm_monoid (option (option (option unsigned))))) : strong_rank_condition (add_cancel_comm_monoid (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_161474 (h0 : set (set to_additive.value_type)) : is_countably_spanning h0 := sorry --non-trivial
lemma new_lemma_161475 (h0 : ring (has_to_string num)) : strong_rank_condition (has_to_string num) := sorry --non-trivial
lemma new_lemma_161476 (h0 : complete_lattice (has_scalar reducibility_hints linarith.comp_source)) : complete_lattice.is_Sup_finite_compact (has_scalar reducibility_hints linarith.comp_source) := sorry --non-trivial
lemma new_lemma_161477 (h0 : ordered_comm_monoid (has_neg_part (finset name))) : has_exists_mul_of_le (has_neg_part (finset name)) := sorry --non-trivial
lemma new_lemma_161478 (h0 : functor.add_const (finset (bin_tree unsigned)) num) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_161479 (h0 : add_group (has_bot name)) : is_add_cyclic (has_bot name) := sorry --non-trivial
lemma new_lemma_161480 (h1 : ring (semi_normed_ring char)) : strong_rank_condition (semi_normed_ring char) := sorry --non-trivial
lemma new_lemma_161481 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_161482 (h0 : functor.add_const (topological_space (mul_zero_class congr_arg_kind)) congr_arg_kind) : @preirreducible_space.{0} (mul_zero_class.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_161483 (h0 : function.extfun Type ring) : @is_domain.{0} (semiring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} h0 (semiring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_161484 (h0 : function.extfun Type ordered_add_comm_monoid) : archimedean rat := sorry --non-trivial
lemma new_lemma_161485 (h1 : ring (has_lt to_additive.value_type)) : strong_rank_condition (has_lt to_additive.value_type) := sorry --non-trivial
lemma new_lemma_161486 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} znum (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) znum)  := sorry --non-trivial
lemma new_lemma_161487 (h0 : function.extfun Type ring) : @is_domain.{0} (non_assoc_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (non_assoc_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_161488 (h0 : not (topological_space (normed_group empty) -> false)) : @preirreducible_space.{0} (normed_group.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_group.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_161489 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_compactly_generated.{0} (random_gen.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (random_gen.{0} num))  := sorry --non-trivial
lemma new_lemma_161490 (h0 : topological_space (distrib_lattice (random_gen string_imp))) : locally_compact_space (distrib_lattice (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_161491 (h0 : ordered_add_comm_monoid (has_edist (option unsigned))) : archimedean (has_edist (option unsigned)) := sorry --non-trivial
lemma new_lemma_161492 (h0 : ring (canonically_ordered_monoid (has_pos_part real))) : is_domain (canonically_ordered_monoid (has_pos_part real)) := sorry --non-trivial
lemma new_lemma_161493 (h0 : add_monoid (has_to_string environment.implicit_infer_kind)) : add_monoid.fg (has_to_string environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_161494 (h0 : functor.add_const (ring (ordered_comm_ring pos)) linarith.comp) : @is_principal_ideal_ring.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (ordered_comm_ring.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_161495 (h0 : ordered_add_comm_monoid (boolean_algebra.core (has_add (ring linarith.comp)))) : archimedean (boolean_algebra.core (has_add (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_161496 (h0 : semiring (metric_space unsigned)) : is_noetherian_ring (metric_space unsigned) := sorry --non-trivial
lemma new_lemma_161497 (h0 : functor.add_const (filter (boolean_algebra pos)) pos) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_161498 (h0 : functor.add_const (function.extfun (Type 1) filter) pos) : filter.ne_bot (function.extfun_app (functor.add_const.run h0) (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_161499 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (random_gen.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (random_gen.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_161500 (h0 : add_group (denumerable (comm_ring (random_gen to_additive.value_type)))) : is_add_cyclic (denumerable (comm_ring (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_161501 (h1 : has_neg (normed_field std_gen)) (h2 : measurable_space (normed_field std_gen)) : has_measurable_neg (normed_field std_gen) := sorry --non-trivial
lemma new_lemma_161502 (h0 : topological_space (linear_ordered_comm_group ennreal)) : topological_space.separable_space (linear_ordered_comm_group ennreal) := sorry --non-trivial
lemma new_lemma_161503 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (pseudo_metric_space.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (pseudo_metric_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_161504 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (complete_distrib_lattice name)) := sorry --non-trivial
lemma new_lemma_161505 (h0 : ring (random_gen (semiring congr_arg_kind))) : is_domain (random_gen (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_161506 (h0 : function.extfun (finset (Type 1 -> Type 1)) (has_mem.mem topological_space)) : @totally_separated_space.{1} Type (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@finset.pi.empty.{2 2} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) topological_space.{1} (@function.extfun_app.{3 0} (finset.{2} (Type 1 → Type 1)) (@has_mem.mem.{2 2} (Type 1 → Type 1) (finset.{2} (Type 1 → Type 1)) (@finset.has_mem.{2} (Type 1 → Type 1)) topological_space.{1}) h0 (@has_emptyc.emptyc.{2} (finset.{2} (Type 1 → Type 1)) (@finset.has_emptyc.{2} (Type 1 → Type 1))))) Type)  := sorry --non-trivial
lemma new_lemma_161507 (h0 : group (has_emptyc empty)) : group.fg (has_emptyc empty) := sorry --non-trivial
lemma new_lemma_161508 (h0 : ring (boolean_algebra (has_to_string name))) : rank_condition (boolean_algebra (has_to_string name)) := sorry --non-trivial
lemma new_lemma_161509 (h0 : function.extfun Type (functor.add_const (topological_space (left_cancel_monoid empty)))) : @normal_space.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (left_cancel_monoid.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_161510 (h0 : has_lt (partial_order (normed_linear_ordered_field (mul_one_class string.iterator_imp)))) : no_max_order (partial_order (normed_linear_ordered_field (mul_one_class string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_161511 (h0 : ring (has_nndist (has_to_string unsigned))) : rank_condition (has_nndist (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_161512 (h0 : complete_lattice (has_to_string (has_to_string ennreal))) : is_compactly_generated (has_to_string (has_to_string ennreal)) := sorry --non-trivial
lemma new_lemma_161513 (h0 : ring (has_zero (has_neg (option pos)))) : is_domain (has_zero (has_neg (option pos))) := sorry --non-trivial
lemma new_lemma_161514 (h0 : complete_lattice (semiring (has_top (random_gen (has_top to_additive.value_type))))) : is_compactly_generated (semiring (has_top (random_gen (has_top to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_161515 (h0 : topological_space (normed_comm_ring (has_nndist (option pos)))) : totally_disconnected_space (normed_comm_ring (has_nndist (option pos))) := sorry --non-trivial
lemma new_lemma_161516 (h1 : uniform_space empty) : complete_space empty := sorry --non-trivial
lemma new_lemma_161517 (h0 : functor.add_const (ring (semigroup linarith.comp)) (finset (finset (finset linarith.comp)))) : @rank_condition.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (semigroup.{0} linarith.comp)) (finset.{0} (finset.{0} (finset.{0} linarith.comp))) h0)  := sorry --non-trivial
lemma new_lemma_161518 (h0 : add_monoid (complete_linear_order (semiring (semiring (semiring (semiring unsigned)))))) : add_monoid.fg (complete_linear_order (semiring (semiring (semiring (semiring unsigned))))) := sorry --non-trivial
lemma new_lemma_161519 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @sequential_space.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_161520 (h0 : not (has_mem.mem (id linarith.comp) has_emptyc.emptyc -> false)) : @totally_disconnected_space.{0} (@id.{2} Type linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (@id.{2} Type linarith.comp) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (@id.{2} Type linarith.comp) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_161521 (h0 : topological_space (ordered_comm_ring (ring Type))) : irreducible_space (ordered_comm_ring (ring Type)) := sorry --non-trivial
lemma new_lemma_161522 (h0 : complete_lattice (add_left_cancel_monoid (has_nnnorm linarith.ineq))) : complete_lattice.is_Sup_finite_compact (add_left_cancel_monoid (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_161523 (h0 : set (fun_info -> string.iterator_imp)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_161524 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @is_simple_group.{0} (has_bot.{0} pos) (@matrix.vec_empty.{0} (group.{0} (has_bot.{0} pos)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_161525 (h0 : topological_space (complete_linear_order (semiring congr_arg_kind))) : t1_space (complete_linear_order (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_161526 (h0 : group (option (semiring congr_arg_kind))) : is_cyclic (option (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_161527 (h0 : functor.add_const (topological_space (plift num)) num) : @totally_disconnected_space.{1} (plift.{1} num) (@functor.add_const.run.{1 0} (topological_space.{1} (plift.{1} num)) num h0)  := sorry --non-trivial
lemma new_lemma_161528 (h0 : group (has_norm (random_gen (has_union fun_info)))) : group.fg (has_norm (random_gen (has_union fun_info))) := sorry --non-trivial
lemma new_lemma_161529 (h1 : semiring (nondiscrete_normed_field char)) (h2 : nondiscrete_normed_field char) : even h2 := sorry --non-trivial
lemma new_lemma_161530 (h0 : ring (has_neg_part (has_add pos))) : strong_rank_condition (has_neg_part (has_add pos)) := sorry --non-trivial
lemma new_lemma_161531 (h0 : not (topological_space (normed_group linarith.ineq) -> false)) : @t0_space.{0} (normed_group.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_group.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_161532 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_group.{0} h0 (semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_161533 (h1 : topological_space real.angle) : t0_space real.angle := sorry --non-trivial
lemma new_lemma_161534 (h0 : add_monoid (finset (has_neg (ring (has_neg linarith.comp))))) : add_monoid.fg (finset (has_neg (ring (has_neg linarith.comp)))) := sorry --non-trivial
lemma new_lemma_161535 (h0 : functor.add_const (group (plift empty)) num) : @group.fg.{1} (plift.{1} empty) (@functor.add_const.run.{1 0} (group.{1} (plift.{1} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_161536 (h0 : functor.add_const (topological_space (add_cancel_monoid linarith.comp)) pos) : @totally_separated_space.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_161537 (h0 : functor.add_const (functor.add_const (group (has_to_string linarith.comp)) pos) (has_neg pos)) : @group.fg.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (has_to_string.{0} linarith.comp)) pos (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (group.{0} (has_to_string.{0} linarith.comp)) pos) (has_neg.{0} pos) h0))  := sorry --non-trivial
lemma new_lemma_161538 (h0 : function.extfun Type group) : @normalizer_condition.{0} (linear_ordered_comm_ring.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (linear_ordered_comm_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_161539 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (left_cancel_semigroup.{0} empty) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (left_cancel_semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_161540 (h0 : topological_space (mul_zero_class ennreal)) : topological_space.separable_space (mul_zero_class ennreal) := sorry --non-trivial
lemma new_lemma_161541 (h0 : group (add_cancel_monoid (has_zero (has_Inf pos)))) : normalizer_condition (add_cancel_monoid (has_zero (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_161542 (h0 : functor.add_const (ring (ring Type)) name) : @strong_rank_condition.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (ring.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_161543 (h0 : ring (finset (has_add Type))) : strong_rank_condition (finset (has_add Type)) := sorry --non-trivial
lemma new_lemma_161544 (h0 : functor.add_const (function.extfun Type topological_space) (finset Type)) : @preconnected_space.{0} (ordered_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) (finset.{1} Type) h0) (ordered_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_161545 (h0 : ring (has_compl (has_nnnorm (has_inv fun_info)))) : rank_condition (has_compl (has_nnnorm (has_inv fun_info))) := sorry --non-trivial
lemma new_lemma_161546 (h0 : topological_space (with_one (semiring linarith.ineq))) : discrete_topology (with_one (semiring linarith.ineq)) := sorry --non-trivial
lemma new_lemma_161547 (h0 : functor.add_const (topological_space pos) name) : @preconnected_space.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) name h0)  := sorry --non-trivial
lemma new_lemma_161548 (h0 : functor.add_const (uniform_space (add_group congr_arg_kind)) congr_arg_kind) : @complete_space.{0} (add_group.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (uniform_space.{0} (add_group.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_161549 (h0 : functor.add_const (function.extfun Type semiring) pos) : @is_noetherian_ring.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type semiring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type semiring.{0}) pos h0) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_161550 (h0 : add_group (has_one empty)) : is_add_cyclic (has_one empty) := sorry --non-trivial
lemma new_lemma_161551 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (add_comm_monoid name)) := sorry --non-trivial
lemma new_lemma_161552 (h0 : function.extfun Type (functor.add_const Prop)) : functor.add_const.run (function.extfun_app h0 (ordered_comm_ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_161553 (h0 : fin has_zero.zero) : matrix.vec_empty (matrix.vec_empty (id (id (id h0)))) := sorry --non-trivial
lemma new_lemma_161554 (h2 h3 : multiset linarith.comp_source) : multiset.subset h2 h3 := sorry --non-trivial
lemma new_lemma_161555 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (linear_ordered_semiring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_161556 (h0 : complete_lattice (cancel_monoid congr_arg_kind)) : is_atomistic (cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_161557 (h0 : uniform_space (complete_semilattice_Sup (has_top (has_top (has_top linarith.comp_source))))) : complete_space (complete_semilattice_Sup (has_top (has_top (has_top linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_161558 (h0 : ring (linear_ordered_add_comm_group fun_info)) : strong_rank_condition (linear_ordered_add_comm_group fun_info) := sorry --non-trivial
lemma new_lemma_161559 (h3 : ring (has_div to_additive.value_type)) : rank_condition (has_div to_additive.value_type) := sorry --non-trivial
lemma new_lemma_161560 (h0 : functor.add_const (topological_space (has_neg linarith.comp)) name) : @totally_separated_space.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_161561 (h0 : topological_space (has_add congr_arg_kind)) : loc_path_connected_space (has_add congr_arg_kind) := sorry --non-trivial
lemma new_lemma_161562 (h0 : topological_space (has_neg (has_add name))) : path_connected_space (has_neg (has_add name)) := sorry --non-trivial
lemma new_lemma_161563 (h0 : functor.add_const (complete_lattice (normed_comm_ring ennreal)) Type) : @is_atomistic.{0} (normed_comm_ring.{0} ennreal) (@functor.add_const.run.{0 1} (complete_lattice.{0} (normed_comm_ring.{0} ennreal)) Type h0)  := sorry --non-trivial
lemma new_lemma_161564 (h0 : function.extfun (Type 1) topological_space) : @locally_compact_space.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_161565 (h0 : functor.add_const (topological_space (normed_lattice_add_comm_group linarith.comp)) name) : @t0_space.{0} (normed_lattice_add_comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_lattice_add_comm_group.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_161566 (h0 : ring (cancel_monoid congr_arg_kind)) : strong_rank_condition (cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_161567 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (has_ssubset (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_161568 (h0 : function.extfun nat fin) : @preirreducible_space.{1} (canonically_linear_ordered_add_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (canonically_linear_ordered_add_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_161569 (h0 : topological_space (measurable_space (has_norm linarith.ineq))) : totally_disconnected_space (measurable_space (has_norm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_161570 (h0 : function.extfun Type (functor.add_const (topological_space Type))) : @topological_space.separable_space.{1} Type (@functor.add_const.run.{1 0} (topological_space.{1} Type) pos (@function.extfun_app.{2 2} Type (functor.add_const.{1 0} (topological_space.{1} Type)) h0 pos))  := sorry --non-trivial
lemma new_lemma_161571 (h0 : function.extfun Type (functor.add_const (functor.add_const Prop ennreal))) : functor.add_const.run (functor.add_const.run (function.extfun_app h0 empty)) := sorry --non-trivial
lemma new_lemma_161572 (h0 : topological_space (has_compl (random_gen string_imp))) : t0_space (has_compl (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_161573 (h0 : function.extfun (has_top linarith.comp_source -> Type) (function.extfun (has_top linarith.comp_source))) : Exists (function.extfun_app (function.extfun_app h0 (fun (x : has_top linarith.comp_source), Prop))) := sorry --non-trivial
lemma new_lemma_161574 (h0 : not (ring (non_unital_non_assoc_semiring string_imp) -> false)) : @is_domain.{0} (non_unital_non_assoc_semiring.{0} string_imp) (@classical.by_contradiction'.{1} (ring.{0} (non_unital_non_assoc_semiring.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_161575 (h0 : prod (plift (free_add_monoid unsigned)) (plift (free_add_monoid unsigned))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_161576 (h0 : topological_space (canonically_ordered_monoid name)) : loc_path_connected_space (canonically_ordered_monoid name) := sorry --non-trivial
lemma new_lemma_161577 (h0 : prod (finset (option empty)) (finset (option empty))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_161578 (h0 : functor.add_const (add_group (has_neg Type)) environment.implicit_infer_kind) : @is_add_cyclic.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (add_group.{1} (has_neg.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_161579 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (metric_space.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (metric_space.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_161580 (h0 : topological_space (has_nndist (option (option (option unsigned))))) : totally_disconnected_space (has_nndist (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_161581 (h0 : functor.add_const (complete_lattice (pseudo_metric_space unsigned)) name) : @complete_lattice.is_Sup_finite_compact.{0} (pseudo_metric_space.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (pseudo_metric_space.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_161582 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} congr_arg_kind (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_161583 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (ring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_161584 (h0 : topological_space (bin_tree empty)) : path_connected_space (bin_tree empty) := sorry --non-trivial
lemma new_lemma_161585 (h0 : functor.add_const (ordered_comm_monoid (cancel_monoid unsigned)) (has_add unsigned)) : @has_exists_mul_of_le.{0} (cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (cancel_monoid.{0} unsigned)) (has_add.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_161586 (h0 : group (add_comm_monoid (option empty))) : is_cyclic (add_comm_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_161587 (h0 : fin has_zero.zero) : @separated_space.{0} (complete_distrib_lattice.{0} real) (@matrix.vec_empty.{0} (uniform_space.{0} (complete_distrib_lattice.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_161588 (h0 : functor.add_const Prop (measure_theory.measure_space empty)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_161589 (h0 : filter (ordered_comm_monoid (ring Type))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_161590 (h0 : add_group (simple_graph std_gen)) : is_add_cyclic (simple_graph std_gen) := sorry --non-trivial
lemma new_lemma_161591 (h1 : group (metric_space (denumerable reducibility_hints))) : is_cyclic (metric_space (denumerable reducibility_hints)) := sorry --non-trivial
lemma new_lemma_161592 (h0 : functor.add_const (topological_space (normed_comm_ring pos)) (has_add Type)) : @locally_compact_space.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (normed_comm_ring.{0} pos)) (has_add.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_161593 (h0 : functor.comp topological_space finset Type) : @irreducible_space.{1} (finset.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} finset.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_161594 (h0 : topological_space (semigroup environment.implicit_infer_kind)) : loc_path_connected_space (semigroup environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_161595 (h0 : not (function.extfun Type topological_space -> false)) : @irreducible_space.{0} (has_top.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_top.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_161596 (h0 : function.extfun Type (functor.add_const (group (has_inter ennreal)))) : @is_simple_group.{0} (has_inter.{0} ennreal) (@functor.add_const.run.{0 0} (group.{0} (has_inter.{0} ennreal)) (option.{0} ennreal) (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (group.{0} (has_inter.{0} ennreal))) h0 (option.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_161597 (h0 : ring (mul_one_class string.iterator_imp)) : strong_rank_condition (mul_one_class string.iterator_imp) := sorry --non-trivial
lemma new_lemma_161598 (h0 : group (comm_ring fun_info)) : group.fg (comm_ring fun_info) := sorry --non-trivial
lemma new_lemma_161599 (h0 : functor.add_const (group (ring Type)) (has_add (ring pos))) : @normalizer_condition.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (ring.{1} Type)) (has_add.{0} (ring.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_161600 (h0 : topological_space (has_ssubset (random_gen linarith.ineq))) : totally_disconnected_space (has_ssubset (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_161601 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (ordered_comm_monoid real)) := sorry --non-trivial
lemma new_lemma_161602 (h0 : function.extfun Type topological_space) : @regular_space.{0} (comm_group.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_group.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_161603 (h1 : not (group (normed_field string_imp) -> false)) : @is_cyclic.{0} (normed_field.{0} string_imp) (@classical.by_contradiction'.{1} (group.{0} (normed_field.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_161604 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (random_gen.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (random_gen.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_161605 (h0 : topological_space (ordered_comm_ring (has_neg name))) : totally_separated_space (ordered_comm_ring (has_neg name)) := sorry --non-trivial
lemma new_lemma_161606 (h0 : topological_space (mul_one_class reducibility_hints)) (h1 : add_group (mul_one_class reducibility_hints)) : topological_add_group (mul_one_class reducibility_hints) := sorry --non-trivial
lemma new_lemma_161607 (h0 : functor.add_const (group (semigroup Type)) Type) : @group.fg.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 1} (group.{1} (semigroup.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_161608 (h0 : functor.add_const (topological_space (preorder unsigned)) unsigned) : @totally_separated_space.{0} (preorder.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (preorder.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_161609 (h0 : not (semiring (linear_ordered_semiring empty) -> false)) : @is_noetherian_ring.{0} (linear_ordered_semiring.{0} empty) (@classical.by_contradiction'.{1} (semiring.{0} (linear_ordered_semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_161610 (h0 : list (has_neg (option pos))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_161611 (h0 : functor.add_const (function.extfun (Type 1) filter) (ring pos)) : filter.ne_bot (function.extfun_app (functor.add_const.run h0) Type) := sorry --non-trivial
lemma new_lemma_161612 (h1 : set (mul_one_class fun_info)) : set.finite h1 := sorry --non-trivial
lemma new_lemma_161613 (h0 : topological_space (filter (option unsigned))) : discrete_topology (filter (option unsigned)) := sorry --non-trivial
lemma new_lemma_161614 (h0 : functor.add_const (list (finset environment.implicit_infer_kind)) linarith.comp) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_161615 (h0 : functor.add_const (monoid (ring pos)) pos) : @monoid.fg.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (monoid.{0} (ring.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_161616 (h0 : functor.add_const (ring (boolean_algebra.core unsigned)) linarith.comp) : @strong_rank_condition.{0} (boolean_algebra.core.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.core.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_161617 (h0 : topological_space (has_pos_part real)) : t1_space (has_pos_part real) := sorry --non-trivial
lemma new_lemma_161618 (h0 : add_monoid (normed_lattice_add_comm_group pos)) : add_monoid.fg (normed_lattice_add_comm_group pos) := sorry --non-trivial
lemma new_lemma_161619 (h0 : ring (linear_ordered_add_comm_group (random_gen (random_gen char)))) : rank_condition (linear_ordered_add_comm_group (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_161620 (h0 : functor.add_const (topological_space (has_add name)) environment.implicit_infer_kind) : @normal_space.{0} (has_add.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_161621 (h0 : functor.add_const (topological_space (ordered_comm_ring pos)) (has_add Type)) : @totally_separated_space.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (ordered_comm_ring.{0} pos)) (has_add.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_161622 (h0 : topological_space char) (h1 : not (preorder char -> false)) : order_closed_topology char := sorry --non-trivial
lemma new_lemma_161623 (h0 : functor.add_const (topological_space (add_cancel_comm_monoid empty)) congr_arg_kind) : @discrete_topology.{0} (add_cancel_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_comm_monoid.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_161624 (h0 : topological_space (non_unital_non_assoc_semiring (mul_one_class std_gen))) : t0_space (non_unital_non_assoc_semiring (mul_one_class std_gen)) := sorry --non-trivial
lemma new_lemma_161625 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_compactly_generated.{1} (has_zero.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 complete_lattice.{1}) (has_zero.{1} Type))  := sorry --non-trivial
lemma new_lemma_161626 (h0 : list (complete_semilattice_Sup (has_norm to_additive.value_type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_161627 (h0 : filter (has_nndist environment.implicit_infer_kind)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_161628 (h0 : uniform_space (has_nndist (has_neg linarith.comp))) : separated_space (has_nndist (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_161629 (h0 : group (has_emptyc (random_gen num))) : normalizer_condition (has_emptyc (random_gen num)) := sorry --non-trivial
lemma new_lemma_161630 (h0 : functor.add_const (function.extfun Type ring) pos) : @is_principal_ideal_ring.{0} (ordered_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) pos h0) (ordered_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_161631 (h0 : enat -> enat -> Prop) (h2 : filter enat) : filter.is_bounded h0 h2 := sorry --non-trivial
lemma new_lemma_161632 (h0 : ring (complete_distrib_lattice ennreal)) : is_domain (complete_distrib_lattice ennreal) := sorry --non-trivial
lemma new_lemma_161633 (h1 : topological_space (add_comm_semigroup (add_comm_semigroup ereal))) : locally_compact_space (add_comm_semigroup (add_comm_semigroup ereal)) := sorry --non-trivial
lemma new_lemma_161634 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_inter.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inter.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_161635 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @sequential_space.{0} (ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_161636 (h0 : with_bot (fin has_zero.zero)) (h1 : ne h0 has_bot.bot) : matrix.vec_empty (matrix.vec_empty (with_bot.unbot h0 h1)) := sorry --non-trivial
lemma new_lemma_161637 (h0 : functor.add_const (functor.add_const (add_monoid pos) pos) linarith.comp) : @add_monoid.fg.{0} pos (@functor.add_const.run.{0 0} (add_monoid.{0} pos) pos (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (add_monoid.{0} pos) pos) linarith.comp h0))  := sorry --non-trivial
lemma new_lemma_161638 (h0 : functor.add_const (group (add_semigroup empty)) empty) : @is_cyclic.{0} (add_semigroup.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (add_semigroup.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_161639 (h0 : group (complete_semilattice_Sup (semiring (semiring (semiring congr_arg_kind))))) : group.fg (complete_semilattice_Sup (semiring (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_161640 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} (has_zero.{0} name) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) (has_zero.{0} name))  := sorry --non-trivial
lemma new_lemma_161641 (h0 : add_group (semi_normed_ring std_gen)) : is_add_cyclic (semi_normed_ring std_gen) := sorry --non-trivial
lemma new_lemma_161642 (h0 : topological_space (has_neg (finset (finset (finset pos))))) : totally_disconnected_space (has_neg (finset (finset (finset pos)))) := sorry --non-trivial
lemma new_lemma_161643 (h0 : not (filter (measure_theory.measure_space empty) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_161644 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (complete_distrib_lattice.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_distrib_lattice.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_161645 (h0 : add_group (has_nnnorm (mul_one_class (normed_field linarith.ineq)))) : is_add_cyclic (has_nnnorm (mul_one_class (normed_field linarith.ineq))) := sorry --non-trivial
lemma new_lemma_161646 (h0 : function.extfun (finset Type) (has_mem.mem linarith.comp)) : @is_cyclic.{0} linarith.comp (@finset.pi.empty.{1 0} Type group.{0} linarith.comp (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) linarith.comp) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_161647 (h0 : uniform_space (has_zero name)) : complete_space (has_zero name) := sorry --non-trivial
lemma new_lemma_161648 (h0 : has_mem.mem (id (semiring empty)) has_emptyc.emptyc) : @discrete_topology.{0} (@id.{2} Type (semiring.{0} empty)) (@finset.pi.empty.{1 0} Type topological_space.{0} (@id.{2} Type (semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_161649 (h0 : complete_lattice (linear_ordered_semiring (semiring (semiring (semiring empty))))) : is_compactly_generated (linear_ordered_semiring (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_161650 (h0 : functor.add_const (ring (left_cancel_monoid num)) congr_arg_kind) : @is_principal_ideal_ring.{0} (left_cancel_monoid.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (left_cancel_monoid.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_161651 (h1 : topological_space (normed_field (random_gen char))) : t0_space (normed_field (random_gen char)) := sorry --non-trivial
lemma new_lemma_161652 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @totally_disconnected_space.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_161653 (h0 : topological_space (has_zero (comm_group unsigned))) : sequential_space (has_zero (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_161654 (h0 : ring (random_gen string.iterator_imp)) : rank_condition (random_gen string.iterator_imp) := sorry --non-trivial
lemma new_lemma_161655 (h1 : topological_space (comm_ring (has_ssubset (has_ssubset char)))) : path_connected_space (comm_ring (has_ssubset (has_ssubset char))) := sorry --non-trivial
lemma new_lemma_161656 (h0 : complete_lattice (boolean_algebra.core (option name))) : is_compactly_generated (boolean_algebra.core (option name)) := sorry --non-trivial
lemma new_lemma_161657 (h0 : set (char -> char)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_161658 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (ordered_comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} h0 (ordered_comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_161659 (h0 : functor.add_const (topological_space (simple_graph pos)) pos) : @t1_space.{0} (simple_graph.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (simple_graph.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_161660 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem ring)) : @strong_rank_condition.{0} (has_emptyc.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) ring.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_emptyc.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_161661 (h0 : ring (complete_distrib_lattice congr_arg_kind)) : strong_rank_condition (complete_distrib_lattice congr_arg_kind) := sorry --non-trivial
lemma new_lemma_161662 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (semilattice_inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semilattice_inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_161663 (h0 : filter (has_zero (has_neg_part pos))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_161664 (h0 : semiring (comm_group (has_to_string (has_to_string (has_to_string unsigned))))) : is_noetherian_ring (comm_group (has_to_string (has_to_string (has_to_string unsigned)))) := sorry --non-trivial
lemma new_lemma_161665 (h0 : topological_space (has_dist (option ennreal))) : totally_disconnected_space (has_dist (option ennreal)) := sorry --non-trivial
lemma new_lemma_161666 (h0 : not (function.extfun Type topological_space -> false)) : @totally_separated_space.{0} (has_emptyc.{0} (has_top.{0} (random_gen.{0} (has_inv.{0} (has_inv.{0} linarith.comp_source))))) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_emptyc.{0} (has_top.{0} (random_gen.{0} (has_inv.{0} (has_inv.{0} linarith.comp_source))))))  := sorry --non-trivial
lemma new_lemma_161667 (h0 : uniform_space (has_norm to_additive.value_type)) : complete_space (has_norm to_additive.value_type) := sorry --non-trivial
lemma new_lemma_161668 (h1 : topological_space (with_bot linarith.ineq)) : locally_compact_space (with_bot linarith.ineq) := sorry --non-trivial
lemma new_lemma_161669 (h0 : functor.add_const (function.extfun Type ring) name) : @strong_rank_condition.{0} (has_nndist.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) name h0) (has_nndist.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_161670 (h0 : topological_space (with_bot (semiring congr_arg_kind))) : preirreducible_space (with_bot (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_161671 (h0 : topological_space (has_neg_part (comm_group (has_add Type)))) : t0_space (has_neg_part (comm_group (has_add Type))) := sorry --non-trivial
lemma new_lemma_161672 (h0 : functor.add_const (filter (comm_group pos)) Type) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_161673 (h0 : functor.add_const (add_group (boolean_algebra.core Type)) (boolean_algebra.core pos)) : @is_add_cyclic.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (add_group.{1} (boolean_algebra.core.{1} Type)) (boolean_algebra.core.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_161674 (h0 : topological_space (has_nndist (finset (finset (finset environment.implicit_infer_kind))))) : t1_space (has_nndist (finset (finset (finset environment.implicit_infer_kind)))) := sorry --non-trivial
lemma new_lemma_161675 (h0 : group (semigroup (has_add (has_add Type)))) : group.fg (semigroup (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_161676 (h0 : topological_space (has_add (ring linarith.comp))) : normal_space (has_add (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_161677 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_dist.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_dist.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_161678 (h0 : semiring (ordered_comm_monoid (boolean_algebra.core (boolean_algebra.core (has_add pos))))) : is_noetherian_ring (ordered_comm_monoid (boolean_algebra.core (boolean_algebra.core (has_add pos)))) := sorry --non-trivial
lemma new_lemma_161679 (h0 : set (set (linear_ordered_comm_group_with_zero environment.projection_info))) (h1 : set (linear_ordered_comm_group_with_zero environment.projection_info)) : measurable_space.dynkin_system.generate_has h0 h1 := sorry --non-trivial
lemma new_lemma_161680 (h0 : topological_space (has_add name)) : totally_separated_space (has_add name) := sorry --non-trivial
lemma new_lemma_161681 (h0 : functor.add_const (topological_space (with_bot num)) (semiring num)) : @locally_compact_space.{0} (with_bot.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (with_bot.{0} num)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_161682 (h0 : topological_space (linear_ordered_field (option unsigned))) : t1_space (linear_ordered_field (option unsigned)) := sorry --non-trivial
lemma new_lemma_161683 (h0 : topological_space (add_comm_monoid (finset (finset (finset (finset (finset (finset linarith.comp)))))))) : regular_space (add_comm_monoid (finset (finset (finset (finset (finset (finset linarith.comp))))))) := sorry --non-trivial
lemma new_lemma_161684 (h1 : has_coe (non_unital_non_assoc_semiring string.iterator_imp) Prop) (h2 : non_unital_non_assoc_semiring string.iterator_imp) : @coe_b.{1 1} (non_unital_non_assoc_semiring.{0} string.iterator_imp) Prop h1 h2  := sorry --non-trivial
lemma new_lemma_161685 (h0 : ring (has_to_string (option (option ennreal))) -> ring (has_to_string (option (option ennreal))) -> Prop) : is_symm (ring (has_to_string (option (option ennreal)))) h0 := sorry --non-trivial
lemma new_lemma_161686 (h0 : topological_space (add_group (has_norm unsigned))) : t0_space (add_group (has_norm unsigned)) := sorry --non-trivial
lemma new_lemma_161687 (h0 : ring (finset (has_Inf (ring linarith.comp)))) : strong_rank_condition (finset (has_Inf (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_161688 (h1 : monoid (has_emptyc linarith.ineq)) : monoid.fg (has_emptyc linarith.ineq) := sorry --non-trivial
lemma new_lemma_161689 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} pos (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) pos)  := sorry --non-trivial
lemma new_lemma_161690 (h0 : functor.add_const (topological_space (left_cancel_monoid congr_arg_kind)) empty) : @discrete_topology.{0} (left_cancel_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_161691 (h0 : fin has_zero.zero) : @normalizer_condition.{0} (ordered_comm_monoid.{0} real) (@matrix.vec_empty.{0} (group.{0} (ordered_comm_monoid.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_161692 (h1 : complete_lattice (add_cancel_comm_monoid to_additive.value_type)) : complete_lattice.is_Sup_finite_compact (add_cancel_comm_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_161693 (h0 : function.extfun Type (functor.comp topological_space add_comm_monoid)) : @locally_compact_space.{0} (add_comm_monoid.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} add_comm_monoid.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} add_comm_monoid.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_161694 (h0 : group (with_one to_additive.value_type)) : is_cyclic (with_one to_additive.value_type) := sorry --non-trivial
lemma new_lemma_161695 (h0 : has_lt (simple_graph environment.projection_info)) : no_max_order (simple_graph environment.projection_info) := sorry --non-trivial
lemma new_lemma_161696 (h0 : topological_space (has_bot Type)) : topological_space.separable_space (has_bot Type) := sorry --non-trivial
lemma new_lemma_161697 (h0 : not (complete_lattice (complete_linear_order num) -> false)) : @is_compactly_generated.{0} (complete_linear_order.{0} num) (@classical.by_contradiction'.{1} (complete_lattice.{0} (complete_linear_order.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_161698 (h0 : functor.add_const (monoid (has_add linarith.comp)) name) : @monoid.fg.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (monoid.{0} (has_add.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_161699 (h0 : topological_space (has_bot (has_neg (has_neg (has_neg pos))))) : locally_compact_space (has_bot (has_neg (has_neg (has_neg pos)))) := sorry --non-trivial
lemma new_lemma_161700 (h0 : function.extfun Type (functor.add_const (topological_space (linear_ordered_comm_monoid_with_zero empty)))) : @discrete_topology.{0} (linear_ordered_comm_monoid_with_zero.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_comm_monoid_with_zero.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (linear_ordered_comm_monoid_with_zero.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_161701 (h0 : functor.comp group has_nndist name) : @group.fg.{0} (has_nndist.{0} name) (@functor.comp.run.{0 0 0} group.{0} has_nndist.{0} name (@functor.comp.run.{0 0 0} group.{0} has_nndist.{0} name (@functor.comp.run.{0 0 0} group.{0} has_nndist.{0} name (@functor.comp.run.{0 0 0} group.{0} has_nndist.{0} name h0))))  := sorry --non-trivial
lemma new_lemma_161702 (h0 : group (has_emptyc (has_top fun_info))) : normalizer_condition (has_emptyc (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_161703 (h0 : not (ring (distrib_lattice string_imp) -> false)) : @is_domain.{0} (distrib_lattice.{0} string_imp) (@classical.by_contradiction'.{1} (ring.{0} (distrib_lattice.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_161704 (h0 : topological_space (complete_distrib_lattice (has_Inf linarith.comp))) : preirreducible_space (complete_distrib_lattice (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_161705 (h0 : topological_space (has_emptyc (has_norm fun_info))) : t0_space (has_emptyc (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_161706 (h0 : group (ordered_comm_ring (has_add (finset (boolean_algebra.core pos))))) : normalizer_condition (ordered_comm_ring (has_add (finset (boolean_algebra.core pos)))) := sorry --non-trivial
lemma new_lemma_161707 (h0 : monoid (add_cancel_monoid name)) : monoid.fg (add_cancel_monoid name) := sorry --non-trivial
lemma new_lemma_161708 (h0 : uniform_space (dlist (has_nnnorm (has_nnnorm fun_info)))) : complete_space (dlist (has_nnnorm (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_161709 : not punit := sorry --non-trivial
lemma new_lemma_161710 (h0 : topological_space (has_one (has_emptyc num))) : t0_space (has_one (has_emptyc num)) := sorry --non-trivial
lemma new_lemma_161711 (h0 : function.extfun Type (functor.comp topological_space semigroup)) : @preconnected_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} environment.implicit_infer_kind (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} semigroup.{0}) h0 environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_161712 (h0 : ring (ordered_comm_monoid (has_neg (has_neg name)))) : strong_rank_condition (ordered_comm_monoid (has_neg (has_neg name))) := sorry --non-trivial
lemma new_lemma_161713 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (add_right_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_right_cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_161714 (h0 : ring (has_star (semiring (semiring unsigned)))) : strong_rank_condition (has_star (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_161715 (h0 : ring (random_gen (semiring linarith.comp))) : strong_rank_condition (random_gen (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_161716 (h0 : filter (partial_order (semiring congr_arg_kind))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_161717 (h1 : add_group (linear_ordered_comm_group_with_zero std_gen)) : is_add_cyclic (linear_ordered_comm_group_with_zero std_gen) := sorry --non-trivial
lemma new_lemma_161718 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_161719 (h0 : group (semigroup (has_add (has_add Type)))) : is_simple_group (semigroup (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_161720 (h0 : fin has_zero.zero) : @is_cyclic.{0} (comm_semigroup.{0} name) (@matrix.vec_empty.{0} (group.{0} (comm_semigroup.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_161721 (h0 : topological_space (has_nndist (finset (finset pos)))) : t1_space (has_nndist (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_161722 (h0 : topological_space (has_Inf real)) : normal_space (has_Inf real) := sorry --non-trivial
lemma new_lemma_161723 (h0 : complete_lattice (has_zero (option name))) : is_compactly_generated (has_zero (option name)) := sorry --non-trivial
lemma new_lemma_161724 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (linear_ordered_field.{0} num) (@function.extfun_app.{2 1} Type monoid.{0} h0 (linear_ordered_field.{0} num))  := sorry --non-trivial
lemma new_lemma_161725 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @locally_compact_space.{0} real.angle (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) real.angle)  := sorry --non-trivial
lemma new_lemma_161726 (h0 : list (add_cancel_monoid (has_add (has_neg name)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_161727 (h0 : topological_space (has_nnnorm (has_ssubset (mul_one_class string.iterator_imp)))) : totally_disconnected_space (has_nnnorm (has_ssubset (mul_one_class string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_161728 (h0 : add_group (has_compl (mul_one_class linarith.ineq))) : is_add_cyclic (has_compl (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_161729 (h0 : function.extfun (Type 1) topological_space) : @t0_space.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_161730 (h0 : functor.add_const (ordered_add_comm_monoid (has_Inf pos)) (ring pos)) : @archimedean.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_Inf.{0} pos)) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_161731 (h0 : filter (monoid (has_inter (has_inter empty)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_161732 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (has_zero.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_161733 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (as_linear_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (as_linear_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_161734 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_161735 (h0 : ring (has_ssubset (has_inv linarith.ineq))) : is_domain (has_ssubset (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_161736 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} congr_arg_kind (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_161737 (h0 : not (filter (denumerable linarith.ineq) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_161738 (h0 : monoid (add_comm_semigroup char)) (h1 : submonoid (add_comm_semigroup char)) : submonoid.fg h1 := sorry --non-trivial
lemma new_lemma_161739 (h0 : group (add_right_cancel_monoid (semiring unsigned))) : normalizer_condition (add_right_cancel_monoid (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_161740 (h0 : functor.add_const (topological_space (has_to_string linarith.comp)) linarith.comp) : @locally_compact_space.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_161741 (h0 : finset (measurable_space.dynkin_system (semiring unsigned))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_161742 (h0 : topological_space (simple_graph name)) : locally_compact_space (simple_graph name) := sorry --non-trivial
lemma new_lemma_161743 (h0 : topological_space (has_union (has_top (semiring linarith.comp)))) : irreducible_space (has_union (has_top (semiring linarith.comp))) := sorry --non-trivial
lemma new_lemma_161744 (h0 : not (function.extfun Type ring -> false)) : @rank_condition.{0} (linear_ordered_semiring.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (linear_ordered_semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_161745 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_sub.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_sub.{0} empty))  := sorry --non-trivial
lemma new_lemma_161746 (h0 : functor.add_const (function.extfun Type topological_space) real) : @t1_space.{0} (comm_semigroup.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) real h0) (comm_semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_161747 (h0 : group (has_ssubset (random_gen (has_nnnorm char)))) : group.fg (has_ssubset (random_gen (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_161748 (h0 : topological_space (has_bot congr_arg_kind)) : discrete_topology (has_bot congr_arg_kind) := sorry --non-trivial
lemma new_lemma_161749 (h0 : ring (normed_group (semiring linarith.comp))) : rank_condition (normed_group (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_161750 (h0 : complete_lattice (normed_group fun_info)) : is_compactly_generated (normed_group fun_info) := sorry --non-trivial
lemma new_lemma_161751 (h0 : set (uniform_space fun_info)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_161752 (h0 : not (topological_space (with_bot linarith.comp) -> false)) : @irreducible_space.{0} (with_bot.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (with_bot.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_161753 (h1 : set (has_lt to_additive.value_type)) : set.finite h1 := sorry --non-trivial
lemma new_lemma_161754 (h0 : function.extfun Type topological_space) : @normal_space.{0} (has_sub.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_sub.{0} empty))  := sorry --non-trivial
lemma new_lemma_161755 (h2 : topological_space (complete_semilattice_Sup congr_arg_kind)) : totally_separated_space (complete_semilattice_Sup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_161756 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} h0 (cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_161757 (h0 : functor.add_const (finset (measurable_space.dynkin_system empty)) empty) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_161758 (h0 : topological_space (linear_ordered_comm_group_with_zero linarith.comp_source)) (h1 : preorder (linear_ordered_comm_group_with_zero linarith.comp_source)) : order_closed_topology (linear_ordered_comm_group_with_zero linarith.comp_source) := sorry --non-trivial
lemma new_lemma_161759 (h0 : topological_space (has_bot (has_Inf pos))) : totally_separated_space (has_bot (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_161760 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (with_bot.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (with_bot.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_161761 (h0 : group (has_neg (option ennreal))) : is_simple_group (has_neg (option ennreal)) := sorry --non-trivial
lemma new_lemma_161762 (h0 : functor.add_const (topological_space (has_nndist empty)) empty) : @irreducible_space.{0} (has_nndist.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_161763 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_nnnorm.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_nnnorm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_161764 (h0 : group (left_cancel_semigroup unsigned)) (h1 : option (group (left_cancel_semigroup unsigned))) : group.fg (left_cancel_semigroup unsigned) := sorry --non-trivial
lemma new_lemma_161765 (h0 : functor.add_const (functor.add_const (topological_space Type) linarith.comp) (finset (ring Type))) : @normal_space.{1} Type (@functor.add_const.run.{1 0} (topological_space.{1} Type) linarith.comp (@functor.add_const.run.{1 1} (functor.add_const.{1 0} (topological_space.{1} Type) linarith.comp) (finset.{1} (ring.{1} Type)) h0))  := sorry --non-trivial
lemma new_lemma_161766 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} (boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) (boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_161767 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (distrib_lattice.{0} string_imp) (@function.extfun_app.{2 1} Type monoid.{0} h0 (distrib_lattice.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_161768 (h0 : functor.add_const (list (non_assoc_semiring empty)) unsigned) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_161769 (h0 : topological_space (has_union (has_norm congr_arg_kind))) : preirreducible_space (has_union (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_161770 (h0 : functor.add_const (cancel_comm_monoid_with_zero (sub_neg_monoid linarith.comp)) Type) : @unique_factorization_monoid.{0} (sub_neg_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (cancel_comm_monoid_with_zero.{0} (sub_neg_monoid.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_161771 (h0 : monoid (add_comm_monoid (has_add (normed_comm_ring linarith.comp)))) : monoid.fg (add_comm_monoid (has_add (normed_comm_ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_161772 (h0 : has_mem.mem (normed_group num) has_emptyc.emptyc) : @totally_separated_space.{0} (normed_group.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (normed_group.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_161773 (h0 : ordered_add_comm_monoid (has_to_string (has_to_string linarith.comp))) : archimedean (has_to_string (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_161774 (h0 : topological_space (has_norm (semiring (semiring (semiring (semiring unsigned)))))) : topological_space.separable_space (has_norm (semiring (semiring (semiring (semiring unsigned))))) := sorry --non-trivial
lemma new_lemma_161775 (h0 : ring (id (has_norm (has_top linarith.comp)))) : strong_rank_condition (id (has_norm (has_top linarith.comp))) := sorry --non-trivial
lemma new_lemma_161776 (h0 : functor.add_const (topological_space (has_pos_part pos)) pos) : @topological_space.separable_space.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_161777 (h0 : functor.add_const (functor.add_const (function.extfun Type group) environment.implicit_infer_kind) linarith.comp) : @normalizer_condition.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) environment.implicit_infer_kind (@functor.add_const.run.{1 0} (functor.add_const.{1 0} (function.extfun.{2 1} Type group.{0}) environment.implicit_infer_kind) linarith.comp h0)) (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_161778 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (with_one.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_one.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_161779 (h0 : group (boolean_algebra (has_Inf Type))) : is_simple_group (boolean_algebra (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_161780 (h0 : group (denumerable (random_gen fun_info))) : normalizer_condition (denumerable (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_161781 (h0 : add_monoid (ordered_comm_monoid (ring Type))) : add_monoid.fg (ordered_comm_monoid (ring Type)) := sorry --non-trivial
lemma new_lemma_161782 (h0 : ordered_add_comm_monoid (semiring num)) : archimedean (semiring num) := sorry --non-trivial
lemma new_lemma_161783 (h2 : ring (uniform_space linarith.comp_source)) : rank_condition (uniform_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_161784 (h0 : ring (canonically_ordered_monoid real)) : is_domain (canonically_ordered_monoid real) := sorry --non-trivial
lemma new_lemma_161785 (h0 : topological_space (comm_group (option (has_add ennreal)))) : irreducible_space (comm_group (option (has_add ennreal))) := sorry --non-trivial
lemma new_lemma_161786 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_161787 (h0 : functor.comp ring has_to_string Type) : @is_domain.{1} (has_to_string.{1} Type) (@functor.comp.run.{1 1 1} ring.{1} has_to_string.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_161788 (h0 : topological_space (ordered_comm_monoid (has_neg (has_neg (has_neg Type))))) : preirreducible_space (ordered_comm_monoid (has_neg (has_neg (has_neg Type)))) := sorry --non-trivial
lemma new_lemma_161789 (h0 : topological_space (boolean_algebra (has_Inf (has_add Type)))) : sequential_space (boolean_algebra (has_Inf (has_add Type))) := sorry --non-trivial
lemma new_lemma_161790 (h0 : fin has_zero.zero) : @path_connected_space.{0} (has_bot.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_bot.{0} name))  := sorry --non-trivial
lemma new_lemma_161791 (h0 : group (with_one (has_nnnorm (random_gen fun_info)))) : group.fg (with_one (has_nnnorm (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_161792 (h1 : complete_lattice (has_inv (random_gen string_imp))) : complete_lattice.is_Sup_finite_compact (has_inv (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_161793 (h0 : topological_space (finset (has_to_string name))) : t0_space (finset (has_to_string name)) := sorry --non-trivial
lemma new_lemma_161794 (h1 : topological_space (measurable_space to_additive.value_type)) : discrete_topology (measurable_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_161795 (h0 : functor.add_const (topological_space (is_R_or_C unsigned)) congr_arg_kind) : @loc_path_connected_space.{0} (is_R_or_C.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (is_R_or_C.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_161796 (h0 : functor.comp add_monoid complete_distrib_lattice environment.implicit_infer_kind) : @add_monoid.fg.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} add_monoid.{0} complete_distrib_lattice.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_161797 (h0 : not (function.extfun Type monoid -> false)) : @monoid.fg.{0} (has_emptyc.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type monoid.{0}) h0) (has_emptyc.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_161798 (h0 : function.extfun Type ring) : @is_domain.{0} (comm_group.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (comm_group.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_161799 (h0 : function.extfun (Type 1) topological_space) : @normal_space.{1} (mul_zero_class.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (mul_zero_class.{1} Type))  := sorry --non-trivial
lemma new_lemma_161800 (h0 : topological_space (linear_ordered_comm_group (option (option num)))) : irreducible_space (linear_ordered_comm_group (option (option num))) := sorry --non-trivial
lemma new_lemma_161801 (h0 : uniform_space (with_one (has_top (semiring num)))) : complete_space (with_one (has_top (semiring num))) := sorry --non-trivial
lemma new_lemma_161802 (h0 : ordered_comm_monoid (boolean_algebra (ring (has_Inf (finset (finset (finset Type))))))) : has_exists_mul_of_le (boolean_algebra (ring (has_Inf (finset (finset (finset Type)))))) := sorry --non-trivial
lemma new_lemma_161803 (h0 : function.extfun (Type 1) ordered_comm_monoid) : @has_exists_mul_of_le.{1} (canonically_linear_ordered_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_comm_monoid.{1} h0 (canonically_linear_ordered_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_161804 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (finset.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (finset.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_161805 (h0 : complete_lattice (option ennreal)) : is_compactly_generated (option ennreal) := sorry --non-trivial
lemma new_lemma_161806 (h0 : topological_space (has_nndist (finset linarith.comp))) : totally_disconnected_space (has_nndist (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_161807 (h0 : fin has_zero.zero) : @topological_space.separable_space.{1} (normed_lattice_add_comm_group.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (normed_lattice_add_comm_group.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_161808 (h0 : add_monoid string_imp) (h1 : string_imp) : is_of_fin_add_order h1 := sorry --non-trivial
lemma new_lemma_161809 (h0 : topological_space (add_semigroup (option unsigned))) : t0_space (add_semigroup (option unsigned)) := sorry --non-trivial
lemma new_lemma_161810 (h0 : finset (linear_ordered_cancel_comm_monoid empty)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_161811 (h0 : functor.add_const Prop (has_nndist environment.implicit_infer_kind)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_161812 (h0 : ring (has_bot (ordered_comm_monoid Type))) : strong_rank_condition (has_bot (ordered_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_161813 (h0 : monoid (add_cancel_monoid (has_neg pos))) : monoid.fg (add_cancel_monoid (has_neg pos)) := sorry --non-trivial
lemma new_lemma_161814 (h0 : topological_space (has_union (linear_ordered_semiring (linear_ordered_semiring empty)))) : preirreducible_space (has_union (linear_ordered_semiring (linear_ordered_semiring empty))) := sorry --non-trivial
lemma new_lemma_161815 (h0 : monoid (with_one (has_top (has_top (random_gen congr_arg_kind))))) : monoid.fg (with_one (has_top (has_top (random_gen congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_161816 (h0 : group fun_info) (h1 : function.extfun Type topological_space) : @locally_compact_space.{0} (@group_topology.{0} fun_info h0) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (@group_topology.{0} fun_info h0))  := sorry --non-trivial
lemma new_lemma_161817 (h0 : topological_space (has_top (has_top (has_top (has_top (has_top to_additive.value_type)))))) : discrete_topology (has_top (has_top (has_top (has_top (has_top to_additive.value_type))))) := sorry --non-trivial
lemma new_lemma_161818 (h0 : functor.add_const (filter (add_cancel_monoid linarith.comp)) environment.implicit_infer_kind) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_161819 (h0 : topological_space (has_nndist (has_add environment.implicit_infer_kind))) : normal_space (has_nndist (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_161820 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_union.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_union.{0} empty))  := sorry --non-trivial
lemma new_lemma_161821 (h0 : monoid (add_cancel_comm_monoid empty)) : monoid.fg (add_cancel_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_161822 (h0 : ordered_add_comm_monoid (sub_neg_monoid (has_add (has_Inf linarith.comp)))) : archimedean (sub_neg_monoid (has_add (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_161823 (h0 : has_Inf (generalized_boolean_algebra real) -> has_Inf (generalized_boolean_algebra real) -> Prop) : is_per (has_Inf (generalized_boolean_algebra real)) h0 := sorry --non-trivial
lemma new_lemma_161824 (h0 : uniform_space (plift (semiring empty))) : complete_space (plift (semiring empty)) := sorry --non-trivial
lemma new_lemma_161825 (h0 : functor.add_const (function.extfun Type ring) unsigned) : @strong_rank_condition.{0} (mul_zero_class.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) unsigned h0) (mul_zero_class.{0} num))  := sorry --non-trivial
lemma new_lemma_161826 (h0 : topological_space (linear_ordered_field (option empty))) : preconnected_space (linear_ordered_field (option empty)) := sorry --non-trivial
lemma new_lemma_161827 (h0 : functor.add_const (ordered_add_comm_monoid (canonically_ordered_comm_semiring name)) name) : @archimedean.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (canonically_ordered_comm_semiring.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_161828 (h0 : function.extfun Type ring) : @is_domain.{0} (has_compl.{0} linarith.ineq) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_compl.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_161829 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (ordered_ring.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} h0 (ordered_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_161830 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (add_cancel_monoid empty)) := sorry --non-trivial
lemma new_lemma_161831 (h0 : ring (has_nndist (finset pos))) : is_principal_ideal_ring (has_nndist (finset pos)) := sorry --non-trivial
lemma new_lemma_161832 (h0 : functor.add_const (ring (ring environment.implicit_infer_kind)) name) : @is_principal_ideal_ring.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (ring.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_161833 (h0 : functor.add_const (uniform_space (as_linear_order unsigned)) empty) : @separated_space.{0} (as_linear_order.{0} unsigned) (@functor.add_const.run.{0 0} (uniform_space.{0} (as_linear_order.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_161834 (h0 : not (complete_lattice (semiring to_additive.value_type) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (semiring.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (complete_lattice.{0} (semiring.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_161835 (h0 : complete_lattice (comm_group (add_cancel_monoid (has_add (has_neg_part (comm_group name)))))) : is_compactly_generated (comm_group (add_cancel_monoid (has_add (has_neg_part (comm_group name))))) := sorry --non-trivial
lemma new_lemma_161836 (h1 : ring (metric_space char)) : rank_condition (metric_space char) := sorry --non-trivial
lemma new_lemma_161837 (h0 : topological_space (complete_distrib_lattice congr_arg_kind)) : path_connected_space (complete_distrib_lattice congr_arg_kind) := sorry --non-trivial
lemma new_lemma_161838 (h0 : monoid (ordered_comm_monoid (has_neg pos))) : monoid.fg (ordered_comm_monoid (has_neg pos)) := sorry --non-trivial
lemma new_lemma_161839 (h0 : functor.add_const (topological_space (comm_group Type)) name) : @topological_space.separable_space.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (comm_group.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_161840 (h0 : has_mem.mem (canonically_ordered_add_monoid linarith.comp_source) has_emptyc.emptyc) : @is_atomistic.{0} (canonically_ordered_add_monoid.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (canonically_ordered_add_monoid.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_161841 (h0 : uniform_space (normed_comm_ring (has_sub unsigned))) : separated_space (normed_comm_ring (has_sub unsigned)) := sorry --non-trivial
lemma new_lemma_161842 (h0 : functor.add_const (ordered_add_comm_monoid (normed_linear_ordered_group congr_arg_kind)) unsigned) : @archimedean.{0} (normed_linear_ordered_group.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (normed_linear_ordered_group.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_161843 (h0 : topological_space (with_bot (has_norm empty))) : path_connected_space (with_bot (has_norm empty)) := sorry --non-trivial
lemma new_lemma_161844 (h0 : functor.add_const (filter (has_zero linarith.comp)) (finset linarith.comp)) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_161845 (h0 : topological_space (simple_graph (has_Inf (has_add (finset Type))))) : t1_space (simple_graph (has_Inf (has_add (finset Type)))) := sorry --non-trivial
lemma new_lemma_161846 (h0 : uniform_space (id (has_inv (has_top fun_info)))) : complete_space (id (has_inv (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_161847 (h0 : functor.add_const (topological_space (has_Sup empty)) empty) : @totally_disconnected_space.{0} (has_Sup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Sup.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_161848 (h0 : functor.add_const (ring (semigroup pos)) linarith.comp) : @strong_rank_condition.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (semigroup.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_161849 (h0 : functor.add_const (ring (plift num)) (semiring num)) : @strong_rank_condition.{1} (plift.{1} num) (@functor.add_const.run.{1 0} (ring.{1} (plift.{1} num)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_161850 (h1 : ring (has_append string_imp)) : is_domain (has_append string_imp) := sorry --non-trivial
lemma new_lemma_161851 (h0 : filter (has_nndist (has_add (finset (finset (has_add linarith.comp)))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_161852 (h0 : topological_space (random_gen num)) : normal_space (random_gen num) := sorry --non-trivial
lemma new_lemma_161853 (h0 : ring (random_gen (mul_one_class to_additive.value_type))) : strong_rank_condition (random_gen (mul_one_class to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_161854 (h0 : functor.add_const (uniform_space (add_comm_monoid pos)) (finset Type)) : @separated_space.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 1} (uniform_space.{0} (add_comm_monoid.{0} pos)) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_161855 (h0 : function.extfun ((finset Type -> Prop) -> Prop) (function.extfun (finset Type -> Prop))) : @strong_rank_condition.{0} num (@finset.pi.empty.{1 0} Type ring.{0} num (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) num) (@function.extfun_app.{2 0} (finset.{1} Type → Prop) (function.extfun.{2 0} (finset.{1} Type)) (@function.extfun_app.{2 0} ((finset.{1} Type → Prop) → Prop) (function.extfun.{2 0} (finset.{1} Type → Prop)) h0 (function.extfun.{2 0} (finset.{1} Type))) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) num)) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_161856 (h0 : has_mem.mem (semiring congr_arg_kind) has_emptyc.emptyc) : @monoid.fg.{0} (semiring.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type monoid.{0} (semiring.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_161857 (h0 : topological_space (linear_ordered_semiring (semiring (semiring (semiring (semiring unsigned)))))) : locally_compact_space (linear_ordered_semiring (semiring (semiring (semiring (semiring unsigned))))) := sorry --non-trivial
lemma new_lemma_161858 (h0 : topological_space (has_pos_part (finset pos))) : totally_disconnected_space (has_pos_part (finset pos)) := sorry --non-trivial
lemma new_lemma_161859 (h0 : add_group (has_lt enat)) : is_add_cyclic (has_lt enat) := sorry --non-trivial
lemma new_lemma_161860 (h0 : topological_space (ordered_comm_ring name)) : sequential_space (ordered_comm_ring name) := sorry --non-trivial
lemma new_lemma_161861 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @discrete_topology.{0} (has_neg.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (has_neg.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_161862 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_161863 (h1 : add_group (has_compl (mul_one_class (mul_one_class string.iterator_imp)))) : is_add_cyclic (has_compl (mul_one_class (mul_one_class string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_161864 (h0 : function.extfun Type topological_space) : @t0_space.{0} (linear_ordered_add_comm_group.{0} char) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_add_comm_group.{0} char))  := sorry --non-trivial
lemma new_lemma_161865 (h0 : ring (finset unsigned)) : is_principal_ideal_ring (finset unsigned) := sorry --non-trivial
lemma new_lemma_161866 (h0 : not (ring (semi_normed_comm_ring linarith.comp_source) -> false)) : @strong_rank_condition.{0} (semi_normed_comm_ring.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (semi_normed_comm_ring.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_161867 (h0 : functor.add_const (function.extfun Type topological_space) (ring Type)) : @path_connected_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) (ring.{1} Type) h0) (semigroup.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_161868 (h0 : list (linear_ordered_add_comm_group (has_ssubset (random_gen linarith.comp_source)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_161869 (h0 : group (has_one linarith.comp)) : is_cyclic (has_one linarith.comp) := sorry --non-trivial
lemma new_lemma_161870 (h0 : ring (has_zero (ring (ring Type)))) : is_domain (has_zero (ring (ring Type))) := sorry --non-trivial
lemma new_lemma_161871 (h0 : not (group (semi_normed_ring to_additive.value_type) -> false)) : @is_cyclic.{0} (semi_normed_ring.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (group.{0} (semi_normed_ring.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_161872 (h0 : topological_space (denumerable (has_ssubset (has_ssubset char)))) : path_connected_space (denumerable (has_ssubset (has_ssubset char))) := sorry --non-trivial
lemma new_lemma_161873 (h0 : function.extfun Type topological_space) : @normal_space.{0} (group_with_zero.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (group_with_zero.{0} empty))  := sorry --non-trivial
lemma new_lemma_161874 (h0 : topological_space (ordered_comm_group congr_arg_kind)) : irreducible_space (ordered_comm_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_161875 (h0 : topological_space (semilattice_inf (has_pos_part linarith.comp))) : irreducible_space (semilattice_inf (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_161876 (h0 : functor.add_const (group (semigroup Type)) pos) : @normalizer_condition.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (semigroup.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_161877 (h0 : complete_lattice (ring name)) : is_compactly_generated (ring name) := sorry --non-trivial
lemma new_lemma_161878 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (has_to_string.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_161879 (h0 : complete_lattice (bin_tree (semiring num))) : complete_lattice.is_Sup_finite_compact (bin_tree (semiring num)) := sorry --non-trivial
lemma new_lemma_161880 (h0 : function.extfun nat fin) : @normal_space.{0} (boolean_algebra.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (boolean_algebra.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_161881 (h0 : functor.add_const (uniform_space (boolean_algebra Type)) (ring Type)) : @separated_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 1} (uniform_space.{1} (boolean_algebra.{1} Type)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_161882 (h0 : not (ring (linear_ordered_add_comm_group to_additive.value_type) -> false)) : @is_domain.{0} (linear_ordered_add_comm_group.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (linear_ordered_add_comm_group.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_161883 (h0 : topological_space (ordered_comm_monoid (has_pos_part linarith.comp))) : regular_space (ordered_comm_monoid (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_161884 (h0 : nat) (h1 h2 : fin h0) : id (fin.lt h1 h2) := sorry --non-trivial
lemma new_lemma_161885 (h0 : topological_space (measure_theory.measure_space (semiring (semiring (semiring (semiring unsigned)))))) : t1_space (measure_theory.measure_space (semiring (semiring (semiring (semiring unsigned))))) := sorry --non-trivial
lemma new_lemma_161886 (h0 : topological_space (add_comm_monoid (finset linarith.comp))) : totally_separated_space (add_comm_monoid (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_161887 (h0 : ring (free_add_monoid empty)) : is_domain (free_add_monoid empty) := sorry --non-trivial
lemma new_lemma_161888 (h0 : function.extfun Type topological_space) : @t1_space.{0} (has_dist.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_dist.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_161889 (h0 : topological_space (has_neg (cancel_monoid pos))) : locally_compact_space (has_neg (cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_161890 (h0 : monoid (id (has_inv to_additive.value_type))) : monoid.fg (id (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_161891 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (has_bot.{0} name) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (has_bot.{0} name))  := sorry --non-trivial
lemma new_lemma_161892 (h0 : add_group (semiring (has_norm num))) : is_add_cyclic (semiring (has_norm num)) := sorry --non-trivial
lemma new_lemma_161893 (h0 : functor.add_const (ring (has_add linarith.comp)) environment.implicit_infer_kind) : @is_domain.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_add.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_161894 (h0 : monoid (generalized_boolean_algebra (finset (has_add pos)))) : monoid.fg (generalized_boolean_algebra (finset (has_add pos))) := sorry --non-trivial
lemma new_lemma_161895 (h0 : functor.add_const (topological_space (as_linear_order empty)) empty) : @totally_separated_space.{0} (as_linear_order.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (as_linear_order.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_161896 (h2 : ring (uniform_space reducibility_hints)) : strong_rank_condition (uniform_space reducibility_hints) := sorry --non-trivial
lemma new_lemma_161897 (h0 : topological_space (comm_group (has_neg_part Type))) : normal_space (comm_group (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_161898 (h0 : functor.add_const (topological_space (semigroup Type)) (comm_group Type)) : @locally_compact_space.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (semigroup.{1} Type)) (comm_group.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_161899 (h1 : has_lt (add_cancel_monoid std_gen)) : no_max_order (add_cancel_monoid std_gen) := sorry --non-trivial
lemma new_lemma_161900 (h0 : uniform_space (mul_zero_class (semiring num))) : separated_space (mul_zero_class (semiring num)) := sorry --non-trivial
lemma new_lemma_161901 (h0 : topological_space (has_add linarith.comp)) : loc_path_connected_space (has_add linarith.comp) := sorry --non-trivial
lemma new_lemma_161902 (h0 : functor.add_const (finset (has_add linarith.comp)) linarith.comp) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_161903 (h0 : functor.add_const (complete_lattice (has_neg Type)) linarith.comp) : @is_atomistic.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (has_neg.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_161904 (h0 : filter (filter empty)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_161905 (h0 : topological_space (has_add (option unsigned))) : totally_disconnected_space (has_add (option unsigned)) := sorry --non-trivial
lemma new_lemma_161906 (h0 : not (finset (ordered_semiring num) -> false)) : finset.nonempty (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_161907 (h0 : topological_space (ordered_comm_ring (has_bot Type))) : path_connected_space (ordered_comm_ring (has_bot Type)) := sorry --non-trivial
lemma new_lemma_161908 (h0 : ring (has_add (has_nndist name))) : rank_condition (has_add (has_nndist name)) := sorry --non-trivial
lemma new_lemma_161909 (h0 : topological_space (has_to_string (comm_group (comm_group unsigned)))) : locally_compact_space (has_to_string (comm_group (comm_group unsigned))) := sorry --non-trivial
lemma new_lemma_161910 (h0 : complete_lattice (normed_linear_ordered_group (semiring unsigned))) : complete_lattice.is_Sup_finite_compact (normed_linear_ordered_group (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_161911 (h0 : topological_space (linear_ordered_add_comm_monoid_with_top pos)) : loc_path_connected_space (linear_ordered_add_comm_monoid_with_top pos) := sorry --non-trivial
lemma new_lemma_161912 (h0 : functor.add_const (uniform_space (add_comm_monoid Type)) linarith.comp) : @separated_space.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (add_comm_monoid.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_161913 (h0 : functor.add_const (topological_space (add_cancel_monoid name)) name) : @regular_space.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_161914 (h0 : topological_space (has_dist (option num))) : topological_space.separable_space (has_dist (option num)) := sorry --non-trivial
lemma new_lemma_161915 (h0 : char -> Prop) (h1 : set char) (h2 : char) : set.sep h0 h1 h2 := sorry --non-trivial
lemma new_lemma_161916 (h0 : topological_space (has_add (sub_neg_monoid (has_bot (has_add Type))))) : sequential_space (has_add (sub_neg_monoid (has_bot (has_add Type)))) := sorry --non-trivial
lemma new_lemma_161917 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_one.{0} (semiring.{0} (metric_space.{0} (semiring.{0} num)))) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_one.{0} (semiring.{0} (metric_space.{0} (semiring.{0} num)))))  := sorry --non-trivial
lemma new_lemma_161918 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (with_one.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} fun_info)))) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (with_one.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} fun_info)))))  := sorry --non-trivial
lemma new_lemma_161919 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (topological_space char)) := sorry --non-trivial
lemma new_lemma_161920 (h1 : not (ring (non_unital_non_assoc_semiring linarith.comp_source) -> false)) : @strong_rank_condition.{0} (non_unital_non_assoc_semiring.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (non_unital_non_assoc_semiring.{0} linarith.comp_source)) h1)  := sorry --non-trivial
lemma new_lemma_161921 (h0 : functor.add_const (complete_lattice (canonically_ordered_monoid real)) real) : @complete_lattice.is_Sup_finite_compact.{0} (canonically_ordered_monoid.{0} real) (@functor.add_const.run.{0 0} (complete_lattice.{0} (canonically_ordered_monoid.{0} real)) real h0)  := sorry --non-trivial
lemma new_lemma_161922 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (linear_ordered_field empty)) := sorry --non-trivial
lemma new_lemma_161923 (h0 : topological_space (ordered_comm_ring (sub_neg_monoid pos))) : path_connected_space (ordered_comm_ring (sub_neg_monoid pos)) := sorry --non-trivial
lemma new_lemma_161924 (h0 : function.extfun Type topological_space) : @t0_space.{0} (normed_linear_ordered_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_linear_ordered_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_161925 (h0 : functor.add_const (finset (has_pos_part linarith.comp)) pos) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_161926 (h0 : function.extfun Type (functor.add_const Prop)) : functor.add_const.run (function.extfun_app h0 (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_161927 (h0 : topological_space (complete_linear_order (semiring (semiring unsigned)))) : preirreducible_space (complete_linear_order (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_161928 (h0 : functor.add_const (group (normed_comm_ring name)) unsigned) : @group.fg.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (group.{0} (normed_comm_ring.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_161929 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (complete_distrib_lattice.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_distrib_lattice.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_161930 (h0 : ring (left_cancel_semigroup (semiring num))) : is_principal_ideal_ring (left_cancel_semigroup (semiring num)) := sorry --non-trivial
lemma new_lemma_161931 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} unsigned (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) unsigned)  := sorry --non-trivial
lemma new_lemma_161932 (h0 : ordered_add_comm_monoid (pseudo_metric_space (option unsigned))) : archimedean (pseudo_metric_space (option unsigned)) := sorry --non-trivial
lemma new_lemma_161933 (h1 : uniform_space (denumerable string_imp)) : complete_space (denumerable string_imp) := sorry --non-trivial
lemma new_lemma_161934 (h0 : uniform_space (complete_semilattice_Sup (semiring num))) : separated_space (complete_semilattice_Sup (semiring num)) := sorry --non-trivial
lemma new_lemma_161935 (h0 : ring (linear_ordered_comm_group unsigned)) : rank_condition (linear_ordered_comm_group unsigned) := sorry --non-trivial
lemma new_lemma_161936 (h0 : semiring (generalized_boolean_algebra (sub_neg_monoid linarith.comp))) : is_noetherian_ring (generalized_boolean_algebra (sub_neg_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_161937 (h0 : ring (has_top num)) : strong_rank_condition (has_top num) := sorry --non-trivial
lemma new_lemma_161938 (h0 : ring (has_nndist congr_arg_kind)) : is_domain (has_nndist congr_arg_kind) := sorry --non-trivial
lemma new_lemma_161939 (h0 : ring (has_add (has_neg linarith.comp))) : rank_condition (has_add (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_161940 (h0 : topological_space (preorder empty)) : loc_path_connected_space (preorder empty) := sorry --non-trivial
lemma new_lemma_161941 (h0 : ring (random_gen linarith.comp)) : rank_condition (random_gen linarith.comp) := sorry --non-trivial
lemma new_lemma_161942 (h0 : topological_space (has_add pos)) : normal_space (has_add pos) := sorry --non-trivial
lemma new_lemma_161943 (h0 : function.extfun (finset Type) (has_mem.mem (normed_group num))) : @rank_condition.{0} (normed_group.{0} num) (@finset.pi.empty.{1 0} Type ring.{0} (normed_group.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (normed_group.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_161944 (h0 : finset (semigroup num)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_161945 (h0 : not (function.extfun (finset Type) (has_mem.mem linarith.comp) -> false)) : @path_connected_space.{0} linarith.comp (@finset.pi.empty.{1 0} Type topological_space.{0} linarith.comp (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) linarith.comp) (@classical.by_contradiction'.{0} (function.extfun.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) linarith.comp)) h0) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_161946 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_comm_monoid_with_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_161947 (h0 : group (add_group (has_norm (has_norm num)))) : is_cyclic (add_group (has_norm (has_norm num))) := sorry --non-trivial
lemma new_lemma_161948 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (ordered_cancel_add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_cancel_add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_161949 (h0 : add_monoid (canonically_ordered_comm_semiring (has_add (has_add (has_pos_part (ring pos)))))) : add_monoid.fg (canonically_ordered_comm_semiring (has_add (has_add (has_pos_part (ring pos))))) := sorry --non-trivial
lemma new_lemma_161950 (h2 : set (linarith.ineq -> char)) : set.separates_points h2 := sorry --non-trivial
lemma new_lemma_161951 (h0 : topological_space (normed_comm_ring (has_nndist ennreal))) : totally_separated_space (normed_comm_ring (has_nndist ennreal)) := sorry --non-trivial
lemma new_lemma_161952 (h0 : functor.add_const (list (boolean_algebra name)) linarith.comp) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_161953 (h0 : functor.add_const (topological_space (left_cancel_semigroup congr_arg_kind)) empty) : @topological_space.separable_space.{0} (left_cancel_semigroup.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_semigroup.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_161954 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (complete_semilattice_Sup.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (complete_semilattice_Sup.{0} empty))  := sorry --non-trivial
lemma new_lemma_161955 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (add_right_cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_right_cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_161956 (h0 : group (ordered_comm_monoid real)) : is_cyclic (ordered_comm_monoid real) := sorry --non-trivial
lemma new_lemma_161957 (h0 : functor.comp topological_space comm_group Type) : @irreducible_space.{1} (comm_group.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} comm_group.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_161958 (h0 : functor.add_const (cancel_comm_monoid_with_zero (finset ennreal)) num) : @unique_factorization_monoid.{0} (finset.{0} ennreal) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (finset.{0} ennreal)) num h0)  := sorry --non-trivial
lemma new_lemma_161959 (h0 : functor.add_const Prop (has_neg_part (add_comm_monoid Type))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_161960 (h0 : functor.add_const (cancel_comm_monoid_with_zero (boolean_algebra.core Type)) name) : @unique_factorization_monoid.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (cancel_comm_monoid_with_zero.{1} (boolean_algebra.core.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_161961 (h0 : functor.add_const (topological_space (finset pos)) (has_Inf pos)) : @preconnected_space.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} pos)) (has_Inf.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_161962 (h0 : functor.add_const (function.extfun Type ring) Type) : @is_domain.{0} pos (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ring.{0}) Type h0) pos)  := sorry --non-trivial
lemma new_lemma_161963 (h0 : function.extfun Type has_le) : @no_bot_order.{0} (monoid.{0} empty) (@function.extfun_app.{2 1} Type has_le.{0} h0 (monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_161964 (h0 : functor.add_const (complete_lattice (pseudo_metric_space empty)) unsigned) : @complete_lattice.is_Sup_finite_compact.{0} (pseudo_metric_space.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (pseudo_metric_space.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_161965 (h0 : topological_space (partial_order congr_arg_kind)) : preirreducible_space (partial_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_161966 (h0 : complete_lattice (has_emptyc linarith.ineq)) : is_atomistic (has_emptyc linarith.ineq) := sorry --non-trivial
lemma new_lemma_161967 (h0 : topological_space (semigroup (normed_comm_ring (normed_comm_ring name)))) : irreducible_space (semigroup (normed_comm_ring (normed_comm_ring name))) := sorry --non-trivial
lemma new_lemma_161968 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (ordered_cancel_add_comm_monoid empty)) := sorry --non-trivial
lemma new_lemma_161969 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (monoid_with_zero.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (monoid_with_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_161970 (h0 : functor.add_const (function.extfun Type group) (has_Inf pos)) : @normalizer_condition.{0} (normed_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) (has_Inf.{0} pos) h0) (normed_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_161971 (h1 : ring (distrib (has_nnnorm (random_gen char)))) : rank_condition (distrib (has_nnnorm (random_gen char))) := sorry --non-trivial
lemma new_lemma_161972 (h0 : functor.add_const (topological_space (ordered_comm_monoid Type)) linarith.comp) : @totally_separated_space.{1} (ordered_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ordered_comm_monoid.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_161973 (h0 : complete_lattice (ring (has_neg_part (comm_group (has_add (has_add Type)))))) : is_compactly_generated (ring (has_neg_part (comm_group (has_add (has_add Type))))) := sorry --non-trivial
lemma new_lemma_161974 (h0 : function.extfun Type ring) : @is_domain.{0} (has_compl.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_compl.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_161975 (h1 : group (normed_field reducibility_hints)) : is_cyclic (normed_field reducibility_hints) := sorry --non-trivial
lemma new_lemma_161976 (h0 : uniform_space (measurable_space (has_inv (random_gen (random_gen fun_info))))) : complete_space (measurable_space (has_inv (random_gen (random_gen fun_info)))) := sorry --non-trivial
lemma new_lemma_161977 (h0 : has_mem.mem add_group has_emptyc.emptyc) : @is_add_cyclic.{0} num (@function.extfun_app.{2 1} Type add_group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) add_group.{0} h0) num)  := sorry --non-trivial
lemma new_lemma_161978 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (left_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (left_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_161979 (h0 : group (measure_theory.measure_space congr_arg_kind)) : group.fg (measure_theory.measure_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_161980 (h0 : topological_space (has_zero (option unsigned))) : t0_space (has_zero (option unsigned)) := sorry --non-trivial
lemma new_lemma_161981 (h0 : topological_space (with_bot (semiring (semiring empty)))) : path_connected_space (with_bot (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_161982 (h0 : topological_space (has_neg_part pos)) : t1_space (has_neg_part pos) := sorry --non-trivial
lemma new_lemma_161983 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (mul_zero_class.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (mul_zero_class.{0} empty))  := sorry --non-trivial
lemma new_lemma_161984 (h0 : topological_space (id (semiring empty))) : normal_space (id (semiring empty)) := sorry --non-trivial
lemma new_lemma_161985 (h1 : topological_space (normed_field std_gen)) : totally_disconnected_space (normed_field std_gen) := sorry --non-trivial
lemma new_lemma_161986 (h0 : uniform_space (mul_zero_class (has_add name))) : complete_space (mul_zero_class (has_add name)) := sorry --non-trivial
lemma new_lemma_161987 (h0 : uniform_space (ordered_cancel_add_comm_monoid empty)) : complete_space (ordered_cancel_add_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_161988 (h0 : topological_space (has_compl int)) : t0_space (has_compl int) := sorry --non-trivial
lemma new_lemma_161989 (h0 : topological_space (ring (has_Inf (ordered_ring name)))) : preconnected_space (ring (has_Inf (ordered_ring name))) := sorry --non-trivial
lemma new_lemma_161990 (h0 : topological_space (finset environment.implicit_infer_kind)) : irreducible_space (finset environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_161991 (h1 : not (topological_space (fintype char) -> false)) : @path_connected_space.{0} (fintype.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (fintype.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_161992 (h0 : functor.add_const (filter (has_bot empty)) unsigned) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_161993 (h0 : topological_space (semi_normed_comm_ring (random_gen (random_gen (random_gen linarith.comp_source))))) : t0_space (semi_normed_comm_ring (random_gen (random_gen (random_gen linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_161994 (h0 : functor.add_const (topological_space (semigroup name)) Type) : @regular_space.{0} (semigroup.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (semigroup.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_161995 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} (random_gen.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (random_gen.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_161996 (h0 : add_group (add_cancel_monoid (option ennreal))) : is_add_cyclic (add_cancel_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_161997 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (semi_normed_ring.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (semi_normed_ring.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_161998 (h0 : filter (has_add (has_add (has_pos_part environment.implicit_infer_kind)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_161999 (h0 : ring (monoid empty)) : is_domain (monoid empty) := sorry --non-trivial
lemma new_lemma_162000 (h0 : topological_space (has_inter (option unsigned))) : normal_space (has_inter (option unsigned)) := sorry --non-trivial
lemma new_lemma_162001 (h0 : finset (has_to_string (option pos)) -> finset (has_to_string (option pos)) -> Prop) : is_symm (finset (has_to_string (option pos))) h0 := sorry --non-trivial
lemma new_lemma_162002 (h0 : functor.add_const (semiring (measurable_space.dynkin_system congr_arg_kind)) unsigned) : @is_noetherian_ring.{0} (measurable_space.dynkin_system.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (semiring.{0} (measurable_space.dynkin_system.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_162003 (h0 : ring (has_le enat)) : is_domain (has_le enat) := sorry --non-trivial
lemma new_lemma_162004 (h0 : topological_space (add_cancel_monoid (finset linarith.comp))) : locally_compact_space (add_cancel_monoid (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_162005 (h0 : complete_lattice complex) : is_compactly_generated complex := sorry --non-trivial
lemma new_lemma_162006 (h0 : topological_space (ring (has_neg (has_neg (has_neg pos))))) : normal_space (ring (has_neg (has_neg (has_neg pos)))) := sorry --non-trivial
lemma new_lemma_162007 (h0 : function.extfun Type (functor.comp (functor.comp topological_space has_neg_part) ring)) : @irreducible_space.{0} (has_neg_part.{0} (ring.{0} unsigned)) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg_part.{0} (ring.{0} unsigned) (@functor.comp.run.{0 0 0} (functor.comp.{0 0 0} topological_space.{0} has_neg_part.{0}) ring.{0} unsigned (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} (functor.comp.{0 0 0} topological_space.{0} has_neg_part.{0}) ring.{0}) h0 unsigned)))  := sorry --non-trivial
lemma new_lemma_162008 (h1 : uniform_space (has_div std_gen)) : complete_space (has_div std_gen) := sorry --non-trivial
lemma new_lemma_162009 (h0 : topological_space (boolean_algebra (has_pos_part pos))) : preconnected_space (boolean_algebra (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_162010 (h0 : topological_space (topological_space (random_gen to_additive.value_type))) : path_connected_space (topological_space (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_162011 (h0 : functor.add_const (group (canonically_ordered_comm_semiring linarith.comp)) (has_neg_part linarith.comp)) : @group.fg.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (canonically_ordered_comm_semiring.{0} linarith.comp)) (has_neg_part.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_162012 (h0 : topological_space (comm_ring (has_nnnorm (random_gen (random_gen to_additive.value_type))))) : totally_disconnected_space (comm_ring (has_nnnorm (random_gen (random_gen to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_162013 (h0 : group (complete_distrib_lattice ennreal)) : group.fg (complete_distrib_lattice ennreal) := sorry --non-trivial
lemma new_lemma_162014 (h0 : ordered_add_comm_monoid (has_add (has_to_string (cancel_monoid ennreal)))) : archimedean (has_add (has_to_string (cancel_monoid ennreal))) := sorry --non-trivial
lemma new_lemma_162015 (h0 : functor.add_const (uniform_space (boolean_algebra.core Type)) environment.implicit_infer_kind) : @separated_space.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (boolean_algebra.core.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_162016 (h0 : topological_space string) (h1 : preorder string) : order_closed_topology string := sorry --non-trivial
lemma new_lemma_162017 (h2 : group (id num)) : is_cyclic (id num) := sorry --non-trivial
lemma new_lemma_162018 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (has_edist unsigned)) := sorry --non-trivial
lemma new_lemma_162019 (h0 : semiring (linear_ordered_semiring (semiring (has_top unsigned)))) : is_noetherian_ring (linear_ordered_semiring (semiring (has_top unsigned))) := sorry --non-trivial
lemma new_lemma_162020 (h0 : ring (has_nndist (ring (finset Type)))) : strong_rank_condition (has_nndist (ring (finset Type))) := sorry --non-trivial
lemma new_lemma_162021 (h0 : not (topological_space (metric_space empty) -> false)) : @irreducible_space.{0} (metric_space.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (metric_space.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_162022 (h0 : filter (complete_linear_order (semiring (semiring (semiring congr_arg_kind))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_162023 (h0 : function.extfun Type ring) : @is_domain.{0} (has_norm.{0} string_imp) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_norm.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_162024 (h0 : functor.add_const (topological_space (complete_distrib_lattice name)) linarith.comp) : @t1_space.{0} (complete_distrib_lattice.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_162025 (h0 : group (add_cancel_monoid (has_add pos))) : group.fg (add_cancel_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_162026 (h0 : functor.add_const (monoid (boolean_algebra.core environment.implicit_infer_kind)) pos) : @monoid.fg.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (monoid.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_162027 (h0 : group (has_norm (random_gen string_imp))) : group.fg (has_norm (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_162028 (h0 : not (topological_space fun_info -> false)) : @path_connected_space.{0} fun_info (@classical.by_contradiction'.{1} (topological_space.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_162029 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (canonically_ordered_add_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_ordered_add_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_162030 (h0 : complete_lattice (normed_lattice_add_comm_group (has_Inf Type))) : is_compactly_generated (normed_lattice_add_comm_group (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_162031 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @regular_space.{0} (has_add.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (has_add.{0} name))  := sorry --non-trivial
lemma new_lemma_162032 (h0 : functor.add_const (topological_space (option unsigned)) pos) : @regular_space.{0} (option.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_162033 (h0 : functor.add_const (complete_lattice (complete_linear_order unsigned)) empty) : @complete_lattice.is_Sup_finite_compact.{0} (complete_linear_order.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (complete_linear_order.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_162034 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (has_neg_part.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_neg_part.{0} name))  := sorry --non-trivial
lemma new_lemma_162035 (h0 : group (ordered_comm_monoid (has_pos_part linarith.comp))) : group.fg (ordered_comm_monoid (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_162036 (h0 : functor.add_const (uniform_space (normed_comm_ring name)) linarith.comp) : @complete_space.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (normed_comm_ring.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_162037 (h0 : topological_space (pseudo_metric_space name)) : preirreducible_space (pseudo_metric_space name) := sorry --non-trivial
lemma new_lemma_162038 (h2 : topological_space std_gen) : totally_disconnected_space std_gen := sorry --non-trivial
lemma new_lemma_162039 (h0 : add_group (semi_normed_comm_ring (has_nnnorm linarith.comp_source))) : is_add_cyclic (semi_normed_comm_ring (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_162040 (h0 : functor.add_const (monoid (finset pos)) pos) : @monoid.fg.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (monoid.{0} (finset.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_162041 (h0 : not (filter (linear_ordered_comm_ring unsigned) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_162042 (h0 : functor.add_const (functor.add_const (topological_space Type) pos) pos) : @preconnected_space.{1} Type (@functor.add_const.run.{1 0} (topological_space.{1} Type) pos (@functor.add_const.run.{1 0} (functor.add_const.{1 0} (topological_space.{1} Type) pos) pos h0))  := sorry --non-trivial
lemma new_lemma_162043 (h0 : not (complete_lattice (mul_zero_class unsigned) -> false)) : @is_compactly_generated.{0} (mul_zero_class.{0} unsigned) (@classical.by_contradiction'.{1} (complete_lattice.{0} (mul_zero_class.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_162044 (h1 : not (topological_space (has_compl linarith.comp_source) -> false)) : @totally_disconnected_space.{0} (has_compl.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (has_compl.{0} linarith.comp_source)) h1)  := sorry --non-trivial
lemma new_lemma_162045 (h1 : group (id linarith.comp)) : normalizer_condition (id linarith.comp) := sorry --non-trivial
lemma new_lemma_162046 (h0 : function.extfun (finset Type) (has_mem.mem (linear_ordered_semiring num))) : @strong_rank_condition.{0} (linear_ordered_semiring.{0} num) (@finset.pi.empty.{1 0} Type ring.{0} (linear_ordered_semiring.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (linear_ordered_semiring.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_162047 (h0 : ring (has_nnnorm (has_nnnorm string.iterator_imp))) : is_domain (has_nnnorm (has_nnnorm string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_162048 (h0 : topological_space (boolean_algebra (has_to_string (has_neg (finset linarith.comp))))) : irreducible_space (boolean_algebra (has_to_string (has_neg (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_162049 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (add_group.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (add_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_162050 (h0 : functor.add_const (topological_space (partial_order unsigned)) congr_arg_kind) : @t1_space.{0} (partial_order.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (partial_order.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_162051 (h0 : topological_space (with_one string_imp)) : irreducible_space (with_one string_imp) := sorry --non-trivial
lemma new_lemma_162052 (h0 : functor.add_const (function.extfun Type group) Type) : @group.fg.{0} (complete_distrib_lattice.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type group.{0}) Type h0) (complete_distrib_lattice.{0} pos))  := sorry --non-trivial
lemma new_lemma_162053 (h0 : std_gen) (h1 : set std_gen) : set.mem h0 h1 := sorry --non-trivial
lemma new_lemma_162054 (h0 : topological_space (add_cancel_comm_monoid to_additive.value_type)) (h1 : preorder (add_cancel_comm_monoid to_additive.value_type)) : order_topology (add_cancel_comm_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_162055 (h0 : cancel_comm_monoid_with_zero (simple_graph (comm_monoid (comm_monoid (option unsigned))))) : unique_factorization_monoid (simple_graph (comm_monoid (comm_monoid (option unsigned)))) := sorry --non-trivial
lemma new_lemma_162056 (h0 : uniform_space (ordered_cancel_add_comm_monoid congr_arg_kind)) : separated_space (ordered_cancel_add_comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_162057 (h0 : functor.add_const (uniform_space (ring linarith.comp)) pos) : @separated_space.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (ring.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_162058 (h0 : topological_space (has_top (random_gen (random_gen (has_top char))))) : t0_space (has_top (random_gen (random_gen (has_top char)))) := sorry --non-trivial
lemma new_lemma_162059 (h0 : group (has_norm (random_gen (random_gen fun_info)))) : is_cyclic (has_norm (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_162060 (h0 : group (measurable_space (semiring unsigned))) : normalizer_condition (measurable_space (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_162061 (h0 : topological_space (distrib (has_inv (dlist fun_info)))) : path_connected_space (distrib (has_inv (dlist fun_info))) := sorry --non-trivial
lemma new_lemma_162062 (h0 : functor.add_const (topological_space (has_add pos)) name) : @irreducible_space.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_162063 (h1 : ring (has_lt std_gen)) : strong_rank_condition (has_lt std_gen) := sorry --non-trivial
lemma new_lemma_162064 (h0 : ring (normed_group (random_gen (random_gen (has_nnnorm char))))) : strong_rank_condition (normed_group (random_gen (random_gen (has_nnnorm char)))) := sorry --non-trivial
lemma new_lemma_162065 (h0 : has_mem.mem complete_lattice has_emptyc.emptyc) : @is_atomistic.{0} (complete_semilattice_Sup.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} h0) (complete_semilattice_Sup.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_162066 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (has_star.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_star.{0} num))  := sorry --non-trivial
lemma new_lemma_162067 (h0 : complete_lattice (has_nndist (has_neg linarith.comp))) : complete_lattice.is_Sup_finite_compact (has_nndist (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_162068 (h0 : functor.add_const (group (comm_group Type)) linarith.comp) : @is_simple_group.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (comm_group.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_162069 (h0 : topological_space (canonically_ordered_comm_semiring empty)) : topological_space.separable_space (canonically_ordered_comm_semiring empty) := sorry --non-trivial
lemma new_lemma_162070 (h0 : list (cancel_monoid (option (option pos)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_162071 (h0 : group (has_add (mul_one_class linarith.comp))) : normalizer_condition (has_add (mul_one_class linarith.comp)) := sorry --non-trivial
lemma new_lemma_162072 (h0 : complete_lattice linarith.comp) : is_compactly_generated linarith.comp := sorry --non-trivial
lemma new_lemma_162073 (h0 : ring (has_emptyc (random_gen (random_gen fun_info)))) : strong_rank_condition (has_emptyc (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_162074 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (random_gen.{0} string_imp) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 monoid.{0}) (random_gen.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_162075 (h0 : topological_space (distrib_lattice (random_gen linarith.ineq))) : totally_separated_space (distrib_lattice (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_162076 (h0 : ring (add_cancel_comm_monoid (has_nnnorm reducibility_hints))) : rank_condition (add_cancel_comm_monoid (has_nnnorm reducibility_hints)) := sorry --non-trivial
lemma new_lemma_162077 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (has_nndist.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_nndist.{0} name))  := sorry --non-trivial
lemma new_lemma_162078 (h0 : add_group (linear_ordered_cancel_comm_monoid num)) : is_add_cyclic (linear_ordered_cancel_comm_monoid num) := sorry --non-trivial
lemma new_lemma_162079 (h0 : has_mem.mem complete_lattice has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} unsigned (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} h0) unsigned)  := sorry --non-trivial
lemma new_lemma_162080 (h0 : not (topological_space (has_nnnorm string.iterator_imp) -> false)) : @path_connected_space.{0} (has_nnnorm.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (topological_space.{0} (has_nnnorm.{0} string.iterator_imp)) h0)  := sorry --non-trivial
lemma new_lemma_162081 (h0 : topological_space (canonically_ordered_monoid (has_add real))) : discrete_topology (canonically_ordered_monoid (has_add real)) := sorry --non-trivial
lemma new_lemma_162082 (h1 : not (complete_lattice (add_cancel_comm_monoid string_imp) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (add_cancel_comm_monoid.{0} string_imp) (@classical.by_contradiction'.{1} (complete_lattice.{0} (add_cancel_comm_monoid.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_162083 (h0 : ring (has_sub (semiring unsigned))) : strong_rank_condition (has_sub (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_162084 (h1 : uniform_space (distrib_lattice string_imp)) : complete_space (distrib_lattice string_imp) := sorry --non-trivial
lemma new_lemma_162085 (h0 : has_one (has_norm num) -> has_one (has_norm num) -> has_one (has_norm num)) : is_right_cancel (has_one (has_norm num)) h0 := sorry --non-trivial
lemma new_lemma_162086 (h0 : ordered_comm_monoid (boolean_algebra Type)) : has_exists_mul_of_le (boolean_algebra Type) := sorry --non-trivial
lemma new_lemma_162087 (h0 : has_zero (has_add congr_arg_kind) -> has_zero (has_add congr_arg_kind) -> Prop) : is_symm (has_zero (has_add congr_arg_kind)) h0 := sorry --non-trivial
lemma new_lemma_162088 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_to_string.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_to_string.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_162089 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (complete_semilattice_Sup.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (complete_semilattice_Sup.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_162090 (h0 : has_lt (has_lt string_imp)) : no_max_order (has_lt string_imp) := sorry --non-trivial
lemma new_lemma_162091 (h0 : group (has_Sup (option (option (option unsigned))))) : normalizer_condition (has_Sup (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_162092 (h0 : functor.add_const (filter (add_cancel_monoid unsigned)) environment.implicit_infer_kind) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_162093 (h0 : topological_space (has_pos_part (has_Inf (has_Inf real)))) : t1_space (has_pos_part (has_Inf (has_Inf real))) := sorry --non-trivial
lemma new_lemma_162094 (h0 : topological_space (ordered_comm_monoid real)) : topological_space.separable_space (ordered_comm_monoid real) := sorry --non-trivial
lemma new_lemma_162095 (h0 : function.extfun Type ring) : @is_domain.{0} (has_to_string.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_to_string.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_162096 (h0 : uniform_space (has_bot (sub_neg_monoid real))) : separated_space (has_bot (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_162097 (h0 : topological_space (add_group (semiring congr_arg_kind))) : totally_disconnected_space (add_group (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_162098 (h0 : group (is_R_or_C (option empty))) : normalizer_condition (is_R_or_C (option empty)) := sorry --non-trivial
lemma new_lemma_162099 (h0 : has_mem.mem (with_bot congr_arg_kind) has_emptyc.emptyc) : @is_atomistic.{0} (with_bot.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (with_bot.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_162100 (h0 : functor.add_const (topological_space (complete_distrib_lattice environment.implicit_infer_kind)) pos) : @sequential_space.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_162101 (h0 : not (function.extfun Type ring -> false)) : @strong_rank_condition.{0} (complete_semilattice_Sup.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (complete_semilattice_Sup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_162102 (h0 : group (canonically_ordered_monoid (has_add Type))) : is_cyclic (canonically_ordered_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_162103 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @strong_rank_condition.{1} (boolean_algebra.core.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ring.{1}) (boolean_algebra.core.{1} Type))  := sorry --non-trivial
lemma new_lemma_162104 (h0 : group (measure_theory.measure_space empty)) : normalizer_condition (measure_theory.measure_space empty) := sorry --non-trivial
lemma new_lemma_162105 (h0 : topological_space (normed_comm_ring unsigned)) : discrete_topology (normed_comm_ring unsigned) := sorry --non-trivial
lemma new_lemma_162106 (h0 : ring (semigroup (finset Type))) : is_domain (semigroup (finset Type)) := sorry --non-trivial
lemma new_lemma_162107 (h0 : functor.add_const (complete_lattice (has_add pos)) (option ennreal)) : @is_atomistic.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_add.{0} pos)) (option.{0} ennreal) h0)  := sorry --non-trivial
lemma new_lemma_162108 (h0 : topological_space (complete_semilattice_Sup (semiring (has_sub congr_arg_kind)))) : irreducible_space (complete_semilattice_Sup (semiring (has_sub congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_162109 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (has_compl.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_compl.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_162110 (h0 : functor.add_const (monoid (has_Inf pos)) (has_Inf Type)) : @monoid.fg.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 1} (monoid.{0} (has_Inf.{0} pos)) (has_Inf.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_162111 (h0 : complete_lattice (add_cancel_monoid (has_Inf name))) : complete_lattice.is_Sup_finite_compact (add_cancel_monoid (has_Inf name)) := sorry --non-trivial
lemma new_lemma_162112 (h0 : group (has_append (has_ssubset (canonically_linear_ordered_add_monoid char)))) : is_cyclic (has_append (has_ssubset (canonically_linear_ordered_add_monoid char))) := sorry --non-trivial
lemma new_lemma_162113 (h0 : topological_space (random_gen (has_norm (has_norm empty)))) : discrete_topology (random_gen (has_norm (has_norm empty))) := sorry --non-trivial
lemma new_lemma_162114 (h0 : functor.add_const (topological_space auto.case_option) num) : @t0_space.{0} auto.case_option (@functor.add_const.run.{0 0} (topological_space.{0} auto.case_option) num h0)  := sorry --non-trivial
lemma new_lemma_162115 (h0 : filter (semi_normed_comm_ring fun_info)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_162116 (h0 : filter (complete_semilattice_Sup (comm_ring linarith.ineq))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_162117 (h0 : fin has_zero.zero) : @t1_space.{0} (generalized_boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (generalized_boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_162118 (h0 : functor.add_const (ring (complete_distrib_lattice linarith.comp)) Type) : @rank_condition.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.add_const.run.{0 1} (ring.{0} (complete_distrib_lattice.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_162119 (h0 : cancel_comm_monoid_with_zero (has_sub (semiring (has_top (semiring num))))) : unique_factorization_monoid (has_sub (semiring (has_top (semiring num)))) := sorry --non-trivial
lemma new_lemma_162120 (h0 : topological_space (distrib_lattice (random_gen string_imp))) : totally_disconnected_space (distrib_lattice (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_162121 (h0 : topological_space (has_Inf linarith.comp)) : sequential_space (has_Inf linarith.comp) := sorry --non-trivial
lemma new_lemma_162122 (h0 : functor.add_const (uniform_space (has_zero name)) Type) : @complete_space.{0} (has_zero.{0} name) (@functor.add_const.run.{0 1} (uniform_space.{0} (has_zero.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_162123 (h0 : topological_space (add_right_cancel_monoid empty)) : t1_space (add_right_cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_162124 (h0 : ring (ring (semigroup (add_comm_monoid name)))) : rank_condition (ring (semigroup (add_comm_monoid name))) := sorry --non-trivial
lemma new_lemma_162125 (h0 : functor.add_const (monoid Type) pos) : @monoid.fg.{1} Type (@functor.add_const.run.{1 0} (monoid.{1} Type) pos h0)  := sorry --non-trivial
lemma new_lemma_162126 (h0 : fin has_zero.zero) : @is_atomistic.{1} (canonically_linear_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (complete_lattice.{1} (canonically_linear_ordered_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_162127 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (add_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_162128 (h0 : list (has_pos_part (has_pos_part linarith.comp))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_162129 (h0 : group (ordered_comm_semiring congr_arg_kind)) : normalizer_condition (ordered_comm_semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_162130 (h0 : topological_space (has_pos_part (has_add Type))) : locally_compact_space (has_pos_part (has_add Type)) := sorry --non-trivial
lemma new_lemma_162131 (h0 : list (boolean_algebra.core (finset name))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_162132 (h0 : topological_space (has_one (has_top num))) : locally_compact_space (has_one (has_top num)) := sorry --non-trivial
lemma new_lemma_162133 (h0 : functor.add_const (monoid (finset environment.implicit_infer_kind)) pos) : @monoid.fg.{0} (finset.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (monoid.{0} (finset.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_162134 (h0 : topological_space (simple_graph (has_Inf name))) : normal_space (simple_graph (has_Inf name)) := sorry --non-trivial
lemma new_lemma_162135 (h0 : topological_space (with_one (semiring num))) : totally_disconnected_space (with_one (semiring num)) := sorry --non-trivial
lemma new_lemma_162136 (h0 : function.extfun Type ring) : @is_domain.{0} (has_ssubset.{0} string_imp) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_ssubset.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_162137 (h0 : functor.add_const (function.extfun (Type 1) group) pos) : @is_cyclic.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) group.{1}) pos h0) (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_162138 (h0 : topological_space (boolean_algebra (ring (mul_one_class Type)))) : t1_space (boolean_algebra (ring (mul_one_class Type))) := sorry --non-trivial
lemma new_lemma_162139 (h0 : function.extfun Type topological_space) : @t1_space.{0} (preorder.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (preorder.{0} empty))  := sorry --non-trivial
lemma new_lemma_162140 (h0 : functor.add_const (cancel_comm_monoid_with_zero (boolean_algebra.core unsigned)) Type) : @unique_factorization_monoid.{0} (boolean_algebra.core.{0} unsigned) (@functor.add_const.run.{0 1} (cancel_comm_monoid_with_zero.{0} (boolean_algebra.core.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_162141 (h0 : ring (preorder congr_arg_kind)) : strong_rank_condition (preorder congr_arg_kind) := sorry --non-trivial
lemma new_lemma_162142 (h0 : group (left_cancel_monoid empty)) : group.fg (left_cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_162143 (h0 : uniform_space (has_neg (has_neg ennreal))) : separated_space (has_neg (has_neg ennreal)) := sorry --non-trivial
lemma new_lemma_162144 (h0 : has_mem.mem (id linarith.comp) has_emptyc.emptyc) : @locally_compact_space.{0} (@id.{2} Type linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (@id.{2} Type linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_162145 (h0 : topological_space (linear_ordered_semiring (semiring (semiring (semiring unsigned))))) : locally_compact_space (linear_ordered_semiring (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_162146 (h0 : group (normed_group (semiring num))) : group.fg (normed_group (semiring num)) := sorry --non-trivial
lemma new_lemma_162147 (h0 : complete_lattice (linear_ordered_field (comm_group (cancel_monoid (has_neg_part ennreal))))) : is_atomistic (linear_ordered_field (comm_group (cancel_monoid (has_neg_part ennreal)))) := sorry --non-trivial
lemma new_lemma_162148 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (@id.{2} Type linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (@id.{2} Type linarith.comp))  := sorry --non-trivial
lemma new_lemma_162149 (h0 : set (distrib string.iterator_imp)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_162150 (h0 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} (has_norm.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_norm.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_162151 (h0 : ring (encodable linarith.comp_source)) : rank_condition (encodable linarith.comp_source) := sorry --non-trivial
lemma new_lemma_162152 (h0 : list (has_to_string (ring Type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_162153 (h0 : topological_space (left_cancel_monoid (option unsigned))) : path_connected_space (left_cancel_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_162154 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (mul_zero_class.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (mul_zero_class.{0} empty))  := sorry --non-trivial
lemma new_lemma_162155 (h0 : topological_space (fintype string_imp)) : path_connected_space (fintype string_imp) := sorry --non-trivial
lemma new_lemma_162156 (h0 : topological_space (comm_group (add_cancel_monoid linarith.comp))) : regular_space (comm_group (add_cancel_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_162157 (h0 : topological_space (id (semiring (semiring (semiring (semiring empty)))))) : path_connected_space (id (semiring (semiring (semiring (semiring empty))))) := sorry --non-trivial
lemma new_lemma_162158 (h0 : fin has_zero.zero) : @loc_path_connected_space.{1} (complete_distrib_lattice.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (complete_distrib_lattice.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_162159 (h0 : functor.add_const (topological_space (add_cancel_monoid linarith.comp)) pos) : @normal_space.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_162160 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_ssubset.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_ssubset.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_162161 (h0 : not (ring (comm_semigroup fun_info) -> false)) : @strong_rank_condition.{0} (comm_semigroup.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (comm_semigroup.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_162162 (h0 : topological_space (distrib (denumerable (denumerable (denumerable (denumerable fun_info)))))) : path_connected_space (distrib (denumerable (denumerable (denumerable (denumerable fun_info))))) := sorry --non-trivial
lemma new_lemma_162163 (h0 : functor.add_const (topological_space (normed_linear_ordered_group empty)) congr_arg_kind) : @totally_separated_space.{0} (normed_linear_ordered_group.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_linear_ordered_group.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_162164 (h0 : function.extfun Type group) : @group.fg.{0} (ordered_cancel_add_comm_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} h0 (ordered_cancel_add_comm_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_162165 (h0 : ring (add_comm_monoid (option pos))) : rank_condition (add_comm_monoid (option pos)) := sorry --non-trivial
lemma new_lemma_162166 (h1 : uniform_space (measurable_space linarith.comp_source)) : complete_space (measurable_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_162167 (h0 : functor.add_const (list (canonically_ordered_comm_semiring name)) pos) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_162168 (h0 : ereal -> ereal -> Prop) : is_total ereal h0 := sorry --non-trivial
lemma new_lemma_162169 (h0 : topological_space (boolean_algebra (has_pos_part pos))) : t0_space (boolean_algebra (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_162170 (h0 : function.extfun ((group linarith.ineq -> false) -> Prop) (function.extfun (group linarith.ineq -> false))) : @is_cyclic.{0} linarith.ineq (@classical.by_contradiction'.{1} (group.{0} linarith.ineq) (@function.extfun_app.{0 0} (group.{0} linarith.ineq → false) (λ (x : group.{0} linarith.ineq → false), false) (@function.extfun_app.{1 0} ((group.{0} linarith.ineq → false) → Prop) (function.extfun.{0 0} (group.{0} linarith.ineq → false)) h0 (λ (x : group.{0} linarith.ineq → false), false))))  := sorry --non-trivial
lemma new_lemma_162171 (h0 : functor.add_const (ring (finset environment.implicit_infer_kind)) linarith.comp) : @strong_rank_condition.{0} (finset.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (finset.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_162172 (h0 : functor.add_const (ring (has_add linarith.comp)) (ring Type)) : @is_domain.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 1} (ring.{0} (has_add.{0} linarith.comp)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_162173 (h0 : topological_space (has_to_string (option ennreal))) : totally_separated_space (has_to_string (option ennreal)) := sorry --non-trivial
lemma new_lemma_162174 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring linarith.comp)) pos) : @normal_space.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_162175 (h0 : filter (option (semiring (has_top (semiring (semiring empty)))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_162176 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (partial_order.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (partial_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_162177 (h0 : uniform_space (ring (boolean_algebra (has_Inf name)))) : complete_space (ring (boolean_algebra (has_Inf name))) := sorry --non-trivial
lemma new_lemma_162178 (h0 : topological_space (has_zero (has_nndist (finset name)))) : regular_space (has_zero (has_nndist (finset name))) := sorry --non-trivial
lemma new_lemma_162179 (h0 : functor.comp group cancel_monoid Type) : @group.fg.{1} (cancel_monoid.{1} Type) (@functor.comp.run.{1 1 1} group.{1} cancel_monoid.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_162180 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (linear_ordered_comm_group.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_comm_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_162181 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_edist.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_edist.{0} empty))  := sorry --non-trivial
lemma new_lemma_162182 (h0 : function.extfun Type ring) : @is_domain.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_162183 (h0 : list (semigroup (has_zero Type))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_162184 (h0 : add_monoid (semiring (metric_space linarith.comp))) : add_monoid.fg (semiring (metric_space linarith.comp)) := sorry --non-trivial
lemma new_lemma_162185 (h0 : fin has_zero.zero) : @is_domain.{1} (sub_neg_monoid.{1} (has_add.{1} (has_pos_part.{1} Type))) (@matrix.vec_empty.{1} (ring.{1} (sub_neg_monoid.{1} (has_add.{1} (has_pos_part.{1} Type)))) h0)  := sorry --non-trivial
lemma new_lemma_162186 (h0 : group (ordered_cancel_add_comm_monoid (monoid_with_zero pos))) : is_simple_group (ordered_cancel_add_comm_monoid (monoid_with_zero pos)) := sorry --non-trivial
lemma new_lemma_162187 (h0 : add_group (random_gen (has_inv (has_inv (has_inv linarith.ineq))))) : is_add_cyclic (random_gen (has_inv (has_inv (has_inv linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_162188 (h0 : list (complete_distrib_lattice unsigned)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_162189 (h0 : functor.add_const (topological_space (mul_zero_class num)) num) : @locally_compact_space.{0} (mul_zero_class.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_162190 (h1 : uniform_space (metric_space to_additive.value_type)) : complete_space (metric_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_162191 (h0 : has_add (has_add real) -> real -> real) : left_commutative h0 := sorry --non-trivial
lemma new_lemma_162192 (h0 : function.extfun Type group) : @normalizer_condition.{0} (measurable_space.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} h0 (measurable_space.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_162193 (h0 : topological_space (with_bot linarith.comp_source)) : irreducible_space (with_bot linarith.comp_source) := sorry --non-trivial
lemma new_lemma_162194 (h0 : functor.add_const (topological_space (complete_distrib_lattice empty)) empty) : @irreducible_space.{0} (complete_distrib_lattice.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_162195 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (measurable_space.dynkin_system.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measurable_space.dynkin_system.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_162196 (h0 : list (ring (boolean_algebra environment.implicit_infer_kind))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_162197 (h0 : functor.comp ring cancel_monoid pos) : @strong_rank_condition.{0} (cancel_monoid.{0} pos) (@functor.comp.run.{0 0 0} ring.{0} cancel_monoid.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_162198 (h0 : functor.comp monoid semigroup name) : @monoid.fg.{0} (semigroup.{0} name) (@functor.comp.run.{0 0 0} monoid.{0} semigroup.{0} name h0)  := sorry --non-trivial
lemma new_lemma_162199 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (monoid.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_162200 (h0 : functor.add_const (group (has_zero unsigned)) linarith.comp) : @is_simple_group.{0} (has_zero.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (has_zero.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_162201 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : separated_space nnreal := sorry --non-trivial
lemma new_lemma_162202 (h0 : not (fin has_zero.zero -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (semi_normed_comm_ring.{0} char) (@matrix.vec_empty.{0} (complete_lattice.{0} (semi_normed_comm_ring.{0} char)) (@classical.by_contradiction'.{1} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_162203 (h0 : functor.add_const (function.extfun (Type 1) complete_lattice) linarith.comp) : @is_compactly_generated.{1} (comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) complete_lattice.{1}) linarith.comp h0) (comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_162204 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (bin_tree.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (bin_tree.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_162205 (h0 : uniform_space (pseudo_metric_space (option unsigned))) : complete_space (pseudo_metric_space (option unsigned)) := sorry --non-trivial
lemma new_lemma_162206 (h0 : topological_space (ordered_comm_monoid Type)) : t0_space (ordered_comm_monoid Type) := sorry --non-trivial
lemma new_lemma_162207 (h1 : ring (distrib_lattice (random_gen string_imp))) : rank_condition (distrib_lattice (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_162208 (h0 : functor.add_const (functor.add_const (complete_lattice (normed_comm_ring linarith.comp)) Type) Type) : @is_compactly_generated.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (complete_lattice.{0} (normed_comm_ring.{0} linarith.comp)) Type (@functor.add_const.run.{0 1} (functor.add_const.{0 1} (complete_lattice.{0} (normed_comm_ring.{0} linarith.comp)) Type) Type h0))  := sorry --non-trivial
lemma new_lemma_162209 (h0 : functor.add_const (topological_space (has_Inf Type)) Type) : @preconnected_space.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_Inf.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_162210 (h0 : functor.add_const (topological_space (plift congr_arg_kind)) congr_arg_kind) : @t0_space.{1} (plift.{1} congr_arg_kind) (@functor.add_const.run.{1 0} (topological_space.{1} (plift.{1} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_162211 (h2 : uniform_space reducibility_hints) : complete_space reducibility_hints := sorry --non-trivial
lemma new_lemma_162212 (h0 : topological_space (with_one (measurable_space linarith.comp_source))) : totally_separated_space (with_one (measurable_space linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_162213 (h0 : functor.comp topological_space ring Type) : @topological_space.separable_space.{1} (ring.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} ring.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_162214 (h0 : ring (add_monoid fun_info)) : strong_rank_condition (add_monoid fun_info) := sorry --non-trivial
lemma new_lemma_162215 (h0 : list (has_nndist (add_comm_monoid environment.implicit_infer_kind))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_162216 (h0 : functor.add_const (ring (has_neg_part name)) (add_cancel_monoid ennreal)) : @strong_rank_condition.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (has_neg_part.{0} name)) (add_cancel_monoid.{0} ennreal) h0)  := sorry --non-trivial
lemma new_lemma_162217 (h2 : topological_space (complete_semilattice_Sup string_imp)) : t0_space (complete_semilattice_Sup string_imp) := sorry --non-trivial
lemma new_lemma_162218 (h1 : add_group (has_compl to_additive.value_type)) : is_add_cyclic (has_compl to_additive.value_type) := sorry --non-trivial
lemma new_lemma_162219 (h0 : monoid (linear_ordered_semiring (has_top num))) : monoid.fg (linear_ordered_semiring (has_top num)) := sorry --non-trivial
lemma new_lemma_162220 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (canonically_ordered_comm_semiring ennreal)) := sorry --non-trivial
lemma new_lemma_162221 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @irreducible_space.{0} (random_gen.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (random_gen.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_162222 (h0 : function.extfun Type topological_space) : @t0_space.{0} (linear_ordered_field.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_field.{0} empty))  := sorry --non-trivial
lemma new_lemma_162223 (h1 : complete_lattice (fintype to_additive.value_type)) : is_compactly_generated (fintype to_additive.value_type) := sorry --non-trivial
lemma new_lemma_162224 (h0 : add_group (semi_normed_comm_ring (mul_one_class linarith.ineq))) : is_add_cyclic (semi_normed_comm_ring (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_162225 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (random_gen.{0} string_imp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (random_gen.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_162226 (h0 : functor.add_const (monoid (finset linarith.comp)) pos) : @monoid.fg.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (monoid.{0} (finset.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_162227 (h0 : group (has_to_string (comm_group pos))) : normalizer_condition (has_to_string (comm_group pos)) := sorry --non-trivial
lemma new_lemma_162228 (h0 : ring (has_neg num)) : is_domain (has_neg num) := sorry --non-trivial
lemma new_lemma_162229 (h0 : cancel_comm_monoid_with_zero (finset (semigroup Type))) : unique_factorization_monoid (finset (semigroup Type)) := sorry --non-trivial
lemma new_lemma_162230 (h0 : group (normed_group to_additive.value_type)) : is_cyclic (normed_group to_additive.value_type) := sorry --non-trivial
lemma new_lemma_162231 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : palindrome (function.extfun_app (function.extfun_app h0 list) (ordered_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_162232 (h1 : group (topological_space (random_gen string_imp))) : is_cyclic (topological_space (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_162233 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (sub_neg_monoid.{0} real) (@function.extfun_app.{2 1} Type semiring.{0} h0 (sub_neg_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_162234 (h0 : complete_lattice (ring (ring pos))) : is_compactly_generated (ring (ring pos)) := sorry --non-trivial
lemma new_lemma_162235 (h0 : complete_linear_order unsigned -> complete_linear_order unsigned -> Prop) : is_strict_order (complete_linear_order unsigned) h0 := sorry --non-trivial
lemma new_lemma_162236 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_inv.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inv.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_162237 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @regular_space.{0} (comm_group.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (comm_group.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_162238 (h0 : topological_space (comm_group (normed_comm_ring linarith.comp))) : discrete_topology (comm_group (normed_comm_ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_162239 (h0 : semiring (with_bot (with_bot unsigned))) : is_noetherian_ring (with_bot (with_bot unsigned)) := sorry --non-trivial
lemma new_lemma_162240 (h0 : group (has_union (semiring congr_arg_kind))) : normalizer_condition (has_union (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_162241 (h0 : functor.add_const (topological_space (boolean_algebra unsigned)) Type) : @totally_disconnected_space.{0} (boolean_algebra.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_162242 (h0 : complete_lattice (complete_distrib_lattice real)) : is_compactly_generated (complete_distrib_lattice real) := sorry --non-trivial
lemma new_lemma_162243 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_to_string.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (has_to_string.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_162244 (h0 : functor.add_const (group (left_cancel_monoid num)) num) : @group.fg.{0} (left_cancel_monoid.{0} num) (@functor.add_const.run.{0 0} (group.{0} (left_cancel_monoid.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_162245 (h0 : ring (normed_group (semiring (has_emptyc empty)))) : rank_condition (normed_group (semiring (has_emptyc empty))) := sorry --non-trivial
lemma new_lemma_162246 (h0 : not (group (has_compl linarith.ineq) -> false)) : @is_cyclic.{0} (has_compl.{0} linarith.ineq) (@classical.by_contradiction'.{1} (group.{0} (has_compl.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_162247 (h0 : list (has_nndist (finset pos))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_162248 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (option.{0} (canonically_linear_ordered_monoid.{0} pos)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (option.{0} (canonically_linear_ordered_monoid.{0} pos)))  := sorry --non-trivial
lemma new_lemma_162249 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (has_add.{0} real) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (has_add.{0} real))  := sorry --non-trivial
lemma new_lemma_162250 (h0 : ring (denumerable linarith.ineq)) : strong_rank_condition (denumerable linarith.ineq) := sorry --non-trivial
lemma new_lemma_162251 (h0 : semiring (comm_semigroup (canonically_linear_ordered_monoid (ordered_comm_monoid Type)))) : is_noetherian_ring (comm_semigroup (canonically_linear_ordered_monoid (ordered_comm_monoid Type))) := sorry --non-trivial
lemma new_lemma_162252 (h0 : set (prod (has_add (has_add pos)) (has_add (has_add pos)))) : symmetric_rel h0 := sorry --non-trivial
lemma new_lemma_162253 (h1 : not (ring (random_gen char) -> false)) : @is_domain.{0} (random_gen.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (random_gen.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_162254 (h0 : topological_space (has_norm (has_top (has_top fun_info)))) : totally_disconnected_space (has_norm (has_top (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_162255 (h0 : functor.add_const (group environment.implicit_infer_kind) (semigroup Type)) : @normalizer_condition.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 1} (group.{0} environment.implicit_infer_kind) (semigroup.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_162256 (h0 : functor.add_const (monoid (ring linarith.comp)) pos) : @monoid.fg.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (monoid.{0} (ring.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_162257 (h0 : topological_space (has_neg (finset pos))) : loc_path_connected_space (has_neg (finset pos)) := sorry --non-trivial
lemma new_lemma_162258 (h0 : group (div_inv_monoid (has_nnnorm to_additive.value_type))) : is_cyclic (div_inv_monoid (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_162259 (h1 : measurable_space (nondiscrete_normed_field reducibility_hints)) (h2 : measure_theory.measure (nondiscrete_normed_field reducibility_hints)) : measure_theory.is_finite_measure h2 := sorry --non-trivial
lemma new_lemma_162260 (h0 : topological_space (comm_ring (random_gen (random_gen (random_gen fun_info))))) : totally_disconnected_space (comm_ring (random_gen (random_gen (random_gen fun_info)))) := sorry --non-trivial
lemma new_lemma_162261 (h0 : filter (has_one (semiring (semiring (has_union (semiring empty)))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_162262 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (semiring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (semiring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_162263 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (generalized_boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (generalized_boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_162264 (h0 : group (boolean_algebra.core pos)) : group.fg (boolean_algebra.core pos) := sorry --non-trivial
lemma new_lemma_162265 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (has_Sup.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_Sup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_162266 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (has_zero.{0} (option.{0} ennreal)) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_zero.{0} (option.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_162267 (h0 : functor.add_const (complete_lattice (left_cancel_semigroup num)) num) : @complete_lattice.is_Sup_finite_compact.{0} (left_cancel_semigroup.{0} num) (@functor.add_const.run.{0 0} (complete_lattice.{0} (left_cancel_semigroup.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_162268 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @regular_space.{0} (ring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ring.{0} name))  := sorry --non-trivial
lemma new_lemma_162269 (h0 : topological_space (semigroup (has_to_string pos))) : discrete_topology (semigroup (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_162270 (h0 : functor.add_const (topological_space (ordered_comm_ring Type)) pos) : @preconnected_space.{1} (ordered_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ordered_comm_ring.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_162271 (h0 : functor.add_const (topological_space (boolean_algebra unsigned)) environment.implicit_infer_kind) : @t0_space.{0} (boolean_algebra.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_162272 (h0 : group (comm_semigroup (has_Inf name))) : is_cyclic (comm_semigroup (has_Inf name)) := sorry --non-trivial
lemma new_lemma_162273 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (has_norm.{0} num) (@function.extfun_app.{2 1} Type monoid.{0} h0 (has_norm.{0} num))  := sorry --non-trivial
lemma new_lemma_162274 (h0 : add_comm_semigroup ereal -> add_comm_semigroup ereal -> add_comm_semigroup ereal) : set.finite (left_identity h0) := sorry --non-trivial
lemma new_lemma_162275 (h0 : add_group string.iterator_imp) : is_add_cyclic string.iterator_imp := sorry --non-trivial
lemma new_lemma_162276 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (ordered_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_162277 (h0 : functor.add_const (ordered_comm_monoid (has_Inf linarith.comp)) (has_neg linarith.comp)) : @has_exists_mul_of_le.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_Inf.{0} linarith.comp)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_162278 (h0 : functor.add_const (functor.add_const (uniform_space Type) linarith.comp) linarith.comp) : @complete_space.{1} Type (@functor.add_const.run.{1 0} (uniform_space.{1} Type) linarith.comp (@functor.add_const.run.{1 0} (functor.add_const.{1 0} (uniform_space.{1} Type) linarith.comp) linarith.comp h0))  := sorry --non-trivial
lemma new_lemma_162279 (h0 : not (uniform_space (left_cancel_semigroup congr_arg_kind) -> false)) : @complete_space.{0} (left_cancel_semigroup.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (uniform_space.{0} (left_cancel_semigroup.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_162280 (h0 : topological_space (semiring (option unsigned))) : locally_compact_space (semiring (option unsigned)) := sorry --non-trivial
lemma new_lemma_162281 (h1 : group (add_left_cancel_monoid (has_neg to_additive.value_type))) : is_cyclic (add_left_cancel_monoid (has_neg to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_162282 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (has_to_string.{0} name) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (has_to_string.{0} name))  := sorry --non-trivial
lemma new_lemma_162283 (h0 : functor.add_const (topological_space (option empty)) num) : @locally_compact_space.{0} (option.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_162284 (h0 : functor.add_const (add_monoid (comm_group unsigned)) unsigned) : @add_monoid.fg.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (add_monoid.{0} (comm_group.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_162285 (h0 : finset (add_cancel_monoid (option pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_162286 (h0 : function.extfun Type ring) : @is_domain.{0} (ordered_cancel_add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (ordered_cancel_add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_162287 (h0 : topological_space (generalized_boolean_algebra (has_pos_part (finset linarith.comp)))) : sequential_space (generalized_boolean_algebra (has_pos_part (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_162288 (h0 : add_group (is_R_or_C num)) : is_add_cyclic (is_R_or_C num) := sorry --non-trivial
lemma new_lemma_162289 (h0 : topological_space (complete_distrib_lattice (comm_group name))) : sequential_space (complete_distrib_lattice (comm_group name)) := sorry --non-trivial
lemma new_lemma_162290 (h0 : topological_space (has_dist empty)) : topological_space.separable_space (has_dist empty) := sorry --non-trivial
lemma new_lemma_162291 (h0 : not (topological_space (has_star congr_arg_kind) -> false)) : @preirreducible_space.{0} (has_star.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (has_star.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_162292 (h0 : functor.add_const (topological_space (mul_zero_class empty)) unsigned) : @preirreducible_space.{0} (mul_zero_class.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_162293 (h0 : group (has_top (semiring (semiring (semiring num))))) : normalizer_condition (has_top (semiring (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_162294 (h0 : group (normed_lattice_add_comm_group (has_add (has_Inf (has_add (has_bot real)))))) : normalizer_condition (normed_lattice_add_comm_group (has_add (has_Inf (has_add (has_bot real))))) := sorry --non-trivial
lemma new_lemma_162295 (h0 : finset (has_to_string (mul_one_class (has_nndist linarith.comp)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_162296 (h0 : fin has_zero.zero) : @irreducible_space.{0} (sub_neg_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (sub_neg_monoid.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_162297 (h0 : monoid (has_neg (ring linarith.comp))) : monoid.fg (has_neg (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_162298 (h0 : group (has_top unsigned)) : group.fg (has_top unsigned) := sorry --non-trivial
lemma new_lemma_162299 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @sequential_space.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_162300 (h0 : functor.add_const (topological_space (normed_comm_ring environment.implicit_infer_kind)) name) : @regular_space.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_162301 (h0 : finset (normed_comm_ring (option ennreal))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_162302 (h1 : add_group (normed_field (normed_field linarith.ineq))) : is_add_cyclic (normed_field (normed_field linarith.ineq)) := sorry --non-trivial
lemma new_lemma_162303 (h0 : topological_space (has_bot (has_neg (has_neg name)))) : locally_compact_space (has_bot (has_neg (has_neg name))) := sorry --non-trivial
lemma new_lemma_162304 (h0 : functor.add_const (group (canonically_ordered_comm_semiring ennreal)) name) : @normalizer_condition.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@functor.add_const.run.{0 0} (group.{0} (canonically_ordered_comm_semiring.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_162305 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (@id.{2} Type linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 ring.{0}) (@id.{2} Type linarith.comp))  := sorry --non-trivial
lemma new_lemma_162306 (h0 : functor.add_const (topological_space (comm_group unsigned)) unsigned) : @irreducible_space.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_162307 (h0 : ordered_comm_monoid (ordered_comm_ring (ring (ring linarith.comp)))) : has_exists_mul_of_le (ordered_comm_ring (ring (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_162308 (h0 : topological_space (has_Inf (has_nndist pos))) : regular_space (has_Inf (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_162309 (h0 : filter (ring (ring Type))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_162310 (h0 : ring Type) : is_principal_ideal_ring Type := sorry --non-trivial
lemma new_lemma_162311 (h0 : monoid (has_neg (has_add unsigned))) : monoid.fg (has_neg (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_162312 (h0 : group (cancel_monoid empty)) : is_cyclic (cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_162313 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (with_one.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type monoid.{0} h0 (with_one.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_162314 (h0 : function.extfun Type (functor.add_const (complete_lattice (bin_tree empty)))) : @complete_lattice.is_Sup_finite_compact.{0} (bin_tree.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (bin_tree.{0} empty)) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (complete_lattice.{0} (bin_tree.{0} empty))) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_162315 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (linear_ordered_semiring.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (linear_ordered_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_162316 (h0 : topological_space (add_cancel_comm_monoid unsigned)) : discrete_topology (add_cancel_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_162317 (h2 : measurable_space (has_ssubset char)) (h3 : filter (has_ssubset char)) : filter.is_measurably_generated h3 := sorry --non-trivial
lemma new_lemma_162318 (h0 : not (add_group (topological_space reducibility_hints) -> false)) : @is_add_cyclic.{0} (topological_space.{0} reducibility_hints) (@classical.by_contradiction'.{1} (add_group.{0} (topological_space.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_162319 (h0 : semiring (canonically_ordered_comm_semiring (ring (ring linarith.comp)))) : is_noetherian_ring (canonically_ordered_comm_semiring (ring (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_162320 (h0 : ring (has_top fun_info)) : rank_condition (has_top fun_info) := sorry --non-trivial
lemma new_lemma_162321 (h0 : topological_space (has_add (has_pos_part (has_bot (has_Inf (has_Inf real)))))) : loc_path_connected_space (has_add (has_pos_part (has_bot (has_Inf (has_Inf real))))) := sorry --non-trivial
lemma new_lemma_162322 (h0 : add_monoid (canonically_ordered_comm_semiring Type)) : add_monoid.fg (canonically_ordered_comm_semiring Type) := sorry --non-trivial
lemma new_lemma_162323 (h0 : ring (has_top (has_top linarith.comp_source))) : is_principal_ideal_ring (has_top (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_162324 (h0 : functor.comp topological_space ring name) : @totally_disconnected_space.{0} (ring.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} ring.{0} name h0)  := sorry --non-trivial
lemma new_lemma_162325 (h0 : functor.add_const (topological_space (boolean_algebra.core pos)) name) : @discrete_topology.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_162326 (h0 : ring (ordered_comm_ring (has_add (has_add real)))) : rank_condition (ordered_comm_ring (has_add (has_add real))) := sorry --non-trivial
lemma new_lemma_162327 (h0 : ordered_comm_monoid (has_zero (ring Type))) : has_exists_mul_of_le (has_zero (ring Type)) := sorry --non-trivial
lemma new_lemma_162328 (h0 : function.extfun Type group) : @normalizer_condition.{0} (random_gen.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} h0 (random_gen.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_162329 (h0 : filter (has_nndist (option (option (option ennreal))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_162330 (h0 : topological_space (has_nndist (comm_group pos))) : regular_space (has_nndist (comm_group pos)) := sorry --non-trivial
lemma new_lemma_162331 (h0 : topological_space (has_zero (has_pos_part (has_neg (finset Type))))) : path_connected_space (has_zero (has_pos_part (has_neg (finset Type)))) := sorry --non-trivial
lemma new_lemma_162332 (h0 : finset (boolean_algebra.core (has_add (boolean_algebra linarith.comp)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_162333 (h0 : list congr_arg_kind) : palindrome h0 := sorry --non-trivial
lemma new_lemma_162334 (h0 : function.extfun Type group) : @is_simple_group.{0} (has_neg.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} h0 (has_neg.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_162335 (h0 : topological_space (add_right_cancel_monoid (semiring congr_arg_kind))) : irreducible_space (add_right_cancel_monoid (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_162336 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (free_add_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} h0 (free_add_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_162337 (h0 : function.extfun Type (functor.comp topological_space has_to_string)) : @sequential_space.{0} (has_to_string.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} has_to_string.{0} name (@functor.comp.run.{0 0 0} topological_space.{0} has_to_string.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} has_to_string.{0}) h0 name)))  := sorry --non-trivial
lemma new_lemma_162338 (h0 : topological_space (ring num)) : t0_space (ring num) := sorry --non-trivial
lemma new_lemma_162339 (h0 : topological_space (complete_distrib_lattice (option (option (option (option pos)))))) : preconnected_space (complete_distrib_lattice (option (option (option (option pos))))) := sorry --non-trivial
lemma new_lemma_162340 (h0 : function.extfun Type topological_space) : @t0_space.{0} (canonically_linear_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_linear_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_162341 (h0 : has_mem.mem (random_gen to_additive.value_type) has_emptyc.emptyc) : @discrete_topology.{0} (random_gen.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type topological_space.{0} (random_gen.{0} to_additive.value_type) h0)  := sorry --non-trivial
lemma new_lemma_162342 (h2 : topological_space (with_bot num)) : t0_space (with_bot num) := sorry --non-trivial
lemma new_lemma_162343 (h0 : functor.add_const Prop (boolean_algebra (has_neg linarith.comp))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_162344 (h3 : group (with_one num)) : group.fg (with_one num) := sorry --non-trivial
lemma new_lemma_162345 (h0 : functor.add_const (topological_space (comm_group unsigned)) environment.implicit_infer_kind) : @t1_space.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_162346 (h0 : filter (ring (boolean_algebra environment.implicit_infer_kind))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_162347 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (pseudo_metric_space ennreal)) := sorry --non-trivial
lemma new_lemma_162348 (h0 : functor.add_const (function.extfun Type uniform_space) (has_add ennreal)) : @complete_space.{0} (comm_group.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) (has_add.{0} ennreal) h0) (comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_162349 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @t0_space.{0} (random_gen.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (random_gen.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_162350 (h0 : uniform_space (add_left_cancel_monoid (has_inv linarith.ineq))) : complete_space (add_left_cancel_monoid (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_162351 (h0 : filter (comm_ring linarith.comp_source)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_162352 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_atomistic.{1} (normed_lattice_add_comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 complete_lattice.{1}) (normed_lattice_add_comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_162353 (h2 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h2 complete_lattice.{0}) (complete_semilattice_Sup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_162354 (h0 : functor.add_const (ordered_add_comm_monoid (has_add unsigned)) (has_neg name)) : @archimedean.{0} (has_add.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_add.{0} unsigned)) (has_neg.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_162355 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @locally_compact_space.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_162356 (h0 : filter (comm_group (has_neg_part linarith.comp))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_162357 (h0 : topological_space (has_add (ring pos))) : t1_space (has_add (ring pos)) := sorry --non-trivial
lemma new_lemma_162358 (h0 : functor.add_const (ring (as_linear_order unsigned)) unsigned) : @is_domain.{0} (as_linear_order.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (as_linear_order.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_162359 (h0 : topological_space (has_bot (canonically_ordered_monoid Type))) : totally_separated_space (has_bot (canonically_ordered_monoid Type)) := sorry --non-trivial
lemma new_lemma_162360 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @sequential_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_cancel_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_162361 (h0 : functor.add_const (topological_space (finset empty)) num) : @t1_space.{0} (finset.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_162362 (h0 : function.extfun Type topological_space) : @regular_space.{0} (ordered_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_162363 (h0 : not (function.extfun Type monoid -> false)) : @monoid.fg.{0} empty (@function.extfun_app.{2 1} Type monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type monoid.{0}) h0) empty)  := sorry --non-trivial
lemma new_lemma_162364 (h0 : monoid (random_gen (normed_linear_ordered_group (has_union empty)))) : monoid.fg (random_gen (normed_linear_ordered_group (has_union empty))) := sorry --non-trivial
lemma new_lemma_162365 (h0 : topological_space (has_pos_part (has_Inf (has_add (has_Inf (has_Inf real)))))) : discrete_topology (has_pos_part (has_Inf (has_add (has_Inf (has_Inf real))))) := sorry --non-trivial
lemma new_lemma_162366 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (with_one.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} h0 (with_one.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_162367 (h0 : ring (filter (add_left_cancel_semigroup unsigned))) : rank_condition (filter (add_left_cancel_semigroup unsigned)) := sorry --non-trivial
lemma new_lemma_162368 (h0 : ring (simple_graph empty)) : rank_condition (simple_graph empty) := sorry --non-trivial
lemma new_lemma_162369 (h0 : add_group (ordered_comm_ring (has_neg (boolean_algebra.core linarith.comp)))) : is_add_cyclic (ordered_comm_ring (has_neg (boolean_algebra.core linarith.comp))) := sorry --non-trivial
lemma new_lemma_162370 (h0 : fin has_zero.zero) : @loc_path_connected_space.{0} (simple_graph.{0} (has_add.{0} linarith.comp)) (@matrix.vec_empty.{0} (topological_space.{0} (simple_graph.{0} (has_add.{0} linarith.comp))) h0)  := sorry --non-trivial
lemma new_lemma_162371 (h0 : function.extfun Type (functor.add_const (complete_lattice (linear_ordered_cancel_comm_monoid empty)))) : @is_compactly_generated.{0} (linear_ordered_cancel_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (linear_ordered_cancel_comm_monoid.{0} empty)) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (complete_lattice.{0} (linear_ordered_cancel_comm_monoid.{0} empty))) h0 num))  := sorry --non-trivial
lemma new_lemma_162372 (h0 : group (has_add (option (option pos)))) : is_simple_group (has_add (option (option pos))) := sorry --non-trivial
lemma new_lemma_162373 (h0 : ring (comm_ring (random_gen (has_nnnorm (random_gen linarith.comp_source))))) : is_domain (comm_ring (random_gen (has_nnnorm (random_gen linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_162374 (h0 : complete_lattice (finset num)) : complete_lattice.is_Sup_finite_compact (finset num) := sorry --non-trivial
lemma new_lemma_162375 (h0 : ring (has_nndist (option (option num)))) : is_principal_ideal_ring (has_nndist (option (option num))) := sorry --non-trivial
lemma new_lemma_162376 (h0 : not (topological_space (option num) -> false)) : @totally_disconnected_space.{0} (option.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (option.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_162377 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (ordered_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (ordered_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_162378 (h0 : add_group (has_norm (random_gen (random_gen to_additive.value_type)))) : is_add_cyclic (has_norm (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_162379 (h0 : semiring (has_star (semiring (semiring (semiring unsigned))))) : is_noetherian_ring (has_star (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_162380 (h0 : topological_space (simple_graph (has_to_string Type))) : preconnected_space (simple_graph (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_162381 (h0 : topological_space (complete_linear_order (semiring (semiring empty)))) : irreducible_space (complete_linear_order (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_162382 (h0 : functor.add_const (topological_space (boolean_algebra linarith.comp)) pos) : @regular_space.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_162383 (h0 : topological_space (option (has_add (option (option ennreal))))) : t0_space (option (has_add (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_162384 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @sequential_space.{0} (generalized_boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (generalized_boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_162385 (h0 : ring (has_to_string (option name))) : strong_rank_condition (has_to_string (option name)) := sorry --non-trivial
lemma new_lemma_162386 (h0 : complete_lattice (normed_comm_ring (semiring unsigned))) : is_compactly_generated (normed_comm_ring (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_162387 (h0 : fin has_zero.zero) : countable_Inter_filter (function.extfun_app (matrix.vec_empty h0) (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_162388 (h0 : ring (is_R_or_C unsigned)) : is_principal_ideal_ring (is_R_or_C unsigned) := sorry --non-trivial
lemma new_lemma_162389 (h0 : list (has_well_founded string_imp)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_162390 (h0 : group (has_bot (has_add real))) : normalizer_condition (has_bot (has_add real)) := sorry --non-trivial
lemma new_lemma_162391 (h0 : function.extfun Type (functor.comp filter has_neg)) : countable_Inter_filter (functor.comp.run (function.extfun_app h0 environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_162392 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @totally_disconnected_space.{0} (has_nndist.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (has_nndist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_162393 (h1 : function.extfun Type monoid) : @monoid.fg.{0} (normed_group.{0} linarith.ineq) (@function.extfun_app.{2 1} Type monoid.{0} h1 (normed_group.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_162394 (h1 : measurable_space (has_compl string_imp)) (h2 : filter (has_compl string_imp)) : filter.is_measurably_generated h2 := sorry --non-trivial
lemma new_lemma_162395 (h0 : topological_space (distrib (has_nnnorm fun_info))) : totally_disconnected_space (distrib (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_162396 (h0 : functor.add_const (function.extfun (Type 1) topological_space) linarith.comp) : @loc_path_connected_space.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) linarith.comp h0) (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_162397 (h0 : functor.add_const (filter auto.case_option) (option (option unsigned))) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_162398 (h0 : functor.add_const (topological_space (has_zero name)) linarith.comp) : @sequential_space.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_162399 (h0 : function.extfun Type topological_space) : @normal_space.{0} (linear_ordered_semiring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_162400 (h0 : group (canonically_linear_ordered_monoid (has_Inf Type))) : normalizer_condition (canonically_linear_ordered_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_162401 (h0 : topological_space (linear_ordered_comm_ring unsigned)) : totally_separated_space (linear_ordered_comm_ring unsigned) := sorry --non-trivial
lemma new_lemma_162402 (h0 : function.extfun (finset Type) (has_mem.mem (random_gen linarith.ineq))) : @rank_condition.{0} (random_gen.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type ring.{0} (random_gen.{0} linarith.ineq) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} linarith.ineq)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_162403 (h0 : semiring (normed_group (semiring (semiring (semiring empty))))) : is_noetherian_ring (normed_group (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_162404 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (with_bot.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_bot.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_162405 (h0 : topological_space (has_one (has_top empty))) : totally_separated_space (has_one (has_top empty)) := sorry --non-trivial
lemma new_lemma_162406 (h0 : order_hom nat (topological_space real.angle)) : @t0_space.{0} real.angle (@monotonic_sequence_limit.{0} (topological_space.{0} real.angle) (@topological_space.partial_order.{0} real.angle) h0)  := sorry --non-trivial
lemma new_lemma_162407 (h0 : functor.add_const (topological_space (add_group num)) num) : @totally_disconnected_space.{0} (add_group.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (add_group.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_162408 (h0 : fin has_zero.zero) : @loc_path_connected_space.{1} (canonically_linear_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (canonically_linear_ordered_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_162409 (h0 : group (add_comm_monoid pos)) : is_cyclic (add_comm_monoid pos) := sorry --non-trivial
lemma new_lemma_162410 (h0 : function.extfun Type (functor.add_const (topological_space (has_Inf linarith.comp)))) : @t0_space.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} linarith.comp)) linarith.comp (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (has_Inf.{0} linarith.comp))) h0 linarith.comp))  := sorry --non-trivial
lemma new_lemma_162411 (h0 : group (with_one (random_gen (random_gen to_additive.value_type)))) : is_cyclic (with_one (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_162412 (h1 : add_group (nondiscrete_normed_field reducibility_hints)) : is_add_cyclic (nondiscrete_normed_field reducibility_hints) := sorry --non-trivial
lemma new_lemma_162413 (h1 : function.extfun Type topological_space) : @t0_space.{0} (semiring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_162414 (h0 : uniform_space (mul_zero_class unsigned)) : complete_space (mul_zero_class unsigned) := sorry --non-trivial
lemma new_lemma_162415 (h0 : functor.add_const (topological_space (cancel_monoid unsigned)) Type) : @totally_disconnected_space.{0} (cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (cancel_monoid.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_162416 (h0 : topological_space (has_add (normed_comm_ring unsigned))) : locally_compact_space (has_add (normed_comm_ring unsigned)) := sorry --non-trivial
lemma new_lemma_162417 (h0 : function.extfun Type group) : @group.fg.{0} real (@function.extfun_app.{2 1} Type group.{0} h0 real)  := sorry --non-trivial
lemma new_lemma_162418 (h0 : topological_space (cancel_monoid linarith.comp)) : sequential_space (cancel_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_162419 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (linear_ordered_field.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_field.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_162420 (h0 : topological_space (preorder (option (option (option (option unsigned)))))) : path_connected_space (preorder (option (option (option (option unsigned))))) := sorry --non-trivial
lemma new_lemma_162421 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_162422 (h0 : complete_lattice (has_neg (has_neg (has_neg unsigned)))) : is_compactly_generated (has_neg (has_neg (has_neg unsigned))) := sorry --non-trivial
lemma new_lemma_162423 (h0 : topological_space (linear_ordered_comm_group_with_zero to_additive.value_type)) (h1 : preorder (linear_ordered_comm_group_with_zero to_additive.value_type)) : order_closed_topology (linear_ordered_comm_group_with_zero to_additive.value_type) := sorry --non-trivial
lemma new_lemma_162424 (h0 : ring (semigroup (option (option (option pos))))) : rank_condition (semigroup (option (option (option pos)))) := sorry --non-trivial
lemma new_lemma_162425 (h0 : function.extfun Type (functor.add_const (finset (partial_order congr_arg_kind)))) : finset.nonempty (functor.add_const.run (function.extfun_app h0 empty)) := sorry --non-trivial
lemma new_lemma_162426 (h0 : topological_space (has_zero (normed_comm_ring environment.implicit_infer_kind))) : discrete_topology (has_zero (normed_comm_ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_162427 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (semigroup.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_162428 (h0 : functor.add_const (group (has_zero linarith.comp)) name) : @normalizer_condition.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (has_zero.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_162429 (h0 : complete_lattice (semiring congr_arg_kind)) : is_atomistic (semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_162430 (h0 : not (uniform_space (non_unital_non_assoc_semiring linarith.comp_source) -> false)) : @complete_space.{0} (non_unital_non_assoc_semiring.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (uniform_space.{0} (non_unital_non_assoc_semiring.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_162431 (h0 : set (mul_one_class (add_comm_semigroup (normed_field std_gen)))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_162432 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (boolean_algebra.core.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (boolean_algebra.core.{0} name))  := sorry --non-trivial
lemma new_lemma_162433 (h0 : topological_space (sub_neg_monoid (has_Inf pos))) : discrete_topology (sub_neg_monoid (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_162434 (h0 : topological_space (linear_ordered_semiring (semiring fun_info))) : preirreducible_space (linear_ordered_semiring (semiring fun_info)) := sorry --non-trivial
lemma new_lemma_162435 (h0 : filter (fintype linarith.ineq)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_162436 (h0 : group (measurable_space (has_norm to_additive.value_type))) : normalizer_condition (measurable_space (has_norm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_162437 (h0 : topological_space (distrib (has_nnnorm linarith.comp_source))) : totally_disconnected_space (distrib (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_162438 (h0 : complete_lattice (finset (option unsigned))) : complete_lattice.is_Sup_finite_compact (finset (option unsigned)) := sorry --non-trivial
lemma new_lemma_162439 (h0 : add_group (has_emptyc (has_norm (random_gen (has_norm fun_info))))) : is_add_cyclic (has_emptyc (has_norm (random_gen (has_norm fun_info)))) := sorry --non-trivial
lemma new_lemma_162440 (h0 h1 : multiset (has_ssubset (mul_one_class string_imp))) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_162441 (h0 : topological_space (generalized_boolean_algebra linarith.comp)) : discrete_topology (generalized_boolean_algebra linarith.comp) := sorry --non-trivial
lemma new_lemma_162442 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (has_to_string.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_162443 (h0 : ring (semi_normed_comm_ring (random_gen (random_gen fun_info)))) : strong_rank_condition (semi_normed_comm_ring (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_162444 (h0 : topological_space (add_cancel_monoid (boolean_algebra.core pos))) : sequential_space (add_cancel_monoid (boolean_algebra.core pos)) := sorry --non-trivial
lemma new_lemma_162445 (h0 : semiring (has_edist empty)) : is_noetherian_ring (has_edist empty) := sorry --non-trivial
lemma new_lemma_162446 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (has_union congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_162447 (h0 : finset (has_Inf (finset pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_162448 (h0 : topological_space (linear_ordered_field (option (option empty)))) : totally_separated_space (linear_ordered_field (option (option empty))) := sorry --non-trivial
lemma new_lemma_162449 (h0 : has_mem.mem real.angle has_emptyc.emptyc) : @strong_rank_condition.{0} real.angle (@finset.pi.empty.{1 0} Type ring.{0} real.angle h0)  := sorry --non-trivial
lemma new_lemma_162450 (h0 : topological_space (has_nndist (has_add (finset (has_add linarith.comp))))) : loc_path_connected_space (has_nndist (has_add (finset (has_add linarith.comp)))) := sorry --non-trivial
lemma new_lemma_162451 (h1 : ring (semi_normed_comm_ring string_imp)) : strong_rank_condition (semi_normed_comm_ring string_imp) := sorry --non-trivial
lemma new_lemma_162452 (h0 : topological_space (comm_group (has_add pos))) : preirreducible_space (comm_group (has_add pos)) := sorry --non-trivial
lemma new_lemma_162453 (h0 : group (ordered_comm_ring (has_add Type))) : is_simple_group (ordered_comm_ring (has_add Type)) := sorry --non-trivial
lemma new_lemma_162454 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (canonically_linear_ordered_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_linear_ordered_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_162455 (h0 : add_group (has_top (has_top (has_top to_additive.value_type)))) : is_add_cyclic (has_top (has_top (has_top to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_162456 (h0 : functor.add_const (topological_space (has_Sup unsigned)) empty) : @preirreducible_space.{0} (has_Sup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Sup.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_162457 (h0 : fin has_zero.zero) : @normalizer_condition.{0} (canonically_linear_ordered_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (group.{0} (canonically_linear_ordered_monoid.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_162458 (h1 : ring (comm_ring (comm_ring (comm_ring (comm_ring reducibility_hints))))) : is_domain (comm_ring (comm_ring (comm_ring (comm_ring reducibility_hints)))) := sorry --non-trivial
lemma new_lemma_162459 (h0 : group (has_nndist (has_neg (has_add (add_comm_monoid (has_add (has_to_string Type))))))) : group.fg (has_nndist (has_neg (has_add (add_comm_monoid (has_add (has_to_string Type)))))) := sorry --non-trivial
lemma new_lemma_162460 (h0 : finset (mul_zero_class Type)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_162461 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_neg ennreal)) Type) : @unique_factorization_monoid.{0} (has_neg.{0} ennreal) (@functor.add_const.run.{0 1} (cancel_comm_monoid_with_zero.{0} (has_neg.{0} ennreal)) Type h0)  := sorry --non-trivial
lemma new_lemma_162462 (h0 : functor.add_const (function.extfun (Type 1) uniform_space) pos) : @complete_space.{1} Type (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) uniform_space.{1}) pos h0) Type)  := sorry --non-trivial
lemma new_lemma_162463 (h0 : topological_space (measurable_space fun_info)) : discrete_topology (measurable_space fun_info) := sorry --non-trivial
lemma new_lemma_162464 (h0 : uniform_space (id (random_gen fun_info))) : complete_space (id (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_162465 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (boolean_algebra.core.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (boolean_algebra.core.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_162466 (h0 : add_group (semiring num)) : is_add_cyclic (semiring num) := sorry --non-trivial
lemma new_lemma_162467 (h0 : group (comm_ring linarith.comp_source)) : is_cyclic (comm_ring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_162468 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_162469 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : list.nodup (function.extfun_app (function.extfun_app h0 list) (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_162470 (h0 : functor.add_const (finset (preorder congr_arg_kind)) empty) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_162471 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_162472 (h0 : functor.add_const (topological_space (mul_zero_class name)) name) : @preirreducible_space.{0} (mul_zero_class.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_162473 (h0 : has_mem.mem (complete_semilattice_Sup fun_info) has_emptyc.emptyc) : @is_compactly_generated.{0} (complete_semilattice_Sup.{0} fun_info) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (complete_semilattice_Sup.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_162474 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_zero.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_162475 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @locally_compact_space.{1} (add_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (add_comm_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_162476 (h0 : functor.add_const (topological_space (plift unsigned)) unsigned) : @preirreducible_space.{1} (plift.{1} unsigned) (@functor.add_const.run.{1 0} (topological_space.{1} (plift.{1} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_162477 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @locally_compact_space.{1} (canonically_ordered_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (canonically_ordered_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_162478 (h0 : nat -> Prop) (h2 : nat) : @disjointed.{0} Prop (@boolean_algebra.to_generalized_boolean_algebra.{0} Prop Prop.boolean_algebra) h0 h2  := sorry --non-trivial
lemma new_lemma_162479 (h0 : ring (has_add (has_Inf real))) : strong_rank_condition (has_add (has_Inf real)) := sorry --non-trivial
lemma new_lemma_162480 (h0 : topological_space (has_neg (has_neg pos))) : t0_space (has_neg (has_neg pos)) := sorry --non-trivial
lemma new_lemma_162481 (h0 : ordered_add_comm_monoid (has_add (has_add linarith.comp))) : archimedean (has_add (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_162482 (h0 : function.extfun Type topological_space) : @normal_space.{0} (has_add.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_162483 (h0 : functor.add_const (group (has_to_string unsigned)) pos) : @is_simple_group.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (has_to_string.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_162484 (h0 : filter (canonically_linear_ordered_monoid (option (measurable_space.dynkin_system pos)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_162485 (h0 : functor.add_const (complete_lattice (has_neg num)) unsigned) : @complete_lattice.is_Sup_finite_compact.{0} (has_neg.{0} num) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_neg.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_162486 (h0 : list (add_comm_monoid (boolean_algebra (finset environment.implicit_infer_kind)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_162487 (h0 : topological_space (as_linear_order (option (option unsigned)))) : preirreducible_space (as_linear_order (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_162488 (h0 : finset (ordered_comm_monoid (has_add pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_162489 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_zero.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} h0 (has_zero.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_162490 (h0 : list (has_star num)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_162491 (h0 : topological_space (mul_one_class (add_comm_semigroup char))) : totally_disconnected_space (mul_one_class (add_comm_semigroup char)) := sorry --non-trivial
lemma new_lemma_162492 (h0 : multiset (random_gen (mul_one_class (mul_one_class linarith.ineq)))) (h1 : not (multiset (random_gen (mul_one_class (mul_one_class linarith.ineq))) -> false)) : multiset.disjoint h0 (classical.by_contradiction' h1) := sorry --non-trivial
lemma new_lemma_162493 (h0 : functor.add_const (topological_space pos) ennreal) : @regular_space.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) ennreal h0)  := sorry --non-trivial
lemma new_lemma_162494 (h0 : ring (comm_ring (has_nnnorm (mul_one_class (has_nnnorm char))))) : is_domain (comm_ring (has_nnnorm (mul_one_class (has_nnnorm char)))) := sorry --non-trivial
lemma new_lemma_162495 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (bin_tree.{0} (option.{0} (option.{0} unsigned))) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (bin_tree.{0} (option.{0} (option.{0} unsigned))))  := sorry --non-trivial
lemma new_lemma_162496 (h0 : cancel_comm_monoid_with_zero (filter congr_arg_kind)) : unique_factorization_monoid (filter congr_arg_kind) := sorry --non-trivial
lemma new_lemma_162497 (h0 : complete_lattice (boolean_algebra.core (option pos))) : is_compactly_generated (boolean_algebra.core (option pos)) := sorry --non-trivial
lemma new_lemma_162498 (h0 : topological_space (canonically_ordered_monoid (has_Inf (has_add pos)))) : totally_separated_space (canonically_ordered_monoid (has_Inf (has_add pos))) := sorry --non-trivial
lemma new_lemma_162499 (h0 : complete_lattice (boolean_algebra (finset (finset linarith.comp)))) : is_compactly_generated (boolean_algebra (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_162500 (h0 : functor.add_const (topological_space (has_neg name)) (ring (ring Type))) : @irreducible_space.{0} (has_neg.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg.{0} name)) (ring.{1} (ring.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_162501 (h0 : topological_space (generalized_boolean_algebra (has_Inf Type))) : discrete_topology (generalized_boolean_algebra (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_162502 (h0 : group (complete_linear_order (semiring num))) : normalizer_condition (complete_linear_order (semiring num)) := sorry --non-trivial
lemma new_lemma_162503 (h0 : topological_space (add_cancel_monoid (ring environment.implicit_infer_kind))) : totally_disconnected_space (add_cancel_monoid (ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_162504 (h0 : function.extfun Type pseudo_metric_space) (h1 : monoid empty) : has_lipschitz_mul empty := sorry --non-trivial
lemma new_lemma_162505 (h0 : complete_lattice (has_to_string (option (option ennreal)))) : is_atomistic (has_to_string (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_162506 (h0 : functor.add_const (topological_space (finset Type)) Type) : @discrete_topology.{1} (finset.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (finset.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_162507 (h1 : not (topological_space (complete_semilattice_Sup num) -> false)) : @path_connected_space.{0} (complete_semilattice_Sup.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (complete_semilattice_Sup.{0} num)) h1)  := sorry --non-trivial
lemma new_lemma_162508 (h0 : not (function.extfun Type group -> false)) : @group.fg.{0} (has_inv.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (has_inv.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_162509 (h6 : complete_lattice (non_unital_non_assoc_semiring linarith.ineq)) : is_compactly_generated (non_unital_non_assoc_semiring linarith.ineq) := sorry --non-trivial
lemma new_lemma_162510 (h0 : group (has_pos_part name)) : is_simple_group (has_pos_part name) := sorry --non-trivial
lemma new_lemma_162511 (h0 : filter (has_sub (semiring (semiring empty)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_162512 (h0 : topological_space (bin_tree (semiring num))) : locally_compact_space (bin_tree (semiring num)) := sorry --non-trivial
lemma new_lemma_162513 (h1 : has_mul (topological_space string_imp)) (h2 : uniform_space (topological_space (con (topological_space string_imp)))) : complete_space (topological_space (con (topological_space string_imp))) := sorry --non-trivial
lemma new_lemma_162514 (h0 : functor.add_const (uniform_space (normed_comm_ring environment.implicit_infer_kind)) linarith.comp) : @separated_space.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (uniform_space.{0} (normed_comm_ring.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_162515 (h0 : add_group (linear_order num)) : is_add_cyclic (linear_order num) := sorry --non-trivial
lemma new_lemma_162516 (h0 : functor.add_const (cancel_comm_monoid_with_zero (finset linarith.comp)) pos) : @unique_factorization_monoid.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (finset.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_162517 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (has_Inf.{0} real) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (has_Inf.{0} real))  := sorry --non-trivial
lemma new_lemma_162518 (h0 : functor.add_const (add_group (normed_linear_ordered_group empty)) empty) : @is_add_cyclic.{0} (normed_linear_ordered_group.{0} empty) (@functor.add_const.run.{0 0} (add_group.{0} (normed_linear_ordered_group.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_162519 (h0 : topological_space (has_lt environment.projection_info)) (h1 : add_group (has_lt environment.projection_info)) : topological_add_group (has_lt environment.projection_info) := sorry --non-trivial
lemma new_lemma_162520 (h0 : functor.add_const (topological_space (generalized_boolean_algebra linarith.comp)) (ring Type)) : @preirreducible_space.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (generalized_boolean_algebra.{0} linarith.comp)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_162521 (h0 : group (has_bot (has_pos_part real))) : is_simple_group (has_bot (has_pos_part real)) := sorry --non-trivial
lemma new_lemma_162522 (h0 : functor.add_const (topological_space (boolean_algebra.core unsigned)) Type) : @topological_space.separable_space.{0} (boolean_algebra.core.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.core.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_162523 (h1 : topological_space (dlist string_imp)) : locally_compact_space (dlist string_imp) := sorry --non-trivial
lemma new_lemma_162524 (h0 : topological_space (semigroup (has_to_string congr_arg_kind))) : normal_space (semigroup (has_to_string congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_162525 (h0 : not (topological_space (has_compl to_additive.value_type) -> false)) : @t0_space.{0} (has_compl.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (has_compl.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_162526 (h0 : ring (left_cancel_semigroup (semiring congr_arg_kind))) : is_domain (left_cancel_semigroup (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_162527 (h0 : topological_space (has_inter (option ennreal))) : loc_path_connected_space (has_inter (option ennreal)) := sorry --non-trivial
lemma new_lemma_162528 (h0 : uniform_space (boolean_algebra (has_neg (has_neg (has_neg (has_neg Type)))))) : separated_space (boolean_algebra (has_neg (has_neg (has_neg (has_neg Type))))) := sorry --non-trivial
lemma new_lemma_162529 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (comm_semigroup.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (comm_semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_162530 (h0 : not (ring (option empty) -> false)) : @strong_rank_condition.{0} (option.{0} empty) (@classical.by_contradiction'.{1} (ring.{0} (option.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_162531 (h0 : topological_space (boolean_algebra.core (boolean_algebra (finset Type)))) : irreducible_space (boolean_algebra.core (boolean_algebra (finset Type))) := sorry --non-trivial
lemma new_lemma_162532 (h0 : not (ring (denumerable char) -> false)) : @rank_condition.{0} (denumerable.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (denumerable.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_162533 (h0 : group (with_bot empty)) : is_cyclic (with_bot empty) := sorry --non-trivial
lemma new_lemma_162534 (h0 : functor.add_const (monoid (boolean_algebra.core unsigned)) Type) : @monoid.fg.{0} (boolean_algebra.core.{0} unsigned) (@functor.add_const.run.{0 1} (monoid.{0} (boolean_algebra.core.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_162535 (h0 : functor.add_const (monoid (has_to_string environment.implicit_infer_kind)) linarith.comp) : @monoid.fg.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (monoid.{0} (has_to_string.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_162536 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (canonically_ordered_comm_semiring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_162537 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (ring pos)) := sorry --non-trivial
lemma new_lemma_162538 (h0 : topological_space (linear_ordered_field (option unsigned))) : totally_disconnected_space (linear_ordered_field (option unsigned)) := sorry --non-trivial
lemma new_lemma_162539 (h0 : function.extfun Type (functor.add_const (filter znum))) : filter.ne_bot (functor.add_const.run (function.extfun_app h0 empty)) := sorry --non-trivial
lemma new_lemma_162540 (h0 : topological_space (comm_group (has_neg_part (has_to_string unsigned)))) : regular_space (comm_group (has_neg_part (has_to_string unsigned))) := sorry --non-trivial
lemma new_lemma_162541 (h0 : topological_space (ring (has_neg_part environment.implicit_infer_kind))) : normal_space (ring (has_neg_part environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_162542 (h0 : functor.add_const (topological_space (boolean_algebra real)) real) : @preirreducible_space.{0} (boolean_algebra.{0} real) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} real)) real h0)  := sorry --non-trivial
lemma new_lemma_162543 (h0 : not (function.extfun Type topological_space -> false)) : @irreducible_space.{0} (has_norm.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_norm.{0} num))  := sorry --non-trivial
lemma new_lemma_162544 (h0 : ordered_add_comm_monoid (has_add (has_to_string name))) : archimedean (has_add (has_to_string name)) := sorry --non-trivial
lemma new_lemma_162545 (h0 : function.extfun Type (functor.add_const (uniform_space auto.case_option))) : @complete_space.{0} auto.case_option (@functor.add_const.run.{0 0} (uniform_space.{0} auto.case_option) (option.{0} (option.{0} (option.{0} (option.{0} (option.{0} (option.{0} unsigned)))))) (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (uniform_space.{0} auto.case_option)) h0 (option.{0} (option.{0} (option.{0} (option.{0} (option.{0} (option.{0} unsigned))))))))  := sorry --non-trivial
lemma new_lemma_162546 (h0 : not (function.extfun Type group -> false)) : @group.fg.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (linear_ordered_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_162547 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (partial_order.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (partial_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_162548 (h0 : functor.add_const (filter (as_linear_order unsigned)) unsigned) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_162549 (h0 : add_group (normed_group (has_top fun_info))) : is_add_cyclic (normed_group (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_162550 (h0 : uniform_space (normed_lattice_add_comm_group (random_gen string_imp))) : complete_space (normed_lattice_add_comm_group (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_162551 (h0 : cancel_comm_monoid_with_zero (finset name)) : unique_factorization_monoid (finset name) := sorry --non-trivial
lemma new_lemma_162552 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (non_assoc_semiring.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (non_assoc_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_162553 (h0 : topological_space (measure_theory.measure_space unsigned)) : normal_space (measure_theory.measure_space unsigned) := sorry --non-trivial
lemma new_lemma_162554 (h0 : complete_lattice (mul_zero_class (finset (finset ennreal)))) : complete_lattice.is_Sup_finite_compact (mul_zero_class (finset (finset ennreal))) := sorry --non-trivial
lemma new_lemma_162555 (h0 : semiring (pseudo_metric_space pos)) : is_noetherian_ring (pseudo_metric_space pos) := sorry --non-trivial
lemma new_lemma_162556 (h0 : functor.add_const (cancel_comm_monoid_with_zero (normed_comm_ring ennreal)) name) : @unique_factorization_monoid.{0} (normed_comm_ring.{0} ennreal) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (normed_comm_ring.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_162557 (h0 : semiring (add_comm_monoid (add_comm_monoid name))) : is_noetherian_ring (add_comm_monoid (add_comm_monoid name)) := sorry --non-trivial
lemma new_lemma_162558 (h0 : functor.add_const (uniform_space (add_group unsigned)) unsigned) : @separated_space.{0} (add_group.{0} unsigned) (@functor.add_const.run.{0 0} (uniform_space.{0} (add_group.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_162559 (h0 : ring (add_group (semiring (semiring num)))) : is_domain (add_group (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_162560 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @is_add_cyclic.{0} (ordered_cancel_add_comm_monoid.{0} num) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) add_group.{0}) (ordered_cancel_add_comm_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_162561 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (has_norm.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_norm.{0} num))  := sorry --non-trivial
lemma new_lemma_162562 (h0 : topological_space (add_cancel_monoid (has_nndist (has_pos_part (finset linarith.comp))))) : normal_space (add_cancel_monoid (has_nndist (has_pos_part (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_162563 (h0 : has_add linarith.comp_source) (h1 : function.extfun Type has_le) (h2 : linarith.comp_source) : @add_le_cancellable.{0} linarith.comp_source (@id.{1} (has_add.{0} linarith.comp_source) h0) (@function.extfun_app.{2 1} Type has_le.{0} h1 linarith.comp_source) h2  := sorry --non-trivial
lemma new_lemma_162564 (h0 : functor.add_const (topological_space (add_group congr_arg_kind)) congr_arg_kind) : @locally_compact_space.{0} (add_group.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (add_group.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_162565 (h0 : ordered_comm_monoid (add_cancel_monoid (ring pos))) : has_exists_mul_of_le (add_cancel_monoid (ring pos)) := sorry --non-trivial
lemma new_lemma_162566 (h0 : has_mem.mem (metric_space linarith.comp) has_emptyc.emptyc) : @complete_space.{0} (metric_space.{0} linarith.comp) (@finset.pi.empty.{1 0} Type uniform_space.{0} (metric_space.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_162567 (h0 : group (canonically_ordered_monoid (sub_neg_monoid (has_neg Type)))) : group.fg (canonically_ordered_monoid (sub_neg_monoid (has_neg Type))) := sorry --non-trivial
lemma new_lemma_162568 (h0 : functor.add_const (ring (boolean_algebra Type)) (has_nndist linarith.comp)) : @is_principal_ideal_ring.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (boolean_algebra.{1} Type)) (has_nndist.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_162569 (h0 : functor.add_const (complete_lattice (has_zero pos)) environment.implicit_infer_kind) : @is_atomistic.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_zero.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_162570 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (ordered_ring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_162571 (h0 : topological_space (has_top (random_gen fun_info))) : locally_compact_space (has_top (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_162572 (h0 : function.extfun Type topological_space) : t0_space nnreal := sorry --non-trivial
lemma new_lemma_162573 (h0 : functor.add_const (ring (has_pos_part linarith.comp)) (has_add linarith.comp)) : @is_domain.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_pos_part.{0} linarith.comp)) (has_add.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_162574 (h0 : filter (ordered_comm_ring (has_pos_part Type))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_162575 (h0 : not (topological_space (has_nnnorm reducibility_hints) -> false)) : @t0_space.{0} (has_nnnorm.{0} reducibility_hints) (@classical.by_contradiction'.{1} (topological_space.{0} (has_nnnorm.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_162576 (h0 : not (add_group (random_gen to_additive.value_type) -> false)) : @is_add_cyclic.{0} (random_gen.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (add_group.{0} (random_gen.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_162577 (h0 : preorder char) (h1 : succ_order char) : is_succ_archimedean char := sorry --non-trivial
lemma new_lemma_162578 (h0 : topological_space (canonically_ordered_add_monoid num)) : locally_compact_space (canonically_ordered_add_monoid num) := sorry --non-trivial
lemma new_lemma_162579 (h0 : topological_space (has_neg name)) : totally_disconnected_space (has_neg name) := sorry --non-trivial
lemma new_lemma_162580 (h0 : functor.add_const (function.extfun Type list) pos) : palindrome (function.extfun_app (functor.add_const.run h0) (semigroup linarith.comp)) := sorry --non-trivial
lemma new_lemma_162581 (h1 : topological_space (has_emptyc linarith.comp_source)) : totally_separated_space (has_emptyc linarith.comp_source) := sorry --non-trivial
lemma new_lemma_162582 (h0 : measurable_space (nondiscrete_normed_field (mul_one_class (add_comm_semigroup linarith.ineq)))) (h1 : measure_theory.measure (nondiscrete_normed_field (mul_one_class (add_comm_semigroup linarith.ineq)))) : measure_theory.is_finite_measure h1 := sorry --non-trivial
lemma new_lemma_162583 (h1 : add_monoid string.iterator_imp) : add_monoid.fg string.iterator_imp := sorry --non-trivial
lemma new_lemma_162584 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (has_sub.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type monoid.{0} h0 (has_sub.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_162585 (h0 : semiring (mul_zero_class name)) : is_noetherian_ring (mul_zero_class name) := sorry --non-trivial
lemma new_lemma_162586 (h0 : topological_space (id linarith.comp_source)) : totally_separated_space (id linarith.comp_source) := sorry --non-trivial
lemma new_lemma_162587 (h0 : functor.comp group cancel_monoid name) : @group.fg.{0} (cancel_monoid.{0} name) (@functor.comp.run.{0 0 0} group.{0} cancel_monoid.{0} name h0)  := sorry --non-trivial
lemma new_lemma_162588 (h0 : topological_space (has_top (measurable_space linarith.comp_source))) : irreducible_space (has_top (measurable_space linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_162589 (h0 : add_group (has_nnnorm (mul_one_class (mul_one_class (mul_one_class fun_info))))) : is_add_cyclic (has_nnnorm (mul_one_class (mul_one_class (mul_one_class fun_info)))) := sorry --non-trivial
lemma new_lemma_162590 (h0 : topological_space (linear_ordered_semiring (has_norm empty))) : preirreducible_space (linear_ordered_semiring (has_norm empty)) := sorry --non-trivial
lemma new_lemma_162591 (h0 : functor.add_const (topological_space (has_add pos)) linarith.comp) : @loc_path_connected_space.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_162592 (h0 : complete_lattice (has_top (semiring (has_norm unsigned)))) : is_atomistic (has_top (semiring (has_norm unsigned))) := sorry --non-trivial
lemma new_lemma_162593 (h0 : complete_lattice (semigroup (has_to_string name))) : is_atomistic (semigroup (has_to_string name)) := sorry --non-trivial
lemma new_lemma_162594 (h0 : functor.add_const (topological_space (finset name)) Type) : @t1_space.{0} (finset.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (finset.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_162595 (h0 : ring (mul_zero_class (add_comm_monoid (has_add Type)))) : is_domain (mul_zero_class (add_comm_monoid (has_add Type))) := sorry --non-trivial
lemma new_lemma_162596 (h3 : uniform_space (random_gen char)) : complete_space (random_gen char) := sorry --non-trivial
lemma new_lemma_162597 (h0 : topological_space (ordered_comm_ring (ring name))) : preirreducible_space (ordered_comm_ring (ring name)) := sorry --non-trivial
lemma new_lemma_162598 (h0 : function.extfun nat fin) : @path_connected_space.{0} (add_comm_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (add_comm_monoid.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_162599 (h0 : functor.add_const (finset (has_Inf name)) (has_neg (has_add (ring (ring (has_neg Type)))))) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_162600 (h0 : set (has_div (canonically_linear_ordered_monoid string.iterator_imp))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_162601 (h0 : fin has_zero.zero) : @t0_space.{1} (canonically_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (canonically_ordered_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_162602 (h0 : topological_space (complete_distrib_lattice (add_comm_monoid (has_add Type)))) : preirreducible_space (complete_distrib_lattice (add_comm_monoid (has_add Type))) := sorry --non-trivial
lemma new_lemma_162603 (h0 : topological_space (canonically_ordered_monoid linarith.comp)) : topological_space.separable_space (canonically_ordered_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_162604 (h0 : ring (measurable_space linarith.comp_source)) : rank_condition (measurable_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_162605 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (option.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (option.{0} empty))  := sorry --non-trivial
lemma new_lemma_162606 (h0 : functor.add_const (complete_lattice (add_cancel_monoid Type)) name) : @is_compactly_generated.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (add_cancel_monoid.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_162607 (h0 : group (mul_zero_class (finset name))) : is_simple_group (mul_zero_class (finset name)) := sorry --non-trivial
lemma new_lemma_162608 (h0 : topological_space (finset (normed_comm_ring ennreal))) : locally_compact_space (finset (normed_comm_ring ennreal)) := sorry --non-trivial
lemma new_lemma_162609 (h0 : functor.add_const (function.extfun Type topological_space) environment.implicit_infer_kind) : @preconnected_space.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) environment.implicit_infer_kind h0) (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_162610 (h0 : semiring (has_add (has_neg (finset (has_neg (finset environment.implicit_infer_kind)))))) : is_noetherian_ring (has_add (has_neg (finset (has_neg (finset environment.implicit_infer_kind))))) := sorry --non-trivial
lemma new_lemma_162611 (h1 : has_le ereal) (h2 : bounded_order ereal) : is_simple_order ereal := sorry --non-trivial
lemma new_lemma_162612 (h0 : complete_lattice (ordered_ring unsigned)) : is_compactly_generated (ordered_ring unsigned) := sorry --non-trivial
lemma new_lemma_162613 (h0 : filter (semiring (has_norm congr_arg_kind))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_162614 (h0 : topological_space (canonically_linear_ordered_monoid (has_neg pos))) : preirreducible_space (canonically_linear_ordered_monoid (has_neg pos)) := sorry --non-trivial
lemma new_lemma_162615 (h0 : not (complete_lattice (with_zero znum) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (with_zero.{0} znum) (@classical.by_contradiction'.{1} (complete_lattice.{0} (with_zero.{0} znum)) h0)  := sorry --non-trivial
lemma new_lemma_162616 (h1 : not (ring (complete_semilattice_Sup linarith.comp_source) -> false)) : @rank_condition.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (complete_semilattice_Sup.{0} linarith.comp_source)) h1)  := sorry --non-trivial
lemma new_lemma_162617 (h0 : functor.add_const (add_monoid (add_comm_monoid linarith.comp)) real) : @add_monoid.fg.{0} (add_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_monoid.{0} (add_comm_monoid.{0} linarith.comp)) real h0)  := sorry --non-trivial
lemma new_lemma_162618 (h0 : not (topological_space (option congr_arg_kind) -> false)) : @discrete_topology.{0} (option.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (option.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_162619 (h0 : fin has_zero.zero) : @archimedean.{0} (has_neg.{0} pos) (@matrix.vec_empty.{0} (ordered_add_comm_monoid.{0} (has_neg.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_162620 (h0 : ordered_add_comm_monoid (has_bot (option empty))) : archimedean (has_bot (option empty)) := sorry --non-trivial
lemma new_lemma_162621 (h0 : topological_space (comm_group (cancel_monoid unsigned))) : irreducible_space (comm_group (cancel_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_162622 (h1 : topological_space (semi_normed_comm_ring reducibility_hints)) : totally_disconnected_space (semi_normed_comm_ring reducibility_hints) := sorry --non-trivial
lemma new_lemma_162623 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @totally_separated_space.{0} (has_norm.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_norm.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_162624 (h0 : not (complete_lattice (semi_normed_ring char) -> false)) : @is_compactly_generated.{0} (semi_normed_ring.{0} char) (@classical.by_contradiction'.{1} (complete_lattice.{0} (semi_normed_ring.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_162625 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_162626 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (partial_order.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (partial_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_162627 (h0 : functor.add_const (topological_space (add_cancel_monoid Type)) name) : @preirreducible_space.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_cancel_monoid.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_162628 (h0 : uniform_space (uniform_space linarith.ineq)) : complete_space (uniform_space linarith.ineq) := sorry --non-trivial
lemma new_lemma_162629 (h0 : group (has_Inf (finset (ring (finset (finset Type)))))) : normalizer_condition (has_Inf (finset (ring (finset (finset Type))))) := sorry --non-trivial
lemma new_lemma_162630 (h0 : topological_space (has_add real)) : t0_space (has_add real) := sorry --non-trivial
lemma new_lemma_162631 (h0 : add_monoid (generalized_boolean_algebra (has_neg (has_neg Type)))) : add_monoid.fg (generalized_boolean_algebra (has_neg (has_neg Type))) := sorry --non-trivial
lemma new_lemma_162632 (h0 : fin has_zero.zero) : @preirreducible_space.{1} (boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (boolean_algebra.{1} Type)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)))))  := sorry --non-trivial
lemma new_lemma_162633 (h0 : not (function.extfun Type topological_space -> false)) : @discrete_topology.{0} (measure_theory.measure_space.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (measure_theory.measure_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_162634 (h0 : set (has_ssubset string_imp)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_162635 (h0 : ring (metric_space (random_gen char))) : is_domain (metric_space (random_gen char)) := sorry --non-trivial
lemma new_lemma_162636 (h0 : fin has_zero.zero) : @totally_disconnected_space.{1} (complete_distrib_lattice.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (complete_distrib_lattice.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_162637 (h0 : topological_space (ring Type)) : locally_compact_space (ring Type) := sorry --non-trivial
lemma new_lemma_162638 (h0 : functor.add_const (topological_space (has_nndist name)) pos) : @totally_separated_space.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_162639 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (has_to_string empty)) := sorry --non-trivial
lemma new_lemma_162640 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_162641 (h0 : not (topological_space (distrib_lattice to_additive.value_type) -> false)) : @t0_space.{0} (distrib_lattice.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (distrib_lattice.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_162642 (h0 : topological_space (has_nnnorm linarith.comp_source)) (h1 : preorder (has_nnnorm linarith.comp_source)) : order_closed_topology (has_nnnorm linarith.comp_source) := sorry --non-trivial
lemma new_lemma_162643 (h0 : topological_space (lattice ennreal)) : totally_disconnected_space (lattice ennreal) := sorry --non-trivial
lemma new_lemma_162644 (h0 : cancel_comm_monoid_with_zero (has_to_string (cancel_monoid Type))) : unique_factorization_monoid (has_to_string (cancel_monoid Type)) := sorry --non-trivial
lemma new_lemma_162645 (h2 : set (set enat)) (h3 : set enat) : filter.generate_sets h2 h3 := sorry --non-trivial
lemma new_lemma_162646 (h0 : ring (has_inv (has_ssubset to_additive.value_type))) : is_domain (has_inv (has_ssubset to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_162647 (h0 : topological_space (canonically_linear_ordered_monoid (option (option (option pos))))) : locally_compact_space (canonically_linear_ordered_monoid (option (option (option pos)))) := sorry --non-trivial
lemma new_lemma_162648 (h0 : add_group (has_norm (random_gen linarith.ineq))) : is_add_cyclic (has_norm (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_162649 (h0 : function.extfun nat fin) : @irreducible_space.{0} (generalized_boolean_algebra.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (generalized_boolean_algebra.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_162650 (h0 : complete_lattice (with_bot (has_norm num))) : is_compactly_generated (with_bot (has_norm num)) := sorry --non-trivial
lemma new_lemma_162651 (h0 : complete_lattice (has_add string_imp)) : is_compactly_generated (has_add string_imp) := sorry --non-trivial
lemma new_lemma_162652 (h0 : function.extfun Type topological_space) : @normal_space.{0} (complete_distrib_lattice.{0} (option.{0} (option.{0} ennreal))) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} (option.{0} (option.{0} ennreal))))  := sorry --non-trivial
lemma new_lemma_162653 (h0 : finset (has_nndist (comm_monoid unsigned))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_162654 (h0 : ring (has_add (option (option (option (option pos)))))) : rank_condition (has_add (option (option (option (option pos))))) := sorry --non-trivial
lemma new_lemma_162655 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (normed_lattice_add_comm_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_lattice_add_comm_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_162656 (h0 : ring (boolean_algebra (finset (ring (has_to_string Type))))) : strong_rank_condition (boolean_algebra (finset (ring (has_to_string Type)))) := sorry --non-trivial
lemma new_lemma_162657 (h0 : function.extfun Type topological_space) : @normal_space.{0} (ordered_ring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_162658 (h0 : topological_space (normed_group (comm_ring linarith.comp_source))) : totally_disconnected_space (normed_group (comm_ring linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_162659 (h0 : add_group (has_ssubset (boolean_algebra.core (has_ssubset ereal)))) : is_add_cyclic (has_ssubset (boolean_algebra.core (has_ssubset ereal))) := sorry --non-trivial
lemma new_lemma_162660 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @is_domain.{0} ennreal (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) ring.{0}) ennreal)  := sorry --non-trivial
lemma new_lemma_162661 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (has_to_string.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_162662 (h0 : cancel_comm_monoid_with_zero (ordered_comm_ring (has_Inf (boolean_algebra.core pos)))) : unique_factorization_monoid (ordered_comm_ring (has_Inf (boolean_algebra.core pos))) := sorry --non-trivial
lemma new_lemma_162663 (h0 : functor.add_const (function.extfun Type ring) Type) : @rank_condition.{0} (simple_graph.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ring.{0}) Type h0) (simple_graph.{0} pos))  := sorry --non-trivial
lemma new_lemma_162664 (h0 : add_monoid (semigroup (has_add (has_add Type)))) : add_monoid.fg (semigroup (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_162665 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (has_Sup.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (has_Sup.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_162666 (h0 : option Type) (h1 : topological_space (option.lhoare unsigned h0)) : path_connected_space (option.lhoare unsigned h0) := sorry --non-trivial
lemma new_lemma_162667 (h0 : cancel_comm_monoid_with_zero ennreal) : unique_factorization_monoid ennreal := sorry --non-trivial
lemma new_lemma_162668 (h0 : ring (add_comm_monoid unsigned) -> ring (add_comm_monoid unsigned) -> Prop) : is_symm (ring (add_comm_monoid unsigned)) h0 := sorry --non-trivial
lemma new_lemma_162669 (h2 : uniform_space (has_div string_imp)) : complete_space (has_div string_imp) := sorry --non-trivial
lemma new_lemma_162670 (h0 : add_group (encodable (has_top to_additive.value_type))) : is_add_cyclic (encodable (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_162671 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (has_bot.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (has_bot.{0} empty))  := sorry --non-trivial
lemma new_lemma_162672 (h0 : functor.add_const (ordered_add_comm_monoid (normed_comm_ring unsigned)) name) : @archimedean.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (normed_comm_ring.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_162673 (h0 : functor.add_const (ring (has_Sup congr_arg_kind)) num) : @rank_condition.{0} (has_Sup.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ring.{0} (has_Sup.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_162674 (h0 : functor.add_const (monoid (has_to_string unsigned)) (has_add (has_add name))) : @monoid.fg.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 0} (monoid.{0} (has_to_string.{0} unsigned)) (has_add.{0} (has_add.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_162675 (h0 : list (topological_space (has_compl (mul_one_class linarith.ineq)))) : @totally_disconnected_space.{0} (has_compl.{0} (mul_one_class.{0} linarith.ineq)) (@list.ilast.{0} (topological_space.{0} (has_compl.{0} (mul_one_class.{0} linarith.ineq))) (@inhabited_topological_space.{0} (has_compl.{0} (mul_one_class.{0} linarith.ineq))) h0)  := sorry --non-trivial
lemma new_lemma_162676 (h0 : has_mem.mem (complete_semilattice_Sup linarith.comp_source) has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (complete_semilattice_Sup.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_162677 (h0 : not (topological_space (with_one to_additive.value_type) -> false)) : @totally_separated_space.{0} (with_one.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (with_one.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_162678 (h0 : group (add_cancel_monoid (comm_group pos))) : normalizer_condition (add_cancel_monoid (comm_group pos)) := sorry --non-trivial
lemma new_lemma_162679 (h0 : topological_space (normed_group (has_norm (has_norm (with_bot (has_norm congr_arg_kind)))))) : irreducible_space (normed_group (has_norm (has_norm (with_bot (has_norm congr_arg_kind))))) := sorry --non-trivial
lemma new_lemma_162680 (h0 : topological_space (complete_linear_order empty)) : t1_space (complete_linear_order empty) := sorry --non-trivial
lemma new_lemma_162681 (h0 : functor.add_const (function.extfun Type filter) (ring Type)) : filter.ne_bot (function.extfun_app (functor.add_const.run h0) (ring pos)) := sorry --non-trivial
lemma new_lemma_162682 (h0 : ordered_add_comm_monoid (non_assoc_semiring empty)) : archimedean (non_assoc_semiring empty) := sorry --non-trivial
lemma new_lemma_162683 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (canonically_ordered_comm_semiring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_162684 (h0 : monoid (non_assoc_semiring congr_arg_kind)) : monoid.fg (non_assoc_semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_162685 (h0 : topological_space (sub_neg_monoid Type)) : locally_compact_space (sub_neg_monoid Type) := sorry --non-trivial
lemma new_lemma_162686 (h0 : uniform_space (has_inter (option empty))) : complete_space (has_inter (option empty)) := sorry --non-trivial
lemma new_lemma_162687 (h0 : topological_space (with_one (has_top num))) : path_connected_space (with_one (has_top num)) := sorry --non-trivial
lemma new_lemma_162688 (h0 : topological_space (has_emptyc linarith.comp)) : path_connected_space (has_emptyc linarith.comp) := sorry --non-trivial
lemma new_lemma_162689 (h0 : set (add_comm_semigroup char -> ereal)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_162690 (h0 : not (add_group (has_nnnorm linarith.ineq) -> false)) : @is_add_cyclic.{0} (has_nnnorm.{0} linarith.ineq) (@classical.by_contradiction'.{1} (add_group.{0} (has_nnnorm.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_162691 (h0 : add_group (has_add fun_info)) : is_add_cyclic (has_add fun_info) := sorry --non-trivial
lemma new_lemma_162692 (h0 : functor.add_const (cancel_comm_monoid_with_zero (simple_graph linarith.comp)) Type) : @unique_factorization_monoid.{0} (simple_graph.{0} linarith.comp) (@functor.add_const.run.{0 1} (cancel_comm_monoid_with_zero.{0} (simple_graph.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_162693 (h0 : ring (with_bot (random_gen (has_inv (random_gen linarith.ineq))))) : is_domain (with_bot (random_gen (has_inv (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_162694 (h0 : function.extfun Type ring) : @is_domain.{0} (has_emptyc.{0} linarith.ineq) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_emptyc.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_162695 (h0 : ring (distrib_lattice (has_inv (has_norm to_additive.value_type)))) : rank_condition (distrib_lattice (has_inv (has_norm to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_162696 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (group_with_zero name)) := sorry --non-trivial
lemma new_lemma_162697 (h0 : functor.add_const (group (has_bot pos)) linarith.comp) : @is_simple_group.{0} (has_bot.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_bot.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_162698 (h1 : topological_space (has_lt (mul_one_class fun_info))) : totally_disconnected_space (has_lt (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_162699 (h2 : topological_space (nondiscrete_normed_field linarith.ineq)) (h3 : preorder (nondiscrete_normed_field linarith.ineq)) : order_closed_topology (nondiscrete_normed_field linarith.ineq) := sorry --non-trivial
lemma new_lemma_162700 (h0 : functor.add_const (group (normed_comm_ring pos)) (has_neg (has_neg linarith.comp))) : @group.fg.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (normed_comm_ring.{0} pos)) (has_neg.{0} (has_neg.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_162701 (h0 : cancel_comm_monoid_with_zero (simple_graph (has_neg name))) : unique_factorization_monoid (simple_graph (has_neg name)) := sorry --non-trivial
lemma new_lemma_162702 (h0 : functor.add_const (semiring (has_pos_part linarith.comp)) Type) : @is_noetherian_ring.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 1} (semiring.{0} (has_pos_part.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_162703 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_162704 (h0 : topological_space (normed_comm_ring (semigroup name))) : sequential_space (normed_comm_ring (semigroup name)) := sorry --non-trivial
lemma new_lemma_162705 (h0 : function.extfun Type (functor.add_const (complete_lattice znum))) : @is_compactly_generated.{0} znum (@functor.add_const.run.{0 0} (complete_lattice.{0} znum) (option.{0} (option.{0} (option.{0} (option.{0} (option.{0} unsigned))))) (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (complete_lattice.{0} znum)) h0 (option.{0} (option.{0} (option.{0} (option.{0} (option.{0} unsigned)))))))  := sorry --non-trivial
lemma new_lemma_162706 (h1 : complete_lattice (has_nnnorm (random_gen to_additive.value_type))) : is_compactly_generated (has_nnnorm (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_162707 (h0 : topological_space (ordered_comm_ring (has_nndist pos))) : preirreducible_space (ordered_comm_ring (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_162708 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (mul_zero_class.{0} num) (@function.extfun_app.{2 1} Type add_group.{0} h0 (mul_zero_class.{0} num))  := sorry --non-trivial
lemma new_lemma_162709 (h0 : list (has_pos_part linarith.comp)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_162710 (h0 : complete_lattice (id (has_norm (has_norm (has_norm empty))))) : complete_lattice.is_Sup_finite_compact (id (has_norm (has_norm (has_norm empty)))) := sorry --non-trivial
lemma new_lemma_162711 (h2 h3 : multiset (simple_graph to_additive.value_type)) : multiset.disjoint h2 h3 := sorry --non-trivial
lemma new_lemma_162712 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (linear_ordered_comm_monoid_with_zero.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_comm_monoid_with_zero.{0} empty))  := sorry --non-trivial
lemma new_lemma_162713 (h0 : topological_space (canonically_ordered_comm_semiring (finset pos))) : preconnected_space (canonically_ordered_comm_semiring (finset pos)) := sorry --non-trivial
lemma new_lemma_162714 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (has_pos_part.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_pos_part.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_162715 (h0 : functor.add_const (function.extfun Type list) (boolean_algebra (has_neg_part Type))) : list.nodup (function.extfun_app (functor.add_const.run h0) (has_zero unsigned)) := sorry --non-trivial
lemma new_lemma_162716 (h0 : topological_space (has_zero (comm_group unsigned))) : normal_space (has_zero (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_162717 (h0 : complete_lattice (add_right_cancel_monoid congr_arg_kind)) : is_atomistic (add_right_cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_162718 (h0 : topological_space (add_group (has_norm congr_arg_kind))) : preirreducible_space (add_group (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_162719 (h0 : functor.add_const (topological_space (boolean_algebra linarith.comp)) (add_cancel_monoid Type)) : @normal_space.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.{0} linarith.comp)) (add_cancel_monoid.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_162720 (h0 : ordered_add_comm_monoid (ordered_cancel_add_comm_monoid (option (option pos)))) : archimedean (ordered_cancel_add_comm_monoid (option (option pos))) := sorry --non-trivial
lemma new_lemma_162721 (h0 : topological_space (has_top (has_norm (has_norm linarith.comp)))) : discrete_topology (has_top (has_norm (has_norm linarith.comp))) := sorry --non-trivial
lemma new_lemma_162722 (h0 : ordered_add_comm_monoid (ring (has_neg Type))) : archimedean (ring (has_neg Type)) := sorry --non-trivial
lemma new_lemma_162723 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @preconnected_space.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_162724 (h0 : topological_space (complete_semilattice_Sup (random_gen (has_norm fun_info)))) : totally_disconnected_space (complete_semilattice_Sup (random_gen (has_norm fun_info))) := sorry --non-trivial
lemma new_lemma_162725 (h0 : functor.add_const (function.extfun (Type 1) complete_lattice) Type) : @complete_lattice.is_Sup_finite_compact.{1} (has_pos_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) complete_lattice.{1}) Type h0) (has_pos_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_162726 (h0 : functor.add_const (add_group (canonically_ordered_monoid linarith.comp)) name) : @is_add_cyclic.{0} (canonically_ordered_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_group.{0} (canonically_ordered_monoid.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_162727 (h0 : topological_space (has_to_string (finset (finset linarith.comp)))) : preconnected_space (has_to_string (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_162728 (h0 : list (canonically_ordered_comm_semiring empty)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_162729 (h0 : functor.add_const (topological_space (ring name)) linarith.comp) : @discrete_topology.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_162730 (h0 : finset (comm_group unsigned)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_162731 (h0 : functor.add_const (topological_space (boolean_algebra.core environment.implicit_infer_kind)) Type) : @t0_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_162732 (h0 : topological_space (has_sdiff (has_zero (has_add pos)))) : topological_space.separable_space (has_sdiff (has_zero (has_add pos))) := sorry --non-trivial
lemma new_lemma_162733 (h0 : functor.add_const (fin has_zero.zero) real) : @is_noetherian_ring.{0} (canonically_ordered_monoid.{0} pos) (@matrix.vec_empty.{0} (semiring.{0} (canonically_ordered_monoid.{0} pos)) (@functor.add_const.run.{0 0} (fin (@has_zero.zero.{0} nat nat.has_zero)) real h0))  := sorry --non-trivial
lemma new_lemma_162734 (h0 : topological_space (complete_distrib_lattice (sub_neg_monoid real))) : regular_space (complete_distrib_lattice (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_162735 (h1 : not (ring (add_left_cancel_monoid char) -> false)) : @is_domain.{0} (add_left_cancel_monoid.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (add_left_cancel_monoid.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_162736 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (linear_ordered_semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (linear_ordered_semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_162737 (h0 : topological_space (is_R_or_C (semiring empty))) : normal_space (is_R_or_C (semiring empty)) := sorry --non-trivial
lemma new_lemma_162738 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @strong_rank_condition.{0} (has_top.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) ring.{0}) (has_top.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_162739 (h0 : filter (add_comm_monoid (option unsigned))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_162740 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (canonically_ordered_add_monoid.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_add_monoid.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_162741 (h0 : functor.add_const (uniform_space (canonically_ordered_comm_semiring pos)) name) : @separated_space.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (canonically_ordered_comm_semiring.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_162742 (h0 : group (simple_graph Type)) : group.fg (simple_graph Type) := sorry --non-trivial
lemma new_lemma_162743 (h0 : not (group (encodable linarith.comp_source) -> false)) : @is_cyclic.{0} (encodable.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (group.{0} (encodable.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_162744 (h0 : functor.add_const (semiring (has_to_string environment.implicit_infer_kind)) Type) : @is_noetherian_ring.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (semiring.{0} (has_to_string.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_162745 (h0 : functor.add_const (group (has_nndist environment.implicit_infer_kind)) unsigned) : @is_cyclic.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (has_nndist.{0} environment.implicit_infer_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_162746 (h0 : functor.add_const (function.extfun Type ring) environment.implicit_infer_kind) : @is_principal_ideal_ring.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) environment.implicit_infer_kind h0) (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_162747 (h1 : ring (random_gen (has_ssubset linarith.comp_source))) : rank_condition (random_gen (has_ssubset linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_162748 (h0 : function.extfun (finset Type) (has_mem.mem (semiring empty))) : @complete_space.{0} (semiring.{0} empty) (@finset.pi.empty.{1 0} Type uniform_space.{0} (semiring.{0} empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} empty)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_162749 (h0 : cancel_comm_monoid_with_zero (has_zero (add_cancel_monoid unsigned))) : unique_factorization_monoid (has_zero (add_cancel_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_162750 (h0 : topological_space (non_unital_non_assoc_ring linarith.ineq)) (h1 : has_add (non_unital_non_assoc_ring linarith.ineq)) : has_continuous_add (non_unital_non_assoc_ring linarith.ineq) := sorry --non-trivial
lemma new_lemma_162751 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (has_neg.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_neg.{0} name))  := sorry --non-trivial
lemma new_lemma_162752 (h1 : add_group (with_one (has_top linarith.comp_source))) : is_add_cyclic (with_one (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_162753 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} (metric_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (metric_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_162754 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (sub_neg_monoid.{0} real) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (sub_neg_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_162755 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (linear_ordered_comm_ring.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (linear_ordered_comm_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_162756 (h0 : group (normed_group (has_inv linarith.comp_source))) : group.fg (normed_group (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_162757 (h0 : topological_space (has_neg_part (boolean_algebra.core (mul_zero_class pos)))) : preirreducible_space (has_neg_part (boolean_algebra.core (mul_zero_class pos))) := sorry --non-trivial
lemma new_lemma_162758 (h0 : not (complete_lattice (measurable_space to_additive.value_type) -> false)) : is_compactly_generated (measurable_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_162759 (h0 : functor.add_const (topological_space (has_pos_part pos)) pos) : @irreducible_space.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_162760 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} linarith.comp (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) linarith.comp)  := sorry --non-trivial
lemma new_lemma_162761 (h0 : add_group (normed_field (canonically_linear_ordered_monoid reducibility_hints))) : is_add_cyclic (normed_field (canonically_linear_ordered_monoid reducibility_hints)) := sorry --non-trivial
lemma new_lemma_162762 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (canonically_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (canonically_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_162763 (h0 : functor.add_const (group (has_nndist name)) Type) : @group.fg.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 1} (group.{0} (has_nndist.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_162764 (h0 : complete_lattice (has_Inf (has_neg (has_neg (has_neg pos))))) : complete_lattice.is_Sup_finite_compact (has_Inf (has_neg (has_neg (has_neg pos)))) := sorry --non-trivial
lemma new_lemma_162765 (h0 : functor.add_const (group (ring Type)) (has_to_string linarith.comp)) : @is_cyclic.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (ring.{1} Type)) (has_to_string.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_162766 (h0 : functor.add_const (add_monoid (ordered_comm_ring linarith.comp)) name) : @add_monoid.fg.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_monoid.{0} (ordered_comm_ring.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_162767 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @normalizer_condition.{1} (has_neg.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 group.{1}) (has_neg.{1} Type))  := sorry --non-trivial
lemma new_lemma_162768 (h0 : ring (has_nndist num)) : is_domain (has_nndist num) := sorry --non-trivial
lemma new_lemma_162769 (h1 : group (has_norm congr_arg_kind)) : normalizer_condition (has_norm congr_arg_kind) := sorry --non-trivial
lemma new_lemma_162770 (h0 : finset (partial_order (semiring empty))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_162771 (h0 : function.extfun Type group) : @normalizer_condition.{0} (with_bot.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} h0 (with_bot.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_162772 (h0 : uniform_space (has_append (random_gen (random_gen (random_gen (random_gen (random_gen char))))))) : complete_space (has_append (random_gen (random_gen (random_gen (random_gen (random_gen char)))))) := sorry --non-trivial
lemma new_lemma_162773 (h0 : finset (simple_graph linarith.comp)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_162774 (h0 : filter (option pos)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_162775 (h0 : set (set fun_info)) (h1 : set fun_info) : measurable_space.dynkin_system.generate_has h0 h1 := sorry --non-trivial
lemma new_lemma_162776 (h0 : functor.add_const (function.extfun Type complete_lattice) (finset (finset linarith.comp))) : @is_atomistic.{0} (add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) (finset.{0} (finset.{0} linarith.comp)) h0) (add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_162777 (h0 : group (has_emptyc (has_norm (semiring congr_arg_kind)))) : is_cyclic (has_emptyc (has_norm (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_162778 (h0 : monoid (denumerable (random_gen to_additive.value_type))) : monoid.fg (denumerable (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_162779 (h0 : function.extfun (finset Type) (has_mem.mem fun_info)) : @complete_space.{0} fun_info (@finset.pi.empty.{1 0} Type uniform_space.{0} fun_info (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) fun_info) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_162780 (h0 : topological_space (partial_order (semiring (option (option unsigned))))) : irreducible_space (partial_order (semiring (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_162781 (h0 : functor.add_const (topological_space (is_R_or_C empty)) empty) : @loc_path_connected_space.{0} (is_R_or_C.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (is_R_or_C.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_162782 (h0 : ordered_add_comm_monoid (has_pos_part (has_pos_part pos))) : archimedean (has_pos_part (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_162783 (h0 : function.extfun Type (functor.comp uniform_space has_nndist)) : @separated_space.{0} (has_nndist.{0} pos) (@functor.comp.run.{0 0 0} uniform_space.{0} has_nndist.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} uniform_space.{0} has_nndist.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_162784 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @totally_disconnected_space.{1} (canonically_ordered_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (canonically_ordered_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_162785 (h0 : monoid (has_norm linarith.comp_source)) : monoid.fg (has_norm linarith.comp_source) := sorry --non-trivial
lemma new_lemma_162786 (h0 : uniform_space (has_top (semiring linarith.comp))) : complete_space (has_top (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_162787 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (mul_zero_class.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (mul_zero_class.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_162788 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (simple_graph.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (simple_graph.{0} empty))  := sorry --non-trivial
lemma new_lemma_162789 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (linear_ordered_field.{0} ennreal) (@function.extfun_app.{2 1} Type add_group.{0} h0 (linear_ordered_field.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_162790 (h2 : complete_lattice (nondiscrete_normed_field ereal)) : complete_lattice.is_Sup_finite_compact (nondiscrete_normed_field ereal) := sorry --non-trivial
lemma new_lemma_162791 (h0 : topological_space (semigroup (has_add linarith.comp))) : path_connected_space (semigroup (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_162792 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (as_linear_order empty)) := sorry --non-trivial
lemma new_lemma_162793 (h0 : functor.add_const (complete_lattice (has_Sup unsigned)) (semiring empty)) : @is_compactly_generated.{0} (has_Sup.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_Sup.{0} unsigned)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_162794 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_neg_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_162795 (h0 : topological_space (distrib (has_nnnorm (uniform_space linarith.ineq)))) : totally_disconnected_space (distrib (has_nnnorm (uniform_space linarith.ineq))) := sorry --non-trivial
lemma new_lemma_162796 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (pseudo_metric_space ennreal)) := sorry --non-trivial
lemma new_lemma_162797 (h0 : ring (non_assoc_semiring (semiring unsigned))) : is_principal_ideal_ring (non_assoc_semiring (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_162798 (h0 : topological_space (comm_group (has_add linarith.comp))) : irreducible_space (comm_group (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_162799 (h0 : ring (has_inv (random_gen (has_ssubset string_imp)))) : is_domain (has_inv (random_gen (has_ssubset string_imp))) := sorry --non-trivial
lemma new_lemma_162800 (h0 : function.extfun Type (functor.add_const (topological_space (linear_ordered_comm_monoid_with_zero empty)))) : @t0_space.{0} (linear_ordered_comm_monoid_with_zero.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_comm_monoid_with_zero.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (linear_ordered_comm_monoid_with_zero.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_162801 (h0 : topological_space (ordered_comm_monoid (has_Inf name))) : totally_separated_space (ordered_comm_monoid (has_Inf name)) := sorry --non-trivial
lemma new_lemma_162802 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (bin_tree.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (bin_tree.{0} num))  := sorry --non-trivial
lemma new_lemma_162803 (h0 : functor.add_const (ring (ring Type)) Type) : @strong_rank_condition.{1} (ring.{1} Type) (@functor.add_const.run.{1 1} (ring.{1} (ring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_162804 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_162805 (h0 : filter (has_to_string (finset pos))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_162806 (h0 : topological_space (has_neg (finset (finset linarith.comp)))) : loc_path_connected_space (has_neg (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_162807 (h0 : topological_space (canonically_linear_ordered_monoid ennreal)) : normal_space (canonically_linear_ordered_monoid ennreal) := sorry --non-trivial
lemma new_lemma_162808 (h0 : topological_space (ordered_comm_monoid (comm_semigroup real))) : t0_space (ordered_comm_monoid (comm_semigroup real)) := sorry --non-trivial
lemma new_lemma_162809 (h0 : measurable_space (add_zero_class (option (has_inv (random_gen (random_gen (random_gen char))))))) (h1 : add_zero_class (option (has_inv (random_gen (random_gen (random_gen char))))) -> Prop) (h2 : measure_theory.measure (add_zero_class (option (has_inv (random_gen (random_gen (random_gen char))))))) : @ess_sup.{0 0} (add_zero_class.{0} (option.{0} (has_inv.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} char)))))) Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice) h0 h1 h2  := sorry --non-trivial
lemma new_lemma_162810 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (boolean_algebra.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_162811 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @complete_space.{1} (generalized_boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 uniform_space.{1}) (generalized_boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_162812 (h0 : group (has_inter (option ennreal))) : normalizer_condition (has_inter (option ennreal)) := sorry --non-trivial
lemma new_lemma_162813 (h0 : semiring (denumerable string_imp)) (h1 : ideal (denumerable string_imp)) : ideal.fg h1 := sorry --non-trivial
lemma new_lemma_162814 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_neg.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_162815 (h0 : add_group (boolean_algebra (has_add (add_comm_monoid environment.implicit_infer_kind)))) : is_add_cyclic (boolean_algebra (has_add (add_comm_monoid environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_162816 (h0 : uniform_space (add_semigroup (semiring empty))) : separated_space (add_semigroup (semiring empty)) := sorry --non-trivial
lemma new_lemma_162817 (h0 : functor.add_const (finset (has_neg_part pos)) pos) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_162818 (h0 : ring (cancel_monoid (finset name))) : is_domain (cancel_monoid (finset name)) := sorry --non-trivial
lemma new_lemma_162819 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (ordered_cancel_add_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_cancel_add_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_162820 (h1 : has_nnnorm fun_info -> Prop) (h2 : has_nnnorm fun_info) : set_of h1 h2 := sorry --non-trivial
lemma new_lemma_162821 (h0 : topological_space (bin_tree (semiring congr_arg_kind))) : irreducible_space (bin_tree (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_162822 (h0 : topological_space (has_nndist (option (option unsigned)))) : t0_space (has_nndist (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_162823 (h0 : fin has_zero.zero) : @group.fg.{0} (generalized_boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type group.{0}) h0) (generalized_boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_162824 (h0 : functor.add_const (uniform_space (simple_graph pos)) Type) : @complete_space.{0} (simple_graph.{0} pos) (@functor.add_const.run.{0 1} (uniform_space.{0} (simple_graph.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_162825 (h0 : group (add_comm_monoid (option ennreal))) : normalizer_condition (add_comm_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_162826 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_162827 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @is_principal_ideal_ring.{0} (has_add.{0} real) (@matrix.vec_empty.{0} (ring.{0} (has_add.{0} real)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_162828 (h0 : functor.add_const (cancel_comm_monoid_with_zero (plift num)) num) : @unique_factorization_monoid.{1} (plift.{1} num) (@functor.add_const.run.{1 0} (cancel_comm_monoid_with_zero.{1} (plift.{1} num)) num h0)  := sorry --non-trivial
lemma new_lemma_162829 (h0 : functor.add_const (group (add_comm_monoid Type)) name) : @normalizer_condition.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (add_comm_monoid.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_162830 (h0 : complete_lattice (group_with_zero (option num))) : is_atomistic (group_with_zero (option num)) := sorry --non-trivial
lemma new_lemma_162831 (h0 : ring (normed_comm_ring empty)) : is_principal_ideal_ring (normed_comm_ring empty) := sorry --non-trivial
lemma new_lemma_162832 (h0 : functor.add_const (complete_lattice (has_zero unsigned)) (option ennreal)) : @complete_lattice.is_Sup_finite_compact.{0} (has_zero.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_zero.{0} unsigned)) (option.{0} ennreal) h0)  := sorry --non-trivial
lemma new_lemma_162833 (h0 : ring (complete_semilattice_Sup (semiring (semiring unsigned)))) : is_principal_ideal_ring (complete_semilattice_Sup (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_162834 (h0 : complete_lattice (option ennreal)) : complete_lattice.is_Sup_finite_compact (option ennreal) := sorry --non-trivial
lemma new_lemma_162835 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_principal_ideal_ring.{1} (boolean_algebra.core.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ring.{1}) (boolean_algebra.core.{1} Type))  := sorry --non-trivial
lemma new_lemma_162836 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @complete_lattice.is_Sup_finite_compact.{1} (cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 complete_lattice.{1}) (cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_162837 (h0 : complete_lattice (has_to_string unsigned)) : complete_lattice.is_Sup_finite_compact (has_to_string unsigned) := sorry --non-trivial
lemma new_lemma_162838 (h0 : ring (measurable_space linarith.comp)) : is_domain (measurable_space linarith.comp) := sorry --non-trivial
lemma new_lemma_162839 (h0 : ring (has_ssubset ereal)) : rank_condition (has_ssubset ereal) := sorry --non-trivial
lemma new_lemma_162840 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (group_with_zero.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (group_with_zero.{0} num))  := sorry --non-trivial
lemma new_lemma_162841 (h0 : function.extfun Type ring) : @rank_condition.{0} (random_gen.{0} string_imp) (@function.extfun_app.{2 1} Type ring.{0} h0 (random_gen.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_162842 (h0 : has_le (non_unital_non_assoc_semiring fun_info)) (h1 : bounded_order (non_unital_non_assoc_semiring fun_info)) : is_simple_order (non_unital_non_assoc_semiring fun_info) := sorry --non-trivial
lemma new_lemma_162843 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (generalized_boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (generalized_boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_162844 (h0 : group (with_bot (has_norm empty))) : normalizer_condition (with_bot (has_norm empty)) := sorry --non-trivial
lemma new_lemma_162845 (h0 : ring (has_neg_part pos)) : strong_rank_condition (has_neg_part pos) := sorry --non-trivial
lemma new_lemma_162846 (h0 : functor.add_const (topological_space (add_cancel_monoid linarith.comp)) linarith.comp) : @normal_space.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_162847 (h0 : topological_space (option congr_arg_kind)) : discrete_topology (option congr_arg_kind) := sorry --non-trivial
lemma new_lemma_162848 (h0 : ring (has_neg (has_pos_part pos))) : rank_condition (has_neg (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_162849 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_inv.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inv.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_162850 (h0 : functor.add_const (topological_space (normed_comm_ring linarith.comp)) linarith.comp) : @sequential_space.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_162851 (h0 : functor.add_const (ring (has_neg_part name)) Type) : @rank_condition.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 1} (ring.{0} (has_neg_part.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_162852 (h1 : topological_space (has_nnnorm (random_gen (has_inv string_imp)))) : totally_disconnected_space (has_nnnorm (random_gen (has_inv string_imp))) := sorry --non-trivial
lemma new_lemma_162853 (h0 : function.extfun Type (functor.comp topological_space pseudo_metric_space)) : @totally_disconnected_space.{0} (pseudo_metric_space.{0} (has_to_string.{0} pos)) (@functor.comp.run.{0 0 0} topological_space.{0} pseudo_metric_space.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} pseudo_metric_space.{0}) h0 (has_to_string.{0} pos)))  := sorry --non-trivial
lemma new_lemma_162854 (h1 : not (topological_space (random_gen char) -> false)) : @path_connected_space.{0} (random_gen.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (random_gen.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_162855 (h0 : topological_space (has_bot (option unsigned))) : t1_space (has_bot (option unsigned)) := sorry --non-trivial
lemma new_lemma_162856 (h0 : functor.add_const (topological_space (has_Sup unsigned)) unsigned) : @topological_space.separable_space.{0} (has_Sup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Sup.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_162857 (h0 : ring (add_comm_monoid (has_neg pos))) : strong_rank_condition (add_comm_monoid (has_neg pos)) := sorry --non-trivial
lemma new_lemma_162858 (h0 : add_monoid (has_zero (has_pos_part Type))) : add_monoid.fg (has_zero (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_162859 (h0 : topological_space (has_norm (semiring num))) : discrete_topology (has_norm (semiring num)) := sorry --non-trivial
lemma new_lemma_162860 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (metric_space.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (metric_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_162861 (h0 : add_comm_group (has_nnnorm char)) (h1 : ring (add_comm_group.positive_cone (has_nnnorm char))) : strong_rank_condition (add_comm_group.positive_cone (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_162862 (h0 : functor.add_const (list (has_to_string environment.implicit_infer_kind)) name) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_162863 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (monoid_with_zero.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (monoid_with_zero.{0} num))  := sorry --non-trivial
lemma new_lemma_162864 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (add_cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (add_cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_162865 (h1 : ring (normed_group char)) : is_domain (normed_group char) := sorry --non-trivial
lemma new_lemma_162866 (h0 : function.extfun Type (functor.comp topological_space has_neg_part)) : @totally_separated_space.{0} (has_neg_part.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg_part.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} has_neg_part.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_162867 (h0 : functor.add_const (topological_space (normed_comm_ring pos)) pos) : @t0_space.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_162868 (h0 : list (has_pos_part (ring name))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_162869 (h0 : has_mem.mem (measurable_space empty) has_emptyc.emptyc) : filter.ne_bot (finset.pi.empty filter (measurable_space empty) h0) := sorry --non-trivial
lemma new_lemma_162870 (h0 h1 : multiset (mul_one_class (mul_one_class enat))) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_162871 (h0 : functor.add_const (group (boolean_algebra Type)) pos) : @is_simple_group.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (boolean_algebra.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_162872 (h0 : functor.add_const (topological_space (has_add linarith.comp)) Type) : @normal_space.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_add.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_162873 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (has_Inf real)) := sorry --non-trivial
lemma new_lemma_162874 (h0 : functor.add_const (function.extfun (Type 1) topological_space) environment.implicit_infer_kind) : @totally_disconnected_space.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) environment.implicit_infer_kind h0) (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_162875 (h1 : topological_space (has_div string.iterator_imp)) : t0_space (has_div string.iterator_imp) := sorry --non-trivial
lemma new_lemma_162876 (h0 : semiring (has_star (semiring num)) -> semiring (has_star (semiring num)) -> Prop) : is_strict_order (semiring (has_star (semiring num))) h0 := sorry --non-trivial
lemma new_lemma_162877 (h4 : ring linarith.ineq) : strong_rank_condition linarith.ineq := sorry --non-trivial
lemma new_lemma_162878 (h0 : functor.add_const (topological_space (cancel_monoid Type)) linarith.comp) : @irreducible_space.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (cancel_monoid.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_162879 (h0 : functor.add_const (function.extfun Type topological_space) name) : @topological_space.separable_space.{0} (normed_comm_ring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (normed_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_162880 (h0 : not (group (linear_ordered_semiring linarith.comp) -> false)) : @group.fg.{0} (linear_ordered_semiring.{0} linarith.comp) (@classical.by_contradiction'.{1} (group.{0} (linear_ordered_semiring.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_162881 (h0 : ring (with_bot (semiring congr_arg_kind))) : rank_condition (with_bot (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_162882 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (comm_group.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_group.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_162883 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_162884 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (has_norm.{0} char) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_norm.{0} char))  := sorry --non-trivial
lemma new_lemma_162885 (h0 : add_monoid (comm_semigroup (ordered_comm_monoid real))) : add_monoid.fg (comm_semigroup (ordered_comm_monoid real)) := sorry --non-trivial
lemma new_lemma_162886 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @path_connected_space.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_162887 (h0 : function.extfun Type topological_space) : @t1_space.{0} (has_nndist.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_162888 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (measure_theory.measure_space.{0} empty) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (measure_theory.measure_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_162889 (h0 : topological_space (mul_one_class (random_gen char))) : path_connected_space (mul_one_class (random_gen char)) := sorry --non-trivial
lemma new_lemma_162890 (h0 : uniform_space (has_emptyc (semiring num))) : complete_space (has_emptyc (semiring num)) := sorry --non-trivial
lemma new_lemma_162891 (h1 : not (add_group (non_unital_non_assoc_semiring linarith.comp_source) -> false)) : @is_add_cyclic.{0} (non_unital_non_assoc_semiring.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (add_group.{0} (non_unital_non_assoc_semiring.{0} linarith.comp_source)) h1)  := sorry --non-trivial
lemma new_lemma_162892 (h0 : functor.add_const (complete_lattice (pseudo_metric_space num)) ennreal) : @complete_lattice.is_Sup_finite_compact.{0} (pseudo_metric_space.{0} num) (@functor.add_const.run.{0 0} (complete_lattice.{0} (pseudo_metric_space.{0} num)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_162893 (h1 : uniform_space (has_emptyc congr_arg_kind)) : separated_space (has_emptyc congr_arg_kind) := sorry --non-trivial
lemma new_lemma_162894 (h0 : functor.add_const (topological_space (has_zero unsigned)) linarith.comp) : @topological_space.separable_space.{0} (has_zero.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_162895 (h0 : topological_space (has_bot Type)) : normal_space (has_bot Type) := sorry --non-trivial
lemma new_lemma_162896 (h0 : function.extfun Type (functor.add_const (topological_space (has_add linarith.comp)))) : @totally_disconnected_space.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} linarith.comp)) pos (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (has_add.{0} linarith.comp))) h0 pos))  := sorry --non-trivial
lemma new_lemma_162897 (h0 : not (add_group (random_gen (has_compl char)) -> false)) : @is_add_cyclic.{0} (random_gen.{0} (has_compl.{0} char)) (@classical.by_contradiction'.{1} (add_group.{0} (random_gen.{0} (has_compl.{0} char))) h0)  := sorry --non-trivial
lemma new_lemma_162898 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (normed_comm_ring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} h0 (normed_comm_ring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_162899 (h0 : topological_space (normed_comm_ring (has_add (boolean_algebra.core (add_comm_monoid name))))) : preconnected_space (normed_comm_ring (has_add (boolean_algebra.core (add_comm_monoid name)))) := sorry --non-trivial
lemma new_lemma_162900 (h0 : not (topological_space (partial_order empty) -> false)) : @locally_compact_space.{0} (partial_order.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (partial_order.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_162901 (h0 : topological_space (semigroup (has_neg (has_neg (finset linarith.comp))))) : totally_disconnected_space (semigroup (has_neg (has_neg (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_162902 (h0 : topological_space (finset linarith.comp)) : locally_compact_space (finset linarith.comp) := sorry --non-trivial
lemma new_lemma_162903 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_cancel_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_162904 (h0 : functor.add_const (list (normed_comm_ring Type)) (has_to_string environment.implicit_infer_kind)) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_162905 (h0 : functor.add_const (ordered_add_comm_monoid (cancel_monoid Type)) (has_add environment.implicit_infer_kind)) : @archimedean.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (ordered_add_comm_monoid.{1} (cancel_monoid.{1} Type)) (has_add.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_162906 (h0 : functor.add_const (cancel_comm_monoid_with_zero (partial_order congr_arg_kind)) empty) : @unique_factorization_monoid.{0} (partial_order.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (partial_order.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_162907 (h0 : topological_space (measurable_space unsigned)) : totally_separated_space (measurable_space unsigned) := sorry --non-trivial
lemma new_lemma_162908 (h0 : topological_space (topological_space (normed_group linarith.ineq))) : t0_space (topological_space (normed_group linarith.ineq)) := sorry --non-trivial
lemma new_lemma_162909 (h0 : group (metric_space unsigned)) : group.fg (metric_space unsigned) := sorry --non-trivial
lemma new_lemma_162910 (h0 : topological_space (ordered_comm_monoid (has_bot (sub_neg_monoid real)))) : locally_compact_space (ordered_comm_monoid (has_bot (sub_neg_monoid real))) := sorry --non-trivial
lemma new_lemma_162911 (h0 : functor.add_const (group (finset environment.implicit_infer_kind)) unsigned) : @is_simple_group.{0} (finset.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (finset.{0} environment.implicit_infer_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_162912 (h0 : ordered_comm_monoid (has_add (has_Inf (finset (has_Inf pos))))) : has_exists_mul_of_le (has_add (has_Inf (finset (has_Inf pos)))) := sorry --non-trivial
lemma new_lemma_162913 (h0 : add_group (has_nnnorm (has_append linarith.ineq))) : is_add_cyclic (has_nnnorm (has_append linarith.ineq)) := sorry --non-trivial
lemma new_lemma_162914 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (complete_distrib_lattice.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_162915 (h0 : add_monoid (has_zero Type)) : add_monoid.fg (has_zero Type) := sorry --non-trivial
lemma new_lemma_162916 (h0 : prod (finset congr_arg_kind) (finset congr_arg_kind)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_162917 (h0 : topological_space (has_to_string (normed_comm_ring environment.implicit_infer_kind))) : preirreducible_space (has_to_string (normed_comm_ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_162918 (h0 : ring (canonically_linear_ordered_monoid (has_add name))) : is_principal_ideal_ring (canonically_linear_ordered_monoid (has_add name)) := sorry --non-trivial
lemma new_lemma_162919 (h0 : filter (with_one (has_norm (has_norm congr_arg_kind)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_162920 (h0 : functor.add_const (ordered_add_comm_monoid (has_add pos)) name) : @archimedean.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_add.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_162921 (h0 : ring (semigroup (has_add (has_add linarith.comp)))) : strong_rank_condition (semigroup (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_162922 (h0 : add_monoid (mul_zero_class unsigned)) : add_monoid.fg (mul_zero_class unsigned) := sorry --non-trivial
lemma new_lemma_162923 (h0 : function.extfun Type topological_space) : @regular_space.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_162924 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_neg.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_162925 (h0 : functor.add_const (function.extfun Type group) Type) : @is_cyclic.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type group.{0}) Type h0) (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_162926 (h0 : functor.add_const (topological_space (ring environment.implicit_infer_kind)) pos) : @totally_separated_space.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_162927 (h0 : function.extfun ((Type 1 -> Type 1) -> Type 2) (function.extfun (Type 1 -> Type 1))) : @t1_space.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) (@function.extfun_app.{4 3} ((Type 1 → Type 1) → Type 2) (function.extfun.{3 3} (Type 1 → Type 1)) h0 (function.extfun.{3 2} (Type 1))) topological_space.{1}) (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_162928 (h0 : monoid (random_gen (semiring (has_norm empty)))) : monoid.fg (random_gen (semiring (has_norm empty))) := sorry --non-trivial
lemma new_lemma_162929 (h0 : comm_ring (metric_space unsigned)) : local_ring (metric_space unsigned) := sorry --non-trivial
lemma new_lemma_162930 (h0 : topological_space (partial_order empty)) : t0_space (partial_order empty) := sorry --non-trivial
lemma new_lemma_162931 (h0 : group (distrib_lattice (has_inv fun_info))) : is_cyclic (distrib_lattice (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_162932 (h0 : topological_space (add_comm_monoid (finset (finset (has_nndist Type))))) : t1_space (add_comm_monoid (finset (finset (has_nndist Type)))) := sorry --non-trivial
lemma new_lemma_162933 (h0 : topological_space (has_star (semiring empty))) : t0_space (has_star (semiring empty)) := sorry --non-trivial
lemma new_lemma_162934 (h0 : group (boolean_algebra.core (boolean_algebra.core (finset (finset Type))))) : is_simple_group (boolean_algebra.core (boolean_algebra.core (finset (finset Type)))) := sorry --non-trivial
lemma new_lemma_162935 (h0 : topological_space (group_with_zero (option num))) : totally_separated_space (group_with_zero (option num)) := sorry --non-trivial
lemma new_lemma_162936 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (add_comm_monoid ennreal)) := sorry --non-trivial
lemma new_lemma_162937 (h0 : ring (plift (normed_linear_ordered_group empty))) : is_principal_ideal_ring (plift (normed_linear_ordered_group empty)) := sorry --non-trivial
lemma new_lemma_162938 (h0 : has_mem.mem group has_emptyc.emptyc) : @normalizer_condition.{0} (normed_group.{0} num) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} h0) (normed_group.{0} num))  := sorry --non-trivial
lemma new_lemma_162939 (h0 : cancel_comm_monoid_with_zero (normed_comm_ring (option unsigned))) : unique_factorization_monoid (normed_comm_ring (option unsigned)) := sorry --non-trivial
lemma new_lemma_162940 (h0 : complete_lattice (simple_graph (linear_ordered_comm_group_with_zero string.iterator_imp))) : is_compactly_generated (simple_graph (linear_ordered_comm_group_with_zero string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_162941 (h0 : function.extfun Type group) : @group.fg.{0} (has_norm.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (has_norm.{0} empty))  := sorry --non-trivial
lemma new_lemma_162942 (h0 : add_comm_semigroup char -> add_comm_semigroup char) (h1 : add_comm_semigroup char) : function.is_fixed_pt h0 h1 := sorry --non-trivial
lemma new_lemma_162943 (h0 : functor.add_const (complete_lattice (has_to_string unsigned)) Type) : @complete_lattice.is_Sup_finite_compact.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 1} (complete_lattice.{0} (has_to_string.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_162944 (h0 : functor.add_const (ring (has_add pos)) Type) : @is_domain.{0} (has_add.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (has_add.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_162945 (h0 : functor.add_const (topological_space (has_neg linarith.comp)) Type) : @sequential_space.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_162946 (h0 : add_group (emetric_space unsigned)) : is_add_cyclic (emetric_space unsigned) := sorry --non-trivial
lemma new_lemma_162947 (h0 : function.extfun (finset Type) (has_mem.mem (semiring unsigned))) : @add_monoid.fg.{0} (semiring.{0} unsigned) (@finset.pi.empty.{1 0} Type add_monoid.{0} (semiring.{0} unsigned) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} unsigned)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_162948 (h0 : uniform_space (with_bot (random_gen to_additive.value_type))) : complete_space (with_bot (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_162949 (h0 : functor.add_const Prop (semigroup environment.implicit_infer_kind)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_162950 (h0 : not (topological_space (has_top linarith.comp) -> false)) : @t0_space.{0} (has_top.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (has_top.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_162951 (h0 : add_group (has_emptyc (random_gen (has_norm empty)))) : is_add_cyclic (has_emptyc (random_gen (has_norm empty))) := sorry --non-trivial
lemma new_lemma_162952 (h0 : add_monoid (with_bot (has_norm (has_norm (has_norm (has_top empty)))))) : add_monoid.fg (with_bot (has_norm (has_norm (has_norm (has_top empty))))) := sorry --non-trivial
lemma new_lemma_162953 (h0 : ring (nondiscrete_normed_field (nondiscrete_normed_field (normed_field fun_info)))) : strong_rank_condition (nondiscrete_normed_field (nondiscrete_normed_field (normed_field fun_info))) := sorry --non-trivial
lemma new_lemma_162954 (h0 : functor.add_const (group (ring linarith.comp)) (has_neg Type)) : @normalizer_condition.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (group.{0} (ring.{0} linarith.comp)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_162955 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_norm.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_norm.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_162956 (h0 : topological_space (complete_distrib_lattice (has_nndist Type))) : loc_path_connected_space (complete_distrib_lattice (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_162957 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @locally_compact_space.{0} (has_emptyc.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_emptyc.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_162958 (h0 : topological_space (plift (semiring empty))) : locally_compact_space (plift (semiring empty)) := sorry --non-trivial
lemma new_lemma_162959 (h0 : set (linear_ordered_comm_group_with_zero fun_info)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_162960 (h0 : functor.add_const (complete_lattice (has_zero name)) linarith.comp) : @is_atomistic.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_zero.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_162961 (h0 : cancel_comm_monoid_with_zero (ordered_comm_ring (ring Type))) : unique_factorization_monoid (ordered_comm_ring (ring Type)) := sorry --non-trivial
lemma new_lemma_162962 (h0 : functor.add_const (cancel_comm_monoid_with_zero (complete_linear_order unsigned)) unsigned) : @unique_factorization_monoid.{0} (complete_linear_order.{0} unsigned) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (complete_linear_order.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_162963 (h0 : topological_space (add_comm_monoid (ring name))) : totally_separated_space (add_comm_monoid (ring name)) := sorry --non-trivial
lemma new_lemma_162964 (h0 : topological_space (comm_group (add_comm_monoid pos))) : preconnected_space (comm_group (add_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_162965 (h0 : topological_space (ring (option congr_arg_kind))) : totally_separated_space (ring (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_162966 (h0 : functor.add_const (complete_lattice (add_comm_monoid empty)) unsigned) : @complete_lattice.is_Sup_finite_compact.{0} (add_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_comm_monoid.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_162967 (h0 : add_monoid (complete_semilattice_Sup (has_top unsigned))) : add_monoid.fg (complete_semilattice_Sup (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_162968 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (has_zero ennreal)) := sorry --non-trivial
lemma new_lemma_162969 (h0 : topological_space (add_comm_monoid (option (option (option (option (option empty))))))) : path_connected_space (add_comm_monoid (option (option (option (option (option empty)))))) := sorry --non-trivial
lemma new_lemma_162970 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (ring.{0} name) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (ring.{0} name))  := sorry --non-trivial
lemma new_lemma_162971 (h0 : has_Sup (has_Sup num) -> has_Sup (has_Sup num) -> Prop) : well_founded h0 := sorry --non-trivial
lemma new_lemma_162972 (h0 : ring (semi_normed_ring (mul_one_class (mul_one_class string.iterator_imp)))) : rank_condition (semi_normed_ring (mul_one_class (mul_one_class string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_162973 (h0 : ring (linear_ordered_add_comm_monoid_with_top congr_arg_kind)) : rank_condition (linear_ordered_add_comm_monoid_with_top congr_arg_kind) := sorry --non-trivial
lemma new_lemma_162974 (h0 : topological_space (semigroup (normed_comm_ring Type))) : t0_space (semigroup (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_162975 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (left_cancel_monoid.{0} (semiring.{0} (semiring.{0} empty))) (@function.extfun_app.{2 1} Type ring.{0} h0 (left_cancel_monoid.{0} (semiring.{0} (semiring.{0} empty))))  := sorry --non-trivial
lemma new_lemma_162976 (h0 : topological_space (normed_group (has_top linarith.comp_source))) : t0_space (normed_group (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_162977 (h0 : measurable_space (has_le to_additive.value_type)) (h1 : filter (has_le to_additive.value_type)) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_162978 (h0 : function.extfun Type group) : @group.fg.{0} (normed_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (normed_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_162979 (h0 : topological_space (linear_ordered_add_comm_group (with_one (has_inv string_imp)))) : totally_disconnected_space (linear_ordered_add_comm_group (with_one (has_inv string_imp))) := sorry --non-trivial
lemma new_lemma_162980 (h0 : add_group (has_neg_part (boolean_algebra.core name))) : is_add_cyclic (has_neg_part (boolean_algebra.core name)) := sorry --non-trivial
lemma new_lemma_162981 (h0 : functor.add_const (function.extfun Type topological_space) name) : @locally_compact_space.{0} (ordered_comm_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (ordered_comm_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_162982 (h0 : semiring (filter (option unsigned))) : is_noetherian_ring (filter (option unsigned)) := sorry --non-trivial
lemma new_lemma_162983 (h2 : set (fun_info -> std_gen)) : set.separates_points h2 := sorry --non-trivial
lemma new_lemma_162984 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (ordered_cancel_add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (ordered_cancel_add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_162985 (h0 : functor.add_const (group (ring linarith.comp)) pos) : @group.fg.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (ring.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_162986 (h0 : function.extfun Type ring) : @is_domain.{0} (ordered_ring.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (ordered_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_162987 (h0 : complete_lattice (has_pos_part (sub_neg_monoid Type))) : is_atomistic (has_pos_part (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_162988 (h0 : topological_space (has_zero ennreal)) : sequential_space (has_zero ennreal) := sorry --non-trivial
lemma new_lemma_162989 (h0 : topological_space (generalized_boolean_algebra real)) : normal_space (generalized_boolean_algebra real) := sorry --non-trivial
lemma new_lemma_162990 (h0 : functor.add_const (add_monoid (has_to_string ennreal)) pos) : @add_monoid.fg.{0} (has_to_string.{0} ennreal) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_to_string.{0} ennreal)) pos h0)  := sorry --non-trivial
lemma new_lemma_162991 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (has_bot.{0} pos) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (has_bot.{0} pos))  := sorry --non-trivial
lemma new_lemma_162992 (h0 : topological_space (has_bot (has_bot Type))) : t1_space (has_bot (has_bot Type)) := sorry --non-trivial
lemma new_lemma_162993 (h0 : not (add_group (linear_ordered_add_comm_group string_imp) -> false)) : @is_add_cyclic.{0} (linear_ordered_add_comm_group.{0} string_imp) (@classical.by_contradiction'.{1} (add_group.{0} (linear_ordered_add_comm_group.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_162994 (h0 : functor.add_const (ordered_add_comm_monoid (mul_zero_class unsigned)) unsigned) : @archimedean.{0} (mul_zero_class.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (mul_zero_class.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_162995 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (has_to_string.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_to_string.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_162996 (h0 : function.extfun Type (prod (has_nndist name))) : set.diagonal (has_nndist name) (function.extfun_app h0 (has_nndist name)) := sorry --non-trivial
lemma new_lemma_162997 (h0 : functor.add_const (ring (has_bot pos)) Type) : @is_domain.{0} (has_bot.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (has_bot.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_162998 (h0 : comm_semiring linarith.comp_source) (h1 : ring (linear_recurrence linarith.comp_source)) : is_domain (linear_recurrence linarith.comp_source) := sorry --non-trivial
lemma new_lemma_162999 (h0 : not (function.extfun Type topological_space -> false)) : @discrete_topology.{0} (has_star.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_star.{0} empty))  := sorry --non-trivial
lemma new_lemma_163000 (h0 : not (topological_space (id unsigned) -> false)) : @irreducible_space.{0} (@id.{2} Type unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (@id.{2} Type unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_163001 (h0 : topological_space (add_cancel_monoid (has_add name))) : totally_disconnected_space (add_cancel_monoid (has_add name)) := sorry --non-trivial
lemma new_lemma_163002 (h0 : complete_lattice (has_append (comm_ring (has_nnnorm (has_nnnorm (comm_ring fun_info)))))) : is_compactly_generated (has_append (comm_ring (has_nnnorm (has_nnnorm (comm_ring fun_info))))) := sorry --non-trivial
lemma new_lemma_163003 (h0 : complete_lattice (has_bot Type)) : is_compactly_generated (has_bot Type) := sorry --non-trivial
lemma new_lemma_163004 (h0 : functor.add_const (group (ring linarith.comp)) linarith.comp) : @normalizer_condition.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (ring.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_163005 (h0 : group (has_compl (random_gen (random_gen (random_gen (random_gen to_additive.value_type)))))) : group.fg (has_compl (random_gen (random_gen (random_gen (random_gen to_additive.value_type))))) := sorry --non-trivial
lemma new_lemma_163006 (h0 : topological_space nat) : path_connected_space nat := sorry --non-trivial
lemma new_lemma_163007 (h0 : topological_space (has_zero (has_add pos))) : normal_space (has_zero (has_add pos)) := sorry --non-trivial
lemma new_lemma_163008 : infinite (has_nndist (has_nndist (has_add (semigroup environment.implicit_infer_kind)))) := sorry --non-trivial
lemma new_lemma_163009 (h0 : topological_space (has_top (random_gen linarith.comp_source))) : path_connected_space (has_top (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_163010 (h0 : ordered_add_comm_monoid (semigroup (has_nndist name))) : archimedean (semigroup (has_nndist name)) := sorry --non-trivial
lemma new_lemma_163011 (h0 : functor.add_const (filter (has_add Type)) Type) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_163012 (h0 : complete_lattice (has_emptyc (has_top (has_top (has_top linarith.ineq))))) : is_compactly_generated (has_emptyc (has_top (has_top (has_top linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_163013 (h1 : topological_space (has_nnnorm (mul_one_class char))) : t0_space (has_nnnorm (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_163014 (h0 : functor.add_const (ring (cancel_monoid environment.implicit_infer_kind)) linarith.comp) : @strong_rank_condition.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (cancel_monoid.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_163015 (h0 : topological_space (add_comm_semigroup std_gen)) : path_connected_space (add_comm_semigroup std_gen) := sorry --non-trivial
lemma new_lemma_163016 (h0 : ring (has_one (has_norm fun_info))) : strong_rank_condition (has_one (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_163017 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} (normed_group.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (normed_group.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_163018 (h1 : complete_lattice (simple_graph string_imp)) : is_compactly_generated (simple_graph string_imp) := sorry --non-trivial
lemma new_lemma_163019 (h0 : functor.add_const (list (complete_distrib_lattice environment.implicit_infer_kind)) linarith.comp) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_163020 (h0 : group (normed_lattice_add_comm_group (has_Inf (has_neg linarith.comp)))) : is_cyclic (normed_lattice_add_comm_group (has_Inf (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_163021 (h0 : has_mem.mem (id unsigned) has_emptyc.emptyc) : @preirreducible_space.{0} (@id.{2} Type unsigned) (@finset.pi.empty.{1 0} Type topological_space.{0} (@id.{2} Type unsigned) h0)  := sorry --non-trivial
lemma new_lemma_163022 (h0 : topological_space (complete_semilattice_Sup (random_gen (random_gen linarith.comp_source)))) : totally_separated_space (complete_semilattice_Sup (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_163023 (h0 : with_bot (function.extfun Type topological_space)) (h1 : ne h0 has_bot.bot) : @irreducible_space.{0} unsigned (@function.extfun_app.{2 1} Type topological_space.{0} (@with_bot.unbot.{1} (function.extfun.{2 1} Type topological_space.{0}) h0 h1) unsigned)  := sorry --non-trivial
lemma new_lemma_163024 (h0 : functor.add_const (ring (has_neg_part name)) (comm_group name)) : @is_domain.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (has_neg_part.{0} name)) (comm_group.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_163025 (h0 : not (topological_space (linear_ordered_comm_group_with_zero to_additive.value_type) -> false)) : @totally_disconnected_space.{0} (linear_ordered_comm_group_with_zero.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_comm_group_with_zero.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_163026 (h0 : list (semigroup (has_Inf (finset (has_Inf (has_pos_part (has_add pos))))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_163027 (h0 : ring (has_add (has_top (has_add string_imp)))) : strong_rank_condition (has_add (has_top (has_add string_imp))) := sorry --non-trivial
lemma new_lemma_163028 (h0 : functor.add_const (topological_space (mul_zero_class environment.implicit_infer_kind)) Type) : @regular_space.{0} (mul_zero_class.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (mul_zero_class.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_163029 (h0 : ordered_add_comm_monoid (has_inter (option ennreal))) : archimedean (has_inter (option ennreal)) := sorry --non-trivial
lemma new_lemma_163030 (h0 : filter (monoid congr_arg_kind)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_163031 (h0 : functor.add_const (finset unsigned) (option pos)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_163032 (h0 : topological_space (option congr_arg_kind)) : totally_separated_space (option congr_arg_kind) := sorry --non-trivial
lemma new_lemma_163033 (h0 : functor.add_const (cancel_comm_monoid_with_zero (measurable_space.dynkin_system name)) Type) : @unique_factorization_monoid.{0} (measurable_space.dynkin_system.{0} name) (@functor.add_const.run.{0 1} (cancel_comm_monoid_with_zero.{0} (measurable_space.dynkin_system.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_163034 (h0 : fin has_zero.zero) : @t0_space.{0} (ordered_comm_ring.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_ring.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_163035 (h0 : not (uniform_space (has_append string_imp) -> false)) : @complete_space.{0} (has_append.{0} string_imp) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_append.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_163036 (h0 : ring (canonically_ordered_monoid (has_add real))) : is_principal_ideal_ring (canonically_ordered_monoid (has_add real)) := sorry --non-trivial
lemma new_lemma_163037 (h0 : has_mem.mem (has_top linarith.comp) has_emptyc.emptyc) : @strong_rank_condition.{0} (has_top.{0} linarith.comp) (@finset.pi.empty.{1 0} Type ring.{0} (has_top.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_163038 (h0 : semiring (has_bot (has_add pos))) : is_noetherian_ring (has_bot (has_add pos)) := sorry --non-trivial
lemma new_lemma_163039 (h0 : functor.add_const (functor.add_const (topological_space Type) linarith.comp) linarith.comp) : @regular_space.{1} Type (@functor.add_const.run.{1 0} (topological_space.{1} Type) linarith.comp (@functor.add_const.run.{1 0} (functor.add_const.{1 0} (topological_space.{1} Type) linarith.comp) linarith.comp h0))  := sorry --non-trivial
lemma new_lemma_163040 (h0 : has_mem.mem (has_top num) has_emptyc.emptyc) : @is_atomistic.{0} (has_top.{0} num) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (has_top.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_163041 (h0 : not (function.extfun Type ring -> false)) : @strong_rank_condition.{0} (has_emptyc.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (has_emptyc.{0} empty))  := sorry --non-trivial
lemma new_lemma_163042 (h0 : functor.add_const (filter (has_neg environment.implicit_infer_kind)) linarith.comp) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_163043 (h0 : uniform_space (has_edist (option unsigned))) : separated_space (has_edist (option unsigned)) := sorry --non-trivial
lemma new_lemma_163044 (h0 : functor.add_const Prop (cancel_monoid ennreal)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_163045 (h1 : ring (denumerable reducibility_hints)) : rank_condition (denumerable reducibility_hints) := sorry --non-trivial
lemma new_lemma_163046 (h0 : functor.add_const (ring (normed_comm_ring pos)) (has_Inf linarith.comp)) : @is_domain.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (normed_comm_ring.{0} pos)) (has_Inf.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_163047 (h0 : functor.add_const (topological_space (generalized_boolean_algebra Type)) pos) : @totally_separated_space.{1} (generalized_boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (generalized_boolean_algebra.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_163048 (h0 : has_mem.mem (has_emptyc (random_gen linarith.comp_source)) has_emptyc.emptyc) : @discrete_topology.{0} (has_emptyc.{0} (random_gen.{0} linarith.comp_source)) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_emptyc.{0} (random_gen.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_163049 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (has_emptyc.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_emptyc.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_163050 (h1 : ring (has_union (has_top congr_arg_kind))) : is_domain (has_union (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_163051 (h0 : group (with_zero (has_nnnorm linarith.ineq))) : is_cyclic (with_zero (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_163052 (h0 : filter (distrib_lattice (has_norm to_additive.value_type))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_163053 (h0 : topological_space (linear_ordered_field (option (option (option (option (option (option (option empty))))))))) : t0_space (linear_ordered_field (option (option (option (option (option (option (option empty)))))))) := sorry --non-trivial
lemma new_lemma_163054 (h0 : group (ring (has_add (has_add (has_add name))))) : is_simple_group (ring (has_add (has_add (has_add name)))) := sorry --non-trivial
lemma new_lemma_163055 (h0 : topological_space (semigroup linarith.comp)) : preirreducible_space (semigroup linarith.comp) := sorry --non-trivial
lemma new_lemma_163056 (h0 : ring (pseudo_metric_space (has_add pos))) : is_domain (pseudo_metric_space (has_add pos)) := sorry --non-trivial
lemma new_lemma_163057 (h0 : ring (uniform_space (random_gen (random_gen char)))) : is_domain (uniform_space (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_163058 (h0 : finset (normed_comm_ring (add_comm_monoid (has_add unsigned)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_163059 (h0 : measurable_space (mul_one_class ereal)) (h1 : filter (mul_one_class ereal)) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_163060 (h0 : ordered_add_comm_monoid (boolean_algebra (boolean_algebra Type))) : archimedean (boolean_algebra (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_163061 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (add_semigroup.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_163062 (h0 : ring (normed_comm_ring (option (option (option (option (option empty))))))) : is_domain (normed_comm_ring (option (option (option (option (option empty)))))) := sorry --non-trivial
lemma new_lemma_163063 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (normed_group.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (normed_group.{0} num))  := sorry --non-trivial
lemma new_lemma_163064 (h0 : function.extfun Type (functor.add_const (topological_space Type))) : @preconnected_space.{1} Type (@functor.add_const.run.{1 0} (topological_space.{1} Type) environment.implicit_infer_kind (@function.extfun_app.{2 2} Type (functor.add_const.{1 0} (topological_space.{1} Type)) h0 environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_163065 (h0 : topological_space (ring (has_add (has_add pos)))) : irreducible_space (ring (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_163066 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (preorder.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (preorder.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_163067 (h0 : functor.add_const (filter (ring environment.implicit_infer_kind)) linarith.comp) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_163068 (h0 : ring (add_cancel_monoid (has_add (has_add (has_add Type))))) : is_domain (add_cancel_monoid (has_add (has_add (has_add Type)))) := sorry --non-trivial
lemma new_lemma_163069 (h1 : set (add_comm_semigroup linarith.ineq -> enat)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_163070 (h0 : not (group (add_group num) -> false)) : @group.fg.{0} (add_group.{0} num) (@classical.by_contradiction'.{1} (group.{0} (add_group.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_163071 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (has_union.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_union.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_163072 (h0 : functor.add_const (ordered_add_comm_monoid (has_add pos)) (has_neg name)) : @archimedean.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_add.{0} pos)) (has_neg.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_163073 (h0 : functor.comp topological_space add_cancel_monoid ennreal) : @sequential_space.{0} (add_cancel_monoid.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} add_cancel_monoid.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_163074 (h0 : ring (ring (comm_group pos))) : is_domain (ring (comm_group pos)) := sorry --non-trivial
lemma new_lemma_163075 (h0 : topological_space (finset empty)) : preconnected_space (finset empty) := sorry --non-trivial
lemma new_lemma_163076 (h0 : functor.add_const (group (complete_distrib_lattice pos)) pos) : @normalizer_condition.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (complete_distrib_lattice.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_163077 (h0 : not (topological_space (normed_field fun_info) -> false)) : @t0_space.{0} (normed_field.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_field.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_163078 (h0 : filter (add_cancel_monoid num)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_163079 (h0 : list (with_one (has_inv (has_norm to_additive.value_type)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_163080 (h0 : not (complete_lattice (metric_space reducibility_hints) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (metric_space.{0} reducibility_hints) (@classical.by_contradiction'.{1} (complete_lattice.{0} (metric_space.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_163081 (h0 : not (complete_lattice (semi_normed_ring linarith.ineq) -> false)) : @is_compactly_generated.{0} (semi_normed_ring.{0} linarith.ineq) (@classical.by_contradiction'.{1} (complete_lattice.{0} (semi_normed_ring.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_163082 (h0 : complete_lattice (normed_field string.iterator_imp)) : is_compactly_generated (normed_field string.iterator_imp) := sorry --non-trivial
lemma new_lemma_163083 (h0 : fin has_zero.zero) : @has_exists_mul_of_le.{0} (ordered_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) h0) (ordered_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_163084 (h0 : monoid (boolean_algebra.core (cancel_monoid environment.implicit_infer_kind))) : monoid.fg (boolean_algebra.core (cancel_monoid environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_163085 (h0 : has_mem.mem group has_emptyc.emptyc) : @normalizer_condition.{0} (semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} h0) (semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_163086 (h0 : add_group (semigroup (has_add environment.implicit_infer_kind))) : is_add_cyclic (semigroup (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_163087 (h0 : filter (distrib_lattice (has_top to_additive.value_type))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_163088 (h0 : function.extfun (finset Type) (has_mem.mem (metric_space linarith.comp))) : @t0_space.{0} (metric_space.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (metric_space.{0} linarith.comp) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (metric_space.{0} linarith.comp)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_163089 (h0 : functor.add_const (cancel_comm_monoid_with_zero (semigroup name)) name) : @unique_factorization_monoid.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (semigroup.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_163090 (h0 : list (linear_ordered_add_comm_group (has_nnnorm linarith.comp_source))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_163091 (h0 : not (filter (measure_theory.measure_space num) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_163092 (h0 : ring (complete_semilattice_Sup (random_gen fun_info))) : rank_condition (complete_semilattice_Sup (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_163093 (h0 : complete_lattice (has_emptyc (has_top fun_info))) : complete_lattice.is_Sup_finite_compact (has_emptyc (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_163094 (h0 : not (function.extfun Type ring -> false)) : @strong_rank_condition.{0} (complete_linear_order.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (complete_linear_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_163095 (h0 : functor.add_const (filter (has_repr pos)) environment.implicit_infer_kind) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_163096 (h0 : functor.add_const (filter (finset pos)) (has_to_string environment.implicit_infer_kind)) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_163097 (h0 : not (function.extfun Type ring -> false)) : @strong_rank_condition.{0} (with_bot.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (with_bot.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_163098 (h0 : monoid (random_gen empty)) (h1 : topological_space (conj_classes (random_gen empty))) : totally_separated_space (conj_classes (random_gen empty)) := sorry --non-trivial
lemma new_lemma_163099 (h0 : set (has_div char)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_163100 (h0 : topological_space (comm_group (has_neg_part (has_to_string (has_add (has_neg_part ennreal)))))) : t1_space (comm_group (has_neg_part (has_to_string (has_add (has_neg_part ennreal))))) := sorry --non-trivial
lemma new_lemma_163101 (h0 : list (semigroup linarith.comp)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_163102 (h0 : topological_space (ordered_comm_ring (ring pos))) : totally_separated_space (ordered_comm_ring (ring pos)) := sorry --non-trivial
lemma new_lemma_163103 (h0 : function.extfun nat fin) : @normalizer_condition.{0} (sub_neg_monoid.{0} pos) (@matrix.vec_empty.{0} (group.{0} (sub_neg_monoid.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_163104 (h0 : functor.add_const (complete_lattice (partial_order empty)) empty) : @complete_lattice.is_Sup_finite_compact.{0} (partial_order.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (partial_order.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_163105 (h0 : functor.add_const (ordered_comm_monoid name) unsigned) : @has_exists_mul_of_le.{0} name (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} name) unsigned h0)  := sorry --non-trivial
lemma new_lemma_163106 (h2 : ring (encodable char)) : rank_condition (encodable char) := sorry --non-trivial
lemma new_lemma_163107 (h0 : functor.add_const (functor.add_const (ordered_comm_monoid environment.implicit_infer_kind) Type) pos) : @has_exists_mul_of_le.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} environment.implicit_infer_kind) Type (@functor.add_const.run.{0 0} (functor.add_const.{0 1} (ordered_comm_monoid.{0} environment.implicit_infer_kind) Type) pos h0))  := sorry --non-trivial
lemma new_lemma_163108 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @totally_separated_space.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_163109 (h0 : ring (has_nndist (ring (finset (ring Type))))) : strong_rank_condition (has_nndist (ring (finset (ring Type)))) := sorry --non-trivial
lemma new_lemma_163110 (h0 : cancel_comm_monoid_with_zero (linear_ordered_semiring unsigned)) : unique_factorization_monoid (linear_ordered_semiring unsigned) := sorry --non-trivial
lemma new_lemma_163111 (h0 : complete_lattice (semigroup linarith.comp)) : complete_lattice.is_Sup_finite_compact (semigroup linarith.comp) := sorry --non-trivial
lemma new_lemma_163112 (h0 : topological_space (mul_zero_class num)) : t0_space (mul_zero_class num) := sorry --non-trivial
lemma new_lemma_163113 (h0 : function.extfun Type group) : @is_cyclic.{0} (normed_group.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} h0 (normed_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_163114 (h0 : semiring (with_one (semiring empty))) : is_noetherian_ring (with_one (semiring empty)) := sorry --non-trivial
lemma new_lemma_163115 (h0 : functor.add_const (function.extfun Type topological_space) name) : @preirreducible_space.{0} (has_neg.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (has_neg.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_163116 (h0 : ring (topological_space (has_nnnorm (has_nnnorm (has_nnnorm fun_info))))) : rank_condition (topological_space (has_nnnorm (has_nnnorm (has_nnnorm fun_info)))) := sorry --non-trivial
lemma new_lemma_163117 (h0 : semiring (cancel_monoid (comm_monoid unsigned))) : is_noetherian_ring (cancel_monoid (comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_163118 (h0 : set (uniform_space string.iterator_imp)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_163119 (h0 : function.extfun Type (functor.add_const (ordered_comm_monoid (ordered_comm_ring linarith.comp)))) : @has_exists_mul_of_le.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (ordered_comm_ring.{0} linarith.comp)) (has_add.{0} (has_add.{0} (has_add.{0} linarith.comp))) (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ordered_comm_monoid.{0} (ordered_comm_ring.{0} linarith.comp))) h0 (has_add.{0} (has_add.{0} (has_add.{0} linarith.comp)))))  := sorry --non-trivial
lemma new_lemma_163120 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (with_bot.{0} num) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (with_bot.{0} num))  := sorry --non-trivial
lemma new_lemma_163121 (h0 : topological_space (has_add Type)) : normal_space (has_add Type) := sorry --non-trivial
lemma new_lemma_163122 (h0 : function.extfun Type (functor.add_const (uniform_space (ordered_ring empty)))) : @complete_space.{0} (ordered_ring.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (ordered_ring.{0} empty)) (semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (uniform_space.{0} (ordered_ring.{0} empty))) h0 (semiring.{0} congr_arg_kind)))  := sorry --non-trivial
lemma new_lemma_163123 (h0 : topological_space (non_assoc_semiring (option empty))) : loc_path_connected_space (non_assoc_semiring (option empty)) := sorry --non-trivial
lemma new_lemma_163124 (h0 : group (has_norm (has_norm congr_arg_kind))) : normalizer_condition (has_norm (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_163125 (h0 : uniform_space (add_group (semiring (semiring congr_arg_kind)))) : complete_space (add_group (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_163126 (h0 : functor.add_const (cancel_comm_monoid_with_zero (comm_group linarith.comp)) name) : @unique_factorization_monoid.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (comm_group.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_163127 (h0 : topological_space (left_cancel_semigroup (semiring empty))) : t1_space (left_cancel_semigroup (semiring empty)) := sorry --non-trivial
lemma new_lemma_163128 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (cancel_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_163129 (h0 : function.extfun Type group) : @is_simple_group.{0} (complete_distrib_lattice.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (complete_distrib_lattice.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_163130 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (@id.{2} Type unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (@id.{2} Type unsigned))  := sorry --non-trivial
lemma new_lemma_163131 (h0 : functor.add_const (topological_space (boolean_algebra linarith.comp)) name) : @preconnected_space.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_163132 (h0 : uniform_space (ordered_comm_ring (has_Inf linarith.comp))) : separated_space (ordered_comm_ring (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_163133 (h0 : not (topological_space (has_nnnorm to_additive.value_type) -> false)) : @locally_compact_space.{0} (has_nnnorm.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (has_nnnorm.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_163134 (h0 : ereal -> nat) (h1 h2 : ereal) : measure h0 h1 h2 := sorry --non-trivial
lemma new_lemma_163135 (h0 : functor.add_const (add_group (has_to_string linarith.comp)) linarith.comp) : @is_add_cyclic.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_group.{0} (has_to_string.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_163136 (h0 : ring (omega_complete_partial_order num)) : is_principal_ideal_ring (omega_complete_partial_order num) := sorry --non-trivial
lemma new_lemma_163137 (h0 : topological_space (boolean_algebra.core (finset (has_add environment.implicit_infer_kind)))) : preirreducible_space (boolean_algebra.core (finset (has_add environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_163138 (h0 : functor.comp topological_space boolean_algebra.core pos) : @discrete_topology.{0} (boolean_algebra.core.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} boolean_algebra.core.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_163139 (h0 : group (with_bot (random_gen (random_gen num)))) : normalizer_condition (with_bot (random_gen (random_gen num))) := sorry --non-trivial
lemma new_lemma_163140 (h0 : functor.add_const (function.extfun Type topological_space) name) : @normal_space.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_163141 (h0 : functor.add_const (monoid (has_nndist name)) linarith.comp) : @monoid.fg.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (monoid.{0} (has_nndist.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_163142 (h0 : topological_space (has_pos_part (has_pos_part (finset (has_add pos))))) : preconnected_space (has_pos_part (has_pos_part (finset (has_add pos)))) := sorry --non-trivial
lemma new_lemma_163143 (h0 : group (non_assoc_semiring (option empty))) : normalizer_condition (non_assoc_semiring (option empty)) := sorry --non-trivial
lemma new_lemma_163144 (h0 : has_lt (add_comm_semigroup (add_comm_semigroup ereal))) : no_max_order (add_comm_semigroup (add_comm_semigroup ereal)) := sorry --non-trivial
lemma new_lemma_163145 (h0 : group (add_group (semiring (semiring linarith.comp)))) : is_cyclic (add_group (semiring (semiring linarith.comp))) := sorry --non-trivial
lemma new_lemma_163146 (h0 : function.extfun (Type 1) ring) : @is_domain.{1} (sub_neg_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (sub_neg_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_163147 (h0 : list (normed_group (semiring congr_arg_kind))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_163148 (h1 : function.extfun Type topological_space) : @discrete_topology.{0} to_additive.value_type (@function.extfun_app.{2 1} Type topological_space.{0} h1 to_additive.value_type)  := sorry --non-trivial
lemma new_lemma_163149 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (with_bot.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (with_bot.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_163150 (h0 : topological_space (canonically_ordered_comm_semiring (option ennreal))) : regular_space (canonically_ordered_comm_semiring (option ennreal)) := sorry --non-trivial
lemma new_lemma_163151 (h0 : complete_lattice (mul_zero_class Type)) : is_compactly_generated (mul_zero_class Type) := sorry --non-trivial
lemma new_lemma_163152 (h0 : topological_space (add_cancel_monoid (has_neg name))) : preconnected_space (add_cancel_monoid (has_neg name)) := sorry --non-trivial
lemma new_lemma_163153 (h0 : complete_lattice (ring pos)) : is_compactly_generated (ring pos) := sorry --non-trivial
lemma new_lemma_163154 (h0 : topological_space (with_bot (has_norm unsigned))) : irreducible_space (with_bot (has_norm unsigned)) := sorry --non-trivial
lemma new_lemma_163155 (h0 : ring (finset (mul_one_class (ring (has_neg (has_add linarith.comp)))))) : is_principal_ideal_ring (finset (mul_one_class (ring (has_neg (has_add linarith.comp))))) := sorry --non-trivial
lemma new_lemma_163156 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (normed_group.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_group.{0} num))  := sorry --non-trivial
lemma new_lemma_163157 (h0 : topological_space (measurable_space.dynkin_system (semiring (semiring unsigned)))) : t0_space (measurable_space.dynkin_system (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_163158 (h0 : functor.add_const (topological_space (complete_distrib_lattice linarith.comp)) Type) : @normal_space.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (complete_distrib_lattice.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_163159 (h1 : ring (has_append linarith.ineq)) : rank_condition (has_append linarith.ineq) := sorry --non-trivial
lemma new_lemma_163160 (h0 : function.extfun Type (functor.add_const (complete_lattice nnreal))) : @is_atomistic.{0} nnreal (@functor.add_const.run.{0 0} (complete_lattice.{0} nnreal) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (complete_lattice.{0} nnreal)) h0 empty))  := sorry --non-trivial
lemma new_lemma_163161 (h0 : topological_space (has_ssubset (has_ssubset (has_ssubset to_additive.value_type)))) : irreducible_space (has_ssubset (has_ssubset (has_ssubset to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_163162 (h0 : topological_space (with_one (has_norm linarith.comp))) : normal_space (with_one (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_163163 (h0 : ring (semigroup name)) : rank_condition (semigroup name) := sorry --non-trivial
lemma new_lemma_163164 (h0 : topological_space (ordered_comm_ring (has_Inf (has_neg linarith.comp)))) : regular_space (ordered_comm_ring (has_Inf (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_163165 (h1 : measurable_space (add_comm_semigroup enat)) (h2 : measure_theory.measure (add_comm_semigroup enat)) : measure_theory.is_finite_measure h2 := sorry --non-trivial
lemma new_lemma_163166 (h0 : topological_space (comm_group (has_to_string (has_to_string (has_to_string unsigned))))) : t0_space (comm_group (has_to_string (has_to_string (has_to_string unsigned)))) := sorry --non-trivial
lemma new_lemma_163167 (h0 : functor.add_const (complete_lattice (canonically_linear_ordered_monoid name)) name) : @is_compactly_generated.{0} (canonically_linear_ordered_monoid.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (canonically_linear_ordered_monoid.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_163168 (h1 : topological_space (has_norm (random_gen (random_gen num)))) : discrete_topology (has_norm (random_gen (random_gen num))) := sorry --non-trivial
lemma new_lemma_163169 (h0 : fin has_zero.zero) : @monoid.fg.{0} (normed_lattice_add_comm_group.{0} real) (@function.extfun_app.{2 1} Type monoid.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type monoid.{0}) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)) (normed_lattice_add_comm_group.{0} real))  := sorry --non-trivial
lemma new_lemma_163170 (h0 : fin has_zero.zero) : @archimedean.{1} (add_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (ordered_add_comm_monoid.{1} (add_comm_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_163171 (h0 : group (comm_group (option name))) : group.fg (comm_group (option name)) := sorry --non-trivial
lemma new_lemma_163172 (h0 : functor.add_const (topological_space (has_to_string unsigned)) Type) : @totally_disconnected_space.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (has_to_string.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_163173 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem group)) : @normalizer_condition.{0} (with_bot.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} linarith.ineq))))) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) group.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (with_bot.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} linarith.ineq))))))  := sorry --non-trivial
lemma new_lemma_163174 (h0 : function.extfun (Type 1) semiring) : @is_noetherian_ring.{1} (ordered_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) semiring.{1} h0 (ordered_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_163175 (h0 : functor.add_const (filter (monoid empty)) unsigned) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_163176 (h0 : monoid (has_pos_part (has_Inf Type))) : monoid.fg (has_pos_part (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_163177 (h0 : functor.add_const (complete_lattice (semigroup Type)) (has_neg Type)) : @complete_lattice.is_Sup_finite_compact.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 1} (complete_lattice.{1} (semigroup.{1} Type)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_163178 (h0 : topological_space (has_neg (has_pos_part (finset pos)))) : totally_separated_space (has_neg (has_pos_part (finset pos))) := sorry --non-trivial
lemma new_lemma_163179 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @irreducible_space.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_163180 (h0 : list (option (option (option (option (option pos)))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_163181 (h0 : ring (non_unital_non_assoc_semiring (has_append linarith.comp_source))) : rank_condition (non_unital_non_assoc_semiring (has_append linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_163182 (h0 : not (filter (linear_ordered_add_comm_group enat) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_163183 (h0 : ordered_add_comm_monoid (plift num)) : archimedean (plift num) := sorry --non-trivial
lemma new_lemma_163184 (h0 : prod (linear_ordered_cancel_comm_monoid unsigned) (linear_ordered_cancel_comm_monoid unsigned)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_163185 (h0 : functor.add_const (topological_space (normed_linear_ordered_group congr_arg_kind)) unsigned) : @loc_path_connected_space.{0} (normed_linear_ordered_group.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_linear_ordered_group.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_163186 (h1 : filter (linear_ordered_add_comm_group to_additive.value_type)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_163187 (h0 : uniform_space (ring (boolean_algebra Type))) : complete_space (ring (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_163188 (h1 : complete_lattice (has_div std_gen)) : complete_lattice.is_Sup_finite_compact (has_div std_gen) := sorry --non-trivial
lemma new_lemma_163189 (h0 : function.extfun Type topological_space) : @normal_space.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_163190 (h0 : group (canonically_linear_ordered_monoid Type)) : group.fg (canonically_linear_ordered_monoid Type) := sorry --non-trivial
lemma new_lemma_163191 (h0 : functor.add_const (function.extfun Type filter) pos) : countable_Inter_filter (function.extfun_app (functor.add_const.run h0) (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_163192 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (option.{0} pos) (@function.extfun_app.{2 1} Type add_group.{0} h0 (option.{0} pos))  := sorry --non-trivial
lemma new_lemma_163193 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (semigroup.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (semigroup.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_163194 (h0 : ring (ring (has_add (ordered_comm_monoid (ordered_comm_monoid linarith.comp))))) : rank_condition (ring (has_add (ordered_comm_monoid (ordered_comm_monoid linarith.comp)))) := sorry --non-trivial
lemma new_lemma_163195 (h0 : uniform_space (has_star (ordered_cancel_comm_monoid (option unsigned)))) : separated_space (has_star (ordered_cancel_comm_monoid (option unsigned))) := sorry --non-trivial
lemma new_lemma_163196 (h0 : cancel_comm_monoid_with_zero (has_Inf (has_Inf (has_neg Type)))) : unique_factorization_monoid (has_Inf (has_Inf (has_neg Type))) := sorry --non-trivial
lemma new_lemma_163197 (h1 : complete_lattice (distrib_lattice char)) : complete_lattice.is_Sup_finite_compact (distrib_lattice char) := sorry --non-trivial
lemma new_lemma_163198 (h0 : ring (ordered_comm_monoid (normed_comm_ring (ordered_comm_monoid (ring name))))) : is_domain (ordered_comm_monoid (normed_comm_ring (ordered_comm_monoid (ring name)))) := sorry --non-trivial
lemma new_lemma_163199 (h0 : not (semiring (complete_linear_order congr_arg_kind) -> false)) : @is_noetherian_ring.{0} (complete_linear_order.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (semiring.{0} (complete_linear_order.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_163200 (h2 : add_group (topological_space fun_info)) : is_add_cyclic (topological_space fun_info) := sorry --non-trivial
lemma new_lemma_163201 (h0 : topological_space (with_one (has_union (option empty)))) : totally_separated_space (with_one (has_union (option empty))) := sorry --non-trivial
lemma new_lemma_163202 (h0 : topological_space (has_ssubset (mul_one_class reducibility_hints))) : totally_disconnected_space (has_ssubset (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_163203 (h0 : complete_lattice (linear_ordered_comm_ring (semiring (semiring unsigned)))) : complete_lattice.is_Sup_finite_compact (linear_ordered_comm_ring (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_163204 (h0 : not (complete_lattice (denumerable to_additive.value_type) -> false)) : @is_compactly_generated.{0} (denumerable.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (complete_lattice.{0} (denumerable.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_163205 (h0 : functor.add_const (filter (ordered_comm_ring linarith.comp)) (ring (ring (ring (ring (ring Type)))))) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_163206 (h0 : functor.add_const (topological_space Type) linarith.comp) : @topological_space.separable_space.{1} Type (@functor.add_const.run.{1 0} (topological_space.{1} Type) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_163207 (h0 : topological_space (mul_zero_class (option pos))) : totally_disconnected_space (mul_zero_class (option pos)) := sorry --non-trivial
lemma new_lemma_163208 (h0 : functor.comp group boolean_algebra Type) : @is_simple_group.{1} (boolean_algebra.{1} Type) (@functor.comp.run.{1 1 1} group.{1} boolean_algebra.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_163209 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (measure_theory.measure_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (measure_theory.measure_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_163210 (h1 : ring (non_unital_non_assoc_semiring char)) : rank_condition (non_unital_non_assoc_semiring char) := sorry --non-trivial
lemma new_lemma_163211 (h0 : functor.add_const (function.extfun Type semiring) (ring (has_add (has_add (has_add (has_add linarith.comp)))))) : @is_noetherian_ring.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type semiring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type semiring.{0}) (ring.{0} (has_add.{0} (has_add.{0} (has_add.{0} (has_add.{0} linarith.comp))))) h0) (normed_comm_ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_163212 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (simple_graph.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (simple_graph.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_163213 (h0 : functor.add_const (complete_lattice (has_zero pos)) pos) : @is_atomistic.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_zero.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_163214 (h0 : topological_space (complete_semilattice_Sup (has_norm fun_info))) : irreducible_space (complete_semilattice_Sup (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_163215 (h1 : set (has_ssubset reducibility_hints)) : set.subsingleton h1 := sorry --non-trivial
lemma new_lemma_163216 (h0 : not (list (partial_order unsigned) -> false)) : list.nodup (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_163217 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (ordered_cancel_add_comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (ordered_cancel_add_comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_163218 (h0 : function.extfun (finset Type) (has_mem.mem (with_bot empty))) : @path_connected_space.{0} (with_bot.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_bot.{0} empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_bot.{0} empty)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_163219 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_union.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_union.{0} num))  := sorry --non-trivial
lemma new_lemma_163220 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @strong_rank_condition.{1} Type (@function.extfun_app.{3 2} (Type 1) ring.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ring.{1}) Type)  := sorry --non-trivial
lemma new_lemma_163221 (h0 : add_monoid (id (has_top (has_top num)))) : add_monoid.fg (id (has_top (has_top num))) := sorry --non-trivial
lemma new_lemma_163222 (h1 : ring (mul_one_class (add_comm_semigroup linarith.ineq))) : is_domain (mul_one_class (add_comm_semigroup linarith.ineq)) := sorry --non-trivial
lemma new_lemma_163223 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (ordered_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_163224 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (ring.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_163225 (h0 : semiring linarith.comp_source) (h1 : polynomial linarith.comp_source) : polynomial.monic h1 := sorry --non-trivial
lemma new_lemma_163226 (h0 : not (ring (has_sub unsigned) -> false)) : @strong_rank_condition.{0} (has_sub.{0} unsigned) (@classical.by_contradiction'.{1} (ring.{0} (has_sub.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_163227 (h0 : functor.add_const (filter (has_neg name)) Type) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_163228 (h0 : functor.add_const (complete_lattice (has_to_string name)) pos) : @is_compactly_generated.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_to_string.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_163229 (h1 : topological_space (has_ssubset reducibility_hints)) : totally_disconnected_space (has_ssubset reducibility_hints) := sorry --non-trivial
lemma new_lemma_163230 (h0 : functor.add_const (uniform_space (has_to_string environment.implicit_infer_kind)) linarith.comp) : @complete_space.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_to_string.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_163231 (h0 : filter (add_cancel_comm_monoid congr_arg_kind)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_163232 (h0 : ring (has_to_string (has_add (has_add (has_add (has_add (has_add Type))))))) : rank_condition (has_to_string (has_add (has_add (has_add (has_add (has_add Type)))))) := sorry --non-trivial
lemma new_lemma_163233 (h0 : uniform_space (has_emptyc (random_gen (random_gen to_additive.value_type)))) : complete_space (has_emptyc (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_163234 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (@id.{2} Type unsigned) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (@id.{2} Type unsigned))  := sorry --non-trivial
lemma new_lemma_163235 (h0 : functor.add_const (topological_space (finset unsigned)) unsigned) : @preirreducible_space.{0} (finset.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_163236 (h0 : function.extfun Type (functor.add_const (topological_space (comm_monoid empty)))) : @preirreducible_space.{0} (comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_monoid.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (comm_monoid.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_163237 (h0 : ordered_add_comm_monoid (free_add_monoid (semiring empty))) : archimedean (free_add_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_163238 (h0 : ring (semigroup (option (mul_zero_class name)))) : rank_condition (semigroup (option (mul_zero_class name))) := sorry --non-trivial
lemma new_lemma_163239 (h0 : has_mem.mem (random_gen fun_info) has_emptyc.emptyc) : @totally_disconnected_space.{0} (random_gen.{0} fun_info) (@finset.pi.empty.{1 0} Type topological_space.{0} (random_gen.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_163240 (h0 : functor.add_const (list (cancel_monoid ennreal)) unsigned) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_163241 (h0 : function.extfun Type (functor.comp complete_lattice has_nndist)) : @complete_lattice.is_Sup_finite_compact.{0} (has_nndist.{0} pos) (@functor.comp.run.{0 0 0} complete_lattice.{0} has_nndist.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} complete_lattice.{0} has_nndist.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_163242 (h0 : function.extfun (Type 1) topological_space) : @preirreducible_space.{1} Type (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 Type)  := sorry --non-trivial
lemma new_lemma_163243 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (measurable_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (measurable_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_163244 (h2 : group (topological_space (has_nnnorm (add_cancel_comm_monoid (mul_one_class char))))) : is_cyclic (topological_space (has_nnnorm (add_cancel_comm_monoid (mul_one_class char)))) := sorry --non-trivial
lemma new_lemma_163245 (h0 : ring enat) : is_principal_ideal_ring enat := sorry --non-trivial
lemma new_lemma_163246 (h0 : uniform_space (ring (has_Inf (normed_comm_ring linarith.comp)))) : complete_space (ring (has_Inf (normed_comm_ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_163247 (h0 : functor.add_const (topological_space (comm_group pos)) ennreal) : @preirreducible_space.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} pos)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_163248 (h0 : uniform_space (has_Inf (has_Inf real))) : complete_space (has_Inf (has_Inf real)) := sorry --non-trivial
lemma new_lemma_163249 (h0 : function.extfun nat fin) : @is_domain.{0} (canonically_ordered_monoid.{0} pos) (@matrix.vec_empty.{0} (ring.{0} (canonically_ordered_monoid.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_163250 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @totally_separated_space.{0} (linear_ordered_semiring.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (linear_ordered_semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_163251 (h0 : finset (plift (semiring (semiring empty)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_163252 (h0 : functor.add_const (ring (left_cancel_monoid congr_arg_kind)) (semiring num)) : @is_principal_ideal_ring.{0} (left_cancel_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ring.{0} (left_cancel_monoid.{0} congr_arg_kind)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_163253 (h0 : has_mem.mem to_additive.value_type has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} to_additive.value_type (@finset.pi.empty.{1 0} Type complete_lattice.{0} to_additive.value_type h0)  := sorry --non-trivial
lemma new_lemma_163254 (h0 : topological_space (ordered_comm_ring (has_neg (has_neg linarith.comp)))) : path_connected_space (ordered_comm_ring (has_neg (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_163255 (h0 : functor.add_const (function.extfun Type topological_space) (ring (has_pos_part pos))) : @sequential_space.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (ring.{0} (has_pos_part.{0} pos)) h0) (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_163256 (h0 : left_cancel_monoid char -> left_cancel_monoid char -> Prop) : nonempty (is_strict_order (left_cancel_monoid char) h0) := sorry --non-trivial
lemma new_lemma_163257 (h0 : not (group (has_top unsigned) -> false)) : @is_cyclic.{0} (has_top.{0} unsigned) (@classical.by_contradiction'.{1} (group.{0} (has_top.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_163258 (h0 : complete_lattice (mul_zero_class Type)) : is_atomistic (mul_zero_class Type) := sorry --non-trivial
lemma new_lemma_163259 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (complete_linear_order.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (complete_linear_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_163260 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (measurable_space.dynkin_system.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (measurable_space.dynkin_system.{0} empty))  := sorry --non-trivial
lemma new_lemma_163261 (h0 : topological_space (add_comm_monoid (option (option unsigned)))) : path_connected_space (add_comm_monoid (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_163262 (h0 : function.extfun Type (functor.comp filter has_zero)) : filter.ne_bot (functor.comp.run (function.extfun_app h0 (has_to_string ennreal))) := sorry --non-trivial
lemma new_lemma_163263 (h0 : topological_space (with_bot (random_gen linarith.ineq))) : totally_disconnected_space (with_bot (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_163264 (h0 : functor.add_const (topological_space (add_semigroup unsigned)) empty) : @totally_disconnected_space.{0} (add_semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_semigroup.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_163265 (h0 : functor.add_const (semiring (has_to_string linarith.comp)) name) : @is_noetherian_ring.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (semiring.{0} (has_to_string.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_163266 (h0 : add_group (semigroup empty)) : is_add_cyclic (semigroup empty) := sorry --non-trivial
lemma new_lemma_163267 (h0 : functor.add_const (topological_space (has_to_string name)) (comm_group (comm_group pos))) : @discrete_topology.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} name)) (comm_group.{0} (comm_group.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_163268 (h0 : functor.add_const (complete_lattice (ring pos)) Type) : @is_compactly_generated.{0} (ring.{0} pos) (@functor.add_const.run.{0 1} (complete_lattice.{0} (ring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_163269 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} (with_bot.{0} empty) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (with_bot.{0} empty))  := sorry --non-trivial
lemma new_lemma_163270 (h0 : function.extfun (Type -> Type) (function.extfun Type)) (h1 : random_gen linarith.comp_source) : @is_of_fin_add_order.{0} (random_gen.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (random_gen.{0} linarith.comp_source)) h1  := sorry --non-trivial
lemma new_lemma_163271 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (has_dist.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_dist.{0} empty))  := sorry --non-trivial
lemma new_lemma_163272 (h2 : ring (semi_normed_comm_ring char)) : rank_condition (semi_normed_comm_ring char) := sorry --non-trivial
lemma new_lemma_163273 (h0 : topological_space (has_nndist (add_cancel_monoid pos))) : preconnected_space (has_nndist (add_cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_163274 (h0 : complete_lattice (has_top linarith.ineq)) : is_atomistic (has_top linarith.ineq) := sorry --non-trivial
lemma new_lemma_163275 (h0 : functor.add_const Prop (has_to_string (has_nndist pos))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_163276 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (boolean_algebra.core.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_163277 (h0 : topological_space (has_emptyc num)) : irreducible_space (has_emptyc num) := sorry --non-trivial
lemma new_lemma_163278 (h0 : ring (normed_group (has_ssubset to_additive.value_type))) : strong_rank_condition (normed_group (has_ssubset to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_163279 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (ordered_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_163280 (h0 h1 : multiset (has_div (mul_one_class linarith.ineq))) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_163281 (h0 : topological_space (add_comm_monoid unsigned)) : normal_space (add_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_163282 (h0 : functor.add_const (topological_space (ordered_comm_ring name)) linarith.comp) : @totally_separated_space.{0} (ordered_comm_ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_163283 (h0 : functor.add_const (list (normed_comm_ring linarith.comp)) environment.implicit_infer_kind) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_163284 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (canonically_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (canonically_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_163285 (h0 : not (topological_space (random_gen string_imp) -> false)) : @totally_disconnected_space.{0} (random_gen.{0} string_imp) (@classical.by_contradiction'.{1} (topological_space.{0} (random_gen.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_163286 (h0 : functor.add_const (ring (finset Type)) (has_neg (ordered_ring (has_Inf Type)))) : @rank_condition.{1} (finset.{1} Type) (@functor.add_const.run.{1 1} (ring.{1} (finset.{1} Type)) (has_neg.{1} (ordered_ring.{1} (has_Inf.{1} Type))) h0)  := sorry --non-trivial
lemma new_lemma_163287 (h0 : ordered_comm_monoid (has_zero (has_to_string (has_to_string pos)))) : has_exists_mul_of_le (has_zero (has_to_string (has_to_string pos))) := sorry --non-trivial
lemma new_lemma_163288 (h0 : finset (add_comm_monoid linarith.comp)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_163289 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (has_neg.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_neg.{0} empty))  := sorry --non-trivial
lemma new_lemma_163290 (h0 : uniform_space (add_left_cancel_semigroup (semiring empty))) : complete_space (add_left_cancel_semigroup (semiring empty)) := sorry --non-trivial
lemma new_lemma_163291 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (with_one.{0} (has_top.{0} num)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_one.{0} (has_top.{0} num)))  := sorry --non-trivial
lemma new_lemma_163292 (h0 : group (encodable linarith.comp_source)) : group.fg (encodable linarith.comp_source) := sorry --non-trivial
lemma new_lemma_163293 (h0 : cancel_comm_monoid_with_zero (has_Inf (has_add pos))) : unique_factorization_monoid (has_Inf (has_add pos)) := sorry --non-trivial
lemma new_lemma_163294 (h0 : topological_space (simple_graph (boolean_algebra.core (has_neg (has_Inf linarith.comp))))) : preirreducible_space (simple_graph (boolean_algebra.core (has_neg (has_Inf linarith.comp)))) := sorry --non-trivial
lemma new_lemma_163295 (h0 : functor.add_const (complete_lattice (has_zero name)) name) : @is_compactly_generated.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_zero.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_163296 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring name)) environment.implicit_infer_kind) : @irreducible_space.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_163297 (h0 : functor.add_const (filter pos) pos) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_163298 (h0 : not (group (random_gen linarith.comp_source) -> false)) : @is_cyclic.{0} (random_gen.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (group.{0} (random_gen.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_163299 (h0 : topological_space (has_inv (random_gen (random_gen (random_gen fun_info))))) : irreducible_space (has_inv (random_gen (random_gen (random_gen fun_info)))) := sorry --non-trivial
lemma new_lemma_163300 (h1 : topological_space (measurable_space to_additive.value_type)) : totally_separated_space (measurable_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_163301 (h0 : ordered_comm_monoid (ordered_comm_monoid (has_Inf (has_neg (has_neg real))))) : has_exists_mul_of_le (ordered_comm_monoid (has_Inf (has_neg (has_neg real)))) := sorry --non-trivial
lemma new_lemma_163302 (h0 : not (filter (fintype linarith.ineq) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_163303 (h0 : topological_space (canonically_ordered_comm_semiring (cancel_monoid pos))) : discrete_topology (canonically_ordered_comm_semiring (cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_163304 (h0 : functor.add_const Prop (ring environment.implicit_infer_kind)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_163305 (h0 : topological_space (comm_group (boolean_algebra Type))) : path_connected_space (comm_group (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_163306 (h0 : function.extfun Type multiset) : multiset.nodup (function.extfun_app h0 (has_neg unsigned)) := sorry --non-trivial
lemma new_lemma_163307 (h0 : topological_space (has_inv linarith.ineq)) : t0_space (has_inv linarith.ineq) := sorry --non-trivial
lemma new_lemma_163308 (h0 : not (complete_lattice (has_emptyc num) -> false)) : @is_compactly_generated.{0} (has_emptyc.{0} num) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_emptyc.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_163309 (h0 : functor.add_const (ring (has_neg Type)) linarith.comp) : @strong_rank_condition.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_neg.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_163310 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @normal_space.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_163311 (h0 : group (denumerable (has_nnnorm reducibility_hints))) : is_cyclic (denumerable (has_nnnorm reducibility_hints)) := sorry --non-trivial
lemma new_lemma_163312 (h1 : function.extfun Type uniform_space) : @complete_space.{0} num (@function.extfun_app.{2 1} Type uniform_space.{0} h1 num)  := sorry --non-trivial
lemma new_lemma_163313 (h1 : complete_lattice (distrib_lattice (random_gen char))) : is_compactly_generated (distrib_lattice (random_gen char)) := sorry --non-trivial
lemma new_lemma_163314 (h0 : functor.add_const (topological_space (has_star num)) congr_arg_kind) : @t0_space.{0} (has_star.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_163315 (h0 : filter (complete_distrib_lattice (has_add (has_add (finset name))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_163316 (h0 : add_group (has_top (random_gen (has_inv linarith.comp_source)))) : is_add_cyclic (has_top (random_gen (has_inv linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_163317 (h0 : fin has_zero.zero) : @sequential_space.{1} (ordered_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@matrix.vec_empty.{2} (function.extfun.{3 2} (Type 1) topological_space.{1}) h0) (ordered_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_163318 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (measurable_space.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (measurable_space.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_163319 (h0 : finset (linear_ordered_field (option (option empty)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_163320 (h0 : topological_space (add_right_cancel_monoid unsigned)) : totally_disconnected_space (add_right_cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_163321 (h0 : ring (distrib_lattice (random_gen (topological_space (random_gen (random_gen fun_info)))))) : is_domain (distrib_lattice (random_gen (topological_space (random_gen (random_gen fun_info))))) := sorry --non-trivial
lemma new_lemma_163322 (h0 : add_group (has_star (complete_linear_order (semiring congr_arg_kind)))) : is_add_cyclic (has_star (complete_linear_order (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_163323 (h1 : topological_space (has_emptyc linarith.comp_source)) : totally_disconnected_space (has_emptyc linarith.comp_source) := sorry --non-trivial
lemma new_lemma_163324 (h0 : ordered_add_comm_monoid (canonically_linear_ordered_monoid pos)) : archimedean (canonically_linear_ordered_monoid pos) := sorry --non-trivial
lemma new_lemma_163325 (h0 : fin has_zero.zero) : @has_exists_mul_of_le.{1} (has_pos_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_comm_monoid.{1} (@matrix.vec_empty.{2} (function.extfun.{3 2} (Type 1) ordered_comm_monoid.{1}) h0) (has_pos_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_163326 (h0 : monoid (finset (has_add name))) : monoid.fg (finset (has_add name)) := sorry --non-trivial
lemma new_lemma_163327 (h0 : prod (monoid (option (option empty))) (monoid (option (option empty)))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_163328 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_163329 (h0 : ring (has_bot (option unsigned))) : is_principal_ideal_ring (has_bot (option unsigned)) := sorry --non-trivial
lemma new_lemma_163330 (h0 : fin has_zero.zero) : @complete_lattice.is_Sup_finite_compact.{0} (complete_distrib_lattice.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (complete_distrib_lattice.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_163331 (h2 : not (uniform_space (denumerable char) -> false)) : @complete_space.{0} (denumerable.{0} char) (@classical.by_contradiction'.{1} (uniform_space.{0} (denumerable.{0} char)) h2)  := sorry --non-trivial
lemma new_lemma_163332 (h0 : functor.add_const (topological_space (boolean_algebra unsigned)) pos) : @t0_space.{0} (boolean_algebra.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_163333 (h0 : topological_space (has_inv linarith.ineq)) : totally_separated_space (has_inv linarith.ineq) := sorry --non-trivial
lemma new_lemma_163334 (h0 : fin has_zero.zero) : @locally_compact_space.{0} (has_add.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (has_add.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_163335 (h0 : topological_space (has_ssubset string_imp)) : path_connected_space (has_ssubset string_imp) := sorry --non-trivial
lemma new_lemma_163336 (h0 : topological_space (ring (option empty))) : t1_space (ring (option empty)) := sorry --non-trivial
lemma new_lemma_163337 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (add_left_cancel_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (add_left_cancel_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_163338 (h2 : topological_space (mul_one_class (mul_one_class char))) : totally_disconnected_space (mul_one_class (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_163339 (h0 : ring (has_top string_imp)) : rank_condition (has_top string_imp) := sorry --non-trivial
lemma new_lemma_163340 (h0 : add_group (metric_space unsigned)) : is_add_cyclic (metric_space unsigned) := sorry --non-trivial
lemma new_lemma_163341 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (add_group.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (add_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_163342 (h1 : ring (has_nnnorm (denumerable char))) : is_domain (has_nnnorm (denumerable char)) := sorry --non-trivial
lemma new_lemma_163343 (h0 : topological_space (ring (add_comm_monoid environment.implicit_infer_kind))) : irreducible_space (ring (add_comm_monoid environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_163344 (h0 : complete_lattice (semigroup environment.implicit_infer_kind)) : complete_lattice.is_Sup_finite_compact (semigroup environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_163345 (h0 : topological_space (add_cancel_monoid (option empty))) : path_connected_space (add_cancel_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_163346 (h0 : uniform_space (normed_field (has_nnnorm (has_nnnorm linarith.comp_source)))) : complete_space (normed_field (has_nnnorm (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_163347 (h0 : complete_lattice (topological_space linarith.comp_source)) : complete_lattice.is_Sup_finite_compact (topological_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_163348 (h0 : uniform_space (has_nnnorm (mul_one_class fun_info))) : complete_space (has_nnnorm (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_163349 (h0 : group (add_cancel_comm_monoid linarith.ineq)) : is_cyclic (add_cancel_comm_monoid linarith.ineq) := sorry --non-trivial
lemma new_lemma_163350 (h1 : not (uniform_space (encodable linarith.ineq) -> false)) : @complete_space.{0} (encodable.{0} linarith.ineq) (@classical.by_contradiction'.{1} (uniform_space.{0} (encodable.{0} linarith.ineq)) h1)  := sorry --non-trivial
lemma new_lemma_163351 (h2 : set (has_div to_additive.value_type)) : set.finite h2 := sorry --non-trivial
lemma new_lemma_163352 (h0 : ring (has_emptyc (random_gen congr_arg_kind))) : strong_rank_condition (has_emptyc (random_gen congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_163353 (h0 : preorder empty -> preorder empty -> bool) : is_dec_refl h0 := sorry --non-trivial
lemma new_lemma_163354 (h0 : topological_space (complete_distrib_lattice name)) : locally_compact_space (complete_distrib_lattice name) := sorry --non-trivial
lemma new_lemma_163355 (h0 : function.extfun Type (functor.comp ordered_add_comm_monoid has_to_string)) : @archimedean.{0} (has_to_string.{0} pos) (@functor.comp.run.{0 0 0} ordered_add_comm_monoid.{0} has_to_string.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} ordered_add_comm_monoid.{0} has_to_string.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_163356 (h0 : not (filter (has_compl linarith.ineq) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_163357 (h0 : list (has_add unsigned)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_163358 (h0 : uniform_space (has_pos_part (finset (finset linarith.comp)))) : separated_space (has_pos_part (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_163359 (h0 : function.extfun Type (functor.comp group canonically_ordered_comm_semiring)) : @is_simple_group.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.comp.run.{0 0 0} group.{0} canonically_ordered_comm_semiring.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} group.{0} canonically_ordered_comm_semiring.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_163360 (h2 : add_group (with_one (random_gen (has_top linarith.ineq)))) : is_add_cyclic (with_one (random_gen (has_top linarith.ineq))) := sorry --non-trivial
lemma new_lemma_163361 (h0 : semiring (boolean_algebra.core (boolean_algebra.core (finset (finset (finset pos)))))) : is_noetherian_ring (boolean_algebra.core (boolean_algebra.core (finset (finset (finset pos))))) := sorry --non-trivial
lemma new_lemma_163362 (h0 : topological_space (normed_comm_ring (has_to_string (has_to_string ennreal)))) : locally_compact_space (normed_comm_ring (has_to_string (has_to_string ennreal))) := sorry --non-trivial
lemma new_lemma_163363 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (measure_theory.measure_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (measure_theory.measure_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_163364 (h0 : filter (fintype (linear_ordered_add_comm_group char))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_163365 (h0 : topological_space (ordered_comm_monoid (has_neg Type))) : t0_space (ordered_comm_monoid (has_neg Type)) := sorry --non-trivial
lemma new_lemma_163366 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (generalized_boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (generalized_boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_163367 (h0 : functor.add_const (filter (complete_distrib_lattice pos)) linarith.comp) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_163368 (h0 : functor.add_const (ring (ring linarith.comp)) (metric_space linarith.comp)) : @strong_rank_condition.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (ring.{0} linarith.comp)) (metric_space.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_163369 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @preconnected_space.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_163370 (h0 : cancel_comm_monoid_with_zero (ordered_comm_monoid (has_add (has_add pos)))) : unique_factorization_monoid (ordered_comm_monoid (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_163371 (h0 : functor.add_const (ring (has_neg pos)) pos) : @is_domain.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_neg.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_163372 (h0 : monoid (normed_group (has_top empty))) : monoid.fg (normed_group (has_top empty)) := sorry --non-trivial
lemma new_lemma_163373 (h0 : functor.add_const (topological_space (generalized_boolean_algebra linarith.comp)) Type) : @path_connected_space.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (generalized_boolean_algebra.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_163374 (h0 : topological_space (canonically_ordered_monoid (has_Inf real))) : totally_separated_space (canonically_ordered_monoid (has_Inf real)) := sorry --non-trivial
lemma new_lemma_163375 (h0 : functor.add_const (topological_space (monoid empty)) empty) : @irreducible_space.{0} (monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_163376 (h0 : functor.add_const (topological_space (finset linarith.comp)) name) : @regular_space.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_163377 (h0 : functor.add_const (complete_lattice (has_neg_part unsigned)) linarith.comp) : @is_compactly_generated.{0} (has_neg_part.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_neg_part.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_163378 (h0 : functor.add_const (ring (left_cancel_semigroup congr_arg_kind)) unsigned) : @is_domain.{0} (left_cancel_semigroup.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ring.{0} (left_cancel_semigroup.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_163379 (h0 : function.extfun Type (functor.comp group has_nndist)) : @group.fg.{0} (has_nndist.{0} ennreal) (@functor.comp.run.{0 0 0} group.{0} has_nndist.{0} ennreal (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} group.{0} has_nndist.{0}) h0 ennreal))  := sorry --non-trivial
lemma new_lemma_163380 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (semigroup.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_163381 (h0 : functor.add_const (topological_space (has_neg_part unsigned)) name) : @t0_space.{0} (has_neg_part.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_163382 (h0 : functor.add_const (topological_space (complete_distrib_lattice pos)) linarith.comp) : @regular_space.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_163383 (h0 : ordered_add_comm_monoid (normed_lattice_add_comm_group Type)) : archimedean (normed_lattice_add_comm_group Type) := sorry --non-trivial
lemma new_lemma_163384 (h0 : ring (cancel_monoid ennreal)) : is_principal_ideal_ring (cancel_monoid ennreal) := sorry --non-trivial
lemma new_lemma_163385 (h0 : functor.add_const (semiring (has_Sup num)) empty) : @is_noetherian_ring.{0} (has_Sup.{0} num) (@functor.add_const.run.{0 0} (semiring.{0} (has_Sup.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_163386 (h0 : topological_space (has_bot (sub_neg_monoid (has_pos_part real)))) : preirreducible_space (has_bot (sub_neg_monoid (has_pos_part real))) := sorry --non-trivial
lemma new_lemma_163387 (h0 : not (filter (with_one empty) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_163388 (h0 : has_mem.mem (linear_ordered_semiring num) has_emptyc.emptyc) : @locally_compact_space.{0} (linear_ordered_semiring.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (linear_ordered_semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_163389 (h0 : not (topological_space (measurable_space.dynkin_system num) -> false)) : @t1_space.{0} (measurable_space.dynkin_system.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (measurable_space.dynkin_system.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_163390 (h0 : functor.add_const (topological_space (has_pos_part pos)) Type) : @loc_path_connected_space.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_pos_part.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_163391 (h0 : functor.add_const (topological_space (has_zero unsigned)) unsigned) : @loc_path_connected_space.{0} (has_zero.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_163392 (h0 : fin has_zero.zero) : @has_exists_mul_of_le.{0} (ordered_comm_monoid.{0} name) (@matrix.vec_empty.{0} (ordered_comm_monoid.{0} (ordered_comm_monoid.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_163393 (h0 : ring (has_Inf (has_add linarith.comp))) : rank_condition (has_Inf (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_163394 (h0 : ring (option (has_to_string num))) : rank_condition (option (has_to_string num)) := sorry --non-trivial
lemma new_lemma_163395 (h0 : topological_space (complete_semilattice_Sup linarith.ineq)) : irreducible_space (complete_semilattice_Sup linarith.ineq) := sorry --non-trivial
lemma new_lemma_163396 (h0 : functor.add_const (topological_space (has_star empty)) empty) : @loc_path_connected_space.{0} (has_star.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_163397 (h0 : topological_space (has_one (linear_ordered_semiring unsigned))) : totally_separated_space (has_one (linear_ordered_semiring unsigned)) := sorry --non-trivial
lemma new_lemma_163398 (h0 : topological_space (pseudo_metric_space (finset pos))) : preirreducible_space (pseudo_metric_space (finset pos)) := sorry --non-trivial
lemma new_lemma_163399 (h0 : topological_space (has_nndist (semigroup Type))) : locally_compact_space (has_nndist (semigroup Type)) := sorry --non-trivial
lemma new_lemma_163400 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @discrete_topology.{1} (cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_163401 (h0 : has_lt (has_ssubset linarith.ineq)) : no_max_order (has_ssubset linarith.ineq) := sorry --non-trivial
lemma new_lemma_163402 (h0 : topological_space (has_add (finset pos))) : t0_space (has_add (finset pos)) := sorry --non-trivial
lemma new_lemma_163403 (h0 : ordered_add_comm_monoid (linear_ordered_field (option (option ennreal)))) : archimedean (linear_ordered_field (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_163404 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (group_with_zero.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (group_with_zero.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_163405 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_163406 (h2 : add_group (denumerable linarith.comp_source)) : is_add_cyclic (denumerable linarith.comp_source) := sorry --non-trivial
lemma new_lemma_163407 (h0 : ring (normed_group (has_emptyc fun_info))) : is_domain (normed_group (has_emptyc fun_info)) := sorry --non-trivial
lemma new_lemma_163408 (h0 : functor.add_const (topological_space (add_cancel_monoid unsigned)) name) : @discrete_topology.{0} (add_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_163409 (h0 : not (ring (linear_ordered_semiring linarith.comp_source) -> false)) : @strong_rank_condition.{0} (linear_ordered_semiring.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (linear_ordered_semiring.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_163410 (h0 : add_monoid (generalized_boolean_algebra (has_Inf pos))) : add_monoid.fg (generalized_boolean_algebra (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_163411 (h0 : group (normed_group (random_gen fun_info))) : is_cyclic (normed_group (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_163412 (h0 : list (has_inv (has_norm (comm_ring (random_gen (has_norm fun_info)))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_163413 (h0 : topological_space (ring (has_add Type))) : totally_separated_space (ring (has_add Type)) := sorry --non-trivial
lemma new_lemma_163414 (h0 : add_group (comm_group (semigroup (semigroup (has_neg_part unsigned))))) : is_add_cyclic (comm_group (semigroup (semigroup (has_neg_part unsigned)))) := sorry --non-trivial
lemma new_lemma_163415 (h0 : topological_space (measurable_space unsigned)) : irreducible_space (measurable_space unsigned) := sorry --non-trivial
lemma new_lemma_163416 (h0 : pseudo_metric_space unsigned) (h1 : monoid unsigned) : has_lipschitz_mul unsigned := sorry --non-trivial
lemma new_lemma_163417 (h0 : functor.add_const (function.extfun Type topological_space) (has_Inf pos)) : @locally_compact_space.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (has_Inf.{0} pos) h0) (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_163418 (h0 : complete_lattice (has_one (has_top empty))) : is_atomistic (has_one (has_top empty)) := sorry --non-trivial
lemma new_lemma_163419 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (sub_neg_monoid.{0} real) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (sub_neg_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_163420 (h0 : monoid (has_norm (has_inv linarith.comp_source))) : monoid.fg (has_norm (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_163421 (h0 : functor.add_const (topological_space (simple_graph linarith.comp)) linarith.comp) : @regular_space.{0} (simple_graph.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (simple_graph.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_163422 (h0 : topological_space (complete_semilattice_Sup unsigned)) : t0_space (complete_semilattice_Sup unsigned) := sorry --non-trivial
lemma new_lemma_163423 (h0 : topological_space (group_with_zero (option (option empty)))) : loc_path_connected_space (group_with_zero (option (option empty))) := sorry --non-trivial
lemma new_lemma_163424 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (add_left_cancel_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_left_cancel_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_163425 (h0 : cancel_comm_monoid_with_zero (has_zero (has_neg (normed_comm_ring (boolean_algebra pos))))) : unique_factorization_monoid (has_zero (has_neg (normed_comm_ring (boolean_algebra pos)))) := sorry --non-trivial
lemma new_lemma_163426 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (ordered_comm_monoid name)) := sorry --non-trivial
lemma new_lemma_163427 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (random_gen.{0} num) (@function.extfun_app.{2 1} Type monoid.{0} h0 (random_gen.{0} num))  := sorry --non-trivial
lemma new_lemma_163428 (h1 : add_group (uniform_space (uniform_space linarith.comp_source))) : is_add_cyclic (uniform_space (uniform_space linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_163429 (h0 : functor.comp topological_space has_neg Type) : @preirreducible_space.{1} (has_neg.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} has_neg.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_163430 (h0 : has_mem.mem (linear_ordered_semiring (has_top fun_info)) has_emptyc.emptyc) : @totally_disconnected_space.{0} (linear_ordered_semiring.{0} (has_top.{0} fun_info)) (@finset.pi.empty.{1 0} Type topological_space.{0} (linear_ordered_semiring.{0} (has_top.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_163431 (h0 : pfun enat Prop) (h1 : coe_sort (pfun.dom h0) -> coe_sort (pfun.dom h0) -> Prop) (h2 : quot h1) : pfun.as_subtype h0 (quot.out h2) := sorry --non-trivial
lemma new_lemma_163432 (h0 : uniform_space (left_cancel_monoid empty)) : separated_space (left_cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_163433 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (has_bot.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_bot.{0} pos))  := sorry --non-trivial
lemma new_lemma_163434 (h0 : topological_space (plift unsigned)) : locally_compact_space (plift unsigned) := sorry --non-trivial
lemma new_lemma_163435 (h0 : functor.add_const (semiring (add_cancel_monoid Type)) Type) : @is_noetherian_ring.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 1} (semiring.{1} (add_cancel_monoid.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_163436 (h0 : group (comm_group pos)) : is_simple_group (comm_group pos) := sorry --non-trivial
lemma new_lemma_163437 (h0 : topological_space (simple_graph (has_Inf (has_add (has_add pos))))) : preconnected_space (simple_graph (has_Inf (has_add (has_add pos)))) := sorry --non-trivial
lemma new_lemma_163438 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (add_cancel_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_163439 (h0 : group (id (has_top congr_arg_kind))) : normalizer_condition (id (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_163440 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (linear_ordered_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_163441 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (generalized_boolean_algebra.{0} (finset.{0} pos)) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (generalized_boolean_algebra.{0} (finset.{0} pos)))  := sorry --non-trivial
lemma new_lemma_163442 (h0 : uniform_space (linear_ordered_semiring num)) : complete_space (linear_ordered_semiring num) := sorry --non-trivial
lemma new_lemma_163443 (h0 : set (has_nnnorm (has_nnnorm (semi_normed_comm_ring string.iterator_imp)))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_163444 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_163445 (h0 : topological_space (ordered_cancel_add_comm_monoid (option (option empty)))) : t1_space (ordered_cancel_add_comm_monoid (option (option empty))) := sorry --non-trivial
lemma new_lemma_163446 (h0 : topological_space (has_inv (comm_ring (comm_ring to_additive.value_type)))) : t0_space (has_inv (comm_ring (comm_ring to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_163447 (h0 : topological_space (has_top (semiring (semiring linarith.comp_source)))) : irreducible_space (has_top (semiring (semiring linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_163448 (h0 : functor.add_const (ordered_add_comm_monoid (cancel_monoid name)) (option (option pos))) : @archimedean.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (cancel_monoid.{0} name)) (option.{0} (option.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_163449 (h0 : function.extfun (finset Type) (has_mem.mem unsigned)) : @complete_space.{0} unsigned (@finset.pi.empty.{1 0} Type uniform_space.{0} unsigned (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) unsigned) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_163450 (h0 : complete_lattice (with_one (with_bot (with_bot string_imp)))) : complete_lattice.is_Sup_finite_compact (with_one (with_bot (with_bot string_imp))) := sorry --non-trivial
lemma new_lemma_163451 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (cancel_monoid num)) := sorry --non-trivial
lemma new_lemma_163452 (h0 : function.extfun (finset ((Type -> Type) -> Type 1)) (has_mem.mem (function.extfun Type))) : @is_add_cyclic.{0} fun_info (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@finset.pi.empty.{2 1} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) (function.extfun.{2 1} Type) (@function.extfun_app.{3 0} (finset.{2} ((Type → Type) → Type 1)) (@has_mem.mem.{2 2} ((Type → Type) → Type 1) (finset.{2} ((Type → Type) → Type 1)) (@finset.has_mem.{2} ((Type → Type) → Type 1)) (function.extfun.{2 1} Type)) h0 (@has_emptyc.emptyc.{2} (finset.{2} ((Type → Type) → Type 1)) (@finset.has_emptyc.{2} ((Type → Type) → Type 1))))) add_group.{0}) fun_info)  := sorry --non-trivial
lemma new_lemma_163453 (h0 : uniform_space (bin_tree num)) : complete_space (bin_tree num) := sorry --non-trivial
lemma new_lemma_163454 (h4 : ring (has_ssubset char)) : rank_condition (has_ssubset char) := sorry --non-trivial
lemma new_lemma_163455 (h0 : list (semigroup (finset (ring Type)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_163456 (h0 : normed_comm_ring (ring (option unsigned)) -> normed_comm_ring (ring (option unsigned)) -> Prop) : is_symm (normed_comm_ring (ring (option unsigned))) h0 := sorry --non-trivial
lemma new_lemma_163457 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (measurable_space.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measurable_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_163458 (h0 : topological_space (ring (normed_comm_ring pos))) : totally_disconnected_space (ring (normed_comm_ring pos)) := sorry --non-trivial
lemma new_lemma_163459 (h0 : functor.add_const (topological_space (has_neg Type)) environment.implicit_infer_kind) : @discrete_topology.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_neg.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_163460 (h0 : fin has_zero.zero) : @is_add_cyclic.{0} (generalized_boolean_algebra.{0} real) (@matrix.vec_empty.{0} (add_group.{0} (generalized_boolean_algebra.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_163461 (h0 : topological_space (has_neg (boolean_algebra name))) : sequential_space (has_neg (boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_163462 (h0 : boolean_algebra (finset (add_comm_monoid name)) -> Prop) : zzz_forall h0 := sorry --non-trivial
lemma new_lemma_163463 (h0 : functor.comp topological_space has_neg name) : @preirreducible_space.{0} (has_neg.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} name h0)  := sorry --non-trivial
lemma new_lemma_163464 (h0 : group (semigroup (has_pos_part pos))) : group.fg (semigroup (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_163465 (h0 : list Prop) : list.tfae h0 := sorry --non-trivial
lemma new_lemma_163466 (h0 : ring (denumerable (has_inv (random_gen (random_gen (random_gen (has_ssubset fun_info))))))) : rank_condition (denumerable (has_inv (random_gen (random_gen (random_gen (has_ssubset fun_info)))))) := sorry --non-trivial
lemma new_lemma_163467 (h0 : topological_space (add_group (semiring unsigned))) : preirreducible_space (add_group (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_163468 (h0 : functor.add_const (topological_space (has_zero name)) name) : @irreducible_space.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_163469 (h0 : topological_space (linear_ordered_semiring (has_top (has_top fun_info)))) : t0_space (linear_ordered_semiring (has_top (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_163470 (h0 : topological_space (has_inf unsigned)) : irreducible_space (has_inf unsigned) := sorry --non-trivial
lemma new_lemma_163471 (h0 : functor.comp topological_space add_comm_monoid name) : @topological_space.separable_space.{0} (add_comm_monoid.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} add_comm_monoid.{0} name h0)  := sorry --non-trivial
lemma new_lemma_163472 (h0 : function.extfun Type monoid) (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @is_of_fin_order.{0} (has_norm.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type monoid.{0} h0 (has_norm.{0} to_additive.value_type)) (@function.extfun_app.{2 1} Type has_norm.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 has_norm.{0}) to_additive.value_type)  := sorry --non-trivial
lemma new_lemma_163473 (h0 : ordered_add_comm_monoid (canonically_ordered_monoid (has_neg (has_bot real)))) : archimedean (canonically_ordered_monoid (has_neg (has_bot real))) := sorry --non-trivial
lemma new_lemma_163474 (h0 : topological_space (finset (option pos))) : discrete_topology (finset (option pos)) := sorry --non-trivial
lemma new_lemma_163475 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (sub_neg_monoid.{0} pos) (@function.extfun_app.{2 1} Type add_group.{0} h0 (sub_neg_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_163476 (h0 : not (complete_lattice (has_append to_additive.value_type) -> false)) : @is_compactly_generated.{0} (has_append.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_append.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_163477 (h0 : topological_space (omega_complete_partial_order congr_arg_kind)) : preirreducible_space (omega_complete_partial_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_163478 (h0 : list (non_assoc_semiring unsigned)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_163479 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (group_with_zero unsigned)) := sorry --non-trivial
lemma new_lemma_163480 (h0 : topological_space (complete_distrib_lattice empty)) : discrete_topology (complete_distrib_lattice empty) := sorry --non-trivial
lemma new_lemma_163481 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (with_bot linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_163482 (h0 : function.extfun (finset (Type -> Type) -> Prop) (function.extfun (finset (Type -> Type)))) : @t0_space.{0} string_imp (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) (@function.extfun_app.{2 0} (finset.{1} (Type → Type) → Prop) (function.extfun.{2 0} (finset.{1} (Type → Type))) h0 (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0})) (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) string_imp)  := sorry --non-trivial
lemma new_lemma_163483 (h0 : list (has_nndist (has_add pos))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_163484 (h0 : functor.add_const (functor.comp monoid mul_zero_class environment.implicit_infer_kind) unsigned) : @monoid.fg.{0} (mul_zero_class.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} monoid.{0} mul_zero_class.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 0} (functor.comp.{0 0 0} monoid.{0} mul_zero_class.{0} environment.implicit_infer_kind) unsigned h0))  := sorry --non-trivial
lemma new_lemma_163485 (h0 : ring (finset (has_add unsigned))) : rank_condition (finset (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_163486 (h0 : topological_space (has_neg_part (has_to_string (cancel_monoid pos)))) : sequential_space (has_neg_part (has_to_string (cancel_monoid pos))) := sorry --non-trivial
lemma new_lemma_163487 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @is_atomistic.{0} (ordered_comm_ring.{0} real) (@matrix.vec_empty.{0} (complete_lattice.{0} (ordered_comm_ring.{0} real)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_163488 (h0 : ordered_add_comm_monoid (has_nndist (ring linarith.comp))) : archimedean (has_nndist (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_163489 (h0 : functor.add_const (topological_space (semigroup pos)) (option unsigned)) : @preconnected_space.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} pos)) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_163490 (h0 : has_mem.mem unsigned has_emptyc.emptyc) : @discrete_topology.{0} unsigned (@finset.pi.empty.{1 0} Type topological_space.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_163491 (h0 : set (string.iterator_imp -> simple_graph linarith.ineq)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_163492 (h0 : functor.add_const (ring (add_comm_monoid unsigned)) Type) : @is_principal_ideal_ring.{0} (add_comm_monoid.{0} unsigned) (@functor.add_const.run.{0 1} (ring.{0} (add_comm_monoid.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_163493 (h0 : topological_space fun_info) (h1 : set fun_info) : is_preconnected h1 := sorry --non-trivial
lemma new_lemma_163494 (h0 : functor.comp (functor.comp finset canonically_ordered_comm_semiring) has_nndist ennreal) : finset.nonempty (functor.comp.run (functor.comp.run h0)) := sorry --non-trivial
lemma new_lemma_163495 (h1 : add_group (complete_semilattice_Sup to_additive.value_type)) : is_add_cyclic (complete_semilattice_Sup to_additive.value_type) := sorry --non-trivial
lemma new_lemma_163496 (h1 : ring (normed_field linarith.ineq)) : is_domain (normed_field linarith.ineq) := sorry --non-trivial
lemma new_lemma_163497 (h0 : not (function.extfun Type topological_space -> false)) : @totally_disconnected_space.{0} (has_one.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_one.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_163498 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_163499 (h0 : complete_lattice (comm_group (has_add Type))) : is_compactly_generated (comm_group (has_add Type)) := sorry --non-trivial
lemma new_lemma_163500 (h0 : function.extfun Type group) : @group.fg.{0} (has_star.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (has_star.{0} empty))  := sorry --non-trivial
lemma new_lemma_163501 (h0 : topological_space (boolean_algebra (finset environment.implicit_infer_kind))) : t1_space (boolean_algebra (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_163502 (h0 : topological_space (simple_graph (finset pos))) : irreducible_space (simple_graph (finset pos)) := sorry --non-trivial
lemma new_lemma_163503 (h0 : set (distrib char)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_163504 (h0 : topological_space (has_nnnorm (mul_one_class (mul_one_class bool)))) : t0_space (has_nnnorm (mul_one_class (mul_one_class bool))) := sorry --non-trivial
lemma new_lemma_163505 (h0 : filter (linear_ordered_add_comm_group (comm_ring linarith.ineq))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_163506 (h0 : add_group (with_bot (semiring empty))) : is_add_cyclic (with_bot (semiring empty)) := sorry --non-trivial
lemma new_lemma_163507 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 complete_lattice.{0}) (complete_semilattice_Sup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_163508 (h0 : add_monoid (linear_ordered_comm_group pos)) : add_monoid.fg (linear_ordered_comm_group pos) := sorry --non-trivial
lemma new_lemma_163509 (h0 : functor.add_const (topological_space (add_cancel_monoid unsigned)) linarith.comp) : @topological_space.separable_space.{0} (add_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_163510 (h0 : group (random_gen (random_gen (random_gen (random_gen char))))) : group.fg (random_gen (random_gen (random_gen (random_gen char)))) := sorry --non-trivial
lemma new_lemma_163511 (h1 : ring (linear_ordered_add_comm_group (random_gen char))) : is_domain (linear_ordered_add_comm_group (random_gen char)) := sorry --non-trivial
lemma new_lemma_163512 (h0 : int) (h1 : thunk int) : int.lt h0 (@trace_call_stack.{0} int h1)  := sorry --non-trivial
lemma new_lemma_163513 (h0 : finset (has_pos_part (has_add name))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_163514 (h0 : complete_lattice (has_lt string_imp)) : is_compactly_generated (has_lt string_imp) := sorry --non-trivial
lemma new_lemma_163515 (h1 : not (topological_space (denumerable to_additive.value_type) -> false)) : @totally_disconnected_space.{0} (denumerable.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (denumerable.{0} to_additive.value_type)) h1)  := sorry --non-trivial
lemma new_lemma_163516 (h0 : topological_space (semigroup (option ennreal))) : totally_separated_space (semigroup (option ennreal)) := sorry --non-trivial
lemma new_lemma_163517 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (linear_ordered_semiring.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (linear_ordered_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_163518 (h0 : uniform_space (distrib (has_nnnorm reducibility_hints))) : complete_space (distrib (has_nnnorm reducibility_hints)) := sorry --non-trivial
lemma new_lemma_163519 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_163520 (h0 : functor.add_const (ring (complete_distrib_lattice Type)) pos) : @rank_condition.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (complete_distrib_lattice.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_163521 (h0 : functor.comp topological_space has_to_string unsigned) : @totally_separated_space.{0} (has_to_string.{0} unsigned) (@functor.comp.run.{0 0 0} topological_space.{0} has_to_string.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_163522 (h0 : function.extfun Type group) : @is_simple_group.{0} (semigroup.{0} name) (@function.extfun_app.{2 1} Type group.{0} h0 (semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_163523 (h0 : set (non_unital_non_assoc_semiring fun_info)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_163524 (h0 : ring (normed_comm_ring (has_pos_part pos))) : strong_rank_condition (normed_comm_ring (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_163525 (h1 : topological_space (normed_field (has_nnnorm (has_ssubset (has_nnnorm (has_nnnorm char)))))) : totally_disconnected_space (normed_field (has_nnnorm (has_ssubset (has_nnnorm (has_nnnorm char))))) := sorry --non-trivial
lemma new_lemma_163526 (h0 : topological_space (has_Inf (has_add name))) : path_connected_space (has_Inf (has_add name)) := sorry --non-trivial
lemma new_lemma_163527 (h0 : group (omega_complete_partial_order congr_arg_kind)) : normalizer_condition (omega_complete_partial_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_163528 (h0 : has_mem.mem (with_one empty) has_emptyc.emptyc) : @complete_space.{0} (with_one.{0} empty) (@finset.pi.empty.{1 0} Type uniform_space.{0} (with_one.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_163529 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (monoid unsigned)) := sorry --non-trivial
lemma new_lemma_163530 (h0 : group (metric_space (semiring (has_top num)))) : group.fg (metric_space (semiring (has_top num))) := sorry --non-trivial
lemma new_lemma_163531 (h0 : function.extfun (Type 1) filter) : filter.ne_bot (function.extfun_app h0 (comm_group Type)) := sorry --non-trivial
lemma new_lemma_163532 (h0 : functor.add_const (uniform_space (add_cancel_monoid linarith.comp)) (finset linarith.comp)) : @separated_space.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (add_cancel_monoid.{0} linarith.comp)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_163533 (h1 h2 : multiset (simple_graph reducibility_hints)) : multiset.disjoint h1 h2 := sorry --non-trivial
lemma new_lemma_163534 (h0 : functor.add_const (ring (ring name)) linarith.comp) : @rank_condition.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (ring.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_163535 (h0 : functor.add_const (topological_space (simple_graph Type)) linarith.comp) : @locally_compact_space.{1} (simple_graph.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (simple_graph.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_163536 (h0 : has_lt (nondiscrete_normed_field (add_comm_semigroup ereal))) : no_max_order (nondiscrete_normed_field (add_comm_semigroup ereal)) := sorry --non-trivial
lemma new_lemma_163537 (h0 : add_monoid (add_right_cancel_monoid num)) : add_monoid.fg (add_right_cancel_monoid num) := sorry --non-trivial
lemma new_lemma_163538 (h0 : topological_space (has_lt linarith.ineq) -> Prop) (h1 : Exists (fun (x : topological_space (has_lt linarith.ineq)), h0 x)) : @path_connected_space.{0} (has_lt.{0} linarith.ineq) (@classical.some.{1} (topological_space.{0} (has_lt.{0} linarith.ineq)) h0 h1)  := sorry --non-trivial
lemma new_lemma_163539 (h0 : topological_space (boolean_algebra (has_pos_part pos))) : regular_space (boolean_algebra (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_163540 (h0 : function.extfun Type topological_space) : @t1_space.{0} (pseudo_metric_space.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (pseudo_metric_space.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_163541 (h0 : group (has_one (has_norm empty))) : is_cyclic (has_one (has_norm empty)) := sorry --non-trivial
lemma new_lemma_163542 (h0 : uniform_space (boolean_algebra.core (option empty))) : separated_space (boolean_algebra.core (option empty)) := sorry --non-trivial
lemma new_lemma_163543 (h0 : topological_space (has_inter (option empty))) : totally_separated_space (has_inter (option empty)) := sorry --non-trivial
lemma new_lemma_163544 (h0 : topological_space (partial_order num)) : loc_path_connected_space (partial_order num) := sorry --non-trivial
lemma new_lemma_163545 (h0 : topological_space (random_gen (has_nnnorm (random_gen (has_ssubset (random_gen (random_gen char))))))) : t0_space (random_gen (has_nnnorm (random_gen (has_ssubset (random_gen (random_gen char)))))) := sorry --non-trivial
lemma new_lemma_163546 (h0 : functor.add_const (group (has_add Type)) Type) : @is_cyclic.{1} (has_add.{1} Type) (@functor.add_const.run.{1 1} (group.{1} (has_add.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_163547 (h1 : set (linarith.ineq -> std_gen)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_163548 (h0 : ring (has_add (has_add (has_neg (has_neg name))))) : rank_condition (has_add (has_add (has_neg (has_neg name)))) := sorry --non-trivial
lemma new_lemma_163549 (h0 : ring (ring (boolean_algebra (boolean_algebra name)))) : is_principal_ideal_ring (ring (boolean_algebra (boolean_algebra name))) := sorry --non-trivial
lemma new_lemma_163550 (h1 : add_group (div_inv_monoid linarith.comp_source)) : is_add_cyclic (div_inv_monoid linarith.comp_source) := sorry --non-trivial
lemma new_lemma_163551 (h0 : topological_space (comm_monoid (option empty))) : discrete_topology (comm_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_163552 (h0 : functor.add_const (topological_space (has_add linarith.comp)) linarith.comp) : @irreducible_space.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_163553 (h0 : uniform_space (has_star congr_arg_kind)) : separated_space (has_star congr_arg_kind) := sorry --non-trivial
lemma new_lemma_163554 (h0 : function.extfun (Type 1) (functor.add_const (add_group environment.implicit_infer_kind))) : @is_add_cyclic.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 1} (add_group.{0} environment.implicit_infer_kind) Type (@function.extfun_app.{3 1} (Type 1) (functor.add_const.{0 1} (add_group.{0} environment.implicit_infer_kind)) h0 Type))  := sorry --non-trivial
lemma new_lemma_163555 (h0 : filter (add_cancel_monoid (option (option (option (option (option name))))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_163556 (h0 : complete_lattice (add_cancel_monoid (ring Type))) : is_atomistic (add_cancel_monoid (ring Type)) := sorry --non-trivial
lemma new_lemma_163557 (h1 : not (topological_space (semiring num) -> false)) : @locally_compact_space.{0} (semiring.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (semiring.{0} num)) h1)  := sorry --non-trivial
lemma new_lemma_163558 (h0 : topological_space (random_gen (has_top unsigned))) : preirreducible_space (random_gen (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_163559 (h0 : measurable_space (random_gen string_imp)) (h1 h2 : measure_theory.measure (random_gen string_imp)) : measure_theory.measure.absolutely_continuous h1 h2 := sorry --non-trivial
lemma new_lemma_163560 (h0 : set (ereal -> mul_one_class ereal)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_163561 (h0 : topological_space (boolean_algebra.core Type)) : regular_space (boolean_algebra.core Type) := sorry --non-trivial
lemma new_lemma_163562 (h0 : function.extfun Type (functor.add_const (topological_space (has_add linarith.comp)))) : @sequential_space.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} linarith.comp)) pos (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (has_add.{0} linarith.comp))) h0 pos))  := sorry --non-trivial
lemma new_lemma_163563 (h0 : functor.add_const (topological_space (free_add_monoid congr_arg_kind)) num) : @t1_space.{0} (free_add_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_163564 (h0 : topological_space (canonically_ordered_monoid (has_pos_part Type))) : locally_compact_space (canonically_ordered_monoid (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_163565 (h0 : functor.add_const (semiring (cancel_monoid unsigned)) unsigned) : @is_noetherian_ring.{0} (cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (semiring.{0} (cancel_monoid.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_163566 (h0 : topological_space (canonically_linear_ordered_monoid (has_neg_part ennreal))) : totally_separated_space (canonically_linear_ordered_monoid (has_neg_part ennreal)) := sorry --non-trivial
lemma new_lemma_163567 (h0 : topological_space (ordered_comm_ring (has_add (has_neg name)))) : preconnected_space (ordered_comm_ring (has_add (has_neg name))) := sorry --non-trivial
lemma new_lemma_163568 (h0 : functor.add_const (topological_space (has_zero unsigned)) name) : @totally_separated_space.{0} (has_zero.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_163569 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (has_neg_part.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_neg_part.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_163570 (h0 : complete_lattice (add_cancel_monoid (has_zero Type))) : is_compactly_generated (add_cancel_monoid (has_zero Type)) := sorry --non-trivial
lemma new_lemma_163571 (h0 : topological_space (linear_ordered_add_comm_group (has_top fun_info))) : t0_space (linear_ordered_add_comm_group (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_163572 (h0 : cancel_comm_monoid_with_zero (preorder congr_arg_kind)) : unique_factorization_monoid (preorder congr_arg_kind) := sorry --non-trivial
lemma new_lemma_163573 (h0 : group (has_star (semiring (semiring (semiring empty))))) : normalizer_condition (has_star (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_163574 (h0 : group (has_star congr_arg_kind)) : group.fg (has_star congr_arg_kind) := sorry --non-trivial
lemma new_lemma_163575 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (semigroup.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (semigroup.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_163576 (h0 : complete_lattice (with_one (has_top (has_inv linarith.ineq)))) : is_compactly_generated (with_one (has_top (has_inv linarith.ineq))) := sorry --non-trivial
lemma new_lemma_163577 (h0 : topological_space (semigroup ennreal)) : regular_space (semigroup ennreal) := sorry --non-trivial
lemma new_lemma_163578 (h0 : topological_space (has_add (canonically_ordered_monoid (has_add pos)))) : totally_separated_space (has_add (canonically_ordered_monoid (has_add pos))) := sorry --non-trivial
lemma new_lemma_163579 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} unsigned (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) unsigned)  := sorry --non-trivial
lemma new_lemma_163580 (h0 : not (function.extfun Type ring -> false)) : @is_principal_ideal_ring.{0} (add_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (add_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_163581 (h0 : topological_space (generalized_boolean_algebra (has_Inf linarith.comp))) : regular_space (generalized_boolean_algebra (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_163582 (h0 : topological_space (linear_ordered_comm_monoid_with_zero empty)) : path_connected_space (linear_ordered_comm_monoid_with_zero empty) := sorry --non-trivial
lemma new_lemma_163583 (h0 : cancel_comm_monoid_with_zero (add_cancel_monoid (option (option pos)))) : unique_factorization_monoid (add_cancel_monoid (option (option pos))) := sorry --non-trivial
lemma new_lemma_163584 (h0 : finset (non_assoc_semiring (semiring (semiring (semiring empty))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_163585 (h1 : Prop) : set.finite (id (fun (h0 : linarith.ineq), h1)) := sorry --non-trivial
lemma new_lemma_163586 (h0 : group (comm_group (finset linarith.comp))) : group.fg (comm_group (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_163587 (h1 : filter (distrib_lattice fun_info)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_163588 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (has_to_string.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} num))  := sorry --non-trivial
lemma new_lemma_163589 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_atomistic.{0} (has_norm.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (has_norm.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_163590 (h0 : functor.add_const (ring (generalized_boolean_algebra pos)) name) : @strong_rank_condition.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (generalized_boolean_algebra.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_163591 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (add_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (add_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_163592 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (generalized_boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (generalized_boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_163593 (h0 : topological_space (has_ssubset linarith.comp_source)) (h1 : preorder (has_ssubset linarith.comp_source)) : order_closed_topology (has_ssubset linarith.comp_source) := sorry --non-trivial
lemma new_lemma_163594 (h0 : list (has_top (has_inv linarith.ineq))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_163595 (h0 : complete_lattice (has_ssubset (mul_one_class (mul_one_class char)))) : complete_lattice.is_Sup_finite_compact (has_ssubset (mul_one_class (mul_one_class char))) := sorry --non-trivial
lemma new_lemma_163596 (h0 : topological_space (div_inv_monoid (random_gen char))) : totally_disconnected_space (div_inv_monoid (random_gen char)) := sorry --non-trivial
lemma new_lemma_163597 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @rank_condition.{1} (plift.{1} empty) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ring.{1}) (plift.{1} empty))  := sorry --non-trivial
lemma new_lemma_163598 (h0 : topological_space (has_one (has_norm (has_norm (has_norm unsigned))))) : normal_space (has_one (has_norm (has_norm (has_norm unsigned)))) := sorry --non-trivial
lemma new_lemma_163599 (h0 : topological_space (add_cancel_monoid (ring pos))) : sequential_space (add_cancel_monoid (ring pos)) := sorry --non-trivial
lemma new_lemma_163600 (h0 : functor.add_const (function.extfun Type finset) environment.implicit_infer_kind) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (add_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_163601 (h0 : topological_space (dlist (random_gen (has_inv fun_info)))) : path_connected_space (dlist (random_gen (has_inv fun_info))) := sorry --non-trivial
lemma new_lemma_163602 (h0 : group (add_left_cancel_monoid linarith.ineq)) : is_cyclic (add_left_cancel_monoid linarith.ineq) := sorry --non-trivial
lemma new_lemma_163603 (h0 : ring (ordered_comm_ring (has_neg linarith.comp))) : strong_rank_condition (ordered_comm_ring (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_163604 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @totally_separated_space.{0} (measurable_space.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (measurable_space.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_163605 (h3 : not (ring (semi_normed_comm_ring char) -> false)) : @rank_condition.{0} (semi_normed_comm_ring.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (semi_normed_comm_ring.{0} char)) h3)  := sorry --non-trivial
lemma new_lemma_163606 (h0 : topological_space (semigroup empty)) : preirreducible_space (semigroup empty) := sorry --non-trivial
lemma new_lemma_163607 (h0 : group (complete_distrib_lattice (option ennreal))) : is_simple_group (complete_distrib_lattice (option ennreal)) := sorry --non-trivial
lemma new_lemma_163608 (h0 : functor.add_const (list (semigroup linarith.comp)) pos) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_163609 (h0 : function.extfun Type (functor.comp ring semigroup)) : @is_principal_ideal_ring.{0} (semigroup.{0} ennreal) (@functor.comp.run.{0 0 0} ring.{0} semigroup.{0} ennreal (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} ring.{0} semigroup.{0}) h0 ennreal))  := sorry --non-trivial
lemma new_lemma_163610 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (normed_lattice_add_comm_group.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (normed_lattice_add_comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_163611 (h0 : add_group (left_cancel_semigroup (semiring (semiring empty)))) : is_add_cyclic (left_cancel_semigroup (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_163612 (h0 : topological_space (has_neg name)) : normal_space (has_neg name) := sorry --non-trivial
lemma new_lemma_163613 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (add_right_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (add_right_cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_163614 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_163615 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (option.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (option.{0} pos))  := sorry --non-trivial
lemma new_lemma_163616 (h0 : ring (normed_field (has_lt linarith.comp_source))) : rank_condition (normed_field (has_lt linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_163617 (h0 : complete_lattice (monoid unsigned)) : complete_lattice.is_Sup_finite_compact (monoid unsigned) := sorry --non-trivial
lemma new_lemma_163618 (h0 : filter (mul_zero_class (complete_distrib_lattice (finset (finset Type))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_163619 (h0 : function.extfun nat fin) : @t1_space.{1} (generalized_boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (generalized_boolean_algebra.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_163620 (h0 : function.extfun Type group) : @is_simple_group.{0} (add_semigroup.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (add_semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_163621 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} (add_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (add_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_163622 (h0 : topological_space (has_edist (option unsigned))) : t0_space (has_edist (option unsigned)) := sorry --non-trivial
lemma new_lemma_163623 (h0 : uniform_space (has_to_string (option ennreal))) : separated_space (has_to_string (option ennreal)) := sorry --non-trivial
lemma new_lemma_163624 (h0 : topological_space (add_comm_monoid (comm_group name))) : discrete_topology (add_comm_monoid (comm_group name)) := sorry --non-trivial
lemma new_lemma_163625 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (has_top.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_top.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_163626 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @group.fg.{1} (has_zero.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 group.{1}) (has_zero.{1} Type))  := sorry --non-trivial
lemma new_lemma_163627 (h0 : ring (has_dist (option (option unsigned)))) : is_principal_ideal_ring (has_dist (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_163628 (h0 : group (canonically_ordered_comm_semiring (finset name))) : is_simple_group (canonically_ordered_comm_semiring (finset name)) := sorry --non-trivial
lemma new_lemma_163629 (h2 : ring (has_emptyc num)) : strong_rank_condition (has_emptyc num) := sorry --non-trivial
lemma new_lemma_163630 (h1 : group (with_bot (random_gen (with_bot string_imp)))) : normalizer_condition (with_bot (random_gen (with_bot string_imp))) := sorry --non-trivial
lemma new_lemma_163631 (h0 : semiring (bin_tree (semiring congr_arg_kind))) : is_noetherian_ring (bin_tree (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_163632 (h0 : complete_lattice (canonically_ordered_monoid fun_info)) : is_compactly_generated (canonically_ordered_monoid fun_info) := sorry --non-trivial
lemma new_lemma_163633 (h0 : complete_lattice (dlist (has_nnnorm linarith.ineq))) : complete_lattice.is_Sup_finite_compact (dlist (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_163634 (h1 : function.extfun Type topological_space) : @t0_space.{0} (linear_ordered_add_comm_group.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (linear_ordered_add_comm_group.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_163635 (h1 : topological_space (add_comm_semigroup ereal)) : path_connected_space (add_comm_semigroup ereal) := sorry --non-trivial
lemma new_lemma_163636 (h0 : topological_space (has_to_string (finset name))) : preconnected_space (has_to_string (finset name)) := sorry --non-trivial
lemma new_lemma_163637 (h0 : uniform_space (has_bot (has_bot (has_neg name)))) : separated_space (has_bot (has_bot (has_neg name))) := sorry --non-trivial
lemma new_lemma_163638 (h0 : ring (add_cancel_monoid (has_add linarith.comp))) : is_principal_ideal_ring (add_cancel_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_163639 (h0 : topological_space (has_to_string (has_add linarith.comp))) : totally_separated_space (has_to_string (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_163640 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (has_to_string.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_to_string.{0} name))  := sorry --non-trivial
lemma new_lemma_163641 (h0 : functor.add_const (add_group (has_pos_part Type)) pos) : @is_add_cyclic.{1} (has_pos_part.{1} Type) (@functor.add_const.run.{1 0} (add_group.{1} (has_pos_part.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_163642 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (distrib_lattice.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (distrib_lattice.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_163643 (h0 : has_add linarith.comp_source) (h1 : ring (add_con linarith.comp_source)) : rank_condition (add_con linarith.comp_source) := sorry --non-trivial
lemma new_lemma_163644 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (partial_order.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} h0 (partial_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_163645 (h0 : ring (ring (boolean_algebra.core Type))) : is_domain (ring (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_163646 (h0 : topological_space (ordered_comm_ring (sub_neg_monoid (has_Inf Type)))) : totally_separated_space (ordered_comm_ring (sub_neg_monoid (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_163647 (h0 : function.extfun ((Type 1 -> Type 1) -> Type 2) (function.extfun (Type 1 -> Type 1))) : @group.fg.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) (@function.extfun_app.{4 3} ((Type 1 → Type 1) → Type 2) (function.extfun.{3 3} (Type 1 → Type 1)) h0 (function.extfun.{3 2} (Type 1))) group.{1}) (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_163648 (h0 : function.extfun Type topological_space) : @normal_space.{0} (finset.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} num))  := sorry --non-trivial
lemma new_lemma_163649 (h0 : add_monoid (boolean_algebra (cancel_monoid name))) (h1 : topological_space (has_nndist (add_units (boolean_algebra (cancel_monoid name))))) : t0_space (has_nndist (add_units (boolean_algebra (cancel_monoid name)))) := sorry --non-trivial
lemma new_lemma_163650 (h0 : topological_space (has_append (has_nnnorm linarith.comp_source))) : t0_space (has_append (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_163651 (h0 : topological_space (measurable_space (random_gen linarith.comp_source))) : irreducible_space (measurable_space (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_163652 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (complete_linear_order.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (complete_linear_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_163653 (h1 : topological_space (linear_ordered_add_comm_group (random_gen linarith.ineq))) : locally_compact_space (linear_ordered_add_comm_group (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_163654 (h0 : topological_space (has_neg name)) : totally_separated_space (has_neg name) := sorry --non-trivial
lemma new_lemma_163655 (h0 : list (has_emptyc (measurable_space (has_inv (has_emptyc (has_emptyc congr_arg_kind)))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_163656 (h0 : complete_lattice (distrib_lattice linarith.comp_source)) : is_atomistic (distrib_lattice linarith.comp_source) := sorry --non-trivial
lemma new_lemma_163657 (h0 : not (topological_space (complete_semilattice_Sup empty) -> false)) : @discrete_topology.{0} (complete_semilattice_Sup.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (complete_semilattice_Sup.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_163658 (h0 : function.extfun Type topological_space) : @t0_space.{0} (normed_group.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_group.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_163659 (h0 : topological_space fun_info) (h1 : preorder fun_info) : order_topology fun_info := sorry --non-trivial
lemma new_lemma_163660 (h0 : functor.add_const (topological_space (semigroup unsigned)) environment.implicit_infer_kind) : @sequential_space.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_163661 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (monoid_with_zero ennreal)) := sorry --non-trivial
lemma new_lemma_163662 (h0 : ordered_comm_monoid (boolean_algebra (has_Inf pos))) : has_exists_mul_of_le (boolean_algebra (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_163663 (h0 : group (with_bot (comm_ring to_additive.value_type))) : normalizer_condition (with_bot (comm_ring to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_163664 (h0 : list (random_gen (has_emptyc linarith.comp_source))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_163665 (h0 : complete_lattice (canonically_ordered_comm_semiring (option unsigned)) -> Prop) (h1 : Exists (fun (x : complete_lattice (canonically_ordered_comm_semiring (option unsigned))), h0 x)) : @is_compactly_generated.{0} (canonically_ordered_comm_semiring.{0} (option.{0} unsigned)) (@classical.some.{1} (complete_lattice.{0} (canonically_ordered_comm_semiring.{0} (option.{0} unsigned))) h0 h1)  := sorry --non-trivial
lemma new_lemma_163666 (h0 : topological_space (has_zero (add_comm_monoid (has_to_string ennreal)))) : t1_space (has_zero (add_comm_monoid (has_to_string ennreal))) := sorry --non-trivial
lemma new_lemma_163667 (h0 : finset (ordered_comm_group (option empty))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_163668 (h0 : topological_space (add_cancel_monoid (has_add (finset (ring pos))))) : preirreducible_space (add_cancel_monoid (has_add (finset (ring pos)))) := sorry --non-trivial
lemma new_lemma_163669 (h0 : topological_space (ordered_comm_ring (has_nndist (has_Inf Type)))) : preirreducible_space (ordered_comm_ring (has_nndist (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_163670 (h0 : uniform_space (add_cancel_monoid (has_add (boolean_algebra name)))) : separated_space (add_cancel_monoid (has_add (boolean_algebra name))) := sorry --non-trivial
lemma new_lemma_163671 (h0 : functor.add_const (function.extfun Type ordered_add_comm_monoid) Type) : @archimedean.{0} (has_Inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ordered_add_comm_monoid.{0}) Type h0) (has_Inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_163672 (h0 : functor.add_const (add_group (simple_graph Type)) name) : @is_add_cyclic.{1} (simple_graph.{1} Type) (@functor.add_const.run.{1 0} (add_group.{1} (simple_graph.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_163673 (h0 : has_mem.mem (has_emptyc empty) has_emptyc.emptyc) : @add_monoid.fg.{0} (has_emptyc.{0} empty) (@finset.pi.empty.{1 0} Type add_monoid.{0} (has_emptyc.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_163674 (h1 : topological_space (measurable_space (semiring linarith.comp))) : preirreducible_space (measurable_space (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_163675 (h0 : complete_lattice (semiring (has_top empty))) : is_atomistic (semiring (has_top empty)) := sorry --non-trivial
lemma new_lemma_163676 (h0 : uniform_space (ordered_comm_ring (has_bot real))) : complete_space (ordered_comm_ring (has_bot real)) := sorry --non-trivial
lemma new_lemma_163677 (h0 : functor.add_const (ordered_add_comm_monoid (left_cancel_monoid empty)) congr_arg_kind) : @archimedean.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (left_cancel_monoid.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_163678 (h0 : ring (has_div (has_nnnorm (has_nnnorm linarith.ineq)))) : rank_condition (has_div (has_nnnorm (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_163679 (h0 : topological_space (ordered_comm_ring (has_Inf (has_Inf pos)))) : totally_separated_space (ordered_comm_ring (has_Inf (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_163680 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (with_bot.{0} linarith.comp) (@function.extfun_app.{2 1} Type monoid.{0} h0 (with_bot.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_163681 (h0 : uniform_space (has_to_string (option (mul_zero_class name)))) : complete_space (has_to_string (option (mul_zero_class name))) := sorry --non-trivial
lemma new_lemma_163682 (h0 : complete_lattice (random_gen (semiring (has_top linarith.comp)))) : is_atomistic (random_gen (semiring (has_top linarith.comp))) := sorry --non-trivial
lemma new_lemma_163683 (h0 : group (complete_semilattice_Sup (has_nnnorm (has_nnnorm linarith.comp_source)))) : is_cyclic (complete_semilattice_Sup (has_nnnorm (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_163684 (h2 : complete_lattice (semi_normed_comm_ring reducibility_hints)) : complete_lattice.is_Sup_finite_compact (semi_normed_comm_ring reducibility_hints) := sorry --non-trivial
lemma new_lemma_163685 (h0 : ordered_add_comm_monoid (finset (has_neg_part Type))) : archimedean (finset (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_163686 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (ordered_cancel_add_comm_monoid congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_163687 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (has_neg.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (has_neg.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_163688 (h1 : ring linarith.ineq) : is_domain linarith.ineq := sorry --non-trivial
lemma new_lemma_163689 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (linear_ordered_field.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_field.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_163690 (h0 : topological_space (add_cancel_monoid (has_add (has_add Type)))) : sequential_space (add_cancel_monoid (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_163691 (h0 : group (random_gen (has_inv (has_inv (has_inv to_additive.value_type))))) : is_cyclic (random_gen (has_inv (has_inv (has_inv to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_163692 (h0 : filter (linear_ordered_add_comm_group (random_gen fun_info))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_163693 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (normed_comm_ring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_163694 (h0 : uniform_space (has_nndist (finset Type))) : separated_space (has_nndist (finset Type)) := sorry --non-trivial
lemma new_lemma_163695 (h0 : filter (pseudo_metric_space empty)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_163696 (h0 : functor.add_const (topological_space (ordered_cancel_add_comm_monoid empty)) unsigned) : @normal_space.{0} (ordered_cancel_add_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_cancel_add_comm_monoid.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_163697 (h0 : not (topological_space (complete_semilattice_Sup unsigned) -> false)) : @discrete_topology.{0} (complete_semilattice_Sup.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (complete_semilattice_Sup.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_163698 (h0 : functor.add_const (topological_space (option congr_arg_kind)) num) : @preirreducible_space.{0} (option.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_163699 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_163700 (h0 : topological_space (add_group (has_norm linarith.comp))) : normal_space (add_group (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_163701 (h0 : topological_space (add_cancel_monoid (ring (boolean_algebra (has_Inf Type))))) : totally_separated_space (add_cancel_monoid (ring (boolean_algebra (has_Inf Type)))) := sorry --non-trivial
lemma new_lemma_163702 (h0 : functor.add_const (topological_space (add_cancel_monoid name)) name) : @sequential_space.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_163703 (h0 : fin has_zero.zero) : totally_separated_space real := sorry --non-trivial
lemma new_lemma_163704 (h0 : equiv.perm (has_inf fun_info)) : equiv.perm.is_cycle h0 := sorry --non-trivial
lemma new_lemma_163705 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (complete_linear_order unsigned)) := sorry --non-trivial
lemma new_lemma_163706 (h0 : topological_space (generalized_boolean_algebra (ring linarith.comp))) : totally_disconnected_space (generalized_boolean_algebra (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_163707 (h0 : filter (has_norm (random_gen num))) (h1 : has_norm (random_gen num) -> Prop) : @filter.limsup.{0 0} Prop (has_norm.{0} (random_gen.{0} num)) (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice) h0 h1  := sorry --non-trivial
lemma new_lemma_163708 (h0 : list (generalized_boolean_algebra (ring (canonically_ordered_comm_semiring pos)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_163709 (h0 : ring (has_inter empty)) : rank_condition (has_inter empty) := sorry --non-trivial
lemma new_lemma_163710 (h0 : uniform_space (simple_graph (mul_one_class (mul_one_class (has_ssubset char))))) : complete_space (simple_graph (mul_one_class (mul_one_class (has_ssubset char)))) := sorry --non-trivial
lemma new_lemma_163711 (h2 : not (complete_lattice (normed_field char) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (normed_field.{0} char) (@classical.by_contradiction'.{1} (complete_lattice.{0} (normed_field.{0} char)) h2)  := sorry --non-trivial
lemma new_lemma_163712 (h0 : topological_space (has_add (has_nndist (finset (has_add (has_neg pos)))))) : path_connected_space (has_add (has_nndist (finset (has_add (has_neg pos))))) := sorry --non-trivial
lemma new_lemma_163713 (h0 : uniform_space (mul_one_class enat)) (h1 : uniform_space (uniform_space.separation_quotient (mul_one_class enat))) : complete_space (uniform_space.separation_quotient (mul_one_class enat)) := sorry --non-trivial
lemma new_lemma_163714 (h0 : functor.add_const (topological_space (finset linarith.comp)) Type) : @sequential_space.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (finset.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_163715 (h0 : semiring (has_add (option ennreal))) : is_noetherian_ring (has_add (option ennreal)) := sorry --non-trivial
lemma new_lemma_163716 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (add_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_163717 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (finset.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (finset.{0} name))  := sorry --non-trivial
lemma new_lemma_163718 (h1 : ring (has_append reducibility_hints)) : rank_condition (has_append reducibility_hints) := sorry --non-trivial
lemma new_lemma_163719 (h1 : topological_space num) : totally_separated_space num := sorry --non-trivial
lemma new_lemma_163720 (h0 : functor.add_const (topological_space (boolean_algebra.core name)) name) : @loc_path_connected_space.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_163721 (h0 : topological_space (has_star (semiring congr_arg_kind))) : totally_disconnected_space (has_star (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_163722 (h0 : functor.add_const (group (cancel_monoid Type)) linarith.comp) : @group.fg.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (cancel_monoid.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_163723 (h0 : function.extfun (finset Type) (has_mem.mem (complete_semilattice_Sup linarith.comp))) : @normalizer_condition.{0} (complete_semilattice_Sup.{0} linarith.comp) (@finset.pi.empty.{1 0} Type group.{0} (complete_semilattice_Sup.{0} linarith.comp) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (complete_semilattice_Sup.{0} linarith.comp)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_163724 (h0 : functor.add_const (list (has_to_string pos)) pos) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_163725 (h0 : function.extfun Type (functor.comp ring has_neg_part)) : @is_principal_ideal_ring.{0} (has_neg_part.{0} ennreal) (@functor.comp.run.{0 0 0} ring.{0} has_neg_part.{0} ennreal (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} ring.{0} has_neg_part.{0}) h0 ennreal))  := sorry --non-trivial
lemma new_lemma_163726 (h0 : not (function.extfun (finset Type) (has_mem.mem (measurable_space unsigned)) -> false)) : @add_monoid.fg.{0} (measurable_space.{0} unsigned) (@finset.pi.empty.{1 0} Type add_monoid.{0} (measurable_space.{0} unsigned) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (measurable_space.{0} unsigned)) (@classical.by_contradiction'.{0} (function.extfun.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (measurable_space.{0} unsigned))) h0) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_163727 (h2 : complete_lattice (mul_one_class char)) : complete_lattice.is_Sup_finite_compact (mul_one_class char) := sorry --non-trivial
lemma new_lemma_163728 (h0 : list (has_emptyc (random_gen (random_gen linarith.comp_source)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_163729 (h0 : not (topological_space (complete_semilattice_Sup congr_arg_kind) -> false)) : @path_connected_space.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (complete_semilattice_Sup.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_163730 (h0 : monoid (id (semiring (has_top unsigned)))) : monoid.fg (id (semiring (has_top unsigned))) := sorry --non-trivial
lemma new_lemma_163731 (h0 : topological_space (boolean_algebra (has_Inf (normed_comm_ring pos)))) : path_connected_space (boolean_algebra (has_Inf (normed_comm_ring pos))) := sorry --non-trivial
lemma new_lemma_163732 (h0 : topological_space (boolean_algebra.core (has_add (has_add pos)))) : totally_disconnected_space (boolean_algebra.core (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_163733 (h0 : topological_space (linear_ordered_field pos)) : t1_space (linear_ordered_field pos) := sorry --non-trivial
lemma new_lemma_163734 (h0 : functor.add_const (topological_space (has_pos_part pos)) (has_neg linarith.comp)) : @loc_path_connected_space.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} pos)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_163735 (h0 : topological_space (complete_distrib_lattice (has_add linarith.comp))) : preirreducible_space (complete_distrib_lattice (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_163736 (h1 : complete_lattice (nondiscrete_normed_field reducibility_hints)) : complete_lattice.is_Sup_finite_compact (nondiscrete_normed_field reducibility_hints) := sorry --non-trivial
lemma new_lemma_163737 (h0 : finset (generalized_boolean_algebra (has_Inf pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_163738 (h2 : not (topological_space (with_one num) -> false)) : @locally_compact_space.{0} (with_one.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (with_one.{0} num)) h2)  := sorry --non-trivial
lemma new_lemma_163739 (h0 : topological_space (cancel_monoid (comm_group unsigned))) : normal_space (cancel_monoid (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_163740 (h0 : functor.add_const (function.extfun Type ring) pos) : @strong_rank_condition.{0} (has_Inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) pos h0) (has_Inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_163741 (h0 : topological_space (with_bot (random_gen linarith.comp))) : totally_disconnected_space (with_bot (random_gen linarith.comp)) := sorry --non-trivial
lemma new_lemma_163742 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (filter.{0} empty) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (filter.{0} empty))  := sorry --non-trivial
lemma new_lemma_163743 (h0 : functor.add_const (complete_lattice (has_well_founded empty)) empty) : @is_compactly_generated.{1} (has_well_founded.{1} empty) (@functor.add_const.run.{1 0} (complete_lattice.{1} (has_well_founded.{1} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_163744 (h1 : add_group (distrib_lattice (has_nnnorm (has_nnnorm char)))) : is_add_cyclic (distrib_lattice (has_nnnorm (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_163745 (h0 : group (ring Type)) : is_cyclic (ring Type) := sorry --non-trivial
lemma new_lemma_163746 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_163747 (h0 : functor.add_const (topological_space (comm_group real)) name) : @discrete_topology.{0} (comm_group.{0} real) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} real)) name h0)  := sorry --non-trivial
lemma new_lemma_163748 (h0 : set (add_comm_semigroup (add_comm_semigroup (mul_one_class std_gen)) -> std_gen)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_163749 (h0 : finset num) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_163750 (h0 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} (normed_group.{0} linarith.ineq) (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h0) (normed_group.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_163751 (h0 : group (random_gen (semiring (semiring (semiring (semiring unsigned)))))) : normalizer_condition (random_gen (semiring (semiring (semiring (semiring unsigned))))) := sorry --non-trivial
lemma new_lemma_163752 (h0 : uniform_space (cancel_monoid (has_neg pos))) : complete_space (cancel_monoid (has_neg pos)) := sorry --non-trivial
lemma new_lemma_163753 (h0 : not (function.extfun Type topological_space -> false)) : @preirreducible_space.{0} (add_right_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (add_right_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_163754 (h0 : function.extfun Type topological_space) : @regular_space.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_163755 (h0 : functor.add_const (topological_space (monoid unsigned)) (option unsigned)) : @totally_separated_space.{0} (monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (monoid.{0} unsigned)) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_163756 (h0 : complete_lattice (has_norm (random_gen (has_top (has_inv fun_info))))) : is_atomistic (has_norm (random_gen (has_top (has_inv fun_info)))) := sorry --non-trivial
lemma new_lemma_163757 (h0 : not (monoid (has_emptyc linarith.comp_source) -> false)) : @monoid.fg.{0} (has_emptyc.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (monoid.{0} (has_emptyc.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_163758 (h1 : complete_lattice (distrib (metric_space (add_cancel_comm_monoid string_imp)))) : is_compactly_generated (distrib (metric_space (add_cancel_comm_monoid string_imp))) := sorry --non-trivial
lemma new_lemma_163759 (h1 : complete_lattice (measurable_space to_additive.value_type)) : is_compactly_generated (measurable_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_163760 (h1 : topological_space (denumerable string_imp)) : totally_disconnected_space (denumerable string_imp) := sorry --non-trivial
lemma new_lemma_163761 (h0 : ring (canonically_linear_ordered_monoid (has_Inf Type))) : rank_condition (canonically_linear_ordered_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_163762 (h2 : ring (mul_one_class (add_comm_semigroup char))) : is_domain (mul_one_class (add_comm_semigroup char)) := sorry --non-trivial
lemma new_lemma_163763 (h0 : functor.add_const (group (has_bot pos)) pos) : @is_cyclic.{0} (has_bot.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_bot.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_163764 (h1 : ring (add_comm_semigroup reducibility_hints)) : is_domain (add_comm_semigroup reducibility_hints) := sorry --non-trivial
lemma new_lemma_163765 (h0 : topological_space (has_emptyc (has_top num))) : t0_space (has_emptyc (has_top num)) := sorry --non-trivial
lemma new_lemma_163766 (h0 : fin has_zero.zero) : @loc_path_connected_space.{1} (canonically_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (canonically_ordered_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_163767 (h0 : topological_space (complete_distrib_lattice Type)) : normal_space (complete_distrib_lattice Type) := sorry --non-trivial
lemma new_lemma_163768 (h0 : topological_space (complete_distrib_lattice (option (option (option (option empty)))))) : irreducible_space (complete_distrib_lattice (option (option (option (option empty))))) := sorry --non-trivial
lemma new_lemma_163769 (h0 : list (has_top (comm_ring to_additive.value_type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_163770 (h0 : topological_space (add_comm_monoid (option ennreal))) : normal_space (add_comm_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_163771 (h1 : ring (has_compl char)) : rank_condition (has_compl char) := sorry --non-trivial
lemma new_lemma_163772 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring ennreal)) name) : @discrete_topology.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_163773 (h0 : topological_space (comm_ring linarith.comp_source)) : locally_compact_space (comm_ring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_163774 (h0 : functor.add_const (ring (cancel_monoid empty)) empty) : @rank_condition.{0} (cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (cancel_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_163775 (h0 : monoid (has_emptyc (has_inv (has_top (has_inv (has_inv (has_inv linarith.comp_source))))))) : monoid.fg (has_emptyc (has_inv (has_top (has_inv (has_inv (has_inv linarith.comp_source)))))) := sorry --non-trivial
lemma new_lemma_163776 (h0 : topological_space (has_norm (random_gen (has_norm (random_gen linarith.ineq))))) : path_connected_space (has_norm (random_gen (has_norm (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_163777 (h0 : filter (mul_zero_class (boolean_algebra.core name))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_163778 (h0 : finset (has_Inf (has_Inf linarith.comp))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_163779 (h0 : function.extfun Type group) : @is_cyclic.{0} (add_group.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (add_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_163780 (h0 : complete_lattice (ordered_comm_monoid (ring Type))) : complete_lattice.is_Sup_finite_compact (ordered_comm_monoid (ring Type)) := sorry --non-trivial
lemma new_lemma_163781 (h0 : not (topological_space (add_cancel_comm_monoid reducibility_hints) -> false)) : @t0_space.{0} (add_cancel_comm_monoid.{0} reducibility_hints) (@classical.by_contradiction'.{1} (topological_space.{0} (add_cancel_comm_monoid.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_163782 (h0 : complete_lattice (has_bot (has_scalar (ordered_comm_ring Type) (sub_neg_monoid pos)))) : is_atomistic (has_bot (has_scalar (ordered_comm_ring Type) (sub_neg_monoid pos))) := sorry --non-trivial
lemma new_lemma_163783 (h0 : group (random_gen (has_nnnorm char))) : is_cyclic (random_gen (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_163784 (h0 : functor.comp list linear_ordered_field name) : palindrome (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_163785 (h0 : not (topological_space (uniform_space (mul_one_class (mul_one_class enat))) -> false)) : @t0_space.{0} (uniform_space.{0} (mul_one_class.{0} (mul_one_class.{0} enat))) (@classical.by_contradiction'.{1} (topological_space.{0} (uniform_space.{0} (mul_one_class.{0} (mul_one_class.{0} enat)))) h0)  := sorry --non-trivial
lemma new_lemma_163786 (h0 : ring (uniform_space (mul_one_class enat))) : rank_condition (uniform_space (mul_one_class enat)) := sorry --non-trivial
lemma new_lemma_163787 (h0 : topological_space (distrib (mul_one_class (has_nnnorm reducibility_hints)))) : t0_space (distrib (mul_one_class (has_nnnorm reducibility_hints))) := sorry --non-trivial
lemma new_lemma_163788 (h1 : uniform_space int) : complete_space int := sorry --non-trivial
lemma new_lemma_163789 (h0 : topological_space (sub_neg_monoid real)) : regular_space (sub_neg_monoid real) := sorry --non-trivial
lemma new_lemma_163790 (h0 : ring (complete_distrib_lattice (option (option unsigned)))) : is_domain (complete_distrib_lattice (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_163791 (h0 : add_group (random_gen (has_nnnorm linarith.comp_source))) : is_add_cyclic (random_gen (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_163792 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (has_to_string.{0} ennreal) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (has_to_string.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_163793 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (has_emptyc.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 add_group.{0}) (has_emptyc.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_163794 (h0 : group (has_nndist (has_zero (finset (finset pos))))) : is_cyclic (has_nndist (has_zero (finset (finset pos)))) := sorry --non-trivial
lemma new_lemma_163795 (h0 : functor.add_const (ring (free_add_monoid empty)) congr_arg_kind) : @is_domain.{0} (free_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (free_add_monoid.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_163796 (h0 : add_group (simple_graph (mul_one_class string.iterator_imp))) : is_add_cyclic (simple_graph (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_163797 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (option.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (option.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_163798 (h0 : functor.add_const (topological_space (has_star congr_arg_kind)) (semiring (semiring congr_arg_kind))) : @totally_disconnected_space.{0} (has_star.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} congr_arg_kind)) (semiring.{0} (semiring.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_163799 (h0 : has_le (mul_one_class std_gen)) (h1 : bounded_order (mul_one_class std_gen)) : is_simple_order (mul_one_class std_gen) := sorry --non-trivial
lemma new_lemma_163800 (h0 : cancel_comm_monoid_with_zero (ordered_comm_group unsigned)) : unique_factorization_monoid (ordered_comm_group unsigned) := sorry --non-trivial
lemma new_lemma_163801 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (has_Inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_Inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_163802 (h0 : ring (has_Inf (ordered_ring linarith.comp))) : strong_rank_condition (has_Inf (ordered_ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_163803 (h0 : functor.add_const (finset (add_comm_monoid num)) num) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_163804 (h0 : group (preorder unsigned)) : normalizer_condition (preorder unsigned) := sorry --non-trivial
lemma new_lemma_163805 (h0 : topological_space (has_nndist (ring (has_to_string environment.implicit_infer_kind)))) : preirreducible_space (has_nndist (ring (has_to_string environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_163806 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (has_neg.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_neg.{0} name))  := sorry --non-trivial
lemma new_lemma_163807 (h0 : filter (random_gen (denumerable empty))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_163808 (h0 : functor.add_const (topological_space (has_to_string name)) (ring Type)) : @irreducible_space.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (has_to_string.{0} name)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_163809 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (canonically_linear_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (canonically_linear_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_163810 (h0 : complete_lattice (random_gen (metric_space linarith.comp_source))) : complete_lattice.is_Sup_finite_compact (random_gen (metric_space linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_163811 (h0 : function.extfun Type group) : @is_simple_group.{0} (has_to_string.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (has_to_string.{0} num))  := sorry --non-trivial
lemma new_lemma_163812 (h0 : group (finset (boolean_algebra.core Type))) : is_simple_group (finset (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_163813 (h0 : functor.add_const (add_group (boolean_algebra pos)) pos) : @is_add_cyclic.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (boolean_algebra.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_163814 (h0 : complete_lattice (topological_space linarith.ineq)) : complete_lattice.is_Sup_finite_compact (topological_space linarith.ineq) := sorry --non-trivial
lemma new_lemma_163815 (h0 : functor.add_const (cancel_comm_monoid_with_zero (mul_zero_class environment.implicit_infer_kind)) Type) : @unique_factorization_monoid.{0} (mul_zero_class.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (cancel_comm_monoid_with_zero.{0} (mul_zero_class.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_163816 (h0 : complete_lattice (has_top (has_top fun_info))) : complete_lattice.is_Sup_finite_compact (has_top (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_163817 (h0 : functor.add_const (ring (boolean_algebra unsigned)) linarith.comp) : @is_domain.{0} (boolean_algebra.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_163818 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (filter.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (filter.{0} empty))  := sorry --non-trivial
lemma new_lemma_163819 (h0 : topological_space (add_cancel_monoid (option unsigned))) : locally_compact_space (add_cancel_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_163820 (h0 : monoid (has_emptyc (random_gen (random_gen (random_gen (random_gen linarith.comp_source)))))) : monoid.fg (has_emptyc (random_gen (random_gen (random_gen (random_gen linarith.comp_source))))) := sorry --non-trivial
lemma new_lemma_163821 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (normed_lattice_add_comm_group.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_lattice_add_comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_163822 (h0 : cancel_comm_monoid_with_zero (has_nndist (has_add (boolean_algebra.core (has_add (has_add name)))))) : unique_factorization_monoid (has_nndist (has_add (boolean_algebra.core (has_add (has_add name))))) := sorry --non-trivial
lemma new_lemma_163823 (h0 : monoid (has_add (ring linarith.comp))) : monoid.fg (has_add (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_163824 (h1 : add_group (has_nnnorm (mul_one_class (has_le (has_nnnorm (mul_one_class string_imp)))))) : is_add_cyclic (has_nnnorm (mul_one_class (has_le (has_nnnorm (mul_one_class string_imp))))) := sorry --non-trivial
lemma new_lemma_163825 (h0 : not (topological_space (linear_ordered_semiring linarith.comp) -> false)) : @path_connected_space.{0} (linear_ordered_semiring.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_semiring.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_163826 (h0 : filter (linear_ordered_semiring (semiring (semiring (semiring unsigned))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_163827 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (add_left_cancel_semigroup.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_left_cancel_semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_163828 (h0 : group (add_cancel_comm_monoid (topological_space reducibility_hints))) : is_cyclic (add_cancel_comm_monoid (topological_space reducibility_hints)) := sorry --non-trivial
lemma new_lemma_163829 (h0 : functor.add_const (ordered_comm_monoid (ring linarith.comp)) linarith.comp) : @has_exists_mul_of_le.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (ring.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_163830 (h0 : ring (normed_lattice_add_comm_group (has_Inf (has_Inf (has_Inf (has_add pos)))))) : strong_rank_condition (normed_lattice_add_comm_group (has_Inf (has_Inf (has_Inf (has_add pos))))) := sorry --non-trivial
lemma new_lemma_163831 (h0 : functor.comp topological_space has_neg_part ennreal) : @regular_space.{0} (has_neg_part.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg_part.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_163832 (h0 : topological_space (semigroup (has_neg_part (has_neg_part (has_neg_part Type))))) : preirreducible_space (semigroup (has_neg_part (has_neg_part (has_neg_part Type)))) := sorry --non-trivial
lemma new_lemma_163833 (h0 : functor.add_const (topological_space (add_cancel_monoid pos)) Type) : @totally_separated_space.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (add_cancel_monoid.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_163834 (h0 : functor.add_const (topological_space (normed_comm_ring unsigned)) pos) : @loc_path_connected_space.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_163835 (h0 : topological_space (free_add_monoid (semiring num))) : topological_space.separable_space (free_add_monoid (semiring num)) := sorry --non-trivial
lemma new_lemma_163836 (h0 : monoid (add_comm_monoid (has_neg_part unsigned))) : monoid.fg (add_comm_monoid (has_neg_part unsigned)) := sorry --non-trivial
lemma new_lemma_163837 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (add_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (add_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_163838 (h0 : functor.add_const (ring (has_pos_part name)) linarith.comp) : @is_domain.{0} (has_pos_part.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (has_pos_part.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_163839 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_group.{0} h0 (monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_163840 (h0 : topological_space (canonically_ordered_monoid Type)) : loc_path_connected_space (canonically_ordered_monoid Type) := sorry --non-trivial
lemma new_lemma_163841 (h0 : topological_space (topological_space (ordered_cancel_comm_monoid char))) : path_connected_space (topological_space (ordered_cancel_comm_monoid char)) := sorry --non-trivial
lemma new_lemma_163842 (h0 : uniform_space (with_bot (has_inv to_additive.value_type))) : complete_space (with_bot (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_163843 (h0 : finset (comm_monoid (option unsigned))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_163844 (h0 : function.extfun Type (functor.add_const (cancel_comm_monoid_with_zero (ordered_ring unsigned)))) : @unique_factorization_monoid.{0} (ordered_ring.{0} unsigned) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (ordered_ring.{0} unsigned)) congr_arg_kind (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (cancel_comm_monoid_with_zero.{0} (ordered_ring.{0} unsigned))) h0 congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_163845 (h0 : function.extfun nat fin) : @has_exists_mul_of_le.{0} (ordered_comm_monoid.{0} real) (@matrix.vec_empty.{0} (ordered_comm_monoid.{0} (ordered_comm_monoid.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_163846 (h0 : group (boolean_algebra.core (has_to_string name))) : normalizer_condition (boolean_algebra.core (has_to_string name)) := sorry --non-trivial
lemma new_lemma_163847 (h0 : uniform_space (boolean_algebra (canonically_linear_ordered_monoid real))) : complete_space (boolean_algebra (canonically_linear_ordered_monoid real)) := sorry --non-trivial
lemma new_lemma_163848 (h0 : list (boolean_algebra.core (has_neg linarith.comp))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_163849 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (semigroup.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (semigroup.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_163850 (h0 : complete_lattice (mul_one_class string_imp)) : is_compactly_generated (mul_one_class string_imp) := sorry --non-trivial
lemma new_lemma_163851 (h0 : topological_space (normed_comm_ring (finset linarith.comp))) : t0_space (normed_comm_ring (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_163852 (h0 : functor.add_const (function.extfun (Type 1) add_group) num) : @is_add_cyclic.{1} (plift.{1} empty) (@function.extfun_app.{3 2} (Type 1) add_group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) add_group.{1}) num h0) (plift.{1} empty))  := sorry --non-trivial
lemma new_lemma_163853 (h0 : topological_space (has_neg_part (has_add (semigroup Type)))) : t0_space (has_neg_part (has_add (semigroup Type))) := sorry --non-trivial
lemma new_lemma_163854 (h0 : has_mem.mem group has_emptyc.emptyc) : @group.fg.{0} (linear_ordered_semiring.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} h0) (linear_ordered_semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_163855 (h0 : ring (group_with_zero (option (option num)))) : strong_rank_condition (group_with_zero (option (option num))) := sorry --non-trivial
lemma new_lemma_163856 (h0 : add_monoid (complete_linear_order (semiring (semiring congr_arg_kind)))) : add_monoid.fg (complete_linear_order (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_163857 (h0 : topological_space (with_one empty)) : t0_space (with_one empty) := sorry --non-trivial
lemma new_lemma_163858 (h0 : function.extfun (Type 1) topological_space) : @sequential_space.{1} Type (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 Type)  := sorry --non-trivial
lemma new_lemma_163859 (h0 : topological_space (cancel_monoid unsigned)) : normal_space (cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_163860 (h0 : monoid (finset (semigroup pos))) : monoid.fg (finset (semigroup pos)) := sorry --non-trivial
lemma new_lemma_163861 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (normed_linear_ordered_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_linear_ordered_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_163862 (h0 : ring (random_gen (random_gen (has_norm fun_info)))) : strong_rank_condition (random_gen (random_gen (has_norm fun_info))) := sorry --non-trivial
lemma new_lemma_163863 (h0 : ring (has_compl (random_gen linarith.comp_source))) : is_domain (has_compl (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_163864 (h0 : functor.add_const (function.extfun Type topological_space) environment.implicit_infer_kind) : @normal_space.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) environment.implicit_infer_kind h0) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_163865 (h0 : not (topological_space (left_cancel_semigroup empty) -> false)) : @discrete_topology.{0} (left_cancel_semigroup.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (left_cancel_semigroup.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_163866 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (with_bot.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_bot.{0} num))  := sorry --non-trivial
lemma new_lemma_163867 (h0 : topological_space (has_union (semiring congr_arg_kind))) : totally_disconnected_space (has_union (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_163868 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (metric_space.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (metric_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_163869 (h0 : functor.add_const (topological_space (complete_semilattice_Sup congr_arg_kind)) unsigned) : @loc_path_connected_space.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_semilattice_Sup.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_163870 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @totally_separated_space.{0} (ordered_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (ordered_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_163871 (h0 : complete_lattice (ring (has_add (has_add Type)))) : is_compactly_generated (ring (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_163872 (h0 : functor.add_const (topological_space (boolean_algebra linarith.comp)) pos) : @irreducible_space.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_163873 (h0 : function.extfun (Type 1) topological_space) : @normal_space.{1} (normed_lattice_add_comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (normed_lattice_add_comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_163874 (h0 : group (has_zero (has_Inf name))) : group.fg (has_zero (has_Inf name)) := sorry --non-trivial
lemma new_lemma_163875 (h0 : list (ordered_cancel_add_comm_monoid unsigned)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_163876 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (filter.{0} unsigned) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (filter.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_163877 (h3 : add_group (has_div linarith.ineq)) : is_add_cyclic (has_div linarith.ineq) := sorry --non-trivial
lemma new_lemma_163878 (h0 : order_hom nat (topological_space (set empty))) : @path_connected_space.{0} (set.{0} empty) (@monotonic_sequence_limit.{0} (topological_space.{0} (set.{0} empty)) (@topological_space.partial_order.{0} (set.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_163879 (h0 : add_group (has_nnnorm ereal)) : is_add_cyclic (has_nnnorm ereal) := sorry --non-trivial
lemma new_lemma_163880 (h0 : has_lt (nondiscrete_normed_field (normed_field linarith.ineq))) : no_max_order (nondiscrete_normed_field (normed_field linarith.ineq)) := sorry --non-trivial
lemma new_lemma_163881 (h0 : monoid (finset (option (option (option (option (option (option (option empty))))))))) : monoid.fg (finset (option (option (option (option (option (option (option empty)))))))) := sorry --non-trivial
lemma new_lemma_163882 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (ordered_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (ordered_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_163883 (h0 : not (complete_lattice (has_top empty) -> false)) : @is_atomistic.{0} (has_top.{0} empty) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_top.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_163884 (h0 : functor.add_const (topological_space (has_nndist pos)) linarith.comp) : @topological_space.separable_space.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_163885 (h0 : ring (has_bot (ordered_comm_monoid (has_Inf real)))) : rank_condition (has_bot (ordered_comm_monoid (has_Inf real))) := sorry --non-trivial
lemma new_lemma_163886 (h0 : ring (linear_ordered_comm_group_with_zero char)) : rank_condition (linear_ordered_comm_group_with_zero char) := sorry --non-trivial
lemma new_lemma_163887 (h0 : topological_space (simple_graph unsigned)) : totally_disconnected_space (simple_graph unsigned) := sorry --non-trivial
lemma new_lemma_163888 (h0 : not (function.extfun Type topological_space -> false)) : @irreducible_space.{0} (has_top.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_top.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_163889 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (has_bot.{0} real) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_bot.{0} real))  := sorry --non-trivial
lemma new_lemma_163890 (h0 : complete_lattice (has_zero unsigned)) : complete_lattice.is_Sup_finite_compact (has_zero unsigned) := sorry --non-trivial
lemma new_lemma_163891 (h0 : topological_space (ring (ring (ordered_ring Type)))) : totally_separated_space (ring (ring (ordered_ring Type))) := sorry --non-trivial
lemma new_lemma_163892 (h0 : not (topological_space (has_top linarith.comp) -> false)) : @path_connected_space.{0} (has_top.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (has_top.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_163893 (h0 : ring (has_bot (has_neg real))) : is_domain (has_bot (has_neg real)) := sorry --non-trivial
lemma new_lemma_163894 (h0 : uniform_space (generalized_boolean_algebra (has_neg pos))) : separated_space (generalized_boolean_algebra (has_neg pos)) := sorry --non-trivial
lemma new_lemma_163895 (h3 : topological_space (id linarith.comp_source)) : locally_compact_space (id linarith.comp_source) := sorry --non-trivial
lemma new_lemma_163896 (h0 : cancel_comm_monoid_with_zero (canonically_linear_ordered_monoid ennreal)) : unique_factorization_monoid (canonically_linear_ordered_monoid ennreal) := sorry --non-trivial
lemma new_lemma_163897 (h0 : topological_space (boolean_algebra.core (has_neg (has_neg name)))) : discrete_topology (boolean_algebra.core (has_neg (has_neg name))) := sorry --non-trivial
lemma new_lemma_163898 (h0 : fin has_zero.zero) : @loc_path_connected_space.{1} (comm_semigroup.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (comm_semigroup.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_163899 (h0 : topological_space (measure_theory.measure_space unsigned)) : discrete_topology (measure_theory.measure_space unsigned) := sorry --non-trivial
lemma new_lemma_163900 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (option.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (option.{0} name))  := sorry --non-trivial
lemma new_lemma_163901 (h0 : filter (has_to_string (has_to_string (has_add name)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_163902 (h0 : uniform_space (distrib linarith.ineq)) : complete_space (distrib linarith.ineq) := sorry --non-trivial
lemma new_lemma_163903 (h1 : complete_lattice (normed_field char)) : complete_lattice.is_Sup_finite_compact (normed_field char) := sorry --non-trivial
lemma new_lemma_163904 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (add_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (add_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_163905 (h0 h1 : multiset linarith.comp_source) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_163906 (h0 : list (has_Inf (has_Inf (has_add (has_Inf (has_pos_part linarith.comp)))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_163907 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (comm_group.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_163908 (h0 : has_lt (has_nnnorm (mul_one_class reducibility_hints))) : no_max_order (has_nnnorm (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_163909 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_inv.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inv.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_163910 (h0 : functor.add_const (group (left_cancel_monoid congr_arg_kind)) empty) : @group.fg.{0} (left_cancel_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (group.{0} (left_cancel_monoid.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_163911 (h0 : uniform_space (has_bot name)) : complete_space (has_bot name) := sorry --non-trivial
lemma new_lemma_163912 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (linear_ordered_comm_ring.{0} num) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (linear_ordered_comm_ring.{0} num))  := sorry --non-trivial
lemma new_lemma_163913 (h0 : functor.add_const (ring (has_to_string name)) pos) : @is_principal_ideal_ring.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (has_to_string.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_163914 (h0 : function.extfun Type (functor.comp topological_space has_zero)) : @loc_path_connected_space.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} has_zero.{0} environment.implicit_infer_kind (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} has_zero.{0}) h0 environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_163915 (h0 : function.extfun nat fin) : @irreducible_space.{0} (canonically_linear_ordered_monoid.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (canonically_linear_ordered_monoid.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_163916 (h0 : ring (add_comm_monoid empty)) : rank_condition (add_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_163917 (h0 : topological_space (ordered_ring (option empty))) : path_connected_space (ordered_ring (option empty)) := sorry --non-trivial
lemma new_lemma_163918 (h0 : group (finset (canonically_ordered_comm_semiring (has_neg pos)))) : normalizer_condition (finset (canonically_ordered_comm_semiring (has_neg pos))) := sorry --non-trivial
lemma new_lemma_163919 (h0 : function.extfun Type (functor.comp filter has_add)) : countable_Inter_filter (functor.comp.run (function.extfun_app h0 ennreal)) := sorry --non-trivial
lemma new_lemma_163920 (h0 : functor.add_const (ring (finset environment.implicit_infer_kind)) name) : @strong_rank_condition.{0} (finset.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (finset.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_163921 (h0 : ordered_add_comm_monoid (comm_group (boolean_algebra.core ennreal))) : archimedean (comm_group (boolean_algebra.core ennreal)) := sorry --non-trivial
lemma new_lemma_163922 (h0 : group (id (random_gen (random_gen linarith.ineq)))) : group.fg (id (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_163923 (h0 : id (with_bot (random_gen string_imp)) -> id (with_bot (random_gen string_imp)) -> bool) : is_dec_refl h0 := sorry --non-trivial
lemma new_lemma_163924 (h0 : topological_space (complete_semilattice_Sup (random_gen string_imp))) : totally_disconnected_space (complete_semilattice_Sup (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_163925 (h0 : ring (non_unital_non_assoc_semiring enat)) : strong_rank_condition (non_unital_non_assoc_semiring enat) := sorry --non-trivial
lemma new_lemma_163926 (h0 : topological_space (comm_group (has_neg_part num))) : discrete_topology (comm_group (has_neg_part num)) := sorry --non-trivial
lemma new_lemma_163927 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring pos)) unsigned) : @loc_path_connected_space.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_163928 (h0 : topological_space (comm_group (has_neg_part ennreal))) : totally_disconnected_space (comm_group (has_neg_part ennreal)) := sorry --non-trivial
lemma new_lemma_163929 (h0 : functor.add_const (add_monoid (has_zero unsigned)) Type) : @add_monoid.fg.{0} (has_zero.{0} unsigned) (@functor.add_const.run.{0 1} (add_monoid.{0} (has_zero.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_163930 (h0 : topological_space (semigroup (finset (finset linarith.comp)))) : discrete_topology (semigroup (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_163931 (h0 : finset (has_star (semiring num))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_163932 (h0 : uniform_space (has_compl (mul_one_class (mul_one_class fun_info)))) : complete_space (has_compl (mul_one_class (mul_one_class fun_info))) := sorry --non-trivial
lemma new_lemma_163933 (h0 : functor.add_const (group environment.implicit_infer_kind) name) : @normalizer_condition.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 0} (group.{0} environment.implicit_infer_kind) name h0)  := sorry --non-trivial
lemma new_lemma_163934 (h0 : topological_space (add_cancel_monoid (has_neg pos))) : t0_space (add_cancel_monoid (has_neg pos)) := sorry --non-trivial
lemma new_lemma_163935 (h0 : function.extfun Type (functor.comp topological_space has_neg)) : @totally_disconnected_space.{0} (has_neg.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} has_neg.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_163936 (h0 : ring (distrib (mul_one_class (mul_one_class reducibility_hints)))) : strong_rank_condition (distrib (mul_one_class (mul_one_class reducibility_hints))) := sorry --non-trivial
lemma new_lemma_163937 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (linear_ordered_semiring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_163938 (h0 : functor.add_const (function.extfun (Type 1) add_monoid) environment.implicit_infer_kind) : @add_monoid.fg.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) add_monoid.{1}) environment.implicit_infer_kind h0) (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_163939 (h0 : topological_space (has_norm (with_one to_additive.value_type))) : locally_compact_space (has_norm (with_one to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_163940 (h0 : function.extfun Type ring) : @rank_condition.{0} (linear_order.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_163941 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_norm.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_norm.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_163942 (h0 : add_monoid (has_to_string (finset (finset (has_neg (boolean_algebra Type)))))) : add_monoid.fg (has_to_string (finset (finset (has_neg (boolean_algebra Type))))) := sorry --non-trivial
lemma new_lemma_163943 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_monoid_with_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_163944 (h0 : topological_space (has_top (has_nnnorm (has_nnnorm linarith.comp_source)))) : totally_disconnected_space (has_top (has_nnnorm (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_163945 (h0 : not (function.extfun Type group -> false)) : @group.fg.{0} (with_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (with_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_163946 (h0 : not (ring (comm_ring string_imp) -> false)) : @rank_condition.{0} (comm_ring.{0} string_imp) (@classical.by_contradiction'.{1} (ring.{0} (comm_ring.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_163947 (h0 : ordered_comm_monoid (complete_distrib_lattice (has_add name))) : has_exists_mul_of_le (complete_distrib_lattice (has_add name)) := sorry --non-trivial
lemma new_lemma_163948 (h0 : functor.add_const (ring (has_to_string linarith.comp)) environment.implicit_infer_kind) : @is_principal_ideal_ring.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_to_string.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_163949 (h0 : topological_space (linear_ordered_add_comm_group (has_top linarith.ineq))) : t0_space (linear_ordered_add_comm_group (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_163950 (h0 : ring (generalized_boolean_algebra (has_add name))) : is_principal_ideal_ring (generalized_boolean_algebra (has_add name)) := sorry --non-trivial
lemma new_lemma_163951 (h0 : function.extfun (Type 1) topological_space) : @path_connected_space.{1} (normed_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (normed_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_163952 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @loc_path_connected_space.{1} (ordered_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@matrix.vec_empty.{2} (function.extfun.{3 2} (Type 1) topological_space.{1}) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero))) (ordered_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_163953 (h0 : uniform_space (random_gen (has_nnnorm (has_nnnorm linarith.comp_source)))) : complete_space (random_gen (has_nnnorm (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_163954 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem complete_lattice)) : @is_atomistic.{0} (semiring.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) complete_lattice.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_163955 (h0 : ring (linear_order (option empty))) : strong_rank_condition (linear_order (option empty)) := sorry --non-trivial
lemma new_lemma_163956 (h0 : group (ordered_comm_ring pos)) : normalizer_condition (ordered_comm_ring pos) := sorry --non-trivial
lemma new_lemma_163957 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (pseudo_metric_space.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (pseudo_metric_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_163958 (h0 : add_monoid (complete_distrib_lattice (comm_group (comm_group (comm_group Type))))) : add_monoid.fg (complete_distrib_lattice (comm_group (comm_group (comm_group Type)))) := sorry --non-trivial
lemma new_lemma_163959 (h0 : ordered_add_comm_monoid (has_zero Type)) : archimedean (has_zero Type) := sorry --non-trivial
lemma new_lemma_163960 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (linear_ordered_field.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_ordered_field.{0} num))  := sorry --non-trivial
lemma new_lemma_163961 (h0 : topological_space (ordered_comm_monoid (ordered_comm_monoid (has_add (has_Inf Type))))) : locally_compact_space (ordered_comm_monoid (ordered_comm_monoid (has_add (has_Inf Type)))) := sorry --non-trivial
lemma new_lemma_163962 (h1 : not (filter (fintype string_imp) -> false)) : filter.ne_bot (classical.by_contradiction' h1) := sorry --non-trivial
lemma new_lemma_163963 (h0 : list (linear_ordered_add_comm_group complex)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_163964 (h0 : functor.add_const (monoid (plift empty)) unsigned) : @monoid.fg.{1} (plift.{1} empty) (@functor.add_const.run.{1 0} (monoid.{1} (plift.{1} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_163965 (h0 : function.extfun Type (prod (has_inter unsigned))) : id_rel (function.extfun_app h0 (has_inter unsigned)) := sorry --non-trivial
lemma new_lemma_163966 (h0 : uniform_space (mul_zero_class (mul_zero_class name))) : separated_space (mul_zero_class (mul_zero_class name)) := sorry --non-trivial
lemma new_lemma_163967 (h0 : functor.add_const (semiring (add_group empty)) unsigned) : @is_noetherian_ring.{0} (add_group.{0} empty) (@functor.add_const.run.{0 0} (semiring.{0} (add_group.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_163968 (h0 : set (add_comm_semigroup (add_comm_semigroup ereal) -> enat)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_163969 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (ordered_comm_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_163970 (h0 : uniform_space (canonically_ordered_add_monoid (complete_distrib_lattice empty))) : complete_space (canonically_ordered_add_monoid (complete_distrib_lattice empty)) := sorry --non-trivial
lemma new_lemma_163971 (h0 : topological_space (semigroup (option name))) : locally_compact_space (semigroup (option name)) := sorry --non-trivial
lemma new_lemma_163972 (h0 : ring (has_Inf (ring (boolean_algebra.core (has_pos_part (has_neg Type)))))) : is_domain (has_Inf (ring (boolean_algebra.core (has_pos_part (has_neg Type))))) := sorry --non-trivial
lemma new_lemma_163973 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (linear_ordered_comm_ring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_ring.{0} num))  := sorry --non-trivial
lemma new_lemma_163974 (h0 : set (enat -> mul_one_class std_gen)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_163975 (h0 : topological_space (normed_comm_ring pos)) : loc_path_connected_space (normed_comm_ring pos) := sorry --non-trivial
lemma new_lemma_163976 (h0 : topological_space (ordered_comm_ring (has_Inf (has_Inf Type)))) : discrete_topology (ordered_comm_ring (has_Inf (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_163977 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (has_neg.{0} unsigned) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (has_neg.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_163978 (h0 : functor.add_const (topological_space (ring Type)) environment.implicit_infer_kind) : @preconnected_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ring.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_163979 (h0 : topological_space (has_pos_part (has_neg name))) : topological_space.separable_space (has_pos_part (has_neg name)) := sorry --non-trivial
lemma new_lemma_163980 (h0 : has_mem.mem (id linarith.comp) has_emptyc.emptyc) : @totally_disconnected_space.{0} (@id.{2} Type linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (@id.{2} Type linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_163981 (h1 : topological_space (topological_space (mul_one_class to_additive.value_type))) : totally_disconnected_space (topological_space (mul_one_class to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_163982 (h0 : functor.add_const (topological_space (bin_tree congr_arg_kind)) empty) : @path_connected_space.{0} (bin_tree.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (bin_tree.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_163983 (h0 : topological_space (ordered_comm_monoid (has_add pos))) : t1_space (ordered_comm_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_163984 (h1 : add_group (with_one string_imp)) : is_add_cyclic (with_one string_imp) := sorry --non-trivial
lemma new_lemma_163985 (h0 : functor.add_const (ordered_comm_monoid (simple_graph Type)) Type) : @has_exists_mul_of_le.{1} (simple_graph.{1} Type) (@functor.add_const.run.{1 1} (ordered_comm_monoid.{1} (simple_graph.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_163986 (h0 : functor.comp topological_space canonically_ordered_comm_semiring Type) : @path_connected_space.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} canonically_ordered_comm_semiring.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_163987 (h0 : complete_lattice (preorder (semiring num))) : is_atomistic (preorder (semiring num)) := sorry --non-trivial
lemma new_lemma_163988 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @topological_space.separable_space.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_163989 (h0 : topological_space (normed_group (has_inv (random_gen (random_gen linarith.comp_source))))) : t0_space (normed_group (has_inv (random_gen (random_gen linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_163990 (h0 : has_top empty -> has_top empty -> Prop) : transitive h0 := sorry --non-trivial
lemma new_lemma_163991 (h0 : not (topological_space (measure_theory.measure_space congr_arg_kind) -> false)) : @t0_space.{0} (measure_theory.measure_space.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (measure_theory.measure_space.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_163992 (h0 : add_group (measure_theory.measure_space (has_top (has_top empty)))) : is_add_cyclic (measure_theory.measure_space (has_top (has_top empty))) := sorry --non-trivial
lemma new_lemma_163993 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} linarith.comp (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) linarith.comp)  := sorry --non-trivial
lemma new_lemma_163994 (h0 : complete_lattice (has_nndist (normed_comm_ring (has_add (has_add (has_add (has_add pos))))))) : is_compactly_generated (has_nndist (normed_comm_ring (has_add (has_add (has_add (has_add pos)))))) := sorry --non-trivial
lemma new_lemma_163995 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @topological_space.separable_space.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_163996 (h0 : topological_space (boolean_algebra (has_Inf (has_nndist pos)))) : t0_space (boolean_algebra (has_Inf (has_nndist pos))) := sorry --non-trivial
lemma new_lemma_163997 (h0 : functor.add_const (complete_lattice (semigroup empty)) unsigned) : @complete_lattice.is_Sup_finite_compact.{0} (semigroup.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (semigroup.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_163998 (h0 : topological_space (omega_complete_partial_order unsigned)) : normal_space (omega_complete_partial_order unsigned) := sorry --non-trivial
lemma new_lemma_163999 (h0 : complete_lattice (comm_group (comm_group pos))) : complete_lattice.is_Sup_finite_compact (comm_group (comm_group pos)) := sorry --non-trivial
lemma new_lemma_164000 (h0 : ring (partial_order unsigned)) : strong_rank_condition (partial_order unsigned) := sorry --non-trivial
lemma new_lemma_164001 (h0 : functor.add_const (topological_space (has_neg pos)) pos) : @t0_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_164002 (h0 : add_group (non_unital_non_assoc_ring linarith.ineq)) : is_add_cyclic (non_unital_non_assoc_ring linarith.ineq) := sorry --non-trivial
lemma new_lemma_164003 (h0 : functor.add_const (complete_lattice (add_group empty)) empty) : @is_compactly_generated.{0} (add_group.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_group.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_164004 (h0 : std_gen -> std_gen -> Prop) : nonempty (is_strict_order std_gen h0) := sorry --non-trivial
lemma new_lemma_164005 (h0 : function.extfun Type topological_space) : @normal_space.{0} (has_edist.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_edist.{0} empty))  := sorry --non-trivial
lemma new_lemma_164006 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_nndist.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_nndist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_164007 (h0 : topological_space (ring (cancel_monoid (boolean_algebra (boolean_algebra pos))))) : totally_separated_space (ring (cancel_monoid (boolean_algebra (boolean_algebra pos)))) := sorry --non-trivial
lemma new_lemma_164008 (h0 : functor.add_const (group (normed_comm_ring ennreal)) (has_add Type)) : @is_simple_group.{0} (normed_comm_ring.{0} ennreal) (@functor.add_const.run.{0 1} (group.{0} (normed_comm_ring.{0} ennreal)) (has_add.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_164009 (h0 : complete_lattice (semiring (semiring (semiring (has_top num))))) : is_atomistic (semiring (semiring (semiring (has_top num)))) := sorry --non-trivial
lemma new_lemma_164010 (h0 : list (ordered_cancel_add_comm_monoid pos)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_164011 (h0 : topological_space (linear_ordered_semiring (semiring (semiring unsigned)))) : preirreducible_space (linear_ordered_semiring (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_164012 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (ring.{0} name) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (ring.{0} name))  := sorry --non-trivial
lemma new_lemma_164013 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @complete_space.{0} unsigned (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) uniform_space.{0}) unsigned)  := sorry --non-trivial
lemma new_lemma_164014 (h0 : functor.add_const (ordered_comm_monoid (semigroup Type)) Type) : @has_exists_mul_of_le.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 1} (ordered_comm_monoid.{1} (semigroup.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_164015 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (normed_group.{0} linarith.ineq) (@function.extfun_app.{2 1} Type add_group.{0} h0 (normed_group.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_164016 (h0 : uniform_space to_additive.value_type -> Prop) (h1 : unit) : set.finite (matrix.row h0 h1) := sorry --non-trivial
lemma new_lemma_164017 (h0 : ring (ring (has_add environment.implicit_infer_kind))) : strong_rank_condition (ring (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_164018 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_neg_part.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg_part.{0} name))  := sorry --non-trivial
lemma new_lemma_164019 (h2 : group (has_emptyc congr_arg_kind)) : normalizer_condition (has_emptyc congr_arg_kind) := sorry --non-trivial
lemma new_lemma_164020 (h1 : ring (ordered_comm_semiring fun_info)) : rank_condition (ordered_comm_semiring fun_info) := sorry --non-trivial
lemma new_lemma_164021 (h0 : functor.add_const (monoid (normed_comm_ring linarith.comp)) pos) : @monoid.fg.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (monoid.{0} (normed_comm_ring.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_164022 (h0 : cancel_comm_monoid_with_zero (has_compl linarith.ineq)) (h1 : complete_lattice (gcd_monoid (has_compl linarith.ineq))) : is_compactly_generated (gcd_monoid (has_compl linarith.ineq)) := sorry --non-trivial
lemma new_lemma_164023 (h0 : complete_lattice (complete_distrib_lattice (has_add Type))) : is_compactly_generated (complete_distrib_lattice (has_add Type)) := sorry --non-trivial
lemma new_lemma_164024 (h0 : topological_space (has_ssubset (has_top linarith.ineq))) : totally_disconnected_space (has_ssubset (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_164025 (h0 : topological_space (normed_lattice_add_comm_group (has_Inf (has_add real)))) : t0_space (normed_lattice_add_comm_group (has_Inf (has_add real))) := sorry --non-trivial
lemma new_lemma_164026 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (normed_lattice_add_comm_group.{0} pos) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (normed_lattice_add_comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_164027 (h0 : has_le (add_comm_semigroup enat)) (h1 : add_comm_semigroup enat) : is_bot h1 := sorry --non-trivial
lemma new_lemma_164028 (h1 : has_lt (mul_one_class ereal)) : no_max_order (mul_one_class ereal) := sorry --non-trivial
lemma new_lemma_164029 (h0 : functor.add_const (group (ordered_comm_group empty)) empty) : @is_cyclic.{0} (ordered_comm_group.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (ordered_comm_group.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_164030 (h0 : complete_lattice (distrib_lattice (has_nnnorm linarith.ineq))) : is_compactly_generated (distrib_lattice (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_164031 (h0 : complete_lattice (has_neg_part (comm_group (comm_group name)))) : is_compactly_generated (has_neg_part (comm_group (comm_group name))) := sorry --non-trivial
lemma new_lemma_164032 (h0 : add_group (normed_comm_ring (comm_group (comm_group (comm_group name))))) : is_add_cyclic (normed_comm_ring (comm_group (comm_group (comm_group name)))) := sorry --non-trivial
lemma new_lemma_164033 (h0 : metric_space linarith.comp -> empty -> Prop) : relator.bi_total h0 := sorry --non-trivial
lemma new_lemma_164034 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (finset.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (finset.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_164035 (h1 : complete_lattice (fintype to_additive.value_type)) : complete_lattice.is_Sup_finite_compact (fintype to_additive.value_type) := sorry --non-trivial
lemma new_lemma_164036 (h0 : add_left_cancel_semigroup to_additive.value_type -> add_left_cancel_semigroup to_additive.value_type -> Prop) : total h0 := sorry --non-trivial
lemma new_lemma_164037 (h0 : uniform_space (complete_semilattice_Sup (semiring num))) : complete_space (complete_semilattice_Sup (semiring num)) := sorry --non-trivial
lemma new_lemma_164038 (h0 : uniform_space (has_neg_part name)) : separated_space (has_neg_part name) := sorry --non-trivial
lemma new_lemma_164039 (h0 : semiring (measure_theory.measure_space num)) : is_noetherian_ring (measure_theory.measure_space num) := sorry --non-trivial
lemma new_lemma_164040 (h0 : group (ordered_comm_ring real)) : group.fg (ordered_comm_ring real) := sorry --non-trivial
lemma new_lemma_164041 (h0 : not (function.extfun Type list -> false)) : list.nodup (function.extfun_app (classical.by_contradiction' h0) (denumerable linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_164042 (h0 : add_group (ordered_cancel_add_comm_monoid unsigned)) : is_add_cyclic (ordered_cancel_add_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_164043 (h0 : functor.add_const (monoid (add_comm_monoid unsigned)) Type) : @monoid.fg.{0} (add_comm_monoid.{0} unsigned) (@functor.add_const.run.{0 1} (monoid.{0} (add_comm_monoid.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_164044 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (monoid_with_zero.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (monoid_with_zero.{0} num))  := sorry --non-trivial
lemma new_lemma_164045 (h0 : ring (has_ssubset (has_ssubset to_additive.value_type))) : strong_rank_condition (has_ssubset (has_ssubset to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_164046 (h0 : functor.add_const (add_group (canonically_ordered_comm_semiring ennreal)) empty) : @is_add_cyclic.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@functor.add_const.run.{0 0} (add_group.{0} (canonically_ordered_comm_semiring.{0} ennreal)) empty h0)  := sorry --non-trivial
lemma new_lemma_164047 (h0 : topological_space (uniform_space unsigned)) : totally_disconnected_space (uniform_space unsigned) := sorry --non-trivial
lemma new_lemma_164048 (h0 : function.extfun (finset Type) (has_mem.mem (with_bot empty))) : @separated_space.{0} (with_bot.{0} empty) (@finset.pi.empty.{1 0} Type uniform_space.{0} (with_bot.{0} empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_bot.{0} empty)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_164049 (h0 : functor.comp semiring has_neg Type) : @is_noetherian_ring.{1} (has_neg.{1} Type) (@functor.comp.run.{1 1 1} semiring.{1} has_neg.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_164050 (h0 : topological_space (linear_ordered_field (option (option ennreal)))) : discrete_topology (linear_ordered_field (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_164051 (h0 : topological_space (normed_comm_ring Type)) : irreducible_space (normed_comm_ring Type) := sorry --non-trivial
lemma new_lemma_164052 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (has_norm.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} linarith.ineq))))) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_norm.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} linarith.ineq))))))  := sorry --non-trivial
lemma new_lemma_164053 (h0 : ring (plift (add_left_cancel_semigroup unsigned))) : rank_condition (plift (add_left_cancel_semigroup unsigned)) := sorry --non-trivial
lemma new_lemma_164054 (h0 : functor.add_const (group (ring linarith.comp)) Type) : @is_simple_group.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (group.{0} (ring.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_164055 (h0 : topological_space (add_comm_monoid (has_add Type))) : preconnected_space (add_comm_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_164056 (h0 : uniform_space (add_comm_semigroup (semi_normed_comm_ring reducibility_hints))) : complete_space (add_comm_semigroup (semi_normed_comm_ring reducibility_hints)) := sorry --non-trivial
lemma new_lemma_164057 (h0 : group (id (semiring unsigned))) : is_cyclic (id (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_164058 (h0 : topological_space (boolean_algebra unsigned)) : topological_space.separable_space (boolean_algebra unsigned) := sorry --non-trivial
lemma new_lemma_164059 (h0 : group (with_bot (random_gen (with_bot congr_arg_kind)))) : normalizer_condition (with_bot (random_gen (with_bot congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_164060 (h1 : add_group (has_ssubset (random_gen (has_ssubset to_additive.value_type)))) : is_add_cyclic (has_ssubset (random_gen (has_ssubset to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_164061 (h0 : cancel_comm_monoid_with_zero (generalized_boolean_algebra (has_Inf (has_nndist linarith.comp)))) : unique_factorization_monoid (generalized_boolean_algebra (has_Inf (has_nndist linarith.comp))) := sorry --non-trivial
lemma new_lemma_164062 (h0 : functor.add_const (topological_space (semigroup Type)) pos) : @topological_space.separable_space.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (semigroup.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_164063 (h2 : topological_space (distrib (comm_ring to_additive.value_type))) : totally_disconnected_space (distrib (comm_ring to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_164064 (h2 : group (complete_semilattice_Sup (random_gen linarith.ineq))) : normalizer_condition (complete_semilattice_Sup (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_164065 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (has_nndist unsigned)) := sorry --non-trivial
lemma new_lemma_164066 (h0 : not (topological_space (has_sub num) -> false)) : @path_connected_space.{0} (has_sub.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (has_sub.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_164067 (h0 : function.extfun Type (prod (has_neg ennreal))) : id_rel (function.extfun_app h0 (has_neg ennreal)) := sorry --non-trivial
lemma new_lemma_164068 (h0 : functor.add_const (topological_space (has_add linarith.comp)) pos) : @topological_space.separable_space.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_164069 (h0 : functor.add_const (filter (simple_graph Type)) Type) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_164070 (h0 : topological_space (mul_zero_class name)) : topological_space.separable_space (mul_zero_class name) := sorry --non-trivial
lemma new_lemma_164071 (h0 : functor.add_const (functor.add_const (group linarith.comp) linarith.comp) pos) : @is_simple_group.{0} linarith.comp (@functor.add_const.run.{0 0} (group.{0} linarith.comp) linarith.comp (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (group.{0} linarith.comp) linarith.comp) pos h0))  := sorry --non-trivial
lemma new_lemma_164072 (h0 : complete_lattice (random_gen (has_norm num))) : is_atomistic (random_gen (has_norm num)) := sorry --non-trivial
lemma new_lemma_164073 (h0 : topological_space (right_cancel_semigroup linarith.ineq)) : path_connected_space (right_cancel_semigroup linarith.ineq) := sorry --non-trivial
lemma new_lemma_164074 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_164075 (h0 : ordered_add_comm_monoid (ordered_cancel_add_comm_monoid (option (option unsigned)))) : archimedean (ordered_cancel_add_comm_monoid (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_164076 (h0 : topological_space (complete_distrib_lattice (has_add name))) : totally_disconnected_space (complete_distrib_lattice (has_add name)) := sorry --non-trivial
lemma new_lemma_164077 (h0 : filter (has_one (semiring (semiring unsigned)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_164078 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_164079 (h0 : not (ring (set fun_info) -> false)) : @is_domain.{0} (set.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (set.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_164080 (h0 : filter (has_add (add_cancel_monoid (has_neg name)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_164081 (h0 : not (function.extfun Type topological_space -> false)) : @t1_space.{0} (measurable_space.dynkin_system.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (measurable_space.dynkin_system.{0} num))  := sorry --non-trivial
lemma new_lemma_164082 (h0 : add_monoid (simple_graph (ring linarith.comp))) : add_monoid.fg (simple_graph (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_164083 (h0 : complete_lattice (has_neg_part pos)) : complete_lattice.is_Sup_finite_compact (has_neg_part pos) := sorry --non-trivial
lemma new_lemma_164084 (h0 : functor.add_const (list (non_assoc_semiring empty)) (option unsigned)) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_164085 (h0 : list (semigroup (ring linarith.comp))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_164086 (h1 : uniform_space (distrib to_additive.value_type)) : complete_space (distrib to_additive.value_type) := sorry --non-trivial
lemma new_lemma_164087 (h0 : functor.add_const (function.extfun (Type 1) topological_space) name) : @t0_space.{1} (mul_zero_class.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) name h0) (mul_zero_class.{1} Type))  := sorry --non-trivial
lemma new_lemma_164088 (h0 : topological_space (boolean_algebra (has_neg_part Type))) : loc_path_connected_space (boolean_algebra (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_164089 (h0 : functor.comp topological_space has_to_string pos) : @sequential_space.{0} (has_to_string.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} has_to_string.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_164090 (h0 : topological_space (add_comm_monoid pos)) : t1_space (add_comm_monoid pos) := sorry --non-trivial
lemma new_lemma_164091 (h0 : topological_space (normed_comm_ring (option empty))) : normal_space (normed_comm_ring (option empty)) := sorry --non-trivial
lemma new_lemma_164092 (h0 : functor.add_const (topological_space (cancel_monoid unsigned)) pos) : @totally_disconnected_space.{0} (cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_164093 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_dist.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_dist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_164094 (h0 : ring (has_nnnorm (random_gen (has_inv string_imp)))) : is_domain (has_nnnorm (random_gen (has_inv string_imp))) := sorry --non-trivial
lemma new_lemma_164095 (h0 : add_monoid (plift (semiring empty))) : add_monoid.fg (plift (semiring empty)) := sorry --non-trivial
lemma new_lemma_164096 (h0 : group (has_union (semiring unsigned))) : group.fg (has_union (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_164097 (h0 : list (id (random_gen (random_gen string_imp)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_164098 (h0 : topological_space (non_unital_non_assoc_semiring ennreal)) : t0_space (non_unital_non_assoc_semiring ennreal) := sorry --non-trivial
lemma new_lemma_164099 (h0 : function.extfun Type (functor.comp ordered_comm_monoid add_comm_monoid)) : @has_exists_mul_of_le.{0} (add_comm_monoid.{0} unsigned) (@functor.comp.run.{0 0 0} ordered_comm_monoid.{0} add_comm_monoid.{0} unsigned (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} ordered_comm_monoid.{0} add_comm_monoid.{0}) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_164100 (h0 : topological_space (has_to_string (has_add (has_add Type)))) : loc_path_connected_space (has_to_string (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_164101 (h0 : uniform_space (generalized_boolean_algebra (has_Inf pos))) : separated_space (generalized_boolean_algebra (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_164102 (h0 : topological_space (has_add (cancel_monoid pos))) : preconnected_space (has_add (cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_164103 (h0 : ring (add_left_cancel_monoid (has_nnnorm (has_nnnorm (has_nnnorm linarith.ineq))))) : is_domain (add_left_cancel_monoid (has_nnnorm (has_nnnorm (has_nnnorm linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_164104 (h0 : function.extfun Type group) : @is_cyclic.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_164105 (h0 : set (has_div std_gen)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_164106 (h1 : ring (normed_field (metric_space (metric_space (metric_space char))))) : strong_rank_condition (normed_field (metric_space (metric_space (metric_space char)))) := sorry --non-trivial
lemma new_lemma_164107 (h0 : add_group (normed_comm_ring Type)) : is_add_cyclic (normed_comm_ring Type) := sorry --non-trivial
lemma new_lemma_164108 (h0 : complete_lattice (has_to_string pos)) : is_atomistic (has_to_string pos) := sorry --non-trivial
lemma new_lemma_164109 (h0 : functor.add_const (list Type) (has_neg Type)) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_164110 (h0 : filter (semigroup (option pos))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_164111 (h0 : uniform_space (has_inter (option (option (option empty))))) : complete_space (has_inter (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_164112 (h0 : topological_space (ordered_cancel_add_comm_monoid num)) : totally_disconnected_space (ordered_cancel_add_comm_monoid num) := sorry --non-trivial
lemma new_lemma_164113 (h0 : ring (random_gen (mul_one_class (has_nnnorm char)))) : rank_condition (random_gen (mul_one_class (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_164114 (h2 : ring (measurable_space linarith.ineq)) : is_domain (measurable_space linarith.ineq) := sorry --non-trivial
lemma new_lemma_164115 (h0 : functor.add_const (group (is_R_or_C num)) unsigned) : @is_cyclic.{0} (is_R_or_C.{0} num) (@functor.add_const.run.{0 0} (group.{0} (is_R_or_C.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_164116 (h0 : not (topological_space (linear_ordered_semiring linarith.comp) -> false)) : @normal_space.{0} (linear_ordered_semiring.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_semiring.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_164117 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (complete_semilattice_Sup unsigned)) := sorry --non-trivial
lemma new_lemma_164118 (h0 : group (has_nndist pos)) : is_cyclic (has_nndist pos) := sorry --non-trivial
lemma new_lemma_164119 (h0 : ring (has_pos_part (has_pos_part (ring (ring linarith.comp))))) : rank_condition (has_pos_part (has_pos_part (ring (ring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_164120 (h1 : false) : @totally_disconnected_space.{0} (@id.{2} Type empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) (@id.{0} (not (function.extfun.{2 1} Type topological_space.{0} → false)) (λ (h0 : function.extfun.{2 1} Type topological_space.{0} → false), h1))) (@id.{2} Type empty))  := sorry --trivial
lemma new_lemma_164121 (h0 : fin has_zero.zero) : @is_simple_group.{0} (generalized_boolean_algebra.{0} real) (@matrix.vec_empty.{0} (group.{0} (generalized_boolean_algebra.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_164122 (h0 : monoid (ring (add_cancel_monoid (has_to_string Type)))) : monoid.fg (ring (add_cancel_monoid (has_to_string Type))) := sorry --non-trivial
lemma new_lemma_164123 (h0 : topological_space (measure_theory.measure_space empty)) : loc_path_connected_space (measure_theory.measure_space empty) := sorry --non-trivial
lemma new_lemma_164124 (h0 : complete_lattice (has_zero (has_to_string name))) : is_atomistic (has_zero (has_to_string name)) := sorry --non-trivial
lemma new_lemma_164125 (h0 : not (ring (measure_theory.measure_space num) -> false)) : @is_domain.{0} (measure_theory.measure_space.{0} num) (@classical.by_contradiction'.{1} (ring.{0} (measure_theory.measure_space.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_164126 (h3 : uniform_space (has_ssubset linarith.comp_source)) : complete_space (has_ssubset linarith.comp_source) := sorry --non-trivial
lemma new_lemma_164127 (h0 : filter (add_left_cancel_monoid linarith.ineq)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_164128 (h0 : functor.add_const (complete_lattice (has_add Type)) name) : @is_compactly_generated.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (has_add.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_164129 (h0 : functor.add_const (function.extfun Type topological_space) (finset pos)) : @topological_space.separable_space.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (finset.{0} pos) h0) (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_164130 (h0 : functor.add_const (ring (simple_graph Type)) name) : @rank_condition.{1} (simple_graph.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (simple_graph.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_164131 (h0 : option (non_assoc_semiring congr_arg_kind) -> option (non_assoc_semiring congr_arg_kind) -> Prop) : is_strict_order (option (non_assoc_semiring congr_arg_kind)) h0 := sorry --non-trivial
lemma new_lemma_164132 (h0 : topological_space (normed_comm_ring (option (option ennreal)))) : normal_space (normed_comm_ring (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_164133 (h0 : functor.add_const (ordered_add_comm_monoid (boolean_algebra.core linarith.comp)) linarith.comp) : @archimedean.{0} (boolean_algebra.core.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (boolean_algebra.core.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_164134 (h0 : ordered_add_comm_monoid (linear_ordered_field ennreal)) : archimedean (linear_ordered_field ennreal) := sorry --non-trivial
lemma new_lemma_164135 (h0 : measurable_space ereal) (h1 : has_sup ereal) : has_measurable_sup₂ ereal := sorry --non-trivial
lemma new_lemma_164136 (h0 : semiring (semiring (semiring (semiring (semiring (semiring unsigned)))))) : is_noetherian_ring (semiring (semiring (semiring (semiring (semiring unsigned))))) := sorry --non-trivial
lemma new_lemma_164137 (h0 : ring (linear_ordered_add_comm_group (has_norm (random_gen fun_info)))) : is_domain (linear_ordered_add_comm_group (has_norm (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_164138 (h0 : topological_space (comm_group (has_add name))) : irreducible_space (comm_group (has_add name)) := sorry --non-trivial
lemma new_lemma_164139 (h0 : ring (has_Inf (has_add (ring (has_Inf Type))))) : rank_condition (has_Inf (has_add (ring (has_Inf Type)))) := sorry --non-trivial
lemma new_lemma_164140 (h0 : functor.add_const (semiring (add_comm_monoid linarith.comp)) unsigned) : @is_noetherian_ring.{0} (add_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (semiring.{0} (add_comm_monoid.{0} linarith.comp)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_164141 (h0 : uniform_space (free_add_monoid unsigned)) : separated_space (free_add_monoid unsigned) := sorry --non-trivial
lemma new_lemma_164142 (h0 : uniform_space (finset (has_pos_part (normed_comm_ring Type)))) : complete_space (finset (has_pos_part (normed_comm_ring Type))) := sorry --non-trivial
lemma new_lemma_164143 (h0 : functor.add_const (finset (semigroup name)) (has_neg_part (finset Type))) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_164144 (h0 : topological_space (complete_distrib_lattice (sub_neg_monoid (sub_neg_monoid Type)))) : preconnected_space (complete_distrib_lattice (sub_neg_monoid (sub_neg_monoid Type))) := sorry --non-trivial
lemma new_lemma_164145 (h0 : group (measurable_space.dynkin_system unsigned)) : is_cyclic (measurable_space.dynkin_system unsigned) := sorry --non-trivial
lemma new_lemma_164146 (h0 : topological_space (canonically_linear_ordered_monoid (finset real))) : t1_space (canonically_linear_ordered_monoid (finset real)) := sorry --non-trivial
lemma new_lemma_164147 (h0 : functor.add_const (topological_space (ring linarith.comp)) environment.implicit_infer_kind) : @t0_space.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_164148 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_neg_part.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg_part.{0} name))  := sorry --non-trivial
lemma new_lemma_164149 (h0 : topological_space (simple_graph (has_add (has_add linarith.comp)))) : totally_separated_space (simple_graph (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_164150 (h0 : topological_space (semigroup (has_Inf (has_Inf pos)))) : locally_compact_space (semigroup (has_Inf (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_164151 (h0 : group (complete_semilattice_Sup string_imp)) : is_cyclic (complete_semilattice_Sup string_imp) := sorry --non-trivial
lemma new_lemma_164152 (h0 : ring (has_nnnorm (mul_one_class reducibility_hints))) : is_domain (has_nnnorm (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_164153 (h0 : not (function.extfun Type topological_space -> false)) : @irreducible_space.{0} (random_gen.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (random_gen.{0} num))  := sorry --non-trivial
lemma new_lemma_164154 (h0 : not (has_mem.mem (has_norm fun_info) has_emptyc.emptyc -> false)) : @is_cyclic.{0} (has_norm.{0} fun_info) (@finset.pi.empty.{1 0} Type group.{0} (has_norm.{0} fun_info) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_norm.{0} fun_info) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_164155 (h0 : prod (has_zero (has_zero ennreal)) (has_zero (has_zero ennreal))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_164156 (h0 : group (with_bot (measurable_space empty))) : is_cyclic (with_bot (measurable_space empty)) := sorry --non-trivial
lemma new_lemma_164157 (h0 : ring (distrib (has_lt (has_nnnorm char)))) : strong_rank_condition (distrib (has_lt (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_164158 (h0 : functor.add_const (ring (finset pos)) name) : @rank_condition.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (finset.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_164159 (h0 : functor.add_const Prop (complete_distrib_lattice environment.implicit_infer_kind)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_164160 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (canonically_linear_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (canonically_linear_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_164161 (h0 h1 : multiset (semi_normed_ring std_gen)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_164162 (h0 h1 : random_gen num -> random_gen num) : function.commute h0 h1 := sorry --non-trivial
lemma new_lemma_164163 (h0 : topological_space (group_with_zero (option ennreal))) : totally_separated_space (group_with_zero (option ennreal)) := sorry --non-trivial
lemma new_lemma_164164 (h0 : not (finset linarith.comp_source -> false)) (h1 : finset.nonempty (classical.by_contradiction' h0)) (h2 : linarith.comp_source -> Prop) : @finset.sup'.{0 0} Prop linarith.comp_source (@lattice.to_semilattice_sup.{0} Prop (@conditionally_complete_lattice.to_lattice.{0} Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice))) (@classical.by_contradiction'.{1} (finset.{0} linarith.comp_source) h0) h1 h2  := sorry --non-trivial
lemma new_lemma_164165 (h0 : uniform_space (sub_neg_monoid real)) : separated_space (sub_neg_monoid real) := sorry --non-trivial
lemma new_lemma_164166 (h0 : order_hom nat (uniform_space (random_gen fun_info))) : @complete_space.{0} (random_gen.{0} fun_info) (@monotonic_sequence_limit.{0} (uniform_space.{0} (random_gen.{0} fun_info)) (@uniform_space.partial_order.{0} (random_gen.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_164167 (h0 : topological_space (boolean_algebra (semigroup unsigned))) : normal_space (boolean_algebra (semigroup unsigned)) := sorry --non-trivial
lemma new_lemma_164168 (h0 : topological_space (has_nnnorm (mul_one_class string.iterator_imp))) (h1 : preorder (has_nnnorm (mul_one_class string.iterator_imp))) : order_topology (has_nnnorm (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_164169 (h0 : functor.add_const (ring (normed_comm_ring unsigned)) (add_right_cancel_monoid environment.implicit_infer_kind)) : @is_domain.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (normed_comm_ring.{0} unsigned)) (add_right_cancel_monoid.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_164170 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_norm.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_norm.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_164171 (h0 : set (has_compl (mul_one_class char))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_164172 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (preorder.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (preorder.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_164173 (h0 : functor.add_const (filter (has_neg Type)) (has_neg linarith.comp)) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_164174 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (has_emptyc.{0} linarith.ineq) (@function.extfun_app.{2 1} Type monoid.{0} h0 (has_emptyc.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_164175 (h0 : topological_space (random_gen (has_norm congr_arg_kind))) : path_connected_space (random_gen (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_164176 (h0 : function.extfun Type (functor.add_const Prop)) : functor.add_const.run (function.extfun_app h0 (has_neg name)) := sorry --non-trivial
lemma new_lemma_164177 (h0 : group (random_gen (random_gen (random_gen (random_gen linarith.ineq))))) : is_cyclic (random_gen (random_gen (random_gen (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_164178 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (has_nndist num)) := sorry --non-trivial
lemma new_lemma_164179 (h0 : add_monoid (has_nndist (has_add pos))) : add_monoid.fg (has_nndist (has_add pos)) := sorry --non-trivial
lemma new_lemma_164180 (h0 : ring (boolean_algebra (has_add (finset (finset (has_add linarith.comp)))))) : is_domain (boolean_algebra (has_add (finset (finset (has_add linarith.comp))))) := sorry --non-trivial
lemma new_lemma_164181 (h0 : add_group (plift (semiring (semiring (semiring num))))) : is_add_cyclic (plift (semiring (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_164182 (h0 : functor.add_const (topological_space (linear_ordered_comm_monoid_with_zero empty)) empty) : @totally_separated_space.{0} (linear_ordered_comm_monoid_with_zero.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_comm_monoid_with_zero.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_164183 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (random_gen.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (random_gen.{0} empty))  := sorry --non-trivial
lemma new_lemma_164184 (h0 : topological_space (finset (has_neg (ring (mul_one_class (mul_one_class linarith.comp)))))) : discrete_topology (finset (has_neg (ring (mul_one_class (mul_one_class linarith.comp))))) := sorry --non-trivial
lemma new_lemma_164185 (h1 : complete_lattice (random_gen (comm_ring (comm_ring string_imp)))) : complete_lattice.is_Sup_finite_compact (random_gen (comm_ring (comm_ring string_imp))) := sorry --non-trivial
lemma new_lemma_164186 (h0 : function.extfun Type (functor.add_const (topological_space znum))) : @normal_space.{0} znum (@functor.add_const.run.{0 0} (topological_space.{0} znum) congr_arg_kind (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} znum)) h0 congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_164187 (h0 : ring (has_nnnorm (mul_one_class string.iterator_imp))) : is_domain (has_nnnorm (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_164188 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (add_cancel_comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_cancel_comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_164189 (h0 : topological_space (measurable_space (has_inv to_additive.value_type))) : locally_compact_space (measurable_space (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_164190 (h0 : functor.add_const (uniform_space (finset Type)) name) : @separated_space.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (finset.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_164191 (h0 : function.extfun nat fin) : @is_noetherian_ring.{0} (normed_lattice_add_comm_group.{0} name) (@function.extfun_app.{2 1} Type semiring.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type semiring.{0}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (normed_lattice_add_comm_group.{0} name))  := sorry --non-trivial
lemma new_lemma_164192 (h0 : group (boolean_algebra (semigroup Type))) : is_simple_group (boolean_algebra (semigroup Type)) := sorry --non-trivial
lemma new_lemma_164193 (h3 : complete_lattice (simple_graph char)) : complete_lattice.is_Sup_finite_compact (simple_graph char) := sorry --non-trivial
lemma new_lemma_164194 (h0 : group (comm_ring (has_top linarith.comp_source))) : is_cyclic (comm_ring (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_164195 (h0 : function.extfun Type ring) : @rank_condition.{0} (complete_distrib_lattice.{0} (option.{0} ennreal)) (@function.extfun_app.{2 1} Type ring.{0} h0 (complete_distrib_lattice.{0} (option.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_164196 (h0 : functor.add_const (list (has_add Type)) Type) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_164197 (h0 : functor.comp topological_space canonically_ordered_comm_semiring ennreal) : @discrete_topology.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} canonically_ordered_comm_semiring.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_164198 (h0 : not (add_group (fintype char) -> false)) : @is_add_cyclic.{0} (fintype.{0} char) (@classical.by_contradiction'.{1} (add_group.{0} (fintype.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_164199 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @unique_factorization_monoid.{1} (complete_distrib_lattice.{1} Type) (@function.extfun_app.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 cancel_comm_monoid_with_zero.{1}) (complete_distrib_lattice.{1} Type))  := sorry --non-trivial
lemma new_lemma_164200 (h1 : topological_space (add_monoid char)) : path_connected_space (add_monoid char) := sorry --non-trivial
lemma new_lemma_164201 (h0 : ring (has_nndist name)) : strong_rank_condition (has_nndist name) := sorry --non-trivial
lemma new_lemma_164202 (h0 : add_group (encodable (has_nnnorm linarith.comp_source))) : is_add_cyclic (encodable (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_164203 (h0 : filter (has_to_string (finset (has_add (finset Type))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_164204 (h0 : topological_space (comm_monoid (option empty))) : t1_space (comm_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_164205 (h0 : monoid (measurable_space (has_inv (has_inv to_additive.value_type)))) : monoid.fg (measurable_space (has_inv (has_inv to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_164206 (h0 : topological_space (nondiscrete_normed_field (normed_field (normed_field char)))) (h1 : set (nondiscrete_normed_field (normed_field (normed_field char)))) : is_path_connected h1 := sorry --non-trivial
lemma new_lemma_164207 (h0 : group (pseudo_metric_space (cancel_monoid ennreal))) : group.fg (pseudo_metric_space (cancel_monoid ennreal)) := sorry --non-trivial
lemma new_lemma_164208 (h0 : topological_space (has_add (has_top unsigned))) : irreducible_space (has_add (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_164209 (h0 : topological_space (add_comm_monoid (sub_neg_monoid real))) : preirreducible_space (add_comm_monoid (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_164210 (h0 : functor.add_const (ring name) empty) : @is_principal_ideal_ring.{0} name (@functor.add_const.run.{0 0} (ring.{0} name) empty h0)  := sorry --non-trivial
lemma new_lemma_164211 (h0 : semiring (plift (option num))) : is_noetherian_ring (plift (option num)) := sorry --non-trivial
lemma new_lemma_164212 (h0 : add_group (add_group (semiring (semiring empty)))) : is_add_cyclic (add_group (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_164213 (h0 : topological_space (add_group (semiring (option congr_arg_kind)))) : irreducible_space (add_group (semiring (option congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_164214 (h0 : functor.add_const (topological_space (mul_zero_class empty)) num) : @discrete_topology.{0} (mul_zero_class.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_164215 (h0 : functor.add_const (topological_space (add_cancel_monoid name)) (has_neg_part Type)) : @loc_path_connected_space.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (add_cancel_monoid.{0} name)) (has_neg_part.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_164216 (h0 : uniform_space (cancel_monoid (option congr_arg_kind))) : complete_space (cancel_monoid (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_164217 (h0 : function.extfun Type ring) : @is_domain.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_164218 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @preconnected_space.{1} (has_neg_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (has_neg_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_164219 (h0 : complete_lattice (ring (option (option empty)))) : is_compactly_generated (ring (option (option empty))) := sorry --non-trivial
lemma new_lemma_164220 (h0 : topological_space (ring congr_arg_kind)) : discrete_topology (ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_164221 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_compl.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_compl.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_164222 (h0 : topological_space (canonically_ordered_monoid Type)) : locally_compact_space (canonically_ordered_monoid Type) := sorry --non-trivial
lemma new_lemma_164223 (h1 : function.extfun Type topological_space) : @locally_compact_space.{0} (with_one.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (with_one.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_164224 (h0 : functor.comp topological_space normed_comm_ring name) : @locally_compact_space.{0} (normed_comm_ring.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} normed_comm_ring.{0} name h0)  := sorry --non-trivial
lemma new_lemma_164225 (h0 : topological_space (add_cancel_monoid (has_add Type))) : irreducible_space (add_cancel_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_164226 (h0 : filter (linear_ordered_comm_group empty)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_164227 (h1 : ring (linear_ordered_comm_group_with_zero reducibility_hints)) : strong_rank_condition (linear_ordered_comm_group_with_zero reducibility_hints) := sorry --non-trivial
lemma new_lemma_164228 (h0 : filter (boolean_algebra environment.implicit_infer_kind)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_164229 (h0 : function.extfun nat fin) : @monoid.fg.{0} (add_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type monoid.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type monoid.{0}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (add_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_164230 (h0 : ring (has_add (has_Inf Type))) : is_domain (has_add (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_164231 (h0 : functor.add_const (add_monoid (boolean_algebra.core Type)) environment.implicit_infer_kind) : @add_monoid.fg.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (add_monoid.{1} (boolean_algebra.core.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_164232 (h0 : finset (left_cancel_semigroup (semiring (semiring congr_arg_kind)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_164233 (h0 : function.extfun Type ring) : @rank_condition.{0} (distrib_lattice.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} h0 (distrib_lattice.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_164234 (h0 : topological_space (has_neg (has_neg (has_add pos)))) : irreducible_space (has_neg (has_neg (has_add pos))) := sorry --non-trivial
lemma new_lemma_164235 (h0 : filter (normed_comm_ring (option unsigned))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_164236 (h0 : ring (non_unital_non_assoc_semiring to_additive.value_type)) : strong_rank_condition (non_unital_non_assoc_semiring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_164237 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (boolean_algebra.core.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} pos))  := sorry --non-trivial
lemma new_lemma_164238 (h0 : topological_space (uniform_space string.iterator_imp)) : path_connected_space (uniform_space string.iterator_imp) := sorry --non-trivial
lemma new_lemma_164239 (h0 : semiring (partial_order congr_arg_kind)) : is_noetherian_ring (partial_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_164240 (h0 : functor.add_const (add_group (has_pos_part pos)) (has_nndist name)) : @is_add_cyclic.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (has_pos_part.{0} pos)) (has_nndist.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_164241 (h0 : topological_space (has_zero (has_add environment.implicit_infer_kind))) : path_connected_space (has_zero (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_164242 (h0 : list (boolean_algebra (boolean_algebra.core (has_add Type)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_164243 (h0 : monoid (has_nndist unsigned)) : monoid.fg (has_nndist unsigned) := sorry --non-trivial
lemma new_lemma_164244 (h0 : topological_space (has_nndist ennreal)) : sequential_space (has_nndist ennreal) := sorry --non-trivial
lemma new_lemma_164245 (h2 : add_group (mul_one_class ereal)) : is_add_cyclic (mul_one_class ereal) := sorry --non-trivial
lemma new_lemma_164246 (h0 : set (reducibility_hints -> mul_one_class linarith.ineq)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_164247 (h0 : functor.add_const (topological_space (boolean_algebra Type)) environment.implicit_infer_kind) : @loc_path_connected_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_164248 (h0 : complete_lattice (random_gen (has_norm linarith.comp_source))) : is_atomistic (random_gen (has_norm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_164249 (h0 : uniform_space (semigroup congr_arg_kind)) : complete_space (semigroup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_164250 (h0 : group (linear_ordered_comm_group_with_zero to_additive.value_type)) : is_cyclic (linear_ordered_comm_group_with_zero to_additive.value_type) := sorry --non-trivial
lemma new_lemma_164251 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (measurable_space.dynkin_system.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (measurable_space.dynkin_system.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_164252 (h0 : uniform_space (has_star (semiring unsigned))) : complete_space (has_star (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_164253 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @archimedean.{0} (linear_ordered_comm_group.{0} ennreal) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) ordered_add_comm_monoid.{0}) (linear_ordered_comm_group.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_164254 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (filter.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (filter.{0} num))  := sorry --non-trivial
lemma new_lemma_164255 (h0 : not (monoid (measurable_space congr_arg_kind) -> false)) : @monoid.fg.{0} (measurable_space.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (monoid.{0} (measurable_space.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_164256 (h0 : ring (fintype (add_monoid (add_monoid char)))) : rank_condition (fintype (add_monoid (add_monoid char))) := sorry --non-trivial
lemma new_lemma_164257 (h0 : functor.add_const (group (cancel_monoid Type)) Type) : @group.fg.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 1} (group.{1} (cancel_monoid.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_164258 (h0 : group (ordered_comm_ring (has_bot name))) : group.fg (ordered_comm_ring (has_bot name)) := sorry --non-trivial
lemma new_lemma_164259 (h0 : topological_space (div_inv_monoid (has_nnnorm fun_info))) : path_connected_space (div_inv_monoid (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_164260 (h0 : functor.add_const (filter (ring name)) linarith.comp) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_164261 (h0 : list (has_star (semiring (semiring (semiring unsigned))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_164262 (h0 : topological_space (has_norm empty)) : irreducible_space (has_norm empty) := sorry --non-trivial
lemma new_lemma_164263 (h0 : functor.add_const (function.extfun Type list) name) : list.nodup (function.extfun_app (functor.add_const.run h0) (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_164264 (h3 : topological_space enat) : path_connected_space enat := sorry --non-trivial
lemma new_lemma_164265 (h0 : functor.add_const (topological_space (left_cancel_monoid empty)) empty) : @totally_separated_space.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_164266 (h1 : complete_lattice (metric_space linarith.comp)) : complete_lattice.is_Sup_finite_compact (metric_space linarith.comp) := sorry --non-trivial
lemma new_lemma_164267 (h0 : not (complete_lattice (has_norm linarith.ineq) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_norm.{0} linarith.ineq) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_norm.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_164268 (h0 : functor.add_const (filter (normed_comm_ring name)) Type) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_164269 (h2 : complete_lattice (denumerable char)) : is_compactly_generated (denumerable char) := sorry --non-trivial
lemma new_lemma_164270 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (normed_linear_ordered_group.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (normed_linear_ordered_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_164271 (h0 : topological_space (has_div fun_info)) (h1 : add_group (has_div fun_info)) : topological_add_group (has_div fun_info) := sorry --non-trivial
lemma new_lemma_164272 (h0 : function.extfun Type ring) : @is_domain.{0} (has_bot.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_bot.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_164273 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @unique_factorization_monoid.{1} (ordered_comm_ring.{1} Type) (@matrix.vec_empty.{1} (cancel_comm_monoid_with_zero.{1} (ordered_comm_ring.{1} Type)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_164274 (h0 : list (canonically_linear_ordered_monoid ennreal)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_164275 (h0 : set (simple_graph (mul_one_class string.iterator_imp))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_164276 (h0 : topological_space (preorder unsigned)) : t0_space (preorder unsigned) := sorry --non-trivial
lemma new_lemma_164277 (h0 : topological_space (has_pos_part real)) : totally_disconnected_space (has_pos_part real) := sorry --non-trivial
lemma new_lemma_164278 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (cancel_monoid congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_164279 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (semiring.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_164280 (h0 : functor.add_const (list (has_neg_part pos)) (option unsigned)) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_164281 (h0 : not (ring (has_compl string_imp) -> false)) : @rank_condition.{0} (has_compl.{0} string_imp) (@classical.by_contradiction'.{1} (ring.{0} (has_compl.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_164282 (h2 : ring (distrib (has_nnnorm fun_info))) : rank_condition (distrib (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_164283 (h0 : topological_space (cancel_monoid (has_add environment.implicit_infer_kind))) : normal_space (cancel_monoid (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_164284 (h0 : uniform_space (cancel_monoid (complete_distrib_lattice empty))) : separated_space (cancel_monoid (complete_distrib_lattice empty)) := sorry --non-trivial
lemma new_lemma_164285 (h0 : functor.add_const (topological_space (has_dist empty)) congr_arg_kind) : @preirreducible_space.{0} (has_dist.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_dist.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_164286 (h0 : complete_lattice (has_ssubset (comm_ring fun_info))) : is_compactly_generated (has_ssubset (comm_ring fun_info)) := sorry --non-trivial
lemma new_lemma_164287 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_dist unsigned)) empty) : @unique_factorization_monoid.{0} (has_dist.{0} unsigned) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_dist.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_164288 (h0 : ulower pnat) (h1 : with_bot pnat) (h2 : ne h1 has_bot.bot) : pnat.coprime (ulower.up h0) (with_bot.unbot h1 h2) := sorry --non-trivial
lemma new_lemma_164289 (h0 : add_group (has_Inf real)) : is_add_cyclic (has_Inf real) := sorry --non-trivial
lemma new_lemma_164290 (h0 : option (preorder num) -> option (preorder num) -> Prop) : is_strict_order (option (preorder num)) h0 := sorry --non-trivial
lemma new_lemma_164291 (h0 : multiset (has_nnnorm to_additive.value_type)) (h1 : not (multiset (has_nnnorm to_additive.value_type) -> false)) : multiset.disjoint h0 (classical.by_contradiction' h1) := sorry --non-trivial
lemma new_lemma_164292 (h1 : add_group (has_add to_additive.value_type)) : is_add_cyclic (has_add to_additive.value_type) := sorry --non-trivial
lemma new_lemma_164293 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (comm_group.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (comm_group.{0} name))  := sorry --non-trivial
lemma new_lemma_164294 (h0 : uniform_space (id (random_gen (random_gen (random_gen linarith.ineq))))) : complete_space (id (random_gen (random_gen (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_164295 (h1 : group (semi_normed_comm_ring string_imp)) : is_cyclic (semi_normed_comm_ring string_imp) := sorry --non-trivial
lemma new_lemma_164296 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @regular_space.{0} (semigroup.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_164297 (h0 : functor.add_const (function.extfun Type ring) Type) : @strong_rank_condition.{0} (ring.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ring.{0}) Type h0) (ring.{0} name))  := sorry --non-trivial
lemma new_lemma_164298 (h0 : topological_space (uniform_space (distrib reducibility_hints))) : path_connected_space (uniform_space (distrib reducibility_hints)) := sorry --non-trivial
lemma new_lemma_164299 (h0 : set (mul_one_class (normed_field std_gen))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_164300 (h0 : group (normed_group num)) : is_cyclic (normed_group num) := sorry --non-trivial
lemma new_lemma_164301 (h0 : topological_space (ring ennreal)) : irreducible_space (ring ennreal) := sorry --non-trivial
lemma new_lemma_164302 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @totally_disconnected_space.{1} (normed_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (normed_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_164303 (h0 : functor.add_const (topological_space (boolean_algebra name)) Type) : @irreducible_space.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_164304 (h0 : add_monoid (left_cancel_semigroup empty)) (h1 : add_monoid (add_units (left_cancel_semigroup empty))) : add_monoid.fg (add_units (left_cancel_semigroup empty)) := sorry --non-trivial
lemma new_lemma_164305 (h0 : not (function.extfun Type uniform_space -> false)) : @separated_space.{0} (with_bot.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (with_bot.{0} num))  := sorry --non-trivial
lemma new_lemma_164306 (h0 : functor.add_const (ring (boolean_algebra environment.implicit_infer_kind)) unsigned) : @strong_rank_condition.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_164307 (h0 : topological_space (has_ssubset (normed_field (mul_one_class (mul_one_class ereal))))) : totally_disconnected_space (has_ssubset (normed_field (mul_one_class (mul_one_class ereal)))) := sorry --non-trivial
lemma new_lemma_164308 (h0 : ordered_add_comm_monoid (boolean_algebra.core (has_to_string ennreal))) : archimedean (boolean_algebra.core (has_to_string ennreal)) := sorry --non-trivial
lemma new_lemma_164309 (h0 : topological_space (has_add Type)) : preconnected_space (has_add Type) := sorry --non-trivial
lemma new_lemma_164310 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (omega_complete_partial_order.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (omega_complete_partial_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_164311 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (has_add.{0} ennreal) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (has_add.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_164312 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} auto.case_option (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) auto.case_option)  := sorry --non-trivial
lemma new_lemma_164313 (h0 : topological_space (has_pos_part (sub_neg_monoid pos))) : totally_separated_space (has_pos_part (sub_neg_monoid pos)) := sorry --non-trivial
lemma new_lemma_164314 (h0 : topological_space (simple_graph (ring name))) : topological_space.separable_space (simple_graph (ring name)) := sorry --non-trivial
lemma new_lemma_164315 (h0 : not (semiring (add_right_cancel_monoid linarith.comp) -> false)) : @is_noetherian_ring.{0} (add_right_cancel_monoid.{0} linarith.comp) (@classical.by_contradiction'.{1} (semiring.{0} (add_right_cancel_monoid.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_164316 (h0 : functor.add_const (topological_space (measurable_space.dynkin_system unsigned)) congr_arg_kind) : @topological_space.separable_space.{0} (measurable_space.dynkin_system.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (measurable_space.dynkin_system.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_164317 (h0 : function.extfun Type ring) : @rank_condition.{0} (@id.{2} Type empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (@id.{2} Type empty))  := sorry --non-trivial
lemma new_lemma_164318 (h0 : ring (pseudo_metric_space pos)) : strong_rank_condition (pseudo_metric_space pos) := sorry --non-trivial
lemma new_lemma_164319 (h0 : ring (comm_ring (metric_space linarith.comp_source))) : is_domain (comm_ring (metric_space linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_164320 (h0 : filter (has_top (random_gen to_additive.value_type))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_164321 (h0 : filter (add_cancel_monoid (semigroup (comm_group Type)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_164322 (h0 : complete_lattice (with_one (random_gen (random_gen string_imp)))) : is_compactly_generated (with_one (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_164323 (h0 : set (semi_normed_comm_ring std_gen)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_164324 (h0 : not (group (add_group_with_zero_nhd char) -> false)) : @group.fg.{0} (add_group_with_zero_nhd.{0} char) (@classical.by_contradiction'.{1} (group.{0} (add_group_with_zero_nhd.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_164325 (h0 : functor.add_const (topological_space (has_neg_part pos)) name) : @regular_space.{0} (has_neg_part.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_164326 (h0 : group (has_add (has_pos_part (has_Inf linarith.comp)))) : normalizer_condition (has_add (has_pos_part (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_164327 (h0 : functor.add_const (ring (semigroup empty)) congr_arg_kind) : @is_principal_ideal_ring.{0} (semigroup.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (semigroup.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_164328 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (sub_neg_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type semiring.{0} h0 (sub_neg_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_164329 (h0 : ring (power_series to_additive.value_type)) : rank_condition (power_series to_additive.value_type) := sorry --non-trivial
lemma new_lemma_164330 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_neg.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_neg.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_164331 (h0 : functor.add_const (topological_space (ring pos)) name) : @preirreducible_space.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_164332 (h1 : add_group (topological_space (comm_ring char))) : is_add_cyclic (topological_space (comm_ring char)) := sorry --non-trivial
lemma new_lemma_164333 (h0 : ring (complete_distrib_lattice (has_add (has_nndist (has_Inf Type))))) : rank_condition (complete_distrib_lattice (has_add (has_nndist (has_Inf Type)))) := sorry --non-trivial
lemma new_lemma_164334 (h0 : not (has_mem.mem (measurable_space congr_arg_kind) has_emptyc.emptyc -> false)) : @strong_rank_condition.{0} (measurable_space.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type ring.{0} (measurable_space.{0} congr_arg_kind) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (measurable_space.{0} congr_arg_kind) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_164335 (h0 : functor.add_const (function.extfun (Type 1) ordered_add_comm_monoid) name) : @archimedean.{1} (generalized_boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_add_comm_monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ordered_add_comm_monoid.{1}) name h0) (generalized_boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_164336 (h0 : fin has_zero.zero) : @normal_space.{1} (canonically_ordered_comm_semiring.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (canonically_ordered_comm_semiring.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_164337 (h0 : group (boolean_algebra (has_add (has_add environment.implicit_infer_kind)))) : group.fg (boolean_algebra (has_add (has_add environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_164338 (h0 : ring (monoid (option (option congr_arg_kind)))) : strong_rank_condition (monoid (option (option congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_164339 (h0 : finset (mul_zero_class name)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_164340 (h0 : ring (has_le linarith.comp_source)) : strong_rank_condition (has_le linarith.comp_source) := sorry --non-trivial
lemma new_lemma_164341 (h2 : ring (random_gen string_imp)) : is_domain (random_gen string_imp) := sorry --non-trivial
lemma new_lemma_164342 (h0 : function.extfun nat fin) : @is_atomistic.{0} (normed_lattice_add_comm_group.{0} real) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type complete_lattice.{0}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (normed_lattice_add_comm_group.{0} real))  := sorry --non-trivial
lemma new_lemma_164343 (h0 : topological_space (normed_field (mul_one_class ereal))) : totally_disconnected_space (normed_field (mul_one_class ereal)) := sorry --non-trivial
lemma new_lemma_164344 (h0 : topological_space (boolean_algebra.core (mul_zero_class Type))) : normal_space (boolean_algebra.core (mul_zero_class Type)) := sorry --non-trivial
lemma new_lemma_164345 (h0 : topological_space (boolean_algebra environment.implicit_infer_kind)) : loc_path_connected_space (boolean_algebra environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_164346 (h0 : topological_space (ordered_ring (semiring unsigned))) : normal_space (ordered_ring (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_164347 (h0 : functor.comp ring has_add environment.implicit_infer_kind) : @rank_condition.{0} (has_add.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} ring.{0} has_add.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_164348 (h2 : not (has_mem.mem (with_one linarith.comp_source) has_emptyc.emptyc -> false)) : @t0_space.{0} (with_one.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_one.{0} linarith.comp_source) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_one.{0} linarith.comp_source) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h2))  := sorry --non-trivial
lemma new_lemma_164349 (h0 : topological_space (has_add unsigned)) : irreducible_space (has_add unsigned) := sorry --non-trivial
lemma new_lemma_164350 (h2 : set (set linarith.ineq)) (h3 : set linarith.ineq) : measurable_space.dynkin_system.generate_has h2 h3 := sorry --non-trivial
lemma new_lemma_164351 (h0 : functor.add_const (group (add_group num)) unsigned) : @normalizer_condition.{0} (add_group.{0} num) (@functor.add_const.run.{0 0} (group.{0} (add_group.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_164352 (h0 : topological_space (measurable_space (has_norm congr_arg_kind))) : totally_disconnected_space (measurable_space (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_164353 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (comm_ring.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (comm_ring.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_164354 (h0 : topological_space (semi_normed_comm_ring (random_gen string_imp))) : path_connected_space (semi_normed_comm_ring (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_164355 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_164356 (h0 : finset (has_pos_part (has_add (ring name)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_164357 (h0 : functor.add_const (group (ring linarith.comp)) environment.implicit_infer_kind) : @group.fg.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (ring.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_164358 (h0 : add_monoid (linear_ordered_comm_ring (semiring (has_top (has_top congr_arg_kind))))) : add_monoid.fg (linear_ordered_comm_ring (semiring (has_top (has_top congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_164359 (h0 : not (topological_space (has_emptyc linarith.ineq) -> false)) : @locally_compact_space.{0} (has_emptyc.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (has_emptyc.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_164360 (h0 : functor.add_const (ring (has_Inf linarith.comp)) (has_add pos)) : @is_domain.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_Inf.{0} linarith.comp)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_164361 (h0 : topological_space (linear_ordered_field congr_arg_kind)) : locally_compact_space (linear_ordered_field congr_arg_kind) := sorry --non-trivial
lemma new_lemma_164362 (h0 : function.extfun Type topological_space) : @normal_space.{0} (left_cancel_semigroup.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (left_cancel_semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_164363 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (add_group.{0} empty) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (add_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_164364 (h0 : ring (fintype (comm_ring linarith.ineq))) : rank_condition (fintype (comm_ring linarith.ineq)) := sorry --non-trivial
lemma new_lemma_164365 (h1 : ring char) (h2 : set (subring char -> char)) : set.separates_points h2 := sorry --non-trivial
lemma new_lemma_164366 (h0 : filter (with_zero (has_inv fun_info))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_164367 (h0 : group (has_norm (has_top congr_arg_kind))) : normalizer_condition (has_norm (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_164368 (h0 : pnat) (h1 : with_bot pnat) (h2 : ne h1 has_bot.bot) : pnat.coprime h0 (with_bot.unbot h1 h2) := sorry --non-trivial
lemma new_lemma_164369 (h0 : topological_space (ordered_comm_monoid (has_Inf Type))) : totally_separated_space (ordered_comm_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_164370 (h0 : topological_space (ordered_comm_monoid pos)) : normal_space (ordered_comm_monoid pos) := sorry --non-trivial
lemma new_lemma_164371 (h0 : topological_space (add_cancel_comm_monoid (has_nnnorm char))) : totally_disconnected_space (add_cancel_comm_monoid (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_164372 (h0 : topological_space (mul_one_class (mul_one_class std_gen))) : totally_disconnected_space (mul_one_class (mul_one_class std_gen)) := sorry --non-trivial
lemma new_lemma_164373 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (has_norm.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_norm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_164374 (h0 : topological_space (distrib_lattice (random_gen char))) : locally_compact_space (distrib_lattice (random_gen char)) := sorry --non-trivial
lemma new_lemma_164375 (h0 : function.extfun Type topological_space) : @normal_space.{0} (normed_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_164376 (h0 : topological_space (cancel_monoid (option pos))) : t1_space (cancel_monoid (option pos)) := sorry --non-trivial
lemma new_lemma_164377 (h0 : topological_space (finset name)) : path_connected_space (finset name) := sorry --non-trivial
lemma new_lemma_164378 (h0 : topological_space (with_one (semiring linarith.comp))) : irreducible_space (with_one (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_164379 (h1 : linarith.comp_source -> linarith.comp_source -> Prop) (h2 : set linarith.comp_source) : directed_on h1 h2 := sorry --non-trivial
lemma new_lemma_164380 (h0 : topological_space (has_pos_part (has_add linarith.comp))) : sequential_space (has_pos_part (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_164381 (h0 : semiring (has_neg Type)) : is_noetherian_ring (has_neg Type) := sorry --non-trivial
lemma new_lemma_164382 (h0 : functor.comp filter has_to_string environment.implicit_infer_kind) : countable_Inter_filter (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_164383 (h0 : topological_space (comm_group name)) : preirreducible_space (comm_group name) := sorry --non-trivial
lemma new_lemma_164384 (h0 : ordered_add_comm_monoid (has_dist num)) : archimedean (has_dist num) := sorry --non-trivial
lemma new_lemma_164385 (h0 : topological_space (has_Inf (has_neg (has_neg Type)))) : irreducible_space (has_Inf (has_neg (has_neg Type))) := sorry --non-trivial
lemma new_lemma_164386 (h0 : functor.add_const (topological_space (add_group num)) (semiring num)) : @normal_space.{0} (add_group.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (add_group.{0} num)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_164387 (h0 : complete_lattice (has_dist unsigned)) : is_atomistic (has_dist unsigned) := sorry --non-trivial
lemma new_lemma_164388 (h0 : functor.add_const (topological_space (linear_order unsigned)) empty) : @path_connected_space.{0} (linear_order.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_order.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_164389 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (with_one.{0} (comm_ring.{0} to_additive.value_type)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_one.{0} (comm_ring.{0} to_additive.value_type)))  := sorry --non-trivial
lemma new_lemma_164390 (h0 : functor.comp topological_space complete_distrib_lattice name) : @sequential_space.{0} (complete_distrib_lattice.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} complete_distrib_lattice.{0} name h0)  := sorry --non-trivial
lemma new_lemma_164391 (h0 : ring (canonically_linear_ordered_monoid (sub_neg_monoid real))) : rank_condition (canonically_linear_ordered_monoid (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_164392 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @normal_space.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_164393 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (omega_complete_partial_order.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (omega_complete_partial_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_164394 (h0 : semiring (linear_ordered_comm_monoid_with_zero empty)) : is_noetherian_ring (linear_ordered_comm_monoid_with_zero empty) := sorry --non-trivial
lemma new_lemma_164395 (h0 : not (group (metric_space num) -> false)) : @is_cyclic.{0} (metric_space.{0} num) (@classical.by_contradiction'.{1} (group.{0} (metric_space.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_164396 (h0 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} (has_star.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h0) (has_star.{0} empty))  := sorry --non-trivial
lemma new_lemma_164397 (h0 : not (topological_space (add_cancel_comm_monoid char) -> false)) : @path_connected_space.{0} (add_cancel_comm_monoid.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (add_cancel_comm_monoid.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_164398 (h0 : functor.add_const (topological_space (has_neg pos)) linarith.comp) : @totally_disconnected_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_164399 (h0 : topological_space (with_one (random_gen (with_bot to_additive.value_type)))) : irreducible_space (with_one (random_gen (with_bot to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_164400 (h0 : topological_space (ordered_ring (semiring empty))) : path_connected_space (ordered_ring (semiring empty)) := sorry --non-trivial
lemma new_lemma_164401 (h0 : ring (topological_space (has_ssubset (has_ssubset (has_ssubset linarith.ineq))))) : is_domain (topological_space (has_ssubset (has_ssubset (has_ssubset linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_164402 (h0 : not (function.extfun Type topological_space -> false)) : @normal_space.{0} (linear_ordered_semiring.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (linear_ordered_semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_164403 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (non_assoc_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (non_assoc_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_164404 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @discrete_topology.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) topological_space.{0}) (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_164405 (h0 : not (uniform_space (has_nndist unsigned) -> false)) : @complete_space.{0} (has_nndist.{0} unsigned) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_nndist.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_164406 (h2 : topological_space (add_comm_semigroup std_gen)) (h3 : preorder (add_comm_semigroup std_gen)) : order_closed_topology (add_comm_semigroup std_gen) := sorry --non-trivial
lemma new_lemma_164407 (h0 : ordered_comm_monoid (finset ennreal)) : has_exists_mul_of_le (finset ennreal) := sorry --non-trivial
lemma new_lemma_164408 (h1 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (measurable_space.{0} num) (@function.extfun_app.{2 1} Type add_monoid.{0} h1 (measurable_space.{0} num))  := sorry --non-trivial
lemma new_lemma_164409 (h0 : complete_lattice (boolean_algebra.core name)) : is_atomistic (boolean_algebra.core name) := sorry --non-trivial
lemma new_lemma_164410 (h0 : group (distrib_lattice (has_inv (has_inv (has_inv linarith.comp_source))))) : is_cyclic (distrib_lattice (has_inv (has_inv (has_inv linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_164411 (h0 : functor.add_const (complete_lattice (left_cancel_monoid empty)) empty) : @complete_lattice.is_Sup_finite_compact.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (left_cancel_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_164412 (h1 : topological_space (uniform_space linarith.comp_source)) : path_connected_space (uniform_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_164413 (h0 : topological_space (has_compl (mul_one_class (mul_one_class string.iterator_imp)))) (h1 : preorder (has_compl (mul_one_class (mul_one_class string.iterator_imp)))) : order_topology (has_compl (mul_one_class (mul_one_class string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_164414 (h0 : ring (has_bot (option empty))) : rank_condition (has_bot (option empty)) := sorry --non-trivial
lemma new_lemma_164415 (h0 : topological_space (ordered_comm_monoid Type)) : path_connected_space (ordered_comm_monoid Type) := sorry --non-trivial
lemma new_lemma_164416 (h0 : has_neg (add_comm_semigroup fun_info)) (h1 : measurable_space (add_comm_semigroup fun_info)) : has_measurable_neg (add_comm_semigroup fun_info) := sorry --non-trivial
lemma new_lemma_164417 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (preorder.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (preorder.{0} empty))  := sorry --non-trivial
lemma new_lemma_164418 (h0 : functor.add_const (topological_space (linear_ordered_comm_monoid_with_zero unsigned)) (option empty)) : @irreducible_space.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_164419 (h0 : complete_lattice (has_Inf (has_neg real))) : is_compactly_generated (has_Inf (has_neg real)) := sorry --non-trivial
lemma new_lemma_164420 (h0 : semiring (normed_comm_ring (has_neg_part unsigned))) : is_noetherian_ring (normed_comm_ring (has_neg_part unsigned)) := sorry --non-trivial
lemma new_lemma_164421 (h0 : list (boolean_algebra.core (option (option (option ennreal))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_164422 (h0 : topological_space (has_Inf (has_add linarith.comp))) : regular_space (has_Inf (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_164423 (h0 : add_group (add_comm_semigroup enat)) : is_add_cyclic (add_comm_semigroup enat) := sorry --non-trivial
lemma new_lemma_164424 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_bot.{0} pos) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_bot.{0} pos))  := sorry --non-trivial
lemma new_lemma_164425 (h0 : topological_space (has_neg (has_Inf (has_add (metric_space (has_pos_part Type)))))) : irreducible_space (has_neg (has_Inf (has_add (metric_space (has_pos_part Type))))) := sorry --non-trivial
lemma new_lemma_164426 (h0 : has_add (random_gen string_imp)) (h1 : complete_lattice (add_con (random_gen string_imp))) : is_compactly_generated (add_con (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_164427 (h0 : function.extfun (Type 1) ring) : @strong_rank_condition.{1} (plift.{1} unsigned) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (plift.{1} unsigned))  := sorry --non-trivial
lemma new_lemma_164428 (h0 : functor.add_const (topological_space environment.implicit_infer_kind) (boolean_algebra Type)) : @normal_space.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 1} (topological_space.{0} environment.implicit_infer_kind) (boolean_algebra.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_164429 (h0 : complete_lattice (omega_complete_partial_order (omega_complete_partial_order unsigned))) : is_atomistic (omega_complete_partial_order (omega_complete_partial_order unsigned)) := sorry --non-trivial
lemma new_lemma_164430 (h0 : topological_space (generalized_boolean_algebra (boolean_algebra.core (has_neg name)))) : regular_space (generalized_boolean_algebra (boolean_algebra.core (has_neg name))) := sorry --non-trivial
lemma new_lemma_164431 (h0 : group (ring (boolean_algebra Type))) : is_simple_group (ring (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_164432 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (has_norm.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_norm.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_164433 (h0 : topological_space (ordered_comm_monoid real)) : totally_separated_space (ordered_comm_monoid real) := sorry --non-trivial
lemma new_lemma_164434 (h0 : complete_lattice (measure_theory.measure_space (semiring (semiring unsigned)))) : complete_lattice.is_Sup_finite_compact (measure_theory.measure_space (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_164435 (h0 : topological_space (ring ennreal)) : preconnected_space (ring ennreal) := sorry --non-trivial
lemma new_lemma_164436 (h0 : semiring (has_Inf (sub_neg_monoid (sub_neg_monoid Type)))) : is_noetherian_ring (has_Inf (sub_neg_monoid (sub_neg_monoid Type))) := sorry --non-trivial
lemma new_lemma_164437 (h0 : string.iterator_imp -> Prop) (h1 : string.iterator_imp) : set_of h0 h1 := sorry --non-trivial
lemma new_lemma_164438 (h0 : uniform_space (has_nndist (has_neg environment.implicit_infer_kind))) : complete_space (has_nndist (has_neg environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_164439 (h0 : has_mem.mem (semi_normed_comm_ring linarith.ineq) has_zero.zero) : @strong_rank_condition.{0} (semi_normed_comm_ring.{0} linarith.ineq) (@multiset.pi.empty.{1 0} Type ring.{0} (semi_normed_comm_ring.{0} linarith.ineq) h0)  := sorry --non-trivial
lemma new_lemma_164440 (h0 : not (topological_space (has_union unsigned) -> false)) : @irreducible_space.{0} (has_union.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (has_union.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_164441 (h0 : fin has_zero.zero) : @preirreducible_space.{0} (has_add.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (has_add.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_164442 (h0 : functor.add_const (function.extfun (Type 1) topological_space) environment.implicit_infer_kind) : @irreducible_space.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) environment.implicit_infer_kind h0) (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_164443 (h0 : function.extfun (Type 1) topological_space) : @t1_space.{1} Type (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 Type)  := sorry --non-trivial
lemma new_lemma_164444 (h0 : functor.add_const (group (canonically_ordered_comm_semiring name)) name) : @is_cyclic.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.add_const.run.{0 0} (group.{0} (canonically_ordered_comm_semiring.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_164445 (h0 : functor.add_const (complete_lattice (has_nndist linarith.comp)) linarith.comp) : @complete_lattice.is_Sup_finite_compact.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_nndist.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_164446 (h0 : functor.add_const (function.extfun (Type 1) ring) ennreal) : @is_domain.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ring.{1}) ennreal h0) (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_164447 (h0 : topological_space (semigroup pos)) : t1_space (semigroup pos) := sorry --non-trivial
lemma new_lemma_164448 (h0 : list (has_zero (has_add name))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_164449 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} auto.case_option (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) auto.case_option)  := sorry --non-trivial
lemma new_lemma_164450 (h0 : topological_space (ordered_cancel_add_comm_monoid (option (option empty)))) : preirreducible_space (ordered_cancel_add_comm_monoid (option (option empty))) := sorry --non-trivial
lemma new_lemma_164451 (h0 : functor.add_const (function.extfun (Type 1) group) (normed_comm_ring (finset (normed_comm_ring pos)))) : @group.fg.{1} Type (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) group.{1}) (normed_comm_ring.{0} (finset.{0} (normed_comm_ring.{0} pos))) h0) Type)  := sorry --non-trivial
lemma new_lemma_164452 (h0 : uniform_space (simple_graph (has_neg linarith.comp))) : complete_space (simple_graph (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_164453 (h0 : group (boolean_algebra (has_bot (sub_neg_monoid (has_Inf Type))))) : is_cyclic (boolean_algebra (has_bot (sub_neg_monoid (has_Inf Type)))) := sorry --non-trivial
lemma new_lemma_164454 (h0 : topological_space (add_cancel_monoid (option (option name)))) : sequential_space (add_cancel_monoid (option (option name))) := sorry --non-trivial
lemma new_lemma_164455 (h0 : ordered_add_comm_monoid (has_nndist Type)) : archimedean (has_nndist Type) := sorry --non-trivial
lemma new_lemma_164456 (h1 : topological_space (denumerable (random_gen (has_Sup string_imp)))) : path_connected_space (denumerable (random_gen (has_Sup string_imp))) := sorry --non-trivial
lemma new_lemma_164457 (h0 : functor.add_const (topological_space (boolean_algebra.core pos)) ennreal) : @totally_disconnected_space.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} pos)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_164458 (h0 : topological_space (denumerable char)) : path_connected_space (denumerable char) := sorry --non-trivial
lemma new_lemma_164459 (h0 : topological_space (finset (has_Inf pos))) : preirreducible_space (finset (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_164460 (h0 : functor.add_const (monoid (left_cancel_monoid num)) empty) : @monoid.fg.{0} (left_cancel_monoid.{0} num) (@functor.add_const.run.{0 0} (monoid.{0} (left_cancel_monoid.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_164461 (h0 : topological_space (add_left_cancel_semigroup num)) : irreducible_space (add_left_cancel_semigroup num) := sorry --non-trivial
lemma new_lemma_164462 (h0 : finset (has_neg (has_neg name))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_164463 (h0 : topological_space (has_Inf (has_neg Type))) : totally_disconnected_space (has_Inf (has_neg Type)) := sorry --non-trivial
lemma new_lemma_164464 (h0 : functor.add_const (ordered_comm_monoid (semigroup linarith.comp)) name) : @has_exists_mul_of_le.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (semigroup.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_164465 (h0 : ring (complete_distrib_lattice (finset (finset (finset Type))))) : is_domain (complete_distrib_lattice (finset (finset (finset Type)))) := sorry --non-trivial
lemma new_lemma_164466 (h0 : set (set (mul_one_class string.iterator_imp))) (h1 : set (mul_one_class string.iterator_imp)) : filter.generate_sets h0 h1 := sorry --non-trivial
lemma new_lemma_164467 (h0 : topological_space char) (h1 : add_comm_semigroup char -> set char) : locally_finite h1 := sorry --non-trivial
lemma new_lemma_164468 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @monoid.fg.{0} (has_top.{0} linarith.ineq) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) monoid.{0}) (has_top.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_164469 (h0 : functor.add_const (complete_lattice (complete_distrib_lattice pos)) pos) : @is_atomistic.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (complete_distrib_lattice.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_164470 (h0 : has_scalar (mul_one_class fun_info) (mul_one_class linarith.comp_source)) : has_faithful_scalar (mul_one_class fun_info) (mul_one_class linarith.comp_source) := sorry --non-trivial
lemma new_lemma_164471 (h0 : ring (complete_distrib_lattice (option (option (option (option (option empty))))))) : strong_rank_condition (complete_distrib_lattice (option (option (option (option (option empty)))))) := sorry --non-trivial
lemma new_lemma_164472 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (has_top.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_top.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_164473 (h0 : not (function.extfun Type monoid -> false)) : @monoid.fg.{0} (with_bot.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} unsigned)))))) (@function.extfun_app.{2 1} Type monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type monoid.{0}) h0) (with_bot.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} unsigned)))))))  := sorry --non-trivial
lemma new_lemma_164474 (h0 : functor.add_const (ring (semigroup Type)) name) : @strong_rank_condition.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (semigroup.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_164475 (h3 : set (fun_info -> linarith.ineq)) : set.separates_points h3 := sorry --non-trivial
lemma new_lemma_164476 (h0 : ring (normed_field (has_compl (distrib char)))) : strong_rank_condition (normed_field (has_compl (distrib char))) := sorry --non-trivial
lemma new_lemma_164477 (h0 : add_monoid (has_nndist (has_neg_part pos))) : add_monoid.fg (has_nndist (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_164478 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (fintype.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type add_group.{0} h0 (fintype.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_164479 (h1 : filter (dlist (random_gen string_imp))) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_164480 (h0 : complete_lattice (random_gen (has_inv linarith.ineq))) : is_compactly_generated (random_gen (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_164481 (h1 : not (function.extfun Type monoid -> false)) : @monoid.fg.{0} (semiring.{0} fun_info) (@function.extfun_app.{2 1} Type monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type monoid.{0}) h1) (semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_164482 (h0 : topological_space (has_to_string environment.implicit_infer_kind)) : t0_space (has_to_string environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_164483 (h0 : functor.add_const (group (mul_zero_class Type)) pos) : @is_simple_group.{1} (mul_zero_class.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (mul_zero_class.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_164484 (h1 : topological_space ereal) : t0_space ereal := sorry --non-trivial
lemma new_lemma_164485 (h0 : filter (semigroup (has_Inf (has_add pos)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_164486 (h0 : uniform_space (ordered_cancel_add_comm_monoid empty)) : separated_space (ordered_cancel_add_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_164487 (h0 : monoid (ordered_comm_monoid (has_Inf (sub_neg_monoid real)))) : monoid.fg (ordered_comm_monoid (has_Inf (sub_neg_monoid real))) := sorry --non-trivial
lemma new_lemma_164488 (h0 : complete_lattice (uniform_space (random_gen reducibility_hints))) : is_compactly_generated (uniform_space (random_gen reducibility_hints)) := sorry --non-trivial
lemma new_lemma_164489 (h0 : functor.add_const (complete_lattice (left_cancel_monoid unsigned)) unsigned) : @complete_lattice.is_Sup_finite_compact.{0} (left_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (left_cancel_monoid.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_164490 (h0 : complete_lattice (with_bot (has_top fun_info))) : complete_lattice.is_Sup_finite_compact (with_bot (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_164491 (h0 : uniform_space (denumerable fun_info)) : complete_space (denumerable fun_info) := sorry --non-trivial
lemma new_lemma_164492 (h0 : option (topological_space (has_bot unsigned))) (h1 : topological_space (has_bot unsigned)) : totally_disconnected_space (has_bot unsigned) := sorry --non-trivial
lemma new_lemma_164493 (h0 : topological_space (has_one (metric_space (has_norm congr_arg_kind)))) : preirreducible_space (has_one (metric_space (has_norm congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_164494 (h0 : filter (has_well_founded ennreal)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_164495 (h0 : functor.add_const (topological_space (has_neg_part environment.implicit_infer_kind)) linarith.comp) : @topological_space.separable_space.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_164496 (h0 : function.extfun Type (functor.add_const (cancel_comm_monoid_with_zero pos))) : @unique_factorization_monoid.{0} pos (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} pos) pos (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (cancel_comm_monoid_with_zero.{0} pos)) h0 pos))  := sorry --non-trivial
lemma new_lemma_164497 (h0 : topological_space (monoid_with_zero ennreal)) : normal_space (monoid_with_zero ennreal) := sorry --non-trivial
lemma new_lemma_164498 (h0 : functor.add_const (list (has_neg_part name)) (boolean_algebra environment.implicit_infer_kind)) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_164499 (h0 : filter (measurable_space (has_norm linarith.comp))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_164500 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (has_top.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (has_top.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_164501 (h0 : group (has_nndist (finset linarith.comp))) : group.fg (has_nndist (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_164502 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_to_string linarith.comp)) linarith.comp) : @unique_factorization_monoid.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_to_string.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_164503 (h0 : complete_lattice (plift (option empty))) : is_atomistic (plift (option empty)) := sorry --non-trivial
lemma new_lemma_164504 (h0 : functor.add_const (topological_space (semiring congr_arg_kind)) congr_arg_kind) : @totally_disconnected_space.{0} (semiring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (semiring.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_164505 (h0 : topological_space (linear_ordered_add_comm_group (random_gen (random_gen char)))) : t0_space (linear_ordered_add_comm_group (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_164506 (h0 : complete_lattice (has_zero (has_add (has_add Type)))) : complete_lattice.is_Sup_finite_compact (has_zero (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_164507 (h0 : functor.add_const (topological_space (has_add pos)) (comm_group Type)) : @topological_space.separable_space.{0} (has_add.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_add.{0} pos)) (comm_group.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_164508 (h0 : topological_space (mul_one_class (add_comm_semigroup enat))) : path_connected_space (mul_one_class (add_comm_semigroup enat)) := sorry --non-trivial
lemma new_lemma_164509 (h0 : not (cancel_comm_monoid_with_zero (partial_order unsigned) -> false)) : @unique_factorization_monoid.{0} (partial_order.{0} unsigned) (@classical.by_contradiction'.{1} (cancel_comm_monoid_with_zero.{0} (partial_order.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_164510 (h0 : has_mem.mem (normed_group congr_arg_kind) has_emptyc.emptyc) : @totally_separated_space.{0} (normed_group.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (normed_group.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_164511 (h0 : functor.add_const (add_monoid (ordered_comm_ring real)) Type) : @add_monoid.fg.{0} (ordered_comm_ring.{0} real) (@functor.add_const.run.{0 1} (add_monoid.{0} (ordered_comm_ring.{0} real)) Type h0)  := sorry --non-trivial
lemma new_lemma_164512 (h0 : topological_space (finset (ring pos))) : locally_compact_space (finset (ring pos)) := sorry --non-trivial
lemma new_lemma_164513 (h0 : group (has_ssubset (has_top (has_nnnorm fun_info)))) : group.fg (has_ssubset (has_top (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_164514 (h0 : group (mul_zero_class (semiring (semiring (semiring num))))) : group.fg (mul_zero_class (semiring (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_164515 (h0 : function.extfun nat fin) : @normal_space.{0} (sub_neg_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (sub_neg_monoid.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_164516 (h0 : functor.add_const (topological_space (partial_order empty)) num) : @irreducible_space.{0} (partial_order.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (partial_order.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_164517 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_164518 (h0 : has_lt (has_lt (mul_one_class to_additive.value_type))) : no_max_order (has_lt (mul_one_class to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_164519 (h0 : not (topological_space (distrib to_additive.value_type) -> false)) : @path_connected_space.{0} (distrib.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (distrib.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_164520 (h0 : add_group (random_gen num)) : is_add_cyclic (random_gen num) := sorry --non-trivial
lemma new_lemma_164521 (h0 : add_monoid (has_Inf (ring pos))) : add_monoid.fg (has_Inf (ring pos)) := sorry --non-trivial
lemma new_lemma_164522 (h0 : functor.add_const (complete_lattice (cancel_monoid unsigned)) unsigned) : @is_atomistic.{0} (cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (cancel_monoid.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_164523 (h0 : not (uniform_space (with_one linarith.ineq) -> false)) : @complete_space.{0} (with_one.{0} linarith.ineq) (@classical.by_contradiction'.{1} (uniform_space.{0} (with_one.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_164524 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (normed_group.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_group.{0} num))  := sorry --non-trivial
lemma new_lemma_164525 (h0 : functor.add_const (topological_space (comm_group name)) pos) : @sequential_space.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_164526 (h0 : topological_space (add_cancel_monoid (option congr_arg_kind))) : discrete_topology (add_cancel_monoid (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_164527 (h0 : uniform_space (ring (option (option pos)))) : complete_space (ring (option (option pos))) := sorry --non-trivial
lemma new_lemma_164528 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : is_atomistic (measurable_space linarith.ineq) := sorry --non-trivial
lemma new_lemma_164529 (h0 : group (has_dist (option num))) : normalizer_condition (has_dist (option num)) := sorry --non-trivial
lemma new_lemma_164530 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (generalized_boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (generalized_boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_164531 (h0 : group (boolean_algebra (finset Type))) : is_cyclic (boolean_algebra (finset Type)) := sorry --non-trivial
lemma new_lemma_164532 (h0 : list (ring (ring pos))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_164533 (h0 : functor.add_const (monoid (add_group num)) (semiring (semiring (semiring num)))) : @monoid.fg.{0} (add_group.{0} num) (@functor.add_const.run.{0 0} (monoid.{0} (add_group.{0} num)) (semiring.{0} (semiring.{0} (semiring.{0} num))) h0)  := sorry --non-trivial
lemma new_lemma_164534 (h0 : complete_lattice (semi_normed_comm_ring string.iterator_imp)) : complete_lattice.is_Sup_finite_compact (semi_normed_comm_ring string.iterator_imp) := sorry --non-trivial
lemma new_lemma_164535 (h0 : not (has_mem.mem (has_top fun_info) has_emptyc.emptyc -> false)) : @rank_condition.{0} (has_top.{0} fun_info) (@finset.pi.empty.{1 0} Type ring.{0} (has_top.{0} fun_info) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_top.{0} fun_info) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_164536 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (monoid_with_zero.{0} ennreal) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (monoid_with_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_164537 (h0 : ring (monoid (option (option (option (option pos)))))) : is_principal_ideal_ring (monoid (option (option (option (option pos))))) := sorry --non-trivial
lemma new_lemma_164538 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_164539 (h0 : topological_space (ring (has_add (ring Type)))) : topological_space.separable_space (ring (has_add (ring Type))) := sorry --non-trivial
lemma new_lemma_164540 (h1 : not (topological_space (random_gen string_imp) -> false)) : @path_connected_space.{0} (random_gen.{0} string_imp) (@classical.by_contradiction'.{1} (topological_space.{0} (random_gen.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_164541 (h0 : add_monoid (boolean_algebra (ring pos))) : add_monoid.fg (boolean_algebra (ring pos)) := sorry --non-trivial
lemma new_lemma_164542 (h0 : complete_lattice (has_neg_part (boolean_algebra.core Type))) : is_compactly_generated (has_neg_part (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_164543 (h0 : not (function.extfun Type topological_space -> false)) : @normal_space.{0} (normed_group.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (normed_group.{0} num))  := sorry --non-trivial
lemma new_lemma_164544 (h0 : finset (has_neg (has_nndist (finset environment.implicit_infer_kind)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_164545 (h0 : topological_space (boolean_algebra (has_Inf real))) : preirreducible_space (boolean_algebra (has_Inf real)) := sorry --non-trivial
lemma new_lemma_164546 (h0 : not (topological_space (semi_normed_ring linarith.ineq) -> false)) : @path_connected_space.{0} (semi_normed_ring.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (semi_normed_ring.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_164547 (h0 : functor.add_const (filter (has_add environment.implicit_infer_kind)) pos) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_164548 (h0 : monoid (has_star congr_arg_kind)) : monoid.fg (has_star congr_arg_kind) := sorry --non-trivial
lemma new_lemma_164549 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (normed_group.{0} (semiring.{0} (semiring.{0} linarith.comp))) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_group.{0} (semiring.{0} (semiring.{0} linarith.comp))))  := sorry --non-trivial
lemma new_lemma_164550 (h0 : has_lt (has_lt (mul_one_class fun_info))) : no_max_order (has_lt (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_164551 (h0 : monoid (has_inter congr_arg_kind)) : monoid.fg (has_inter congr_arg_kind) := sorry --non-trivial
lemma new_lemma_164552 (h0 : filter (has_neg_part (option (option ennreal)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_164553 (h0 : functor.add_const (add_group (simple_graph empty)) unsigned) : @is_add_cyclic.{0} (simple_graph.{0} empty) (@functor.add_const.run.{0 0} (add_group.{0} (simple_graph.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_164554 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_neg.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} h0 (has_neg.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_164555 (h0 : functor.add_const (add_monoid (left_cancel_monoid num)) unsigned) : @add_monoid.fg.{0} (left_cancel_monoid.{0} num) (@functor.add_const.run.{0 0} (add_monoid.{0} (left_cancel_monoid.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_164556 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (canonically_ordered_add_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_ordered_add_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_164557 (h0 : topological_space (linear_ordered_comm_group (option pos))) : totally_separated_space (linear_ordered_comm_group (option pos)) := sorry --non-trivial
lemma new_lemma_164558 (h0 : ring (complete_distrib_lattice (comm_group name))) : rank_condition (complete_distrib_lattice (comm_group name)) := sorry --non-trivial
lemma new_lemma_164559 (h4 : set reducibility_hints) : set.finite h4 := sorry --non-trivial
lemma new_lemma_164560 (h0 : function.extfun (finset Type) (has_mem.mem (has_top linarith.comp_source))) : @strong_rank_condition.{0} (has_top.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type ring.{0} (has_top.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_top.{0} linarith.comp_source)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_164561 (h0 : topological_space (semigroup (has_neg Type))) : normal_space (semigroup (has_neg Type)) := sorry --non-trivial
lemma new_lemma_164562 (h0 : topological_space (has_ssubset (comm_ring char))) : t0_space (has_ssubset (comm_ring char)) := sorry --non-trivial
lemma new_lemma_164563 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (boolean_algebra.core.{0} unsigned) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (boolean_algebra.core.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_164564 (h0 : semiring (normed_lattice_add_comm_group (ordered_comm_monoid real))) : is_noetherian_ring (normed_lattice_add_comm_group (ordered_comm_monoid real)) := sorry --non-trivial
lemma new_lemma_164565 (h1 : monoid (with_one num)) : monoid.fg (with_one num) := sorry --non-trivial
lemma new_lemma_164566 (h0 : not (complete_lattice (add_cancel_comm_monoid char) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (add_cancel_comm_monoid.{0} char) (@classical.by_contradiction'.{1} (complete_lattice.{0} (add_cancel_comm_monoid.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_164567 (h0 : topological_space (has_dist (option num))) : preconnected_space (has_dist (option num)) := sorry --non-trivial
lemma new_lemma_164568 (h1 : group (add_cancel_comm_monoid reducibility_hints)) : is_cyclic (add_cancel_comm_monoid reducibility_hints) := sorry --non-trivial
lemma new_lemma_164569 (h0 : group (semi_normed_comm_ring (has_nnnorm char))) : group.fg (semi_normed_comm_ring (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_164570 (h1 : ring (uniform_space linarith.comp_source)) : rank_condition (uniform_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_164571 (h0 : functor.add_const (complete_lattice (has_Inf Type)) pos) : @complete_lattice.is_Sup_finite_compact.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (has_Inf.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_164572 (h0 : semiring congr_arg_kind) : is_noetherian_ring congr_arg_kind := sorry --non-trivial
lemma new_lemma_164573 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @is_domain.{0} (is_R_or_C.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) ring.{0}) (is_R_or_C.{0} empty))  := sorry --non-trivial
lemma new_lemma_164574 (h0 : filter (has_add name)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_164575 (h0 : not (uniform_space (normed_field std_gen) -> false)) : @complete_space.{0} (normed_field.{0} std_gen) (@classical.by_contradiction'.{1} (uniform_space.{0} (normed_field.{0} std_gen)) h0)  := sorry --non-trivial
lemma new_lemma_164576 (h0 : group (ring (finset (ring name)))) : is_cyclic (ring (finset (ring name))) := sorry --non-trivial
lemma new_lemma_164577 (h0 : group (has_ssubset (random_gen string_imp))) : is_cyclic (has_ssubset (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_164578 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (normed_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (normed_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_164579 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @is_noetherian_ring.{0} (ordered_comm_ring.{0} pos) (@matrix.vec_empty.{0} (semiring.{0} (ordered_comm_ring.{0} pos)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_164580 (h0 : list (ring (distrib char))) (h1 : ne h0 list.nil) : @rank_condition.{0} (distrib.{0} char) (@list.last.{0} (ring.{0} (distrib.{0} char)) h0 h1)  := sorry --non-trivial
lemma new_lemma_164581 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_bot.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_bot.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_164582 (h0 : uniform_space (semiring (random_gen to_additive.value_type))) : separated_space (semiring (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_164583 (h0 : topological_space (canonically_linear_ordered_monoid (has_add (finset Type)))) : sequential_space (canonically_linear_ordered_monoid (has_add (finset Type))) := sorry --non-trivial
lemma new_lemma_164584 (h0 : complete_lattice (metric_space empty)) : is_compactly_generated (metric_space empty) := sorry --non-trivial
lemma new_lemma_164585 (h0 : monoid (distrib_lattice unsigned)) : monoid.fg (distrib_lattice unsigned) := sorry --non-trivial
lemma new_lemma_164586 (h0 : function.extfun nat fin) : sequential_space real := sorry --non-trivial
lemma new_lemma_164587 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (ring ennreal)) := sorry --non-trivial
lemma new_lemma_164588 (h2 : add_group (nondiscrete_normed_field (mul_one_class environment.projection_info))) : is_add_cyclic (nondiscrete_normed_field (mul_one_class environment.projection_info)) := sorry --non-trivial
lemma new_lemma_164589 (h1 : has_lt (simple_graph (non_unital_non_assoc_semiring enat))) : no_max_order (simple_graph (non_unital_non_assoc_semiring enat)) := sorry --non-trivial
lemma new_lemma_164590 (h0 : has_mem.mem (random_gen fun_info) has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} (random_gen.{0} fun_info) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (random_gen.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_164591 (h0 : topological_space (semigroup (has_add (ring Type)))) : loc_path_connected_space (semigroup (has_add (ring Type))) := sorry --non-trivial
lemma new_lemma_164592 (h0 : measurable_space (has_edist (random_gen string_imp))) (h1 : has_add (has_edist (random_gen string_imp))) (h2 : measure_theory.measure (has_edist (random_gen string_imp))) : measure_theory.measure.is_add_left_invariant h2 := sorry --non-trivial
lemma new_lemma_164593 (h0 : functor.add_const (finset (comm_group name)) linarith.comp) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_164594 (h0 : ring (has_append to_additive.value_type)) : rank_condition (has_append to_additive.value_type) := sorry --non-trivial
lemma new_lemma_164595 (h0 : functor.add_const (topological_space (finset Type)) pos) : @loc_path_connected_space.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (finset.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_164596 (h0 : ring (mul_one_class (random_gen string_imp))) : rank_condition (mul_one_class (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_164597 (h0 : functor.add_const (topological_space (add_cancel_monoid linarith.comp)) linarith.comp) : @preirreducible_space.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_164598 (h0 : ring (semigroup (has_neg (ring linarith.comp)))) : is_domain (semigroup (has_neg (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_164599 (h0 : option (group (ring (has_add (add_comm_monoid (has_add Type)))))) (h1 : group (ring (has_add (add_comm_monoid (has_add Type))))) : is_simple_group (ring (has_add (add_comm_monoid (has_add Type)))) := sorry --non-trivial
lemma new_lemma_164600 (h0 : list (has_norm (random_gen (random_gen (has_top fun_info))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_164601 (h0 : fin has_zero.zero) : countable_Inter_filter (function.extfun_app (matrix.vec_empty h0) (complete_distrib_lattice name)) := sorry --non-trivial
lemma new_lemma_164602 (h0 : uniform_space (add_comm_monoid (has_bot real))) : complete_space (add_comm_monoid (has_bot real)) := sorry --non-trivial
lemma new_lemma_164603 (h0 : functor.add_const (uniform_space (add_cancel_monoid environment.implicit_infer_kind)) Type) : @complete_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (uniform_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_164604 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_164605 (h0 : group (preorder unsigned)) : is_cyclic (preorder unsigned) := sorry --non-trivial
lemma new_lemma_164606 (h0 : not (topological_space (random_gen linarith.comp) -> false)) : @irreducible_space.{0} (random_gen.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (random_gen.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_164607 (h0 : prod (partial_order (option (option empty))) (partial_order (option (option empty)))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_164608 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (has_norm.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_norm.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_164609 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @normal_space.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (normed_comm_ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_164610 (h0 : complete_lattice (has_inter unsigned)) : is_atomistic (has_inter unsigned) := sorry --non-trivial
lemma new_lemma_164611 (h0 : finset (ring (mul_one_class (mul_one_class (has_zero Type))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_164612 (h0 : topological_space (random_gen (has_ssubset to_additive.value_type))) : path_connected_space (random_gen (has_ssubset to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_164613 (h0 : functor.add_const (topological_space (cancel_monoid unsigned)) (normed_comm_ring environment.implicit_infer_kind)) : @path_connected_space.{0} (cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} unsigned)) (normed_comm_ring.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_164614 (h0 : functor.add_const (topological_space (comm_group pos)) unsigned) : @preirreducible_space.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_164615 (h0 : not (topological_space (encodable fun_info) -> false)) : @t0_space.{0} (encodable.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (encodable.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_164616 (h0 : ring (complete_distrib_lattice (comm_group (comm_group pos)))) : is_domain (complete_distrib_lattice (comm_group (comm_group pos))) := sorry --non-trivial
lemma new_lemma_164617 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (has_zero.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_zero.{0} name))  := sorry --non-trivial
lemma new_lemma_164618 (h2 : uniform_space (non_unital_non_assoc_semiring to_additive.value_type)) : complete_space (non_unital_non_assoc_semiring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_164619 (h0 : not (topological_space (metric_space linarith.comp) -> false)) : @preirreducible_space.{0} (metric_space.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (metric_space.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_164620 (h0 : uniform_space (ordered_comm_ring (has_neg linarith.comp))) : complete_space (ordered_comm_ring (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_164621 (h0 : functor.add_const (cancel_comm_monoid_with_zero (simple_graph linarith.comp)) pos) : @unique_factorization_monoid.{0} (simple_graph.{0} linarith.comp) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (simple_graph.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_164622 (h0 : topological_space (has_neg_part (has_neg_part ennreal))) : normal_space (has_neg_part (has_neg_part ennreal)) := sorry --non-trivial
lemma new_lemma_164623 (h0 : not (group (normed_group linarith.comp) -> false)) : @is_cyclic.{0} (normed_group.{0} linarith.comp) (@classical.by_contradiction'.{1} (group.{0} (normed_group.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_164624 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (comm_semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_164625 (h0 : filter (comm_ring linarith.ineq)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_164626 (h0 : topological_space (has_top linarith.comp)) : locally_compact_space (has_top linarith.comp) := sorry --non-trivial
lemma new_lemma_164627 (h0 : function.extfun (finset Type) (has_mem.mem linarith.comp_source)) : @is_atomistic.{0} linarith.comp_source (@finset.pi.empty.{1 0} Type complete_lattice.{0} linarith.comp_source (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) linarith.comp_source) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_164628 (h0 : functor.add_const (ring (has_Inf linarith.comp)) name) : @strong_rank_condition.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_Inf.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_164629 (h0 : has_mem.mem (complete_semilattice_Sup congr_arg_kind) has_emptyc.emptyc) : @is_domain.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type ring.{0} (complete_semilattice_Sup.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_164630 (h0 : topological_space (boolean_algebra (has_neg (has_neg pos)))) : normal_space (boolean_algebra (has_neg (has_neg pos))) := sorry --non-trivial
lemma new_lemma_164631 (h0 : not (prod (measure_theory.measure_space empty) (measure_theory.measure_space empty) -> false)) : id_rel (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_164632 (h0 : topological_space (with_zero fun_info)) : t0_space (with_zero fun_info) := sorry --non-trivial
lemma new_lemma_164633 (h0 : topological_space (add_comm_monoid environment.implicit_infer_kind)) : sequential_space (add_comm_monoid environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_164634 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (has_union.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_union.{0} num))  := sorry --non-trivial
lemma new_lemma_164635 (h0 : functor.add_const (group (add_group num)) (semiring (semiring empty))) : @is_cyclic.{0} (add_group.{0} num) (@functor.add_const.run.{0 0} (group.{0} (add_group.{0} num)) (semiring.{0} (semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_164636 (h1 : not (ring (add_monoid to_additive.value_type) -> false)) : @strong_rank_condition.{0} (add_monoid.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (add_monoid.{0} to_additive.value_type)) h1)  := sorry --non-trivial
lemma new_lemma_164637 (h0 : functor.add_const (topological_space (has_to_string pos)) unsigned) : @discrete_topology.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_164638 (h0 : list (has_bot (option (option (option (option (option empty))))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_164639 (h0 : functor.add_const (topological_space (sub_neg_monoid linarith.comp)) pos) : @irreducible_space.{0} (sub_neg_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (sub_neg_monoid.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_164640 (h0 : topological_space (has_neg (finset pos))) : topological_space.separable_space (has_neg (finset pos)) := sorry --non-trivial
lemma new_lemma_164641 (h0 : group (left_cancel_monoid (option (partial_order congr_arg_kind)))) : is_cyclic (left_cancel_monoid (option (partial_order congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_164642 (h0 : semiring (finset (has_add (ring Type)))) : is_noetherian_ring (finset (has_add (ring Type))) := sorry --non-trivial
lemma new_lemma_164643 (h0 : functor.add_const (function.extfun Type semiring) Type) : @is_noetherian_ring.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type semiring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type semiring.{0}) Type h0) (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_164644 (h1 : add_group (topological_space reducibility_hints)) : is_add_cyclic (topological_space reducibility_hints) := sorry --non-trivial
lemma new_lemma_164645 (h0 : topological_space (comm_group (finset linarith.comp))) : loc_path_connected_space (comm_group (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_164646 (h0 : group (add_group empty)) : is_cyclic (add_group empty) := sorry --non-trivial
lemma new_lemma_164647 (h0 : topological_space (generalized_boolean_algebra linarith.comp)) : totally_disconnected_space (generalized_boolean_algebra linarith.comp) := sorry --non-trivial
lemma new_lemma_164648 (h0 : functor.add_const (semiring (normed_comm_ring name)) (ring (ring linarith.comp))) : @is_noetherian_ring.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (semiring.{0} (normed_comm_ring.{0} name)) (ring.{0} (ring.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_164649 (h0 : topological_space (has_bot (has_Inf (has_add Type)))) : preconnected_space (has_bot (has_Inf (has_add Type))) := sorry --non-trivial
lemma new_lemma_164650 (h0 : topological_space (linear_ordered_add_comm_group (has_top linarith.ineq))) : locally_compact_space (linear_ordered_add_comm_group (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_164651 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} name (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) name)  := sorry --non-trivial
lemma new_lemma_164652 (h0 : has_mem.mem Prop has_emptyc.emptyc) : list.tfae (finset.pi.empty list Prop h0) := sorry --non-trivial
lemma new_lemma_164653 (h4 : set (add_comm_semigroup (add_comm_semigroup char))) : set.finite h4 := sorry --non-trivial
lemma new_lemma_164654 (h0 : semiring (simple_graph (has_pos_part linarith.comp))) : is_noetherian_ring (simple_graph (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_164655 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (has_pos_part.{0} real) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (has_pos_part.{0} real))  := sorry --non-trivial
lemma new_lemma_164656 (h0 : prod (linear_ordered_field unsigned) (linear_ordered_field unsigned)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_164657 (h0 : functor.add_const (add_group (has_nndist unsigned)) unsigned) : @is_add_cyclic.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 0} (add_group.{0} (has_nndist.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_164658 (h0 : list (semi_normed_comm_ring (random_gen (random_gen fun_info)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_164659 (h0 : topological_space (has_nndist Type)) : normal_space (has_nndist Type) := sorry --non-trivial
lemma new_lemma_164660 (h0 : topological_space (has_emptyc num)) : discrete_topology (has_emptyc num) := sorry --non-trivial
lemma new_lemma_164661 (h0 : functor.add_const (list (finset num)) num) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_164662 (h0 : ordered_comm_monoid (canonically_ordered_comm_semiring (ring (option pos)))) : has_exists_mul_of_le (canonically_ordered_comm_semiring (ring (option pos))) := sorry --non-trivial
lemma new_lemma_164663 (h0 : functor.add_const Prop (normed_comm_ring ennreal)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_164664 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (ring.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (ring.{0} name))  := sorry --non-trivial
lemma new_lemma_164665 (h0 : uniform_space (uniform_space (mul_one_class (mul_one_class to_additive.value_type)))) : complete_space (uniform_space (mul_one_class (mul_one_class to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_164666 (h0 : not (has_mem.mem (with_one linarith.comp_source) has_emptyc.emptyc -> false)) : @separated_space.{0} (with_one.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type uniform_space.{0} (with_one.{0} linarith.comp_source) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_one.{0} linarith.comp_source) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_164667 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @discrete_topology.{0} (measurable_space.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (measurable_space.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_164668 (h0 : function.extfun Type topological_space) : @t0_space.{0} (monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_164669 (h0 : topological_space (comm_group (add_cancel_monoid Type))) : t0_space (comm_group (add_cancel_monoid Type)) := sorry --non-trivial
lemma new_lemma_164670 (h0 : functor.add_const (function.extfun (Type 1) topological_space) Type) : @preconnected_space.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) Type h0) (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_164671 (h0 : add_monoid (has_neg_part (add_comm_monoid pos))) : add_monoid.fg (has_neg_part (add_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_164672 (h0 : functor.add_const (function.extfun (Type 1) topological_space) (finset linarith.comp)) : @topological_space.separable_space.{1} Type (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) (finset.{0} linarith.comp) h0) Type)  := sorry --non-trivial
lemma new_lemma_164673 (h1 : not (uniform_space num -> false)) : @separated_space.{0} num (@classical.by_contradiction'.{1} (uniform_space.{0} num) h1)  := sorry --non-trivial
lemma new_lemma_164674 (h0 : functor.add_const (ring (has_neg linarith.comp)) (has_zero Type)) : @is_domain.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 1} (ring.{0} (has_neg.{0} linarith.comp)) (has_zero.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_164675 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (ordered_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_164676 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} linarith.comp_source (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_164677 (h0 : topological_space (random_gen (has_norm linarith.comp))) (h1 : punit) : category_theory.hom_of_element (totally_separated_space (random_gen (has_norm linarith.comp))) h1 := sorry --non-trivial
lemma new_lemma_164678 (h0 : group (encodable (random_gen (random_gen to_additive.value_type)))) : group.fg (encodable (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_164679 (h0 : functor.add_const (ring (has_add name)) pos) : @rank_condition.{0} (has_add.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (has_add.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_164680 (h0 : topological_space (has_nndist (has_nndist name))) : irreducible_space (has_nndist (has_nndist name)) := sorry --non-trivial
lemma new_lemma_164681 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (with_bot.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} fun_info)))))) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (with_bot.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} fun_info)))))))  := sorry --non-trivial
lemma new_lemma_164682 (h0 : functor.add_const (topological_space (has_pos_part Type)) (has_Inf pos)) : @sequential_space.{1} (has_pos_part.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_pos_part.{1} Type)) (has_Inf.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_164683 (h0 : uniform_space (comm_group (has_to_string name))) : complete_space (comm_group (has_to_string name)) := sorry --non-trivial
lemma new_lemma_164684 (h0 : complete_lattice (semi_normed_ring (has_div reducibility_hints))) : complete_lattice.is_Sup_finite_compact (semi_normed_ring (has_div reducibility_hints)) := sorry --non-trivial
lemma new_lemma_164685 (h0 : cancel_comm_monoid_with_zero (nondiscrete_normed_field (add_comm_semigroup linarith.ineq))) (h1 : uniform_space (gcd_monoid (nondiscrete_normed_field (add_comm_semigroup linarith.ineq)))) : complete_space (gcd_monoid (nondiscrete_normed_field (add_comm_semigroup linarith.ineq))) := sorry --non-trivial
lemma new_lemma_164686 (h0 : not (complete_lattice (simple_graph linarith.ineq) -> false)) : @is_compactly_generated.{0} (simple_graph.{0} linarith.ineq) (@classical.by_contradiction'.{1} (complete_lattice.{0} (simple_graph.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_164687 (h0 : topological_space (has_Inf (sub_neg_monoid pos))) : preconnected_space (has_Inf (sub_neg_monoid pos)) := sorry --non-trivial
lemma new_lemma_164688 (h0 : function.extfun Type group) : @group.fg.{0} (has_neg.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} h0 (has_neg.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_164689 (h0 : topological_space (has_pos_part (boolean_algebra.core (has_to_string Type)))) : sequential_space (has_pos_part (boolean_algebra.core (has_to_string Type))) := sorry --non-trivial
lemma new_lemma_164690 (h0 : functor.add_const Prop (semigroup pos)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_164691 (h0 : ring (with_one (has_norm linarith.comp))) : strong_rank_condition (with_one (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_164692 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (pseudo_metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (pseudo_metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_164693 (h0 : functor.add_const (functor.add_const (topological_space Type) name) (has_Inf pos)) : @locally_compact_space.{1} Type (@functor.add_const.run.{1 0} (topological_space.{1} Type) name (@functor.add_const.run.{1 0} (functor.add_const.{1 0} (topological_space.{1} Type) name) (has_Inf.{0} pos) h0))  := sorry --non-trivial
lemma new_lemma_164694 (h0 : normed_comm_ring (has_zero (has_add Type)) -> normed_comm_ring (has_zero (has_add Type)) -> Prop) : is_symm (normed_comm_ring (has_zero (has_add Type))) h0 := sorry --non-trivial
lemma new_lemma_164695 (h1 : list (has_emptyc to_additive.value_type)) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_164696 (h0 : ring (with_one (semiring linarith.comp_source))) : strong_rank_condition (with_one (semiring linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_164697 (h0 : add_group (add_comm_semigroup environment.projection_info)) : is_add_cyclic (add_comm_semigroup environment.projection_info) := sorry --non-trivial
lemma new_lemma_164698 (h0 : ring (canonically_linear_ordered_monoid (has_Inf (has_Inf (has_add (has_add real)))))) : rank_condition (canonically_linear_ordered_monoid (has_Inf (has_Inf (has_add (has_add real))))) := sorry --non-trivial
lemma new_lemma_164699 (h0 : complete_lattice (has_compl (has_nnnorm reducibility_hints))) : complete_lattice.is_Sup_finite_compact (has_compl (has_nnnorm reducibility_hints)) := sorry --non-trivial
lemma new_lemma_164700 (h0 : topological_space (comm_monoid num)) : path_connected_space (comm_monoid num) := sorry --non-trivial
lemma new_lemma_164701 (h0 : ring (non_assoc_semiring congr_arg_kind)) : strong_rank_condition (non_assoc_semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_164702 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (finset.{0} ennreal) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (finset.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_164703 (h0 : fin has_zero.zero) : @is_compactly_generated.{1} (has_add.{1} Type) (@matrix.vec_empty.{1} (complete_lattice.{1} (has_add.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_164704 (h0 : not (group (comm_ring to_additive.value_type) -> false)) : @group.fg.{0} (comm_ring.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (group.{0} (comm_ring.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_164705 (h0 : topological_space (normed_lattice_add_comm_group (has_bot (has_add (has_add (has_add real)))))) : preirreducible_space (normed_lattice_add_comm_group (has_bot (has_add (has_add (has_add real))))) := sorry --non-trivial
lemma new_lemma_164706 (h0 : complete_lattice (with_one (has_top (has_top (random_gen (has_top linarith.comp_source)))))) : is_compactly_generated (with_one (has_top (has_top (random_gen (has_top linarith.comp_source))))) := sorry --non-trivial
lemma new_lemma_164707 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @regular_space.{0} (generalized_boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (generalized_boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_164708 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @normal_space.{0} (normed_group.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) topological_space.{0}) (normed_group.{0} num))  := sorry --non-trivial
lemma new_lemma_164709 (h0 : functor.add_const (topological_space (normed_comm_ring unsigned)) name) : @path_connected_space.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_164710 (h0 : has_lt (has_nnnorm (mul_one_class std_gen))) : no_max_order (has_nnnorm (mul_one_class std_gen)) := sorry --non-trivial
lemma new_lemma_164711 (h0 : functor.add_const (finset (has_add Type)) (has_neg (ring (has_neg (has_nndist Type))))) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_164712 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (has_to_string.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_to_string.{0} name))  := sorry --non-trivial
lemma new_lemma_164713 (h0 : topological_space (normed_linear_ordered_group (option unsigned))) : discrete_topology (normed_linear_ordered_group (option unsigned)) := sorry --non-trivial
lemma new_lemma_164714 (h0 : topological_space (has_compl (boolean_algebra.core string.iterator_imp))) : path_connected_space (has_compl (boolean_algebra.core string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_164715 (h0 : not (topological_space (left_cancel_semigroup unsigned) -> false)) : @t0_space.{0} (left_cancel_semigroup.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (left_cancel_semigroup.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_164716 (h0 : topological_space (semi_normed_ring fun_info)) : path_connected_space (semi_normed_ring fun_info) := sorry --non-trivial
lemma new_lemma_164717 (h0 : topological_space (add_group (has_norm (semiring num)))) : t0_space (add_group (has_norm (semiring num))) := sorry --non-trivial
lemma new_lemma_164718 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (pseudo_metric_space.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (pseudo_metric_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_164719 (h0 : function.extfun Type (functor.add_const (uniform_space (filter unsigned)))) : @separated_space.{0} (filter.{0} unsigned) (@functor.add_const.run.{0 0} (uniform_space.{0} (filter.{0} unsigned)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (uniform_space.{0} (filter.{0} unsigned))) h0 empty))  := sorry --non-trivial
lemma new_lemma_164720 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (normed_group.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_164721 (h0 : group (random_gen (has_nnnorm (has_nnnorm fun_info)))) : is_cyclic (random_gen (has_nnnorm (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_164722 (h0 : topological_space (has_neg (has_nndist (finset pos)))) : t0_space (has_neg (has_nndist (finset pos))) := sorry --non-trivial
lemma new_lemma_164723 (h0 : complete_lattice (ordered_cancel_add_comm_monoid (semiring (semiring (semiring empty))))) : is_atomistic (ordered_cancel_add_comm_monoid (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_164724 (h6 : semiring (nondiscrete_normed_field (mul_one_class linarith.ineq))) (h7 : ideal (nondiscrete_normed_field (mul_one_class linarith.ineq))) : ideal.is_prime h7 := sorry --non-trivial
lemma new_lemma_164725 (h0 : functor.add_const (topological_space (semigroup congr_arg_kind)) unsigned) : @loc_path_connected_space.{0} (semigroup.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_164726 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (normed_linear_ordered_group.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} h0 (normed_linear_ordered_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_164727 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (has_zero.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_zero.{0} name))  := sorry --non-trivial
lemma new_lemma_164728 (h1 : ring (has_lt linarith.comp_source)) : strong_rank_condition (has_lt linarith.comp_source) := sorry --non-trivial
lemma new_lemma_164729 (h0 : finset (simple_graph (finset linarith.comp))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_164730 (h0 : uniform_space (cancel_monoid num)) : complete_space (cancel_monoid num) := sorry --non-trivial
lemma new_lemma_164731 (h0 : group (random_gen (has_ssubset reducibility_hints))) : is_cyclic (random_gen (has_ssubset reducibility_hints)) := sorry --non-trivial
lemma new_lemma_164732 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring name)) Type) : @path_connected_space.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (canonically_ordered_comm_semiring.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_164733 (h0 : semiring (comm_group (has_add (has_add (has_add (has_nndist (has_nndist pos))))))) : is_noetherian_ring (comm_group (has_add (has_add (has_add (has_nndist (has_nndist pos)))))) := sorry --non-trivial
lemma new_lemma_164734 (h0 : group (with_bot fun_info)) : normalizer_condition (with_bot fun_info) := sorry --non-trivial
lemma new_lemma_164735 (h0 : not (uniform_space (has_union congr_arg_kind) -> false)) : @complete_space.{0} (has_union.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_union.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_164736 (h0 : topological_space (add_comm_monoid (ring (ring unsigned)))) : loc_path_connected_space (add_comm_monoid (ring (ring unsigned))) := sorry --non-trivial
lemma new_lemma_164737 (h0 : topological_space (ordered_cancel_comm_monoid environment.projection_info)) (h1 : preorder (ordered_cancel_comm_monoid environment.projection_info)) : order_closed_topology (ordered_cancel_comm_monoid environment.projection_info) := sorry --non-trivial
lemma new_lemma_164738 (h0 : functor.add_const (topological_space (simple_graph empty)) congr_arg_kind) : @normal_space.{0} (simple_graph.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (simple_graph.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_164739 (h0 : uniform_space (add_cancel_monoid (ring (finset Type)))) : complete_space (add_cancel_monoid (ring (finset Type))) := sorry --non-trivial
lemma new_lemma_164740 (h0 : topological_space (has_append (has_nnnorm (random_gen reducibility_hints)))) : totally_disconnected_space (has_append (has_nnnorm (random_gen reducibility_hints))) := sorry --non-trivial
lemma new_lemma_164741 (h0 : add_monoid (has_pos_part (finset (boolean_algebra.core (has_neg pos))))) : add_monoid.fg (has_pos_part (finset (boolean_algebra.core (has_neg pos)))) := sorry --non-trivial
lemma new_lemma_164742 (h0 : functor.add_const (ring (boolean_algebra linarith.comp)) linarith.comp) : @is_domain.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_164743 (h0 : complete_lattice (has_div (mul_one_class to_additive.value_type))) : is_compactly_generated (has_div (mul_one_class to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_164744 (h0 : not (monoid (with_one to_additive.value_type) -> false)) : @monoid.fg.{0} (with_one.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (monoid.{0} (with_one.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_164745 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (has_neg.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} num))  := sorry --non-trivial
lemma new_lemma_164746 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_164747 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} linarith.comp_source (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_164748 (h1 : add_group (normed_field (normed_field (normed_field (normed_field (normed_field char)))))) : is_add_cyclic (normed_field (normed_field (normed_field (normed_field (normed_field char))))) := sorry --non-trivial
lemma new_lemma_164749 (h0 : not (function.extfun Type monoid -> false)) : @monoid.fg.{0} (normed_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type monoid.{0}) h0) (normed_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_164750 (h0 : ring (has_emptyc (has_norm (has_top linarith.comp_source)))) : is_domain (has_emptyc (has_norm (has_top linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_164751 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (with_bot.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_bot.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_164752 (h0 : set.set_semiring (with_one to_additive.value_type)) (h1 : function.extfun Type with_one) : set.set_semiring.down h0 (function.extfun_app h1 to_additive.value_type) := sorry --non-trivial
lemma new_lemma_164753 (h0 : ordered_add_comm_monoid (pseudo_metric_space pos)) : archimedean (pseudo_metric_space pos) := sorry --non-trivial
lemma new_lemma_164754 (h0 : uniform_space (has_emptyc Type)) : separated_space (has_emptyc Type) := sorry --non-trivial
lemma new_lemma_164755 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_164756 (h0 : topological_space (random_gen (has_inv linarith.comp_source))) : totally_separated_space (random_gen (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_164757 (h0 : function.extfun (finset Type) (has_mem.mem (random_gen empty))) : @add_monoid.fg.{0} (random_gen.{0} empty) (@finset.pi.empty.{1 0} Type add_monoid.{0} (random_gen.{0} empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} empty)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_164758 (h0 : functor.add_const (complete_lattice (add_comm_monoid Type)) linarith.comp) : @complete_lattice.is_Sup_finite_compact.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (add_comm_monoid.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_164759 (h0 : topological_space (normed_comm_ring (finset pos))) : locally_compact_space (normed_comm_ring (finset pos)) := sorry --non-trivial
lemma new_lemma_164760 (h0 : not (function.extfun Type group -> false)) : @normalizer_condition.{0} (linear_ordered_comm_ring.{0} num) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (linear_ordered_comm_ring.{0} num))  := sorry --non-trivial
lemma new_lemma_164761 (h0 : ereal -> ereal -> ereal) : left_commutative h0 := sorry --non-trivial
lemma new_lemma_164762 (h0 : functor.add_const (topological_space (ordered_ring congr_arg_kind)) empty) : @t1_space.{0} (ordered_ring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_164763 (h0 : ring (topological_space (comm_ring string_imp))) : is_domain (topological_space (comm_ring string_imp)) := sorry --non-trivial
lemma new_lemma_164764 (h0 : topological_space (linear_ordered_field (monoid pos))) : loc_path_connected_space (linear_ordered_field (monoid pos)) := sorry --non-trivial
lemma new_lemma_164765 (h0 : group real) : group.fg real := sorry --non-trivial
lemma new_lemma_164766 (h0 : topological_space (plift (option empty))) : topological_space.separable_space (plift (option empty)) := sorry --non-trivial
lemma new_lemma_164767 (h0 : monoid_with_zero (complete_distrib_lattice pos) -> monoid_with_zero (complete_distrib_lattice pos) -> Prop) : is_symm (monoid_with_zero (complete_distrib_lattice pos)) h0 := sorry --non-trivial
lemma new_lemma_164768 (h0 : ring (has_ssubset (random_gen string_imp))) : rank_condition (has_ssubset (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_164769 (h0 : list (topological_space (option (semiring (semiring (semiring (semiring (semiring unsigned)))))))) (h1 : function.extfun (eq h0 list.nil) (fun (x : eq h0 list.nil), false)) : @totally_separated_space.{0} (option.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} unsigned)))))) (@list.last.{0} (topological_space.{0} (option.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} unsigned))))))) h0 (@function.extfun_app.{0 0} (@eq.{1} (list.{0} (topological_space.{0} (option.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} unsigned)))))))) h0 (@list.nil.{0} (topological_space.{0} (option.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} unsigned))))))))) (λ (x : @eq.{1} (list.{0} (topological_space.{0} (option.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} unsigned)))))))) h0 (@list.nil.{0} (topological_space.{0} (option.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} unsigned))))))))), false) h1))  := sorry --non-trivial
lemma new_lemma_164770 (h0 : ring (normed_comm_ring (has_neg pos))) : is_domain (normed_comm_ring (has_neg pos)) := sorry --non-trivial
lemma new_lemma_164771 (h0 : function.extfun Type (functor.add_const (ring (emetric_space (option unsigned))))) : @strong_rank_condition.{0} (emetric_space.{0} (option.{0} unsigned)) (@functor.add_const.run.{0 0} (ring.{0} (emetric_space.{0} (option.{0} unsigned))) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} (emetric_space.{0} (option.{0} unsigned)))) h0 empty))  := sorry --non-trivial
lemma new_lemma_164772 (h0 : add_monoid (has_one (semiring (semiring (semiring (semiring (semiring empty))))))) : add_monoid.fg (has_one (semiring (semiring (semiring (semiring (semiring empty)))))) := sorry --non-trivial
lemma new_lemma_164773 (h1 : complete_lattice (topological_space (random_gen (random_gen char)))) : complete_lattice.is_Sup_finite_compact (topological_space (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_164774 (h0 : not (uniform_space (add_right_cancel_monoid linarith.comp) -> false)) : @complete_space.{0} (add_right_cancel_monoid.{0} linarith.comp) (@classical.by_contradiction'.{1} (uniform_space.{0} (add_right_cancel_monoid.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_164775 (h1 : complete_lattice (linear_ordered_add_comm_group char)) : complete_lattice.is_Sup_finite_compact (linear_ordered_add_comm_group char) := sorry --non-trivial
lemma new_lemma_164776 (h0 : ordered_add_comm_monoid (cancel_monoid (has_add environment.implicit_infer_kind))) : archimedean (cancel_monoid (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_164777 (h0 : topological_space (has_neg_part unsigned)) : discrete_topology (has_neg_part unsigned) := sorry --non-trivial
lemma new_lemma_164778 (h1 : not (topological_space (uniform_space reducibility_hints) -> false)) : @totally_disconnected_space.{0} (uniform_space.{0} reducibility_hints) (@classical.by_contradiction'.{1} (topological_space.{0} (uniform_space.{0} reducibility_hints)) h1)  := sorry --non-trivial
lemma new_lemma_164779 (h0 : add_group (has_one (has_top (has_norm linarith.comp)))) : is_add_cyclic (has_one (has_top (has_norm linarith.comp))) := sorry --non-trivial
lemma new_lemma_164780 (h0 : functor.add_const (function.extfun Type list) linarith.comp) : list.nodup (function.extfun_app (functor.add_const.run h0) (comm_group pos)) := sorry --non-trivial
lemma new_lemma_164781 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (comm_semigroup.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_semigroup.{0} real))  := sorry --non-trivial
lemma new_lemma_164782 (h0 : functor.add_const (ring (semigroup linarith.comp)) linarith.comp) : @is_principal_ideal_ring.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (semigroup.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_164783 (h0 : topological_space (has_Inf (has_neg linarith.comp))) : regular_space (has_Inf (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_164784 (h0 : ring (has_pos_part real)) : rank_condition (has_pos_part real) := sorry --non-trivial
lemma new_lemma_164785 (h0 : function.extfun Type group) : @is_cyclic.{0} (random_gen.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (random_gen.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_164786 (h0 : cancel_comm_monoid_with_zero (ring empty)) : unique_factorization_monoid (ring empty) := sorry --non-trivial
lemma new_lemma_164787 (h0 : add_group (complete_distrib_lattice (sub_neg_monoid (has_add (sub_neg_monoid pos))))) : is_add_cyclic (complete_distrib_lattice (sub_neg_monoid (has_add (sub_neg_monoid pos)))) := sorry --non-trivial
lemma new_lemma_164788 (h0 : uniform_space (normed_comm_ring (option pos))) : complete_space (normed_comm_ring (option pos)) := sorry --non-trivial
lemma new_lemma_164789 (h0 : not (filter (linear_ordered_add_comm_group linarith.comp_source) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_164790 (h0 : functor.add_const (complete_lattice (has_Sup empty)) unsigned) : @is_compactly_generated.{0} (has_Sup.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_Sup.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_164791 (h0 : function.extfun (Type -> Type) (function.extfun Type)) (h1 : preorder (has_norm linarith.comp_source)) : @order_topology.{0} (has_norm.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_norm.{0} linarith.comp_source)) h1  := sorry --non-trivial
lemma new_lemma_164792 (h0 : function.extfun (prod unsigned unsigned) (fun (x : prod unsigned unsigned), Prop)) (h1 : prod unsigned unsigned) : symmetrize_rel (function.extfun_app h0) h1 := sorry --non-trivial
lemma new_lemma_164793 (h0 : monoid (with_bot (has_norm linarith.comp))) : monoid.fg (with_bot (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_164794 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_164795 (h0 : functor.add_const (list (cancel_monoid unsigned)) pos) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_164796 (h0 : topological_space (has_nndist (ring pos))) : preconnected_space (has_nndist (ring pos)) := sorry --non-trivial
lemma new_lemma_164797 (h0 : finset (has_star num)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_164798 (h3 : add_group (nondiscrete_normed_field linarith.ineq)) : is_add_cyclic (nondiscrete_normed_field linarith.ineq) := sorry --non-trivial
lemma new_lemma_164799 (h0 : functor.add_const (ring (comm_monoid num)) empty) : @is_principal_ideal_ring.{0} (comm_monoid.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (comm_monoid.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_164800 (h0 : complete_lattice (semiring (has_inv linarith.ineq))) : is_compactly_generated (semiring (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_164801 (h0 : topological_space (add_cancel_monoid (finset environment.implicit_infer_kind))) : preirreducible_space (add_cancel_monoid (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_164802 (h0 : has_lt (add_comm_semigroup (add_comm_semigroup (normed_field std_gen)))) : no_max_order (add_comm_semigroup (add_comm_semigroup (normed_field std_gen))) := sorry --non-trivial
lemma new_lemma_164803 (h1 : add_group empty) : is_add_cyclic empty := sorry --non-trivial
lemma new_lemma_164804 (h0 : function.extfun nat fin) : @is_principal_ideal_ring.{1} (has_pos_part.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (has_pos_part.{1} Type)) (@function.extfun_app.{1 1} nat fin (@matrix.vec_empty.{0} (function.extfun.{1 1} nat fin) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_164805 (h0 : not (group (has_ssubset to_additive.value_type) -> false)) : @group.fg.{0} (has_ssubset.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (group.{0} (has_ssubset.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_164806 (h0 : fin has_zero.zero) : @t1_space.{0} (sub_neg_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (sub_neg_monoid.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_164807 (h0 : functor.add_const (uniform_space (has_to_string name)) name) : @separated_space.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_to_string.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_164808 (h0 : functor.add_const (function.extfun nat fin) linarith.comp) : @t0_space.{0} (complete_distrib_lattice.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (complete_distrib_lattice.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin (@functor.add_const.run.{0 0} (function.extfun.{1 1} nat fin) linarith.comp h0) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_164809 (h0 : functor.add_const (complete_lattice (plift empty)) (option (option empty))) : @is_compactly_generated.{1} (plift.{1} empty) (@functor.add_const.run.{1 0} (complete_lattice.{1} (plift.{1} empty)) (option.{0} (option.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_164810 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (group_with_zero.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (group_with_zero.{0} num))  := sorry --non-trivial
lemma new_lemma_164811 (h0 : complete_lattice (has_norm (option unsigned))) : is_compactly_generated (has_norm (option unsigned)) := sorry --non-trivial
lemma new_lemma_164812 (h0 : functor.add_const (monoid (simple_graph linarith.comp)) (has_neg linarith.comp)) : @monoid.fg.{0} (simple_graph.{0} linarith.comp) (@functor.add_const.run.{0 0} (monoid.{0} (simple_graph.{0} linarith.comp)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_164813 (h0 : ring (add_cancel_monoid pos)) : is_domain (add_cancel_monoid pos) := sorry --non-trivial
lemma new_lemma_164814 (h0 : set (normed_linear_ordered_group linarith.ineq)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_164815 (h1 : add_group (distrib (random_gen char))) : is_add_cyclic (distrib (random_gen char)) := sorry --non-trivial
lemma new_lemma_164816 (h0 : topological_space (canonically_linear_ordered_monoid (option ennreal))) : topological_space.separable_space (canonically_linear_ordered_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_164817 (h0 : functor.add_const (ordered_add_comm_monoid (generalized_boolean_algebra pos)) (ring (ring linarith.comp))) : @archimedean.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (generalized_boolean_algebra.{0} pos)) (ring.{0} (ring.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_164818 (h0 : uniform_space (ordered_comm_ring pos)) : separated_space (ordered_comm_ring pos) := sorry --non-trivial
lemma new_lemma_164819 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_164820 (h0 : functor.add_const (group (has_nndist Type)) pos) : @is_cyclic.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (has_nndist.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_164821 (h0 : topological_space (distrib_lattice linarith.comp_source)) : totally_disconnected_space (distrib_lattice linarith.comp_source) := sorry --non-trivial
lemma new_lemma_164822 (h0 : functor.add_const (topological_space (normed_comm_ring pos)) Type) : @sequential_space.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (normed_comm_ring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_164823 (h1 h2 : multiset real.angle) : multiset.subset h1 h2 := sorry --non-trivial
lemma new_lemma_164824 (h0 : topological_space std_gen) (h1 : measurable_space std_gen) : opens_measurable_space std_gen := sorry --non-trivial
lemma new_lemma_164825 (h0 : functor.add_const (group (ring linarith.comp)) pos) : @is_simple_group.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (ring.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_164826 (h0 : topological_space (has_union (semiring num))) : irreducible_space (has_union (semiring num)) := sorry --non-trivial
lemma new_lemma_164827 (h0 : add_monoid (linear_ordered_field (has_nndist name))) : add_monoid.fg (linear_ordered_field (has_nndist name)) := sorry --non-trivial
lemma new_lemma_164828 (h0 : group (ordered_comm_monoid linarith.comp)) : is_cyclic (ordered_comm_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_164829 (h0 : topological_space (simple_graph (has_Inf Type))) : locally_compact_space (simple_graph (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_164830 (h0 : filter (boolean_algebra (has_to_string (finset Type)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_164831 (h0 : ring (distrib (mul_one_class reducibility_hints))) : strong_rank_condition (distrib (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_164832 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} (with_one.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (with_one.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_164833 (h1 : ring (has_compl (has_nnnorm (random_gen (random_gen (random_gen char)))))) : rank_condition (has_compl (has_nnnorm (random_gen (random_gen (random_gen char))))) := sorry --non-trivial
lemma new_lemma_164834 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type monoid.{0} h0 (monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_164835 (h0 : ordered_add_comm_monoid (canonically_ordered_comm_semiring (option empty))) : archimedean (canonically_ordered_comm_semiring (option empty)) := sorry --non-trivial
lemma new_lemma_164836 (h0 : complete_lattice (has_norm (random_gen linarith.ineq))) : is_compactly_generated (has_norm (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_164837 (h0 : functor.add_const (topological_space (has_neg_part Type)) environment.implicit_infer_kind) : @t0_space.{1} (has_neg_part.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_neg_part.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_164838 (h0 : functor.add_const (filter (add_comm_monoid environment.implicit_infer_kind)) unsigned) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_164839 (h0 : ring (boolean_algebra.core (has_to_string pos))) : strong_rank_condition (boolean_algebra.core (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_164840 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (semigroup.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_164841 (h0 : filter (comm_ring (has_append (set to_additive.value_type)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_164842 (h1 : set (add_comm_semigroup linarith.ineq -> ereal)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_164843 (h0 : function.extfun Type group) : @normalizer_condition.{0} (ordered_comm_ring.{0} name) (@function.extfun_app.{2 1} Type group.{0} h0 (ordered_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_164844 (h0 : semiring (semiring (has_norm unsigned))) : is_noetherian_ring (semiring (has_norm unsigned)) := sorry --non-trivial
lemma new_lemma_164845 (h0 : ring (boolean_algebra.core (has_neg_part name))) : rank_condition (boolean_algebra.core (has_neg_part name)) := sorry --non-trivial
lemma new_lemma_164846 (h0 : group (with_one linarith.ineq)) : normalizer_condition (with_one linarith.ineq) := sorry --non-trivial
lemma new_lemma_164847 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @t1_space.{0} (has_nndist.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (has_nndist.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_164848 (h0 : functor.add_const (function.extfun (Type 1) group) linarith.comp) : @group.fg.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) group.{1}) linarith.comp h0) (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_164849 (h0 : uniform_space (normed_comm_ring (has_to_string Type))) : separated_space (normed_comm_ring (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_164850 (h0 : functor.add_const (semiring (plift name)) congr_arg_kind) : @is_noetherian_ring.{1} (plift.{1} name) (@functor.add_const.run.{1 0} (semiring.{1} (plift.{1} name)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_164851 (h0 : topological_space (comm_group (add_comm_monoid (finset environment.implicit_infer_kind)))) : path_connected_space (comm_group (add_comm_monoid (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_164852 (h0 : functor.add_const (topological_space (measurable_space.dynkin_system empty)) num) : @totally_separated_space.{0} (measurable_space.dynkin_system.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (measurable_space.dynkin_system.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_164853 (h0 : function.extfun Type ring) : @rank_condition.{0} (distrib_lattice.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} h0 (distrib_lattice.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_164854 (h0 : not (add_monoid (has_star unsigned) -> false)) : @add_monoid.fg.{0} (has_star.{0} unsigned) (@classical.by_contradiction'.{1} (add_monoid.{0} (has_star.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_164855 (h0 : has_Inf (canonically_linear_ordered_monoid pos) -> has_Inf (canonically_linear_ordered_monoid pos) -> Prop) : transitive h0 := sorry --non-trivial
lemma new_lemma_164856 (h0 : topological_space (cancel_monoid unsigned)) : preconnected_space (cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_164857 (h0 : ring (non_unital_non_assoc_semiring (has_lt linarith.comp_source))) : rank_condition (non_unital_non_assoc_semiring (has_lt linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_164858 (h0 : functor.add_const (list (has_to_string pos)) (has_add (has_add linarith.comp))) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_164859 (h0 : functor.add_const (finset (semigroup linarith.comp)) (finset (finset (finset linarith.comp)))) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_164860 (h0 : topological_space (plift (semiring empty))) : normal_space (plift (semiring empty)) := sorry --non-trivial
lemma new_lemma_164861 (h0 : functor.add_const (group (semigroup pos)) environment.implicit_infer_kind) : @normalizer_condition.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (semigroup.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_164862 (h0 : topological_space (mul_zero_class unsigned)) : preconnected_space (mul_zero_class unsigned) := sorry --non-trivial
lemma new_lemma_164863 (h0 : functor.add_const (topological_space (omega_complete_partial_order unsigned)) empty) : @locally_compact_space.{0} (omega_complete_partial_order.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (omega_complete_partial_order.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_164864 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (has_neg.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_neg.{0} empty))  := sorry --non-trivial
lemma new_lemma_164865 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (complete_semilattice_Sup.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (complete_semilattice_Sup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_164866 (h0 : topological_space (add_semigroup (option empty))) : path_connected_space (add_semigroup (option empty)) := sorry --non-trivial
lemma new_lemma_164867 (h0 : functor.add_const (topological_space (add_comm_monoid environment.implicit_infer_kind)) linarith.comp) : @locally_compact_space.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_164868 (h0 : functor.add_const (add_group (ring pos)) Type) : @is_add_cyclic.{0} (ring.{0} pos) (@functor.add_const.run.{0 1} (add_group.{0} (ring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_164869 (h0 : function.extfun Type group) : @is_cyclic.{0} (mul_zero_class.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (mul_zero_class.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_164870 (h0 : fin has_zero.zero) : @group.fg.{0} (normed_group.{0} (has_nnnorm.{0} linarith.ineq)) (@matrix.vec_empty.{0} (group.{0} (normed_group.{0} (has_nnnorm.{0} linarith.ineq))) h0)  := sorry --non-trivial
lemma new_lemma_164871 (h0 : ordered_add_comm_monoid (has_zero (has_to_string Type))) : archimedean (has_zero (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_164872 (h0 : topological_space (simple_graph name)) : topological_space.separable_space (simple_graph name) := sorry --non-trivial
lemma new_lemma_164873 (h0 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} (has_nnnorm.{0} fun_info) (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h0) (has_nnnorm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_164874 (h0 : has_mem.mem (has_emptyc fun_info) has_emptyc.emptyc) : @discrete_topology.{0} (has_emptyc.{0} fun_info) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_emptyc.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_164875 (h0 : add_group (with_bot (has_norm (has_norm empty)))) : is_add_cyclic (with_bot (has_norm (has_norm empty))) := sorry --non-trivial
lemma new_lemma_164876 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (random_gen.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (random_gen.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_164877 (h0 : ordered_comm_monoid (has_nndist (has_to_string (ring (finset linarith.comp))))) : has_exists_mul_of_le (has_nndist (has_to_string (ring (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_164878 (h3 : ring (semi_normed_comm_ring linarith.ineq)) : strong_rank_condition (semi_normed_comm_ring linarith.ineq) := sorry --non-trivial
lemma new_lemma_164879 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem monoid)) : @monoid.fg.{0} (measurable_space.{0} num) (@function.extfun_app.{2 1} Type monoid.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) monoid.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) monoid.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (measurable_space.{0} num))  := sorry --non-trivial
lemma new_lemma_164880 (h0 : complete_lattice (has_compl (random_gen (mul_one_class reducibility_hints)))) : is_compactly_generated (has_compl (random_gen (mul_one_class reducibility_hints))) := sorry --non-trivial
lemma new_lemma_164881 (h0 : not (topological_space (with_bot empty) -> false)) : @locally_compact_space.{0} (with_bot.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (with_bot.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_164882 (h0 : complete_lattice (ordered_comm_ring real)) : complete_lattice.is_Sup_finite_compact (ordered_comm_ring real) := sorry --non-trivial
lemma new_lemma_164883 (h0 : functor.add_const (topological_space (has_to_string pos)) name) : @discrete_topology.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_164884 (h0 : list (has_nndist (normed_comm_ring Type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_164885 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (measurable_space.dynkin_system.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (measurable_space.dynkin_system.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_164886 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_164887 (h0 : functor.add_const (topological_space (add_comm_monoid pos)) (has_add Type)) : @totally_disconnected_space.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (add_comm_monoid.{0} pos)) (has_add.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_164888 (h0 : fin has_zero.zero) : @t0_space.{0} (sub_neg_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)) (sub_neg_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_164889 (h0 : topological_space (has_Inf (has_Inf (has_Inf (has_Inf (ordered_comm_monoid pos)))))) : sequential_space (has_Inf (has_Inf (has_Inf (has_Inf (ordered_comm_monoid pos))))) := sorry --non-trivial
lemma new_lemma_164890 (h0 : functor.add_const (topological_space (add_cancel_monoid linarith.comp)) (has_neg (has_Inf linarith.comp))) : @path_connected_space.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} linarith.comp)) (has_neg.{0} (has_Inf.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_164891 (h0 : functor.add_const (topological_space (ordered_comm_group congr_arg_kind)) congr_arg_kind) : @loc_path_connected_space.{0} (ordered_comm_group.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_group.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_164892 (h0 : add_group (add_left_cancel_monoid to_additive.value_type)) : is_add_cyclic (add_left_cancel_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_164893 (h0 : topological_space (add_cancel_monoid (has_add name))) : regular_space (add_cancel_monoid (has_add name)) := sorry --non-trivial
lemma new_lemma_164894 (h0 : uniform_space (add_right_cancel_monoid (has_top congr_arg_kind))) : separated_space (add_right_cancel_monoid (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_164895 (h0 : functor.add_const (semiring (mul_zero_class name)) (mul_zero_class Type)) : @is_noetherian_ring.{0} (mul_zero_class.{0} name) (@functor.add_const.run.{0 1} (semiring.{0} (mul_zero_class.{0} name)) (mul_zero_class.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_164896 (h1 : topological_space (semiring congr_arg_kind)) : path_connected_space (semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_164897 (h0 : topological_space (canonically_ordered_comm_semiring (boolean_algebra.core Type))) : sequential_space (canonically_ordered_comm_semiring (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_164898 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (normed_group.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (normed_group.{0} num))  := sorry --non-trivial
lemma new_lemma_164899 (h1 : not (ring (with_one to_additive.value_type) -> false)) : @rank_condition.{0} (with_one.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (with_one.{0} to_additive.value_type)) h1)  := sorry --non-trivial
lemma new_lemma_164900 (h0 : functor.add_const (topological_space (boolean_algebra real)) Type) : @totally_disconnected_space.{0} (boolean_algebra.{0} real) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.{0} real)) Type h0)  := sorry --non-trivial
lemma new_lemma_164901 (h0 : functor.add_const (ordered_add_comm_monoid (has_well_founded unsigned)) unsigned) : @archimedean.{1} (has_well_founded.{1} unsigned) (@functor.add_const.run.{1 0} (ordered_add_comm_monoid.{1} (has_well_founded.{1} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_164902 (h0 : topological_space (id (has_norm linarith.comp))) : totally_separated_space (id (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_164903 (h1 : ring (distrib (mul_one_class string.iterator_imp))) : rank_condition (distrib (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_164904 (h0 : functor.add_const (group (complete_distrib_lattice ennreal)) linarith.comp) : @group.fg.{0} (complete_distrib_lattice.{0} ennreal) (@functor.add_const.run.{0 0} (group.{0} (complete_distrib_lattice.{0} ennreal)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_164905 (h0 : not (has_mem.mem (random_gen congr_arg_kind) has_emptyc.emptyc -> false)) : @monoid.fg.{0} (random_gen.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type monoid.{0} (random_gen.{0} congr_arg_kind) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} congr_arg_kind) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_164906 (h0 : complete_lattice (cancel_monoid (option (option unsigned)))) : is_compactly_generated (cancel_monoid (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_164907 (h0 : has_mem.mem (semiring linarith.comp) has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} (semiring.{0} linarith.comp) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (semiring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_164908 (h0 : function.extfun Type topological_space) : @normal_space.{0} (complete_distrib_lattice.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} real))  := sorry --non-trivial
lemma new_lemma_164909 (h0 : functor.add_const (ring (group_with_zero num)) num) : @is_principal_ideal_ring.{0} (group_with_zero.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (group_with_zero.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_164910 (h0 : ring (normed_linear_ordered_group congr_arg_kind)) : is_principal_ideal_ring (normed_linear_ordered_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_164911 (h0 : functor.add_const Prop (monoid_with_zero congr_arg_kind)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_164912 (h1 : topological_space (fintype char)) : t0_space (fintype char) := sorry --non-trivial
lemma new_lemma_164913 (h0 : functor.add_const (topological_space (boolean_algebra pos)) linarith.comp) : @path_connected_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_164914 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (semiring.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_164915 (h0 : has_mem.mem (linear_ordered_semiring linarith.comp) has_emptyc.emptyc) : @path_connected_space.{0} (linear_ordered_semiring.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (linear_ordered_semiring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_164916 (h0 : complete_lattice (order_dual (denumerable fun_info))) : complete_lattice.is_Sup_finite_compact (order_dual (denumerable fun_info)) := sorry --non-trivial
lemma new_lemma_164917 (h0 : topological_space (add_right_cancel_monoid (semiring (semiring empty)))) : totally_separated_space (add_right_cancel_monoid (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_164918 (h0 : ordered_comm_monoid (simple_graph (has_add Type))) : has_exists_mul_of_le (simple_graph (has_add Type)) := sorry --non-trivial
lemma new_lemma_164919 (h0 : complete_lattice (comm_semigroup (sub_neg_monoid Type))) : complete_lattice.is_Sup_finite_compact (comm_semigroup (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_164920 (h0 : functor.add_const (topological_space (left_cancel_monoid num)) congr_arg_kind) : @path_connected_space.{0} (left_cancel_monoid.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_164921 (h0 : ring (has_zero (normed_comm_ring pos))) : rank_condition (has_zero (normed_comm_ring pos)) := sorry --non-trivial
lemma new_lemma_164922 (h0 : topological_space (has_nndist (option (comm_monoid (option (option empty)))))) : preirreducible_space (has_nndist (option (comm_monoid (option (option empty))))) := sorry --non-trivial
lemma new_lemma_164923 (h0 : not (function.extfun Type topological_space -> false)) : @preirreducible_space.{0} (has_one.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_164924 (h0 : group (has_top (random_gen linarith.ineq))) : group.fg (has_top (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_164925 (h0 : functor.add_const (finset (left_cancel_monoid num)) congr_arg_kind) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_164926 (h0 : topological_space (has_add (has_to_string (has_to_string (has_to_string (has_to_string pos)))))) : sequential_space (has_add (has_to_string (has_to_string (has_to_string (has_to_string pos))))) := sorry --non-trivial
lemma new_lemma_164927 (h0 h1 : multiset (nondiscrete_normed_field enat)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_164928 (h0 : topological_space (comm_semigroup (sub_neg_monoid linarith.comp))) : totally_disconnected_space (comm_semigroup (sub_neg_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_164929 (h0 : topological_space (linear_ordered_field num)) : totally_disconnected_space (linear_ordered_field num) := sorry --non-trivial
lemma new_lemma_164930 (h2 : complete_lattice (has_compl linarith.comp_source)) : is_compactly_generated (has_compl linarith.comp_source) := sorry --non-trivial
lemma new_lemma_164931 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (with_zero.{0} fun_info) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (with_zero.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_164932 (h0 : has_mem.mem (has_norm num) has_emptyc.emptyc) : @strong_rank_condition.{0} (has_norm.{0} num) (@finset.pi.empty.{1 0} Type ring.{0} (has_norm.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_164933 (h0 : functor.add_const (topological_space (semigroup Type)) (has_to_string environment.implicit_infer_kind)) : @topological_space.separable_space.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (semigroup.{1} Type)) (has_to_string.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_164934 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (finset.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (finset.{0} empty))  := sorry --non-trivial
lemma new_lemma_164935 (h0 : topological_space (omega_complete_partial_order to_additive.value_type)) : totally_disconnected_space (omega_complete_partial_order to_additive.value_type) := sorry --non-trivial
lemma new_lemma_164936 (h0 : functor.add_const (ring (complete_distrib_lattice Type)) Type) : @is_principal_ideal_ring.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 1} (ring.{1} (complete_distrib_lattice.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_164937 (h0 : monoid (has_edist (semiring unsigned))) : monoid.fg (has_edist (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_164938 (h0 : add_monoid (add_semigroup congr_arg_kind)) : add_monoid.fg (add_semigroup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_164939 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (filter.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (filter.{0} num))  := sorry --non-trivial
lemma new_lemma_164940 (h0 : finset (ordered_comm_monoid (ordered_ring Type))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_164941 (h0 : topological_space (canonically_ordered_comm_semiring pos)) : preconnected_space (canonically_ordered_comm_semiring pos) := sorry --non-trivial
lemma new_lemma_164942 (h0 : monoid (finset (boolean_algebra (mul_one_class linarith.comp)))) : monoid.fg (finset (boolean_algebra (mul_one_class linarith.comp))) := sorry --non-trivial
lemma new_lemma_164943 (h1 : not (ring (comm_ring to_additive.value_type) -> false)) : @strong_rank_condition.{0} (comm_ring.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (comm_ring.{0} to_additive.value_type)) h1)  := sorry --non-trivial
lemma new_lemma_164944 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_one.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_164945 (h0 : group (monoid (option (option (option (option unsigned)))))) : group.fg (monoid (option (option (option (option unsigned))))) := sorry --non-trivial
lemma new_lemma_164946 (h0 : topological_space (has_to_string (option num))) : preirreducible_space (has_to_string (option num)) := sorry --non-trivial
lemma new_lemma_164947 (h0 : complete_lattice (normed_group (has_top linarith.ineq))) : is_atomistic (normed_group (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_164948 (h3 : topological_space (topological_space fun_info)) : t0_space (topological_space fun_info) := sorry --non-trivial
lemma new_lemma_164949 (h0 : function.extfun Type topological_space) : @t0_space.{0} (left_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (left_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_164950 (h0 : finset (has_add (finset Type))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_164951 (h0 : functor.add_const (topological_space (normed_comm_ring Type)) (has_zero Type)) : @regular_space.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (normed_comm_ring.{1} Type)) (has_zero.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_164952 (h0 : functor.add_const (topological_space (boolean_algebra.core linarith.comp)) pos) : @totally_separated_space.{0} (boolean_algebra.core.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_164953 (h0 : add_group (finset (has_add (has_add environment.implicit_infer_kind)))) : is_add_cyclic (finset (has_add (has_add environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_164954 (h0 : ring (normed_lattice_add_comm_group linarith.comp)) : is_principal_ideal_ring (normed_lattice_add_comm_group linarith.comp) := sorry --non-trivial
lemma new_lemma_164955 (h0 : topological_space (has_zero (option name))) : t0_space (has_zero (option name)) := sorry --non-trivial
lemma new_lemma_164956 (h0 : topological_space (linear_order unsigned)) : topological_space.separable_space (linear_order unsigned) := sorry --non-trivial
lemma new_lemma_164957 (h0 : uniform_space enat) (h1 : topological_space (uniform_space.separation_quotient enat)) : t0_space (uniform_space.separation_quotient enat) := sorry --non-trivial
lemma new_lemma_164958 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_to_string Type)) name) : @unique_factorization_monoid.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (cancel_comm_monoid_with_zero.{1} (has_to_string.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_164959 (h0 : functor.add_const (topological_space (measure_theory.measure_space num)) empty) : @totally_separated_space.{0} (measure_theory.measure_space.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (measure_theory.measure_space.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_164960 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (sub_neg_monoid.{0} name) (@function.extfun_app.{2 1} Type semiring.{0} h0 (sub_neg_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_164961 (h0 : uniform_space (linear_ordered_cancel_comm_monoid (option congr_arg_kind))) : separated_space (linear_ordered_cancel_comm_monoid (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_164962 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (group_with_zero.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (group_with_zero.{0} empty))  := sorry --non-trivial
lemma new_lemma_164963 (h0 : fin has_zero.zero) : matrix.vec_empty (matrix.vec_empty (id h0)) := sorry --non-trivial
lemma new_lemma_164964 (h0 : add_monoid (has_Inf (has_add pos))) : add_monoid.fg (has_Inf (has_add pos)) := sorry --non-trivial
lemma new_lemma_164965 (h0 : topological_space (complete_linear_order (option empty))) : discrete_topology (complete_linear_order (option empty)) := sorry --non-trivial
lemma new_lemma_164966 (h0 : semiring (has_bot Type)) : is_noetherian_ring (has_bot Type) := sorry --non-trivial
lemma new_lemma_164967 (h0 : topological_space (has_pos_part environment.implicit_infer_kind)) : totally_disconnected_space (has_pos_part environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_164968 (h0 : functor.add_const (function.extfun Type topological_space) unsigned) : @t1_space.{0} (has_nndist.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) unsigned h0) (has_nndist.{0} name))  := sorry --non-trivial
lemma new_lemma_164969 (h1 : ring (fintype (has_nnnorm char))) : strong_rank_condition (fintype (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_164970 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @normal_space.{0} (has_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (has_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_164971 (h0 : group (metric_space (has_top (has_top empty)))) : group.fg (metric_space (has_top (has_top empty))) := sorry --non-trivial
lemma new_lemma_164972 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @complete_space.{0} (has_top.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) uniform_space.{0}) (has_top.{0} empty))  := sorry --non-trivial
lemma new_lemma_164973 (h0 : functor.add_const (group (cancel_monoid name)) name) : @is_simple_group.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (group.{0} (cancel_monoid.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_164974 (h0 : topological_space (id (semiring (semiring empty)))) : locally_compact_space (id (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_164975 (h0 : topological_space (add_right_cancel_monoid (semiring (semiring congr_arg_kind)))) : path_connected_space (add_right_cancel_monoid (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_164976 (h0 : functor.add_const (semiring (boolean_algebra pos)) Type) : @is_noetherian_ring.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 1} (semiring.{0} (boolean_algebra.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_164977 (h0 : add_group (has_to_string (option (has_add (finset (option (has_add ennreal))))))) : is_add_cyclic (has_to_string (option (has_add (finset (option (has_add ennreal)))))) := sorry --non-trivial
lemma new_lemma_164978 (h1 : group (has_emptyc (random_gen to_additive.value_type))) : is_cyclic (has_emptyc (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_164979 (h0 : topological_space (complete_semilattice_Sup (has_norm (random_gen (with_one (has_norm fun_info)))))) : t0_space (complete_semilattice_Sup (has_norm (random_gen (with_one (has_norm fun_info))))) := sorry --non-trivial
lemma new_lemma_164980 (h0 : ordered_add_comm_monoid (generalized_boolean_algebra (has_add (has_neg Type)))) : archimedean (generalized_boolean_algebra (has_add (has_neg Type))) := sorry --non-trivial
lemma new_lemma_164981 (h0 : complete_lattice (fintype char)) : is_compactly_generated (fintype char) := sorry --non-trivial
lemma new_lemma_164982 (h2 h3 : multiset (mul_one_class fun_info)) : multiset.disjoint h2 h3 := sorry --non-trivial
lemma new_lemma_164983 (h0 : not (complete_lattice (has_norm congr_arg_kind) -> false)) : @is_compactly_generated.{0} (has_norm.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_norm.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_164984 (h0 : group (complete_semilattice_Sup (random_gen linarith.ineq))) : is_cyclic (complete_semilattice_Sup (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_164985 (h0 : topological_space (has_Sup (semiring num))) : t1_space (has_Sup (semiring num)) := sorry --non-trivial
lemma new_lemma_164986 (h1 : complete_lattice (measurable_space string_imp)) : is_atomistic (measurable_space string_imp) := sorry --non-trivial
lemma new_lemma_164987 (h0 : topological_space (pseudo_metric_space (option (option empty)))) : preirreducible_space (pseudo_metric_space (option (option empty))) := sorry --non-trivial
lemma new_lemma_164988 (h0 : complete_lattice (monoid_with_zero pos)) : complete_lattice.is_Sup_finite_compact (monoid_with_zero pos) := sorry --non-trivial
lemma new_lemma_164989 (h0 : function.extfun (multiset Type) (has_mem.mem (with_bot linarith.comp))) : @preirreducible_space.{0} (with_bot.{0} linarith.comp) (@multiset.pi.empty.{1 0} Type topological_space.{0} (with_bot.{0} linarith.comp) (@function.extfun_app.{2 0} (multiset.{1} Type) (@has_mem.mem.{1 1} Type (multiset.{1} Type) (@multiset.has_mem.{1} Type) (with_bot.{0} linarith.comp)) h0 (@has_zero.zero.{1} (multiset.{1} Type) (@multiset.has_zero.{1} Type))))  := sorry --non-trivial
lemma new_lemma_164990 (h0 : topological_space (monoid (option empty))) : locally_compact_space (monoid (option empty)) := sorry --non-trivial
lemma new_lemma_164991 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem ring)) : @is_domain.{0} (@id.{2} Type linarith.ineq) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) ring.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (@id.{2} Type linarith.ineq))  := sorry --non-trivial
lemma new_lemma_164992 (h0 : add_group (has_append (has_nnnorm (has_nnnorm fun_info)))) : is_add_cyclic (has_append (has_nnnorm (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_164993 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (boolean_algebra.core.{0} name) (@function.extfun_app.{2 1} Type semiring.{0} h0 (boolean_algebra.core.{0} name))  := sorry --non-trivial
lemma new_lemma_164994 (h0 : complete_lattice (comm_ring (random_gen (random_gen linarith.ineq)))) : is_compactly_generated (comm_ring (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_164995 (h0 : monoid (comm_group Type)) : monoid.fg (comm_group Type) := sorry --non-trivial
lemma new_lemma_164996 (h0 : topological_space (normed_field (has_lt linarith.comp_source))) : t0_space (normed_field (has_lt linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_164997 (h0 : complete_lattice (has_star (add_right_cancel_monoid empty))) : complete_lattice.is_Sup_finite_compact (has_star (add_right_cancel_monoid empty)) := sorry --non-trivial
lemma new_lemma_164998 (h0 : ring (normed_field (comm_ring (denumerable char)))) : is_domain (normed_field (comm_ring (denumerable char))) := sorry --non-trivial
lemma new_lemma_164999 (h0 : topological_space (random_gen (has_norm (random_gen num)))) : totally_separated_space (random_gen (has_norm (random_gen num))) := sorry --non-trivial
lemma new_lemma_165000 (h0 : complete_lattice (has_bot (ordered_comm_ring real))) : is_compactly_generated (has_bot (ordered_comm_ring real)) := sorry --non-trivial
lemma new_lemma_165001 (h0 : group (normed_lattice_add_comm_group (has_add pos))) : normalizer_condition (normed_lattice_add_comm_group (has_add pos)) := sorry --non-trivial
lemma new_lemma_165002 (h0 : functor.add_const (add_monoid (has_zero linarith.comp)) environment.implicit_infer_kind) : @add_monoid.fg.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_zero.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_165003 (h0 : function.extfun (Type 1) complete_lattice) : @complete_lattice.is_Sup_finite_compact.{1} (plift.{1} linarith.comp) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} h0 (plift.{1} linarith.comp))  := sorry --non-trivial
lemma new_lemma_165004 (h0 : ring (option (has_top (semiring (has_top (has_top num)))))) : strong_rank_condition (option (has_top (semiring (has_top (has_top num))))) := sorry --non-trivial
lemma new_lemma_165005 (h0 : ordered_add_comm_monoid (finset (finset pos))) : archimedean (finset (finset pos)) := sorry --non-trivial
lemma new_lemma_165006 (h0 : not (topological_space (non_assoc_semiring congr_arg_kind) -> false)) : @t0_space.{0} (non_assoc_semiring.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (non_assoc_semiring.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_165007 (h0 : functor.comp topological_space add_cancel_monoid environment.implicit_infer_kind) : @sequential_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} add_cancel_monoid.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_165008 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} environment.implicit_infer_kind (@function.extfun_app.{2 1} Type topological_space.{0} h0 environment.implicit_infer_kind)  := sorry --non-trivial
lemma new_lemma_165009 (h0 : ring (has_to_string (option name))) : rank_condition (has_to_string (option name)) := sorry --non-trivial
lemma new_lemma_165010 (h0 : complete_lattice (add_comm_monoid real)) : is_compactly_generated (add_comm_monoid real) := sorry --non-trivial
lemma new_lemma_165011 (h0 : add_group (linear_ordered_semiring (semiring (semiring num)))) : is_add_cyclic (linear_ordered_semiring (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_165012 (h0 : semiring (add_comm_monoid (finset name))) : is_noetherian_ring (add_comm_monoid (finset name)) := sorry --non-trivial
lemma new_lemma_165013 (h0 : list (linear_ordered_field ennreal)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_165014 (h0 : topological_space (mul_zero_class (semiring empty))) : totally_disconnected_space (mul_zero_class (semiring empty)) := sorry --non-trivial
lemma new_lemma_165015 (h0 : group (finset (option pos))) : normalizer_condition (finset (option pos)) := sorry --non-trivial
lemma new_lemma_165016 (h0 : ordered_comm_monoid (cancel_monoid (has_add pos))) : has_exists_mul_of_le (cancel_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_165017 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_165018 (h0 : add_monoid (add_cancel_monoid (boolean_algebra (boolean_algebra linarith.comp)))) : add_monoid.fg (add_cancel_monoid (boolean_algebra (boolean_algebra linarith.comp))) := sorry --non-trivial
lemma new_lemma_165019 (h0 : function.extfun Type ring) : @rank_condition.{0} (monoid.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_165020 (h0 : monoid (has_top (has_top (has_top (has_top (has_top to_additive.value_type)))))) : monoid.fg (has_top (has_top (has_top (has_top (has_top to_additive.value_type))))) := sorry --non-trivial
lemma new_lemma_165021 (h0 : ring (encodable (random_gen (has_inv to_additive.value_type)))) : is_domain (encodable (random_gen (has_inv to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_165022 (h0 : functor.add_const (filter (ordered_comm_ring linarith.comp)) (ring Type)) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_165023 (h0 : uniform_space (boolean_algebra.core (option empty))) : complete_space (boolean_algebra.core (option empty)) := sorry --non-trivial
lemma new_lemma_165024 (h1 : topological_space (has_norm num)) : path_connected_space (has_norm num) := sorry --non-trivial
lemma new_lemma_165025 (h0 : functor.add_const (topological_space (add_semigroup empty)) (semiring empty)) : @loc_path_connected_space.{0} (add_semigroup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_semigroup.{0} empty)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_165026 (h0 : functor.add_const (semiring (has_pos_part name)) name) : @is_noetherian_ring.{0} (has_pos_part.{0} name) (@functor.add_const.run.{0 0} (semiring.{0} (has_pos_part.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_165027 (h0 : function.extfun (finset Type) (has_mem.mem (with_one congr_arg_kind))) : @totally_disconnected_space.{0} (with_one.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_one.{0} congr_arg_kind) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_one.{0} congr_arg_kind)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_165028 (h0 : add_group (with_bot (has_norm linarith.ineq))) : is_add_cyclic (with_bot (has_norm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_165029 (h0 : complete_lattice (boolean_algebra.core (comm_group Type))) : is_atomistic (boolean_algebra.core (comm_group Type)) := sorry --non-trivial
lemma new_lemma_165030 (h0 : ring (has_pos_part (has_pos_part Type))) : is_principal_ideal_ring (has_pos_part (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_165031 (h0 : topological_space (plift unsigned)) : path_connected_space (plift unsigned) := sorry --non-trivial
lemma new_lemma_165032 (h0 : ring (finset (ordered_ring (has_add name)))) : strong_rank_condition (finset (ordered_ring (has_add name))) := sorry --non-trivial
lemma new_lemma_165033 (h0 : topological_space (left_cancel_monoid (option empty))) : t0_space (left_cancel_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_165034 (h0 : has_mem.mem (with_bot fun_info) has_emptyc.emptyc) : @rank_condition.{0} (with_bot.{0} fun_info) (@finset.pi.empty.{1 0} Type ring.{0} (with_bot.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_165035 (h0 : not (uniform_space (has_union empty) -> false)) : @complete_space.{0} (has_union.{0} empty) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_union.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_165036 (h0 : not (topological_space (linear_ordered_semiring congr_arg_kind) -> false)) : @preirreducible_space.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_semiring.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_165037 (h0 : uniform_space (has_pos_part (finset linarith.comp))) : complete_space (has_pos_part (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_165038 (h0 : add_monoid (ring pos)) : add_monoid.fg (ring pos) := sorry --non-trivial
lemma new_lemma_165039 (h0 : function.extfun Type topological_space) : @t0_space.{0} (boolean_algebra.core.{0} (has_nndist.{0} name)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} (has_nndist.{0} name)))  := sorry --non-trivial
lemma new_lemma_165040 (h1 : has_mem.mem linarith.comp has_emptyc.emptyc) : @is_domain.{0} linarith.comp (@finset.pi.empty.{1 0} Type ring.{0} linarith.comp h1)  := sorry --non-trivial
lemma new_lemma_165041 (h0 : ordered_comm_monoid (has_pos_part (boolean_algebra.core linarith.comp))) : has_exists_mul_of_le (has_pos_part (boolean_algebra.core linarith.comp)) := sorry --non-trivial
lemma new_lemma_165042 (h0 : list (monoid (has_neg (has_neg (has_neg (has_neg empty)))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_165043 (h0 : group (semigroup (option name))) : group.fg (semigroup (option name)) := sorry --non-trivial
lemma new_lemma_165044 (h0 : functor.add_const (group (has_to_string name)) linarith.comp) : @is_cyclic.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (group.{0} (has_to_string.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_165045 (h0 : has_mem.mem (measurable_space linarith.comp_source) has_zero.zero) : @is_add_cyclic.{0} (measurable_space.{0} linarith.comp_source) (@multiset.pi.empty.{1 0} Type add_group.{0} (measurable_space.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_165046 (h0 : function.extfun Type (functor.add_const (topological_space empty))) : t0_space empty := sorry --non-trivial
lemma new_lemma_165047 (h1 : function.extfun Type list) : list.nodup (function.extfun_app h1 linarith.ineq) := sorry --non-trivial
lemma new_lemma_165048 (h1 : function.extfun Type ring) : @is_domain.{0} (normed_group.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} h1 (normed_group.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_165049 (h0 : function.extfun nat fin) : @is_cyclic.{0} (has_nndist.{0} linarith.comp) (@matrix.vec_empty.{0} (group.{0} (has_nndist.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_165050 (h0 : topological_space (add_group (measurable_space.dynkin_system num))) : t0_space (add_group (measurable_space.dynkin_system num)) := sorry --non-trivial
lemma new_lemma_165051 (h0 : topological_space (has_star (semiring num))) : totally_disconnected_space (has_star (semiring num)) := sorry --non-trivial
lemma new_lemma_165052 (h0 : functor.add_const (ring (has_add Type)) Type) : @is_principal_ideal_ring.{1} (has_add.{1} Type) (@functor.add_const.run.{1 1} (ring.{1} (has_add.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_165053 (h0 : uniform_space (has_zero (has_neg (ring (has_neg linarith.comp))))) : separated_space (has_zero (has_neg (ring (has_neg linarith.comp)))) := sorry --non-trivial
lemma new_lemma_165054 (h0 : ring (option pos)) : is_domain (option pos) := sorry --non-trivial
lemma new_lemma_165055 (h0 : has_mem.mem (has_one empty) has_emptyc.emptyc) : @path_connected_space.{0} (has_one.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_one.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_165056 (h0 : functor.add_const (add_group (ring name)) linarith.comp) : @is_add_cyclic.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (add_group.{0} (ring.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_165057 (h0 : function.extfun Type group) : @normalizer_condition.{0} (filter.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (filter.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_165058 (h0 : topological_space (ordered_semiring unsigned)) : t0_space (ordered_semiring unsigned) := sorry --non-trivial
lemma new_lemma_165059 (h0 : (char -> fun_info) -> (char -> fun_info) -> Prop) (h1 : char -> fun_info) : set.separates_points (relation.join h0 h1) := sorry --non-trivial
lemma new_lemma_165060 (h0 : topological_space (cancel_monoid Type)) : irreducible_space (cancel_monoid Type) := sorry --non-trivial
lemma new_lemma_165061 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (has_pos_part.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_pos_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_165062 (h0 : add_monoid (ordered_cancel_add_comm_monoid pos)) : add_monoid.fg (ordered_cancel_add_comm_monoid pos) := sorry --non-trivial
lemma new_lemma_165063 (h0 : complete_lattice (add_comm_semigroup fun_info)) : complete_lattice.is_Sup_finite_compact (add_comm_semigroup fun_info) := sorry --non-trivial
lemma new_lemma_165064 (h0 : list (has_neg (semigroup unsigned))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_165065 (h0 : topological_space (has_sub (semiring num))) : totally_separated_space (has_sub (semiring num)) := sorry --non-trivial
lemma new_lemma_165066 (h0 : ordered_comm_monoid (has_zero (finset Type))) : has_exists_mul_of_le (has_zero (finset Type)) := sorry --non-trivial
lemma new_lemma_165067 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (complete_semilattice_Sup.{0} fun_info) (@function.extfun_app.{2 1} Type add_group.{0} h0 (complete_semilattice_Sup.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_165068 (h0 : ring (with_one (has_norm (random_gen num)))) : rank_condition (with_one (has_norm (random_gen num))) := sorry --non-trivial
lemma new_lemma_165069 (h0 : uniform_space (ring (has_add pos))) : complete_space (ring (has_add pos)) := sorry --non-trivial
lemma new_lemma_165070 (h0 : topological_space (semigroup (option (has_add name)))) : preirreducible_space (semigroup (option (has_add name))) := sorry --non-trivial
lemma new_lemma_165071 (h0 : group (add_group (linear_ordered_semiring congr_arg_kind))) : normalizer_condition (add_group (linear_ordered_semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_165072 (h0 : function.extfun (Type 1) ordered_add_comm_monoid) : @archimedean.{1} (has_pos_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_add_comm_monoid.{1} h0 (has_pos_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_165073 (h0 : functor.add_const (filter (finset Type)) (ring Type)) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_165074 (h0 : ring (ordered_comm_ring (has_nndist (finset (semigroup Type))))) : strong_rank_condition (ordered_comm_ring (has_nndist (finset (semigroup Type)))) := sorry --non-trivial
lemma new_lemma_165075 (h0 : topological_space (has_sub (has_top unsigned))) : irreducible_space (has_sub (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_165076 (h0 : functor.add_const (function.extfun Type topological_space) name) : @t1_space.{0} (ordered_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (ordered_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_165077 (h0 : complete_lattice (distrib_lattice to_additive.value_type)) : is_atomistic (distrib_lattice to_additive.value_type) := sorry --non-trivial
lemma new_lemma_165078 (h0 : add_group (with_bot (has_top num))) : is_add_cyclic (with_bot (has_top num)) := sorry --non-trivial
lemma new_lemma_165079 (h0 : topological_space (has_ssubset (has_norm (has_ssubset fun_info)))) : t0_space (has_ssubset (has_norm (has_ssubset fun_info))) := sorry --non-trivial
lemma new_lemma_165080 (h0 : functor.add_const (ordered_add_comm_monoid (add_comm_monoid pos)) pos) : @archimedean.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (add_comm_monoid.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_165081 (h0 : topological_space (mul_zero_class (finset environment.implicit_infer_kind))) : topological_space.separable_space (mul_zero_class (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_165082 (h0 : set (has_le enat)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_165083 (h0 : functor.add_const (group (has_add pos)) Type) : @is_simple_group.{0} (has_add.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (has_add.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_165084 (h0 : functor.add_const (group (mul_zero_class num)) (semiring empty)) : @group.fg.{0} (mul_zero_class.{0} num) (@functor.add_const.run.{0 0} (group.{0} (mul_zero_class.{0} num)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_165085 (h0 : topological_space (semigroup (finset environment.implicit_infer_kind))) : t0_space (semigroup (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_165086 (h0 : filter (dlist (random_gen to_additive.value_type))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_165087 (h0 : topological_space (ordered_comm_group congr_arg_kind)) : normal_space (ordered_comm_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_165088 (h0 : functor.add_const (group (semigroup Type)) unsigned) : @is_simple_group.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (semigroup.{1} Type)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_165089 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_165090 (h0 : functor.add_const (semiring (has_to_string pos)) pos) : @is_noetherian_ring.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (semiring.{0} (has_to_string.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_165091 (h0 : function.extfun nat fin) : @has_exists_mul_of_le.{0} (normed_lattice_add_comm_group.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) (@function.extfun_app.{1 1} nat fin (@matrix.vec_empty.{0} (function.extfun.{1 1} nat fin) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (@has_zero.zero.{0} nat nat.has_zero))) (normed_lattice_add_comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_165092 (h0 : uniform_space (with_one (has_inv (random_gen (has_inv (has_norm linarith.comp_source)))))) : complete_space (with_one (has_inv (random_gen (has_inv (has_norm linarith.comp_source))))) := sorry --non-trivial
lemma new_lemma_165093 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem group)) : @normalizer_condition.{0} (linear_ordered_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) group.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (linear_ordered_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_165094 (h0 : group (encodable (random_gen (random_gen char)))) : is_cyclic (encodable (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_165095 (h0 : preorder (mul_one_class fun_info)) (h1 : set (mul_one_class fun_info)) : set.is_pwo h1 := sorry --non-trivial
lemma new_lemma_165096 (h0 : monoid (has_zero (finset (ring (ring (ring linarith.comp)))))) : monoid.fg (has_zero (finset (ring (ring (ring linarith.comp))))) := sorry --non-trivial
lemma new_lemma_165097 (h0 : topological_space (linear_order (semiring (option (option unsigned))))) : normal_space (linear_order (semiring (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_165098 (h0 : function.extfun (Type 1) (functor.comp topological_space has_to_string)) : @preconnected_space.{1} (has_to_string.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} has_to_string.{1} Type (@function.extfun_app.{3 2} (Type 1) (functor.comp.{1 1 1} topological_space.{1} has_to_string.{1}) h0 Type))  := sorry --non-trivial
lemma new_lemma_165099 (h0 : functor.add_const (complete_lattice (complete_semilattice_Sup num)) (semiring num)) : @is_compactly_generated.{0} (complete_semilattice_Sup.{0} num) (@functor.add_const.run.{0 0} (complete_lattice.{0} (complete_semilattice_Sup.{0} num)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_165100 (h0 : ring (has_nnnorm (mul_one_class (has_lt reducibility_hints)))) : is_domain (has_nnnorm (mul_one_class (has_lt reducibility_hints))) := sorry --non-trivial
lemma new_lemma_165101 (h0 : topological_space (has_neg_part name)) : preconnected_space (has_neg_part name) := sorry --non-trivial
lemma new_lemma_165102 (h0 : add_group (semi_normed_comm_ring string_imp)) : is_add_cyclic (semi_normed_comm_ring string_imp) := sorry --non-trivial
lemma new_lemma_165103 (h0 : ordered_add_comm_monoid (has_add (has_add (has_add (has_add (has_add real)))))) : archimedean (has_add (has_add (has_add (has_add (has_add real))))) := sorry --non-trivial
lemma new_lemma_165104 (h0 : monoid (boolean_algebra.core (semigroup pos))) : monoid.fg (boolean_algebra.core (semigroup pos)) := sorry --non-trivial
lemma new_lemma_165105 (h0 : topological_space (normed_comm_ring (finset (has_add ennreal)))) : irreducible_space (normed_comm_ring (finset (has_add ennreal))) := sorry --non-trivial
lemma new_lemma_165106 (h0 : topological_space (boolean_algebra.core (finset Type))) : irreducible_space (boolean_algebra.core (finset Type)) := sorry --non-trivial
lemma new_lemma_165107 (h0 : ring (has_norm (random_gen fun_info))) : is_domain (has_norm (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_165108 (h0 : ordered_add_comm_monoid (normed_comm_ring (finset linarith.comp))) : archimedean (normed_comm_ring (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_165109 (h0 : function.extfun Type (prod (linear_ordered_comm_monoid_with_zero num))) : id_rel (function.extfun_app h0 (linear_ordered_comm_monoid_with_zero num)) := sorry --non-trivial
lemma new_lemma_165110 (h0 : functor.add_const (topological_space (has_neg_part environment.implicit_infer_kind)) name) : @totally_separated_space.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_165111 (h0 : topological_space (has_zero (normed_comm_ring name))) : normal_space (has_zero (normed_comm_ring name)) := sorry --non-trivial
lemma new_lemma_165112 (h0 : functor.add_const (topological_space (mul_zero_class ennreal)) unsigned) : @totally_disconnected_space.{0} (mul_zero_class.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_165113 (h0 : topological_space (semiring (has_union (semiring unsigned)))) : t0_space (semiring (has_union (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_165114 (h0 : ring (plift congr_arg_kind)) : is_domain (plift congr_arg_kind) := sorry --non-trivial
lemma new_lemma_165115 (h0 : function.extfun Type (prod (has_to_string pos))) : id_rel (function.extfun_app h0 (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_165116 (h0 : uniform_space (has_add environment.implicit_infer_kind)) : separated_space (has_add environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_165117 (h0 : monoid (canonically_linear_ordered_monoid (has_add real))) : monoid.fg (canonically_linear_ordered_monoid (has_add real)) := sorry --non-trivial
lemma new_lemma_165118 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (add_left_cancel_semigroup empty)) := sorry --non-trivial
lemma new_lemma_165119 (h0 : list (semigroup (has_neg pos))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_165120 (h0 : topological_space (add_comm_monoid (has_neg_part ennreal))) : totally_separated_space (add_comm_monoid (has_neg_part ennreal)) := sorry --non-trivial
lemma new_lemma_165121 (h0 : group (with_bot (semiring unsigned))) : group.fg (with_bot (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_165122 (h1 : topological_space (id string_imp)) : t0_space (id string_imp) := sorry --non-trivial
lemma new_lemma_165123 (h0 : uniform_space (add_group (semiring linarith.comp))) : complete_space (add_group (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_165124 (h0 : ring (canonically_ordered_monoid (has_neg (has_pos_part (has_neg (has_neg Type)))))) : rank_condition (canonically_ordered_monoid (has_neg (has_pos_part (has_neg (has_neg Type))))) := sorry --non-trivial
lemma new_lemma_165125 (h0 : uniform_space (has_star empty)) : complete_space (has_star empty) := sorry --non-trivial
lemma new_lemma_165126 (h0 : group (left_cancel_semigroup (semiring unsigned))) : group.fg (left_cancel_semigroup (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_165127 (h0 : topological_space (has_emptyc (random_gen (random_gen (random_gen fun_info))))) : totally_disconnected_space (has_emptyc (random_gen (random_gen (random_gen fun_info)))) := sorry --non-trivial
lemma new_lemma_165128 (h0 : set (set (normed_field char))) (h1 : set (normed_field char)) : measurable_space.dynkin_system.generate_has h0 h1 := sorry --non-trivial
lemma new_lemma_165129 (h0 : functor.add_const (topological_space (finset unsigned)) name) : @locally_compact_space.{0} (finset.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_165130 (h0 : has_mem.mem (random_gen fun_info) has_emptyc.emptyc) : @is_atomistic.{0} (random_gen.{0} fun_info) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (random_gen.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_165131 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (dlist to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_165132 (h0 : filter (has_one (semiring (has_norm linarith.comp)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_165133 (h0 : group (has_nndist ennreal)) : group.fg (has_nndist ennreal) := sorry --non-trivial
lemma new_lemma_165134 (h0 : set (add_comm_semigroup fun_info -> add_comm_semigroup linarith.ineq)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_165135 (h0 : complete_lattice (ordered_comm_monoid Type)) : is_compactly_generated (ordered_comm_monoid Type) := sorry --non-trivial
lemma new_lemma_165136 (h0 : ring (add_cancel_monoid (ring Type))) : is_domain (add_cancel_monoid (ring Type)) := sorry --non-trivial
lemma new_lemma_165137 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (simple_graph.{0} empty) (@function.extfun_app.{2 1} Type semiring.{0} h0 (simple_graph.{0} empty))  := sorry --non-trivial
lemma new_lemma_165138 (h0 : functor.add_const (topological_space (mul_zero_class empty)) num) : @totally_disconnected_space.{0} (mul_zero_class.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_165139 (h0 : set reducibility_hints) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_165140 (h0 : functor.add_const (topological_space (semigroup name)) name) : @preirreducible_space.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_165141 (h0 : function.extfun (Type 1) (functor.add_const (topological_space (boolean_algebra.core linarith.comp)))) : @preirreducible_space.{0} (boolean_algebra.core.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.core.{0} linarith.comp)) Type (@function.extfun_app.{3 1} (Type 1) (functor.add_const.{0 1} (topological_space.{0} (boolean_algebra.core.{0} linarith.comp))) h0 Type))  := sorry --non-trivial
lemma new_lemma_165142 (h0 : group (linear_ordered_semiring unsigned)) : group.fg (linear_ordered_semiring unsigned) := sorry --non-trivial
lemma new_lemma_165143 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @sequential_space.{0} (has_neg.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_neg.{0} name))  := sorry --non-trivial
lemma new_lemma_165144 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (boolean_algebra.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_165145 (h0 : topological_space (has_neg (metric_space (ring pos)))) : totally_disconnected_space (has_neg (metric_space (ring pos))) := sorry --non-trivial
lemma new_lemma_165146 (h0 : add_group (linear_ordered_semiring (random_gen (random_gen (random_gen num))))) : is_add_cyclic (linear_ordered_semiring (random_gen (random_gen (random_gen num)))) := sorry --non-trivial
lemma new_lemma_165147 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (normed_comm_ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_165148 (h0 : topological_space (random_gen (has_top num))) : t0_space (random_gen (has_top num)) := sorry --non-trivial
lemma new_lemma_165149 (h0 : functor.add_const (topological_space (add_comm_monoid linarith.comp)) Type) : @topological_space.separable_space.{0} (add_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (add_comm_monoid.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_165150 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (has_Sup.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_Sup.{0} empty))  := sorry --non-trivial
lemma new_lemma_165151 (h0 : topological_space (simple_graph name)) : totally_disconnected_space (simple_graph name) := sorry --non-trivial
lemma new_lemma_165152 (h0 : add_group (generalized_boolean_algebra (has_Inf linarith.comp))) : is_add_cyclic (generalized_boolean_algebra (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_165153 (h0 : not (complete_lattice (distrib char) -> false)) : @is_compactly_generated.{0} (distrib.{0} char) (@classical.by_contradiction'.{1} (complete_lattice.{0} (distrib.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_165154 (h0 : topological_space (random_gen (has_norm (has_norm (has_norm unsigned))))) : discrete_topology (random_gen (has_norm (has_norm (has_norm unsigned)))) := sorry --non-trivial
lemma new_lemma_165155 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (complete_linear_order.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_linear_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_165156 (h0 : functor.add_const (function.extfun Type complete_lattice) pos) : @is_compactly_generated.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) pos h0) (canonically_ordered_comm_semiring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_165157 (h0 : monoid (normed_comm_ring (comm_monoid (comm_monoid unsigned)))) : monoid.fg (normed_comm_ring (comm_monoid (comm_monoid unsigned))) := sorry --non-trivial
lemma new_lemma_165158 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (has_bot real)) := sorry --non-trivial
lemma new_lemma_165159 (h0 : topological_space (add_cancel_monoid (finset (has_add Type)))) : t1_space (add_cancel_monoid (finset (has_add Type))) := sorry --non-trivial
lemma new_lemma_165160 (h0 : topological_space (add_cancel_monoid (boolean_algebra name))) : sequential_space (add_cancel_monoid (boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_165161 (h0 : topological_space (comm_group (comm_group (comm_group (comm_group (comm_group unsigned)))))) : regular_space (comm_group (comm_group (comm_group (comm_group (comm_group unsigned))))) := sorry --non-trivial
lemma new_lemma_165162 (h0 : topological_space (has_top (id (has_union num)))) : irreducible_space (has_top (id (has_union num))) := sorry --non-trivial
lemma new_lemma_165163 (h0 : functor.add_const (topological_space (semigroup unsigned)) empty) : @normal_space.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_165164 (h0 : functor.add_const (filter environment.implicit_infer_kind) linarith.comp) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_165165 (h0 : functor.add_const (function.extfun Type ring) pos) : @is_domain.{0} (has_to_string.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) pos h0) (has_to_string.{0} name))  := sorry --non-trivial
lemma new_lemma_165166 (h0 : topological_space (mul_zero_class Type)) : preconnected_space (mul_zero_class Type) := sorry --non-trivial
lemma new_lemma_165167 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (normed_comm_ring.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (normed_comm_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_165168 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} pos (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) pos)  := sorry --non-trivial
lemma new_lemma_165169 (h0 : topological_space (linear_ordered_comm_group (option (option empty)))) : normal_space (linear_ordered_comm_group (option (option empty))) := sorry --non-trivial
lemma new_lemma_165170 (h0 : prod (complete_linear_order (semiring num)) (complete_linear_order (semiring num))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_165171 (h0 : functor.add_const (group (semigroup pos)) (ring Type)) : @is_cyclic.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (semigroup.{0} pos)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_165172 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (linear_ordered_comm_group.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (linear_ordered_comm_group.{0} num))  := sorry --non-trivial
lemma new_lemma_165173 (h0 : not (topological_space num -> false)) : @topological_space.separable_space.{0} num (@classical.by_contradiction'.{1} (topological_space.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_165174 (h0 : filter Prop) : @id.{1} Prop (@id.{1} Prop (@id.{1} Prop (@Lim.{0} Prop sierpinski_space (@nonempty_of_inhabited.{1} Prop sort.inhabited.{0}) h0)))  := sorry --non-trivial
lemma new_lemma_165175 (h0 : functor.add_const (topological_space (has_neg linarith.comp)) pos) : @irreducible_space.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_165176 (h0 : ring (mul_zero_class num)) : strong_rank_condition (mul_zero_class num) := sorry --non-trivial
lemma new_lemma_165177 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (canonically_ordered_add_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_ordered_add_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_165178 (h0 : list (has_inv (dlist (distrib_lattice to_additive.value_type)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_165179 (h0 : list (normed_group (has_ssubset to_additive.value_type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_165180 (h0 : ring (normed_group (semiring unsigned))) : strong_rank_condition (normed_group (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_165181 (h0 : ring (cancel_monoid environment.implicit_infer_kind)) : rank_condition (cancel_monoid environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_165182 (h0 : topological_space (ordered_comm_ring (finset real))) : totally_disconnected_space (ordered_comm_ring (finset real)) := sorry --non-trivial
lemma new_lemma_165183 (h0 : topological_space (nondiscrete_normed_field (add_comm_semigroup enat))) : totally_disconnected_space (nondiscrete_normed_field (add_comm_semigroup enat)) := sorry --non-trivial
lemma new_lemma_165184 (h0 : not (function.extfun Type topological_space -> false)) : @irreducible_space.{0} (has_star.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_star.{0} empty))  := sorry --non-trivial
lemma new_lemma_165185 (h0 : functor.add_const (topological_space (semigroup pos)) pos) : @preconnected_space.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_165186 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} environment.implicit_infer_kind (@function.extfun_app.{2 1} Type topological_space.{0} h0 environment.implicit_infer_kind)  := sorry --non-trivial
lemma new_lemma_165187 (h0 : semiring (add_group (semiring unsigned))) : is_noetherian_ring (add_group (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_165188 (h0 : topological_space (simple_graph (has_add (has_add (ordered_comm_monoid (has_Inf linarith.comp)))))) : irreducible_space (simple_graph (has_add (has_add (ordered_comm_monoid (has_Inf linarith.comp))))) := sorry --non-trivial
lemma new_lemma_165189 (h0 : function.extfun Type topological_space) : topological_space.separable_space nnreal := sorry --non-trivial
lemma new_lemma_165190 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (has_to_string congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_165191 (h0 : complete_lattice (has_lt (metric_space char))) : complete_lattice.is_Sup_finite_compact (has_lt (metric_space char)) := sorry --non-trivial
lemma new_lemma_165192 (h0 : list (ordered_comm_monoid (has_neg (has_neg Type)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_165193 (h0 : functor.add_const (complete_lattice (cancel_monoid empty)) unsigned) : @complete_lattice.is_Sup_finite_compact.{0} (cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (cancel_monoid.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_165194 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (complete_linear_order unsigned)) := sorry --non-trivial
lemma new_lemma_165195 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_Sup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_Sup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_165196 (h0 : functor.add_const (topological_space (has_zero linarith.comp)) pos) : @loc_path_connected_space.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_165197 (h0 : group (cancel_monoid num)) : normalizer_condition (cancel_monoid num) := sorry --non-trivial
lemma new_lemma_165198 (h0 : functor.add_const (ordered_comm_monoid (add_comm_monoid name)) pos) : @has_exists_mul_of_le.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (add_comm_monoid.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_165199 (h1 : function.extfun Type ring) : @is_domain.{0} (dlist.{0} string_imp) (@function.extfun_app.{2 1} Type ring.{0} h1 (dlist.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_165200 (h0 : not (function.extfun Type ring -> false)) : @rank_condition.{0} (measurable_space.dynkin_system.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (measurable_space.dynkin_system.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_165201 (h0 : topological_space (linear_ordered_comm_ring (semiring num))) : irreducible_space (linear_ordered_comm_ring (semiring num)) := sorry --non-trivial
lemma new_lemma_165202 (h0 : topological_space (has_sub unsigned)) : irreducible_space (has_sub unsigned) := sorry --non-trivial
lemma new_lemma_165203 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @topological_space.separable_space.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_165204 (h0 : add_group (normed_comm_ring (mul_zero_class ennreal))) : is_add_cyclic (normed_comm_ring (mul_zero_class ennreal)) := sorry --non-trivial
lemma new_lemma_165205 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (with_one.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (with_one.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_165206 (h0 : topological_space (ordered_comm_monoid (finset Type))) : regular_space (ordered_comm_monoid (finset Type)) := sorry --non-trivial
lemma new_lemma_165207 (h0 : semiring (pseudo_metric_space (option name))) : is_noetherian_ring (pseudo_metric_space (option name)) := sorry --non-trivial
lemma new_lemma_165208 (h0 : add_group (has_le (has_ssubset (simple_graph reducibility_hints)))) : is_add_cyclic (has_le (has_ssubset (simple_graph reducibility_hints))) := sorry --non-trivial
lemma new_lemma_165209 (h0 : function.extfun (finset Type) (has_mem.mem (semiring empty))) : @totally_separated_space.{0} (semiring.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (semiring.{0} empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} empty)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_165210 (h1 : ring (has_compl to_additive.value_type)) : is_domain (has_compl to_additive.value_type) := sorry --non-trivial
lemma new_lemma_165211 (h0 : ring (normed_group (has_norm (has_norm empty)))) : is_domain (normed_group (has_norm (has_norm empty))) := sorry --non-trivial
lemma new_lemma_165212 (h0 : list (has_edist unsigned)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_165213 (h0 : functor.add_const Prop (has_add (option (option pos)))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_165214 (h0 : functor.add_const (topological_space (has_add name)) pos) : @t0_space.{0} (has_add.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_165215 (h4 : ring (nondiscrete_normed_field enat)) : strong_rank_condition (nondiscrete_normed_field enat) := sorry --non-trivial
lemma new_lemma_165216 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (add_cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_165217 (h0 : topological_space (has_bot empty)) : discrete_topology (has_bot empty) := sorry --non-trivial
lemma new_lemma_165218 (h0 : list (mul_zero_class Type)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_165219 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_165220 (h0 : functor.add_const (monoid (has_neg_part Type)) (has_add (has_add pos))) : @monoid.fg.{1} (has_neg_part.{1} Type) (@functor.add_const.run.{1 0} (monoid.{1} (has_neg_part.{1} Type)) (has_add.{0} (has_add.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_165221 (h0 : add_group (add_cancel_comm_monoid string.iterator_imp)) : is_add_cyclic (add_cancel_comm_monoid string.iterator_imp) := sorry --non-trivial
lemma new_lemma_165222 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (ordered_cancel_add_comm_monoid.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_cancel_add_comm_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_165223 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (add_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (add_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_165224 (h0 : function.extfun Type topological_space) : @t0_space.{0} (linear_ordered_comm_monoid_with_zero.{0} (option.{0} unsigned)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_monoid_with_zero.{0} (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_165225 (h0 : not (topological_space (plift unsigned) -> false)) : @path_connected_space.{1} (plift.{1} unsigned) (@classical.by_contradiction'.{2} (topological_space.{1} (plift.{1} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_165226 (h0 : topological_space (bin_tree (semiring empty))) : path_connected_space (bin_tree (semiring empty)) := sorry --non-trivial
lemma new_lemma_165227 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} linarith.comp (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) linarith.comp)  := sorry --non-trivial
lemma new_lemma_165228 (h0 : uniform_space (normed_field (random_gen string_imp))) : complete_space (normed_field (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_165229 (h0 : complete_lattice (with_bot (has_inv (has_inv linarith.comp_source)))) : complete_lattice.is_Sup_finite_compact (with_bot (has_inv (has_inv linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_165230 (h0 : complete_lattice (has_neg_part (finset ennreal))) : is_compactly_generated (has_neg_part (finset ennreal)) := sorry --non-trivial
lemma new_lemma_165231 (h0 : filter (with_one (has_norm congr_arg_kind))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_165232 (h0 : functor.add_const (ordered_add_comm_monoid (is_R_or_C unsigned)) congr_arg_kind) : @archimedean.{0} (is_R_or_C.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (is_R_or_C.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_165233 (h0 : cancel_comm_monoid_with_zero (generalized_boolean_algebra (has_zero (has_neg Type)))) : unique_factorization_monoid (generalized_boolean_algebra (has_zero (has_neg Type))) := sorry --non-trivial
lemma new_lemma_165234 (h0 : topological_space (left_cancel_semigroup (option empty))) : totally_separated_space (left_cancel_semigroup (option empty)) := sorry --non-trivial
lemma new_lemma_165235 (h0 : function.extfun (Type 1) ordered_add_comm_monoid) : @archimedean.{1} (cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_add_comm_monoid.{1} h0 (cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_165236 (h0 : real -> real -> Prop) (h1 : set real) : set.unbounded h0 h1 := sorry --non-trivial
lemma new_lemma_165237 (h0 : ordered_add_comm_monoid (bin_tree (option unsigned))) : archimedean (bin_tree (option unsigned)) := sorry --non-trivial
lemma new_lemma_165238 (h0 : topological_space (finset (has_neg (has_add (ring name))))) : normal_space (finset (has_neg (has_add (ring name)))) := sorry --non-trivial
lemma new_lemma_165239 (h0 : filter (has_neg_part (option unsigned))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_165240 (h0 : not (semiring (plift empty) -> false)) : @is_noetherian_ring.{1} (plift.{1} empty) (@classical.by_contradiction'.{2} (semiring.{1} (plift.{1} empty)) h0)  := sorry --non-trivial
lemma new_lemma_165241 (h0 : topological_space (measure_theory.measure_space congr_arg_kind)) : discrete_topology (measure_theory.measure_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_165242 (h0 : topological_space (boolean_algebra (normed_comm_ring environment.implicit_infer_kind))) : locally_compact_space (boolean_algebra (normed_comm_ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_165243 (h1 : has_mem.mem topological_space has_emptyc.emptyc) : @discrete_topology.{0} (complete_semilattice_Sup.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h1) (complete_semilattice_Sup.{0} empty))  := sorry --non-trivial
lemma new_lemma_165244 (h0 : complete_lattice (has_neg (has_to_string unsigned))) : is_atomistic (has_neg (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_165245 (h0 : ring (linear_ordered_add_comm_group (random_gen fun_info))) : is_domain (linear_ordered_add_comm_group (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_165246 (h0 : topological_space (has_add (ring (has_neg Type)))) : totally_separated_space (has_add (ring (has_neg Type))) := sorry --non-trivial
lemma new_lemma_165247 (h0 : list (has_zero (has_add linarith.comp))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_165248 (h0 : has_mem.mem (normed_group empty) has_emptyc.emptyc) : @strong_rank_condition.{0} (normed_group.{0} empty) (@finset.pi.empty.{1 0} Type ring.{0} (normed_group.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_165249 (h0 : complete_lattice (finset name)) : is_atomistic (finset name) := sorry --non-trivial
lemma new_lemma_165250 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (random_gen.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (random_gen.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_165251 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (has_norm.{0} linarith.ineq) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_norm.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_165252 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (omega_complete_partial_order.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (omega_complete_partial_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_165253 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_add.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} real))  := sorry --non-trivial
lemma new_lemma_165254 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (has_zero.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_zero.{0} empty))  := sorry --non-trivial
lemma new_lemma_165255 (h0 : topological_space (has_append (semiring (has_norm empty)))) : path_connected_space (has_append (semiring (has_norm empty))) := sorry --non-trivial
lemma new_lemma_165256 (h0 : topological_space (semigroup pos)) : preconnected_space (semigroup pos) := sorry --non-trivial
lemma new_lemma_165257 (h0 : has_add name -> has_neg (has_neg pos) -> Prop) : relator.bi_total h0 := sorry --non-trivial
lemma new_lemma_165258 (h0 : add_group (has_neg_part ennreal)) : is_add_cyclic (has_neg_part ennreal) := sorry --non-trivial
lemma new_lemma_165259 (h1 : uniform_space (has_append char)) : complete_space (has_append char) := sorry --non-trivial
lemma new_lemma_165260 (h0 : function.extfun Type (functor.add_const (ring unsigned))) : @is_principal_ideal_ring.{0} unsigned (@functor.add_const.run.{0 0} (ring.{0} unsigned) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} unsigned)) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_165261 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_simple_group.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_165262 (h0 : topological_space (plift ennreal)) : loc_path_connected_space (plift ennreal) := sorry --non-trivial
lemma new_lemma_165263 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (add_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_165264 (h0 : functor.add_const (topological_space (add_cancel_monoid empty)) (option empty)) : @totally_disconnected_space.{0} (add_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} empty)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_165265 (h0 : group (boolean_algebra.core (comm_group name))) : normalizer_condition (boolean_algebra.core (comm_group name)) := sorry --non-trivial
lemma new_lemma_165266 (h0 : topological_space (random_gen (random_gen char))) : path_connected_space (random_gen (random_gen char)) := sorry --non-trivial
lemma new_lemma_165267 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (with_one.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (with_one.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_165268 (h1 : topological_space (has_compl (has_ssubset (has_ssubset char)))) : t0_space (has_compl (has_ssubset (has_ssubset char))) := sorry --non-trivial
lemma new_lemma_165269 (h0 : functor.add_const (function.extfun Type list) (mul_one_class (add_cancel_monoid linarith.comp))) : list.nodup (function.extfun_app (functor.add_const.run h0) (normed_comm_ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_165270 (h0 : topological_space (sub_neg_monoid (has_Inf (has_Inf real)))) : topological_space.separable_space (sub_neg_monoid (has_Inf (has_Inf real))) := sorry --non-trivial
lemma new_lemma_165271 (h0 : functor.add_const (finset (has_zero linarith.comp)) Type) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_165272 (h0 : ring (simple_graph (has_pos_part (has_pos_part Type)))) : is_domain (simple_graph (has_pos_part (has_pos_part Type))) := sorry --non-trivial
lemma new_lemma_165273 (h0 : topological_space (boolean_algebra.core (option pos))) : t0_space (boolean_algebra.core (option pos)) := sorry --non-trivial
lemma new_lemma_165274 (h0 : functor.comp topological_space has_to_string Type) : @irreducible_space.{1} (has_to_string.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} has_to_string.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_165275 (h3 : not (topological_space (encodable linarith.ineq) -> false)) : @regular_space.{0} (encodable.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (encodable.{0} linarith.ineq)) h3)  := sorry --non-trivial
lemma new_lemma_165276 (h0 : set (string.iterator_imp -> linarith.ineq)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_165277 (h0 : complete_lattice (with_bot (semiring (semiring (semiring num))))) : is_compactly_generated (with_bot (semiring (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_165278 (h0 : functor.comp ring has_neg_part environment.implicit_infer_kind) : @is_principal_ideal_ring.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} ring.{0} has_neg_part.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_165279 (h0 : prod (pseudo_metric_space congr_arg_kind) (pseudo_metric_space congr_arg_kind)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_165280 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_pos_part.{0} real) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_pos_part.{0} real))  := sorry --non-trivial
lemma new_lemma_165281 (h0 : has_lt (add_comm_semigroup char)) : no_max_order (add_comm_semigroup char) := sorry --non-trivial
lemma new_lemma_165282 (h0 : topological_space (measurable_space (has_top empty))) : path_connected_space (measurable_space (has_top empty)) := sorry --non-trivial
lemma new_lemma_165283 (h0 : cancel_comm_monoid_with_zero (left_cancel_monoid empty)) : unique_factorization_monoid (left_cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_165284 (h0 : topological_space (boolean_algebra (has_Inf (finset pos)))) : locally_compact_space (boolean_algebra (has_Inf (finset pos))) := sorry --non-trivial
lemma new_lemma_165285 (h0 : functor.add_const (topological_space (has_pos_part linarith.comp)) Type) : @discrete_topology.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_pos_part.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_165286 (h0 : topological_space (complete_linear_order congr_arg_kind)) : discrete_topology (complete_linear_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_165287 (h0 : functor.add_const (topological_space (has_neg_part environment.implicit_infer_kind)) name) : @sequential_space.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_165288 (h0 : topological_space (monoid (option (option unsigned)))) : preconnected_space (monoid (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_165289 (h0 : complete_lattice (add_semigroup (option unsigned))) : is_atomistic (add_semigroup (option unsigned)) := sorry --non-trivial
lemma new_lemma_165290 (h0 : ordered_add_comm_monoid (comm_semigroup name)) : archimedean (comm_semigroup name) := sorry --non-trivial
lemma new_lemma_165291 (h0 : group (with_one (has_nnnorm to_additive.value_type))) : group.fg (with_one (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_165292 (h1 : set (ereal -> std_gen)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_165293 (h0 : group (linear_ordered_comm_group (option (option (option unsigned))))) : is_cyclic (linear_ordered_comm_group (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_165294 (h0 : ring (semi_normed_comm_ring (random_gen to_additive.value_type))) : rank_condition (semi_normed_comm_ring (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_165295 (h0 : functor.add_const (list (ordered_ring unsigned)) (semiring (semiring empty))) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_165296 (h0 : topological_space (finset (comm_group Type))) : preconnected_space (finset (comm_group Type)) := sorry --non-trivial
lemma new_lemma_165297 (h0 : ordered_comm_monoid (add_cancel_monoid (has_nndist pos))) : has_exists_mul_of_le (add_cancel_monoid (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_165298 (h0 : monoid (sub_neg_monoid (finset Type))) : monoid.fg (sub_neg_monoid (finset Type)) := sorry --non-trivial
lemma new_lemma_165299 (h0 : functor.add_const (topological_space znum) (option (option unsigned))) : @irreducible_space.{0} znum (@functor.add_const.run.{0 0} (topological_space.{0} znum) (option.{0} (option.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_165300 (h0 : functor.add_const (add_group (has_neg environment.implicit_infer_kind)) (has_add Type)) : @is_add_cyclic.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (add_group.{0} (has_neg.{0} environment.implicit_infer_kind)) (has_add.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_165301 (h0 : topological_space (random_gen (mul_one_class linarith.ineq))) (h1 : preorder (random_gen (mul_one_class linarith.ineq))) : order_topology (random_gen (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_165302 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_top.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_top.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_165303 (h0 : topological_space (normed_field (comm_ring reducibility_hints))) : t0_space (normed_field (comm_ring reducibility_hints)) := sorry --non-trivial
lemma new_lemma_165304 (h1 : topological_space reducibility_hints) (h2 : uniform_space (nondiscrete_normed_field (measure_theory.content reducibility_hints))) : complete_space (nondiscrete_normed_field (measure_theory.content reducibility_hints)) := sorry --non-trivial
lemma new_lemma_165305 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (finset congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_165306 (h0 : topological_space (canonically_ordered_monoid (has_Inf (has_Inf linarith.comp)))) : preirreducible_space (canonically_ordered_monoid (has_Inf (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_165307 (h0 : topological_space (linear_ordered_field ennreal)) : discrete_topology (linear_ordered_field ennreal) := sorry --non-trivial
lemma new_lemma_165308 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (ordered_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_165309 (h0 : functor.add_const (function.extfun (Type 1) ordered_comm_monoid) linarith.comp) : @has_exists_mul_of_le.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_comm_monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ordered_comm_monoid.{1}) linarith.comp h0) (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_165310 (h0 : ordered_add_comm_monoid (cancel_monoid Type)) : archimedean (cancel_monoid Type) := sorry --non-trivial
lemma new_lemma_165311 (h0 : topological_space (non_assoc_semiring num)) : preirreducible_space (non_assoc_semiring num) := sorry --non-trivial
lemma new_lemma_165312 (h0 : ring (boolean_algebra (comm_group (has_add (finset Type))))) : is_principal_ideal_ring (boolean_algebra (comm_group (has_add (finset Type)))) := sorry --non-trivial
lemma new_lemma_165313 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @t0_space.{1} Type (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) Type)  := sorry --non-trivial
lemma new_lemma_165314 (h0 : ring (normed_field (normed_field (normed_field char)))) : is_domain (normed_field (normed_field (normed_field char))) := sorry --non-trivial
lemma new_lemma_165315 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (has_top.{0} string_imp) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 monoid.{0}) (has_top.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_165316 (h0 : functor.add_const (topological_space (has_neg pos)) linarith.comp) : @irreducible_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_165317 (h0 : group (linear_ordered_comm_ring (semiring unsigned))) : is_cyclic (linear_ordered_comm_ring (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_165318 (h0 : add_group (has_add (has_neg name))) : is_add_cyclic (has_add (has_neg name)) := sorry --non-trivial
lemma new_lemma_165319 (h0 : functor.add_const (topological_space (generalized_boolean_algebra name)) Type) : @preirreducible_space.{0} (generalized_boolean_algebra.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (generalized_boolean_algebra.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_165320 (h0 : ring (has_ssubset char) -> linarith.comp_source) (h1 : coe_sort (set.range h0)) : @strong_rank_condition.{0} (has_ssubset.{0} char) (@set.range_splitting.{0 0} (ring.{0} (has_ssubset.{0} char)) linarith.comp_source h0 h1)  := sorry --non-trivial
lemma new_lemma_165321 (h0 : topological_space (simple_graph (has_dist congr_arg_kind))) : t1_space (simple_graph (has_dist congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_165322 (h0 : complete_lattice (ordered_comm_ring (has_add Type))) : is_atomistic (ordered_comm_ring (has_add Type)) := sorry --non-trivial
lemma new_lemma_165323 (h0 : functor.add_const (topological_space (mul_zero_class unsigned)) unsigned) : @totally_disconnected_space.{0} (mul_zero_class.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_165324 (h0 : add_group (semiring (random_gen (random_gen linarith.ineq)))) : is_add_cyclic (semiring (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_165325 (h0 : semiring (metric_space (semiring (has_norm (has_top (semiring congr_arg_kind)))))) : is_noetherian_ring (metric_space (semiring (has_norm (has_top (semiring congr_arg_kind))))) := sorry --non-trivial
lemma new_lemma_165326 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @t1_space.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_165327 (h0 : topological_space (finset (has_to_string (finset environment.implicit_infer_kind)))) : totally_separated_space (finset (has_to_string (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_165328 (h0 : functor.add_const (function.extfun Type ordered_add_comm_monoid) linarith.comp) : @archimedean.{0} (has_zero.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_add_comm_monoid.{0}) linarith.comp h0) (has_zero.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_165329 (h0 : functor.add_const (fin has_zero.zero) Type) : @group.fg.{0} (normed_lattice_add_comm_group.{0} real) (@matrix.vec_empty.{0} (group.{0} (normed_lattice_add_comm_group.{0} real)) (@functor.add_const.run.{0 1} (fin (@has_zero.zero.{0} nat nat.has_zero)) Type h0))  := sorry --non-trivial
lemma new_lemma_165330 (h0 : group (ordered_comm_group (option (option (option unsigned))))) : normalizer_condition (ordered_comm_group (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_165331 (h0 : uniform_space (preorder congr_arg_kind)) : separated_space (preorder congr_arg_kind) := sorry --non-trivial
lemma new_lemma_165332 (h0 : topological_space (mul_one_class (has_neg_part enat))) : path_connected_space (mul_one_class (has_neg_part enat)) := sorry --non-trivial
lemma new_lemma_165333 (h0 : functor.add_const (function.extfun Type complete_lattice) environment.implicit_infer_kind) : @complete_lattice.is_Sup_finite_compact.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) environment.implicit_infer_kind h0) (normed_comm_ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_165334 (h0 : complete_lattice (linear_ordered_comm_ring (has_top (semiring empty)))) : complete_lattice.is_Sup_finite_compact (linear_ordered_comm_ring (has_top (semiring empty))) := sorry --non-trivial
lemma new_lemma_165335 (h0 : functor.add_const (complete_lattice (ring linarith.comp)) (finset linarith.comp)) : @is_compactly_generated.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ring.{0} linarith.comp)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_165336 (h0 : ring (has_ssubset (random_gen reducibility_hints))) : rank_condition (has_ssubset (random_gen reducibility_hints)) := sorry --non-trivial
lemma new_lemma_165337 (h0 : topological_space (comm_semigroup (has_bot (has_bot pos)))) : locally_compact_space (comm_semigroup (has_bot (has_bot pos))) := sorry --non-trivial
lemma new_lemma_165338 (h0 : topological_space (semigroup empty)) : t1_space (semigroup empty) := sorry --non-trivial
lemma new_lemma_165339 (h0 : functor.add_const (add_monoid (cancel_monoid name)) name) : @add_monoid.fg.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (add_monoid.{0} (cancel_monoid.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_165340 (h0 : topological_space (comm_ring (has_inv fun_info))) : t0_space (comm_ring (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_165341 (h0 : topological_space (plift (add_cancel_monoid unsigned))) : path_connected_space (plift (add_cancel_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_165342 (h0 : complete_lattice (has_nndist (option ennreal))) : is_compactly_generated (has_nndist (option ennreal)) := sorry --non-trivial
lemma new_lemma_165343 (h0 : ring (has_add (has_add linarith.comp))) : is_principal_ideal_ring (has_add (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_165344 (h0 : topological_space (with_bot (semiring congr_arg_kind))) : normal_space (with_bot (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_165345 (h0 : ordered_add_comm_monoid (comm_group (finset Type))) : archimedean (comm_group (finset Type)) := sorry --non-trivial
lemma new_lemma_165346 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (normed_lattice_add_comm_group.{0} name) (@function.extfun_app.{2 1} Type add_group.{0} h0 (normed_lattice_add_comm_group.{0} name))  := sorry --non-trivial
lemma new_lemma_165347 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (has_star.{0} (semiring.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_star.{0} (semiring.{0} empty)))  := sorry --non-trivial
lemma new_lemma_165348 (h0 : ring (has_ssubset (random_gen (has_ssubset to_additive.value_type)))) : is_domain (has_ssubset (random_gen (has_ssubset to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_165349 (h0 : ring (semigroup (ring linarith.comp))) : rank_condition (semigroup (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_165350 (h0 : functor.add_const (topological_space (has_pos_part congr_arg_kind)) unsigned) : @t0_space.{0} (has_pos_part.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_165351 (h0 : add_monoid (has_zero (has_neg linarith.comp))) : add_monoid.fg (has_zero (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_165352 (h0 : functor.add_const (ring (has_add pos)) (has_zero Type)) : @is_principal_ideal_ring.{0} (has_add.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (has_add.{0} pos)) (has_zero.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_165353 (h0 : topological_space (measurable_space fun_info)) : totally_disconnected_space (measurable_space fun_info) := sorry --non-trivial
lemma new_lemma_165354 (h0 : list (semi_normed_comm_ring (has_ssubset (has_ssubset (has_ssubset linarith.ineq))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_165355 (h0 : add_monoid (has_norm (semiring (semiring (semiring congr_arg_kind))))) : add_monoid.fg (has_norm (semiring (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_165356 (h0 : group (ordered_comm_monoid (has_add (has_add (has_add (has_add real)))))) : is_simple_group (ordered_comm_monoid (has_add (has_add (has_add (has_add real))))) := sorry --non-trivial
lemma new_lemma_165357 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (finset.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_165358 (h0 : list (has_inner (option unsigned) empty)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_165359 (h0 : ordered_add_comm_monoid (linear_ordered_cancel_comm_monoid (option empty))) : archimedean (linear_ordered_cancel_comm_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_165360 (h0 : has_mem.mem (linear_ordered_semiring linarith.comp) has_emptyc.emptyc) : @rank_condition.{0} (linear_ordered_semiring.{0} linarith.comp) (@finset.pi.empty.{1 0} Type ring.{0} (linear_ordered_semiring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_165361 (h0 : functor.add_const (add_monoid (preorder num)) empty) : @add_monoid.fg.{0} (preorder.{0} num) (@functor.add_const.run.{0 0} (add_monoid.{0} (preorder.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_165362 (h0 : topological_space (boolean_algebra (comm_group unsigned))) : preirreducible_space (boolean_algebra (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_165363 (h0 : has_le (has_ssubset string.iterator_imp)) (h1 : has_ssubset string.iterator_imp) : is_max h1 := sorry --non-trivial
lemma new_lemma_165364 (h0 : group (boolean_algebra.core (has_Inf (ring Type)))) : group.fg (boolean_algebra.core (has_Inf (ring Type))) := sorry --non-trivial
lemma new_lemma_165365 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_atomistic.{0} stieltjes_function (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) stieltjes_function)  := sorry --non-trivial
lemma new_lemma_165366 (h0 : topological_space (add_cancel_monoid (comm_group (comm_group name)))) : preconnected_space (add_cancel_monoid (comm_group (comm_group name))) := sorry --non-trivial
lemma new_lemma_165367 (h1 : ring (with_one (has_nnnorm linarith.comp_source))) : is_domain (with_one (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_165368 (h0 : functor.add_const Prop (has_neg_part (has_nndist (finset (finset environment.implicit_infer_kind))))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_165369 (h0 : add_group (has_bot (ordered_comm_ring (sub_neg_monoid real)))) : is_add_cyclic (has_bot (ordered_comm_ring (sub_neg_monoid real))) := sorry --non-trivial
lemma new_lemma_165370 (h0 : functor.add_const (function.extfun (Type 1) ring) linarith.comp) : @rank_condition.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ring.{1}) linarith.comp h0) (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_165371 (h0 : ring (plift (semiring (semiring (semiring num))))) : strong_rank_condition (plift (semiring (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_165372 (h0 : preorder unsigned) (h1 : preorder num) (h2 : unsigned -> num) : strict_anti h2 := sorry --non-trivial
lemma new_lemma_165373 (h0 : ring (random_gen (has_norm (has_norm to_additive.value_type)))) : is_domain (random_gen (has_norm (has_norm to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_165374 (h0 : topological_space (canonically_ordered_monoid (has_add Type))) : topological_space.separable_space (canonically_ordered_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_165375 (h0 : filter (sub_neg_monoid (has_Inf pos))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_165376 (h0 : topological_space (semiring (semiring congr_arg_kind))) : preirreducible_space (semiring (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_165377 (h0 : group (normed_linear_ordered_group (option empty))) : is_cyclic (normed_linear_ordered_group (option empty)) := sorry --non-trivial
lemma new_lemma_165378 (h0 : topological_space (mul_zero_class empty)) : normal_space (mul_zero_class empty) := sorry --non-trivial
lemma new_lemma_165379 (h0 : ordered_comm_monoid (canonically_ordered_monoid (has_add (has_Inf (has_Inf linarith.comp))))) : has_exists_mul_of_le (canonically_ordered_monoid (has_add (has_Inf (has_Inf linarith.comp)))) := sorry --non-trivial
lemma new_lemma_165380 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (with_bot.{0} (has_top.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} empty)))))) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_bot.{0} (has_top.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} empty)))))))  := sorry --non-trivial
lemma new_lemma_165381 (h0 : pseudo_metric_space ereal) (h1 : add_monoid ereal) : has_lipschitz_add ereal := sorry --non-trivial
lemma new_lemma_165382 (h0 : function.extfun (Type 1) ring) : @is_principal_ideal_ring.{1} (has_bot.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (has_bot.{1} Type))  := sorry --non-trivial
lemma new_lemma_165383 (h0 : complete_lattice (is_R_or_C (option empty))) : is_atomistic (is_R_or_C (option empty)) := sorry --non-trivial
lemma new_lemma_165384 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_dist.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_dist.{0} empty))  := sorry --non-trivial
lemma new_lemma_165385 (h0 : topological_space (measurable_space.dynkin_system unsigned)) : loc_path_connected_space (measurable_space.dynkin_system unsigned) := sorry --non-trivial
lemma new_lemma_165386 (h0 : complete_lattice (denumerable string.iterator_imp)) : complete_lattice.is_Sup_finite_compact (denumerable string.iterator_imp) := sorry --non-trivial
lemma new_lemma_165387 (h0 : complete_lattice (has_top (semiring congr_arg_kind))) : is_compactly_generated (has_top (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_165388 (h0 : complete_lattice (has_pos_part (sub_neg_monoid real))) : is_atomistic (has_pos_part (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_165389 (h0 : topological_space (ring (boolean_algebra.core Type))) : locally_compact_space (ring (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_165390 (h0 : cancel_comm_monoid_with_zero (add_group (semiring (has_top (has_top empty))))) : unique_factorization_monoid (add_group (semiring (has_top (has_top empty)))) := sorry --non-trivial
lemma new_lemma_165391 (h0 : topological_space (normed_comm_ring (option (option ennreal)))) : irreducible_space (normed_comm_ring (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_165392 (h0 : topological_space (add_comm_monoid linarith.comp)) : preconnected_space (add_comm_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_165393 (h0 : topological_space (ordered_semiring (option unsigned))) : path_connected_space (ordered_semiring (option unsigned)) := sorry --non-trivial
lemma new_lemma_165394 (h0 : pnat) (h1 : fin has_zero.zero) : pnat.coprime (id (id h0)) (matrix.vec_empty h1) := sorry --non-trivial
lemma new_lemma_165395 (h0 : ordered_comm_monoid (generalized_boolean_algebra (has_nndist pos))) : has_exists_mul_of_le (generalized_boolean_algebra (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_165396 (h0 : topological_space (has_lt enat)) : totally_disconnected_space (has_lt enat) := sorry --non-trivial
lemma new_lemma_165397 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (add_group.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_165398 (h0 : add_group (has_div (mul_one_class string.iterator_imp))) : is_add_cyclic (has_div (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_165399 (h0 : functor.add_const (ordered_comm_monoid (has_add name)) (ring pos)) : @has_exists_mul_of_le.{0} (has_add.{0} name) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_add.{0} name)) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_165400 (h0 : ring (add_comm_monoid (has_to_string ennreal))) : rank_condition (add_comm_monoid (has_to_string ennreal)) := sorry --non-trivial
lemma new_lemma_165401 (h0 : functor.add_const (finset (add_comm_monoid pos)) Type) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_165402 (h0 : topological_space (monoid (option (option (option ennreal))))) : t0_space (monoid (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_165403 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (has_neg_part.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_neg_part.{0} name))  := sorry --non-trivial
lemma new_lemma_165404 (h0 : functor.add_const (topological_space (has_add linarith.comp)) linarith.comp) : @preirreducible_space.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_165405 (h0 : has_neg (nondiscrete_normed_field (add_comm_semigroup linarith.ineq))) (h1 : measurable_space (nondiscrete_normed_field (add_comm_semigroup linarith.ineq))) : has_measurable_neg (nondiscrete_normed_field (add_comm_semigroup linarith.ineq)) := sorry --non-trivial
lemma new_lemma_165406 (h0 : function.extfun nat fin) : @t0_space.{1} (simple_graph.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (simple_graph.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_165407 (h0 : fin has_zero.zero) : @group.fg.{0} (has_bot.{0} pos) (@matrix.vec_empty.{0} (group.{0} (has_bot.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_165408 (h0 : group (linear_ordered_add_comm_group (random_gen congr_arg_kind))) : group.fg (linear_ordered_add_comm_group (random_gen congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_165409 (h0 : ring (semi_normed_comm_ring (random_gen reducibility_hints))) : strong_rank_condition (semi_normed_comm_ring (random_gen reducibility_hints)) := sorry --non-trivial
lemma new_lemma_165410 (h1 : function.extfun Type monoid) : @monoid.fg.{0} (denumerable.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type monoid.{0} h1 (denumerable.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_165411 (h0 : group (has_inv (random_gen linarith.ineq))) : is_cyclic (has_inv (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_165412 (h0 : ring (semigroup (comm_group (semigroup name)))) : is_domain (semigroup (comm_group (semigroup name))) := sorry --non-trivial
lemma new_lemma_165413 (h0 : function.extfun Type topological_space) : @normal_space.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_165414 (h0 : ring (linear_ordered_comm_group_with_zero to_additive.value_type)) : rank_condition (linear_ordered_comm_group_with_zero to_additive.value_type) := sorry --non-trivial
lemma new_lemma_165415 (h1 : function.extfun (finset (Type -> Type)) (has_mem.mem complete_lattice)) : @is_atomistic.{0} empty (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) complete_lattice.{0}) h1 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) empty)  := sorry --non-trivial
lemma new_lemma_165416 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_to_string.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_to_string.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_165417 (h0 : functor.add_const (function.extfun Type add_monoid) (ring linarith.comp)) : @add_monoid.fg.{0} (complete_distrib_lattice.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_monoid.{0}) (ring.{0} linarith.comp) h0) (complete_distrib_lattice.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_165418 (h0 : topological_space (has_pos_part (finset (has_neg linarith.comp)))) : totally_disconnected_space (has_pos_part (finset (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_165419 (h0 : functor.add_const (monoid (has_to_string Type)) (has_neg linarith.comp)) : @monoid.fg.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (monoid.{1} (has_to_string.{1} Type)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_165420 (h0 : not (group (with_one linarith.comp) -> false)) : @normalizer_condition.{0} (with_one.{0} linarith.comp) (@classical.by_contradiction'.{1} (group.{0} (with_one.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_165421 (h0 : uniform_space (has_top to_additive.value_type)) : complete_space (has_top to_additive.value_type) := sorry --non-trivial
lemma new_lemma_165422 (h0 : topological_space (canonically_ordered_monoid pos)) : normal_space (canonically_ordered_monoid pos) := sorry --non-trivial
lemma new_lemma_165423 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (as_linear_order.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (as_linear_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_165424 (h0 : functor.add_const (topological_space (has_neg_part name)) linarith.comp) : @irreducible_space.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_165425 (h0 : cancel_comm_monoid_with_zero (ring (has_neg_part linarith.comp))) : unique_factorization_monoid (ring (has_neg_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_165426 (h0 : topological_space (add_comm_monoid name)) : loc_path_connected_space (add_comm_monoid name) := sorry --non-trivial
lemma new_lemma_165427 (h0 : group (pseudo_metric_space unsigned)) : normalizer_condition (pseudo_metric_space unsigned) := sorry --non-trivial
lemma new_lemma_165428 (h1 : ring (distrib (comm_ring to_additive.value_type))) : is_domain (distrib (comm_ring to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_165429 (h0 : topological_space (linear_ordered_comm_monoid_with_zero empty)) : totally_separated_space (linear_ordered_comm_monoid_with_zero empty) := sorry --non-trivial
lemma new_lemma_165430 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (linear_ordered_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_165431 (h0 : topological_space (has_pos_part (has_Inf Type))) : t0_space (has_pos_part (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_165432 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (has_bot.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_bot.{0} pos))  := sorry --non-trivial
lemma new_lemma_165433 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (canonically_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (canonically_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_165434 (h0 : function.extfun Type group) : @normalizer_condition.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} unsigned)))))) (@function.extfun_app.{2 1} Type group.{0} h0 (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} unsigned)))))))  := sorry --non-trivial
lemma new_lemma_165435 (h0 : function.extfun Type (functor.comp filter finset)) : filter.ne_bot (functor.comp.run (function.extfun_app h0 name)) := sorry --non-trivial
lemma new_lemma_165436 (h0 : functor.add_const (topological_space (finset pos)) name) : @locally_compact_space.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_165437 (h0 : functor.add_const (filter (has_neg name)) linarith.comp) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_165438 (h0 : topological_space (complete_distrib_lattice (ring Type))) : sequential_space (complete_distrib_lattice (ring Type)) := sorry --non-trivial
lemma new_lemma_165439 (h0 : add_group (linear_ordered_comm_ring (semiring congr_arg_kind))) : is_add_cyclic (linear_ordered_comm_ring (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_165440 (h0 : ring (with_bot (random_gen (with_one to_additive.value_type)))) : rank_condition (with_bot (random_gen (with_one to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_165441 (h0 : uniform_space (has_div (mul_one_class linarith.ineq))) : complete_space (has_div (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_165442 (h0 : functor.add_const (topological_space (complete_distrib_lattice name)) pos) : @regular_space.{0} (complete_distrib_lattice.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_165443 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (canonically_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (canonically_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_165444 (h0 : group (ordered_comm_ring (ring (ring (has_pos_part Type))))) : group.fg (ordered_comm_ring (ring (ring (has_pos_part Type)))) := sorry --non-trivial
lemma new_lemma_165445 (h0 : group (add_cancel_monoid (has_add (has_to_string linarith.comp)))) : group.fg (add_cancel_monoid (has_add (has_to_string linarith.comp))) := sorry --non-trivial
lemma new_lemma_165446 (h0 : function.extfun (finset Type) (has_mem.mem (measurable_space linarith.comp_source))) : @normalizer_condition.{0} (measurable_space.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type group.{0} (measurable_space.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (measurable_space.{0} linarith.comp_source)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_165447 (h0 : functor.add_const (ordered_comm_monoid (has_to_string linarith.comp)) pos) : @has_exists_mul_of_le.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_to_string.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_165448 (h0 : ring (has_sub num)) : rank_condition (has_sub num) := sorry --non-trivial
lemma new_lemma_165449 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @monoid.fg.{1} (comm_semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) monoid.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 monoid.{1}) (comm_semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_165450 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_165451 (h0 : list (normed_comm_ring (has_dist unsigned))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_165452 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (linear_order.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_165453 (h0 : not (ring (topological_space fun_info) -> false)) : @rank_condition.{0} (topological_space.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (topological_space.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_165454 (h0 : has_lt (distrib linarith.comp_source)) : no_max_order (distrib linarith.comp_source) := sorry --non-trivial
lemma new_lemma_165455 (h0 : group (with_bot (random_gen (has_inv linarith.ineq)))) : group.fg (with_bot (random_gen (has_inv linarith.ineq))) := sorry --non-trivial
lemma new_lemma_165456 (h1 : not (ring (has_ssubset string_imp) -> false)) : @rank_condition.{0} (has_ssubset.{0} string_imp) (@classical.by_contradiction'.{1} (ring.{0} (has_ssubset.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_165457 (h0 : topological_space (ring (option (option empty)))) : totally_separated_space (ring (option (option empty))) := sorry --non-trivial
lemma new_lemma_165458 (h0 : functor.add_const (ring (canonically_ordered_comm_semiring linarith.comp)) (add_cancel_monoid pos)) : @strong_rank_condition.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (canonically_ordered_comm_semiring.{0} linarith.comp)) (add_cancel_monoid.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_165459 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (sub_neg_monoid.{0} name) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (sub_neg_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_165460 (h0 : functor.add_const (topological_space (cancel_monoid Type)) linarith.comp) : @totally_separated_space.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (cancel_monoid.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_165461 (h0 : list (topological_space (random_gen linarith.comp_source))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_165462 (h0 : add_group (complete_distrib_lattice (option unsigned))) : is_add_cyclic (complete_distrib_lattice (option unsigned)) := sorry --non-trivial
lemma new_lemma_165463 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (non_unital_non_assoc_ring.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (non_unital_non_assoc_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_165464 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (add_cancel_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_165465 (h0 : has_mem.mem (random_gen num) has_emptyc.emptyc) : @totally_disconnected_space.{0} (random_gen.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (random_gen.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_165466 (h0 h1 : multiset (has_nnnorm enat)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_165467 (h0 : function.extfun Type (functor.add_const (list (has_Sup unsigned)))) : list.nodup (functor.add_const.run (function.extfun_app h0 num)) := sorry --non-trivial
lemma new_lemma_165468 (h0 : topological_space (has_inter (option (option (option ennreal))))) : irreducible_space (has_inter (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_165469 (h0 : group (boolean_algebra.core (has_add linarith.comp))) : is_simple_group (boolean_algebra.core (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_165470 (h0 : topological_space (complete_semilattice_Sup (random_gen (random_gen (random_gen string_imp))))) : t0_space (complete_semilattice_Sup (random_gen (random_gen (random_gen string_imp)))) := sorry --non-trivial
lemma new_lemma_165471 (h0 : topological_space num) : discrete_topology num := sorry --non-trivial
lemma new_lemma_165472 (h0 : cancel_comm_monoid_with_zero (ordered_ring num)) : unique_factorization_monoid (ordered_ring num) := sorry --non-trivial
lemma new_lemma_165473 (h0 : topological_space (semiring (semiring unsigned))) : normal_space (semiring (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_165474 (h0 : not (topological_space (has_top empty) -> false)) : @discrete_topology.{0} (has_top.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (has_top.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_165475 (h0 : complete_lattice (has_compl string_imp)) : complete_lattice.is_Sup_finite_compact (has_compl string_imp) := sorry --non-trivial
lemma new_lemma_165476 (h0 : functor.add_const (complete_lattice (measurable_space.dynkin_system num)) num) : @complete_lattice.is_Sup_finite_compact.{0} (measurable_space.dynkin_system.{0} num) (@functor.add_const.run.{0 0} (complete_lattice.{0} (measurable_space.dynkin_system.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_165477 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @locally_compact_space.{0} (with_bot.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) topological_space.{0}) (with_bot.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_165478 (h0 : functor.add_const (add_monoid (has_nndist pos)) (has_pos_part Type)) : @add_monoid.fg.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 1} (add_monoid.{0} (has_nndist.{0} pos)) (has_pos_part.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_165479 (h0 : function.extfun Type ring) : @rank_condition.{0} (add_comm_monoid.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_comm_monoid.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_165480 (h0 : group (topological_space (random_gen (random_gen linarith.comp_source)))) : group.fg (topological_space (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_165481 (h0 : topological_space (has_lt string.iterator_imp)) (h1 : not (preorder (has_lt string.iterator_imp) -> false)) : @order_closed_topology.{0} (has_lt.{0} string.iterator_imp) h0 (@classical.by_contradiction'.{1} (preorder.{0} (has_lt.{0} string.iterator_imp)) h1)  := sorry --non-trivial
lemma new_lemma_165482 (h0 : not (add_monoid (has_union empty) -> false)) : @add_monoid.fg.{0} (has_union.{0} empty) (@classical.by_contradiction'.{1} (add_monoid.{0} (has_union.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_165483 (h0 : topological_space (nondiscrete_normed_field (add_comm_semigroup (add_comm_semigroup fun_info)))) (h1 : add_group (nondiscrete_normed_field (add_comm_semigroup (add_comm_semigroup fun_info)))) : topological_add_group (nondiscrete_normed_field (add_comm_semigroup (add_comm_semigroup fun_info))) := sorry --non-trivial
lemma new_lemma_165484 (h0 : topological_space (finset (boolean_algebra environment.implicit_infer_kind))) : path_connected_space (finset (boolean_algebra environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_165485 (h0 : semiring (normed_lattice_add_comm_group (has_pos_part (has_add real)))) : is_noetherian_ring (normed_lattice_add_comm_group (has_pos_part (has_add real))) := sorry --non-trivial
lemma new_lemma_165486 (h0 : not (function.extfun Type ring -> false)) : @strong_rank_condition.{0} (measurable_space.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (measurable_space.{0} num))  := sorry --non-trivial
lemma new_lemma_165487 (h1 : ring (add_left_cancel_monoid linarith.comp_source)) : rank_condition (add_left_cancel_monoid linarith.comp_source) := sorry --non-trivial
lemma new_lemma_165488 (h0 : functor.add_const (group (add_comm_monoid Type)) linarith.comp) : @normalizer_condition.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (add_comm_monoid.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_165489 (h0 : functor.add_const (topological_space (add_cancel_monoid linarith.comp)) pos) : @t1_space.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_165490 (h0 : ring (normed_group char)) : strong_rank_condition (normed_group char) := sorry --non-trivial
lemma new_lemma_165491 (h0 : uniform_space (ring (has_Inf (ordered_ring name)))) : complete_space (ring (has_Inf (ordered_ring name))) := sorry --non-trivial
lemma new_lemma_165492 (h0 : as_linear_order (comm_monoid (option empty)) -> as_linear_order (comm_monoid (option empty)) -> Prop) : is_irrefl (as_linear_order (comm_monoid (option empty))) h0 := sorry --non-trivial
lemma new_lemma_165493 (h0 : complete_lattice (group_with_zero pos)) : is_atomistic (group_with_zero pos) := sorry --non-trivial
lemma new_lemma_165494 (h0 : complete_lattice (has_neg (option unsigned))) : is_atomistic (has_neg (option unsigned)) := sorry --non-trivial
lemma new_lemma_165495 (h0 : not (functor.add_const Prop (has_top congr_arg_kind) -> false)) : functor.add_const.run (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_165496 (h0 : has_mem.mem real.angle has_emptyc.emptyc) : @separated_space.{0} real.angle (@finset.pi.empty.{1 0} Type uniform_space.{0} real.angle h0)  := sorry --non-trivial
lemma new_lemma_165497 (h0 : ring (non_assoc_semiring (semiring (semiring unsigned)))) : strong_rank_condition (non_assoc_semiring (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_165498 (h0 : semiring (simple_graph (comm_monoid num))) : is_noetherian_ring (simple_graph (comm_monoid num)) := sorry --non-trivial
lemma new_lemma_165499 (h0 : topological_space (canonically_ordered_monoid (has_Inf name))) : preirreducible_space (canonically_ordered_monoid (has_Inf name)) := sorry --non-trivial
lemma new_lemma_165500 (h0 : functor.add_const (function.extfun Type uniform_space) (finset linarith.comp)) : @complete_space.{0} (canonically_ordered_comm_semiring.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) (finset.{0} linarith.comp) h0) (canonically_ordered_comm_semiring.{0} pos))  := sorry --non-trivial
lemma new_lemma_165501 (h0 : group (has_add (mul_one_class (has_add linarith.comp)))) : is_cyclic (has_add (mul_one_class (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_165502 (h0 : list (has_zero (finset linarith.comp))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_165503 (h0 : functor.add_const (ordered_add_comm_monoid (ordered_comm_group empty)) num) : @archimedean.{0} (ordered_comm_group.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (ordered_comm_group.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_165504 (h0 : group (finset (has_add (boolean_algebra linarith.comp)))) : is_simple_group (finset (has_add (boolean_algebra linarith.comp))) := sorry --non-trivial
lemma new_lemma_165505 (h0 : add_group (add_comm_monoid (has_bot (sub_neg_monoid pos)))) : is_add_cyclic (add_comm_monoid (has_bot (sub_neg_monoid pos))) := sorry --non-trivial
lemma new_lemma_165506 (h0 : cancel_comm_monoid_with_zero (has_add pos)) : unique_factorization_monoid (has_add pos) := sorry --non-trivial
lemma new_lemma_165507 (h0 : topological_space (add_cancel_monoid (has_add (has_add (has_add pos))))) : discrete_topology (add_cancel_monoid (has_add (has_add (has_add pos)))) := sorry --non-trivial
lemma new_lemma_165508 (h0 : functor.add_const (uniform_space (has_pos_part Type)) name) : @separated_space.{1} (has_pos_part.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (has_pos_part.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_165509 (h0 : filter (with_zero fun_info)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_165510 (h0 : semiring (with_bot (add_group (metric_space empty)))) : is_noetherian_ring (with_bot (add_group (metric_space empty))) := sorry --non-trivial
lemma new_lemma_165511 (h0 : functor.add_const (topological_space (comm_group Type)) Type) : @irreducible_space.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (comm_group.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_165512 (h1 : set (mul_one_class (mul_one_class ereal) -> std_gen)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_165513 (h0 : topological_space (has_add (has_neg (has_neg environment.implicit_infer_kind)))) : sequential_space (has_add (has_neg (has_neg environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_165514 (h0 : group (distrib_lattice (has_top linarith.ineq))) : group.fg (distrib_lattice (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_165515 (h0 : list (has_bot (option unsigned))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_165516 (h0 : complete_lattice (semigroup (finset pos))) : is_compactly_generated (semigroup (finset pos)) := sorry --non-trivial
lemma new_lemma_165517 (h0 : not (ring (linear_ordered_semiring unsigned) -> false)) : @strong_rank_condition.{0} (linear_ordered_semiring.{0} unsigned) (@classical.by_contradiction'.{1} (ring.{0} (linear_ordered_semiring.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_165518 (h0 : set (has_ssubset fun_info)) (h1 : has_ssubset fun_info) : set.compl h0 h1 := sorry --non-trivial
lemma new_lemma_165519 (h0 : topological_space (add_comm_monoid environment.implicit_infer_kind)) : totally_disconnected_space (add_comm_monoid environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_165520 (h0 : topological_space (semigroup (has_nndist ennreal))) : topological_space.separable_space (semigroup (has_nndist ennreal)) := sorry --non-trivial
lemma new_lemma_165521 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_top.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} h0 (has_top.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_165522 (h0 : topological_space (has_union (add_group (has_union congr_arg_kind)))) : discrete_topology (has_union (add_group (has_union congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_165523 (h0 : topological_space (generalized_boolean_algebra (has_Inf (sub_neg_monoid (sub_neg_monoid pos))))) : regular_space (generalized_boolean_algebra (has_Inf (sub_neg_monoid (sub_neg_monoid pos)))) := sorry --non-trivial
lemma new_lemma_165524 (h0 : functor.add_const (topological_space (option pos)) pos) : @regular_space.{0} (option.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_165525 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (distrib_lattice.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (distrib_lattice.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_165526 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (linear_ordered_semiring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_165527 (h0 : not (topological_space (random_gen (random_gen linarith.comp_source)) -> false)) : @t0_space.{0} (random_gen.{0} (random_gen.{0} linarith.comp_source)) (@classical.by_contradiction'.{1} (topological_space.{0} (random_gen.{0} (random_gen.{0} linarith.comp_source))) h0)  := sorry --non-trivial
lemma new_lemma_165528 (h0 : functor.add_const (group (has_neg Type)) Type) : @normalizer_condition.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 1} (group.{1} (has_neg.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_165529 (h0 : not (group (random_gen linarith.ineq) -> false)) : @is_cyclic.{0} (random_gen.{0} linarith.ineq) (@classical.by_contradiction'.{1} (group.{0} (random_gen.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_165530 (h0 : not (group (has_inv linarith.comp_source) -> false)) : @is_cyclic.{0} (has_inv.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (group.{0} (has_inv.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_165531 (h0 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} (normed_group.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h0) (normed_group.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_165532 (h0 : complete_lattice (with_bot (has_top (has_top num)))) : is_atomistic (with_bot (has_top (has_top num))) := sorry --non-trivial
lemma new_lemma_165533 (h0 : cancel_monoid ennreal -> cancel_monoid ennreal -> Prop) : is_symm (cancel_monoid ennreal) h0 := sorry --non-trivial
lemma new_lemma_165534 (h0 : functor.add_const (topological_space (boolean_algebra.core pos)) (has_nndist ennreal)) : @irreducible_space.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} pos)) (has_nndist.{0} ennreal) h0)  := sorry --non-trivial
lemma new_lemma_165535 (h0 : function.extfun Type ring) : @rank_condition.{0} (option.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} h0 (option.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_165536 (h0 : has_lt (mul_one_class ereal)) : no_max_order (mul_one_class ereal) := sorry --non-trivial
lemma new_lemma_165537 (h0 : topological_space (semi_normed_ring (has_nnnorm string.iterator_imp))) : t0_space (semi_normed_ring (has_nnnorm string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_165538 (h0 : not (topological_space (option unsigned) -> false)) : @topological_space.separable_space.{0} (option.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (option.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_165539 (h0 : function.extfun Type group) : @is_cyclic.{0} (mul_zero_class.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (mul_zero_class.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_165540 (h0 : not (uniform_space (has_norm empty) -> false)) : @separated_space.{0} (has_norm.{0} empty) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_norm.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_165541 (h0 : functor.add_const (list (semigroup empty)) (semiring congr_arg_kind)) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_165542 (h0 : ring (generalized_boolean_algebra (ring (finset pos)))) : rank_condition (generalized_boolean_algebra (ring (finset pos))) := sorry --non-trivial
lemma new_lemma_165543 (h0 : group (dlist (has_inv (has_inv (has_inv fun_info))))) : is_cyclic (dlist (has_inv (has_inv (has_inv fun_info)))) := sorry --non-trivial
lemma new_lemma_165544 (h0 : functor.add_const (ring (has_Inf Type)) name) : @rank_condition.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_Inf.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_165545 (h0 : topological_space (boolean_algebra pos)) : regular_space (boolean_algebra pos) := sorry --non-trivial
lemma new_lemma_165546 (h0 : group (normed_comm_ring (option (option ennreal)))) : normalizer_condition (normed_comm_ring (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_165547 (h0 : filter (add_group linarith.comp)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_165548 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} linarith.comp_source (@function.extfun_app.{2 1} Type topological_space.{0} h0 linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_165549 (h0 : ordered_add_comm_monoid enat -> ordered_add_comm_monoid enat -> Prop) (h2 h3 : ordered_add_comm_monoid enat) : relation.join h0 h2 h3 := sorry --non-trivial
lemma new_lemma_165550 (h0 : functor.add_const (add_monoid (plift empty)) (semiring num)) : @add_monoid.fg.{1} (plift.{1} empty) (@functor.add_const.run.{1 0} (add_monoid.{1} (plift.{1} empty)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_165551 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @preconnected_space.{1} (comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_165552 (h0 : functor.add_const (topological_space (semigroup pos)) name) : @totally_disconnected_space.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_165553 (h0 : list (finset (has_add (has_neg_part (semigroup environment.implicit_infer_kind))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_165554 (h1 : topological_space (normed_group (has_ssubset (random_gen (has_ssubset fun_info))))) : t0_space (normed_group (has_ssubset (random_gen (has_ssubset fun_info)))) := sorry --non-trivial
lemma new_lemma_165555 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @complete_lattice.is_Sup_finite_compact.{1} (canonically_ordered_comm_semiring.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 complete_lattice.{1}) (canonically_ordered_comm_semiring.{1} Type))  := sorry --non-trivial
lemma new_lemma_165556 (h0 : list (semigroup (has_neg (has_neg linarith.comp)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_165557 (h0 : functor.add_const (topological_space (free_add_monoid empty)) congr_arg_kind) : @t1_space.{0} (free_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_165558 (h0 : filter (linear_ordered_add_comm_group (random_gen string_imp))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_165559 (h0 : functor.add_const (topological_space (has_add Type)) Type) : @locally_compact_space.{1} (has_add.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_add.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_165560 (h0 : uniform_space (mul_zero_class pos)) : separated_space (mul_zero_class pos) := sorry --non-trivial
lemma new_lemma_165561 (h0 : functor.add_const (add_monoid (boolean_algebra name)) Type) : @add_monoid.fg.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 1} (add_monoid.{0} (boolean_algebra.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_165562 (h0 : function.extfun Type topological_space) : @t0_space.{0} (cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_165563 (h0 : topological_space (is_R_or_C (semiring empty))) : path_connected_space (is_R_or_C (semiring empty)) := sorry --non-trivial
lemma new_lemma_165564 (h1 : ring (topological_space reducibility_hints)) : rank_condition (topological_space reducibility_hints) := sorry --non-trivial
lemma new_lemma_165565 (h0 : functor.add_const (topological_space (add_comm_monoid Type)) name) : @t1_space.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_comm_monoid.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_165566 (h0 : topological_space (mul_one_class (measurable_space char))) : path_connected_space (mul_one_class (measurable_space char)) := sorry --non-trivial
lemma new_lemma_165567 (h0 : functor.add_const (ordered_comm_monoid (complete_distrib_lattice environment.implicit_infer_kind)) name) : @has_exists_mul_of_le.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_165568 (h0 : group (add_comm_monoid (finset (comm_group linarith.comp)))) : normalizer_condition (add_comm_monoid (finset (comm_group linarith.comp))) := sorry --non-trivial
lemma new_lemma_165569 (h0 : functor.add_const (add_group (canonically_ordered_comm_semiring unsigned)) name) : @is_add_cyclic.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@functor.add_const.run.{0 0} (add_group.{0} (canonically_ordered_comm_semiring.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_165570 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (add_group congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_165571 (h0 : ring (boolean_algebra.core (boolean_algebra.core (option pos)))) : is_principal_ideal_ring (boolean_algebra.core (boolean_algebra.core (option pos))) := sorry --non-trivial
lemma new_lemma_165572 (h0 : complete_lattice (with_bot (random_gen fun_info))) : is_compactly_generated (with_bot (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_165573 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} congr_arg_kind (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 topological_space.{0}) congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_165574 (h0 : not (topological_space (add_right_cancel_monoid unsigned) -> false)) : @totally_separated_space.{0} (add_right_cancel_monoid.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (add_right_cancel_monoid.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_165575 (h0 : functor.add_const (topological_space (has_neg_part name)) name) : @t0_space.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_165576 (h0 : topological_space (linear_ordered_comm_group_with_zero char)) (h1 : add_group (linear_ordered_comm_group_with_zero char)) : topological_add_group (linear_ordered_comm_group_with_zero char) := sorry --non-trivial
lemma new_lemma_165577 (h0 : function.extfun Type topological_space) : @normal_space.{0} (has_Inf.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_Inf.{0} name))  := sorry --non-trivial
lemma new_lemma_165578 (h0 : has_mem.mem complete_lattice has_emptyc.emptyc) : @is_atomistic.{0} (semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} h0) (semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_165579 (h0 : uniform_space (metric_space string_imp)) : complete_space (metric_space string_imp) := sorry --non-trivial
lemma new_lemma_165580 (h0 : functor.add_const (ordered_comm_monoid (semigroup linarith.comp)) (has_neg linarith.comp)) : @has_exists_mul_of_le.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (semigroup.{0} linarith.comp)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_165581 (h0 : not (cancel_comm_monoid_with_zero (partial_order num) -> false)) : @unique_factorization_monoid.{0} (partial_order.{0} num) (@classical.by_contradiction'.{1} (cancel_comm_monoid_with_zero.{0} (partial_order.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_165582 (h0 : group (has_zero (ring (ring pos)))) : is_simple_group (has_zero (ring (ring pos))) := sorry --non-trivial
lemma new_lemma_165583 (h0 : functor.add_const (function.extfun (Type 1) filter) environment.implicit_infer_kind) : countable_Inter_filter (function.extfun_app (functor.add_const.run h0) Type) := sorry --non-trivial
lemma new_lemma_165584 (h0 : filter (complete_semilattice_Sup (has_norm num))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_165585 (h0 : ordered_add_comm_monoid (complete_distrib_lattice congr_arg_kind)) : archimedean (complete_distrib_lattice congr_arg_kind) := sorry --non-trivial
lemma new_lemma_165586 (h1 : uniform_space (normed_group num)) : complete_space (normed_group num) := sorry --non-trivial
lemma new_lemma_165587 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (linear_ordered_add_comm_group.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_ordered_add_comm_group.{0} num))  := sorry --non-trivial
lemma new_lemma_165588 (h0 : complete_lattice (finset (has_Inf (normed_comm_ring Type)))) : is_compactly_generated (finset (has_Inf (normed_comm_ring Type))) := sorry --non-trivial
lemma new_lemma_165589 (h0 : group (finset name)) : is_cyclic (finset name) := sorry --non-trivial
lemma new_lemma_165590 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (measurable_space.dynkin_system.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (measurable_space.dynkin_system.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_165591 (h0 : not (complete_lattice (has_inv linarith.ineq) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_inv.{0} linarith.ineq) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_inv.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_165592 (h1 : complete_lattice (mul_one_class char)) : complete_lattice.is_Sup_finite_compact (mul_one_class char) := sorry --non-trivial
lemma new_lemma_165593 (h0 : functor.add_const (finset (has_neg pos)) Type) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_165594 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem complete_lattice)) : @is_atomistic.{0} (normed_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) complete_lattice.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (normed_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_165595 (h0 : functor.add_const (ring (add_group empty)) congr_arg_kind) : @is_domain.{0} (add_group.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (add_group.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_165596 (h0 : functor.add_const (ordered_add_comm_monoid (has_add environment.implicit_infer_kind)) Type) : @archimedean.{0} (has_add.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (ordered_add_comm_monoid.{0} (has_add.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_165597 (h0 : ring (boolean_algebra Type)) : rank_condition (boolean_algebra Type) := sorry --non-trivial
lemma new_lemma_165598 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (measurable_space.dynkin_system.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measurable_space.dynkin_system.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_165599 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_165600 (h0 : group (comm_group (add_cancel_monoid pos))) : group.fg (comm_group (add_cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_165601 (h0 : complete_lattice (id (has_norm num))) : complete_lattice.is_Sup_finite_compact (id (has_norm num)) := sorry --non-trivial
lemma new_lemma_165602 (h0 : topological_space (ordered_comm_monoid (has_add linarith.comp))) : t1_space (ordered_comm_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_165603 (h0 : not (complete_lattice (linear_ordered_semiring to_additive.value_type) -> false)) : @is_atomistic.{0} (linear_ordered_semiring.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (complete_lattice.{0} (linear_ordered_semiring.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_165604 (h0 : ring (add_comm_semigroup (normed_field (normed_group (mul_one_class enat))))) : strong_rank_condition (add_comm_semigroup (normed_field (normed_group (mul_one_class enat)))) := sorry --non-trivial
lemma new_lemma_165605 (h0 : list (boolean_algebra.core (ring Type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_165606 (h0 : ereal -> char) : function.bijective h0 := sorry --non-trivial
lemma new_lemma_165607 (h1 : group (normed_field (has_nnnorm char))) : is_cyclic (normed_field (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_165608 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (complete_semilattice_Sup.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_semilattice_Sup.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_165609 (h0 : group (comm_ring (has_nnnorm fun_info))) : group.fg (comm_ring (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_165610 (h0 : function.extfun nat fin) : @complete_space.{0} (ordered_comm_ring.{0} pos) (@matrix.vec_empty.{0} (uniform_space.{0} (ordered_comm_ring.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_165611 (h0 : functor.add_const (complete_lattice (has_neg_part environment.implicit_infer_kind)) name) : @is_compactly_generated.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_neg_part.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_165612 (h0 : topological_space (fintype (random_gen (random_gen linarith.ineq)))) : t0_space (fintype (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_165613 (h0 : function.extfun Type group) : @group.fg.{0} (option.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (option.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_165614 (h0 : topological_space (distrib (has_nnnorm (has_nnnorm (has_nnnorm linarith.ineq))))) : t0_space (distrib (has_nnnorm (has_nnnorm (has_nnnorm linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_165615 (h0 : topological_space (ring (option ennreal))) : path_connected_space (ring (option ennreal)) := sorry --non-trivial
lemma new_lemma_165616 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : countable_Inter_filter (function.extfun_app (function.extfun_app h0 filter) (add_comm_monoid num)) := sorry --non-trivial
lemma new_lemma_165617 (h0 : ring (distrib (has_nnnorm (has_nnnorm linarith.ineq)))) : is_domain (distrib (has_nnnorm (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_165618 (h0 : cancel_comm_monoid_with_zero (add_comm_monoid empty)) : unique_factorization_monoid (add_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_165619 (h0 : fin has_zero.zero) : @loc_path_connected_space.{0} (sub_neg_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (sub_neg_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_165620 (h2 : topological_space (distrib linarith.ineq)) : t0_space (distrib linarith.ineq) := sorry --non-trivial
lemma new_lemma_165621 (h0 : functor.add_const (topological_space (complete_distrib_lattice pos)) pos) : @discrete_topology.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_165622 (h0 : functor.add_const (add_group (add_cancel_monoid unsigned)) empty) : @is_add_cyclic.{0} (add_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (add_group.{0} (add_cancel_monoid.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_165623 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_165624 (h0 : group (has_nndist (finset (finset (finset (finset linarith.comp)))))) : normalizer_condition (has_nndist (finset (finset (finset (finset linarith.comp))))) := sorry --non-trivial
lemma new_lemma_165625 (h0 : functor.add_const (ordered_add_comm_monoid (canonically_ordered_monoid pos)) real) : @archimedean.{0} (canonically_ordered_monoid.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (canonically_ordered_monoid.{0} pos)) real h0)  := sorry --non-trivial
lemma new_lemma_165626 (h1 : complete_lattice (dlist (has_nnnorm linarith.ineq))) : complete_lattice.is_Sup_finite_compact (dlist (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_165627 (h0 : filter (finset (ring name))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_165628 (h0 : topological_space (ordered_comm_ring (has_bot (has_add real)))) : preirreducible_space (ordered_comm_ring (has_bot (has_add real))) := sorry --non-trivial
lemma new_lemma_165629 (h0 : functor.add_const (topological_space (omega_complete_partial_order empty)) empty) : @irreducible_space.{0} (omega_complete_partial_order.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (omega_complete_partial_order.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_165630 (h0 : complete_lattice (linear_ordered_add_comm_group (has_nnnorm fun_info))) : complete_lattice.is_Sup_finite_compact (linear_ordered_add_comm_group (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_165631 (h0 : monoid (has_zero (has_add unsigned))) : monoid.fg (has_zero (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_165632 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (measurable_space.dynkin_system.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (measurable_space.dynkin_system.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_165633 (h0 : topological_space (has_Inf real)) : path_connected_space (has_Inf real) := sorry --non-trivial
lemma new_lemma_165634 (h1 : complete_lattice (non_unital_non_assoc_semiring std_gen)) : is_compactly_generated (non_unital_non_assoc_semiring std_gen) := sorry --non-trivial
lemma new_lemma_165635 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (ordered_cancel_add_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (ordered_cancel_add_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_165636 (h0 : topological_space (linear_ordered_comm_ring (semiring (semiring num)))) : locally_compact_space (linear_ordered_comm_ring (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_165637 (h0 : ring (has_to_string (has_add pos))) : is_domain (has_to_string (has_add pos)) := sorry --non-trivial
lemma new_lemma_165638 (h0 : topological_space (mul_zero_class (boolean_algebra.core pos))) : preirreducible_space (mul_zero_class (boolean_algebra.core pos)) := sorry --non-trivial
lemma new_lemma_165639 (h0 : not (topological_space reducibility_hints -> false)) : @connected_space.{0} reducibility_hints (@classical.by_contradiction'.{1} (topological_space.{0} reducibility_hints) h0)  := sorry --non-trivial
lemma new_lemma_165640 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_top.{0} string_imp) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_top.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_165641 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (has_inter ennreal)) := sorry --non-trivial
lemma new_lemma_165642 (h0 : ring (uniform_space (semi_normed_ring (left_cancel_semigroup (uniform_space char))))) : is_domain (uniform_space (semi_normed_ring (left_cancel_semigroup (uniform_space char)))) := sorry --non-trivial
lemma new_lemma_165643 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 linarith.comp_source) := sorry --non-trivial
lemma new_lemma_165644 (h0 : topological_space (add_comm_monoid ennreal)) : topological_space.separable_space (add_comm_monoid ennreal) := sorry --non-trivial
lemma new_lemma_165645 (h0 : string.iterator_imp -> string.iterator_imp -> Prop) : is_total string.iterator_imp h0 := sorry --non-trivial
lemma new_lemma_165646 (h0 : not (function.extfun (finset Type) (has_mem.mem (linear_ordered_add_comm_group fun_info)) -> false)) : @totally_disconnected_space.{0} (linear_ordered_add_comm_group.{0} fun_info) (@finset.pi.empty.{1 0} Type topological_space.{0} (linear_ordered_add_comm_group.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (linear_ordered_add_comm_group.{0} fun_info)) (@classical.by_contradiction'.{0} (function.extfun.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (linear_ordered_add_comm_group.{0} fun_info))) h0) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_165647 (h0 : filter (has_neg (option num))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_165648 (h0 : not (function.extfun Type ring -> false)) : @strong_rank_condition.{0} (option.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (option.{0} num))  := sorry --non-trivial
lemma new_lemma_165649 (h0 : ordered_add_comm_monoid (has_nndist (has_nndist linarith.comp))) : archimedean (has_nndist (has_nndist linarith.comp)) := sorry --non-trivial
lemma new_lemma_165650 (h0 : functor.add_const (topological_space (add_comm_monoid Type)) pos) : @preirreducible_space.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_comm_monoid.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_165651 (h0 : ordered_comm_monoid (comm_semigroup real)) : has_exists_mul_of_le (comm_semigroup real) := sorry --non-trivial
lemma new_lemma_165652 (h0 : uniform_space (cancel_monoid congr_arg_kind)) : complete_space (cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_165653 (h0 : function.extfun Type topological_space) : @t0_space.{0} (mul_zero_class.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (mul_zero_class.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_165654 (h0 : not (topological_space (has_inv linarith.comp_source) -> false)) : @t0_space.{0} (has_inv.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (has_inv.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_165655 (h0 : topological_space (finset (finset (finset pos)))) : discrete_topology (finset (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_165656 (h1 : topological_space (semiring to_additive.value_type)) : t0_space (semiring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_165657 (h0 : prod (has_nndist (option ennreal)) (has_nndist (option ennreal))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_165658 (h0 : prod (has_zero num) (has_zero num)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_165659 (h0 : topological_space (mul_zero_class ennreal)) : normal_space (mul_zero_class ennreal) := sorry --non-trivial
lemma new_lemma_165660 (h0 : not (function.extfun Type group -> false)) : @normalizer_condition.{0} (metric_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (metric_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_165661 (h0 : not (has_mem.mem complete_lattice has_emptyc.emptyc -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_norm.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) complete_lattice.{0} (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type)))) h0)) (has_norm.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_165662 (h0 : complete_lattice (complete_distrib_lattice name)) : is_compactly_generated (complete_distrib_lattice name) := sorry --non-trivial
lemma new_lemma_165663 (h0 : functor.add_const (topological_space (ordered_comm_ring real)) (has_bot (has_neg real))) : @path_connected_space.{0} (ordered_comm_ring.{0} real) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} real)) (has_bot.{0} (has_neg.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_165664 (h0 : uniform_space (has_neg_part enat)) : complete_space (has_neg_part enat) := sorry --non-trivial
lemma new_lemma_165665 (h0 : functor.add_const (ring (ring name)) name) : @rank_condition.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (ring.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_165666 (h0 : topological_space (measure_theory.measure_space num)) : locally_compact_space (measure_theory.measure_space num) := sorry --non-trivial
lemma new_lemma_165667 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (canonically_ordered_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_ordered_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_165668 (h0 : linear_ordered_field (with_one congr_arg_kind)) (h1 : cau_seq (with_one congr_arg_kind) has_abs.abs) : cau_seq.pos h1 := sorry --non-trivial
lemma new_lemma_165669 (h2 : topological_space (semi_normed_comm_ring (random_gen (has_inv (random_gen (random_gen char)))))) : path_connected_space (semi_normed_comm_ring (random_gen (has_inv (random_gen (random_gen char))))) := sorry --non-trivial
lemma new_lemma_165670 (h0 : list (complete_semilattice_Sup (random_gen (random_gen fun_info)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_165671 (h0 : topological_space (measurable_space congr_arg_kind)) : irreducible_space (measurable_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_165672 (h0 : function.extfun nat fin) : @totally_disconnected_space.{1} (sub_neg_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@matrix.vec_empty.{2} (function.extfun.{3 2} (Type 1) topological_space.{1}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (sub_neg_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_165673 (h0 : filter (has_top (semiring (semiring (semiring unsigned))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_165674 (h0 : group (semigroup unsigned)) : normalizer_condition (semigroup unsigned) := sorry --non-trivial
lemma new_lemma_165675 (h0 : finset (has_add (has_Inf (has_nndist (ordered_ring (has_neg name)))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_165676 (h0 : functor.add_const (complete_lattice (boolean_algebra.core name)) linarith.comp) : @complete_lattice.is_Sup_finite_compact.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (boolean_algebra.core.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_165677 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (has_neg.{0} num) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (has_neg.{0} num))  := sorry --non-trivial
lemma new_lemma_165678 (h0 : functor.add_const (finset (boolean_algebra unsigned)) (finset Type)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_165679 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (has_union.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (has_union.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_165680 (h0 : not (filter (has_top linarith.comp) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_165681 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_to_string.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_to_string.{0} num))  := sorry --non-trivial
lemma new_lemma_165682 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (normed_group.{0} fun_info) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (normed_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_165683 (h0 : add_group (denumerable (random_gen (random_gen (random_gen (random_gen char)))))) : is_add_cyclic (denumerable (random_gen (random_gen (random_gen (random_gen char))))) := sorry --non-trivial
lemma new_lemma_165684 (h0 : prod (metric_space num) (metric_space num)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_165685 (h0 : topological_space (semi_normed_ring std_gen)) : t0_space (semi_normed_ring std_gen) := sorry --non-trivial
lemma new_lemma_165686 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} (measure_theory.measure_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (measure_theory.measure_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_165687 (h0 : not (group (partial_order empty) -> false)) : @is_cyclic.{0} (partial_order.{0} empty) (@classical.by_contradiction'.{1} (group.{0} (partial_order.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_165688 (h0 : topological_space (semigroup (option unsigned))) : topological_space.separable_space (semigroup (option unsigned)) := sorry --non-trivial
lemma new_lemma_165689 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @sequential_space.{0} (has_to_string.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (has_to_string.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_165690 (h0 : group (has_top (comm_ring (comm_ring to_additive.value_type)))) : normalizer_condition (has_top (comm_ring (comm_ring to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_165691 (h0 : functor.add_const (group (add_cancel_monoid Type)) Type) : @is_simple_group.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 1} (group.{1} (add_cancel_monoid.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_165692 (h0 : functor.add_const (ring (canonically_ordered_monoid pos)) (has_to_string pos)) : @is_principal_ideal_ring.{0} (canonically_ordered_monoid.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (canonically_ordered_monoid.{0} pos)) (has_to_string.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_165693 (h0 : function.extfun nat fin) : @group.fg.{0} (has_Inf.{0} real) (@matrix.vec_empty.{0} (group.{0} (has_Inf.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_165694 (h0 : finset (has_one empty)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_165695 (h0 : functor.add_const (ring (boolean_algebra.core Type)) (boolean_algebra pos)) : @rank_condition.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (boolean_algebra.core.{1} Type)) (boolean_algebra.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_165696 (h0 : group (add_comm_monoid pos)) : normalizer_condition (add_comm_monoid pos) := sorry --non-trivial
lemma new_lemma_165697 (h0 : topological_space (semi_normed_comm_ring environment.projection_info)) (h1 : preorder (semi_normed_comm_ring environment.projection_info)) : order_closed_topology (semi_normed_comm_ring environment.projection_info) := sorry --non-trivial
lemma new_lemma_165698 (h0 : not (topological_space (add_comm_semigroup char) -> false)) : @path_connected_space.{0} (add_comm_semigroup.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (add_comm_semigroup.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_165699 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_top.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_top.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_165700 (h0 : linarith.comp_source -> linarith.comp_source -> Prop) : well_founded h0 := sorry --non-trivial
lemma new_lemma_165701 (h0 : ring (normed_lattice_add_comm_group (canonically_ordered_monoid real))) : is_domain (normed_lattice_add_comm_group (canonically_ordered_monoid real)) := sorry --non-trivial
lemma new_lemma_165702 (h0 : add_group (plift (left_cancel_semigroup name))) : is_add_cyclic (plift (left_cancel_semigroup name)) := sorry --non-trivial
lemma new_lemma_165703 (h0 : functor.add_const (add_monoid (has_to_string Type)) (has_add pos)) : @add_monoid.fg.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (add_monoid.{1} (has_to_string.{1} Type)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_165704 (h0 : measurable_space (with_zero (random_gen (random_gen fun_info)))) (h1 : measure_theory.measure (with_zero (random_gen (random_gen fun_info)))) : measure_theory.is_probability_measure h1 := sorry --non-trivial
lemma new_lemma_165705 (h0 : topological_space (add_comm_monoid ennreal)) : t0_space (add_comm_monoid ennreal) := sorry --non-trivial
lemma new_lemma_165706 (h0 : functor.add_const (group (canonically_ordered_comm_semiring Type)) Type) : @group.fg.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.add_const.run.{1 1} (group.{1} (canonically_ordered_comm_semiring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_165707 (h0 : ring (canonically_ordered_comm_semiring (has_add Type))) : is_domain (canonically_ordered_comm_semiring (has_add Type)) := sorry --non-trivial
lemma new_lemma_165708 (h0 : function.extfun Type group) : @group.fg.{0} (measurable_space.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} h0 (measurable_space.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_165709 (h0 : ordered_comm_monoid (has_to_string (has_neg_part unsigned))) : has_exists_mul_of_le (has_to_string (has_neg_part unsigned)) := sorry --non-trivial
lemma new_lemma_165710 (h0 : function.extfun Type (functor.comp filter has_neg_part)) : countable_Inter_filter (functor.comp.run (function.extfun_app h0 pos)) := sorry --non-trivial
lemma new_lemma_165711 (h0 : functor.add_const (group (has_to_string unsigned)) linarith.comp) : @normalizer_condition.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (has_to_string.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_165712 (h0 : filter (boolean_algebra empty)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_165713 (h0 : topological_space (has_top (has_ssubset (random_gen fun_info)))) : irreducible_space (has_top (has_ssubset (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_165714 (h6 : filter (random_gen (comm_ring to_additive.value_type))) : filter.ne_bot h6 := sorry --non-trivial
lemma new_lemma_165715 (h0 : not (function.extfun Type filter -> false)) : filter.ne_bot (function.extfun_app (classical.by_contradiction' h0) (has_emptyc congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_165716 (h0 : filter (has_pos_part (has_Inf (has_Inf (has_Inf (has_Inf (has_Inf (has_Inf (has_Inf pos))))))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_165717 (h0 : group (mul_zero_class (semiring (semiring unsigned)))) : is_cyclic (mul_zero_class (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_165718 (h0 : topological_space (mul_zero_class (semiring (semiring num)))) : discrete_topology (mul_zero_class (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_165719 (h0 : uniform_space (has_pos_part name)) : complete_space (has_pos_part name) := sorry --non-trivial
lemma new_lemma_165720 (h0 : fin has_zero.zero) : @regular_space.{0} (simple_graph.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (simple_graph.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_165721 (h0 : group (add_comm_monoid environment.implicit_infer_kind)) : is_simple_group (add_comm_monoid environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_165722 (h0 : has_mem.mem (has_norm num) has_emptyc.emptyc) : @irreducible_space.{0} (has_norm.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_norm.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_165723 (h0 : functor.add_const (semiring (has_to_string environment.implicit_infer_kind)) (finset pos)) : @is_noetherian_ring.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (semiring.{0} (has_to_string.{0} environment.implicit_infer_kind)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_165724 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (measurable_space.dynkin_system.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (measurable_space.dynkin_system.{0} num))  := sorry --non-trivial
lemma new_lemma_165725 (h0 : uniform_space (add_right_cancel_monoid (semiring empty))) : complete_space (add_right_cancel_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_165726 (h0 : add_monoid (semigroup pos)) : add_monoid.fg (semigroup pos) := sorry --non-trivial
lemma new_lemma_165727 (h0 : preorder (ordered_comm_ring Type)) (h1 : fin has_zero.zero) : @Inf_convergence_class.{1} (ordered_comm_ring.{1} Type) h0 (@matrix.vec_empty.{1} (topological_space.{1} (ordered_comm_ring.{1} Type)) h1)  := sorry --non-trivial
lemma new_lemma_165728 (h0 : uniform_space (cancel_monoid Type)) : complete_space (cancel_monoid Type) := sorry --non-trivial
lemma new_lemma_165729 (h0 : group (sub_neg_monoid (has_neg name))) : is_cyclic (sub_neg_monoid (has_neg name)) := sorry --non-trivial
lemma new_lemma_165730 (h0 : topological_space (has_add (has_bot (has_Inf (has_add Type))))) : totally_separated_space (has_add (has_bot (has_Inf (has_add Type)))) := sorry --non-trivial
lemma new_lemma_165731 (h0 : functor.add_const (topological_space (complete_distrib_lattice Type)) environment.implicit_infer_kind) : @totally_disconnected_space.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (complete_distrib_lattice.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_165732 (h0 : uniform_space (has_union (semiring (semiring empty)))) : complete_space (has_union (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_165733 (h0 : function.extfun Type group) : @normalizer_condition.{0} bool (@function.extfun_app.{2 1} Type group.{0} h0 bool)  := sorry --non-trivial
lemma new_lemma_165734 (h0 : topological_space (cancel_monoid (semigroup (has_add environment.implicit_infer_kind)))) : irreducible_space (cancel_monoid (semigroup (has_add environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_165735 (h0 : not (complete_lattice (has_ssubset linarith.comp_source) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_ssubset.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_ssubset.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_165736 (h0 : set (set enat)) (h1 : set enat) (h2 : decidable (measurable_space.generate_measurable h0 h1)) : as_false (measurable_space.generate_measurable h0 h1) := sorry --non-trivial
lemma new_lemma_165737 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @is_cyclic.{0} (random_gen.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) group.{0}) (random_gen.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_165738 (h0 : add_monoid (semigroup (add_left_cancel_monoid environment.implicit_infer_kind))) : add_monoid.fg (semigroup (add_left_cancel_monoid environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_165739 (h1 : ring (distrib to_additive.value_type)) : rank_condition (distrib to_additive.value_type) := sorry --non-trivial
lemma new_lemma_165740 (h0 : finset (semigroup environment.implicit_infer_kind)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_165741 (h1 : not (uniform_space (has_lt linarith.comp_source) -> false)) : @complete_space.{0} (has_lt.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_lt.{0} linarith.comp_source)) h1)  := sorry --non-trivial
lemma new_lemma_165742 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (semiring.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_165743 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (normed_comm_ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_165744 (h0 : fin has_zero.zero) : @preconnected_space.{1} (has_add.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (has_add.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_165745 (h0 : functor.add_const (topological_space (plift empty)) empty) : @discrete_topology.{1} (plift.{1} empty) (@functor.add_const.run.{1 0} (topological_space.{1} (plift.{1} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_165746 (h0 : has_mem.mem (semiring fun_info) has_emptyc.emptyc) : @is_domain.{0} (semiring.{0} fun_info) (@finset.pi.empty.{1 0} Type ring.{0} (semiring.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_165747 (h0 : filter (has_union congr_arg_kind)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_165748 (h0 : topological_space (simple_graph char)) : t0_space (simple_graph char) := sorry --non-trivial
lemma new_lemma_165749 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (measurable_space.{0} fun_info) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (measurable_space.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_165750 (h0 : functor.add_const (ring (semigroup (has_to_string unsigned))) pos) : @strong_rank_condition.{0} (semigroup.{0} (has_to_string.{0} unsigned)) (@functor.add_const.run.{0 0} (ring.{0} (semigroup.{0} (has_to_string.{0} unsigned))) pos h0)  := sorry --non-trivial
lemma new_lemma_165751 (h1 : complete_lattice (distrib_lattice string_imp)) : is_atomistic (distrib_lattice string_imp) := sorry --non-trivial
lemma new_lemma_165752 (h0 : list (ring (finset (finset (ring (has_pos_part (has_pos_part (has_pos_part pos)))))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_165753 (h0 : complete_lattice (linear_ordered_semiring empty)) : is_compactly_generated (linear_ordered_semiring empty) := sorry --non-trivial
lemma new_lemma_165754 (h1 : has_neg std_gen) (h2 : measurable_space std_gen) : has_measurable_neg std_gen := sorry --non-trivial
lemma new_lemma_165755 (h1 : measurable_space enat) (h2 : filter enat) : filter.is_measurably_generated h2 := sorry --non-trivial
lemma new_lemma_165756 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (add_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_165757 (h2 : topological_space (has_lt linarith.comp_source)) : path_connected_space (has_lt linarith.comp_source) := sorry --non-trivial
lemma new_lemma_165758 (h0 : not (function.extfun Type topological_space -> false)) : @totally_disconnected_space.{0} (random_gen.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (random_gen.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_165759 (h0 : functor.add_const (functor.add_const (add_monoid Type) Type) pos) : @add_monoid.fg.{1} Type (@functor.add_const.run.{1 1} (add_monoid.{1} Type) Type (@functor.add_const.run.{1 0} (functor.add_const.{1 1} (add_monoid.{1} Type) Type) pos h0))  := sorry --non-trivial
lemma new_lemma_165760 (h2 : add_group (linear_ordered_add_comm_group linarith.comp_source)) : is_add_cyclic (linear_ordered_add_comm_group linarith.comp_source) := sorry --non-trivial
lemma new_lemma_165761 (h0 : uniform_space (plift (semiring num))) : complete_space (plift (semiring num)) := sorry --non-trivial
lemma new_lemma_165762 (h0 : not (complete_lattice (has_sub unsigned) -> false)) : @is_atomistic.{0} (has_sub.{0} unsigned) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_sub.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_165763 (h0 : ring (finset pos)) : is_principal_ideal_ring (finset pos) := sorry --non-trivial
lemma new_lemma_165764 (h0 : function.extfun nat fin) : @loc_path_connected_space.{1} (has_add.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (has_add.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_165765 (h0 : environment.implicit_infer_kind -> environment.implicit_infer_kind -> Prop) : id (is_well_order environment.implicit_infer_kind h0) := sorry --non-trivial
lemma new_lemma_165766 (h0 : topological_space (boolean_algebra Type)) : sequential_space (boolean_algebra Type) := sorry --non-trivial
lemma new_lemma_165767 (h0 : topological_space (ring (boolean_algebra.core name))) : locally_compact_space (ring (boolean_algebra.core name)) := sorry --non-trivial
lemma new_lemma_165768 (h0 : functor.add_const (list (ordered_comm_ring linarith.comp)) name) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_165769 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (option.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (option.{0} empty))  := sorry --non-trivial
lemma new_lemma_165770 (h0 : topological_space (boolean_algebra environment.implicit_infer_kind)) : irreducible_space (boolean_algebra environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_165771 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (complete_distrib_lattice.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} name))  := sorry --non-trivial
lemma new_lemma_165772 (h0 : list (has_nndist ennreal)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_165773 (h0 : topological_space (metric_space (random_gen num))) : t0_space (metric_space (random_gen num)) := sorry --non-trivial
lemma new_lemma_165774 (h0 : function.extfun Type topological_space) : @t0_space.{0} (linear_ordered_comm_ring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_165775 (h0 : topological_space (generalized_boolean_algebra (ordered_ring name))) : sequential_space (generalized_boolean_algebra (ordered_ring name)) := sorry --non-trivial
lemma new_lemma_165776 (h0 : ring (has_inter (has_neg num))) : is_principal_ideal_ring (has_inter (has_neg num)) := sorry --non-trivial
lemma new_lemma_165777 (h0 : uniform_space (complete_distrib_lattice (option (option name)))) : separated_space (complete_distrib_lattice (option (option name))) := sorry --non-trivial
lemma new_lemma_165778 (h0 : list (complete_distrib_lattice (option pos))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_165779 (h0 : topological_space (with_one (comm_ring fun_info))) : path_connected_space (with_one (comm_ring fun_info)) := sorry --non-trivial
lemma new_lemma_165780 (h0 : functor.add_const (monoid (comm_group name)) Type) : @monoid.fg.{0} (comm_group.{0} name) (@functor.add_const.run.{0 1} (monoid.{0} (comm_group.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_165781 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (linear_ordered_add_comm_group.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (linear_ordered_add_comm_group.{0} num))  := sorry --non-trivial
lemma new_lemma_165782 (h0 : semiring (has_pos_part (has_Inf (has_Inf linarith.comp)))) : is_noetherian_ring (has_pos_part (has_Inf (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_165783 (h0 : function.extfun Type (functor.comp cancel_comm_monoid_with_zero ring)) : @unique_factorization_monoid.{0} (ring.{0} (normed_comm_ring.{0} environment.implicit_infer_kind)) (@functor.comp.run.{0 0 0} cancel_comm_monoid_with_zero.{0} ring.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} cancel_comm_monoid_with_zero.{0} ring.{0}) h0 (normed_comm_ring.{0} environment.implicit_infer_kind)))  := sorry --non-trivial
lemma new_lemma_165784 (h0 : functor.add_const (group (finset linarith.comp)) (finset linarith.comp)) : @group.fg.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (finset.{0} linarith.comp)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_165785 (h0 : topological_space (finset (has_neg Type))) : topological_space.separable_space (finset (has_neg Type)) := sorry --non-trivial
lemma new_lemma_165786 (h0 : topological_space (has_top (semiring (semiring congr_arg_kind)))) : discrete_topology (has_top (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_165787 (h1 : function.extfun Type topological_space) : @path_connected_space.{0} (semiring.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (semiring.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_165788 (h0 : functor.add_const (add_monoid (ring unsigned)) pos) : @add_monoid.fg.{0} (ring.{0} unsigned) (@functor.add_const.run.{0 0} (add_monoid.{0} (ring.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_165789 (h0 : complete_lattice (has_Sup congr_arg_kind)) : is_atomistic (has_Sup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_165790 (h0 : topological_space (pseudo_metric_space num)) : irreducible_space (pseudo_metric_space num) := sorry --non-trivial
lemma new_lemma_165791 (h0 : functor.add_const (group (canonically_ordered_comm_semiring environment.implicit_infer_kind)) unsigned) : @is_cyclic.{0} (canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_165792 (h0 : functor.add_const (topological_space (has_zero environment.implicit_infer_kind)) (boolean_algebra name)) : @loc_path_connected_space.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} environment.implicit_infer_kind)) (boolean_algebra.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_165793 (h0 : set (prod empty empty)) : symmetric_rel h0 := sorry --non-trivial
lemma new_lemma_165794 (h0 : not (topological_space (has_union empty) -> false)) : @path_connected_space.{0} (has_union.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (has_union.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_165795 (h0 : monoid (has_norm string_imp)) : monoid.fg (has_norm string_imp) := sorry --non-trivial
lemma new_lemma_165796 (h0 : functor.add_const (topological_space (comm_group environment.implicit_infer_kind)) Type) : @loc_path_connected_space.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (comm_group.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_165797 (h0 : topological_space (has_div (mul_one_class (mul_one_class string.iterator_imp)))) : t0_space (has_div (mul_one_class (mul_one_class string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_165798 (h0 : group (with_one to_additive.value_type)) : group.fg (with_one to_additive.value_type) := sorry --non-trivial
lemma new_lemma_165799 (h0 : fin has_zero.zero) : @complete_lattice.is_Sup_finite_compact.{0} (ordered_comm_ring.{0} real) (@matrix.vec_empty.{0} (complete_lattice.{0} (ordered_comm_ring.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_165800 (h0 : functor.add_const (uniform_space (normed_comm_ring name)) Type) : @complete_space.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 1} (uniform_space.{0} (normed_comm_ring.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_165801 (h0 : finset (has_Inf (finset name))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_165802 (h0 : complete_lattice (with_one (has_norm num))) : is_atomistic (with_one (has_norm num)) := sorry --non-trivial
lemma new_lemma_165803 (h0 : topological_space (add_cancel_comm_monoid (random_gen linarith.comp_source))) : t0_space (add_cancel_comm_monoid (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_165804 (h0 : group (canonically_linear_ordered_monoid (has_Inf linarith.comp))) : group.fg (canonically_linear_ordered_monoid (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_165805 (h0 : uniform_space (free_add_monoid empty)) : complete_space (free_add_monoid empty) := sorry --non-trivial
lemma new_lemma_165806 (h0 : add_group (linear_ordered_comm_monoid_with_zero (option unsigned))) : is_add_cyclic (linear_ordered_comm_monoid_with_zero (option unsigned)) := sorry --non-trivial
lemma new_lemma_165807 (h0 : complete_lattice congr_arg_kind) : is_atomistic congr_arg_kind := sorry --non-trivial
lemma new_lemma_165808 (h0 : topological_space (has_nnnorm (random_gen string.iterator_imp))) : totally_disconnected_space (has_nnnorm (random_gen string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_165809 (h0 : function.extfun Type group) : @is_cyclic.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} h0 (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_165810 (h0 : not (topological_space linarith.comp_source -> false)) (h1 : preorder linarith.comp_source) : @order_topology.{0} linarith.comp_source (@classical.by_contradiction'.{1} (topological_space.{0} linarith.comp_source) h0) h1  := sorry --non-trivial
lemma new_lemma_165811 (h0 : ring (cancel_monoid (has_add (has_add (has_add (finset unsigned)))))) : strong_rank_condition (cancel_monoid (has_add (has_add (has_add (finset unsigned))))) := sorry --non-trivial
lemma new_lemma_165812 (h0 : filter (has_inter unsigned)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_165813 (h0 : filter (encodable (random_gen to_additive.value_type))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_165814 (h0 : functor.add_const (complete_lattice (has_nndist empty)) unsigned) : @is_atomistic.{0} (has_nndist.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_nndist.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_165815 (h0 : function.extfun Type ring) : @rank_condition.{0} (ordered_comm_group.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (ordered_comm_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_165816 (h0 : has_lt (nondiscrete_normed_field (add_comm_semigroup (has_ssubset string.iterator_imp)))) : no_max_order (nondiscrete_normed_field (add_comm_semigroup (has_ssubset string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_165817 (h0 : topological_space (has_to_string ennreal)) : irreducible_space (has_to_string ennreal) := sorry --non-trivial
lemma new_lemma_165818 (h0 : not (monoid (with_bot fun_info) -> false)) : @monoid.fg.{0} (with_bot.{0} fun_info) (@classical.by_contradiction'.{1} (monoid.{0} (with_bot.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_165819 (h0 : functor.add_const (topological_space (add_cancel_comm_monoid empty)) empty) : @irreducible_space.{0} (add_cancel_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_comm_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_165820 (h0 : functor.add_const (topological_space (add_cancel_monoid Type)) Type) : @normal_space.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (add_cancel_monoid.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_165821 (h0 : functor.comp topological_space ring pos) : @locally_compact_space.{0} (ring.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} ring.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_165822 (h0 : topological_space (add_comm_monoid (finset linarith.comp))) : discrete_topology (add_comm_monoid (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_165823 (h0 : topological_space (canonically_linear_ordered_monoid Type)) : path_connected_space (canonically_linear_ordered_monoid Type) := sorry --non-trivial
lemma new_lemma_165824 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem ring)) : @is_domain.{0} (with_bot.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) ring.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (with_bot.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_165825 (h0 : group (normed_group (random_gen (has_inv fun_info)))) : is_cyclic (normed_group (random_gen (has_inv fun_info))) := sorry --non-trivial
lemma new_lemma_165826 (h0 : function.extfun Type (functor.add_const (ordered_add_comm_monoid (semigroup empty)))) : @archimedean.{0} (semigroup.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (semigroup.{0} empty)) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ordered_add_comm_monoid.{0} (semigroup.{0} empty))) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_165827 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (has_zero.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_165828 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @is_add_cyclic.{0} (complete_semilattice_Sup.{0} string_imp) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) add_group.{0}) (complete_semilattice_Sup.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_165829 (h0 : functor.add_const (topological_space (has_pos_part linarith.comp)) pos) : @sequential_space.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_165830 (h0 : functor.add_const (function.extfun Type monoid) pos) : @monoid.fg.{0} (has_zero.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type monoid.{0}) pos h0) (has_zero.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_165831 (h0 : functor.add_const (filter (normed_comm_ring linarith.comp)) (has_neg (has_neg Type))) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_165832 (h0 : topological_space (add_group (semiring (has_norm (semiring (has_norm (has_norm linarith.comp))))))) : t0_space (add_group (semiring (has_norm (semiring (has_norm (has_norm linarith.comp)))))) := sorry --non-trivial
lemma new_lemma_165833 (h1 : group (has_append (metric_space (denumerable (has_nnnorm to_additive.value_type))))) : is_cyclic (has_append (metric_space (denumerable (has_nnnorm to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_165834 (h0 : topological_space (encodable string_imp)) : t0_space (encodable string_imp) := sorry --non-trivial
lemma new_lemma_165835 (h0 : ring (has_div fun_info)) : is_domain (has_div fun_info) := sorry --non-trivial
lemma new_lemma_165836 (h0 : functor.add_const (topological_space (has_neg_part name)) (comm_group Type)) : @normal_space.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg_part.{0} name)) (comm_group.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_165837 (h0 : complete_lattice (partial_order (has_top (has_top empty)))) : is_atomistic (partial_order (has_top (has_top empty))) := sorry --non-trivial
lemma new_lemma_165838 (h0 : topological_space (measurable_space unsigned)) : t0_space (measurable_space unsigned) := sorry --non-trivial
lemma new_lemma_165839 (h0 : function.extfun Type (functor.comp topological_space has_to_string)) : @topological_space.separable_space.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} has_to_string.{0} environment.implicit_infer_kind (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} has_to_string.{0}) h0 environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_165840 (h0 : topological_space (has_ssubset to_additive.value_type)) : irreducible_space (has_ssubset to_additive.value_type) := sorry --non-trivial
lemma new_lemma_165841 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (sub_neg_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (sub_neg_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_165842 (h0 : filter (has_Sup to_additive.value_type)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_165843 (h4 : set (finset (has_add enat) -> char)) : set.separates_points h4 := sorry --non-trivial
lemma new_lemma_165844 (h1 : semiring environment.implicit_infer_kind) (h2 : ideal environment.implicit_infer_kind) : ideal.is_prime h2 := sorry --non-trivial
lemma new_lemma_165845 (h0 : ring (has_pos_part (has_add Type))) : rank_condition (has_pos_part (has_add Type)) := sorry --non-trivial
lemma new_lemma_165846 (h0 : measurable_space (boolean_algebra.core ennreal)) (h1 : measure_theory.measure (boolean_algebra.core ennreal)) : measure_theory.is_probability_measure h1 := sorry --non-trivial
lemma new_lemma_165847 (h0 : semiring (add_left_cancel_semigroup (semiring (semiring empty)))) : is_noetherian_ring (add_left_cancel_semigroup (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_165848 (h0 : list (normed_group (has_inv fun_info))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_165849 (h0 : monoid (has_one (linear_ordered_semiring (semiring empty)))) : monoid.fg (has_one (linear_ordered_semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_165850 (h0 : topological_space (has_nndist (finset (finset (finset pos))))) : discrete_topology (has_nndist (finset (finset (finset pos)))) := sorry --non-trivial
lemma new_lemma_165851 (h0 : functor.add_const (complete_lattice (canonically_ordered_monoid name)) (has_bot Type)) : @complete_lattice.is_Sup_finite_compact.{0} (canonically_ordered_monoid.{0} name) (@functor.add_const.run.{0 1} (complete_lattice.{0} (canonically_ordered_monoid.{0} name)) (has_bot.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_165852 (h0 : ring (ring (add_comm_monoid (has_add Type)))) : strong_rank_condition (ring (add_comm_monoid (has_add Type))) := sorry --non-trivial
lemma new_lemma_165853 (h0 : complete_lattice (normed_lattice_add_comm_group (has_add Type))) : complete_lattice.is_Sup_finite_compact (normed_lattice_add_comm_group (has_add Type)) := sorry --non-trivial
lemma new_lemma_165854 (h0 : functor.add_const Prop (ring (option pos))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_165855 (h0 : function.extfun Type group) : @group.fg.{0} (complete_semilattice_Sup.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} h0 (complete_semilattice_Sup.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_165856 (h0 : topological_space (has_inner num num)) : totally_separated_space (has_inner num num) := sorry --non-trivial
lemma new_lemma_165857 (h0 : functor.add_const (ordered_add_comm_monoid (semigroup name)) Type) : @archimedean.{0} (semigroup.{0} name) (@functor.add_const.run.{0 1} (ordered_add_comm_monoid.{0} (semigroup.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_165858 (h1 : ring (add_left_cancel_monoid (random_gen fun_info))) : strong_rank_condition (add_left_cancel_monoid (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_165859 (h0 : topological_space (complete_distrib_lattice (normed_comm_ring (finset Type)))) : path_connected_space (complete_distrib_lattice (normed_comm_ring (finset Type))) := sorry --non-trivial
lemma new_lemma_165860 (h0 : cancel_comm_monoid_with_zero (has_bot (has_neg name))) : unique_factorization_monoid (has_bot (has_neg name)) := sorry --non-trivial
lemma new_lemma_165861 (h0 : group (normed_comm_ring empty)) : is_cyclic (normed_comm_ring empty) := sorry --non-trivial
lemma new_lemma_165862 (h0 : uniform_space (mul_zero_class Type)) : separated_space (mul_zero_class Type) := sorry --non-trivial
lemma new_lemma_165863 (h0 : topological_space (has_Inf (sub_neg_monoid pos))) : path_connected_space (has_Inf (sub_neg_monoid pos)) := sorry --non-trivial
lemma new_lemma_165864 (h0 : function.extfun nat fin) : @unique_factorization_monoid.{0} (has_bot.{0} real) (@matrix.vec_empty.{0} (cancel_comm_monoid_with_zero.{0} (has_bot.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_165865 (h0 : topological_space (has_neg_part (boolean_algebra (has_add pos)))) : totally_disconnected_space (has_neg_part (boolean_algebra (has_add pos))) := sorry --non-trivial
lemma new_lemma_165866 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (normed_comm_ring ennreal)) := sorry --non-trivial
lemma new_lemma_165867 (h1 : topological_space enat) (h2 : preorder enat) : order_topology enat := sorry --non-trivial
lemma new_lemma_165868 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_165869 (h2 : ring (normed_field char)) : is_domain (normed_field char) := sorry --non-trivial
lemma new_lemma_165870 (h0 : ordered_add_comm_monoid (has_star congr_arg_kind)) : archimedean (has_star congr_arg_kind) := sorry --non-trivial
lemma new_lemma_165871 (h0 : ring (measure_theory.measure_space (semiring unsigned))) : rank_condition (measure_theory.measure_space (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_165872 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (cancel_monoid.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (cancel_monoid.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_165873 (h0 : topological_space (with_one (random_gen (measurable_space (measurable_space empty))))) : irreducible_space (with_one (random_gen (measurable_space (measurable_space empty)))) := sorry --non-trivial
lemma new_lemma_165874 (h0 : topological_space fun_info) (h1 : has_sub fun_info) : has_continuous_sub fun_info := sorry --non-trivial
lemma new_lemma_165875 (h0 : topological_space (sub_neg_monoid (has_add linarith.comp))) : irreducible_space (sub_neg_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_165876 (h0 : complete_lattice (has_top (linear_ordered_add_comm_group (random_gen linarith.comp_source)))) : is_compactly_generated (has_top (linear_ordered_add_comm_group (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_165877 (h0 : list (semigroup (has_neg_part pos))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_165878 (h0 : ring (has_append (has_ssubset (has_ssubset char)))) : rank_condition (has_append (has_ssubset (has_ssubset char))) := sorry --non-trivial
lemma new_lemma_165879 (h0 : ring (pseudo_metric_space (option (option (option (option (option ennreal))))))) : is_domain (pseudo_metric_space (option (option (option (option (option ennreal)))))) := sorry --non-trivial
lemma new_lemma_165880 (h0 : functor.add_const (add_monoid (ring pos)) Type) : @add_monoid.fg.{0} (ring.{0} pos) (@functor.add_const.run.{0 1} (add_monoid.{0} (ring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_165881 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : countable_Inter_filter (function.extfun_app (function.extfun_app h0 filter) (option ennreal)) := sorry --non-trivial
lemma new_lemma_165882 (h0 : complete_lattice (has_norm (random_gen (has_nnnorm fun_info)))) : is_compactly_generated (has_norm (random_gen (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_165883 (h0 : topological_space (canonically_ordered_comm_semiring (option empty))) : path_connected_space (canonically_ordered_comm_semiring (option empty)) := sorry --non-trivial
lemma new_lemma_165884 (h0 : fin has_zero.zero) : @locally_compact_space.{1} (boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (boolean_algebra.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_165885 (h0 : not (function.extfun Type list -> false)) : list.nodup (function.extfun_app (classical.by_contradiction' h0) (dlist linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_165886 (h0 : ring (comm_semigroup (has_Inf real))) : strong_rank_condition (comm_semigroup (has_Inf real)) := sorry --non-trivial
lemma new_lemma_165887 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @t1_space.{0} (has_bot.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (has_bot.{0} real))  := sorry --non-trivial
lemma new_lemma_165888 (h0 : functor.add_const (filter (complete_distrib_lattice pos)) name) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_165889 (h0 : topological_space (canonically_ordered_comm_semiring (has_pos_part Type))) : locally_compact_space (canonically_ordered_comm_semiring (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_165890 (h0 : topological_space (add_cancel_monoid (option (option empty)))) : totally_separated_space (add_cancel_monoid (option (option empty))) := sorry --non-trivial
lemma new_lemma_165891 (h0 : topological_space (normed_comm_ring (has_add unsigned))) : preirreducible_space (normed_comm_ring (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_165892 (h1 : ring (denumerable (random_gen reducibility_hints))) : is_domain (denumerable (random_gen reducibility_hints)) := sorry --non-trivial
lemma new_lemma_165893 (h0 : complete_lattice (semigroup linarith.comp)) : is_compactly_generated (semigroup linarith.comp) := sorry --non-trivial
lemma new_lemma_165894 (h0 : functor.add_const (functor.add_const (ordered_comm_monoid (ring linarith.comp)) linarith.comp) linarith.comp) : @has_exists_mul_of_le.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (ring.{0} linarith.comp)) linarith.comp (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (ordered_comm_monoid.{0} (ring.{0} linarith.comp)) linarith.comp) linarith.comp h0))  := sorry --non-trivial
lemma new_lemma_165895 (h0 : topological_space (mul_zero_class (semiring empty))) : topological_space.separable_space (mul_zero_class (semiring empty)) := sorry --non-trivial
lemma new_lemma_165896 (h1 : add_group (id (random_gen num))) : is_add_cyclic (id (random_gen num)) := sorry --non-trivial
lemma new_lemma_165897 (h0 : functor.add_const (topological_space (boolean_algebra Type)) Type) : @t1_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (boolean_algebra.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_165898 (h0 : fin has_zero.zero) : matrix.vec_empty (ulower.up (matrix.vec_empty (matrix.vec_empty (id (matrix.vec_empty h0))))) := sorry --non-trivial
lemma new_lemma_165899 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (has_add.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_add.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_165900 (h0 : uniform_space (plift (semiring empty))) : separated_space (plift (semiring empty)) := sorry --non-trivial
lemma new_lemma_165901 (h0 : topological_space (has_add (finset environment.implicit_infer_kind))) : t1_space (has_add (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_165902 (h0 : functor.add_const (function.extfun Type group) pos) : @is_cyclic.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) pos h0) (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_165903 (h0 : topological_space (sub_neg_monoid (has_add linarith.comp))) : discrete_topology (sub_neg_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_165904 (h0 : functor.add_const (ordered_comm_monoid (add_cancel_monoid linarith.comp)) (comm_group linarith.comp)) : @has_exists_mul_of_le.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (add_cancel_monoid.{0} linarith.comp)) (comm_group.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_165905 (h0 : functor.add_const (ring (has_zero pos)) Type) : @strong_rank_condition.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (has_zero.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_165906 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @preirreducible_space.{0} (ordered_comm_monoid.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_monoid.{0} pos)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_165907 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (linear_ordered_field.{0} name) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (linear_ordered_field.{0} name))  := sorry --non-trivial
lemma new_lemma_165908 (h0 : topological_space (canonically_ordered_comm_semiring (has_add pos))) : t0_space (canonically_ordered_comm_semiring (has_add pos)) := sorry --non-trivial
lemma new_lemma_165909 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (partial_order.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (partial_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_165910 (h0 : functor.add_const (ordered_comm_monoid (has_add linarith.comp)) environment.implicit_infer_kind) : @has_exists_mul_of_le.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_add.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_165911 (h0 : not (complete_lattice (partial_order unsigned) -> false)) : @is_compactly_generated.{0} (partial_order.{0} unsigned) (@classical.by_contradiction'.{1} (complete_lattice.{0} (partial_order.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_165912 (h0 : function.extfun nat fin) : @is_atomistic.{1} (comm_semigroup.{1} Type) (@matrix.vec_empty.{1} (complete_lattice.{1} (comm_semigroup.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_165913 (h0 : ring (measure_theory.measure_space fun_info)) : rank_condition (measure_theory.measure_space fun_info) := sorry --non-trivial
lemma new_lemma_165914 (h0 : topological_space (semigroup (has_nndist linarith.comp))) : totally_separated_space (semigroup (has_nndist linarith.comp)) := sorry --non-trivial
lemma new_lemma_165915 (h0 : not (topological_space (has_emptyc congr_arg_kind) -> false)) : @totally_separated_space.{0} (has_emptyc.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (has_emptyc.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_165916 (h0 : topological_space (boolean_algebra.core (has_add environment.implicit_infer_kind))) : irreducible_space (boolean_algebra.core (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_165917 (h0 : has_mem.mem (normed_group (semiring linarith.comp)) has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} (normed_group.{0} (semiring.{0} linarith.comp)) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (normed_group.{0} (semiring.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_165918 (h0 : function.extfun Type topological_space) : @regular_space.{0} (canonically_linear_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_linear_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_165919 (h0 : list (has_neg_part ennreal)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_165920 (h0 : function.extfun Type (functor.add_const (topological_space (has_dist empty)))) : @t1_space.{0} (has_dist.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_dist.{0} empty)) congr_arg_kind (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (has_dist.{0} empty))) h0 congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_165921 (h0 : topological_space (ring (has_add (has_neg Type)))) : loc_path_connected_space (ring (has_add (has_neg Type))) := sorry --non-trivial
lemma new_lemma_165922 (h0 : function.extfun Type group) : @is_cyclic.{0} unsigned (@function.extfun_app.{2 1} Type group.{0} h0 unsigned)  := sorry --non-trivial
lemma new_lemma_165923 (h0 : functor.add_const (group (semigroup linarith.comp)) (ring pos)) : @is_simple_group.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (semigroup.{0} linarith.comp)) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_165924 (h0 : prod (has_bot pos) (has_bot pos)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_165925 (h0 : uniform_space (non_unital_non_assoc_semiring (has_ssubset string_imp))) : complete_space (non_unital_non_assoc_semiring (has_ssubset string_imp)) := sorry --non-trivial
lemma new_lemma_165926 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (ordered_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_165927 (h0 : topological_space (multiplicative string.iterator_imp)) (h1 : option (topological_space (multiplicative string.iterator_imp))) : totally_disconnected_space (multiplicative string.iterator_imp) := sorry --non-trivial
lemma new_lemma_165928 (h0 : not (complete_lattice linarith.ineq -> false)) : @complete_lattice.is_Sup_finite_compact.{0} linarith.ineq (@classical.by_contradiction'.{1} (complete_lattice.{0} linarith.ineq) h0)  := sorry --non-trivial
lemma new_lemma_165929 (h2 : uniform_space (encodable (random_gen string_imp))) : complete_space (encodable (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_165930 (h0 : not (complete_lattice (complete_linear_order empty) -> false)) : @is_atomistic.{0} (complete_linear_order.{0} empty) (@classical.by_contradiction'.{1} (complete_lattice.{0} (complete_linear_order.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_165931 (h0 : has_lt (simple_graph enat)) : no_max_order (simple_graph enat) := sorry --non-trivial
lemma new_lemma_165932 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_dist.{0} (option.{0} num)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_dist.{0} (option.{0} num)))  := sorry --non-trivial
lemma new_lemma_165933 (h1 : topological_space (semiring fun_info)) : locally_compact_space (semiring fun_info) := sorry --non-trivial
lemma new_lemma_165934 (h0 : has_add (complete_distrib_lattice congr_arg_kind) -> has_add (complete_distrib_lattice congr_arg_kind) -> Prop) : is_symm (has_add (complete_distrib_lattice congr_arg_kind)) h0 := sorry --non-trivial
lemma new_lemma_165935 (h0 : functor.add_const (function.extfun Type ring) environment.implicit_infer_kind) : @rank_condition.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) environment.implicit_infer_kind h0) (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_165936 (h0 : prod (cancel_monoid name) (cancel_monoid name)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_165937 (h0 : topological_space (has_nnnorm to_additive.value_type)) : totally_disconnected_space (has_nnnorm to_additive.value_type) := sorry --non-trivial
lemma new_lemma_165938 (h0 : functor.add_const (ring (has_nndist Type)) linarith.comp) : @is_principal_ideal_ring.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_nndist.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_165939 (h0 : cancel_comm_monoid_with_zero (semigroup (comm_group name))) : unique_factorization_monoid (semigroup (comm_group name)) := sorry --non-trivial
lemma new_lemma_165940 (h0 : functor.add_const (complete_lattice (has_to_string pos)) linarith.comp) : @is_compactly_generated.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_to_string.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_165941 (h0 : add_group (has_append linarith.ineq)) : is_add_cyclic (has_append linarith.ineq) := sorry --non-trivial
lemma new_lemma_165942 (h0 : topological_space (normed_comm_ring (has_add pos))) : sequential_space (normed_comm_ring (has_add pos)) := sorry --non-trivial
lemma new_lemma_165943 (h0 : functor.add_const (complete_lattice (boolean_algebra Type)) Type) : @complete_lattice.is_Sup_finite_compact.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 1} (complete_lattice.{1} (boolean_algebra.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_165944 (h0 : ring (distrib to_additive.value_type)) : is_domain (distrib to_additive.value_type) := sorry --non-trivial
lemma new_lemma_165945 (h3 : not (uniform_space (has_nnnorm string_imp) -> false)) : @complete_space.{0} (has_nnnorm.{0} string_imp) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_nnnorm.{0} string_imp)) h3)  := sorry --non-trivial
lemma new_lemma_165946 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (complete_distrib_lattice.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_distrib_lattice.{0} pos))  := sorry --non-trivial
lemma new_lemma_165947 (h0 : prod (sub_neg_monoid Type) (sub_neg_monoid Type)) : set.diagonal (sub_neg_monoid Type) h0 := sorry --non-trivial
lemma new_lemma_165948 (h0 : uniform_space (with_one (random_gen congr_arg_kind))) : separated_space (with_one (random_gen congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_165949 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (finset.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (finset.{0} num))  := sorry --non-trivial
lemma new_lemma_165950 (h0 : topological_space (linear_ordered_comm_ring (semiring (semiring empty)))) : normal_space (linear_ordered_comm_ring (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_165951 (h0 : complete_lattice (has_to_string (option (option (option (option ennreal)))))) : is_compactly_generated (has_to_string (option (option (option (option ennreal))))) := sorry --non-trivial
lemma new_lemma_165952 (h0 : ordered_comm_monoid (ring (has_to_string (has_to_string (has_add (ring pos)))))) : has_exists_mul_of_le (ring (has_to_string (has_to_string (has_add (ring pos))))) := sorry --non-trivial
lemma new_lemma_165953 (h0 : ring (complete_semilattice_Sup (has_top num))) : strong_rank_condition (complete_semilattice_Sup (has_top num)) := sorry --non-trivial
lemma new_lemma_165954 (h0 : preorder (has_div (mul_one_class (mul_one_class (mul_one_class (mul_one_class (mul_one_class char))))))) (h1 : set (has_div (mul_one_class (mul_one_class (mul_one_class (mul_one_class (mul_one_class char))))))) : set.is_pwo h1 := sorry --non-trivial
lemma new_lemma_165955 (h0 : complete_lattice (free_add_monoid unsigned)) : is_compactly_generated (free_add_monoid unsigned) := sorry --non-trivial
lemma new_lemma_165956 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (option.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (option.{0} num))  := sorry --non-trivial
lemma new_lemma_165957 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem complete_lattice)) : @is_atomistic.{0} linarith.comp_source (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) complete_lattice.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_165958 (h0 : empty -> empty -> empty) : right_cancelative h0 := sorry --non-trivial
lemma new_lemma_165959 (h0 : not (ring (semi_normed_comm_ring linarith.comp_source) -> false)) : @rank_condition.{0} (semi_normed_comm_ring.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (semi_normed_comm_ring.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_165960 (h0 : topological_space (ordered_comm_group unsigned)) : loc_path_connected_space (ordered_comm_group unsigned) := sorry --non-trivial
lemma new_lemma_165961 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (ordered_cancel_add_comm_monoid.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_cancel_add_comm_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_165962 (h0 : functor.add_const (finset (has_pos_part linarith.comp)) name) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_165963 (h0 : group (has_norm (has_inv fun_info))) : group.fg (has_norm (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_165964 (h0 : functor.add_const (monoid auto.case_option) (option unsigned)) : @monoid.fg.{0} auto.case_option (@functor.add_const.run.{0 0} (monoid.{0} auto.case_option) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_165965 (h0 : has_mem.mem to_additive.value_type has_emptyc.emptyc) : @discrete_topology.{0} to_additive.value_type (@finset.pi.empty.{1 0} Type topological_space.{0} to_additive.value_type h0)  := sorry --non-trivial
lemma new_lemma_165966 (h0 : functor.add_const (group (finset pos)) environment.implicit_infer_kind) : @group.fg.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (finset.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_165967 (h0 : ring (has_nndist (finset (finset (finset (finset (finset ennreal))))))) : rank_condition (has_nndist (finset (finset (finset (finset (finset ennreal)))))) := sorry --non-trivial
lemma new_lemma_165968 (h0 : add_group (simple_graph ereal)) : is_add_cyclic (simple_graph ereal) := sorry --non-trivial
lemma new_lemma_165969 (h0 : function.extfun Type (functor.comp topological_space finset)) : @normal_space.{0} (finset.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} finset.{0} ennreal (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} finset.{0}) h0 ennreal))  := sorry --non-trivial
lemma new_lemma_165970 (h0 : group (simple_graph (has_add (has_add (ring (has_add (has_add (has_Inf (has_add Type))))))))) : group.fg (simple_graph (has_add (has_add (ring (has_add (has_add (has_Inf (has_add Type)))))))) := sorry --non-trivial
lemma new_lemma_165971 (h0 : uniform_space (comm_ring to_additive.value_type)) : complete_space (comm_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_165972 (h0 : topological_space (normed_linear_ordered_group (semiring (semiring empty)))) : t1_space (normed_linear_ordered_group (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_165973 (h0 : functor.add_const (semiring (has_add Type)) (finset Type)) : @is_noetherian_ring.{1} (has_add.{1} Type) (@functor.add_const.run.{1 1} (semiring.{1} (has_add.{1} Type)) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_165974 (h0 : topological_space (has_Inf name)) : locally_compact_space (has_Inf name) := sorry --non-trivial
lemma new_lemma_165975 (h0 : ring (distrib_lattice (linear_ordered_add_comm_group linarith.comp_source))) : rank_condition (distrib_lattice (linear_ordered_add_comm_group linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_165976 (h0 : add_group (has_ssubset string_imp)) : is_add_cyclic (has_ssubset string_imp) := sorry --non-trivial
lemma new_lemma_165977 (h0 : has_coe (add_comm_semigroup (add_comm_semigroup enat)) Prop) (h1 : add_comm_semigroup (add_comm_semigroup enat)) : @coe_b.{1 1} (add_comm_semigroup.{0} (add_comm_semigroup.{0} enat)) Prop h0 h1  := sorry --non-trivial
lemma new_lemma_165978 (h0 : ring (cancel_monoid (finset (finset pos)))) : strong_rank_condition (cancel_monoid (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_165979 (h0 : topological_space (add_cancel_monoid (has_nndist pos))) : discrete_topology (add_cancel_monoid (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_165980 (h0 : fin has_zero.zero) : @sequential_space.{0} (has_pos_part.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (has_pos_part.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_165981 (h0 : topological_space (add_comm_monoid (sub_neg_monoid (sub_neg_monoid name)))) : sequential_space (add_comm_monoid (sub_neg_monoid (sub_neg_monoid name))) := sorry --non-trivial
lemma new_lemma_165982 (h2 : set (nondiscrete_normed_field ereal -> char)) : set.separates_points h2 := sorry --non-trivial
lemma new_lemma_165983 (h0 : topological_space (has_neg_part (comm_group Type))) : regular_space (has_neg_part (comm_group Type)) := sorry --non-trivial
lemma new_lemma_165984 (h1 : set (has_lt std_gen)) : set.subsingleton h1 := sorry --non-trivial
lemma new_lemma_165985 (h0 : has_mem.mem uniform_space has_emptyc.emptyc) : @separated_space.{0} (with_one.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type uniform_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) uniform_space.{0} h0) (with_one.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_165986 (h0 : functor.add_const (topological_space (comm_group linarith.comp)) name) : @sequential_space.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_165987 (h1 : add_monoid (measurable_space linarith.comp)) : add_monoid.fg (measurable_space linarith.comp) := sorry --non-trivial
lemma new_lemma_165988 (h0 : topological_space (ring (has_add pos))) : discrete_topology (ring (has_add pos)) := sorry --non-trivial
lemma new_lemma_165989 (h1 : filter (has_compl (has_nnnorm linarith.comp_source))) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_165990 (h0 : ring (has_append (has_ssubset (random_gen (random_gen to_additive.value_type))))) : rank_condition (has_append (has_ssubset (random_gen (random_gen to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_165991 (h0 : add_group (has_compl (random_gen (has_ssubset (has_inv (comm_ring (random_gen string_imp))))))) : is_add_cyclic (has_compl (random_gen (has_ssubset (has_inv (comm_ring (random_gen string_imp)))))) := sorry --non-trivial
lemma new_lemma_165992 (h0 : filter Prop) : @Lim.{0} Prop sierpinski_space (@nonempty_of_inhabited.{1} Prop sort.inhabited.{0}) (@id.{1} (filter.{0} Prop) (@id.{1} (filter.{0} Prop) (@id.{1} (filter.{0} Prop) (@id.{1} (filter.{0} Prop) (@id.{1} (filter.{0} Prop) (@id.{1} (filter.{0} Prop) h0))))))  := sorry --non-trivial
lemma new_lemma_165993 (h0 : functor.add_const (function.extfun Type ordered_comm_monoid) name) : @has_exists_mul_of_le.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) name h0) (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_165994 (h0 : ring (canonically_linear_ordered_monoid num)) : is_principal_ideal_ring (canonically_linear_ordered_monoid num) := sorry --non-trivial
lemma new_lemma_165995 (h0 : function.extfun Type (prod (complete_linear_order empty))) : id_rel (function.extfun_app h0 (complete_linear_order empty)) := sorry --non-trivial
lemma new_lemma_165996 (h0 : function.extfun nat fin) : @monoid.fg.{1} (canonically_ordered_comm_semiring.{1} Type) (@matrix.vec_empty.{1} (monoid.{1} (canonically_ordered_comm_semiring.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_165997 (h0 : not (has_mem.mem (has_norm linarith.comp_source) has_emptyc.emptyc -> false)) : @strong_rank_condition.{0} (has_norm.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type ring.{0} (has_norm.{0} linarith.comp_source) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_norm.{0} linarith.comp_source) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_165998 (h0 : finset (linear_ordered_comm_group (option ennreal))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_165999 (h0 : not (complete_lattice (has_lt (mul_one_class reducibility_hints)) -> false)) : @is_compactly_generated.{0} (has_lt.{0} (mul_one_class.{0} reducibility_hints)) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_lt.{0} (mul_one_class.{0} reducibility_hints))) h0)  := sorry --non-trivial
lemma new_lemma_166000 (h0 : topological_space (linear_ordered_add_comm_group (has_top linarith.ineq))) : irreducible_space (linear_ordered_add_comm_group (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_166001 (h0 : functor.add_const (topological_space (has_zero Type)) Type) : @regular_space.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_zero.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_166002 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (has_neg_part.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_neg_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_166003 (h0 : topological_space (finset (has_nndist environment.implicit_infer_kind))) : sequential_space (finset (has_nndist environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_166004 (h0 : complete_lattice (comm_group (has_neg (finset environment.implicit_infer_kind)))) : is_compactly_generated (comm_group (has_neg (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_166005 (h0 : functor.add_const (topological_space pos) (option pos)) : @preirreducible_space.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) (option.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_166006 (h0 : function.extfun Type (functor.add_const (function.extfun Type topological_space))) : @topological_space.separable_space.{0} (mul_zero_class.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos (@function.extfun_app.{2 2} Type (functor.add_const.{1 0} (function.extfun.{2 1} Type topological_space.{0})) h0 pos)) (mul_zero_class.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_166007 (h0 : uniform_space (ordered_comm_ring (has_add linarith.comp))) : separated_space (ordered_comm_ring (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_166008 (h0 : ring (measurable_space (semiring (metric_space num)))) : strong_rank_condition (measurable_space (semiring (metric_space num))) := sorry --non-trivial
lemma new_lemma_166009 (h0 : add_monoid (comm_group (has_to_string (has_to_string (has_to_string (comm_group Type)))))) : add_monoid.fg (comm_group (has_to_string (has_to_string (has_to_string (comm_group Type))))) := sorry --non-trivial
lemma new_lemma_166010 (h0 : topological_space (add_cancel_monoid (cancel_monoid (has_neg_part pos)))) : path_connected_space (add_cancel_monoid (cancel_monoid (has_neg_part pos))) := sorry --non-trivial
lemma new_lemma_166011 (h0 : functor.add_const (filter (semigroup Type)) (has_neg (has_neg linarith.comp))) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_166012 (h0 : functor.add_const (topological_space (ordered_ring empty)) empty) : @locally_compact_space.{0} (ordered_ring.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_166013 (h0 : fin has_zero.zero) : @regular_space.{1} Type (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@matrix.vec_empty.{2} (function.extfun.{3 2} (Type 1) topological_space.{1}) h0) Type)  := sorry --non-trivial
lemma new_lemma_166014 (h0 : function.extfun Type (functor.add_const (topological_space (ring Type)))) : @path_connected_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ring.{1} Type)) pos (@function.extfun_app.{2 2} Type (functor.add_const.{1 0} (topological_space.{1} (ring.{1} Type))) h0 pos))  := sorry --non-trivial
lemma new_lemma_166015 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (option pos)) := sorry --non-trivial
lemma new_lemma_166016 (h0 : functor.add_const (add_monoid (cancel_monoid real)) Type) : @add_monoid.fg.{0} (cancel_monoid.{0} real) (@functor.add_const.run.{0 1} (add_monoid.{0} (cancel_monoid.{0} real)) Type h0)  := sorry --non-trivial
lemma new_lemma_166017 (h0 : group (normed_group (dlist (has_top (has_top (has_top to_additive.value_type)))))) : normalizer_condition (normed_group (dlist (has_top (has_top (has_top to_additive.value_type))))) := sorry --non-trivial
lemma new_lemma_166018 (h0 : add_comm_semigroup std_gen -> add_comm_semigroup std_gen -> add_comm_semigroup std_gen) (h1 : add_comm_semigroup std_gen) : right_identity h0 h1 := sorry --non-trivial
lemma new_lemma_166019 (h0 : complete_lattice (cancel_monoid (normed_field string.iterator_imp))) : complete_lattice.is_Sup_finite_compact (cancel_monoid (normed_field string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_166020 (h0 : ring (cancel_monoid (comm_group name))) : strong_rank_condition (cancel_monoid (comm_group name)) := sorry --non-trivial
lemma new_lemma_166021 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (generalized_boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (generalized_boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_166022 (h0 : topological_space (random_gen num)) : t0_space (random_gen num) := sorry --non-trivial
lemma new_lemma_166023 (h0 : ring (semigroup (comm_group (normed_comm_ring name)))) : is_domain (semigroup (comm_group (normed_comm_ring name))) := sorry --non-trivial
lemma new_lemma_166024 (h0 : ring (comm_ring (has_append reducibility_hints))) : is_domain (comm_ring (has_append reducibility_hints)) := sorry --non-trivial
lemma new_lemma_166025 (h0 : functor.add_const (list (has_Inf linarith.comp)) linarith.comp) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_166026 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (ordered_cancel_add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_cancel_add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_166027 (h3 : char -> char) (h4 : char) : function.is_fixed_pt h3 h4 := sorry --non-trivial
lemma new_lemma_166028 (h0 : uniform_space (has_norm num)) : separated_space (has_norm num) := sorry --non-trivial
lemma new_lemma_166029 (h0 : has_le (nondiscrete_normed_field linarith.ineq)) (h1 : nondiscrete_normed_field linarith.ineq) : is_max h1 := sorry --non-trivial
lemma new_lemma_166030 (h0 : functor.add_const (group (has_neg pos)) (ring pos)) : @group.fg.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_neg.{0} pos)) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_166031 (h0 : add_monoid (has_neg (has_neg linarith.comp))) : add_monoid.fg (has_neg (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_166032 (h1 : group (has_add (has_nnnorm linarith.ineq))) : is_cyclic (has_add (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_166033 (h0 : not (topological_space (has_star num) -> false)) : @topological_space.separable_space.{0} (has_star.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (has_star.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_166034 (h0 : functor.add_const (finset (normed_linear_ordered_group empty)) empty) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_166035 (h0 : complete_lattice (has_star congr_arg_kind)) : is_atomistic (has_star congr_arg_kind) := sorry --non-trivial
lemma new_lemma_166036 (h0 : topological_space (has_neg (has_add Type))) : preirreducible_space (has_neg (has_add Type)) := sorry --non-trivial
lemma new_lemma_166037 (h0 : not (function.extfun Type ring -> false)) : @rank_condition.{0} (measurable_space.dynkin_system.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (measurable_space.dynkin_system.{0} num))  := sorry --non-trivial
lemma new_lemma_166038 (h0 : functor.add_const (ring (has_neg environment.implicit_infer_kind)) Type) : @strong_rank_condition.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (ring.{0} (has_neg.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_166039 (h0 : functor.add_const (uniform_space (ordered_comm_ring linarith.comp)) linarith.comp) : @complete_space.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (ordered_comm_ring.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_166040 (h0 : not (topological_space (semiring empty) -> false)) : @totally_separated_space.{0} (semiring.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_166041 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @t0_space.{0} (has_norm.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) topological_space.{0}) (has_norm.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_166042 (h0 : monoid_with_zero (distrib (mul_one_class linarith.ineq))) (h1 : nat.arithmetic_function (distrib (mul_one_class linarith.ineq))) : nat.arithmetic_function.is_multiplicative h1 := sorry --non-trivial
lemma new_lemma_166043 (h0 : ring (as_linear_order unsigned)) : rank_condition (as_linear_order unsigned) := sorry --non-trivial
lemma new_lemma_166044 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_166045 (h0 : topological_space (ring (has_add name))) : totally_separated_space (ring (has_add name)) := sorry --non-trivial
lemma new_lemma_166046 (h0 : ring (linear_ordered_field empty)) : rank_condition (linear_ordered_field empty) := sorry --non-trivial
lemma new_lemma_166047 (h0 : monoid (measurable_space num)) : monoid.fg (measurable_space num) := sorry --non-trivial
lemma new_lemma_166048 (h0 : has_mem.mem (linear_ordered_semiring unsigned) has_zero.zero) : @complete_lattice.is_Sup_finite_compact.{0} (linear_ordered_semiring.{0} unsigned) (@multiset.pi.empty.{1 0} Type complete_lattice.{0} (linear_ordered_semiring.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_166049 (h0 : pnat) (h1 : with_bot (fin has_zero.zero)) (h2 : ne h1 has_bot.bot) : pnat.coprime h0 (matrix.vec_empty (with_bot.unbot h1 h2)) := sorry --non-trivial
lemma new_lemma_166050 (h0 : uniform_space (has_Inf (has_Inf (has_neg Type)))) : separated_space (has_Inf (has_Inf (has_neg Type))) := sorry --non-trivial
lemma new_lemma_166051 (h0 : topological_space (semigroup (has_pos_part linarith.comp))) : discrete_topology (semigroup (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_166052 (h0 : complete_lattice (has_nndist (option pos))) : is_atomistic (has_nndist (option pos)) := sorry --non-trivial
lemma new_lemma_166053 (h0 : functor.add_const (topological_space (has_neg_part name)) environment.implicit_infer_kind) : @normal_space.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_166054 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (ordered_cancel_add_comm_monoid empty)) := sorry --non-trivial
lemma new_lemma_166055 (h0 : ordered_add_comm_monoid (ring pos)) : archimedean (ring pos) := sorry --non-trivial
lemma new_lemma_166056 (h0 : has_mem.mem (random_gen fun_info) has_emptyc.emptyc) : @path_connected_space.{0} (random_gen.{0} fun_info) (@finset.pi.empty.{1 0} Type topological_space.{0} (random_gen.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_166057 (h0 : finset (canonically_linear_ordered_monoid (has_Inf (has_Inf real)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_166058 (h0 : topological_space (random_gen (has_top unsigned))) : discrete_topology (random_gen (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_166059 (h0 : uniform_space (linear_ordered_semiring (normed_group unsigned))) : separated_space (linear_ordered_semiring (normed_group unsigned)) := sorry --non-trivial
lemma new_lemma_166060 (h0 : topological_space (distrib_lattice fun_info)) : locally_compact_space (distrib_lattice fun_info) := sorry --non-trivial
lemma new_lemma_166061 (h1 : complete_lattice (with_bot (with_bot string_imp))) : is_compactly_generated (with_bot (with_bot string_imp)) := sorry --non-trivial
lemma new_lemma_166062 (h5 : not (topological_space (distrib linarith.comp_source) -> false)) : @path_connected_space.{0} (distrib.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (distrib.{0} linarith.comp_source)) h5)  := sorry --non-trivial
lemma new_lemma_166063 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} linarith.comp (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) linarith.comp)  := sorry --non-trivial
lemma new_lemma_166064 (h0 : functor.add_const (ordered_add_comm_monoid (has_bot pos)) (has_bot real)) : @archimedean.{0} (has_bot.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_bot.{0} pos)) (has_bot.{0} real) h0)  := sorry --non-trivial
lemma new_lemma_166065 (h0 : functor.add_const (add_monoid (comm_group name)) linarith.comp) : @add_monoid.fg.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (add_monoid.{0} (comm_group.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_166066 (h0 : topological_space (has_zero num)) : preirreducible_space (has_zero num) := sorry --non-trivial
lemma new_lemma_166067 (h1 : complete_lattice (denumerable (random_gen (random_gen (random_gen linarith.comp_source))))) : is_compactly_generated (denumerable (random_gen (random_gen (random_gen linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_166068 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (generalized_boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (generalized_boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_166069 (h1 : topological_space (semi_normed_comm_ring (has_nnnorm linarith.comp_source))) : t0_space (semi_normed_comm_ring (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_166070 (h0 h1 : multiset (has_compl (mul_one_class linarith.ineq))) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_166071 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (has_edist congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_166072 (h4 : set (string.iterator_imp -> char)) : set.separates_points h4 := sorry --non-trivial
lemma new_lemma_166073 (h1 : ring (uniform_space reducibility_hints)) : strong_rank_condition (uniform_space reducibility_hints) := sorry --non-trivial
lemma new_lemma_166074 (h0 : complete_lattice (has_emptyc (has_top to_additive.value_type))) : is_atomistic (has_emptyc (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_166075 (h0 : semiring (canonically_ordered_comm_semiring (finset pos))) : is_noetherian_ring (canonically_ordered_comm_semiring (finset pos)) := sorry --non-trivial
lemma new_lemma_166076 (h0 : add_group (non_assoc_semiring (semiring num))) : is_add_cyclic (non_assoc_semiring (semiring num)) := sorry --non-trivial
lemma new_lemma_166077 (h0 : functor.comp ring normed_comm_ring environment.implicit_infer_kind) : @strong_rank_condition.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} ring.{0} normed_comm_ring.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_166078 (h0 : function.extfun nat fin) : @totally_disconnected_space.{0} (canonically_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (canonically_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_166079 (h0 : functor.add_const (function.extfun Type finset) Type) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_166080 (h0 : with_bot Prop) (h1 : ne h0 has_bot.bot) (h2 : list Prop) : list.ilast' (with_bot.unbot h0 h1) h2 := sorry --non-trivial
lemma new_lemma_166081 (h0 : list (linear_ordered_add_comm_group (has_norm fun_info))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_166082 (h0 : complete_lattice (partial_order (option congr_arg_kind))) : is_compactly_generated (partial_order (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_166083 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (ordered_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (ordered_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_166084 (h0 : not (complete_lattice (distrib reducibility_hints) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (distrib.{0} reducibility_hints) (@classical.by_contradiction'.{1} (complete_lattice.{0} (distrib.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_166085 (h0 : ring (non_unital_non_assoc_semiring char)) : is_domain (non_unital_non_assoc_semiring char) := sorry --non-trivial
lemma new_lemma_166086 (h1 : ring (with_zero (random_gen (random_gen char)))) : is_domain (with_zero (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_166087 (h0 : topological_space (has_to_string (finset unsigned))) : locally_compact_space (has_to_string (finset unsigned)) := sorry --non-trivial
lemma new_lemma_166088 (h0 : group (with_one (random_gen (random_gen string_imp)))) : normalizer_condition (with_one (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_166089 (h0 : not (function.extfun Type topological_space -> false)) : @discrete_topology.{0} (has_top.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_top.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_166090 (h0 : group (normed_comm_ring ennreal)) : is_simple_group (normed_comm_ring ennreal) := sorry --non-trivial
lemma new_lemma_166091 (h0 : complete_lattice (has_dist (option empty))) : is_compactly_generated (has_dist (option empty)) := sorry --non-trivial
lemma new_lemma_166092 (h0 : group (semigroup (ring (add_comm_monoid ennreal)))) : is_simple_group (semigroup (ring (add_comm_monoid ennreal))) := sorry --non-trivial
lemma new_lemma_166093 (h0 : functor.add_const (topological_space (linear_ordered_cancel_comm_monoid empty)) empty) : @irreducible_space.{0} (linear_ordered_cancel_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_cancel_comm_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_166094 (h0 : topological_space (with_bot (has_norm empty))) : irreducible_space (with_bot (has_norm empty)) := sorry --non-trivial
lemma new_lemma_166095 (h0 : functor.add_const (topological_space (mul_zero_class name)) name) : @discrete_topology.{0} (mul_zero_class.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_166096 (h0 : topological_space (has_nndist (has_to_string environment.implicit_infer_kind))) : totally_disconnected_space (has_nndist (has_to_string environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_166097 (h0 : functor.add_const (topological_space (ring name)) Type) : @regular_space.{0} (ring.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (ring.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_166098 (h0 : topological_space (finset (normed_comm_ring Type))) : sequential_space (finset (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_166099 (h0 : topological_space (comm_group (has_neg_part ennreal))) : preconnected_space (comm_group (has_neg_part ennreal)) := sorry --non-trivial
lemma new_lemma_166100 (h0 : topological_space (ordered_comm_monoid (finset (finset (has_Inf (has_Inf pos)))))) : totally_disconnected_space (ordered_comm_monoid (finset (finset (has_Inf (has_Inf pos))))) := sorry --non-trivial
lemma new_lemma_166101 (h0 : group (topological_space (comm_ring (has_nnnorm reducibility_hints)))) : is_cyclic (topological_space (comm_ring (has_nnnorm reducibility_hints))) := sorry --non-trivial
lemma new_lemma_166102 (h1 : ring (topological_space char)) : strong_rank_condition (topological_space char) := sorry --non-trivial
lemma new_lemma_166103 (h0 : uniform_space (semigroup (finset (mul_one_class linarith.comp)))) : separated_space (semigroup (finset (mul_one_class linarith.comp))) := sorry --non-trivial
lemma new_lemma_166104 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_ordered_comm_semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_166105 (h3 : topological_space (distrib char)) : totally_disconnected_space (distrib char) := sorry --non-trivial
lemma new_lemma_166106 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (has_norm.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_norm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_166107 (h0 : functor.add_const (functor.add_const (list environment.implicit_infer_kind) linarith.comp) pos) : list.nodup (functor.add_const.run (functor.add_const.run h0)) := sorry --non-trivial
lemma new_lemma_166108 (h0 : cancel_comm_monoid_with_zero (add_cancel_comm_monoid (semiring empty))) : unique_factorization_monoid (add_cancel_comm_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_166109 (h0 : not (topological_space (normed_field (random_gen reducibility_hints)) -> false)) : @t0_space.{0} (normed_field.{0} (random_gen.{0} reducibility_hints)) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_field.{0} (random_gen.{0} reducibility_hints))) h0)  := sorry --non-trivial
lemma new_lemma_166110 (h0 : group (finset (has_add pos))) : is_cyclic (finset (has_add pos)) := sorry --non-trivial
lemma new_lemma_166111 (h1 : group (denumerable to_additive.value_type)) : normalizer_condition (denumerable to_additive.value_type) := sorry --non-trivial
lemma new_lemma_166112 (h0 : group (has_star empty)) : normalizer_condition (has_star empty) := sorry --non-trivial
lemma new_lemma_166113 (h1 : group (distrib fun_info)) : is_cyclic (distrib fun_info) := sorry --non-trivial
lemma new_lemma_166114 (h0 : complete_lattice (with_bot (has_top (with_bot fun_info)))) : is_atomistic (with_bot (has_top (with_bot fun_info))) := sorry --non-trivial
lemma new_lemma_166115 (h0 : topological_space (mul_zero_class environment.implicit_infer_kind)) : topological_space.separable_space (mul_zero_class environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_166116 (h0 : group (generalized_boolean_algebra (has_add name))) : group.fg (generalized_boolean_algebra (has_add name)) := sorry --non-trivial
lemma new_lemma_166117 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (canonically_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_166118 (h0 : topological_space (has_sub congr_arg_kind)) : preirreducible_space (has_sub congr_arg_kind) := sorry --non-trivial
lemma new_lemma_166119 (h0 : cancel_comm_monoid_with_zero (semigroup (has_Inf (has_Inf (has_add (has_Inf Type)))))) : unique_factorization_monoid (semigroup (has_Inf (has_Inf (has_add (has_Inf Type))))) := sorry --non-trivial
lemma new_lemma_166120 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (with_bot.{0} string_imp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (with_bot.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_166121 (h0 : functor.add_const (topological_space (left_cancel_semigroup num)) empty) : @discrete_topology.{0} (left_cancel_semigroup.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_semigroup.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_166122 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @archimedean.{1} (has_add.{1} Type) (@matrix.vec_empty.{1} (ordered_add_comm_monoid.{1} (has_add.{1} Type)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_166123 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} (has_add.{0} name) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) (has_add.{0} name))  := sorry --non-trivial
lemma new_lemma_166124 (h1 : complete_lattice (encodable linarith.ineq)) : is_compactly_generated (encodable linarith.ineq) := sorry --non-trivial
lemma new_lemma_166125 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (complete_semilattice_Sup.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (complete_semilattice_Sup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_166126 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (has_Sup.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} h0 (has_Sup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_166127 (h0 : functor.add_const (topological_space Type) pos) : @loc_path_connected_space.{1} Type (@functor.add_const.run.{1 0} (topological_space.{1} Type) pos h0)  := sorry --non-trivial
lemma new_lemma_166128 (h0 : functor.add_const (topological_space (add_cancel_monoid linarith.comp)) linarith.comp) : @t1_space.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_166129 (h0 : topological_space (has_add (has_Inf linarith.comp))) : regular_space (has_add (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_166130 (h0 : cancel_comm_monoid_with_zero (has_add (normed_comm_ring pos))) : unique_factorization_monoid (has_add (normed_comm_ring pos)) := sorry --non-trivial
lemma new_lemma_166131 (h0 : complete_lattice (semiring (has_top (has_top fun_info)))) : complete_lattice.is_Sup_finite_compact (semiring (has_top (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_166132 (h0 : ordered_add_comm_monoid (has_to_string (finset (finset environment.implicit_infer_kind)))) : archimedean (has_to_string (finset (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_166133 (h0 : not (add_group (comm_ring string.iterator_imp) -> false)) : @is_add_cyclic.{0} (comm_ring.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (add_group.{0} (comm_ring.{0} string.iterator_imp)) h0)  := sorry --non-trivial
lemma new_lemma_166134 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (pseudo_metric_space num)) := sorry --non-trivial
lemma new_lemma_166135 (h0 : function.extfun Type topological_space) : @t0_space.{0} (finset.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} name))  := sorry --non-trivial
lemma new_lemma_166136 (h0 : complete_lattice (has_nndist (has_neg_part (has_add pos)))) : complete_lattice.is_Sup_finite_compact (has_nndist (has_neg_part (has_add pos))) := sorry --non-trivial
lemma new_lemma_166137 (h0 : functor.add_const Prop (has_pos_part (finset linarith.comp))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_166138 (h0 : cancel_monoid (option ennreal) -> cancel_monoid (option ennreal) -> Prop) : is_symm (cancel_monoid (option ennreal)) h0 := sorry --non-trivial
lemma new_lemma_166139 (h0 : topological_space (option (option (has_to_string (has_to_string pos))))) : path_connected_space (option (option (has_to_string (has_to_string pos)))) := sorry --non-trivial
lemma new_lemma_166140 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_166141 (h0 : not (ring (uniform_space linarith.comp_source) -> false)) : @is_domain.{0} (uniform_space.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (uniform_space.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_166142 (h0 : functor.add_const (ordered_comm_monoid (add_cancel_monoid linarith.comp)) name) : @has_exists_mul_of_le.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (add_cancel_monoid.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_166143 (h0 : complete_lattice (semiring empty)) : is_compactly_generated (semiring empty) := sorry --non-trivial
lemma new_lemma_166144 (h0 : ring (simple_graph (option (option unsigned)))) : strong_rank_condition (simple_graph (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_166145 (h0 : topological_space (has_nndist (semigroup pos))) : t1_space (has_nndist (semigroup pos)) := sorry --non-trivial
lemma new_lemma_166146 (h0 : topological_space (measurable_space.dynkin_system (semiring (semiring (semiring unsigned))))) : preirreducible_space (measurable_space.dynkin_system (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_166147 (h0 : functor.add_const (ring (comm_group Type)) (ring Type)) : @is_domain.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 1} (ring.{1} (comm_group.{1} Type)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_166148 (h0 : ring (normed_field (has_nnnorm (has_nnnorm reducibility_hints)))) : is_domain (normed_field (has_nnnorm (has_nnnorm reducibility_hints))) := sorry --non-trivial
lemma new_lemma_166149 (h0 : ring (has_neg (option (option unsigned)))) : is_principal_ideal_ring (has_neg (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_166150 (h0 : fin has_zero.zero) : @separated_space.{0} (boolean_algebra.{0} real) (@matrix.vec_empty.{0} (uniform_space.{0} (boolean_algebra.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_166151 (h0 : functor.add_const (finset (has_add Type)) linarith.comp) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_166152 (h0 : not (function.extfun Type add_monoid -> false)) : @add_monoid.fg.{0} (has_union.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_monoid.{0}) h0) (has_union.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_166153 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_zero.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_166154 (h0 : functor.add_const (topological_space (complete_distrib_lattice ennreal)) (option (option (option pos)))) : @totally_disconnected_space.{0} (complete_distrib_lattice.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} ennreal)) (option.{0} (option.{0} (option.{0} pos))) h0)  := sorry --non-trivial
lemma new_lemma_166155 (h0 : functor.add_const (group (semigroup (ring linarith.comp))) linarith.comp) : @normalizer_condition.{0} (semigroup.{0} (ring.{0} linarith.comp)) (@functor.add_const.run.{0 0} (group.{0} (semigroup.{0} (ring.{0} linarith.comp))) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_166156 (h0 : not (complete_lattice (mul_one_class string_imp) -> false)) : @is_compactly_generated.{0} (mul_one_class.{0} string_imp) (@classical.by_contradiction'.{1} (complete_lattice.{0} (mul_one_class.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_166157 (h0 : ring (linear_ordered_comm_group_with_zero (has_ssubset reducibility_hints))) : rank_condition (linear_ordered_comm_group_with_zero (has_ssubset reducibility_hints)) := sorry --non-trivial
lemma new_lemma_166158 (h0 : function.extfun nat fin) : @topological_space.separable_space.{1} (ordered_comm_ring.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (ordered_comm_ring.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_166159 (h0 : function.extfun Type topological_space) : @t1_space.{0} (linear_ordered_field.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_field.{0} empty))  := sorry --non-trivial
lemma new_lemma_166160 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (canonically_linear_ordered_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_linear_ordered_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_166161 (h0 : ring (ordered_comm_monoid (has_Inf (has_pos_part pos)))) : is_domain (ordered_comm_monoid (has_Inf (has_pos_part pos))) := sorry --non-trivial
lemma new_lemma_166162 (h0 : monoid (with_one (random_gen string_imp))) : monoid.fg (with_one (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_166163 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (has_edist.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_edist.{0} empty))  := sorry --non-trivial
lemma new_lemma_166164 (h0 : functor.add_const (ring (has_to_string unsigned)) linarith.comp) : @is_domain.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (has_to_string.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_166165 (h0 : topological_space (add_group (semiring num))) : preirreducible_space (add_group (semiring num)) := sorry --non-trivial
lemma new_lemma_166166 (h1 : topological_space (with_zero linarith.comp_source)) : t0_space (with_zero linarith.comp_source) := sorry --non-trivial
lemma new_lemma_166167 (h0 : functor.add_const (list (has_Inf pos)) (ring linarith.comp)) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_166168 (h0 : topological_space (mul_one_class (add_comm_semigroup (add_comm_semigroup std_gen)))) : t0_space (mul_one_class (add_comm_semigroup (add_comm_semigroup std_gen))) := sorry --non-trivial
lemma new_lemma_166169 (h0 : topological_space (ordered_comm_monoid (has_Inf Type))) : discrete_topology (ordered_comm_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_166170 (h0 : finset (canonically_linear_ordered_monoid name)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_166171 (h0 : semiring (metric_space empty)) : is_noetherian_ring (metric_space empty) := sorry --non-trivial
lemma new_lemma_166172 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_simple_group.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_166173 (h0 : add_group (non_unital_non_assoc_semiring (mul_one_class linarith.comp_source))) : is_add_cyclic (non_unital_non_assoc_semiring (mul_one_class linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_166174 (h0 : topological_space (ordered_comm_ring (has_Inf Type))) : locally_compact_space (ordered_comm_ring (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_166175 (h0 : group (normed_field (has_nnnorm string.iterator_imp))) : is_cyclic (normed_field (has_nnnorm string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_166176 (h0 : add_monoid (has_neg_part unsigned)) : add_monoid.fg (has_neg_part unsigned) := sorry --non-trivial
lemma new_lemma_166177 (h0 : functor.add_const (ring (semigroup num)) congr_arg_kind) : @is_principal_ideal_ring.{0} (semigroup.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (semigroup.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_166178 (h0 : complete_lattice (linear_ordered_add_comm_group string_imp)) : complete_lattice.is_Sup_finite_compact (linear_ordered_add_comm_group string_imp) := sorry --non-trivial
lemma new_lemma_166179 (h0 : add_group (finset (has_Inf pos))) : is_add_cyclic (finset (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_166180 (h0 h1 : multiset (has_div string.iterator_imp)) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_166181 (h0 : group (has_norm (semiring empty))) : is_cyclic (has_norm (semiring empty)) := sorry --non-trivial
lemma new_lemma_166182 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @totally_disconnected_space.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_166183 (h0 : topological_space (bin_tree (semiring (semiring num)))) : discrete_topology (bin_tree (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_166184 (h0 : topological_space (option (option (option ennreal)))) : normal_space (option (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_166185 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (monoid_with_zero.{0} pos) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (monoid_with_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_166186 (h1 : complete_lattice (ordered_cancel_comm_monoid (has_nnnorm (has_nnnorm fun_info)))) : is_compactly_generated (ordered_cancel_comm_monoid (has_nnnorm (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_166187 (h0 : functor.add_const (complete_lattice (boolean_algebra linarith.comp)) Type) : @complete_lattice.is_Sup_finite_compact.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 1} (complete_lattice.{0} (boolean_algebra.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_166188 (h0 : list (ordered_comm_group (option (option (option (option unsigned)))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_166189 (h0 : topological_space (complete_distrib_lattice unsigned)) : preconnected_space (complete_distrib_lattice unsigned) := sorry --non-trivial
lemma new_lemma_166190 (h0 : monoid (semigroup unsigned)) : monoid.fg (semigroup unsigned) := sorry --non-trivial
lemma new_lemma_166191 (h0 : ordered_add_comm_monoid (monoid empty)) : archimedean (monoid empty) := sorry --non-trivial
lemma new_lemma_166192 (h1 : add_group (simple_graph std_gen)) : is_add_cyclic (simple_graph std_gen) := sorry --non-trivial
lemma new_lemma_166193 (h1 : ring (has_ssubset (mul_one_class reducibility_hints))) : rank_condition (has_ssubset (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_166194 (h0 : not (topological_space (with_bot linarith.comp) -> false)) : @normal_space.{0} (with_bot.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (with_bot.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_166195 (h0 : uniform_space (semigroup (finset (has_add (has_add pos))))) : separated_space (semigroup (finset (has_add (has_add pos)))) := sorry --non-trivial
lemma new_lemma_166196 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_Inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_Inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_166197 (h0 : topological_space (has_add (has_nnnorm string_imp))) : totally_disconnected_space (has_add (has_nnnorm string_imp)) := sorry --non-trivial
lemma new_lemma_166198 (h0 : set (add_comm_semigroup (mul_one_class fun_info))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_166199 (h0 : add_monoid (has_norm (random_gen empty))) : add_monoid.fg (has_norm (random_gen empty)) := sorry --non-trivial
lemma new_lemma_166200 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_166201 (h0 : functor.add_const (group (add_comm_monoid empty)) num) : @normalizer_condition.{0} (add_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (add_comm_monoid.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_166202 (h0 : topological_space (has_top (has_norm (has_top fun_info)))) : totally_disconnected_space (has_top (has_norm (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_166203 (h0 : functor.add_const (filter (add_cancel_monoid ennreal)) num) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_166204 (h0 : topological_space (normed_lattice_add_comm_group pos)) : totally_separated_space (normed_lattice_add_comm_group pos) := sorry --non-trivial
lemma new_lemma_166205 (h0 : prod (canonically_ordered_comm_semiring num) (canonically_ordered_comm_semiring num)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_166206 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_nnnorm.{0} char) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_nnnorm.{0} char))  := sorry --non-trivial
lemma new_lemma_166207 (h0 : topological_space (ordered_comm_ring (has_add (has_Inf linarith.comp)))) : discrete_topology (ordered_comm_ring (has_add (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_166208 (h0 : not (group (has_sub empty) -> false)) : @normalizer_condition.{0} (has_sub.{0} empty) (@classical.by_contradiction'.{1} (group.{0} (has_sub.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_166209 (h0 : topological_space (has_to_string (ring linarith.comp))) : preconnected_space (has_to_string (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_166210 (h0 : topological_space (has_add (has_Inf (has_neg linarith.comp)))) : regular_space (has_add (has_Inf (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_166211 (h0 : uniform_space (has_ssubset linarith.comp_source)) : complete_space (has_ssubset linarith.comp_source) := sorry --non-trivial
lemma new_lemma_166212 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @discrete_topology.{0} (has_Inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (has_Inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_166213 (h0 : group (generalized_boolean_algebra (has_bot (has_bot name)))) : is_simple_group (generalized_boolean_algebra (has_bot (has_bot name))) := sorry --non-trivial
lemma new_lemma_166214 (h0 : topological_space (ordered_comm_ring (has_neg Type))) : regular_space (ordered_comm_ring (has_neg Type)) := sorry --non-trivial
lemma new_lemma_166215 (h0 : ring (has_emptyc (has_norm fun_info))) : is_domain (has_emptyc (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_166216 (h0 : functor.add_const (list (semigroup unsigned)) congr_arg_kind) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_166217 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (add_comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_166218 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (has_emptyc.{0} fun_info) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (has_emptyc.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_166219 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (with_bot.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (with_bot.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_166220 (h0 : cancel_comm_monoid_with_zero (normed_linear_ordered_group (option (option (option (option empty)))))) : unique_factorization_monoid (normed_linear_ordered_group (option (option (option (option empty))))) := sorry --non-trivial
lemma new_lemma_166221 (h0 : function.extfun Type ring) : @is_domain.{0} (add_cancel_monoid.{0} (option.{0} pos)) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_cancel_monoid.{0} (option.{0} pos)))  := sorry --non-trivial
lemma new_lemma_166222 (h0 : topological_space (has_bot (has_Inf name))) : totally_separated_space (has_bot (has_Inf name)) := sorry --non-trivial
lemma new_lemma_166223 (h0 : complete_lattice nnreal) : is_atomistic nnreal := sorry --non-trivial
lemma new_lemma_166224 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (measurable_space.dynkin_system.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (measurable_space.dynkin_system.{0} num))  := sorry --non-trivial
lemma new_lemma_166225 (h0 : functor.add_const (finset (ring linarith.comp)) (finset (finset environment.implicit_infer_kind))) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_166226 (h0 : function.extfun Type (functor.comp group comm_group)) : @group.fg.{0} (comm_group.{0} ennreal) (@functor.comp.run.{0 0 0} group.{0} comm_group.{0} ennreal (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} group.{0} comm_group.{0}) h0 ennreal))  := sorry --non-trivial
lemma new_lemma_166227 (h0 : complete_lattice (normed_group (has_inv (has_inv (has_inv to_additive.value_type))))) : is_atomistic (normed_group (has_inv (has_inv (has_inv to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_166228 (h0 : function.extfun nat fin) : @separated_space.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type uniform_space.{0}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_166229 (h0 : functor.add_const (topological_space (complete_distrib_lattice environment.implicit_infer_kind)) Type) : @t0_space.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_166230 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (cancel_monoid.{0} (has_neg.{0} num)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} (has_neg.{0} num)))  := sorry --non-trivial
lemma new_lemma_166231 (h0 : functor.add_const (topological_space (cancel_monoid name)) name) : @regular_space.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_166232 (h0 : set (simple_graph (mul_one_class (mul_one_class enat)))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_166233 (h0 : functor.add_const (complete_lattice (canonically_ordered_monoid name)) (has_add Type)) : @complete_lattice.is_Sup_finite_compact.{0} (canonically_ordered_monoid.{0} name) (@functor.add_const.run.{0 1} (complete_lattice.{0} (canonically_ordered_monoid.{0} name)) (has_add.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_166234 (h0 : topological_space (linear_ordered_comm_group (option (option empty)))) : irreducible_space (linear_ordered_comm_group (option (option empty))) := sorry --non-trivial
lemma new_lemma_166235 (h0 : topological_space (boolean_algebra (comm_group (has_add (has_add pos))))) : t0_space (boolean_algebra (comm_group (has_add (has_add pos)))) := sorry --non-trivial
lemma new_lemma_166236 (h0 : complete_lattice (complete_linear_order (has_top (semiring congr_arg_kind)))) : complete_lattice.is_Sup_finite_compact (complete_linear_order (has_top (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_166237 (h0 : ring (has_nndist ennreal)) : strong_rank_condition (has_nndist ennreal) := sorry --non-trivial
lemma new_lemma_166238 (h0 : has_mem.mem (has_top to_additive.value_type) has_emptyc.emptyc) : @discrete_topology.{0} (has_top.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_top.{0} to_additive.value_type) h0)  := sorry --non-trivial
lemma new_lemma_166239 (h0 : topological_space (add_cancel_monoid (finset Type))) : t0_space (add_cancel_monoid (finset Type)) := sorry --non-trivial
lemma new_lemma_166240 (h0 : finset (has_edist (left_cancel_monoid (option unsigned)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_166241 (h0 : functor.add_const (complete_lattice (bin_tree empty)) empty) : @is_atomistic.{0} (bin_tree.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (bin_tree.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_166242 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (linear_ordered_field unsigned)) := sorry --non-trivial
lemma new_lemma_166243 (h1 : topological_space (comm_ring (comm_ring linarith.comp_source))) : totally_disconnected_space (comm_ring (comm_ring linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_166244 (h0 : list (mul_zero_class (has_add name))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_166245 (h0 : function.extfun Type (functor.add_const (complete_lattice (normed_linear_ordered_group num)))) : @is_atomistic.{0} (normed_linear_ordered_group.{0} num) (@functor.add_const.run.{0 0} (complete_lattice.{0} (normed_linear_ordered_group.{0} num)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (complete_lattice.{0} (normed_linear_ordered_group.{0} num))) h0 empty))  := sorry --non-trivial
lemma new_lemma_166246 (h0 : ordered_comm_monoid (has_pos_part (has_Inf (has_neg linarith.comp)))) : has_exists_mul_of_le (has_pos_part (has_Inf (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_166247 (h0 : topological_space (random_gen (has_norm linarith.comp_source))) : totally_disconnected_space (random_gen (has_norm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_166248 (h0 : topological_space (cancel_monoid num)) : loc_path_connected_space (cancel_monoid num) := sorry --non-trivial
lemma new_lemma_166249 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring name)) name) : @irreducible_space.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_166250 (h0 : functor.add_const (topological_space (has_neg pos)) (has_add Type)) : @t1_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg.{0} pos)) (has_add.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_166251 (h0 : not (function.extfun Type complete_lattice -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_emptyc.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (has_emptyc.{0} num))  := sorry --non-trivial
lemma new_lemma_166252 (h0 : functor.add_const (filter (has_add Type)) (ring (ring Type))) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_166253 (h0 : cancel_comm_monoid_with_zero (metric_space empty)) : unique_factorization_monoid (metric_space empty) := sorry --non-trivial
lemma new_lemma_166254 (h0 : topological_space (has_norm (has_norm empty))) : locally_compact_space (has_norm (has_norm empty)) := sorry --non-trivial
lemma new_lemma_166255 (h0 : group (has_add (has_neg name))) : group.fg (has_add (has_neg name)) := sorry --non-trivial
lemma new_lemma_166256 (h0 : topological_space (has_dist (option empty))) : discrete_topology (has_dist (option empty)) := sorry --non-trivial
lemma new_lemma_166257 (h0 : ring (canonically_ordered_monoid (has_neg pos))) : rank_condition (canonically_ordered_monoid (has_neg pos)) := sorry --non-trivial
lemma new_lemma_166258 (h1 : add_group (mul_one_class linarith.comp_source)) : is_add_cyclic (mul_one_class linarith.comp_source) := sorry --non-trivial
lemma new_lemma_166259 (h0 : add_group (simple_graph (has_ssubset linarith.ineq))) : is_add_cyclic (simple_graph (has_ssubset linarith.ineq)) := sorry --non-trivial
lemma new_lemma_166260 (h0 : function.extfun Type group) : @is_cyclic.{0} (with_bot.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} h0 (with_bot.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_166261 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (option.{0} (option.{0} ennreal)) (@function.extfun_app.{2 1} Type ring.{0} h0 (option.{0} (option.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_166262 (h0 : topological_space (pseudo_metric_space (finset pos))) : totally_disconnected_space (pseudo_metric_space (finset pos)) := sorry --non-trivial
lemma new_lemma_166263 (h0 : filter (ordered_comm_group num)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_166264 (h0 : not (topological_space (has_emptyc num) -> false)) : @discrete_topology.{0} (has_emptyc.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (has_emptyc.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_166265 (h0 : list (has_pos_part (has_add (has_add linarith.comp)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_166266 (h0 : functor.add_const (ring (ordered_comm_ring name)) pos) : @strong_rank_condition.{0} (ordered_comm_ring.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (ordered_comm_ring.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_166267 (h0 : topological_space (filter num)) : discrete_topology (filter num) := sorry --non-trivial
lemma new_lemma_166268 (h0 : group (has_neg_part (finset ennreal))) : group.fg (has_neg_part (finset ennreal)) := sorry --non-trivial
lemma new_lemma_166269 (h0 : ring (mul_one_class std_gen)) : is_domain (mul_one_class std_gen) := sorry --non-trivial
lemma new_lemma_166270 (h0 : ring (measurable_space.dynkin_system (mul_one_class reducibility_hints))) : is_domain (measurable_space.dynkin_system (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_166271 (h0 : function.extfun Type group) : @group.fg.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_166272 (h0 : functor.add_const (complete_lattice (has_neg unsigned)) name) : @is_compactly_generated.{0} (has_neg.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_neg.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_166273 (h0 : group (non_assoc_semiring (semiring (semiring (semiring empty))))) : normalizer_condition (non_assoc_semiring (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_166274 (h0 : has_nnnorm linarith.ineq -> has_nnnorm linarith.ineq -> Prop) (h1 : set (has_nnnorm linarith.ineq)) : set.bounded h0 h1 := sorry --non-trivial
lemma new_lemma_166275 (h1 : complete_lattice (complete_semilattice_Sup (has_emptyc string_imp))) : is_compactly_generated (complete_semilattice_Sup (has_emptyc string_imp)) := sorry --non-trivial
lemma new_lemma_166276 (h1 : group (complete_semilattice_Sup (has_top (random_gen (random_gen string_imp))))) : group.fg (complete_semilattice_Sup (has_top (random_gen (random_gen string_imp)))) := sorry --non-trivial
lemma new_lemma_166277 (h0 : functor.add_const (topological_space (ordered_comm_monoid Type)) Type) : @loc_path_connected_space.{1} (ordered_comm_monoid.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (ordered_comm_monoid.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_166278 (h0 : semiring (normed_comm_ring (has_to_string unsigned))) : is_noetherian_ring (normed_comm_ring (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_166279 (h0 : semiring (add_right_cancel_monoid linarith.comp)) : is_noetherian_ring (add_right_cancel_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_166280 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @locally_compact_space.{0} (@id.{2} Type congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (@id.{2} Type congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_166281 (h0 : group (normed_comm_ring ennreal)) : group.fg (normed_comm_ring ennreal) := sorry --non-trivial
lemma new_lemma_166282 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_union.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_union.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_166283 (h0 : monoid (has_norm (random_gen linarith.comp_source))) : monoid.fg (has_norm (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_166284 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} (measurable_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (measurable_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_166285 (h0 : ring (has_compl (random_gen char))) : is_domain (has_compl (random_gen char)) := sorry --non-trivial
lemma new_lemma_166286 (h0 : fin has_zero.zero) : @normal_space.{0} (boolean_algebra.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (boolean_algebra.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_166287 (h0 : semiring (comm_group (has_nndist pos))) : is_noetherian_ring (comm_group (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_166288 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (has_norm.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_norm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_166289 (h0 : add_group (complete_distrib_lattice (semigroup pos))) : is_add_cyclic (complete_distrib_lattice (semigroup pos)) := sorry --non-trivial
lemma new_lemma_166290 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (linear_ordered_comm_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_ordered_comm_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_166291 (h0 : topological_space (linear_ordered_semiring (random_gen (random_gen (random_gen num))))) : totally_disconnected_space (linear_ordered_semiring (random_gen (random_gen (random_gen num)))) := sorry --non-trivial
lemma new_lemma_166292 (h0 : topological_space (add_comm_monoid (sub_neg_monoid pos))) : t1_space (add_comm_monoid (sub_neg_monoid pos)) := sorry --non-trivial
lemma new_lemma_166293 (h0 : monoid (linear_ordered_comm_group (option (option num)))) : monoid.fg (linear_ordered_comm_group (option (option num))) := sorry --non-trivial
lemma new_lemma_166294 (h0 : uniform_space (option (semiring (semiring congr_arg_kind)))) : complete_space (option (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_166295 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (has_top.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 complete_lattice.{0}) (has_top.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_166296 (h0 : functor.add_const (uniform_space (comm_group name)) Type) : @complete_space.{0} (comm_group.{0} name) (@functor.add_const.run.{0 1} (uniform_space.{0} (comm_group.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_166297 (h0 : ordered_add_comm_monoid (add_comm_monoid linarith.comp)) : archimedean (add_comm_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_166298 (h0 : has_mem.mem (linear_ordered_semiring empty) has_emptyc.emptyc) : @is_domain.{0} (linear_ordered_semiring.{0} empty) (@finset.pi.empty.{1 0} Type ring.{0} (linear_ordered_semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_166299 (h0 : cancel_comm_monoid_with_zero (add_comm_monoid (has_to_string linarith.comp))) : unique_factorization_monoid (add_comm_monoid (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_166300 (h0 : ring (with_bot congr_arg_kind)) : strong_rank_condition (with_bot congr_arg_kind) := sorry --non-trivial
lemma new_lemma_166301 (h0 : has_mem.mem Type has_emptyc.emptyc) : @discrete_topology.{1} Type (@finset.pi.empty.{2 1} (Type 1) topological_space.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_166302 (h0 : topological_space (canonically_ordered_comm_semiring (ring linarith.comp))) : t1_space (canonically_ordered_comm_semiring (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_166303 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (has_Inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type semiring.{0} h0 (has_Inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_166304 (h0 : uniform_space (comm_semigroup (sub_neg_monoid (sub_neg_monoid pos)))) : complete_space (comm_semigroup (sub_neg_monoid (sub_neg_monoid pos))) := sorry --non-trivial
lemma new_lemma_166305 (h0 : functor.comp topological_space add_cancel_monoid Type) : @loc_path_connected_space.{1} (add_cancel_monoid.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} add_cancel_monoid.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_166306 (h0 : functor.add_const (topological_space (mul_zero_class ennreal)) Type) : @totally_disconnected_space.{0} (mul_zero_class.{0} ennreal) (@functor.add_const.run.{0 1} (topological_space.{0} (mul_zero_class.{0} ennreal)) Type h0)  := sorry --non-trivial
lemma new_lemma_166307 (h0 : ring (has_nnnorm ereal)) : is_domain (has_nnnorm ereal) := sorry --non-trivial
lemma new_lemma_166308 (h0 : topological_space (add_comm_monoid (comm_group name))) : path_connected_space (add_comm_monoid (comm_group name)) := sorry --non-trivial
lemma new_lemma_166309 (h2 : topological_space (normed_field ereal)) (h3 : add_group (normed_field ereal)) : topological_add_group (normed_field ereal) := sorry --non-trivial
lemma new_lemma_166310 (h0 : functor.add_const (ordered_comm_monoid (has_to_string name)) environment.implicit_infer_kind) : @has_exists_mul_of_le.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_to_string.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_166311 (h0 : topological_space (boolean_algebra.core (finset pos))) : t1_space (boolean_algebra.core (finset pos)) := sorry --non-trivial
lemma new_lemma_166312 (h2 : topological_space (uniform_space linarith.ineq)) : t0_space (uniform_space linarith.ineq) := sorry --non-trivial
lemma new_lemma_166313 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (add_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (add_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_166314 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (linear_ordered_add_comm_group.{0} (random_gen.{0} fun_info)) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (linear_ordered_add_comm_group.{0} (random_gen.{0} fun_info)))  := sorry --non-trivial
lemma new_lemma_166315 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (normed_group.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_group.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_166316 (h0 : fin has_zero.zero) (h1 : setoid (matrix.vec_empty h0)) : quotient h1 := sorry --non-trivial
lemma new_lemma_166317 (h0 : filter (has_nndist (finset (finset Type)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_166318 (h0 : semiring (option (option (option ennreal)))) : is_noetherian_ring (option (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_166319 (h0 : functor.add_const (group (finset Type)) linarith.comp) : @is_cyclic.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (finset.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_166320 (h0 : group (denumerable (semi_normed_ring char))) : is_cyclic (denumerable (semi_normed_ring char)) := sorry --non-trivial
lemma new_lemma_166321 (h0 : topological_space (simple_graph linarith.comp)) : irreducible_space (simple_graph linarith.comp) := sorry --non-trivial
lemma new_lemma_166322 (h1 : topological_space (has_dist (has_nnnorm char))) : path_connected_space (has_dist (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_166323 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (non_assoc_semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_166324 (h0 : ring (monoid_with_zero ennreal)) : strong_rank_condition (monoid_with_zero ennreal) := sorry --non-trivial
lemma new_lemma_166325 (h1 : ring (has_append (has_inv (has_ssubset (has_ssubset (random_gen (random_gen char))))))) : is_domain (has_append (has_inv (has_ssubset (has_ssubset (random_gen (random_gen char)))))) := sorry --non-trivial
lemma new_lemma_166326 (h1 : topological_space (has_nnnorm (random_gen string_imp))) : t0_space (has_nnnorm (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_166327 (h0 : topological_space (normed_comm_ring (finset (has_add linarith.comp)))) : locally_compact_space (normed_comm_ring (finset (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_166328 (h0 : add_monoid (measure_theory.measure_space (semiring (has_top unsigned)))) : add_monoid.fg (measure_theory.measure_space (semiring (has_top unsigned))) := sorry --non-trivial
lemma new_lemma_166329 (h0 : topological_space (metric_space (semiring congr_arg_kind))) : locally_compact_space (metric_space (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_166330 (h0 : functor.add_const (function.extfun Type add_group) Type) : @is_add_cyclic.{0} (has_nndist.{0} name) (@function.extfun_app.{2 1} Type add_group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type add_group.{0}) Type h0) (has_nndist.{0} name))  := sorry --non-trivial
lemma new_lemma_166331 (h0 : topological_space (has_norm num)) : locally_compact_space (has_norm num) := sorry --non-trivial
lemma new_lemma_166332 (h0 : uniform_space (denumerable (random_gen (distrib_lattice (random_gen char))))) : complete_space (denumerable (random_gen (distrib_lattice (random_gen char)))) := sorry --non-trivial
lemma new_lemma_166333 (h0 : topological_space (has_add (has_to_string Type))) : totally_separated_space (has_add (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_166334 (h0 : functor.add_const (topological_space (linear_order num)) num) : @discrete_topology.{0} (linear_order.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_order.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_166335 (h0 : functor.comp ordered_comm_monoid pseudo_metric_space name) : @has_exists_mul_of_le.{0} (pseudo_metric_space.{0} name) (@functor.comp.run.{0 0 0} ordered_comm_monoid.{0} pseudo_metric_space.{0} name h0)  := sorry --non-trivial
lemma new_lemma_166336 (h1 : topological_space (has_top congr_arg_kind)) : t0_space (has_top congr_arg_kind) := sorry --non-trivial
lemma new_lemma_166337 (h0 : functor.add_const (topological_space (complete_distrib_lattice Type)) name) : @totally_disconnected_space.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (complete_distrib_lattice.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_166338 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (measurable_space.dynkin_system.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (measurable_space.dynkin_system.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_166339 (h1 : add_group (dlist to_additive.value_type)) : is_add_cyclic (dlist to_additive.value_type) := sorry --non-trivial
lemma new_lemma_166340 (h0 : add_comm_semigroup fun_info) (h1 : sym2 (add_comm_semigroup fun_info)) : sym2.mem h0 h1 := sorry --non-trivial
lemma new_lemma_166341 (h0 : group (has_neg Type)) : is_simple_group (has_neg Type) := sorry --non-trivial
lemma new_lemma_166342 (h0 : not (topological_space (measurable_space.dynkin_system congr_arg_kind) -> false)) : @path_connected_space.{0} (measurable_space.dynkin_system.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (measurable_space.dynkin_system.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_166343 (h0 : not (topological_space (partial_order unsigned) -> false)) : @t1_space.{0} (partial_order.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (partial_order.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_166344 (h0 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} (add_group.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (add_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_166345 (h0 : complete_lattice (complete_semilattice_Sup (random_gen (has_top string_imp)))) : is_compactly_generated (complete_semilattice_Sup (random_gen (has_top string_imp))) := sorry --non-trivial
lemma new_lemma_166346 (h0 : topological_space (has_add (has_Inf real))) : totally_disconnected_space (has_add (has_Inf real)) := sorry --non-trivial
lemma new_lemma_166347 (h0 : topological_space (add_comm_monoid (has_add unsigned))) : loc_path_connected_space (add_comm_monoid (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_166348 (h0 : cancel_comm_monoid_with_zero (has_norm (semiring (semiring empty)))) : unique_factorization_monoid (has_norm (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_166349 (h0 : topological_space (has_bot (complete_distrib_lattice Type))) : preirreducible_space (has_bot (complete_distrib_lattice Type)) := sorry --non-trivial
lemma new_lemma_166350 (h0 : ring (complete_distrib_lattice (ring pos))) : rank_condition (complete_distrib_lattice (ring pos)) := sorry --non-trivial
lemma new_lemma_166351 (h0 : fin has_zero.zero) : @complete_lattice.is_Sup_finite_compact.{1} (generalized_boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (complete_lattice.{1} (generalized_boolean_algebra.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_166352 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (bin_tree.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (bin_tree.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_166353 (h0 : uniform_space (generalized_boolean_algebra (has_Inf pos))) : complete_space (generalized_boolean_algebra (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_166354 (h0 : topological_space (group_with_zero (option (option ennreal)))) : t0_space (group_with_zero (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_166355 (h0 : functor.add_const (add_monoid (has_to_string unsigned)) environment.implicit_infer_kind) : @add_monoid.fg.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_to_string.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_166356 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_166357 (h0 : group (linear_ordered_field (option (option (option ennreal))))) : group.fg (linear_ordered_field (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_166358 (h0 : list name) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_166359 (h0 : uniform_space (canonically_ordered_monoid (ordered_comm_monoid Type))) : complete_space (canonically_ordered_monoid (ordered_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_166360 (h0 : functor.add_const (complete_lattice (comm_group linarith.comp)) linarith.comp) : @complete_lattice.is_Sup_finite_compact.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (comm_group.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_166361 (h0 : topological_space (random_gen (has_top empty))) : t0_space (random_gen (has_top empty)) := sorry --non-trivial
lemma new_lemma_166362 (h0 : topological_space (linear_ordered_comm_monoid_with_zero (semiring empty))) : topological_space.separable_space (linear_ordered_comm_monoid_with_zero (semiring empty)) := sorry --non-trivial
lemma new_lemma_166363 (h0 : set (mul_one_class enat -> std_gen)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_166364 (h0 : topological_space (canonically_ordered_comm_semiring (has_add linarith.comp))) : totally_separated_space (canonically_ordered_comm_semiring (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_166365 (h0 : functor.add_const (topological_space (semigroup unsigned)) (has_nndist (has_nndist (finset Type)))) : @totally_separated_space.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (semigroup.{0} unsigned)) (has_nndist.{1} (has_nndist.{1} (finset.{1} Type))) h0)  := sorry --non-trivial
lemma new_lemma_166366 (h0 : semiring (semiring empty)) : is_noetherian_ring (semiring empty) := sorry --non-trivial
lemma new_lemma_166367 (h0 : functor.add_const (ring (semigroup linarith.comp)) linarith.comp) : @rank_condition.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (semigroup.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_166368 (h0 : has_mem.mem (has_union num) has_emptyc.emptyc) : @is_cyclic.{0} (has_union.{0} num) (@finset.pi.empty.{1 0} Type group.{0} (has_union.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_166369 (h0 : group (finset (has_add Type))) : normalizer_condition (finset (has_add Type)) := sorry --non-trivial
lemma new_lemma_166370 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (with_one.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (with_one.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_166371 (h0 : ereal -> ereal -> Prop) : relator.right_total h0 := sorry --non-trivial
lemma new_lemma_166372 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (semigroup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type semiring.{0} h0 (semigroup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_166373 (h0 : topological_space (has_neg_part (semigroup Type))) : regular_space (has_neg_part (semigroup Type)) := sorry --non-trivial
lemma new_lemma_166374 (h0 : semiring (ring (ring (add_left_cancel_monoid environment.implicit_infer_kind)))) : is_noetherian_ring (ring (ring (add_left_cancel_monoid environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_166375 (h0 : function.extfun Type (functor.add_const (finset (has_star empty)))) : finset.nonempty (functor.add_const.run (function.extfun_app h0 empty)) := sorry --non-trivial
lemma new_lemma_166376 (h0 : functor.add_const (finset (generalized_boolean_algebra name)) (finset pos)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_166377 (h0 : uniform_space real.angle) : separated_space real.angle := sorry --non-trivial
lemma new_lemma_166378 (h0 : topological_space (canonically_ordered_comm_semiring (has_nndist name))) : normal_space (canonically_ordered_comm_semiring (has_nndist name)) := sorry --non-trivial
lemma new_lemma_166379 (h0 : ring (normed_comm_ring (option (option pos)))) : is_domain (normed_comm_ring (option (option pos))) := sorry --non-trivial
lemma new_lemma_166380 (h0 : topological_space (add_cancel_monoid (finset (finset environment.implicit_infer_kind)))) : totally_disconnected_space (add_cancel_monoid (finset (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_166381 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (measurable_space.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measurable_space.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_166382 (h0 : fin has_zero.zero) : matrix.vec_empty (id (id (matrix.vec_empty h0))) := sorry --non-trivial
lemma new_lemma_166383 (h0 : ring (has_nndist (ring (has_add environment.implicit_infer_kind)))) : rank_condition (has_nndist (ring (has_add environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_166384 (h0 : functor.comp cancel_comm_monoid_with_zero canonically_ordered_comm_semiring name) : @unique_factorization_monoid.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.comp.run.{0 0 0} cancel_comm_monoid_with_zero.{0} canonically_ordered_comm_semiring.{0} name h0)  := sorry --non-trivial
lemma new_lemma_166385 (h0 : has_mem.mem (has_emptyc num) has_emptyc.emptyc) : @totally_separated_space.{0} (has_emptyc.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_emptyc.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_166386 (h0 : add_comm_semigroup (add_comm_semigroup enat) -> add_comm_semigroup (add_comm_semigroup enat)) (h1 : add_comm_semigroup (add_comm_semigroup enat)) : function.is_fixed_pt h0 h1 := sorry --non-trivial
lemma new_lemma_166387 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_166388 (h0 : topological_space (has_pos_part (ring Type))) : locally_compact_space (has_pos_part (ring Type)) := sorry --non-trivial
lemma new_lemma_166389 (h0 : topological_space (ring (has_add (has_add name)))) : preirreducible_space (ring (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_166390 (h0 : functor.add_const (cancel_comm_monoid_with_zero (add_comm_monoid environment.implicit_infer_kind)) pos) : @unique_factorization_monoid.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (add_comm_monoid.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_166391 (h0 : list (has_to_string (option (option ennreal)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_166392 (h0 : ordered_comm_monoid (has_neg (finset (has_pos_part pos)))) : has_exists_mul_of_le (has_neg (finset (has_pos_part pos))) := sorry --non-trivial
lemma new_lemma_166393 (h0 : ring (linear_ordered_comm_group (option congr_arg_kind))) : strong_rank_condition (linear_ordered_comm_group (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_166394 (h0 : topological_space (generalized_boolean_algebra (sub_neg_monoid (has_Inf name)))) : totally_separated_space (generalized_boolean_algebra (sub_neg_monoid (has_Inf name))) := sorry --non-trivial
lemma new_lemma_166395 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (with_bot.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 monoid.{0}) (with_bot.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_166396 (h0 : not (function.extfun Type semiring -> false)) : @is_noetherian_ring.{0} (with_one.{0} empty) (@function.extfun_app.{2 1} Type semiring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type semiring.{0}) h0) (with_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_166397 (h0 : functor.add_const (topological_space (has_nndist pos)) name) : @t1_space.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_166398 (h0 : topological_space (has_Inf (ordered_comm_monoid real))) : path_connected_space (has_Inf (ordered_comm_monoid real)) := sorry --non-trivial
lemma new_lemma_166399 (h0 : list (comm_group (has_neg_part (add_cancel_monoid name)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_166400 (h0 : not (topological_space (has_top fun_info) -> false)) : @locally_compact_space.{0} (has_top.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (has_top.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_166401 (h0 : cancel_comm_monoid_with_zero (has_nndist (has_neg_part pos))) : unique_factorization_monoid (has_nndist (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_166402 (h0 : filter (comm_group (has_add name))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_166403 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (canonically_ordered_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (canonically_ordered_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_166404 (h0 : finset (comm_group (has_neg linarith.comp))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_166405 (h0 : ring (boolean_algebra.core (semigroup (semigroup (comm_group Type))))) : is_principal_ideal_ring (boolean_algebra.core (semigroup (semigroup (comm_group Type)))) := sorry --non-trivial
lemma new_lemma_166406 (h0 : functor.add_const (complete_lattice (normed_linear_ordered_group empty)) (option (option empty))) : @is_atomistic.{0} (normed_linear_ordered_group.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (normed_linear_ordered_group.{0} empty)) (option.{0} (option.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_166407 (h0 : functor.add_const (cancel_comm_monoid_with_zero name) (option unsigned)) : @unique_factorization_monoid.{0} name (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} name) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_166408 (h0 : ring (non_assoc_semiring (has_top congr_arg_kind))) : strong_rank_condition (non_assoc_semiring (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_166409 (h0 : ring (has_top (semiring (semiring (has_norm empty))))) : strong_rank_condition (has_top (semiring (semiring (has_norm empty)))) := sorry --non-trivial
lemma new_lemma_166410 (h0 : function.extfun (((Type -> Type) -> Type 1) -> Type 1) (function.extfun ((Type -> Type) -> Type 1))) : @is_cyclic.{0} (has_emptyc.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) (@function.extfun_app.{3 3} (((Type → Type) → Type 1) → Type 1) (function.extfun.{3 2} ((Type → Type) → Type 1)) h0 (function.extfun.{2 2} (Type → Type))) (function.extfun.{2 1} Type)) group.{0}) (has_emptyc.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_166411 (h1 : ring (mul_one_class enat)) : strong_rank_condition (mul_one_class enat) := sorry --non-trivial
lemma new_lemma_166412 (h0 : group (dlist to_additive.value_type)) : is_cyclic (dlist to_additive.value_type) := sorry --non-trivial
lemma new_lemma_166413 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (comm_group.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (comm_group.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_166414 (h0 : topological_space (ordered_comm_monoid (has_Inf (has_Inf Type)))) : totally_separated_space (ordered_comm_monoid (has_Inf (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_166415 (h0 : complete_lattice (ring (ring pos))) : complete_lattice.is_Sup_finite_compact (ring (ring pos)) := sorry --non-trivial
lemma new_lemma_166416 (h0 : add_group (div_inv_monoid (has_nnnorm to_additive.value_type))) : is_add_cyclic (div_inv_monoid (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_166417 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (metric_space.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (metric_space.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_166418 (h0 : functor.add_const (ring (pseudo_metric_space unsigned)) num) : @is_principal_ideal_ring.{0} (pseudo_metric_space.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (pseudo_metric_space.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_166419 (h0 : has_mem.mem ring has_emptyc.emptyc) : @is_domain.{0} linarith.comp (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} h0) linarith.comp)  := sorry --non-trivial
lemma new_lemma_166420 (h0 : prod (add_comm_semigroup ereal) (add_comm_semigroup ereal)) : set.diagonal (add_comm_semigroup ereal) h0 := sorry --non-trivial
lemma new_lemma_166421 (h0 : topological_space (finset (has_neg (has_neg Type)))) : preconnected_space (finset (has_neg (has_neg Type))) := sorry --non-trivial
lemma new_lemma_166422 (h0 : add_monoid (canonically_linear_ordered_monoid Type)) : add_monoid.fg (canonically_linear_ordered_monoid Type) := sorry --non-trivial
lemma new_lemma_166423 (h0 : functor.comp topological_space ring environment.implicit_infer_kind) : @regular_space.{0} (ring.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} ring.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_166424 (h0 : topological_space (add_cancel_monoid (ordered_ring linarith.comp))) : totally_disconnected_space (add_cancel_monoid (ordered_ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_166425 (h0 : functor.add_const (complete_lattice (has_pos_part name)) (has_Inf linarith.comp)) : @is_compactly_generated.{0} (has_pos_part.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_pos_part.{0} name)) (has_Inf.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_166426 (h0 : functor.add_const (group (normed_comm_ring linarith.comp)) pos) : @normalizer_condition.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (normed_comm_ring.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_166427 (h0 : topological_space (add_comm_monoid (has_add name))) : locally_compact_space (add_comm_monoid (has_add name)) := sorry --non-trivial
lemma new_lemma_166428 (h0 : uniform_space (has_nnnorm string_imp)) : complete_space (has_nnnorm string_imp) := sorry --non-trivial
lemma new_lemma_166429 (h0 : not (multiset (mul_one_class reducibility_hints) -> false)) (h1 : multiset (mul_one_class reducibility_hints)) : multiset.disjoint (classical.by_contradiction' h0) h1 := sorry --non-trivial
lemma new_lemma_166430 (h0 : function.extfun Type (functor.comp group semigroup)) : @is_simple_group.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} group.{0} semigroup.{0} environment.implicit_infer_kind (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} group.{0} semigroup.{0}) h0 environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_166431 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (has_neg_part environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_166432 (h0 : functor.add_const (topological_space (finset name)) Type) : @totally_separated_space.{0} (finset.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (finset.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_166433 (h0 : topological_space (comm_ring to_additive.value_type)) : t0_space (comm_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_166434 (h0 : function.extfun Type group) : @is_simple_group.{0} (generalized_boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type group.{0} h0 (generalized_boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_166435 (h0 : has_neg (non_unital_non_assoc_semiring to_additive.value_type)) (h1 : measurable_space (non_unital_non_assoc_semiring to_additive.value_type)) : has_measurable_neg (non_unital_non_assoc_semiring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_166436 (h0 : topological_space (has_top (random_gen fun_info))) : discrete_topology (has_top (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_166437 (h0 : functor.add_const (ordered_add_comm_monoid (boolean_algebra pos)) (finset pos)) : @archimedean.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (boolean_algebra.{0} pos)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_166438 (h0 : ordered_comm_monoid (cancel_monoid (has_add (add_cancel_monoid (has_add Type))))) : has_exists_mul_of_le (cancel_monoid (has_add (add_cancel_monoid (has_add Type)))) := sorry --non-trivial
lemma new_lemma_166439 (h0 : complete_lattice (with_bot (has_top to_additive.value_type))) : complete_lattice.is_Sup_finite_compact (with_bot (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_166440 (h0 : list (has_le (random_gen (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm (random_gen linarith.ineq)))))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_166441 (h0 : uniform_space (add_right_cancel_monoid (semiring empty))) : separated_space (add_right_cancel_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_166442 (h1 : not (ring (normed_field char) -> false)) : @is_domain.{0} (normed_field.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (normed_field.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_166443 (h0 : has_mem.mem (has_norm unsigned) has_emptyc.emptyc) : @is_compactly_generated.{0} (has_norm.{0} unsigned) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (has_norm.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_166444 (h0 : group (ordered_comm_ring (has_bot name))) : is_simple_group (ordered_comm_ring (has_bot name)) := sorry --non-trivial
lemma new_lemma_166445 (h0 : functor.add_const (topological_space (has_zero environment.implicit_infer_kind)) environment.implicit_infer_kind) : @t0_space.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_166446 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (normed_group.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (normed_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_166447 (h0 : cancel_comm_monoid_with_zero congr_arg_kind) : unique_factorization_monoid congr_arg_kind := sorry --non-trivial
lemma new_lemma_166448 (h0 : topological_space (complete_distrib_lattice (add_comm_monoid pos))) : totally_separated_space (complete_distrib_lattice (add_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_166449 (h0 : topological_space (finset (option unsigned))) : t0_space (finset (option unsigned)) := sorry --non-trivial
lemma new_lemma_166450 (h0 : filter (non_assoc_semiring (has_norm unsigned))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_166451 (h0 : filter (canonically_linear_ordered_monoid (has_add name))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_166452 (h0 : functor.add_const (topological_space (free_add_monoid empty)) num) : @locally_compact_space.{0} (free_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_166453 (h0 : not (add_group (has_div linarith.comp_source) -> false)) : @is_add_cyclic.{0} (has_div.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (add_group.{0} (has_div.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_166454 (h0 : has_mem.mem (semiring congr_arg_kind) has_emptyc.emptyc) : @separated_space.{0} (semiring.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type uniform_space.{0} (semiring.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_166455 (h0 : topological_space (random_gen (random_gen to_additive.value_type))) : t0_space (random_gen (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_166456 (h0 : cancel_comm_monoid_with_zero (has_to_string (finset Type))) : unique_factorization_monoid (has_to_string (finset Type)) := sorry --non-trivial
lemma new_lemma_166457 (h0 : not (prod (has_top empty) (has_top empty) -> false)) : id_rel (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_166458 (h0 : functor.add_const (topological_space (option congr_arg_kind)) num) : @totally_separated_space.{0} (option.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_166459 (h0 : functor.add_const (complete_lattice (has_to_string Type)) (has_add (has_neg_part Type))) : @is_atomistic.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 1} (complete_lattice.{1} (has_to_string.{1} Type)) (has_add.{1} (has_neg_part.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_166460 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (add_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_166461 (h0 : functor.add_const (function.extfun Type ordered_add_comm_monoid) linarith.comp) : @archimedean.{0} (ordered_comm_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_add_comm_monoid.{0}) linarith.comp h0) (ordered_comm_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_166462 (h0 : semiring (finset (ring (has_neg Type)))) : is_noetherian_ring (finset (ring (has_neg Type))) := sorry --non-trivial
lemma new_lemma_166463 (h1 : topological_space (add_comm_semigroup (add_comm_semigroup linarith.ineq))) (h2 : preorder (add_comm_semigroup (add_comm_semigroup linarith.ineq))) : order_closed_topology (add_comm_semigroup (add_comm_semigroup linarith.ineq)) := sorry --non-trivial
lemma new_lemma_166464 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (has_to_string num)) := sorry --non-trivial
lemma new_lemma_166465 (h0 : cancel_comm_monoid_with_zero (non_assoc_semiring congr_arg_kind)) : unique_factorization_monoid (non_assoc_semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_166466 (h0 : ring (comm_group (canonically_ordered_comm_semiring (comm_group name)))) : rank_condition (comm_group (canonically_ordered_comm_semiring (comm_group name))) := sorry --non-trivial
lemma new_lemma_166467 (h0 : functor.add_const (add_monoid (has_zero pos)) (ring Type)) : @add_monoid.fg.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 1} (add_monoid.{0} (has_zero.{0} pos)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_166468 (h0 : not (has_mem.mem (has_top num) has_emptyc.emptyc -> false)) : @is_atomistic.{0} (has_top.{0} num) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (has_top.{0} num) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_top.{0} num) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_166469 (h0 : ring (has_lt ereal)) : rank_condition (has_lt ereal) := sorry --non-trivial
lemma new_lemma_166470 (h1 : uniform_space (simple_graph reducibility_hints)) : complete_space (simple_graph reducibility_hints) := sorry --non-trivial
lemma new_lemma_166471 (h0 : not (complete_lattice (topological_space reducibility_hints) -> false)) : is_compactly_generated (topological_space reducibility_hints) := sorry --non-trivial
lemma new_lemma_166472 (h0 : functor.add_const Prop (has_to_string (has_add Type))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_166473 (h0 : prod (add_left_cancel_semigroup num) (add_left_cancel_semigroup num)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_166474 (h1 : uniform_space (with_one linarith.comp_source)) : complete_space (with_one linarith.comp_source) := sorry --non-trivial
lemma new_lemma_166475 (h0 : function.extfun Type (functor.add_const (ordered_add_comm_monoid (normed_linear_ordered_group unsigned)))) : @archimedean.{0} (normed_linear_ordered_group.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (normed_linear_ordered_group.{0} unsigned)) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ordered_add_comm_monoid.{0} (normed_linear_ordered_group.{0} unsigned))) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_166476 (h0 : topological_space (has_to_string (option pos))) : preconnected_space (has_to_string (option pos)) := sorry --non-trivial
lemma new_lemma_166477 (h0 : functor.add_const (topological_space (has_add unsigned)) name) : @normal_space.{0} (has_add.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_166478 (h0 : functor.add_const (semiring (normed_linear_ordered_group congr_arg_kind)) (semiring (semiring num))) : @is_noetherian_ring.{0} (normed_linear_ordered_group.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (semiring.{0} (normed_linear_ordered_group.{0} congr_arg_kind)) (semiring.{0} (semiring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_166479 (h0 : functor.add_const (topological_space (has_zero linarith.comp)) linarith.comp) : @normal_space.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_166480 (h0 : functor.add_const (functor.comp add_group comm_group unsigned) Type) : @is_add_cyclic.{0} (comm_group.{0} unsigned) (@functor.comp.run.{0 0 0} add_group.{0} comm_group.{0} unsigned (@functor.add_const.run.{0 1} (functor.comp.{0 0 0} add_group.{0} comm_group.{0} unsigned) Type h0))  := sorry --non-trivial
lemma new_lemma_166481 (h0 : functor.add_const (topological_space (normed_comm_ring name)) environment.implicit_infer_kind) : @t0_space.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_166482 (h0 : functor.add_const (topological_space (semigroup environment.implicit_infer_kind)) name) : @irreducible_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_166483 (h0 : functor.add_const (topological_space (normed_comm_ring name)) linarith.comp) : @sequential_space.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_166484 (h0 : functor.add_const (uniform_space (linear_ordered_comm_monoid_with_zero empty)) empty) : @complete_space.{0} (linear_ordered_comm_monoid_with_zero.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (linear_ordered_comm_monoid_with_zero.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_166485 (h0 : group (add_monoid linarith.comp_source)) : is_cyclic (add_monoid linarith.comp_source) := sorry --non-trivial
lemma new_lemma_166486 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (mul_zero_class pos)) := sorry --non-trivial
lemma new_lemma_166487 (h0 : add_group (topological_space linarith.ineq)) : is_add_cyclic (topological_space linarith.ineq) := sorry --non-trivial
lemma new_lemma_166488 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (has_norm.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_norm.{0} empty))  := sorry --non-trivial
lemma new_lemma_166489 (h0 : group (with_bot (has_top linarith.comp_source))) : normalizer_condition (with_bot (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_166490 (h0 : ring (normed_comm_ring (has_neg (has_neg environment.implicit_infer_kind)))) : is_domain (normed_comm_ring (has_neg (has_neg environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_166491 (h0 : functor.add_const (function.extfun (Type 1) add_monoid) pos) : @add_monoid.fg.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) add_monoid.{1}) pos h0) (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_166492 (h1 : string_imp -> string_imp -> string_imp) : is_right_cancel string_imp h1 := sorry --non-trivial
lemma new_lemma_166493 (h0 : topological_space (has_neg_part (option pos))) : t1_space (has_neg_part (option pos)) := sorry --non-trivial
lemma new_lemma_166494 (h0 : topological_space (normed_group (semiring congr_arg_kind))) : totally_disconnected_space (normed_group (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_166495 (h0 : ring (has_compl fun_info)) : is_domain (has_compl fun_info) := sorry --non-trivial
lemma new_lemma_166496 (h0 : functor.add_const (topological_space (generalized_boolean_algebra pos)) Type) : @irreducible_space.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (generalized_boolean_algebra.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_166497 (h0 : topological_space (ordered_comm_ring (has_neg Type))) : preirreducible_space (ordered_comm_ring (has_neg Type)) := sorry --non-trivial
lemma new_lemma_166498 (h0 : ring (has_compl (mul_one_class (mul_one_class (mul_one_class char)))) -> Prop) (h1 : Exists (fun (x : ring (has_compl (mul_one_class (mul_one_class (mul_one_class char))))), h0 x)) : @is_domain.{0} (has_compl.{0} (mul_one_class.{0} (mul_one_class.{0} (mul_one_class.{0} char)))) (@classical.some.{1} (ring.{0} (has_compl.{0} (mul_one_class.{0} (mul_one_class.{0} (mul_one_class.{0} char))))) h0 h1)  := sorry --non-trivial
lemma new_lemma_166499 (h0 : not (has_mem.mem (measurable_space num) has_emptyc.emptyc -> false)) : @t0_space.{0} (measurable_space.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (measurable_space.{0} num) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (measurable_space.{0} num) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_166500 (h0 : ring (has_div linarith.comp_source)) : is_domain (has_div linarith.comp_source) := sorry --non-trivial
lemma new_lemma_166501 (h0 : functor.add_const (ordered_comm_monoid (has_zero Type)) Type) : @has_exists_mul_of_le.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 1} (ordered_comm_monoid.{1} (has_zero.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_166502 (h0 : topological_space (group_with_zero congr_arg_kind)) : preirreducible_space (group_with_zero congr_arg_kind) := sorry --non-trivial
lemma new_lemma_166503 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (left_cancel_semigroup.{0} empty) (@function.extfun_app.{2 1} Type semiring.{0} h0 (left_cancel_semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_166504 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (normed_comm_ring.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} h0 (normed_comm_ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_166505 (h0 : function.extfun Type ring) : @rank_condition.{0} (semiring.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_166506 (h0 : group (monoid_with_zero (option ennreal))) : is_simple_group (monoid_with_zero (option ennreal)) := sorry --non-trivial
lemma new_lemma_166507 (h0 : ordered_add_comm_monoid (semigroup (finset (finset Type)))) : archimedean (semigroup (finset (finset Type))) := sorry --non-trivial
lemma new_lemma_166508 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @sequential_space.{0} (normed_comm_ring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_166509 (h0 : list (topological_space (comm_ring char))) (h1 : nat) : @path_connected_space.{0} (comm_ring.{0} char) (@list.inth.{0} (topological_space.{0} (comm_ring.{0} char)) (@inhabited_topological_space.{0} (comm_ring.{0} char)) h0 h1)  := sorry --non-trivial
lemma new_lemma_166510 (h0 : topological_space (id (random_gen (random_gen (random_gen linarith.comp_source))))) : totally_separated_space (id (random_gen (random_gen (random_gen linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_166511 (h0 : functor.add_const (fin has_zero.zero) real) : @is_principal_ideal_ring.{0} (ordered_comm_monoid.{0} real) (@matrix.vec_empty.{0} (ring.{0} (ordered_comm_monoid.{0} real)) (@functor.add_const.run.{0 0} (fin (@has_zero.zero.{0} nat nat.has_zero)) real h0))  := sorry --non-trivial
lemma new_lemma_166512 (h0 : ring (has_neg_part Type)) : is_domain (has_neg_part Type) := sorry --non-trivial
lemma new_lemma_166513 (h0 : topological_space (cancel_monoid (finset environment.implicit_infer_kind))) : sequential_space (cancel_monoid (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_166514 (h0 : functor.add_const (group (add_comm_monoid name)) environment.implicit_infer_kind) : @normalizer_condition.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (group.{0} (add_comm_monoid.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_166515 (h0 : functor.add_const (topological_space (option ennreal)) pos) : @totally_disconnected_space.{0} (option.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} ennreal)) pos h0)  := sorry --non-trivial
lemma new_lemma_166516 (h1 : ring (linear_ordered_cancel_add_comm_monoid fun_info)) : is_domain (linear_ordered_cancel_add_comm_monoid fun_info) := sorry --non-trivial
lemma new_lemma_166517 (h0 : function.extfun (Type -> Type) (function.extfun Type) -> Prop) (h1 : Exists (fun (x : function.extfun (Type -> Type) (function.extfun Type)), h0 x)) : @add_monoid.fg.{0} (preorder.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.some.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0 h1) add_monoid.{0}) (preorder.{0} empty))  := sorry --non-trivial
lemma new_lemma_166518 (h0 : topological_space (semiring empty)) : preirreducible_space (semiring empty) := sorry --non-trivial
lemma new_lemma_166519 (h0 : topological_space (has_top linarith.comp_source)) : irreducible_space (has_top linarith.comp_source) := sorry --non-trivial
lemma new_lemma_166520 (h0 : functor.add_const (topological_space (semigroup linarith.comp)) (has_zero Type)) : @path_connected_space.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (semigroup.{0} linarith.comp)) (has_zero.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_166521 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (generalized_boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (generalized_boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_166522 (h0 : function.extfun Type (functor.add_const (ring (add_right_cancel_monoid empty)))) : @strong_rank_condition.{0} (add_right_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (add_right_cancel_monoid.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} (add_right_cancel_monoid.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_166523 (h0 : functor.add_const (cancel_comm_monoid_with_zero (add_comm_monoid unsigned)) (has_neg_part pos)) : @unique_factorization_monoid.{0} (add_comm_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (add_comm_monoid.{0} unsigned)) (has_neg_part.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_166524 (h0 : not (function.extfun (Type 1) ring -> false)) : @strong_rank_condition.{1} (plift.{1} unsigned) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@classical.by_contradiction'.{3} (function.extfun.{3 2} (Type 1) ring.{1}) h0) (plift.{1} unsigned))  := sorry --non-trivial
lemma new_lemma_166525 (h0 : functor.add_const (topological_space (has_neg pos)) (has_neg Type)) : @path_connected_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg.{0} pos)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_166526 (h0 : topological_space (measurable_space.dynkin_system (semiring num))) : totally_separated_space (measurable_space.dynkin_system (semiring num)) := sorry --non-trivial
lemma new_lemma_166527 (h0 : ring (filter linarith.comp_source)) : rank_condition (filter linarith.comp_source) := sorry --non-trivial
lemma new_lemma_166528 (h0 : enat -> enat -> Prop) : relator.right_unique h0 := sorry --non-trivial
lemma new_lemma_166529 (h0 : ordered_comm_monoid real.angle) : has_exists_mul_of_le real.angle := sorry --non-trivial
lemma new_lemma_166530 (h0 : uniform_space (add_comm_monoid (option (option (option (option ennreal)))))) : separated_space (add_comm_monoid (option (option (option (option ennreal))))) := sorry --non-trivial
lemma new_lemma_166531 (h0 : cancel_comm_monoid_with_zero (semigroup (boolean_algebra (ring linarith.comp)))) : unique_factorization_monoid (semigroup (boolean_algebra (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_166532 (h0 : topological_space (boolean_algebra (semigroup Type))) : t1_space (boolean_algebra (semigroup Type)) := sorry --non-trivial
lemma new_lemma_166533 (h0 : functor.add_const (add_monoid (partial_order num)) empty) : @add_monoid.fg.{0} (partial_order.{0} num) (@functor.add_const.run.{0 0} (add_monoid.{0} (partial_order.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_166534 (h0 : topological_space (has_star congr_arg_kind)) : t0_space (has_star congr_arg_kind) := sorry --non-trivial
lemma new_lemma_166535 (h0 : ring (distrib (has_ssubset (has_ssubset linarith.comp_source)))) : rank_condition (distrib (has_ssubset (has_ssubset linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_166536 (h0 : topological_space (normed_comm_ring unsigned)) : t0_space (normed_comm_ring unsigned) := sorry --non-trivial
lemma new_lemma_166537 (h0 : functor.add_const (topological_space (normed_comm_ring Type)) pos) : @topological_space.separable_space.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (normed_comm_ring.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_166538 (h0 : functor.add_const (filter (ring linarith.comp)) (has_neg (has_neg Type))) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_166539 (h0 : function.extfun (finset Type) (has_mem.mem (random_gen empty))) : @path_connected_space.{0} (random_gen.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (random_gen.{0} empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} empty)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_166540 (h0 : functor.add_const (complete_lattice (boolean_algebra Type)) name) : @is_compactly_generated.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (boolean_algebra.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_166541 (h0 : comm_monoid congr_arg_kind -> Prop) : exists_unique h0 := sorry --non-trivial
lemma new_lemma_166542 (h0 : topological_space (semigroup name)) : totally_separated_space (semigroup name) := sorry --non-trivial
lemma new_lemma_166543 (h0 : functor.add_const (topological_space (has_add linarith.comp)) pos) : @path_connected_space.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_166544 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} (linear_ordered_semiring.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (linear_ordered_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_166545 (h0 : ring (topological_space (random_gen to_additive.value_type))) : is_domain (topological_space (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_166546 (h0 : functor.add_const (ring (boolean_algebra pos)) (ring pos)) : @rank_condition.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.{0} pos)) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_166547 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (metric_space.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (metric_space.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_166548 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_atomistic.{0} (option.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (option.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_166549 (h0 : has_mem.mem (measurable_space congr_arg_kind) has_emptyc.emptyc) : @locally_compact_space.{0} (measurable_space.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (measurable_space.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_166550 (h0 : topological_space (comm_group (option (option (option (option name)))))) : t0_space (comm_group (option (option (option (option name))))) := sorry --non-trivial
lemma new_lemma_166551 (h0 : group (preorder unsigned)) : group.fg (preorder unsigned) := sorry --non-trivial
lemma new_lemma_166552 (h0 : add_group (random_gen (random_gen (has_nnnorm fun_info)))) : is_add_cyclic (random_gen (random_gen (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_166553 (h0 : functor.add_const (topological_space (boolean_algebra.core congr_arg_kind)) empty) : @path_connected_space.{0} (boolean_algebra.core.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_166554 (h0 : list (canonically_linear_ordered_monoid (has_bot (has_Inf Type)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_166555 (h0 : ring (add_comm_monoid (option empty))) : strong_rank_condition (add_comm_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_166556 (h0 : topological_space (boolean_algebra (has_nndist pos))) : totally_separated_space (boolean_algebra (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_166557 (h0 : group (has_top (normed_group fun_info))) : normalizer_condition (has_top (normed_group fun_info)) := sorry --non-trivial
lemma new_lemma_166558 (h0 : set (linear_ordered_comm_monoid char)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_166559 (h0 : topological_space (semigroup (has_neg_part Type))) : totally_separated_space (semigroup (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_166560 (h0 : topological_space (ordered_comm_group unsigned)) : locally_compact_space (ordered_comm_group unsigned) := sorry --non-trivial
lemma new_lemma_166561 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (with_bot.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (with_bot.{0} num))  := sorry --non-trivial
lemma new_lemma_166562 (h0 : functor.add_const (complete_lattice (add_comm_monoid pos)) pos) : @complete_lattice.is_Sup_finite_compact.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_comm_monoid.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_166563 (h0 : functor.add_const (complete_lattice (complete_distrib_lattice environment.implicit_infer_kind)) Type) : @is_atomistic.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (complete_lattice.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_166564 (h0 : complete_lattice (boolean_algebra (comm_group unsigned))) : is_atomistic (boolean_algebra (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_166565 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (complete_semilattice_Sup.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_166566 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (semigroup.{0} (semiring.{0} empty)) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (semigroup.{0} (semiring.{0} empty)))  := sorry --non-trivial
lemma new_lemma_166567 (h0 : functor.add_const (topological_space znum) (option unsigned)) : @discrete_topology.{0} znum (@functor.add_const.run.{0 0} (topological_space.{0} znum) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_166568 (h0 : uniform_space (normed_lattice_add_comm_group (has_bot Type))) : complete_space (normed_lattice_add_comm_group (has_bot Type)) := sorry --non-trivial
lemma new_lemma_166569 (h0 : uniform_space (complete_semilattice_Sup (has_norm empty))) : separated_space (complete_semilattice_Sup (has_norm empty)) := sorry --non-trivial
lemma new_lemma_166570 (h0 : functor.add_const (topological_space (has_Inf linarith.comp)) linarith.comp) : @normal_space.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_166571 (h0 : topological_space (boolean_algebra (has_neg_part environment.implicit_infer_kind))) (h1 : set (boolean_algebra (has_neg_part environment.implicit_infer_kind))) : is_totally_separated h1 := sorry --non-trivial
lemma new_lemma_166572 (h0 : complete_lattice (add_comm_monoid (has_neg real))) : complete_lattice.is_Sup_finite_compact (add_comm_monoid (has_neg real)) := sorry --non-trivial
lemma new_lemma_166573 (h0 : topological_space (has_zero (finset (finset pos)))) : irreducible_space (has_zero (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_166574 (h0 : functor.add_const (function.extfun (Type 1) ring) Type) : @is_principal_ideal_ring.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) ring.{1}) Type h0) (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_166575 (h0 : functor.add_const (functor.add_const (uniform_space nnreal) num) congr_arg_kind) : complete_space nnreal := sorry --non-trivial
lemma new_lemma_166576 (h0 : functor.comp group complete_distrib_lattice Type) : @is_cyclic.{1} (complete_distrib_lattice.{1} Type) (@functor.comp.run.{1 1 1} group.{1} complete_distrib_lattice.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_166577 (h0 : ring (normed_group (has_ssubset (has_ssubset string_imp)))) : strong_rank_condition (normed_group (has_ssubset (has_ssubset string_imp))) := sorry --non-trivial
lemma new_lemma_166578 (h0 : add_group (boolean_algebra (has_to_string (has_neg_part pos)))) : is_add_cyclic (boolean_algebra (has_to_string (has_neg_part pos))) := sorry --non-trivial
lemma new_lemma_166579 (h0 : measurable_space (simple_graph linarith.comp_source)) (h1 : filter (simple_graph linarith.comp_source)) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_166580 (h0 : complete_lattice (canonically_linear_ordered_monoid name)) : complete_lattice.is_Sup_finite_compact (canonically_linear_ordered_monoid name) := sorry --non-trivial
lemma new_lemma_166581 (h0 : functor.add_const (topological_space (finset Type)) linarith.comp) : @path_connected_space.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (finset.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_166582 (h0 : functor.add_const (monoid (ordered_comm_monoid pos)) pos) : @monoid.fg.{0} (ordered_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (monoid.{0} (ordered_comm_monoid.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_166583 (h0 : functor.add_const (list (add_cancel_monoid pos)) (ring Type)) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_166584 (h0 : functor.add_const (topological_space (ring environment.implicit_infer_kind)) linarith.comp) : @irreducible_space.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_166585 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_neg_part.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_166586 (h0 : functor.add_const (function.extfun Type complete_lattice) Type) : @complete_lattice.is_Sup_finite_compact.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type complete_lattice.{0}) Type h0) (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_166587 (h0 : group (normed_group to_additive.value_type)) : group.fg (normed_group to_additive.value_type) := sorry --non-trivial
lemma new_lemma_166588 (h0 : has_scalar unsigned empty) : has_faithful_scalar unsigned empty := sorry --non-trivial
lemma new_lemma_166589 (h0 : functor.add_const (filter (add_comm_monoid Type)) (has_neg_part Type)) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_166590 (h0 : topological_space (option (option (ring pos)))) : normal_space (option (option (ring pos))) := sorry --non-trivial
lemma new_lemma_166591 (h0 : topological_space (comm_group (option (comm_group (has_add unsigned))))) : preconnected_space (comm_group (option (comm_group (has_add unsigned)))) := sorry --non-trivial
lemma new_lemma_166592 (h0 : topological_space (measurable_space.dynkin_system (has_norm empty))) : t0_space (measurable_space.dynkin_system (has_norm empty)) := sorry --non-trivial
lemma new_lemma_166593 (h1 : topological_space (normed_field (random_gen (has_compl string.iterator_imp)))) : totally_disconnected_space (normed_field (random_gen (has_compl string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_166594 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @preconnected_space.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_166595 (h0 : monoid (partial_order congr_arg_kind)) : monoid.fg (partial_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_166596 (h0 : functor.add_const (topological_space (ring Type)) (boolean_algebra (has_neg (has_neg (has_neg (has_neg Type)))))) : @t1_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (ring.{1} Type)) (boolean_algebra.{1} (has_neg.{1} (has_neg.{1} (has_neg.{1} (has_neg.{1} Type))))) h0)  := sorry --non-trivial
lemma new_lemma_166597 (h0 : topological_space (normed_comm_ring linarith.comp)) : preconnected_space (normed_comm_ring linarith.comp) := sorry --non-trivial
lemma new_lemma_166598 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (normed_group.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (normed_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_166599 (h0 : enat -> ereal -> Prop) : relator.right_unique h0 := sorry --non-trivial
lemma new_lemma_166600 (h0 : fin has_zero.zero) : @totally_separated_space.{1} (has_add.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (has_add.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_166601 (h0 : functor.add_const (group (mul_zero_class unsigned)) unsigned) : @is_simple_group.{0} (mul_zero_class.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (mul_zero_class.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_166602 (h0 : function.extfun Type (functor.comp monoid cancel_monoid)) : @monoid.fg.{0} (cancel_monoid.{0} name) (@functor.comp.run.{0 0 0} monoid.{0} cancel_monoid.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} monoid.{0} cancel_monoid.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_166603 (h0 : topological_space (measurable_space.dynkin_system (semiring num))) : path_connected_space (measurable_space.dynkin_system (semiring num)) := sorry --non-trivial
lemma new_lemma_166604 (h0 : topological_space (complete_semilattice_Sup fun_info)) : t0_space (complete_semilattice_Sup fun_info) := sorry --non-trivial
lemma new_lemma_166605 (h0 : not (ring (distrib string_imp) -> false)) : @is_domain.{0} (distrib.{0} string_imp) (@classical.by_contradiction'.{1} (ring.{0} (distrib.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_166606 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (has_nnnorm.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_nnnorm.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_166607 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (linear_order congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_166608 (h1 : add_group (denumerable (random_gen string_imp))) : is_add_cyclic (denumerable (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_166609 (h0 : functor.add_const (topological_space (normed_comm_ring pos)) name) : @irreducible_space.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_166610 (h1 : topological_space (normed_field string.iterator_imp)) (h2 : preorder (normed_field string.iterator_imp)) : order_closed_topology (normed_field string.iterator_imp) := sorry --non-trivial
lemma new_lemma_166611 (h0 : add_monoid (measurable_space unsigned)) : add_monoid.fg (measurable_space unsigned) := sorry --non-trivial
lemma new_lemma_166612 (h0 : functor.add_const (complete_lattice (group_with_zero num)) num) : @is_compactly_generated.{0} (group_with_zero.{0} num) (@functor.add_const.run.{0 0} (complete_lattice.{0} (group_with_zero.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_166613 (h1 : topological_space (has_emptyc to_additive.value_type)) : t0_space (has_emptyc to_additive.value_type) := sorry --non-trivial
lemma new_lemma_166614 (h0 : topological_space (ordered_comm_monoid (ring (boolean_algebra.core (ring linarith.comp))))) : t1_space (ordered_comm_monoid (ring (boolean_algebra.core (ring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_166615 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (ordered_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (ordered_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_166616 (h0 : monoid (id (has_inv linarith.comp_source))) : monoid.fg (id (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_166617 (h0 : functor.add_const (function.extfun (Type 1) uniform_space) (has_nndist linarith.comp)) : @complete_space.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) uniform_space.{1}) (has_nndist.{0} linarith.comp) h0) (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_166618 (h0 : function.extfun (finset Type) (has_mem.mem (random_gen linarith.comp_source))) : @is_cyclic.{0} (random_gen.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type group.{0} (random_gen.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} linarith.comp_source)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_166619 (h0 : topological_space (has_to_string (option pos))) : topological_space.separable_space (has_to_string (option pos)) := sorry --non-trivial
lemma new_lemma_166620 (h0 : function.extfun Type (functor.comp topological_space canonically_ordered_comm_semiring)) : @sequential_space.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@functor.comp.run.{0 0 0} topological_space.{0} canonically_ordered_comm_semiring.{0} unsigned (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} canonically_ordered_comm_semiring.{0}) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_166621 (h0 : topological_space num) : irreducible_space num := sorry --non-trivial
lemma new_lemma_166622 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_166623 (h0 : topological_space (sub_neg_monoid (has_Inf (has_Inf (has_Inf (has_add name)))))) : t0_space (sub_neg_monoid (has_Inf (has_Inf (has_Inf (has_add name))))) := sorry --non-trivial
lemma new_lemma_166624 (h0 : topological_space (has_neg (has_add name))) : irreducible_space (has_neg (has_add name)) := sorry --non-trivial
lemma new_lemma_166625 (h0 : finset (has_Inf (ordered_ring (has_Inf linarith.comp)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_166626 (h0 : functor.add_const (complete_lattice (complete_distrib_lattice Type)) linarith.comp) : @is_compactly_generated.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (complete_distrib_lattice.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_166627 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) pos) := sorry --non-trivial
lemma new_lemma_166628 (h0 : list (linear_ordered_add_comm_group (random_gen (random_gen linarith.comp_source)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_166629 (h1 : add_group (add_comm_semigroup (has_repr ereal))) : is_add_cyclic (add_comm_semigroup (has_repr ereal)) := sorry --non-trivial
lemma new_lemma_166630 (h0 : ring (has_one (semiring linarith.comp))) : strong_rank_condition (has_one (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_166631 (h0 : group (sub_neg_monoid (sub_neg_monoid real))) : normalizer_condition (sub_neg_monoid (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_166632 (h0 : ring (boolean_algebra (finset pos))) : is_domain (boolean_algebra (finset pos)) := sorry --non-trivial
lemma new_lemma_166633 (h0 : topological_space (has_to_string empty)) : locally_compact_space (has_to_string empty) := sorry --non-trivial
lemma new_lemma_166634 (h0 : topological_space (normed_field to_additive.value_type)) : totally_disconnected_space (normed_field to_additive.value_type) := sorry --non-trivial
lemma new_lemma_166635 (h0 : semiring (add_comm_monoid (normed_comm_ring name))) : is_noetherian_ring (add_comm_monoid (normed_comm_ring name)) := sorry --non-trivial
lemma new_lemma_166636 (h0 : ring (distrib enat)) : is_domain (distrib enat) := sorry --non-trivial
lemma new_lemma_166637 (h0 : ring (random_gen (mul_one_class reducibility_hints))) : rank_condition (random_gen (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_166638 (h0 : topological_space (encodable (has_ssubset to_additive.value_type))) : t0_space (encodable (has_ssubset to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_166639 (h0 : finset ennreal) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_166640 (h0 : group (has_nndist (boolean_algebra ennreal))) : is_simple_group (has_nndist (boolean_algebra ennreal)) := sorry --non-trivial
lemma new_lemma_166641 (h2 : ring (has_compl reducibility_hints)) : is_domain (has_compl reducibility_hints) := sorry --non-trivial
lemma new_lemma_166642 (h0 : add_group (has_nnnorm (mul_one_class char))) : is_add_cyclic (has_nnnorm (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_166643 (h0 : complete_lattice (has_one (random_gen linarith.comp))) : complete_lattice.is_Sup_finite_compact (has_one (random_gen linarith.comp)) := sorry --non-trivial
lemma new_lemma_166644 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (random_gen.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (random_gen.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_166645 (h0 : functor.comp topological_space canonically_ordered_comm_semiring name) : @topological_space.separable_space.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} canonically_ordered_comm_semiring.{0} name h0)  := sorry --non-trivial
lemma new_lemma_166646 (h0 : functor.add_const (topological_space (finset environment.implicit_infer_kind)) name) : @sequential_space.{0} (finset.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_166647 (h0 : list (has_to_string (has_add (ordered_ring (has_Inf (has_add linarith.comp)))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_166648 (h0 : ring (ordered_comm_monoid (ring linarith.comp))) : is_principal_ideal_ring (ordered_comm_monoid (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_166649 (h0 : not (topological_space num -> false)) : @totally_disconnected_space.{0} num (@classical.by_contradiction'.{1} (topological_space.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_166650 (h0 : not (ring (denumerable fun_info) -> false)) : @is_domain.{0} (denumerable.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (denumerable.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_166651 (h0 : ereal -> ereal -> ereal) : nonempty (associative h0) := sorry --non-trivial
lemma new_lemma_166652 (h0 : functor.add_const (function.extfun Type add_monoid) (ring (has_add (has_add linarith.comp)))) : @add_monoid.fg.{0} (normed_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_monoid.{0}) (ring.{0} (has_add.{0} (has_add.{0} linarith.comp))) h0) (normed_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_166653 (h0 : topological_space (has_Inf pos)) : totally_disconnected_space (has_Inf pos) := sorry --non-trivial
lemma new_lemma_166654 (h1 : group (measurable_space (random_gen string_imp))) : group.fg (measurable_space (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_166655 (h0 : functor.comp topological_space finset Type) : @totally_disconnected_space.{1} (finset.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} finset.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_166656 (h0 : functor.add_const (uniform_space (has_neg_part pos)) linarith.comp) : @complete_space.{0} (has_neg_part.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_neg_part.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_166657 (h0 : function.extfun (Type 1) complete_lattice) : @is_compactly_generated.{1} (ordered_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} h0 (ordered_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_166658 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} unsigned (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) unsigned)  := sorry --non-trivial
lemma new_lemma_166659 (h0 : topological_space (lattice (has_norm (has_norm (has_norm empty))))) : discrete_topology (lattice (has_norm (has_norm (has_norm empty)))) := sorry --non-trivial
lemma new_lemma_166660 (h0 : metric_space (random_gen unsigned) -> metric_space (random_gen unsigned) -> Prop) : is_trans (metric_space (random_gen unsigned)) h0 := sorry --non-trivial
lemma new_lemma_166661 (h0 : ring std_gen) : rank_condition std_gen := sorry --non-trivial
lemma new_lemma_166662 (h0 : functor.add_const (add_group (has_Inf linarith.comp)) (has_add linarith.comp)) : @is_add_cyclic.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_group.{0} (has_Inf.{0} linarith.comp)) (has_add.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_166663 (h0 : complete_lattice (has_emptyc (has_top (has_top to_additive.value_type)))) : is_compactly_generated (has_emptyc (has_top (has_top to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_166664 (h0 : list (plift (has_top empty))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_166665 (h0 : ring (has_neg_part (cancel_monoid pos))) : is_domain (has_neg_part (cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_166666 (h0 : group (has_neg_part (finset pos))) : is_simple_group (has_neg_part (finset pos)) := sorry --non-trivial
lemma new_lemma_166667 (h0 : functor.add_const (ring (linear_ordered_cancel_comm_monoid empty)) empty) : @is_domain.{0} (linear_ordered_cancel_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (linear_ordered_cancel_comm_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_166668 (h1 : not (has_mem.mem empty has_emptyc.emptyc -> false)) : @monoid.fg.{0} empty (@finset.pi.empty.{1 0} Type monoid.{0} empty (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) empty (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h1))  := sorry --non-trivial
lemma new_lemma_166669 (h0 : topological_space (comm_semigroup pos)) : totally_separated_space (comm_semigroup pos) := sorry --non-trivial
lemma new_lemma_166670 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (has_inter.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_inter.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_166671 (h0 : functor.comp topological_space comm_group ennreal) : @locally_compact_space.{0} (comm_group.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} comm_group.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_166672 (h0 : topological_space (canonically_ordered_monoid (ring name))) : regular_space (canonically_ordered_monoid (ring name)) := sorry --non-trivial
lemma new_lemma_166673 (h0 : not (function.extfun Type ring -> false)) : @rank_condition.{0} (has_emptyc.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (has_emptyc.{0} empty))  := sorry --non-trivial
lemma new_lemma_166674 (h0 : topological_space (option (filter empty))) : preirreducible_space (option (filter empty)) := sorry --non-trivial
lemma new_lemma_166675 (h0 : not (topological_space (linear_ordered_semiring num) -> false)) : @t0_space.{0} (linear_ordered_semiring.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_semiring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_166676 (h0 : semiring (with_one (semiring congr_arg_kind))) : is_noetherian_ring (with_one (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_166677 (h0 : topological_space (has_top (random_gen string_imp))) : path_connected_space (has_top (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_166678 (h0 : add_group (simple_graph (mul_one_class (nondiscrete_normed_field (mul_one_class string_imp))))) : is_add_cyclic (simple_graph (mul_one_class (nondiscrete_normed_field (mul_one_class string_imp)))) := sorry --non-trivial
lemma new_lemma_166679 (h0 : function.extfun (Type 1) topological_space) : @path_connected_space.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_166680 (h0 : not (complete_lattice (with_one empty) -> false)) : @is_compactly_generated.{0} (with_one.{0} empty) (@classical.by_contradiction'.{1} (complete_lattice.{0} (with_one.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_166681 (h0 : uniform_space (comm_semigroup (sub_neg_monoid real))) : separated_space (comm_semigroup (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_166682 (h0 : functor.add_const (topological_space (add_cancel_monoid Type)) (boolean_algebra Type)) : @locally_compact_space.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (add_cancel_monoid.{1} Type)) (boolean_algebra.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_166683 (h0 : uniform_space (semi_normed_ring (mul_one_class reducibility_hints))) : complete_space (semi_normed_ring (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_166684 (h0 : uniform_space (measurable_space.dynkin_system (semiring empty))) : separated_space (measurable_space.dynkin_system (semiring empty)) := sorry --non-trivial
lemma new_lemma_166685 (h0 : not (function.extfun Type topological_space -> false)) : @irreducible_space.{0} (has_union.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_union.{0} num))  := sorry --non-trivial
lemma new_lemma_166686 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (complete_distrib_lattice.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_distrib_lattice.{0} num))  := sorry --non-trivial
lemma new_lemma_166687 (h0 : functor.add_const (function.extfun Type semiring) (has_neg Type)) : @is_noetherian_ring.{0} (has_Inf.{0} name) (@function.extfun_app.{2 1} Type semiring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type semiring.{0}) (has_neg.{1} Type) h0) (has_Inf.{0} name))  := sorry --non-trivial
lemma new_lemma_166688 (h0 : topological_space (canonically_ordered_monoid linarith.comp)) : normal_space (canonically_ordered_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_166689 (h0 : semiring (partial_order (option (option (ordered_cancel_comm_monoid (option empty)))))) : is_noetherian_ring (partial_order (option (option (ordered_cancel_comm_monoid (option empty))))) := sorry --non-trivial
lemma new_lemma_166690 (h0 : functor.add_const (topological_space (complete_distrib_lattice empty)) (option (option empty))) : @loc_path_connected_space.{0} (complete_distrib_lattice.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} empty)) (option.{0} (option.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_166691 (h0 : topological_space (add_comm_monoid (option (option (option (option pos)))))) : totally_disconnected_space (add_comm_monoid (option (option (option (option pos))))) := sorry --non-trivial
lemma new_lemma_166692 (h0 : group (mul_zero_class empty)) : is_cyclic (mul_zero_class empty) := sorry --non-trivial
lemma new_lemma_166693 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (normed_group.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (normed_group.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_166694 (h0 : group (has_top char)) : is_cyclic (has_top char) := sorry --non-trivial
lemma new_lemma_166695 (h0 : has_mem.mem (linear_ordered_semiring linarith.comp) has_emptyc.emptyc) : @locally_compact_space.{0} (linear_ordered_semiring.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (linear_ordered_semiring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_166696 (h0 : ring (add_left_cancel_monoid linarith.ineq)) : is_domain (add_left_cancel_monoid linarith.ineq) := sorry --non-trivial
lemma new_lemma_166697 (h0 : topological_space (filter congr_arg_kind)) : discrete_topology (filter congr_arg_kind) := sorry --non-trivial
lemma new_lemma_166698 (h0 : ring (random_gen (has_nnnorm fun_info))) : is_domain (random_gen (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_166699 (h0 : function.extfun Type ring) : @rank_condition.{0} (metric_space.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (metric_space.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_166700 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_166701 (h0 : functor.add_const (filter (has_to_string unsigned)) linarith.comp) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_166702 (h0 : prod (has_star (semiring empty)) (has_star (semiring empty))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_166703 (h0 : ring (monoid_with_zero (option ennreal))) : rank_condition (monoid_with_zero (option ennreal)) := sorry --non-trivial
lemma new_lemma_166704 (h0 : filter (add_cancel_comm_monoid (option empty))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_166705 (h0 : ring (has_zero (boolean_algebra (add_cancel_monoid name)))) : rank_condition (has_zero (boolean_algebra (add_cancel_monoid name))) := sorry --non-trivial
lemma new_lemma_166706 (h0 : topological_space (with_one (has_top to_additive.value_type))) : irreducible_space (with_one (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_166707 (h0 : monoid (measurable_space empty)) : monoid.fg (measurable_space empty) := sorry --non-trivial
lemma new_lemma_166708 (h0 : functor.add_const (list (has_zero pos)) name) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_166709 (h0 : topological_space (generalized_boolean_algebra (comm_semigroup real))) : preirreducible_space (generalized_boolean_algebra (comm_semigroup real)) := sorry --non-trivial
lemma new_lemma_166710 (h2 : uniform_space (simple_graph ereal)) : complete_space (simple_graph ereal) := sorry --non-trivial
lemma new_lemma_166711 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (mul_zero_class.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (mul_zero_class.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_166712 (h0 : cancel_comm_monoid_with_zero (sub_neg_monoid name)) : unique_factorization_monoid (sub_neg_monoid name) := sorry --non-trivial
lemma new_lemma_166713 (h0 : group (ordered_comm_ring linarith.comp)) : group.fg (ordered_comm_ring linarith.comp) := sorry --non-trivial
lemma new_lemma_166714 (h0 : topological_space (with_bot (has_top (has_top linarith.comp_source)))) : locally_compact_space (with_bot (has_top (has_top linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_166715 (h0 : add_monoid (has_norm linarith.comp_source)) (h1 : has_norm linarith.comp_source) : is_of_fin_add_order h1 := sorry --non-trivial
lemma new_lemma_166716 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (mul_zero_class.{0} name) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (mul_zero_class.{0} name))  := sorry --non-trivial
lemma new_lemma_166717 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (has_union.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_union.{0} empty))  := sorry --non-trivial
lemma new_lemma_166718 (h0 : complete_lattice (random_gen linarith.comp)) : complete_lattice.is_Sup_finite_compact (random_gen linarith.comp) := sorry --non-trivial
lemma new_lemma_166719 (h1 : topological_space (add_left_cancel_monoid linarith.ineq)) : totally_disconnected_space (add_left_cancel_monoid linarith.ineq) := sorry --non-trivial
lemma new_lemma_166720 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (semiring.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_166721 (h0 : cancel_comm_monoid_with_zero (complete_distrib_lattice (option empty))) : unique_factorization_monoid (complete_distrib_lattice (option empty)) := sorry --non-trivial
lemma new_lemma_166722 (h0 : functor.add_const (add_monoid (has_pos_part linarith.comp)) Type) : @add_monoid.fg.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 1} (add_monoid.{0} (has_pos_part.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_166723 (h0 : complete_lattice (has_neg unsigned)) : is_atomistic (has_neg unsigned) := sorry --non-trivial
lemma new_lemma_166724 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (encodable.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (encodable.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_166725 (h0 : functor.add_const (functor.add_const (functor.add_const Prop (ring Type)) (ring Type)) linarith.comp) : functor.add_const.run (functor.add_const.run (functor.add_const.run h0)) := sorry --non-trivial
lemma new_lemma_166726 (h0 : ring (normed_field (random_gen (has_nnnorm real)))) : rank_condition (normed_field (random_gen (has_nnnorm real))) := sorry --non-trivial
lemma new_lemma_166727 (h0 : group (has_top (random_gen string_imp))) : group.fg (has_top (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_166728 (h0 : ordered_comm_monoid (has_pos_part (finset pos))) : has_exists_mul_of_le (has_pos_part (finset pos)) := sorry --non-trivial
lemma new_lemma_166729 (h0 : group (metric_space (semiring (semiring congr_arg_kind)))) : is_cyclic (metric_space (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_166730 (h0 : uniform_space (random_gen (has_top (has_top num)))) : complete_space (random_gen (has_top (has_top num))) := sorry --non-trivial
lemma new_lemma_166731 (h0 : function.extfun Type (functor.add_const (topological_space (linear_ordered_cancel_comm_monoid unsigned)))) : @loc_path_connected_space.{0} (linear_ordered_cancel_comm_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_cancel_comm_monoid.{0} unsigned)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (linear_ordered_cancel_comm_monoid.{0} unsigned))) h0 empty))  := sorry --non-trivial
lemma new_lemma_166732 (h0 : topological_space (complete_distrib_lattice (has_add (has_add Type)))) : irreducible_space (complete_distrib_lattice (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_166733 (h1 : monoid (denumerable fun_info)) : monoid.fg (denumerable fun_info) := sorry --non-trivial
lemma new_lemma_166734 (h0 : functor.comp comm_ring boolean_algebra.core unsigned) : @local_ring.{0} (boolean_algebra.core.{0} unsigned) (@functor.comp.run.{0 0 0} comm_ring.{0} boolean_algebra.core.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_166735 (h1 : topological_space (id linarith.comp_source)) : totally_separated_space (id linarith.comp_source) := sorry --non-trivial
lemma new_lemma_166736 (h0 : filter (has_neg_part (option name))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_166737 (h0 : functor.add_const (ring (semigroup pos)) (has_neg Type)) : @is_domain.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (semigroup.{0} pos)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_166738 (h0 : complete_lattice (has_dist (option (option empty)))) : is_atomistic (has_dist (option (option empty))) := sorry --non-trivial
lemma new_lemma_166739 (h0 : topological_space (add_cancel_monoid (has_nndist (finset pos)))) : t0_space (add_cancel_monoid (has_nndist (finset pos))) := sorry --non-trivial
lemma new_lemma_166740 (h0 : topological_space (has_zero (semigroup environment.implicit_infer_kind))) : totally_disconnected_space (has_zero (semigroup environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_166741 (h0 : add_group (complete_semilattice_Sup (random_gen linarith.comp_source))) : is_add_cyclic (complete_semilattice_Sup (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_166742 (h0 : uniform_space (comm_semigroup (has_Inf (sub_neg_monoid Type)))) : complete_space (comm_semigroup (has_Inf (sub_neg_monoid Type))) := sorry --non-trivial
lemma new_lemma_166743 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @is_principal_ideal_ring.{0} (has_to_string.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) ring.{0}) (has_to_string.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_166744 (h0 : topological_space (with_one (semiring unsigned))) : totally_separated_space (with_one (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_166745 (h0 : list (pseudo_metric_space name)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_166746 (h0 : topological_space (boolean_algebra (sub_neg_monoid Type))) : loc_path_connected_space (boolean_algebra (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_166747 (h1 : ring (mul_one_class linarith.ineq)) : strong_rank_condition (mul_one_class linarith.ineq) := sorry --non-trivial
lemma new_lemma_166748 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (linear_ordered_cancel_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (linear_ordered_cancel_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_166749 (h1 : group (complete_semilattice_Sup (has_inv (with_bot string_imp)))) : is_cyclic (complete_semilattice_Sup (has_inv (with_bot string_imp))) := sorry --non-trivial
lemma new_lemma_166750 (h0 : functor.add_const (topological_space (has_add name)) pos) : @totally_disconnected_space.{0} (has_add.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_166751 (h0 : topological_space (cancel_monoid name)) : preconnected_space (cancel_monoid name) := sorry --non-trivial
lemma new_lemma_166752 (h0 : group (has_emptyc linarith.comp_source)) : is_cyclic (has_emptyc linarith.comp_source) := sorry --non-trivial
lemma new_lemma_166753 (h0 : functor.add_const (topological_space (add_cancel_monoid linarith.comp)) (has_neg (has_neg Type))) : @totally_disconnected_space.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (add_cancel_monoid.{0} linarith.comp)) (has_neg.{1} (has_neg.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_166754 (h1 : topological_space (measurable_space (random_gen to_additive.value_type))) : locally_compact_space (measurable_space (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_166755 (h0 : complete_lattice (add_right_cancel_monoid congr_arg_kind)) : is_compactly_generated (add_right_cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_166756 (h0 : fin has_zero.zero) (h1 : list Prop) (h2 : ulower (list (list Prop))) : list.ilast' (matrix.vec_empty h0) (list.ilast' h1 (ulower.up h2)) := sorry --non-trivial
lemma new_lemma_166757 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @t0_space.{0} (has_nndist.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (has_nndist.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_166758 (h0 : add_group (linear_ordered_comm_group_with_zero fun_info)) : is_add_cyclic (linear_ordered_comm_group_with_zero fun_info) := sorry --non-trivial
lemma new_lemma_166759 (h0 : ring (normed_comm_ring (option pos))) : rank_condition (normed_comm_ring (option pos)) := sorry --non-trivial
lemma new_lemma_166760 (h0 : mul_zero_class (has_Sup congr_arg_kind) -> Prop) : zzz_forall h0 := sorry --non-trivial
lemma new_lemma_166761 (h0 : function.extfun Type topological_space) : @t1_space.{0} (has_neg.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_166762 (h0 : filter (linear_ordered_add_comm_group (random_gen (random_gen linarith.ineq)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_166763 (h0 : functor.add_const (ring (finset pos)) (finset linarith.comp)) : @strong_rank_condition.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (finset.{0} pos)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_166764 (h0 : topological_space (semiring num)) : locally_compact_space (semiring num) := sorry --non-trivial
lemma new_lemma_166765 (h0 : ordered_comm_monoid (generalized_boolean_algebra (has_neg (has_Inf real)))) : has_exists_mul_of_le (generalized_boolean_algebra (has_neg (has_Inf real))) := sorry --non-trivial
lemma new_lemma_166766 (h0 : uniform_space (has_ssubset (mul_one_class string.iterator_imp))) : complete_space (has_ssubset (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_166767 (h0 : functor.add_const (ring (finset pos)) unsigned) : @is_domain.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (finset.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_166768 (h0 : group (semigroup (has_to_string Type))) : normalizer_condition (semigroup (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_166769 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (partial_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (partial_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_166770 (h0 : ring (mul_zero_class ennreal)) : strong_rank_condition (mul_zero_class ennreal) := sorry --non-trivial
lemma new_lemma_166771 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (with_bot.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_bot.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_166772 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @strong_rank_condition.{0} (has_Inf.{0} linarith.comp) (@matrix.vec_empty.{0} (ring.{0} (has_Inf.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_166773 (h0 : functor.add_const (function.extfun Type topological_space) real) : @sequential_space.{0} (has_bot.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) real h0) (has_bot.{0} name))  := sorry --non-trivial
lemma new_lemma_166774 (h0 : topological_space (left_cancel_semigroup congr_arg_kind)) : irreducible_space (left_cancel_semigroup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_166775 (h0 : functor.add_const (add_monoid (complete_distrib_lattice pos)) environment.implicit_infer_kind) : @add_monoid.fg.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (add_monoid.{0} (complete_distrib_lattice.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_166776 (h0 : functor.add_const (topological_space (has_neg linarith.comp)) environment.implicit_infer_kind) : @preconnected_space.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_166777 (h0 : functor.add_const (semiring (has_zero Type)) linarith.comp) : @is_noetherian_ring.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (semiring.{1} (has_zero.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_166778 (h0 : functor.add_const (topological_space (ring pos)) pos) : @t0_space.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_166779 (h0 : group (has_nnnorm char)) : is_cyclic (has_nnnorm char) := sorry --non-trivial
lemma new_lemma_166780 (h0 : functor.comp filter complete_distrib_lattice Type) : filter.ne_bot (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_166781 (h0 : function.extfun Type ring) : @is_domain.{0} (@id.{2} Type empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (@id.{2} Type empty))  := sorry --non-trivial
lemma new_lemma_166782 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} name (@function.extfun_app.{2 1} Type topological_space.{0} h0 name)  := sorry --non-trivial
lemma new_lemma_166783 (h0 : function.extfun Type topological_space) : @normal_space.{0} (comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_166784 (h0 : group (linear_ordered_field (option (option ennreal)))) : group.fg (linear_ordered_field (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_166785 (h0 : functor.add_const (topological_space (simple_graph Type)) (finset (has_add pos))) : @sequential_space.{1} (simple_graph.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (simple_graph.{1} Type)) (finset.{0} (has_add.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_166786 (h0 : finset (has_nndist (has_add pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_166787 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (group_with_zero.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (group_with_zero.{0} num))  := sorry --non-trivial
lemma new_lemma_166788 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (has_star.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (has_star.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_166789 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_166790 (h0 : topological_space (has_neg_part pos)) : loc_path_connected_space (has_neg_part pos) := sorry --non-trivial
lemma new_lemma_166791 (h0 : topological_space (has_neg (semigroup environment.implicit_infer_kind))) : sequential_space (has_neg (semigroup environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_166792 (h0 : function.extfun (finset Type) (has_mem.mem (with_bot num))) : @complete_lattice.is_Sup_finite_compact.{0} (with_bot.{0} num) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (with_bot.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_bot.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_166793 (h1 : has_lt (has_lt string_imp)) : no_max_order (has_lt string_imp) := sorry --non-trivial
lemma new_lemma_166794 (h0 : functor.add_const (monoid (add_cancel_monoid linarith.comp)) linarith.comp) : @monoid.fg.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (monoid.{0} (add_cancel_monoid.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_166795 (h0 : ring (has_neg_part (has_add (has_add Type)))) : is_principal_ideal_ring (has_neg_part (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_166796 (h0 : not (function.extfun Type group -> false)) : @group.fg.{0} (with_one.{0} empty) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (with_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_166797 (h0 : topological_space (has_pos_part (finset (finset linarith.comp)))) : path_connected_space (has_pos_part (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_166798 (h0 : topological_space (generalized_boolean_algebra (has_Inf (has_Inf pos)))) : preconnected_space (generalized_boolean_algebra (has_Inf (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_166799 (h0 : not (add_group (has_norm linarith.comp) -> false)) : @is_add_cyclic.{0} (has_norm.{0} linarith.comp) (@classical.by_contradiction'.{1} (add_group.{0} (has_norm.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_166800 (h0 : ring (semigroup (finset (finset linarith.comp)))) : is_principal_ideal_ring (semigroup (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_166801 (h0 : functor.add_const (group (left_cancel_monoid empty)) empty) : @normalizer_condition.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (left_cancel_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_166802 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (has_to_string.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_to_string.{0} num))  := sorry --non-trivial
lemma new_lemma_166803 (h0 : functor.add_const (group (finset Type)) (has_to_string (has_to_string Type))) : @is_simple_group.{1} (finset.{1} Type) (@functor.add_const.run.{1 1} (group.{1} (finset.{1} Type)) (has_to_string.{1} (has_to_string.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_166804 (h0 : function.extfun Type (functor.add_const (topological_space (ring pos)))) : @locally_compact_space.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} pos)) pos (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (ring.{0} pos))) h0 pos))  := sorry --non-trivial
lemma new_lemma_166805 (h0 : functor.add_const (topological_space (cancel_monoid Type)) Type) : @regular_space.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (cancel_monoid.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_166806 (h0 : group (semiring (random_gen (has_norm (has_top fun_info))))) : is_cyclic (semiring (random_gen (has_norm (has_top fun_info)))) := sorry --non-trivial
lemma new_lemma_166807 (h0 : finset (add_comm_monoid (finset (finset (finset linarith.comp))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_166808 (h0 : functor.add_const (complete_lattice (add_cancel_monoid Type)) pos) : @complete_lattice.is_Sup_finite_compact.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (add_cancel_monoid.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_166809 (h0 : filter auto.case_option) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_166810 (h1 : ring (distrib (has_ssubset linarith.comp_source))) : rank_condition (distrib (has_ssubset linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_166811 (h0 : topological_space (add_semigroup unsigned)) : locally_compact_space (add_semigroup unsigned) := sorry --non-trivial
lemma new_lemma_166812 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (measurable_space.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (measurable_space.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_166813 (h0 : group (finset (ring linarith.comp))) : is_simple_group (finset (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_166814 (h0 : topological_space (has_to_string (finset linarith.comp))) : totally_disconnected_space (has_to_string (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_166815 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem ring)) : @rank_condition.{0} (has_norm.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) ring.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_norm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_166816 (h0 : ring (cancel_monoid (has_add name))) : strong_rank_condition (cancel_monoid (has_add name)) := sorry --non-trivial
lemma new_lemma_166817 (h0 : ring (has_Inf (has_neg Type))) : is_domain (has_Inf (has_neg Type)) := sorry --non-trivial
lemma new_lemma_166818 (h0 : functor.add_const (complete_lattice (has_to_string Type)) (complete_distrib_lattice Type)) : @is_compactly_generated.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 1} (complete_lattice.{1} (has_to_string.{1} Type)) (complete_distrib_lattice.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_166819 (h0 : filter (finset (has_neg (finset (finset (finset (has_Inf linarith.comp))))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_166820 (h0 : ring (add_left_cancel_monoid (has_nnnorm (has_nnnorm (has_nnnorm to_additive.value_type))))) : is_domain (add_left_cancel_monoid (has_nnnorm (has_nnnorm (has_nnnorm to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_166821 (h0 : functor.add_const (add_monoid (boolean_algebra linarith.comp)) linarith.comp) : @add_monoid.fg.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_monoid.{0} (boolean_algebra.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_166822 (h0 : uniform_space (boolean_algebra (finset (has_zero pos)))) : separated_space (boolean_algebra (finset (has_zero pos))) := sorry --non-trivial
lemma new_lemma_166823 (h0 : functor.add_const (ring (boolean_algebra name)) (has_neg pos)) : @strong_rank_condition.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.{0} name)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_166824 (h0 : group (normed_comm_ring unsigned)) : group.fg (normed_comm_ring unsigned) := sorry --non-trivial
lemma new_lemma_166825 (h0 : functor.add_const (topological_space (ordered_comm_ring Type)) pos) : @sequential_space.{1} (ordered_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ordered_comm_ring.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_166826 (h0 : functor.add_const (topological_space (semigroup name)) linarith.comp) : @discrete_topology.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_166827 (h0 : topological_space (random_gen (has_norm (has_top linarith.comp)))) : t0_space (random_gen (has_norm (has_top linarith.comp))) := sorry --non-trivial
lemma new_lemma_166828 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (has_neg ennreal)) := sorry --non-trivial
lemma new_lemma_166829 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @rank_condition.{0} (measurable_space.{0} linarith.ineq) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) ring.{0}) (measurable_space.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_166830 (h0 : monoid (normed_comm_ring num)) : monoid.fg (normed_comm_ring num) := sorry --non-trivial
lemma new_lemma_166831 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (group_with_zero.{0} empty) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (group_with_zero.{0} empty))  := sorry --non-trivial
lemma new_lemma_166832 (h0 : functor.add_const (function.extfun (Type 1) topological_space) linarith.comp) : @preconnected_space.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) linarith.comp h0) (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_166833 (h0 : not (group (left_cancel_semigroup empty) -> false)) : @normalizer_condition.{0} (left_cancel_semigroup.{0} empty) (@classical.by_contradiction'.{1} (group.{0} (left_cancel_semigroup.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_166834 (h0 : functor.add_const (add_group (has_zero environment.implicit_infer_kind)) name) : @is_add_cyclic.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (add_group.{0} (has_zero.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_166835 (h0 : topological_space (has_Inf (ordered_comm_ring Type))) : loc_path_connected_space (has_Inf (ordered_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_166836 (h0 : function.extfun Type topological_space) : @t1_space.{0} (free_add_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (free_add_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_166837 (h0 : function.extfun Type ring) : @rank_condition.{0} (ring.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_166838 (h0 : topological_space (has_one (has_top unsigned))) : discrete_topology (has_one (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_166839 (h0 : add_monoid (comm_monoid congr_arg_kind)) : add_monoid.fg (comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_166840 (h3 : ring (random_gen to_additive.value_type)) : rank_condition (random_gen to_additive.value_type) := sorry --non-trivial
lemma new_lemma_166841 (h0 : complete_lattice (has_pos_part (finset (has_pos_part pos)))) : complete_lattice.is_Sup_finite_compact (has_pos_part (finset (has_pos_part pos))) := sorry --non-trivial
lemma new_lemma_166842 (h0 : complete_lattice (distrib (comm_ring (comm_ring (comm_ring (comm_ring reducibility_hints)))))) : is_compactly_generated (distrib (comm_ring (comm_ring (comm_ring (comm_ring reducibility_hints))))) := sorry --non-trivial
lemma new_lemma_166843 (h0 : functor.add_const (topological_space (ring Type)) linarith.comp) : @t1_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ring.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_166844 (h0 : ordered_add_comm_monoid (sub_neg_monoid linarith.comp)) : archimedean (sub_neg_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_166845 (h0 : topological_space (left_cancel_monoid (semiring num))) : discrete_topology (left_cancel_monoid (semiring num)) := sorry --non-trivial
lemma new_lemma_166846 (h0 : topological_space (has_pos_part (has_neg (sub_neg_monoid pos)))) : totally_separated_space (has_pos_part (has_neg (sub_neg_monoid pos))) := sorry --non-trivial
lemma new_lemma_166847 (h0 : functor.add_const (list (has_Inf Type)) pos) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_166848 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_166849 (h0 : topological_space (generalized_boolean_algebra (has_neg (has_neg name)))) : loc_path_connected_space (generalized_boolean_algebra (has_neg (has_neg name))) := sorry --non-trivial
lemma new_lemma_166850 (h0 : functor.add_const (uniform_space (free_add_monoid empty)) num) : @complete_space.{0} (free_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (free_add_monoid.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_166851 (h0 : add_group (comm_group (has_add Type))) : is_add_cyclic (comm_group (has_add Type)) := sorry --non-trivial
lemma new_lemma_166852 (h0 : topological_space (has_neg (comm_group unsigned))) : totally_separated_space (has_neg (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_166853 (h0 : topological_space (semigroup (boolean_algebra.core name))) : t1_space (semigroup (boolean_algebra.core name)) := sorry --non-trivial
lemma new_lemma_166854 (h0 : function.extfun (finset Type) (has_mem.mem (random_gen linarith.comp_source))) : @is_atomistic.{0} (random_gen.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (random_gen.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} linarith.comp_source)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_166855 (h0 : uniform_space (id (has_norm num))) : separated_space (id (has_norm num)) := sorry --non-trivial
lemma new_lemma_166856 (h0 : topological_space (ring (option unsigned))) : t0_space (ring (option unsigned)) := sorry --non-trivial
lemma new_lemma_166857 (h0 : functor.add_const (filter (monoid congr_arg_kind)) congr_arg_kind) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_166858 (h0 : not (ring (has_emptyc num) -> false)) : @is_domain.{0} (has_emptyc.{0} num) (@classical.by_contradiction'.{1} (ring.{0} (has_emptyc.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_166859 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_166860 (h0 : topological_space (denumerable congr_arg_kind)) : path_connected_space (denumerable congr_arg_kind) := sorry --non-trivial
lemma new_lemma_166861 (h1 : fintype char) (h2 : decidable_eq char) (h3 : equiv.perm char) : equiv.perm.is_three_cycle h3 := sorry --non-trivial
lemma new_lemma_166862 (h0 : topological_space (linear_ordered_field name)) : t1_space (linear_ordered_field name) := sorry --non-trivial
lemma new_lemma_166863 (h0 : functor.add_const (ring (ordered_comm_ring pos)) pos) : @is_domain.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (ordered_comm_ring.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_166864 (h1 : ring (div_inv_monoid char)) : rank_condition (div_inv_monoid char) := sorry --non-trivial
lemma new_lemma_166865 (h0 : ring (with_bot (semiring congr_arg_kind))) : is_principal_ideal_ring (with_bot (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_166866 (h0 : topological_space (ordered_comm_monoid (has_add pos))) : irreducible_space (ordered_comm_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_166867 (h0 : topological_space (plift unsigned)) : t1_space (plift unsigned) := sorry --non-trivial
lemma new_lemma_166868 (h0 : filter (has_neg unsigned) -> filter (has_neg unsigned) -> Prop) : is_symm (filter (has_neg unsigned)) h0 := sorry --non-trivial
lemma new_lemma_166869 (h0 : functor.add_const (function.extfun Type ring) pos) : @is_principal_ideal_ring.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) pos h0) (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_166870 (h0 : topological_space (has_nndist environment.implicit_infer_kind)) : loc_path_connected_space (has_nndist environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_166871 (h0 : not (topological_space (normed_group congr_arg_kind) -> false)) : @discrete_topology.{0} (normed_group.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_group.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_166872 (h0 : add_monoid (id (semiring (semiring (semiring (has_top unsigned)))))) : add_monoid.fg (id (semiring (semiring (semiring (has_top unsigned))))) := sorry --non-trivial
lemma new_lemma_166873 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (canonically_linear_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (canonically_linear_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_166874 (h0 : ring (has_edist string_imp)) : strong_rank_condition (has_edist string_imp) := sorry --non-trivial
lemma new_lemma_166875 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @normalizer_condition.{1} (cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 group.{1}) (cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_166876 (h0 : topological_space (monoid_with_zero (option (option pos)))) : preirreducible_space (monoid_with_zero (option (option pos))) := sorry --non-trivial
lemma new_lemma_166877 (h0 : topological_space (finset (has_neg (has_neg (has_neg pos))))) : t0_space (finset (has_neg (has_neg (has_neg pos)))) := sorry --non-trivial
lemma new_lemma_166878 (h0 : functor.add_const (topological_space (has_zero Type)) pos) : @topological_space.separable_space.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_zero.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_166879 (h0 : topological_space (with_one (complete_semilattice_Sup empty))) : totally_disconnected_space (with_one (complete_semilattice_Sup empty)) := sorry --non-trivial
lemma new_lemma_166880 (h0 : topological_space (distrib_lattice to_additive.value_type)) : totally_disconnected_space (distrib_lattice to_additive.value_type) := sorry --non-trivial
lemma new_lemma_166881 (h0 : set (char -> linarith.ineq)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_166882 (h0 : topological_space (mul_one_class (mul_one_class string.iterator_imp))) : path_connected_space (mul_one_class (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_166883 (h0 : complete_lattice (uniform_space string_imp)) : is_compactly_generated (uniform_space string_imp) := sorry --non-trivial
lemma new_lemma_166884 (h2 : has_mem.mem (with_one num) has_emptyc.emptyc) : @path_connected_space.{0} (with_one.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_one.{0} num) h2)  := sorry --non-trivial
lemma new_lemma_166885 (h0 : functor.add_const (ring (add_cancel_monoid environment.implicit_infer_kind)) linarith.comp) : @is_domain.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_166886 (h0 : ring (has_ssubset (function.End string_imp))) : is_domain (has_ssubset (function.End string_imp)) := sorry --non-trivial
lemma new_lemma_166887 (h0 : functor.add_const (topological_space (has_add linarith.comp)) environment.implicit_infer_kind) : @regular_space.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_166888 (h0 : functor.add_const (ordered_comm_monoid (cancel_monoid pos)) Type) : @has_exists_mul_of_le.{0} (cancel_monoid.{0} pos) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (cancel_monoid.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_166889 (h0 : functor.add_const (uniform_space (semigroup linarith.comp)) (has_neg linarith.comp)) : @complete_space.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (semigroup.{0} linarith.comp)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_166890 (h0 : function.extfun Type group) : @is_cyclic.{0} (left_cancel_monoid.{0} (semiring.{0} (semiring.{0} empty))) (@function.extfun_app.{2 1} Type group.{0} h0 (left_cancel_monoid.{0} (semiring.{0} (semiring.{0} empty))))  := sorry --non-trivial
lemma new_lemma_166891 (h0 : group (has_bot Type)) : normalizer_condition (has_bot Type) := sorry --non-trivial
lemma new_lemma_166892 (h0 : topological_space (ring (has_neg (has_neg Type)))) : regular_space (ring (has_neg (has_neg Type))) := sorry --non-trivial
lemma new_lemma_166893 (h0 : group (comm_ring (mul_one_class to_additive.value_type))) : is_cyclic (comm_ring (mul_one_class to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_166894 (h0 : function.extfun Type ring) : @rank_condition.{0} (with_bot.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} h0 (with_bot.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_166895 (h0 : function.extfun Type (functor.add_const (complete_lattice (has_star num)))) : @is_atomistic.{0} (has_star.{0} num) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_star.{0} num)) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (complete_lattice.{0} (has_star.{0} num))) h0 num))  := sorry --non-trivial
lemma new_lemma_166896 (h0 : simple_graph (has_compl fun_info)) (h1 : not (has_compl fun_info -> false)) (h2 : sym2 (has_compl fun_info)) : simple_graph.incidence_set h0 (classical.by_contradiction' h1) h2 := sorry --non-trivial
lemma new_lemma_166897 (h0 : topological_space (simple_graph name)) : normal_space (simple_graph name) := sorry --non-trivial
lemma new_lemma_166898 (h1 : add_group (has_inv fun_info)) : is_add_cyclic (has_inv fun_info) := sorry --non-trivial
lemma new_lemma_166899 (h1 : add_group (has_inv to_additive.value_type)) : is_add_cyclic (has_inv to_additive.value_type) := sorry --non-trivial
lemma new_lemma_166900 (h0 : topological_space (simple_graph pos)) : totally_disconnected_space (simple_graph pos) := sorry --non-trivial
lemma new_lemma_166901 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (linear_ordered_cancel_comm_monoid.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type add_group.{0} h0 (linear_ordered_cancel_comm_monoid.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_166902 (h0 : functor.add_const (topological_space (has_to_string name)) unsigned) : @preconnected_space.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_166903 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_Sup.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_Sup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_166904 (h0 : functor.add_const (ring (has_neg unsigned)) name) : @is_principal_ideal_ring.{0} (has_neg.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (has_neg.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_166905 (h1 : topological_space (dlist linarith.comp_source)) : totally_disconnected_space (dlist linarith.comp_source) := sorry --non-trivial
lemma new_lemma_166906 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (ordered_cancel_add_comm_monoid.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_cancel_add_comm_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_166907 (h1 : complete_lattice (semi_normed_ring linarith.comp_source)) : complete_lattice.is_Sup_finite_compact (semi_normed_ring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_166908 (h0 h1 : multiset (has_le (mul_one_class linarith.comp_source))) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_166909 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (add_right_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_right_cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_166910 (h0 : function.extfun (finset Type) (has_mem.mem (linear_ordered_semiring linarith.comp))) : @normal_space.{0} (linear_ordered_semiring.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (linear_ordered_semiring.{0} linarith.comp) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (linear_ordered_semiring.{0} linarith.comp)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_166911 (h2 : function.extfun Type topological_space) : @t0_space.{0} (has_emptyc.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h2 (has_emptyc.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_166912 (h0 : functor.add_const (function.extfun Type topological_space) environment.implicit_infer_kind) : @preconnected_space.{0} (has_zero.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) environment.implicit_infer_kind h0) (has_zero.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_166913 (h0 : complete_lattice (with_one linarith.comp)) : is_compactly_generated (with_one linarith.comp) := sorry --non-trivial
lemma new_lemma_166914 (h0 : finset (has_to_string (finset (has_pos_part Type)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_166915 (h0 : ordered_comm_monoid (canonically_ordered_monoid (has_Inf (ordered_comm_monoid linarith.comp)))) : has_exists_mul_of_le (canonically_ordered_monoid (has_Inf (ordered_comm_monoid linarith.comp))) := sorry --non-trivial
lemma new_lemma_166916 (h0 : topological_space (add_cancel_monoid (finset pos))) : totally_disconnected_space (add_cancel_monoid (finset pos)) := sorry --non-trivial
lemma new_lemma_166917 (h5 : measurable_space (has_lt string.iterator_imp)) (h6 : filter (has_lt string.iterator_imp)) : filter.is_measurably_generated h6 := sorry --non-trivial
lemma new_lemma_166918 (h0 : not (ring (has_top num) -> false)) : @rank_condition.{0} (has_top.{0} num) (@classical.by_contradiction'.{1} (ring.{0} (has_top.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_166919 (h0 : functor.add_const (functor.add_const (topological_space linarith.comp) name) linarith.comp) : @irreducible_space.{0} linarith.comp (@functor.add_const.run.{0 0} (topological_space.{0} linarith.comp) name (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (topological_space.{0} linarith.comp) name) linarith.comp h0))  := sorry --non-trivial
lemma new_lemma_166920 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (has_edist.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_edist.{0} empty))  := sorry --non-trivial
lemma new_lemma_166921 (h0 : topological_space (has_nndist congr_arg_kind)) : locally_compact_space (has_nndist congr_arg_kind) := sorry --non-trivial
lemma new_lemma_166922 (h0 : function.extfun (Type 1) topological_space) : @normal_space.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_166923 (h0 : topological_space (distrib (has_nnnorm (has_nnnorm (has_inv linarith.ineq))))) : totally_disconnected_space (distrib (has_nnnorm (has_nnnorm (has_inv linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_166924 (h0 : group (complete_semilattice_Sup (random_gen (random_gen string_imp)))) : is_cyclic (complete_semilattice_Sup (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_166925 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} (has_neg.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) (has_neg.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_166926 (h0 : ring (distrib (has_lt reducibility_hints))) : strong_rank_condition (distrib (has_lt reducibility_hints)) := sorry --non-trivial
lemma new_lemma_166927 (h0 : topological_space (has_neg_part environment.implicit_infer_kind)) : t1_space (has_neg_part environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_166928 (h0 : function.extfun Type add_monoid) (h1 : function.extfun Type has_one) : @char_zero.{0} fun_info (@function.extfun_app.{2 1} Type add_monoid.{0} h0 fun_info) (@function.extfun_app.{2 1} Type has_one.{0} h1 fun_info)  := sorry --non-trivial
lemma new_lemma_166929 (h0 : topological_space (sub_neg_monoid pos)) : sequential_space (sub_neg_monoid pos) := sorry --non-trivial
lemma new_lemma_166930 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_166931 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_166932 (h0 : not (monoid (add_group linarith.comp) -> false)) : @monoid.fg.{0} (add_group.{0} linarith.comp) (@classical.by_contradiction'.{1} (monoid.{0} (add_group.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_166933 (h0 : topological_space (topological_space string_imp)) : totally_disconnected_space (topological_space string_imp) := sorry --non-trivial
lemma new_lemma_166934 (h0 : list (normed_comm_ring (has_add pos))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_166935 (h0 : ring (finset (has_pos_part (finset pos)))) : rank_condition (finset (has_pos_part (finset pos))) := sorry --non-trivial
lemma new_lemma_166936 (h0 : functor.add_const (ring (bin_tree num)) unsigned) : @rank_condition.{0} (bin_tree.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (bin_tree.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_166937 (h0 : topological_space (normed_lattice_add_comm_group (has_bot real))) : preconnected_space (normed_lattice_add_comm_group (has_bot real)) := sorry --non-trivial
lemma new_lemma_166938 (h0 : topological_space (canonically_ordered_monoid (has_pos_part linarith.comp))) : preconnected_space (canonically_ordered_monoid (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_166939 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_166940 (h0 : topological_space (with_bot (has_norm congr_arg_kind))) : irreducible_space (with_bot (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_166941 (h0 : topological_space (has_top (semiring unsigned))) : totally_separated_space (has_top (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_166942 (h0 : ring string.iterator_imp) : is_domain string.iterator_imp := sorry --non-trivial
lemma new_lemma_166943 (h0 : functor.comp topological_space cancel_monoid linarith.comp) : @locally_compact_space.{0} (cancel_monoid.{0} linarith.comp) (@functor.comp.run.{0 0 0} topological_space.{0} cancel_monoid.{0} linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_166944 (h0 : uniform_space (has_top (semiring (semiring num)))) : separated_space (has_top (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_166945 (h0 : functor.add_const (topological_space (has_add name)) linarith.comp) : @loc_path_connected_space.{0} (has_add.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_166946 (h1 : topological_space (mul_one_class (add_comm_semigroup (add_comm_semigroup string.iterator_imp)))) (h2 : preorder (mul_one_class (add_comm_semigroup (add_comm_semigroup string.iterator_imp)))) : order_closed_topology (mul_one_class (add_comm_semigroup (add_comm_semigroup string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_166947 (h0 : ring (complete_distrib_lattice (option unsigned))) : rank_condition (complete_distrib_lattice (option unsigned)) := sorry --non-trivial
lemma new_lemma_166948 (h0 : list (ring (boolean_algebra (finset Type)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_166949 (h0 : functor.add_const (topological_space (add_group empty)) empty) : @t0_space.{0} (add_group.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_group.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_166950 (h0 : topological_space (has_neg_part Type)) : discrete_topology (has_neg_part Type) := sorry --non-trivial
lemma new_lemma_166951 (h0 : functor.add_const (topological_space (linear_ordered_comm_monoid_with_zero empty)) empty) : @discrete_topology.{0} (linear_ordered_comm_monoid_with_zero.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_comm_monoid_with_zero.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_166952 (h0 : ordered_comm_monoid (semigroup (add_cancel_monoid name))) : has_exists_mul_of_le (semigroup (add_cancel_monoid name)) := sorry --non-trivial
lemma new_lemma_166953 (h0 : has_ssubset (has_top fun_info) -> has_ssubset (has_top fun_info) -> bool) : is_dec_refl h0 := sorry --non-trivial
lemma new_lemma_166954 (h0 : functor.add_const (group (has_star num)) empty) : @group.fg.{0} (has_star.{0} num) (@functor.add_const.run.{0 0} (group.{0} (has_star.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_166955 (h0 : uniform_space (has_pos_part (ring linarith.comp))) : complete_space (has_pos_part (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_166956 (h0 : topological_space (linear_ordered_comm_group_with_zero std_gen)) : path_connected_space (linear_ordered_comm_group_with_zero std_gen) := sorry --non-trivial
lemma new_lemma_166957 (h0 : ring (normed_comm_ring (option unsigned))) : rank_condition (normed_comm_ring (option unsigned)) := sorry --non-trivial
lemma new_lemma_166958 (h0 : cancel_comm_monoid_with_zero (is_R_or_C unsigned)) : unique_factorization_monoid (is_R_or_C unsigned) := sorry --non-trivial
lemma new_lemma_166959 (h0 : functor.comp topological_space add_cancel_monoid pos) : @t1_space.{0} (add_cancel_monoid.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} add_cancel_monoid.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_166960 (h0 : functor.add_const (ring (has_neg_part name)) unsigned) : @rank_condition.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (has_neg_part.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_166961 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @totally_disconnected_space.{1} (has_zero.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (has_zero.{1} Type))  := sorry --non-trivial
lemma new_lemma_166962 (h0 : function.extfun Type topological_space) : @normal_space.{0} (add_cancel_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_166963 (h0 : group (plift (plift num))) : is_simple_group (plift (plift num)) := sorry --non-trivial
lemma new_lemma_166964 (h0 : finset (boolean_algebra (has_pos_part (has_neg (boolean_algebra (has_Inf linarith.comp)))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_166965 (h0 : functor.add_const (ring (has_Sup unsigned)) (semiring unsigned)) : @is_domain.{0} (has_Sup.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (has_Sup.{0} unsigned)) (semiring.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_166966 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (boolean_algebra unsigned)) := sorry --non-trivial
lemma new_lemma_166967 (h0 : functor.add_const (function.extfun Type group) Type) : @normalizer_condition.{0} (add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type group.{0}) Type h0) (add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_166968 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (add_cancel_monoid.{0} (option.{0} unsigned)) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (add_cancel_monoid.{0} (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_166969 (h0 : functor.add_const (topological_space (normed_comm_ring linarith.comp)) Type) : @loc_path_connected_space.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (normed_comm_ring.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_166970 (h0 : functor.add_const (add_monoid (non_assoc_semiring unsigned)) empty) : @add_monoid.fg.{0} (non_assoc_semiring.{0} unsigned) (@functor.add_const.run.{0 0} (add_monoid.{0} (non_assoc_semiring.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_166971 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_nndist.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} name))  := sorry --non-trivial
lemma new_lemma_166972 (h0 : group (has_pos_part (has_add (ring (ordered_ring Type))))) : is_cyclic (has_pos_part (has_add (ring (ordered_ring Type)))) := sorry --non-trivial
lemma new_lemma_166973 (h0 : measurable_space (measurable_space num)) (h1 : has_sup (measurable_space num)) : has_measurable_sup (measurable_space num) := sorry --non-trivial
lemma new_lemma_166974 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_166975 (h0 : topological_space (normed_comm_ring congr_arg_kind)) : locally_compact_space (normed_comm_ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_166976 (h1 : uniform_space (has_inv to_additive.value_type)) : complete_space (has_inv to_additive.value_type) := sorry --non-trivial
lemma new_lemma_166977 (h0 : topological_space (has_add (has_neg (ring linarith.comp)))) : regular_space (has_add (has_neg (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_166978 (h1 : complete_lattice (random_gen (with_bot string_imp))) : is_atomistic (random_gen (with_bot string_imp)) := sorry --non-trivial
lemma new_lemma_166979 (h0 : list (canonically_ordered_comm_semiring (finset ennreal))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_166980 (h0 : functor.add_const (monoid (has_add pos)) Type) : @monoid.fg.{0} (has_add.{0} pos) (@functor.add_const.run.{0 1} (monoid.{0} (has_add.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_166981 (h0 : has_add (has_add Type) -> name -> name) : left_commutative h0 := sorry --non-trivial
lemma new_lemma_166982 (h0 : function.extfun (Type 1) (functor.comp topological_space canonically_ordered_comm_semiring)) : @path_connected_space.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} canonically_ordered_comm_semiring.{1} Type (@function.extfun_app.{3 2} (Type 1) (functor.comp.{1 1 1} topological_space.{1} canonically_ordered_comm_semiring.{1}) h0 Type))  := sorry --non-trivial
lemma new_lemma_166983 (h0 : function.extfun Type topological_space) (h1 : set (has_pos_part linarith.comp)) : @is_totally_separated.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_pos_part.{0} linarith.comp)) h1  := sorry --non-trivial
lemma new_lemma_166984 (h0 : functor.comp topological_space has_to_string ennreal) : @t0_space.{0} (has_to_string.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} has_to_string.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_166985 (h0 : functor.add_const (topological_space (mul_zero_class unsigned)) congr_arg_kind) : @t0_space.{0} (mul_zero_class.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_166986 (h2 : topological_space (add_comm_semigroup fun_info)) : t0_space (add_comm_semigroup fun_info) := sorry --non-trivial
lemma new_lemma_166987 (h0 : not (complete_lattice (measurable_space congr_arg_kind) -> false)) : complete_lattice.is_Sup_finite_compact (measurable_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_166988 (h0 : group (with_bot linarith.comp_source)) : normalizer_condition (with_bot linarith.comp_source) := sorry --non-trivial
lemma new_lemma_166989 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (has_norm.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (has_norm.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_166990 (h0 : topological_space (has_zero (has_to_string pos))) : path_connected_space (has_zero (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_166991 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_edist.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (has_edist.{0} num))  := sorry --non-trivial
lemma new_lemma_166992 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_166993 (h0 : functor.add_const (uniform_space (has_Inf linarith.comp)) linarith.comp) : @separated_space.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_Inf.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_166994 (h0 : ring (has_neg (comm_group Type))) : strong_rank_condition (has_neg (comm_group Type)) := sorry --non-trivial
lemma new_lemma_166995 (h0 : fin has_zero.zero) : @complete_lattice.is_Sup_finite_compact.{0} (sub_neg_monoid.{0} real) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (sub_neg_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_166996 (h0 : fin has_zero.zero) : @t1_space.{0} (comm_semigroup.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (comm_semigroup.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_166997 (h0 : uniform_space (ordered_comm_monoid (has_Inf (has_Inf (boolean_algebra.core linarith.comp))))) : separated_space (ordered_comm_monoid (has_Inf (has_Inf (boolean_algebra.core linarith.comp)))) := sorry --non-trivial
lemma new_lemma_166998 (h0 : functor.add_const (functor.add_const (ordered_comm_monoid pos) name) (finset pos)) : @has_exists_mul_of_le.{0} pos (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} pos) name (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (ordered_comm_monoid.{0} pos) name) (finset.{0} pos) h0))  := sorry --non-trivial
lemma new_lemma_166999 (h0 : group (has_one (semiring empty))) : group.fg (has_one (semiring empty)) := sorry --non-trivial
lemma new_lemma_167000 (h0 : ring (ring (has_neg_part Type))) : rank_condition (ring (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_167001 (h0 : group (with_one (random_gen linarith.ineq))) : is_cyclic (with_one (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_167002 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (normed_group.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (normed_group.{0} num))  := sorry --non-trivial
lemma new_lemma_167003 (h0 : complete_lattice (has_emptyc (has_emptyc linarith.comp))) : is_atomistic (has_emptyc (has_emptyc linarith.comp)) := sorry --non-trivial
lemma new_lemma_167004 (h0 : not (prod (linear_ordered_semiring empty) (linear_ordered_semiring empty) -> false)) : id_rel (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_167005 (h0 : complete_lattice (with_one congr_arg_kind)) : is_atomistic (with_one congr_arg_kind) := sorry --non-trivial
lemma new_lemma_167006 (h0 : group (linear_ordered_field (has_zero (has_zero ennreal)))) : is_cyclic (linear_ordered_field (has_zero (has_zero ennreal))) := sorry --non-trivial
lemma new_lemma_167007 (h0 : topological_space (random_gen (has_nnnorm (has_nnnorm char)))) : totally_disconnected_space (random_gen (has_nnnorm (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_167008 (h0 : topological_space (has_zero (has_nndist (has_to_string ennreal)))) : t0_space (has_zero (has_nndist (has_to_string ennreal))) := sorry --non-trivial
lemma new_lemma_167009 (h0 : functor.add_const (group (semigroup linarith.comp)) linarith.comp) : @normalizer_condition.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (semigroup.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_167010 (h1 : group num) : is_cyclic num := sorry --non-trivial
lemma new_lemma_167011 (h0 : not (list (measure_theory.measure_space unsigned) -> false)) : list.nodup (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_167012 (h0 : not (topological_space (has_ssubset string_imp) -> false)) : @path_connected_space.{0} (has_ssubset.{0} string_imp) (@classical.by_contradiction'.{1} (topological_space.{0} (has_ssubset.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_167013 (h0 : not (add_group (with_one num) -> false)) : @is_add_cyclic.{0} (with_one.{0} num) (@classical.by_contradiction'.{1} (add_group.{0} (with_one.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_167014 (h0 : functor.add_const (semiring (boolean_algebra linarith.comp)) name) : @is_noetherian_ring.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (semiring.{0} (boolean_algebra.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_167015 (h0 : ordered_add_comm_monoid (ordered_comm_ring (ring Type))) : archimedean (ordered_comm_ring (ring Type)) := sorry --non-trivial
lemma new_lemma_167016 (h0 : functor.add_const (topological_space (has_Inf pos)) linarith.comp) : @preconnected_space.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_167017 (h0 : functor.add_const (topological_space auto.case_option) empty) : @preirreducible_space.{0} auto.case_option (@functor.add_const.run.{0 0} (topological_space.{0} auto.case_option) empty h0)  := sorry --non-trivial
lemma new_lemma_167018 (h0 : functor.add_const (topological_space (comm_group Type)) linarith.comp) : @normal_space.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (comm_group.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_167019 (h0 : topological_space (semiring (has_norm linarith.comp_source))) : totally_separated_space (semiring (has_norm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_167020 (h0 : not (topological_space (with_one congr_arg_kind) -> false)) : @irreducible_space.{0} (with_one.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (with_one.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_167021 (h0 : topological_space (complete_distrib_lattice (has_pos_part Type))) : t1_space (complete_distrib_lattice (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_167022 (h0 : not (filter (with_one linarith.comp) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_167023 (h0 : ring (mul_zero_class (semigroup unsigned))) : is_principal_ideal_ring (mul_zero_class (semigroup unsigned)) := sorry --non-trivial
lemma new_lemma_167024 (h0 : list (has_nndist (option (simple_graph num)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_167025 (h0 : ordered_add_comm_monoid (normed_comm_ring num)) : archimedean (normed_comm_ring num) := sorry --non-trivial
lemma new_lemma_167026 (h0 : functor.add_const (filter (add_cancel_monoid Type)) (add_comm_monoid pos)) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_167027 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (boolean_algebra.core.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (boolean_algebra.core.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_167028 (h0 : ordered_comm_monoid (canonically_linear_ordered_monoid (has_add pos))) : has_exists_mul_of_le (canonically_linear_ordered_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_167029 (h0 : group (linear_ordered_add_comm_group (with_bot linarith.comp_source))) : normalizer_condition (linear_ordered_add_comm_group (with_bot linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_167030 (h0 : not (finset (has_star num) -> false)) : finset.nonempty (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_167031 (h0 : functor.add_const (topological_space (has_pos_part real)) real) : @t0_space.{0} (has_pos_part.{0} real) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} real)) real h0)  := sorry --non-trivial
lemma new_lemma_167032 (h0 : not (function.extfun (Type 1) topological_space -> false)) : @discrete_topology.{1} (plift.{1} empty) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@classical.by_contradiction'.{3} (function.extfun.{3 2} (Type 1) topological_space.{1}) h0) (plift.{1} empty))  := sorry --non-trivial
lemma new_lemma_167033 (h0 : functor.add_const (topological_space (add_cancel_monoid pos)) environment.implicit_infer_kind) : @normal_space.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_167034 (h0 : group (canonically_ordered_comm_semiring (has_Inf linarith.comp))) : normalizer_condition (canonically_ordered_comm_semiring (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_167035 (h0 : function.extfun Type ring) : @is_domain.{0} (linear_ordered_field.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_ordered_field.{0} pos))  := sorry --non-trivial
lemma new_lemma_167036 (h0 : functor.comp ordered_comm_monoid option pos) : @has_exists_mul_of_le.{0} (option.{0} pos) (@functor.comp.run.{0 0 0} ordered_comm_monoid.{0} option.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_167037 (h0 : functor.add_const (topological_space (canonically_ordered_add_monoid empty)) (option empty)) : @irreducible_space.{0} (canonically_ordered_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_add_monoid.{0} empty)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_167038 (h0 : uniform_space (boolean_algebra (ring (has_add name)))) : complete_space (boolean_algebra (ring (has_add name))) := sorry --non-trivial
lemma new_lemma_167039 (h0 : functor.add_const (function.extfun Type list) (boolean_algebra.core pos)) : list.nodup (function.extfun_app (functor.add_const.run h0) (semigroup pos)) := sorry --non-trivial
lemma new_lemma_167040 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (add_cancel_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (add_cancel_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_167041 (h0 : has_mem.mem (semiring fun_info) has_emptyc.emptyc) : @strong_rank_condition.{0} (semiring.{0} fun_info) (@finset.pi.empty.{1 0} Type ring.{0} (semiring.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_167042 (h0 : functor.add_const (list (bin_tree empty)) (semiring (semiring (semiring (semiring empty))))) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_167043 (h0 : functor.add_const (topological_space (boolean_algebra.core Type)) name) : @regular_space.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.core.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_167044 (h0 : ring (mul_zero_class (finset pos))) : rank_condition (mul_zero_class (finset pos)) := sorry --non-trivial
lemma new_lemma_167045 (h0 : topological_space (add_cancel_monoid (comm_group pos))) : irreducible_space (add_cancel_monoid (comm_group pos)) := sorry --non-trivial
lemma new_lemma_167046 (h0 : functor.add_const (filter (complete_distrib_lattice pos)) pos) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_167047 (h0 : add_group (canonically_linear_ordered_monoid (has_to_string (has_add unsigned)))) : is_add_cyclic (canonically_linear_ordered_monoid (has_to_string (has_add unsigned))) := sorry --non-trivial
lemma new_lemma_167048 (h1 : list Prop) : list.ilast h1 := sorry --non-trivial
lemma new_lemma_167049 (h0 : not (monoid (with_bot empty) -> false)) : @monoid.fg.{0} (with_bot.{0} empty) (@classical.by_contradiction'.{1} (monoid.{0} (with_bot.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_167050 (h0 : measurable_space (nondiscrete_normed_field std_gen)) (h1 : measure_theory.measure (nondiscrete_normed_field std_gen)) : measure_theory.measure.is_complete h1 := sorry --non-trivial
lemma new_lemma_167051 (h0 : functor.add_const (topological_space (has_Sup congr_arg_kind)) unsigned) : @totally_disconnected_space.{0} (has_Sup.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Sup.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_167052 (h0 : topological_space (has_add (has_to_string linarith.comp))) : t1_space (has_add (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_167053 (h0 : ring (linear_ordered_field num)) : is_domain (linear_ordered_field num) := sorry --non-trivial
lemma new_lemma_167054 (h0 : add_monoid (omega_complete_partial_order (option unsigned))) : add_monoid.fg (omega_complete_partial_order (option unsigned)) := sorry --non-trivial
lemma new_lemma_167055 (h0 : topological_space unsigned) : totally_separated_space unsigned := sorry --non-trivial
lemma new_lemma_167056 (h1 : has_mem.mem (has_emptyc congr_arg_kind) has_emptyc.emptyc) : @t0_space.{0} (has_emptyc.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_emptyc.{0} congr_arg_kind) h1)  := sorry --non-trivial
lemma new_lemma_167057 (h1 : not (topological_space (semiring linarith.comp) -> false)) : @normal_space.{0} (semiring.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (semiring.{0} linarith.comp)) h1)  := sorry --non-trivial
lemma new_lemma_167058 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_167059 (h0 : functor.add_const (group (has_neg Type)) Type) : @is_simple_group.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 1} (group.{1} (has_neg.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_167060 (h0 : function.extfun (Type 1) cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1} h0 (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_167061 (h0 : group (ordered_ring unsigned)) : normalizer_condition (ordered_ring unsigned) := sorry --non-trivial
lemma new_lemma_167062 (h0 : topological_space (ordered_comm_monoid (has_pos_part (has_add Type)))) : locally_compact_space (ordered_comm_monoid (has_pos_part (has_add Type))) := sorry --non-trivial
lemma new_lemma_167063 (h0 : functor.add_const (topological_space (generalized_boolean_algebra pos)) linarith.comp) : @sequential_space.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_167064 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (normed_group.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_group.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_167065 (h0 : group (linear_ordered_comm_group (option ennreal))) : group.fg (linear_ordered_comm_group (option ennreal)) := sorry --non-trivial
lemma new_lemma_167066 (h0 : complete_lattice (normed_lattice_add_comm_group (has_Inf (has_add real)))) : is_compactly_generated (normed_lattice_add_comm_group (has_Inf (has_add real))) := sorry --non-trivial
lemma new_lemma_167067 (h0 : group (finset (finset environment.implicit_infer_kind))) : normalizer_condition (finset (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_167068 (h0 : function.extfun Type ring) : @is_domain.{0} (cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_167069 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @locally_compact_space.{0} (ordered_comm_monoid.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_monoid.{0} pos)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_167070 (h0 : function.extfun (Type 1) (functor.comp list semigroup)) : palindrome (functor.comp.run (function.extfun_app h0 Type)) := sorry --non-trivial
lemma new_lemma_167071 (h0 : add_monoid (id linarith.comp)) : add_monoid.fg (id linarith.comp) := sorry --non-trivial
lemma new_lemma_167072 (h8 : has_lt linarith.ineq) : no_max_order linarith.ineq := sorry --non-trivial
lemma new_lemma_167073 (h1 : ring (has_append linarith.comp_source)) : rank_condition (has_append linarith.comp_source) := sorry --non-trivial
lemma new_lemma_167074 (h0 : uniform_space (has_Inf (has_nndist name))) : separated_space (has_Inf (has_nndist name)) := sorry --non-trivial
lemma new_lemma_167075 (h0 : uniform_space (has_to_string (option name))) : complete_space (has_to_string (option name)) := sorry --non-trivial
lemma new_lemma_167076 (h0 : set (linear_ordered_comm_group_with_zero (mul_one_class linarith.ineq))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_167077 (h0 : complete_lattice (finset environment.implicit_infer_kind)) : complete_lattice.is_Sup_finite_compact (finset environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_167078 (h0 : list (has_zero (boolean_algebra.core ennreal))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_167079 (h0 : functor.add_const (function.extfun Type topological_space) (has_neg name)) : @topological_space.separable_space.{0} (complete_distrib_lattice.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (has_neg.{0} name) h0) (complete_distrib_lattice.{0} name))  := sorry --non-trivial
lemma new_lemma_167080 (h0 : topological_space (ordered_comm_monoid char)) : path_connected_space (ordered_comm_monoid char) := sorry --non-trivial
lemma new_lemma_167081 (h1 : topological_space (normed_field linarith.ineq)) : totally_disconnected_space (normed_field linarith.ineq) := sorry --non-trivial
lemma new_lemma_167082 (h0 : functor.add_const (topological_space (preorder num)) congr_arg_kind) : @path_connected_space.{0} (preorder.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (preorder.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_167083 (h0 : functor.add_const (function.extfun Type add_group) linarith.comp) : @is_add_cyclic.{0} (has_nndist.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_group.{0}) linarith.comp h0) (has_nndist.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_167084 (h1 : complete_lattice (has_norm linarith.comp_source)) : is_compactly_generated (has_norm linarith.comp_source) := sorry --non-trivial
lemma new_lemma_167085 (h0 : functor.add_const (topological_space (ordered_comm_monoid pos)) linarith.comp) : @preirreducible_space.{0} (ordered_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_monoid.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_167086 (h0 : monoid (has_inv linarith.comp_source)) (h1 : submonoid (has_inv linarith.comp_source)) : submonoid.fg h1 := sorry --non-trivial
lemma new_lemma_167087 (h0 : monoid (has_nndist (cancel_monoid Type))) : monoid.fg (has_nndist (cancel_monoid Type)) := sorry --non-trivial
lemma new_lemma_167088 (h0 : functor.add_const (uniform_space (has_Inf pos)) name) : @separated_space.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_Inf.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_167089 (h0 : topological_space (normed_comm_ring linarith.comp)) : preirreducible_space (normed_comm_ring linarith.comp) := sorry --non-trivial
lemma new_lemma_167090 (h0 : uniform_space (normed_group (random_gen (has_inv to_additive.value_type)))) : complete_space (normed_group (random_gen (has_inv to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_167091 (h0 : functor.add_const (topological_space (bin_tree congr_arg_kind)) unsigned) : @totally_disconnected_space.{0} (bin_tree.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (bin_tree.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_167092 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (has_top.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_top.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_167093 (h0 : functor.add_const (function.extfun Type semiring) (has_nndist (has_to_string Type))) : @is_noetherian_ring.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type semiring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type semiring.{0}) (has_nndist.{1} (has_to_string.{1} Type)) h0) (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_167094 (h0 : ring (metric_space (denumerable to_additive.value_type))) : is_domain (metric_space (denumerable to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_167095 (h0 : group (add_left_cancel_semigroup (semiring empty))) : group.fg (add_left_cancel_semigroup (semiring empty)) := sorry --non-trivial
lemma new_lemma_167096 (h0 : functor.add_const (topological_space (measure_theory.measure_space num)) (semiring num)) : @normal_space.{0} (measure_theory.measure_space.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (measure_theory.measure_space.{0} num)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_167097 (h0 : complete_lattice (id (measurable_space congr_arg_kind))) : complete_lattice.is_Sup_finite_compact (id (measurable_space congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_167098 (h0 : topological_space (has_zero (has_add (has_nndist ennreal)))) : totally_disconnected_space (has_zero (has_add (has_nndist ennreal))) := sorry --non-trivial
lemma new_lemma_167099 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_nndist.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_167100 (h0 : functor.add_const (topological_space (add_comm_monoid environment.implicit_infer_kind)) pos) : @normal_space.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_167101 (h0 : topological_space (pseudo_metric_space congr_arg_kind)) : topological_space.separable_space (pseudo_metric_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_167102 (h0 : complete_lattice (has_Inf (has_neg real))) : complete_lattice.is_Sup_finite_compact (has_Inf (has_neg real)) := sorry --non-trivial
lemma new_lemma_167103 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_nndist.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_167104 (h0 : function.extfun Type topological_space) : @normal_space.{0} (mul_zero_class.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (mul_zero_class.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_167105 (h0 : topological_space (has_Inf (has_pos_part (has_add linarith.comp)))) : locally_compact_space (has_Inf (has_pos_part (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_167106 (h0 : topological_space (has_zero ennreal)) : t0_space (has_zero ennreal) := sorry --non-trivial
lemma new_lemma_167107 (h0 : ring (ordered_comm_monoid (has_Inf real))) : is_domain (ordered_comm_monoid (has_Inf real)) := sorry --non-trivial
lemma new_lemma_167108 (h0 : complete_lattice (semiring (has_top (has_norm linarith.comp_source)))) : is_atomistic (semiring (has_top (has_norm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_167109 (h0 : uniform_space (canonically_ordered_comm_semiring (boolean_algebra.core Type))) : separated_space (canonically_ordered_comm_semiring (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_167110 (h0 : list (canonically_ordered_comm_semiring (has_add environment.implicit_infer_kind))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_167111 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} nnreal (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) nnreal)  := sorry --non-trivial
lemma new_lemma_167112 (h0 : semiring (has_one empty)) : is_noetherian_ring (has_one empty) := sorry --non-trivial
lemma new_lemma_167113 (h0 : fin has_zero.zero) : @irreducible_space.{0} (ordered_comm_ring.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_ring.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_167114 (h0 : ring (bin_tree congr_arg_kind)) : strong_rank_condition (bin_tree congr_arg_kind) := sorry --non-trivial
lemma new_lemma_167115 (h0 : not (ring (fintype linarith.comp_source) -> false)) : @rank_condition.{0} (fintype.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (fintype.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_167116 (h0 : topological_space (sub_neg_monoid pos)) : preconnected_space (sub_neg_monoid pos) := sorry --non-trivial
lemma new_lemma_167117 (h0 : topological_space (normed_group (has_inv (has_inv to_additive.value_type)))) : totally_separated_space (normed_group (has_inv (has_inv to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_167118 (h0 : ring (linear_ordered_comm_group (option (option num)))) : strong_rank_condition (linear_ordered_comm_group (option (option num))) := sorry --non-trivial
lemma new_lemma_167119 (h0 : ring (has_le reducibility_hints)) : is_domain (has_le reducibility_hints) := sorry --non-trivial
lemma new_lemma_167120 (h0 : topological_space (canonically_ordered_comm_semiring (option pos))) : regular_space (canonically_ordered_comm_semiring (option pos)) := sorry --non-trivial
lemma new_lemma_167121 (h0 : uniform_space (canonically_ordered_comm_semiring (has_pos_part Type))) : separated_space (canonically_ordered_comm_semiring (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_167122 (h0 : topological_space congr_arg_kind) : totally_separated_space congr_arg_kind := sorry --non-trivial
lemma new_lemma_167123 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (random_gen.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (random_gen.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_167124 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (option.{0} num) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (option.{0} num))  := sorry --non-trivial
lemma new_lemma_167125 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_simple_group.{0} (has_bot.{0} real) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_bot.{0} real))  := sorry --non-trivial
lemma new_lemma_167126 (h0 : set (mul_one_class (add_comm_semigroup (add_comm_semigroup (mul_one_class enat))))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_167127 (h0 : functor.add_const (ring (bin_tree num)) num) : @rank_condition.{0} (bin_tree.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (bin_tree.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_167128 (h0 : not (function.extfun Type complete_lattice -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (random_gen.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (random_gen.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_167129 (h0 : functor.add_const (topological_space (has_add real)) real) : @preirreducible_space.{0} (has_add.{0} real) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} real)) real h0)  := sorry --non-trivial
lemma new_lemma_167130 (h1 : ring (fintype string_imp)) : rank_condition (fintype string_imp) := sorry --non-trivial
lemma new_lemma_167131 (h0 : topological_space (ordered_comm_ring (has_bot (has_add pos)))) : sequential_space (ordered_comm_ring (has_bot (has_add pos))) := sorry --non-trivial
lemma new_lemma_167132 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (finset.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (finset.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_167133 (h0 : function.extfun nat fin) : @t0_space.{1} (sub_neg_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (sub_neg_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_167134 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_167135 (h0 : topological_space (option congr_arg_kind)) : t1_space (option congr_arg_kind) := sorry --non-trivial
lemma new_lemma_167136 (h0 : topological_space (generalized_boolean_algebra (has_pos_part (finset linarith.comp)))) : t0_space (generalized_boolean_algebra (has_pos_part (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_167137 (h0 : functor.add_const (ring (has_nndist empty)) empty) : @is_domain.{0} (has_nndist.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (has_nndist.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_167138 (h0 : topological_space (option unsigned)) : loc_path_connected_space (option unsigned) := sorry --non-trivial
lemma new_lemma_167139 (h0 : complete_lattice (has_emptyc (has_top (has_top num)))) : is_atomistic (has_emptyc (has_top (has_top num))) := sorry --non-trivial
lemma new_lemma_167140 (h0 : topological_space (has_norm (semiring (semiring empty)))) : preirreducible_space (has_norm (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_167141 (h0 : topological_space (has_add (add_left_cancel_monoid (has_add Type)))) : t1_space (has_add (add_left_cancel_monoid (has_add Type))) := sorry --non-trivial
lemma new_lemma_167142 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @path_connected_space.{0} (linear_ordered_add_comm_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (linear_ordered_add_comm_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_167143 (h0 : topological_space (with_zero linarith.ineq)) : totally_disconnected_space (with_zero linarith.ineq) := sorry --non-trivial
lemma new_lemma_167144 (h0 : topological_space (normed_linear_ordered_group num)) : discrete_topology (normed_linear_ordered_group num) := sorry --non-trivial
lemma new_lemma_167145 (h1 : ring (has_emptyc (random_gen (random_gen to_additive.value_type)))) : rank_condition (has_emptyc (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_167146 (h0 : ring (ring (boolean_algebra (boolean_algebra linarith.comp)))) : is_domain (ring (boolean_algebra (boolean_algebra linarith.comp))) := sorry --non-trivial
lemma new_lemma_167147 (h0 : topological_space (has_nnnorm (mul_one_class enat))) (h1 : preorder (has_nnnorm (mul_one_class enat))) : order_closed_topology (has_nnnorm (mul_one_class enat)) := sorry --non-trivial
lemma new_lemma_167148 (h0 : group (ordered_comm_monoid Type)) : is_cyclic (ordered_comm_monoid Type) := sorry --non-trivial
lemma new_lemma_167149 (h0 : topological_space (ordered_comm_ring (has_neg (has_add name)))) : path_connected_space (ordered_comm_ring (has_neg (has_add name))) := sorry --non-trivial
lemma new_lemma_167150 (h0 : fin has_zero.zero) : @is_compactly_generated.{0} (simple_graph.{0} linarith.comp) (@matrix.vec_empty.{0} (complete_lattice.{0} (simple_graph.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_167151 (h0 : group (simple_graph (has_Inf pos))) : is_cyclic (simple_graph (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_167152 (h0 : topological_space (normed_comm_ring (option (option empty)))) : path_connected_space (normed_comm_ring (option (option empty))) := sorry --non-trivial
lemma new_lemma_167153 (h0 : functor.add_const (topological_space (has_to_string unsigned)) (has_neg linarith.comp)) : @topological_space.separable_space.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} unsigned)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_167154 (h0 : not (topological_space (simple_graph char) -> false)) : @totally_disconnected_space.{0} (simple_graph.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (simple_graph.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_167155 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (@id.{2} Type to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (@id.{2} Type to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_167156 (h0 : semiring (semiring (semiring num))) : is_noetherian_ring (semiring (semiring num)) := sorry --non-trivial
lemma new_lemma_167157 (h0 : topological_space (has_pos_part (has_add (finset (finset pos))))) : locally_compact_space (has_pos_part (has_add (finset (finset pos)))) := sorry --non-trivial
lemma new_lemma_167158 (h0 : list (semigroup (mul_zero_class unsigned))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_167159 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (add_cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (add_cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_167160 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (has_norm.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_norm.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_167161 (h0 : functor.add_const (function.extfun Type topological_space) name) : @irreducible_space.{0} (has_to_string.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (has_to_string.{0} name))  := sorry --non-trivial
lemma new_lemma_167162 (h0 : topological_space (sub_neg_monoid (has_bot real))) : t0_space (sub_neg_monoid (has_bot real)) := sorry --non-trivial
lemma new_lemma_167163 (h0 : group (has_zero (has_add (has_to_string pos)))) : is_simple_group (has_zero (has_add (has_to_string pos))) := sorry --non-trivial
lemma new_lemma_167164 (h0 : finset (has_zero (has_add Type))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_167165 (h0 : complete_lattice (semiring (semiring unsigned))) : complete_lattice.is_Sup_finite_compact (semiring (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_167166 (h0 : topological_space (ordered_comm_ring (ring linarith.comp))) : t1_space (ordered_comm_ring (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_167167 (h0 : topological_space (has_to_string (has_neg_part ennreal))) : loc_path_connected_space (has_to_string (has_neg_part ennreal)) := sorry --non-trivial
lemma new_lemma_167168 (h0 : set (add_comm_semigroup char -> add_comm_semigroup (add_comm_semigroup linarith.ineq))) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_167169 (h0 : complete_lattice (normed_lattice_add_comm_group (comm_semigroup real))) : complete_lattice.is_Sup_finite_compact (normed_lattice_add_comm_group (comm_semigroup real)) := sorry --non-trivial
lemma new_lemma_167170 (h0 : topological_space (measurable_space.dynkin_system congr_arg_kind)) : totally_separated_space (measurable_space.dynkin_system congr_arg_kind) := sorry --non-trivial
lemma new_lemma_167171 (h0 : functor.add_const (topological_space (finset pos)) name) : @discrete_topology.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_167172 (h0 : cancel_comm_monoid_with_zero (has_add (normed_comm_ring name))) : unique_factorization_monoid (has_add (normed_comm_ring name)) := sorry --non-trivial
lemma new_lemma_167173 (h0 : topological_space (ordered_comm_monoid (has_add pos))) : discrete_topology (ordered_comm_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_167174 (h0 : functor.add_const (uniform_space (add_comm_monoid empty)) empty) : @separated_space.{0} (add_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (add_comm_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_167175 (h0 : not (ring (distrib_lattice string_imp) -> false)) : @strong_rank_condition.{0} (distrib_lattice.{0} string_imp) (@classical.by_contradiction'.{1} (ring.{0} (distrib_lattice.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_167176 (h0 : topological_space linarith.comp) : t0_space linarith.comp := sorry --non-trivial
lemma new_lemma_167177 (h0 : ring (has_norm string_imp)) : rank_condition (has_norm string_imp) := sorry --non-trivial
lemma new_lemma_167178 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (has_union.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (has_union.{0} empty))  := sorry --non-trivial
lemma new_lemma_167179 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (has_lt.{0} num) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (has_lt.{0} num))  := sorry --non-trivial
lemma new_lemma_167180 (h1 : complete_lattice (has_lt string_imp)) : is_compactly_generated (has_lt string_imp) := sorry --non-trivial
lemma new_lemma_167181 (h0 : functor.add_const (topological_space (finset Type)) unsigned) : @irreducible_space.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (finset.{1} Type)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_167182 (h0 : ordered_comm_monoid (semigroup (has_neg environment.implicit_infer_kind))) : has_exists_mul_of_le (semigroup (has_neg environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_167183 (h0 : topological_space (add_cancel_monoid (has_neg_part name))) : locally_compact_space (add_cancel_monoid (has_neg_part name)) := sorry --non-trivial
lemma new_lemma_167184 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (has_neg.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (has_neg.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_167185 (h0 : string_imp -> string_imp -> bool) : is_dec_refl h0 := sorry --non-trivial
lemma new_lemma_167186 (h0 : functor.add_const (function.extfun Type ring) name) : @rank_condition.{0} (has_nndist.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) name h0) (has_nndist.{0} name))  := sorry --non-trivial
lemma new_lemma_167187 (h0 : fin has_zero.zero) : @path_connected_space.{0} (topological_space.{0} linarith.ineq) (@matrix.vec_empty.{0} (topological_space.{0} (topological_space.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_167188 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (@id.{2} Type string_imp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (@id.{2} Type string_imp))  := sorry --non-trivial
lemma new_lemma_167189 (h0 : function.extfun Type ring) : @is_domain.{0} (partial_order.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (partial_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_167190 (h0 : not (add_group (with_bot num) -> false)) : @is_add_cyclic.{0} (with_bot.{0} num) (@classical.by_contradiction'.{1} (add_group.{0} (with_bot.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_167191 (h0 : topological_space (has_zero ennreal)) : totally_disconnected_space (has_zero ennreal) := sorry --non-trivial
lemma new_lemma_167192 (h0 : add_monoid (bin_tree (semiring (semiring congr_arg_kind)))) : add_monoid.fg (bin_tree (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_167193 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @totally_separated_space.{0} (random_gen.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (random_gen.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_167194 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (semiring.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_167195 (h0 : topological_space (has_le char)) : topological_space.first_countable_topology (has_le char) := sorry --non-trivial
lemma new_lemma_167196 (h0 : uniform_space (has_nndist (has_add Type))) : complete_space (has_nndist (has_add Type)) := sorry --non-trivial
lemma new_lemma_167197 (h0 : list (add_cancel_comm_monoid empty)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_167198 (h0 : monoid (left_cancel_monoid empty)) : monoid.fg (left_cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_167199 (h0 : functor.comp topological_space canonically_ordered_comm_semiring environment.implicit_infer_kind) : @t1_space.{0} (canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_167200 (h1 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} (semiring.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h1) (semiring.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_167201 (h0 : add_group (canonically_linear_ordered_monoid (has_add Type))) : is_add_cyclic (canonically_linear_ordered_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_167202 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (complete_distrib_lattice.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (complete_distrib_lattice.{0} num))  := sorry --non-trivial
lemma new_lemma_167203 (h0 : ring (has_star congr_arg_kind)) : rank_condition (has_star congr_arg_kind) := sorry --non-trivial
lemma new_lemma_167204 (h0 : topological_space (normed_group (random_gen linarith.ineq))) : irreducible_space (normed_group (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_167205 (h0 : group (comm_group (comm_group name))) : group.fg (comm_group (comm_group name)) := sorry --non-trivial
lemma new_lemma_167206 (h0 : not (group (with_one linarith.ineq) -> false)) : @group.fg.{0} (with_one.{0} linarith.ineq) (@classical.by_contradiction'.{1} (group.{0} (with_one.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_167207 (h0 : semiring (mul_zero_class Type)) : is_noetherian_ring (mul_zero_class Type) := sorry --non-trivial
lemma new_lemma_167208 (h0 : ring (ordered_comm_monoid (has_neg (has_neg pos)))) : rank_condition (ordered_comm_monoid (has_neg (has_neg pos))) := sorry --non-trivial
lemma new_lemma_167209 (h0 : measurable_space (has_nnnorm (add_comm_semigroup string.iterator_imp))) (h1 : measure_theory.measure (has_nnnorm (add_comm_semigroup string.iterator_imp))) : measure_theory.is_finite_measure h1 := sorry --non-trivial
lemma new_lemma_167210 (h0 : ring (distrib (has_nnnorm (comm_ring (comm_ring char))))) : rank_condition (distrib (has_nnnorm (comm_ring (comm_ring char)))) := sorry --non-trivial
lemma new_lemma_167211 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_167212 (h0 : prod (normed_group congr_arg_kind) (normed_group congr_arg_kind)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_167213 (h0 : functor.add_const (ordered_add_comm_monoid (finset ennreal)) unsigned) : @archimedean.{0} (finset.{0} ennreal) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (finset.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_167214 (h0 : monoid (normed_comm_ring unsigned)) : monoid.fg (normed_comm_ring unsigned) := sorry --non-trivial
lemma new_lemma_167215 (h0 : has_norm empty -> has_norm empty -> has_norm empty) : is_right_cancel (has_norm empty) h0 := sorry --non-trivial
lemma new_lemma_167216 (h0 : fin has_zero.zero) : @monoid.fg.{0} (ordered_comm_monoid.{0} pos) (@matrix.vec_empty.{0} (monoid.{0} (ordered_comm_monoid.{0} pos)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_167217 (h0 : functor.add_const (topological_space int) unsigned) : totally_separated_space int := sorry --non-trivial
lemma new_lemma_167218 (h0 : ring (fintype linarith.comp_source)) : is_domain (fintype linarith.comp_source) := sorry --non-trivial
lemma new_lemma_167219 (h0 : topological_space (ring (has_add name))) : t0_space (ring (has_add name)) := sorry --non-trivial
lemma new_lemma_167220 (h0 : fin has_zero.zero) : @is_compactly_generated.{0} (canonically_linear_ordered_monoid.{0} pos) (@matrix.vec_empty.{0} (complete_lattice.{0} (canonically_linear_ordered_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_167221 (h0 : functor.add_const (function.extfun Type ordered_comm_monoid) linarith.comp) : @has_exists_mul_of_le.{0} (semigroup.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) linarith.comp h0) (semigroup.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_167222 (h0 : not (ring (has_emptyc congr_arg_kind) -> false)) : @strong_rank_condition.{0} (has_emptyc.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (ring.{0} (has_emptyc.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_167223 (h0 : functor.add_const (topological_space (has_pos_part pos)) real) : @t0_space.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} pos)) real h0)  := sorry --non-trivial
lemma new_lemma_167224 (h0 : monoid (has_zero (has_neg linarith.comp))) : monoid.fg (has_zero (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_167225 (h0 : ordered_add_comm_monoid (normed_comm_ring (has_neg Type))) : archimedean (normed_comm_ring (has_neg Type)) := sorry --non-trivial
lemma new_lemma_167226 (h0 : functor.add_const (topological_space (has_nndist ennreal)) unsigned) : @discrete_topology.{0} (has_nndist.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_167227 (h0 : functor.add_const (list (has_neg_part name)) name) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_167228 (h0 : complete_lattice (add_group (has_norm linarith.comp))) : is_atomistic (add_group (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_167229 (h0 : topological_space (normed_group (denumerable linarith.ineq))) : irreducible_space (normed_group (denumerable linarith.ineq)) := sorry --non-trivial
lemma new_lemma_167230 (h0 : complete_lattice (linear_ordered_field num)) : is_atomistic (linear_ordered_field num) := sorry --non-trivial
lemma new_lemma_167231 (h0 : topological_space (comm_group (has_neg name))) : path_connected_space (comm_group (has_neg name)) := sorry --non-trivial
lemma new_lemma_167232 (h0 : finset (boolean_algebra (has_neg_part environment.implicit_infer_kind))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_167233 (h0 : finset (ordered_comm_monoid (has_bot name))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_167234 (h0 : ring (boolean_algebra (has_neg (finset Type)))) : is_domain (boolean_algebra (has_neg (finset Type))) := sorry --non-trivial
lemma new_lemma_167235 (h0 : functor.add_const (uniform_space (complete_distrib_lattice pos)) (has_add linarith.comp)) : @complete_space.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (complete_distrib_lattice.{0} pos)) (has_add.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_167236 (h0 : functor.add_const (monoid pos) linarith.comp) : @monoid.fg.{0} pos (@functor.add_const.run.{0 0} (monoid.{0} pos) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_167237 (h0 : topological_space (comm_group name)) : irreducible_space (comm_group name) := sorry --non-trivial
lemma new_lemma_167238 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @archimedean.{1} (plift.{1} unsigned) (@function.extfun_app.{3 2} (Type 1) ordered_add_comm_monoid.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ordered_add_comm_monoid.{1}) (plift.{1} unsigned))  := sorry --non-trivial
lemma new_lemma_167239 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (with_bot.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (with_bot.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_167240 (h0 : topological_space (has_zero (option (option pos)))) : normal_space (has_zero (option (option pos))) := sorry --non-trivial
lemma new_lemma_167241 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (has_emptyc linarith.ineq)) := sorry --non-trivial
lemma new_lemma_167242 (h0 : functor.add_const (topological_space (has_star empty)) empty) : @locally_compact_space.{0} (has_star.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_167243 (h0 : not (add_monoid (mul_zero_class unsigned) -> false)) : @add_monoid.fg.{0} (mul_zero_class.{0} unsigned) (@classical.by_contradiction'.{1} (add_monoid.{0} (mul_zero_class.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_167244 (h0 : functor.add_const (functor.add_const (group (boolean_algebra linarith.comp)) pos) pos) : @is_cyclic.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.{0} linarith.comp)) pos (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (group.{0} (boolean_algebra.{0} linarith.comp)) pos) pos h0))  := sorry --non-trivial
lemma new_lemma_167245 (h0 : topological_space (ring (boolean_algebra Type))) : locally_compact_space (ring (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_167246 (h0 : functor.add_const (topological_space (has_Inf name)) (has_add name)) : @irreducible_space.{0} (has_Inf.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} name)) (has_add.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_167247 (h0 : functor.add_const (topological_space (normed_comm_ring unsigned)) empty) : @locally_compact_space.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_167248 (h0 : list (has_norm (has_nnnorm linarith.comp_source))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_167249 (h0 : topological_space (has_neg (finset Type))) : locally_compact_space (has_neg (finset Type)) := sorry --non-trivial
lemma new_lemma_167250 (h0 : function.extfun Type group) : @group.fg.{0} (has_ssubset.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} h0 (has_ssubset.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_167251 (h0 : ring (linear_ordered_add_comm_group (has_inv to_additive.value_type))) : rank_condition (linear_ordered_add_comm_group (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_167252 (h0 : add_group (fintype char)) : is_add_cyclic (fintype char) := sorry --non-trivial
lemma new_lemma_167253 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (canonically_linear_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_linear_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_167254 (h0 : functor.add_const (group (has_nndist name)) (finset Type)) : @is_simple_group.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 1} (group.{0} (has_nndist.{0} name)) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_167255 (h0 : cancel_comm_monoid_with_zero (finset (has_neg_part (has_neg Type)))) : unique_factorization_monoid (finset (has_neg_part (has_neg Type))) := sorry --non-trivial
lemma new_lemma_167256 (h0 : ordered_add_comm_monoid (finset (finset environment.implicit_infer_kind))) : archimedean (finset (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_167257 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @preirreducible_space.{0} (has_zero.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (has_zero.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_167258 (h0 : topological_space (pseudo_metric_space real)) : t0_space (pseudo_metric_space real) := sorry --non-trivial
lemma new_lemma_167259 (h0 : group (distrib_lattice (has_top (has_nnnorm (random_gen linarith.ineq))))) : group.fg (distrib_lattice (has_top (has_nnnorm (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_167260 (h0 : topological_space (has_neg_part (has_add pos))) : totally_disconnected_space (has_neg_part (has_add pos)) := sorry --non-trivial
lemma new_lemma_167261 (h1 : set (uniform_space to_additive.value_type)) : set.finite h1 := sorry --non-trivial
lemma new_lemma_167262 (h0 : complete_lattice (boolean_algebra.core (has_neg_part pos))) : is_compactly_generated (boolean_algebra.core (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_167263 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (add_comm_monoid.{0} (option.{0} pos)) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (add_comm_monoid.{0} (option.{0} pos)))  := sorry --non-trivial
lemma new_lemma_167264 (h0 : topological_space (free_add_monoid unsigned)) : path_connected_space (free_add_monoid unsigned) := sorry --non-trivial
lemma new_lemma_167265 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (add_comm_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_167266 (h0 : ring (random_gen (has_inv linarith.comp_source))) : rank_condition (random_gen (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_167267 (h0 : function.extfun Type ring) : @is_domain.{0} (linear_order.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_167268 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (preorder.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (preorder.{0} empty))  := sorry --non-trivial
lemma new_lemma_167269 (h0 : has_mem.mem group has_emptyc.emptyc) : @is_cyclic.{0} (measurable_space.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} h0) (measurable_space.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_167270 (h0 : topological_space (canonically_ordered_comm_semiring (option num))) : locally_compact_space (canonically_ordered_comm_semiring (option num)) := sorry --non-trivial
lemma new_lemma_167271 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @loc_path_connected_space.{0} (has_neg.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (has_neg.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_167272 (h0 : ring (pseudo_metric_space (has_nndist (finset (has_add name))))) : strong_rank_condition (pseudo_metric_space (has_nndist (finset (has_add name)))) := sorry --non-trivial
lemma new_lemma_167273 (h0 : topological_space (has_nndist (has_add Type))) : discrete_topology (has_nndist (has_add Type)) := sorry --non-trivial
lemma new_lemma_167274 (h0 : functor.add_const (cancel_comm_monoid_with_zero (semigroup unsigned)) linarith.comp) : @unique_factorization_monoid.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (semigroup.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_167275 : id true := sorry --trivial
lemma new_lemma_167276 (h0 : functor.add_const (add_monoid (partial_order unsigned)) unsigned) : @add_monoid.fg.{0} (partial_order.{0} unsigned) (@functor.add_const.run.{0 0} (add_monoid.{0} (partial_order.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_167277 (h0 : ring (mul_zero_class (has_nndist ennreal))) : strong_rank_condition (mul_zero_class (has_nndist ennreal)) := sorry --non-trivial
lemma new_lemma_167278 (h0 : not (topological_space (metric_space empty) -> false)) : @totally_separated_space.{0} (metric_space.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (metric_space.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_167279 (h0 : topological_space (has_bot (sub_neg_monoid name))) : topological_space.separable_space (has_bot (sub_neg_monoid name)) := sorry --non-trivial
lemma new_lemma_167280 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (has_neg.{0} (option.{0} ennreal)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} (option.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_167281 (h0 : filter (has_add (mul_one_class linarith.comp))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_167282 (h0 : functor.add_const (topological_space (ordered_comm_ring pos)) name) : @normal_space.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_167283 (h0 : topological_space (monoid pos)) : preconnected_space (monoid pos) := sorry --non-trivial
lemma new_lemma_167284 (h1 : ring (denumerable char)) : strong_rank_condition (denumerable char) := sorry --non-trivial
lemma new_lemma_167285 (h0 : add_monoid (boolean_algebra.core environment.implicit_infer_kind)) : add_monoid.fg (boolean_algebra.core environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_167286 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (ordered_comm_ring.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_ring.{0} real))  := sorry --non-trivial
lemma new_lemma_167287 (h0 : ring (normed_lattice_add_comm_group (finset (has_add linarith.comp)))) : strong_rank_condition (normed_lattice_add_comm_group (finset (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_167288 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (has_dist congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_167289 (h0 : finset (normed_comm_ring ennreal)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_167290 (h0 : topological_space (has_sub congr_arg_kind)) : totally_disconnected_space (has_sub congr_arg_kind) := sorry --non-trivial
lemma new_lemma_167291 (h0 : group (with_one (has_norm unsigned))) : is_cyclic (with_one (has_norm unsigned)) := sorry --non-trivial
lemma new_lemma_167292 (h0 : list (normed_comm_ring (has_neg (finset linarith.comp)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_167293 (h0 : functor.add_const (add_monoid environment.implicit_infer_kind) (option (option (option unsigned)))) : @add_monoid.fg.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 0} (add_monoid.{0} environment.implicit_infer_kind) (option.{0} (option.{0} (option.{0} unsigned))) h0)  := sorry --non-trivial
lemma new_lemma_167294 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (ordered_cancel_add_comm_monoid.{0} num) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (ordered_cancel_add_comm_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_167295 (h0 : functor.add_const (uniform_space (boolean_algebra Type)) Type) : @complete_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 1} (uniform_space.{1} (boolean_algebra.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_167296 (h0 : topological_space (has_inner empty congr_arg_kind)) : irreducible_space (has_inner empty congr_arg_kind) := sorry --non-trivial
lemma new_lemma_167297 (h0 : topological_space (mul_zero_class (semiring congr_arg_kind))) : t1_space (mul_zero_class (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_167298 (h1 : uniform_space (fintype to_additive.value_type)) : complete_space (fintype to_additive.value_type) := sorry --non-trivial
lemma new_lemma_167299 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (with_one.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (with_one.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_167300 (h0 : group (fintype (random_gen linarith.ineq))) : group.fg (fintype (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_167301 (h0 : topological_space (has_edist (option unsigned))) : preirreducible_space (has_edist (option unsigned)) := sorry --non-trivial
lemma new_lemma_167302 (h0 : list (canonically_ordered_comm_semiring ennreal)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_167303 (h1 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_norm.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} h1 (has_norm.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_167304 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} to_additive.value_type (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) to_additive.value_type)  := sorry --non-trivial
lemma new_lemma_167305 (h0 : ring (option (option num))) : is_domain (option (option num)) := sorry --non-trivial
lemma new_lemma_167306 (h0 : functor.add_const (ring (semigroup linarith.comp)) (has_neg Type)) : @rank_condition.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 1} (ring.{0} (semigroup.{0} linarith.comp)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_167307 (h0 : group (cancel_monoid (option (option (option (option (option (option unsigned)))))))) : is_cyclic (cancel_monoid (option (option (option (option (option (option unsigned))))))) := sorry --non-trivial
lemma new_lemma_167308 (h0 : ordered_comm_monoid (add_comm_monoid name)) : has_exists_mul_of_le (add_comm_monoid name) := sorry --non-trivial
lemma new_lemma_167309 (h0 : not (function.extfun Type group -> false)) : @group.fg.{0} (linear_ordered_semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (linear_ordered_semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_167310 (h0 : ring nnreal) : is_principal_ideal_ring nnreal := sorry --non-trivial
lemma new_lemma_167311 (h1 : add_group (has_ssubset fun_info)) : is_add_cyclic (has_ssubset fun_info) := sorry --non-trivial
lemma new_lemma_167312 (h0 : finset (boolean_algebra.core (has_zero (option (option empty))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_167313 (h0 : option empty -> option empty -> Prop) : is_trans (option empty) h0 := sorry --non-trivial
lemma new_lemma_167314 (h0 : set (mul_one_class (mul_one_class (mul_one_class std_gen)) -> enat)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_167315 (h0 : list (has_star (semiring congr_arg_kind))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_167316 (h0 : has_lt (normed_field (mul_one_class (mul_one_class linarith.ineq)))) : no_max_order (normed_field (mul_one_class (mul_one_class linarith.ineq))) := sorry --non-trivial
lemma new_lemma_167317 (h0 : ring (has_append (mul_one_class (has_nnnorm (has_lt linarith.comp_source))))) : rank_condition (has_append (mul_one_class (has_nnnorm (has_lt linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_167318 (h0 : topological_space (ordered_comm_group (semiring empty))) : totally_disconnected_space (ordered_comm_group (semiring empty)) := sorry --non-trivial
lemma new_lemma_167319 (h0 : monoid (boolean_algebra (ring (has_pos_part linarith.comp)))) : monoid.fg (boolean_algebra (ring (has_pos_part linarith.comp))) := sorry --non-trivial
lemma new_lemma_167320 (h0 : list (add_cancel_monoid unsigned)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_167321 (h0 : functor.add_const (filter (complete_distrib_lattice name)) pos) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_167322 (h0 : topological_space (mul_zero_class (finset pos))) : regular_space (mul_zero_class (finset pos)) := sorry --non-trivial
lemma new_lemma_167323 (h0 : functor.add_const (complete_lattice (comm_group unsigned)) (comm_group pos)) : @is_compactly_generated.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (comm_group.{0} unsigned)) (comm_group.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_167324 (h0 : topological_space (boolean_algebra (has_add (has_Inf pos)))) : topological_space.separable_space (boolean_algebra (has_add (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_167325 (h0 : topological_space (has_Inf (has_Inf name))) : sequential_space (has_Inf (has_Inf name)) := sorry --non-trivial
lemma new_lemma_167326 (h0 : add_group (linear_ordered_cancel_comm_monoid (semiring empty))) : is_add_cyclic (linear_ordered_cancel_comm_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_167327 (h0 : topological_space (with_one (semiring unsigned))) : discrete_topology (with_one (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_167328 (h0 : complete_lattice (generalized_boolean_algebra (comm_semigroup pos))) : is_atomistic (generalized_boolean_algebra (comm_semigroup pos)) := sorry --non-trivial
lemma new_lemma_167329 (h0 : fin has_zero.zero) : @preirreducible_space.{0} (ordered_comm_ring.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_ring.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_167330 (h0 : functor.add_const (topological_space (linear_ordered_comm_monoid_with_zero unsigned)) empty) : @irreducible_space.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_167331 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_167332 (h0 : topological_space nnreal) : path_connected_space nnreal := sorry --non-trivial
lemma new_lemma_167333 (h0 : not (topological_space (has_star empty) -> false)) : @locally_compact_space.{0} (has_star.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (has_star.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_167334 (h0 : complete_lattice (has_add (has_add Type))) : is_compactly_generated (has_add (has_add Type)) := sorry --non-trivial
lemma new_lemma_167335 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (comm_ring.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (comm_ring.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_167336 (h0 : has_add (has_to_string pos) -> has_add (has_to_string pos) -> Prop) : is_symm (has_add (has_to_string pos)) h0 := sorry --non-trivial
lemma new_lemma_167337 (h0 : not (topological_space (has_top char) -> false)) : @t0_space.{0} (has_top.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (has_top.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_167338 (h0 : partial_order (with_one (comm_monoid linarith.comp))) (h1 : order_top (with_one (comm_monoid linarith.comp))) : is_coatomic (with_one (comm_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_167339 (h0 : topological_space (canonically_linear_ordered_monoid pos)) : regular_space (canonically_linear_ordered_monoid pos) := sorry --non-trivial
lemma new_lemma_167340 (h0 : function.extfun Type add_group) : is_add_cyclic real.angle := sorry --non-trivial
lemma new_lemma_167341 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (pseudo_metric_space.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (pseudo_metric_space.{0} pos))  := sorry --non-trivial
lemma new_lemma_167342 (h0 : functor.add_const (topological_space (boolean_algebra environment.implicit_infer_kind)) (finset pos)) : @t1_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_167343 (h0 : add_group (has_sub (semiring unsigned))) : is_add_cyclic (has_sub (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_167344 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @is_add_cyclic.{0} (random_gen.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) add_group.{0}) (random_gen.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_167345 (h0 : topological_space (has_to_string (has_pos_part (has_pos_part linarith.comp)))) : regular_space (has_to_string (has_pos_part (has_pos_part linarith.comp))) := sorry --non-trivial
lemma new_lemma_167346 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (add_left_cancel_monoid.{0} (has_nnnorm.{0} fun_info)) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (add_left_cancel_monoid.{0} (has_nnnorm.{0} fun_info)))  := sorry --non-trivial
lemma new_lemma_167347 (h0 : add_monoid (semiring (semiring num))) : add_monoid.fg (semiring (semiring num)) := sorry --non-trivial
lemma new_lemma_167348 (h0 : functor.add_const (complete_lattice (is_R_or_C num)) empty) : @complete_lattice.is_Sup_finite_compact.{0} (is_R_or_C.{0} num) (@functor.add_const.run.{0 0} (complete_lattice.{0} (is_R_or_C.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_167349 (h0 : function.extfun Type group) : @normalizer_condition.{0} (add_left_cancel_semigroup.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (add_left_cancel_semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_167350 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (with_one.{0} string_imp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (with_one.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_167351 (h0 : ring (has_neg_part linarith.comp)) : strong_rank_condition (has_neg_part linarith.comp) := sorry --non-trivial
lemma new_lemma_167352 (h0 : ring (semigroup (option (option ennreal)))) : is_domain (semigroup (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_167353 (h0 : function.extfun Type (functor.comp topological_space normed_comm_ring)) : @totally_disconnected_space.{0} (normed_comm_ring.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} normed_comm_ring.{0} ennreal (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} normed_comm_ring.{0}) h0 ennreal))  := sorry --non-trivial
lemma new_lemma_167354 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @is_atomistic.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) complete_lattice.{0}) (complete_semilattice_Sup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_167355 (h0 : filter Prop) : @Lim.{0} Prop sierpinski_space (@nonempty_of_inhabited.{1} Prop sort.inhabited.{0}) (@id.{1} (filter.{0} Prop) (@id.{1} (filter.{0} Prop) (@id.{1} (filter.{0} Prop) (@id.{1} (filter.{0} Prop) h0))))  := sorry --non-trivial
lemma new_lemma_167356 (h0 : functor.add_const (function.extfun (Type 1) topological_space) Type) : @sequential_space.{1} (has_neg.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) Type h0) (has_neg.{1} Type))  := sorry --non-trivial
lemma new_lemma_167357 (h0 : functor.add_const (group (has_add Type)) pos) : @is_simple_group.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (has_add.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_167358 (h0 : topological_space (has_compl std_gen)) (h1 : preorder (has_compl std_gen)) : order_closed_topology (has_compl std_gen) := sorry --non-trivial
lemma new_lemma_167359 (h0 : function.extfun (Type 1) topological_space) : @t0_space.{1} (generalized_boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (generalized_boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_167360 (h0 : group (has_norm (has_nnnorm linarith.ineq))) : group.fg (has_norm (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_167361 (h0 : group (linear_ordered_add_comm_group (has_norm (with_bot linarith.ineq)))) : normalizer_condition (linear_ordered_add_comm_group (has_norm (with_bot linarith.ineq))) := sorry --non-trivial
lemma new_lemma_167362 (h0 : uniform_space (semiring (has_norm num))) : separated_space (semiring (has_norm num)) := sorry --non-trivial
lemma new_lemma_167363 (h0 : cancel_comm_monoid_with_zero (add_cancel_monoid empty)) : unique_factorization_monoid (add_cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_167364 (h0 : semiring (has_Inf (sub_neg_monoid (has_Inf Type)))) : is_noetherian_ring (has_Inf (sub_neg_monoid (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_167365 (h0 : topological_space (has_inter (option (option (option unsigned))))) : loc_path_connected_space (has_inter (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_167366 (h0 : topological_space (random_gen linarith.comp)) : locally_compact_space (random_gen linarith.comp) := sorry --non-trivial
lemma new_lemma_167367 (h1 : ring (semi_normed_comm_ring linarith.comp_source)) : rank_condition (semi_normed_comm_ring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_167368 (h0 : topological_space (canonically_ordered_add_monoid (option (option empty)))) : discrete_topology (canonically_ordered_add_monoid (option (option empty))) := sorry --non-trivial
lemma new_lemma_167369 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (has_to_string.{0} ennreal) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (has_to_string.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_167370 (h0 : functor.add_const (finset (complete_distrib_lattice linarith.comp)) (finset linarith.comp)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_167371 (h0 : topological_space (linear_ordered_semiring (semiring unsigned))) : normal_space (linear_ordered_semiring (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_167372 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_167373 (h0 : group (has_nnnorm linarith.comp_source)) : is_cyclic (has_nnnorm linarith.comp_source) := sorry --non-trivial
lemma new_lemma_167374 (h0 : complete_lattice (topological_space (random_gen reducibility_hints))) : complete_lattice.is_Sup_finite_compact (topological_space (random_gen reducibility_hints)) := sorry --non-trivial
lemma new_lemma_167375 (h0 : functor.add_const (topological_space (finset name)) Type) : @discrete_topology.{0} (finset.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (finset.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_167376 (h0 : topological_space (ordered_comm_monoid (ring (ring (ring linarith.comp))))) : preirreducible_space (ordered_comm_monoid (ring (ring (ring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_167377 (h0 : cancel_comm_monoid_with_zero (left_cancel_semigroup (semiring congr_arg_kind))) : unique_factorization_monoid (left_cancel_semigroup (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_167378 (h0 : fin has_zero.zero) : @preirreducible_space.{1} (ordered_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (ordered_comm_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin (@matrix.vec_empty.{0} (function.extfun.{1 1} nat fin) h0) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_167379 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_ssubset.{0} char) (@function.extfun_app.{2 1} Type group.{0} h0 (has_ssubset.{0} char))  := sorry --non-trivial
lemma new_lemma_167380 (h0 : group (has_add (has_Inf (normed_lattice_add_comm_group Type)))) : group.fg (has_add (has_Inf (normed_lattice_add_comm_group Type))) := sorry --non-trivial
lemma new_lemma_167381 (h0 : finset (boolean_algebra.core (mul_zero_class name))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_167382 (h0 : uniform_space (group_with_zero ennreal)) : complete_space (group_with_zero ennreal) := sorry --non-trivial
lemma new_lemma_167383 (h0 : topological_space (metric_space congr_arg_kind)) : totally_disconnected_space (metric_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_167384 (h0 : topological_space (boolean_algebra.core congr_arg_kind)) : topological_space.separable_space (boolean_algebra.core congr_arg_kind) := sorry --non-trivial
lemma new_lemma_167385 (h0 : group (canonically_ordered_comm_semiring (finset (finset (finset pos))))) : group.fg (canonically_ordered_comm_semiring (finset (finset (finset pos)))) := sorry --non-trivial
lemma new_lemma_167386 (h0 : ring (left_cancel_monoid (option (option (option empty))))) : strong_rank_condition (left_cancel_monoid (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_167387 (h0 : functor.add_const (topological_space (has_zero Type)) (has_neg (ring (finset environment.implicit_infer_kind)))) : @irreducible_space.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_zero.{1} Type)) (has_neg.{0} (ring.{0} (finset.{0} environment.implicit_infer_kind))) h0)  := sorry --non-trivial
lemma new_lemma_167388 (h0 : group (linear_ordered_semiring congr_arg_kind)) : group.fg (linear_ordered_semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_167389 (h0 : functor.add_const (function.extfun Type list) Type) : list.nodup (function.extfun_app (functor.add_const.run h0) (add_cancel_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_167390 (h0 : ordered_add_comm_monoid (normed_comm_ring (has_neg (finset linarith.comp)))) : archimedean (normed_comm_ring (has_neg (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_167391 (h0 : topological_space (normed_comm_ring (has_pos_part linarith.comp))) : sequential_space (normed_comm_ring (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_167392 (h0 : topological_space (monoid congr_arg_kind)) : totally_disconnected_space (monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_167393 (h0 : function.extfun Type (functor.add_const (ring (has_star congr_arg_kind)))) : @rank_condition.{0} (has_star.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ring.{0} (has_star.{0} congr_arg_kind)) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} (has_star.{0} congr_arg_kind))) h0 num))  := sorry --non-trivial
lemma new_lemma_167394 (h0 : list (has_pos_part (normed_lattice_add_comm_group (finset (has_add linarith.comp))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_167395 (h0 : group (random_gen (has_norm fun_info))) : normalizer_condition (random_gen (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_167396 (h0 : uniform_space (distrib_lattice (has_inv linarith.comp_source))) : complete_space (distrib_lattice (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_167397 (h0 : filter (option ennreal)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_167398 (h0 : not (topological_space (semiring unsigned) -> false)) : @totally_separated_space.{0} (semiring.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (semiring.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_167399 (h0 : not (add_group (measurable_space.dynkin_system unsigned) -> false)) : @is_add_cyclic.{0} (measurable_space.dynkin_system.{0} unsigned) (@classical.by_contradiction'.{1} (add_group.{0} (measurable_space.dynkin_system.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_167400 (h0 : function.extfun (Type 1) list) : palindrome (function.extfun_app h0 (complete_distrib_lattice Type)) := sorry --non-trivial
lemma new_lemma_167401 (h0 : add_monoid (normed_comm_ring (comm_group pos))) : add_monoid.fg (normed_comm_ring (comm_group pos)) := sorry --non-trivial
lemma new_lemma_167402 (h0 : complete_lattice (add_cancel_monoid (option num))) : complete_lattice.is_Sup_finite_compact (add_cancel_monoid (option num)) := sorry --non-trivial
lemma new_lemma_167403 (h0 : ring (has_neg (has_add (has_add linarith.comp)))) : is_domain (has_neg (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_167404 (h0 : topological_space (linear_ordered_comm_monoid_with_zero unsigned)) : normal_space (linear_ordered_comm_monoid_with_zero unsigned) := sorry --non-trivial
lemma new_lemma_167405 (h0 : topological_space (complete_linear_order unsigned)) : t0_space (complete_linear_order unsigned) := sorry --non-trivial
lemma new_lemma_167406 (h0 : functor.comp topological_space ring linarith.comp) : @regular_space.{0} (ring.{0} linarith.comp) (@functor.comp.run.{0 0 0} topological_space.{0} ring.{0} linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_167407 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (has_top.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_top.{0} num))  := sorry --non-trivial
lemma new_lemma_167408 (h0 : has_add (has_add (has_add Type)) -> name -> name) : left_commutative h0 := sorry --non-trivial
lemma new_lemma_167409 (h0 : has_mem.mem (has_top (has_top num)) has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} (has_top.{0} (has_top.{0} num)) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (has_top.{0} (has_top.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_167410 (h0 : complete_lattice (has_zero (comm_group pos))) : complete_lattice.is_Sup_finite_compact (has_zero (comm_group pos)) := sorry --non-trivial
lemma new_lemma_167411 (h0 : ordered_comm_monoid (has_nndist name)) : has_exists_mul_of_le (has_nndist name) := sorry --non-trivial
lemma new_lemma_167412 (h0 : topological_space (mul_zero_class (option (cancel_monoid ennreal)))) : loc_path_connected_space (mul_zero_class (option (cancel_monoid ennreal))) := sorry --non-trivial
lemma new_lemma_167413 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (with_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_167414 (h0 : group (complete_distrib_lattice (option (option pos)))) : group.fg (complete_distrib_lattice (option (option pos))) := sorry --non-trivial
lemma new_lemma_167415 (h0 : add_group (has_lt char) -> Prop) (h1 : Exists (fun (x : add_group (has_lt char)), h0 x)) : @is_add_cyclic.{0} (has_lt.{0} char) (@classical.some.{1} (add_group.{0} (has_lt.{0} char)) h0 h1)  := sorry --non-trivial
lemma new_lemma_167416 (h0 : not (monoid (with_one congr_arg_kind) -> false)) : @monoid.fg.{0} (with_one.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (monoid.{0} (with_one.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_167417 (h0 : topological_space (ring (has_Inf (has_Inf (has_Inf environment.implicit_infer_kind))))) : t0_space (ring (has_Inf (has_Inf (has_Inf environment.implicit_infer_kind)))) := sorry --non-trivial
lemma new_lemma_167418 (h0 : add_group (has_neg_part (add_comm_monoid (has_nndist (has_add ennreal))))) : is_add_cyclic (has_neg_part (add_comm_monoid (has_nndist (has_add ennreal)))) := sorry --non-trivial
lemma new_lemma_167419 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (add_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_167420 (h0 : functor.add_const (prod (linear_order (option empty)) (linear_order (option empty))) empty) : id_rel (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_167421 (h0 : functor.add_const (complete_lattice (has_zero linarith.comp)) pos) : @is_compactly_generated.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_zero.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_167422 (h0 : function.extfun (finset Type -> Prop) (function.extfun (finset Type))) : @complete_space.{0} unsigned (@finset.pi.empty.{1 0} Type uniform_space.{0} unsigned (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) unsigned) (@function.extfun_app.{2 0} (finset.{1} Type → Prop) (function.extfun.{2 0} (finset.{1} Type)) h0 (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) unsigned)) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_167423 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (linear_ordered_comm_group.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (linear_ordered_comm_group.{0} num))  := sorry --non-trivial
lemma new_lemma_167424 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (has_dist.{0} ennreal) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (has_dist.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_167425 (h0 : function.extfun (Type 1) uniform_space) : @separated_space.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} h0 (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_167426 (h1 : complete_lattice (has_ssubset (has_nnnorm char))) : is_compactly_generated (has_ssubset (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_167427 (h0 : filter environment.implicit_infer_kind) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_167428 (h0 : topological_space (with_bot linarith.ineq)) : t0_space (with_bot linarith.ineq) := sorry --non-trivial
lemma new_lemma_167429 (h0 : topological_space (complete_semilattice_Sup congr_arg_kind)) : t0_space (complete_semilattice_Sup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_167430 (h0 : complete_lattice (has_one (has_norm empty))) : complete_lattice.is_Sup_finite_compact (has_one (has_norm empty)) := sorry --non-trivial
lemma new_lemma_167431 (h0 : finset (semi_normed_comm_ring char)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_167432 (h0 : not (has_mem.mem (with_one num) has_emptyc.emptyc -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (with_one.{0} num) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (with_one.{0} num) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_one.{0} num) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_167433 (h0 : add_monoid (boolean_algebra.core (option (option (has_add pos))))) : add_monoid.fg (boolean_algebra.core (option (option (has_add pos)))) := sorry --non-trivial
lemma new_lemma_167434 (h0 : uniform_space (has_zero (ordered_cancel_comm_monoid (has_add environment.implicit_infer_kind)))) : separated_space (has_zero (ordered_cancel_comm_monoid (has_add environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_167435 (h0 : add_group (has_add (ring Type))) : is_add_cyclic (has_add (ring Type)) := sorry --non-trivial
lemma new_lemma_167436 (h0 : ring (plift (has_add (has_pos_part linarith.comp)))) : strong_rank_condition (plift (has_add (has_pos_part linarith.comp))) := sorry --non-trivial
lemma new_lemma_167437 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @totally_disconnected_space.{0} (finset.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) topological_space.{0}) (finset.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_167438 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (has_sub.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_sub.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_167439 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (monoid.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} h0 (monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_167440 (h0 : functor.add_const (topological_space (has_neg_part Type)) Type) : @sequential_space.{1} (has_neg_part.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_neg_part.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_167441 (h1 : topological_space (with_one (has_norm fun_info))) : discrete_topology (with_one (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_167442 (h0 : functor.add_const (ordered_comm_monoid (has_add linarith.comp)) pos) : @has_exists_mul_of_le.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_add.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_167443 (h4 : uniform_space (semi_normed_ring to_additive.value_type)) : complete_space (semi_normed_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_167444 (h0 : group (add_comm_monoid (has_nndist (has_add pos)))) : is_simple_group (add_comm_monoid (has_nndist (has_add pos))) := sorry --non-trivial
lemma new_lemma_167445 (h0 : functor.add_const (ring (add_cancel_monoid pos)) environment.implicit_infer_kind) : @strong_rank_condition.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (add_cancel_monoid.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_167446 (h0 : functor.add_const (monoid (has_nndist environment.implicit_infer_kind)) environment.implicit_infer_kind) : @monoid.fg.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (monoid.{0} (has_nndist.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_167447 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (linear_ordered_comm_group.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (linear_ordered_comm_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_167448 (h0 : functor.add_const (group (comm_group name)) (add_comm_monoid pos)) : @is_cyclic.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (group.{0} (comm_group.{0} name)) (add_comm_monoid.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_167449 (h0 : complete_lattice (fintype (has_inv (normed_group to_additive.value_type)))) : complete_lattice.is_Sup_finite_compact (fintype (has_inv (normed_group to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_167450 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (option.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (option.{0} num))  := sorry --non-trivial
lemma new_lemma_167451 (h0 : complete_lattice (random_gen (has_nnnorm reducibility_hints))) : complete_lattice.is_Sup_finite_compact (random_gen (has_nnnorm reducibility_hints)) := sorry --non-trivial
lemma new_lemma_167452 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (semigroup.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (semigroup.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_167453 (h0 : functor.add_const (ring (non_assoc_semiring empty)) empty) : @rank_condition.{0} (non_assoc_semiring.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (non_assoc_semiring.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_167454 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (has_bot.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_bot.{0} name))  := sorry --non-trivial
lemma new_lemma_167455 (h0 : cancel_comm_monoid_with_zero (comm_monoid unsigned)) : unique_factorization_monoid (comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_167456 (h0 : functor.add_const (ring (complete_linear_order num)) (semiring num)) : @strong_rank_condition.{0} (complete_linear_order.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (complete_linear_order.{0} num)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_167457 (h0 : monoid (denumerable (random_gen (random_gen (random_gen linarith.ineq))))) : monoid.fg (denumerable (random_gen (random_gen (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_167458 (h0 : topological_space (has_zero (finset ennreal))) : topological_space.separable_space (has_zero (finset ennreal)) := sorry --non-trivial
lemma new_lemma_167459 (h0 : finset (normed_comm_ring (option pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_167460 (h0 : topological_space (add_comm_semigroup ereal)) (h1 : add_group (add_comm_semigroup ereal)) : topological_add_group (add_comm_semigroup ereal) := sorry --non-trivial
lemma new_lemma_167461 (h0 : topological_space (normed_group (has_top empty))) : totally_disconnected_space (normed_group (has_top empty)) := sorry --non-trivial
lemma new_lemma_167462 (h0 : functor.add_const (monoid (add_cancel_monoid pos)) (ring linarith.comp)) : @monoid.fg.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (monoid.{0} (add_cancel_monoid.{0} pos)) (ring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_167463 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_167464 (h0 : topological_space (has_star (option empty))) : loc_path_connected_space (has_star (option empty)) := sorry --non-trivial
lemma new_lemma_167465 (h0 : topological_space (has_to_string (semigroup linarith.comp))) : topological_space.separable_space (has_to_string (semigroup linarith.comp)) := sorry --non-trivial
lemma new_lemma_167466 (h1 : topological_space (normed_field (add_cancel_comm_monoid linarith.comp_source))) : t0_space (normed_field (add_cancel_comm_monoid linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_167467 (h0 : functor.add_const (semiring (free_add_monoid congr_arg_kind)) congr_arg_kind) : @is_noetherian_ring.{0} (free_add_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (semiring.{0} (free_add_monoid.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_167468 (h0 : group (ordered_cancel_add_comm_monoid (option (option unsigned)))) : is_cyclic (ordered_cancel_add_comm_monoid (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_167469 (h0 : functor.add_const (uniform_space (generalized_boolean_algebra linarith.comp)) pos) : @complete_space.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (generalized_boolean_algebra.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_167470 (h0 : function.extfun Type (functor.add_const (topological_space (bin_tree empty)))) : @path_connected_space.{0} (bin_tree.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (bin_tree.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (bin_tree.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_167471 (h0 : functor.add_const (topological_space (mul_zero_class linarith.comp)) (ring name)) : @sequential_space.{0} (mul_zero_class.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} linarith.comp)) (ring.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_167472 (h0 : topological_space (has_compl name)) : t0_space (has_compl name) := sorry --non-trivial
lemma new_lemma_167473 (h0 : functor.add_const (topological_space (add_cancel_monoid Type)) Type) : @path_connected_space.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (add_cancel_monoid.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_167474 (h0 : functor.add_const (topological_space (linear_ordered_field ennreal)) name) : @totally_disconnected_space.{0} (linear_ordered_field.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_field.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_167475 (h0 : not (function.extfun Type topological_space -> false)) : @normal_space.{0} (measurable_space.dynkin_system.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (measurable_space.dynkin_system.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_167476 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} (random_gen.{0} num) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (random_gen.{0} num))  := sorry --non-trivial
lemma new_lemma_167477 : infinite (normed_lattice_add_comm_group char) := sorry --non-trivial
lemma new_lemma_167478 (h0 : functor.add_const (topological_space (normed_linear_ordered_group unsigned)) num) : @totally_separated_space.{0} (normed_linear_ordered_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_linear_ordered_group.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_167479 (h0 : monoid (ring environment.implicit_infer_kind)) : monoid.fg (ring environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_167480 (h0 : cancel_comm_monoid_with_zero (option (option pos))) : unique_factorization_monoid (option (option pos)) := sorry --non-trivial
lemma new_lemma_167481 (h0 : list (has_emptyc (has_emptyc (random_gen congr_arg_kind)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_167482 (h0 : topological_space (has_nndist (has_neg Type))) : discrete_topology (has_nndist (has_neg Type)) := sorry --non-trivial
lemma new_lemma_167483 (h0 : topological_space (semigroup unsigned)) : t0_space (semigroup unsigned) := sorry --non-trivial
lemma new_lemma_167484 (h0 : group (has_Inf (finset Type))) : group.fg (has_Inf (finset Type)) := sorry --non-trivial
lemma new_lemma_167485 (h0 : functor.add_const (list (boolean_algebra unsigned)) name) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_167486 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (monoid.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_167487 (h0 : group (complete_distrib_lattice (has_nnnorm to_additive.value_type))) : is_cyclic (complete_distrib_lattice (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_167488 (h0 : topological_space linarith.ineq) : connected_space linarith.ineq := sorry --non-trivial
lemma new_lemma_167489 (h0 : not (complete_lattice (non_unital_non_assoc_semiring (distrib (mul_one_class reducibility_hints))) -> false)) : @is_compactly_generated.{0} (non_unital_non_assoc_semiring.{0} (distrib.{0} (mul_one_class.{0} reducibility_hints))) (@classical.by_contradiction'.{1} (complete_lattice.{0} (non_unital_non_assoc_semiring.{0} (distrib.{0} (mul_one_class.{0} reducibility_hints)))) h0)  := sorry --non-trivial
lemma new_lemma_167490 (h0 : functor.add_const (filter (semigroup pos)) linarith.comp) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_167491 (h0 : topological_space (ordered_comm_monoid Type)) : t1_space (ordered_comm_monoid Type) := sorry --non-trivial
lemma new_lemma_167492 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @regular_space.{0} (has_to_string.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (has_to_string.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_167493 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (mul_zero_class.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (mul_zero_class.{0} pos))  := sorry --non-trivial
lemma new_lemma_167494 (h0 : topological_space (boolean_algebra.core (boolean_algebra.core environment.implicit_infer_kind))) : t1_space (boolean_algebra.core (boolean_algebra.core environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_167495 (h0 : topological_space (measurable_space.dynkin_system (option empty))) : totally_separated_space (measurable_space.dynkin_system (option empty)) := sorry --non-trivial
lemma new_lemma_167496 (h0 : fin has_zero.zero) : @add_monoid.fg.{1} (simple_graph.{1} Type) (@matrix.vec_empty.{1} (add_monoid.{1} (simple_graph.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_167497 (h0 : cancel_comm_monoid_with_zero (monoid (option ennreal))) : unique_factorization_monoid (monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_167498 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : rank_condition real := sorry --non-trivial
lemma new_lemma_167499 (h1 : function.extfun Type group) : @is_cyclic.{0} (complete_semilattice_Sup.{0} num) (@function.extfun_app.{2 1} Type group.{0} h1 (complete_semilattice_Sup.{0} num))  := sorry --non-trivial
lemma new_lemma_167500 (h0 : functor.add_const (finset (has_Inf name)) Type) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_167501 (h0 : list (normed_comm_ring (comm_group name))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_167502 (h0 : group (generalized_boolean_algebra linarith.comp)) : is_cyclic (generalized_boolean_algebra linarith.comp) := sorry --non-trivial
lemma new_lemma_167503 (h0 : functor.add_const (group (has_add environment.implicit_infer_kind)) (finset (has_pos_part linarith.comp))) : @normalizer_condition.{0} (has_add.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (has_add.{0} environment.implicit_infer_kind)) (finset.{0} (has_pos_part.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_167504 (h0 : topological_space (add_cancel_monoid (boolean_algebra name))) : t1_space (add_cancel_monoid (boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_167505 (h0 : functor.add_const (uniform_space (has_pos_part linarith.comp)) linarith.comp) : @separated_space.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_pos_part.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_167506 (h0 : complete_lattice (has_neg ennreal)) : is_compactly_generated (has_neg ennreal) := sorry --non-trivial
lemma new_lemma_167507 (h0 : functor.add_const (cancel_comm_monoid_with_zero (preorder empty)) (semiring empty)) : @unique_factorization_monoid.{0} (preorder.{0} empty) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (preorder.{0} empty)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_167508 (h0 : complete_lattice (cancel_monoid Type)) : is_compactly_generated (cancel_monoid Type) := sorry --non-trivial
lemma new_lemma_167509 (h0 : monoid (has_add environment.implicit_infer_kind)) : monoid.fg (has_add environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_167510 (h0 : add_monoid (add_cancel_monoid (has_add linarith.comp))) : add_monoid.fg (add_cancel_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_167511 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (has_nndist.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_nndist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_167512 (h0 : complete_lattice (normed_group (semiring (semiring (semiring linarith.comp))))) : is_atomistic (normed_group (semiring (semiring (semiring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_167513 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (has_top.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_top.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_167514 (h0 : topological_space (has_bot (has_pos_part (sub_neg_monoid (sub_neg_monoid (has_Inf real)))))) : regular_space (has_bot (has_pos_part (sub_neg_monoid (sub_neg_monoid (has_Inf real))))) := sorry --non-trivial
lemma new_lemma_167515 (h0 : not (has_mem.mem (measurable_space num) has_emptyc.emptyc -> false)) : @strong_rank_condition.{0} (measurable_space.{0} num) (@finset.pi.empty.{1 0} Type ring.{0} (measurable_space.{0} num) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (measurable_space.{0} num) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_167516 (h0 : complete_lattice (semi_normed_comm_ring enat) -> complete_lattice (semi_normed_comm_ring enat) -> Prop) (h1 : well_founded h0) (h2 : set (complete_lattice (semi_normed_comm_ring enat))) (h3 : set.bounded h0 h2) : @complete_lattice.is_Sup_finite_compact.{0} (semi_normed_comm_ring.{0} enat) (@well_founded.sup.{0} (complete_lattice.{0} (semi_normed_comm_ring.{0} enat)) h0 h1 h2 h3)  := sorry --non-trivial
lemma new_lemma_167517 (h0 : ordered_comm_monoid (canonically_ordered_monoid (has_add pos))) : has_exists_mul_of_le (canonically_ordered_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_167518 (h0 : topological_space (ordered_comm_monoid (has_Inf (has_Inf real)))) : discrete_topology (ordered_comm_monoid (has_Inf (has_Inf real))) := sorry --non-trivial
lemma new_lemma_167519 (h0 : not (complete_lattice (has_append fun_info) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_append.{0} fun_info) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_append.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_167520 (h0 : topological_space (ring (boolean_algebra (has_neg (has_zero (comm_group (boolean_algebra name))))))) : t1_space (ring (boolean_algebra (has_neg (has_zero (comm_group (boolean_algebra name)))))) := sorry --non-trivial
lemma new_lemma_167521 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (generalized_boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (generalized_boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_167522 (h0 : semiring (ring (mul_zero_class pos))) : is_noetherian_ring (ring (mul_zero_class pos)) := sorry --non-trivial
lemma new_lemma_167523 (h0 : not (topological_space (normed_field string.iterator_imp) -> false)) : @path_connected_space.{0} (normed_field.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_field.{0} string.iterator_imp)) h0)  := sorry --non-trivial
lemma new_lemma_167524 (h0 : uniform_space (generalized_boolean_algebra (has_neg (ring Type)))) : separated_space (generalized_boolean_algebra (has_neg (ring Type))) := sorry --non-trivial
lemma new_lemma_167525 (h0 : ring (random_gen (has_ssubset char))) : rank_condition (random_gen (has_ssubset char)) := sorry --non-trivial
lemma new_lemma_167526 (h0 : functor.add_const (function.extfun (Type 1) topological_space) linarith.comp) : @irreducible_space.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) linarith.comp h0) (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_167527 (h0 : list (simple_graph empty)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_167528 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (normed_comm_ring.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (normed_comm_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_167529 (h0 : fin has_zero.zero) : @complete_lattice.is_Sup_finite_compact.{0} (boolean_algebra.{0} name) (@matrix.vec_empty.{0} (complete_lattice.{0} (boolean_algebra.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_167530 (h0 : topological_space (monoid_with_zero (option pos))) : preirreducible_space (monoid_with_zero (option pos)) := sorry --non-trivial
lemma new_lemma_167531 (h1 : topological_space (has_ssubset string.iterator_imp)) : totally_disconnected_space (has_ssubset string.iterator_imp) := sorry --non-trivial
lemma new_lemma_167532 (h0 : topological_space (comm_group (finset ennreal))) : preirreducible_space (comm_group (finset ennreal)) := sorry --non-trivial
lemma new_lemma_167533 (h0 : functor.add_const (topological_space (ordered_comm_ring linarith.comp)) Type) : @preirreducible_space.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (ordered_comm_ring.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_167534 (h0 : functor.add_const (complete_lattice (linear_ordered_cancel_comm_monoid empty)) num) : @is_atomistic.{0} (linear_ordered_cancel_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (linear_ordered_cancel_comm_monoid.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_167535 (h0 : cancel_comm_monoid_with_zero (boolean_algebra.core (has_add (add_group (finset name))))) : unique_factorization_monoid (boolean_algebra.core (has_add (add_group (finset name)))) := sorry --non-trivial
lemma new_lemma_167536 (h0 : uniform_space (normed_comm_ring (normed_comm_ring (finset pos)))) : complete_space (normed_comm_ring (normed_comm_ring (finset pos))) := sorry --non-trivial
lemma new_lemma_167537 (h0 : functor.add_const (group (simple_graph linarith.comp)) pos) : @group.fg.{0} (simple_graph.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (simple_graph.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_167538 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_top.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_top.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_167539 (h0 : ring (has_to_string (finset environment.implicit_infer_kind))) : strong_rank_condition (has_to_string (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_167540 (h0 : group (canonically_linear_ordered_monoid num)) : group.fg (canonically_linear_ordered_monoid num) := sorry --non-trivial
lemma new_lemma_167541 (h0 : ring (ring (has_zero (has_add unsigned)))) : rank_condition (ring (has_zero (has_add unsigned))) := sorry --non-trivial
lemma new_lemma_167542 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : discrete_topology empty := sorry --non-trivial
lemma new_lemma_167543 (h0 : functor.add_const (ring (has_neg_part environment.implicit_infer_kind)) pos) : @rank_condition.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (has_neg_part.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_167544 (h0 : functor.add_const (list (has_to_string linarith.comp)) (has_to_string linarith.comp)) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_167545 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} h0 (linear_ordered_comm_monoid_with_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_167546 (h0 : monoid (has_norm (random_gen string_imp))) : monoid.fg (has_norm (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_167547 (h0 : ordered_add_comm_monoid (complete_distrib_lattice (option name))) : archimedean (complete_distrib_lattice (option name)) := sorry --non-trivial
lemma new_lemma_167548 (h0 : functor.add_const (add_group (has_neg Type)) Type) : @is_add_cyclic.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 1} (add_group.{1} (has_neg.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_167549 (h0 : fin has_zero.zero) : @topological_space.separable_space.{0} (add_comm_monoid.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (add_comm_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_167550 (h0 : add_monoid (mul_zero_class (semiring empty))) : add_monoid.fg (mul_zero_class (semiring empty)) := sorry --non-trivial
lemma new_lemma_167551 (h0 : filter (complete_semilattice_Sup unsigned)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_167552 (h0 : add_group (metric_space (random_gen empty))) : is_add_cyclic (metric_space (random_gen empty)) := sorry --non-trivial
lemma new_lemma_167553 (h0 : topological_space (semi_normed_comm_ring (has_nnnorm fun_info))) : path_connected_space (semi_normed_comm_ring (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_167554 (h1 : ring (linear_ordered_add_comm_group (linear_ordered_add_comm_group char))) : is_domain (linear_ordered_add_comm_group (linear_ordered_add_comm_group char)) := sorry --non-trivial
lemma new_lemma_167555 (h0 : uniform_space (canonically_linear_ordered_monoid (option unsigned))) : separated_space (canonically_linear_ordered_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_167556 (h0 : topological_space (uniform_space linarith.comp_source)) : path_connected_space (uniform_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_167557 (h1 : add_group (distrib_lattice (has_nnnorm (has_nnnorm fun_info)))) : is_add_cyclic (distrib_lattice (has_nnnorm (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_167558 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (finset ennreal)) := sorry --non-trivial
lemma new_lemma_167559 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (semiring.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_167560 (h0 : functor.add_const (group (has_Inf pos)) (finset (finset (finset (finset (finset pos)))))) : @is_cyclic.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_Inf.{0} pos)) (finset.{0} (finset.{0} (finset.{0} (finset.{0} (finset.{0} pos))))) h0)  := sorry --non-trivial
lemma new_lemma_167561 (h0 : ring (add_comm_semigroup (add_comm_semigroup (add_comm_semigroup enat)))) : strong_rank_condition (add_comm_semigroup (add_comm_semigroup (add_comm_semigroup enat))) := sorry --non-trivial
lemma new_lemma_167562 (h0 : functor.add_const (ring (canonically_ordered_comm_semiring ennreal)) unsigned) : @strong_rank_condition.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@functor.add_const.run.{0 0} (ring.{0} (canonically_ordered_comm_semiring.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_167563 (h0 : has_lt (add_comm_semigroup std_gen)) : no_max_order (add_comm_semigroup std_gen) := sorry --non-trivial
lemma new_lemma_167564 (h0 : cancel_comm_monoid_with_zero (monoid_with_zero ennreal)) : unique_factorization_monoid (monoid_with_zero ennreal) := sorry --non-trivial
lemma new_lemma_167565 (h0 : cancel_comm_monoid_with_zero (has_zero (ring linarith.comp))) : unique_factorization_monoid (has_zero (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_167566 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @path_connected_space.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_167567 (h0 : topological_space (has_zero (normed_comm_ring Type))) : preirreducible_space (has_zero (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_167568 (h0 : function.extfun nat fin) : @monoid.fg.{0} (boolean_algebra.{0} real) (@matrix.vec_empty.{0} (monoid.{0} (boolean_algebra.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_167569 (h0 : topological_space (has_inter (option ennreal))) : preirreducible_space (has_inter (option ennreal)) := sorry --non-trivial
lemma new_lemma_167570 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (add_comm_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_167571 (h1 : topological_space string_imp) : totally_separated_space string_imp := sorry --non-trivial
lemma new_lemma_167572 (h0 : uniform_space (add_comm_monoid unsigned)) : complete_space (add_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_167573 (h0 : add_comm_monoid (add_comm_monoid ennreal) -> add_comm_monoid (add_comm_monoid ennreal) -> Prop) : is_symm (add_comm_monoid (add_comm_monoid ennreal)) h0 := sorry --non-trivial
lemma new_lemma_167574 (h0 : functor.add_const (topological_space (pseudo_metric_space ennreal)) ennreal) : @discrete_topology.{0} (pseudo_metric_space.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (pseudo_metric_space.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_167575 (h0 : add_monoid (option (has_star num))) : add_monoid.fg (option (has_star num)) := sorry --non-trivial
lemma new_lemma_167576 (h0 : list (boolean_algebra (has_Inf (ring (has_Inf (ordered_ring linarith.comp)))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_167577 (h0 : functor.add_const (topological_space (complete_distrib_lattice linarith.comp)) Type) : @loc_path_connected_space.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (complete_distrib_lattice.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_167578 (h0 : ring (add_cancel_monoid (ordered_ring name))) : strong_rank_condition (add_cancel_monoid (ordered_ring name)) := sorry --non-trivial
lemma new_lemma_167579 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (add_cancel_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_cancel_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_167580 (h0 : uniform_space (metric_space (comm_ring linarith.comp_source))) : complete_space (metric_space (comm_ring linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_167581 (h0 : function.extfun Type group) : @group.fg.{0} (has_one.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (has_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_167582 (h0 : complete_lattice (semiring (normed_group linarith.comp_source))) : complete_lattice.is_Sup_finite_compact (semiring (normed_group linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_167583 (h0 : ring (distrib (has_ssubset (random_gen string_imp)))) : rank_condition (distrib (has_ssubset (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_167584 (h0 : functor.add_const (ring (has_neg name)) (ring Type)) : @rank_condition.{0} (has_neg.{0} name) (@functor.add_const.run.{0 1} (ring.{0} (has_neg.{0} name)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_167585 (h0 : topological_space (complete_distrib_lattice real)) : totally_disconnected_space (complete_distrib_lattice real) := sorry --non-trivial
lemma new_lemma_167586 (h0 : complete_lattice (linear_ordered_field (option (option num)))) : is_compactly_generated (linear_ordered_field (option (option num))) := sorry --non-trivial
lemma new_lemma_167587 (h0 : ring (nondiscrete_normed_field linarith.ineq)) : rank_condition (nondiscrete_normed_field linarith.ineq) := sorry --non-trivial
lemma new_lemma_167588 (h0 : uniform_space (simple_graph environment.projection_info)) : complete_space (simple_graph environment.projection_info) := sorry --non-trivial
lemma new_lemma_167589 (h0 : uniform_space (random_gen (random_gen empty))) : separated_space (random_gen (random_gen empty)) := sorry --non-trivial
lemma new_lemma_167590 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_167591 (h0 : not (semiring (has_sub congr_arg_kind) -> false)) : @is_noetherian_ring.{0} (has_sub.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (semiring.{0} (has_sub.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_167592 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_167593 (h0 : functor.add_const (function.extfun (Type 1) topological_space) pos) : @sequential_space.{1} (boolean_algebra.core.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) pos h0) (boolean_algebra.core.{1} Type))  := sorry --non-trivial
lemma new_lemma_167594 (h0 : ring (uniform_space (mul_one_class (mul_one_class string_imp)))) : rank_condition (uniform_space (mul_one_class (mul_one_class string_imp))) := sorry --non-trivial
lemma new_lemma_167595 (h0 : topological_space (has_nndist (finset (finset linarith.comp)))) : sequential_space (has_nndist (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_167596 (h0 : topological_space (pseudo_metric_space (option (option pos)))) : t0_space (pseudo_metric_space (option (option pos))) := sorry --non-trivial
lemma new_lemma_167597 (h0 : has_Inf (canonically_linear_ordered_monoid real) -> has_Inf (canonically_linear_ordered_monoid real) -> Prop) : transitive h0 := sorry --non-trivial
lemma new_lemma_167598 (h0 : topological_space (normed_group (semiring (semiring (semiring congr_arg_kind))))) : t0_space (normed_group (semiring (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_167599 (h0 : functor.add_const (filter (cancel_monoid pos)) pos) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_167600 (h0 : add_monoid (boolean_algebra.core (has_neg_part Type))) : add_monoid.fg (boolean_algebra.core (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_167601 (h0 : topological_space (canonically_ordered_monoid (has_add (has_Inf (has_Inf Type))))) : path_connected_space (canonically_ordered_monoid (has_add (has_Inf (has_Inf Type)))) := sorry --non-trivial
lemma new_lemma_167602 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} unsigned (@function.extfun_app.{2 1} Type ring.{0} h0 unsigned)  := sorry --non-trivial
lemma new_lemma_167603 (h1 : complete_lattice (distrib (has_nnnorm (has_ssubset (random_gen (random_gen char)))))) : is_compactly_generated (distrib (has_nnnorm (has_ssubset (random_gen (random_gen char))))) := sorry --non-trivial
lemma new_lemma_167604 (h0 : group (pseudo_metric_space (option pos))) : normalizer_condition (pseudo_metric_space (option pos)) := sorry --non-trivial
lemma new_lemma_167605 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem ring)) : @is_domain.{0} string_imp (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) ring.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) string_imp)  := sorry --non-trivial
lemma new_lemma_167606 (h0 : functor.add_const (function.extfun Type topological_space) name) : @preirreducible_space.{0} (has_pos_part.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (has_pos_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_167607 (h0 : functor.add_const (complete_lattice (semigroup ennreal)) (comm_group name)) : @is_atomistic.{0} (semigroup.{0} ennreal) (@functor.add_const.run.{0 0} (complete_lattice.{0} (semigroup.{0} ennreal)) (comm_group.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_167608 (h0 : ring (finset fun_info)) : strong_rank_condition (finset fun_info) := sorry --non-trivial
lemma new_lemma_167609 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (has_Inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (has_Inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_167610 (h0 : semiring (semigroup unsigned)) : is_noetherian_ring (semigroup unsigned) := sorry --non-trivial
lemma new_lemma_167611 (h0 : complete_lattice (add_cancel_monoid linarith.comp_source)) : is_compactly_generated (add_cancel_monoid linarith.comp_source) := sorry --non-trivial
lemma new_lemma_167612 (h0 : filter (semiring (has_norm num))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_167613 (h0 : not (group (distrib linarith.ineq) -> false)) : @is_cyclic.{0} (distrib.{0} linarith.ineq) (@classical.by_contradiction'.{1} (group.{0} (distrib.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_167614 (h0 : functor.add_const (add_group (generalized_boolean_algebra pos)) (has_add pos)) : @is_add_cyclic.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (generalized_boolean_algebra.{0} pos)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_167615 (h0 : semiring (semigroup Type)) : is_noetherian_ring (semigroup Type) := sorry --non-trivial
lemma new_lemma_167616 (h0 : ring (dlist (has_ssubset (with_zero string_imp)))) : rank_condition (dlist (has_ssubset (with_zero string_imp))) := sorry --non-trivial
lemma new_lemma_167617 (h0 : function.extfun (finset Type) (has_mem.mem empty)) : irreducible_space empty := sorry --non-trivial
lemma new_lemma_167618 (h0 : group (sub_neg_monoid (has_add (sub_neg_monoid pos)))) : is_cyclic (sub_neg_monoid (has_add (sub_neg_monoid pos))) := sorry --non-trivial
lemma new_lemma_167619 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_star.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_star.{0} num))  := sorry --non-trivial
lemma new_lemma_167620 (h0 : topological_space (add_comm_monoid (monoid_with_zero (cancel_monoid pos)))) : discrete_topology (add_comm_monoid (monoid_with_zero (cancel_monoid pos))) := sorry --non-trivial
lemma new_lemma_167621 (h0 : functor.add_const (cancel_comm_monoid_with_zero (ring name)) (comm_group (comm_group (has_to_string unsigned)))) : @unique_factorization_monoid.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (ring.{0} name)) (comm_group.{0} (comm_group.{0} (has_to_string.{0} unsigned))) h0)  := sorry --non-trivial
lemma new_lemma_167622 (h0 : topological_space (has_pos_part (ordered_comm_monoid real))) : normal_space (has_pos_part (ordered_comm_monoid real)) := sorry --non-trivial
lemma new_lemma_167623 (h0 : function.extfun (finset Type) (has_mem.mem (has_top num))) : @rank_condition.{0} (has_top.{0} num) (@finset.pi.empty.{1 0} Type ring.{0} (has_top.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_top.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_167624 (h0 : functor.add_const (ring (normed_comm_ring linarith.comp)) pos) : @is_domain.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (normed_comm_ring.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_167625 (h0 : ordered_add_comm_monoid (generalized_boolean_algebra (ring Type))) : archimedean (generalized_boolean_algebra (ring Type)) := sorry --non-trivial
lemma new_lemma_167626 (h0 : ring (has_le (has_le fun_info))) : is_domain (has_le (has_le fun_info)) := sorry --non-trivial
lemma new_lemma_167627 (h0 : functor.add_const (finset (normed_comm_ring Type)) (finset Type)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_167628 (h0 : set (set (random_gen (has_inv linarith.comp_source)))) : is_countably_spanning h0 := sorry --non-trivial
lemma new_lemma_167629 (h0 : functor.add_const (monoid (complete_distrib_lattice name)) name) : @monoid.fg.{0} (complete_distrib_lattice.{0} name) (@functor.add_const.run.{0 0} (monoid.{0} (complete_distrib_lattice.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_167630 (h0 : topological_space (finset (option empty))) : preirreducible_space (finset (option empty)) := sorry --non-trivial
lemma new_lemma_167631 (h0 : topological_space (finset ennreal)) : loc_path_connected_space (finset ennreal) := sorry --non-trivial
lemma new_lemma_167632 (h0 : functor.add_const (complete_lattice (canonically_ordered_comm_semiring name)) name) : @is_compactly_generated.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (canonically_ordered_comm_semiring.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_167633 (h0 : topological_space (complete_semilattice_Sup (with_one string_imp))) : locally_compact_space (complete_semilattice_Sup (with_one string_imp)) := sorry --non-trivial
lemma new_lemma_167634 (h0 : function.extfun Type (functor.add_const (ordered_add_comm_monoid (linear_ordered_comm_monoid_with_zero unsigned)))) : @archimedean.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ordered_add_comm_monoid.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned))) h0 empty))  := sorry --non-trivial
lemma new_lemma_167635 (h0 : filter (finset (complete_distrib_lattice Type))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_167636 (h0 : topological_space (has_nndist (has_to_string (has_to_string (has_to_string name))))) : locally_compact_space (has_nndist (has_to_string (has_to_string (has_to_string name)))) := sorry --non-trivial
lemma new_lemma_167637 (h0 : complete_lattice (id to_additive.value_type)) : is_compactly_generated (id to_additive.value_type) := sorry --non-trivial
lemma new_lemma_167638 (h0 : not (cancel_comm_monoid_with_zero (option unsigned) -> false)) : @unique_factorization_monoid.{0} (option.{0} unsigned) (@classical.by_contradiction'.{1} (cancel_comm_monoid_with_zero.{0} (option.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_167639 (h0 : functor.add_const (list (non_assoc_semiring congr_arg_kind)) (option empty)) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_167640 (h0 : functor.add_const (complete_lattice (cancel_monoid pos)) (semigroup pos)) : @is_compactly_generated.{0} (cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (cancel_monoid.{0} pos)) (semigroup.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_167641 (h0 : functor.add_const (uniform_space (add_comm_monoid Type)) (has_add (has_neg_part Type))) : @complete_space.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 1} (uniform_space.{1} (add_comm_monoid.{1} Type)) (has_add.{1} (has_neg_part.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_167642 (h0 : functor.add_const (topological_space (boolean_algebra.core pos)) linarith.comp) : @loc_path_connected_space.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_167643 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (complete_distrib_lattice.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_distrib_lattice.{0} name))  := sorry --non-trivial
lemma new_lemma_167644 (h0 : complete_lattice (bin_tree (semiring (semiring num)))) : is_atomistic (bin_tree (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_167645 (h0 : cancel_comm_monoid_with_zero (canonically_linear_ordered_monoid (option unsigned))) : unique_factorization_monoid (canonically_linear_ordered_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_167646 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (with_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_group.{0} h0 (with_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_167647 (h0 : cancel_comm_monoid_with_zero (boolean_algebra.core linarith.comp)) : unique_factorization_monoid (boolean_algebra.core linarith.comp) := sorry --non-trivial
lemma new_lemma_167648 (h0 : semiring (add_right_cancel_monoid empty)) : is_noetherian_ring (add_right_cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_167649 (h0 : functor.comp topological_space semigroup pos) : @regular_space.{0} (semigroup.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_167650 (h0 : functor.add_const (topological_space (ring pos)) Type) : @irreducible_space.{0} (ring.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (ring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_167651 (h0 : functor.add_const (topological_space (boolean_algebra.core pos)) Type) : @discrete_topology.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.core.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_167652 (h0 : ring (normed_comm_ring (boolean_algebra linarith.comp))) : is_domain (normed_comm_ring (boolean_algebra linarith.comp)) := sorry --non-trivial
lemma new_lemma_167653 (h0 : uniform_space (has_neg (has_neg_part (comm_group unsigned)))) : complete_space (has_neg (has_neg_part (comm_group unsigned))) := sorry --non-trivial
lemma new_lemma_167654 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (has_zero.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_zero.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_167655 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (@id.{2} Type congr_arg_kind) (@function.extfun_app.{2 1} Type semiring.{0} h0 (@id.{2} Type congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_167656 (h0 : not (list (comm_ring to_additive.value_type) -> false)) : list.nodup (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_167657 (h0 : cancel_comm_monoid_with_zero (normed_lattice_add_comm_group (sub_neg_monoid Type))) : unique_factorization_monoid (normed_lattice_add_comm_group (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_167658 (h2 : uniform_space (semi_normed_ring string_imp)) : complete_space (semi_normed_ring string_imp) := sorry --non-trivial
lemma new_lemma_167659 (h0 : not (function.extfun Type topological_space -> false)) : @preirreducible_space.{0} (has_norm.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_norm.{0} empty))  := sorry --non-trivial
lemma new_lemma_167660 (h0 : add_group (add_left_cancel_monoid (has_inv to_additive.value_type))) : is_add_cyclic (add_left_cancel_monoid (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_167661 (h0 : topological_space (has_neg environment.implicit_infer_kind)) : totally_separated_space (has_neg environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_167662 (h0 : topological_space (linear_ordered_comm_ring (semiring empty))) : discrete_topology (linear_ordered_comm_ring (semiring empty)) := sorry --non-trivial
lemma new_lemma_167663 (h0 : functor.add_const (ring (ordered_comm_ring linarith.comp)) name) : @is_domain.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (ordered_comm_ring.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_167664 (h0 : ring (ring (finset (has_to_string Type)))) : is_principal_ideal_ring (ring (finset (has_to_string Type))) := sorry --non-trivial
lemma new_lemma_167665 (h1 : complete_lattice (distrib fun_info)) : is_compactly_generated (distrib fun_info) := sorry --non-trivial
lemma new_lemma_167666 (h0 : functor.add_const (ring (generalized_boolean_algebra Type)) pos) : @is_principal_ideal_ring.{1} (generalized_boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (generalized_boolean_algebra.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_167667 (h0 : not (has_mem.mem (with_bot num) has_emptyc.emptyc -> false)) : @totally_separated_space.{0} (with_bot.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_bot.{0} num) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_bot.{0} num) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_167668 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (measurable_space.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (measurable_space.{0} num))  := sorry --non-trivial
lemma new_lemma_167669 (h0 : group (has_bot (has_add (has_pos_part (has_Inf real))))) : is_simple_group (has_bot (has_add (has_pos_part (has_Inf real)))) := sorry --non-trivial
lemma new_lemma_167670 (h0 : group (comm_group linarith.comp)) : is_simple_group (comm_group linarith.comp) := sorry --non-trivial
lemma new_lemma_167671 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (has_to_string.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_to_string.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_167672 (h0 : function.extfun Type (functor.comp topological_space add_cancel_monoid)) : @normal_space.{0} (add_cancel_monoid.{0} unsigned) (@functor.comp.run.{0 0 0} topological_space.{0} add_cancel_monoid.{0} unsigned (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} add_cancel_monoid.{0}) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_167673 (h0 : fin has_zero.zero) : @archimedean.{0} (canonically_linear_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ordered_add_comm_monoid.{0}) h0) (canonically_linear_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_167674 (h0 : add_group (has_add (has_nndist pos))) : is_add_cyclic (has_add (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_167675 (h1 : group (measurable_space num)) : group.fg (measurable_space num) := sorry --non-trivial
lemma new_lemma_167676 (h0 : list (has_zero num)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_167677 (h0 : semiring (has_add (has_neg (has_neg linarith.comp)))) : is_noetherian_ring (has_add (has_neg (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_167678 (h0 : topological_space (has_zero (finset unsigned))) : irreducible_space (has_zero (finset unsigned)) := sorry --non-trivial
lemma new_lemma_167679 (h0 : topological_space (has_zero (option pos))) : sequential_space (has_zero (option pos)) := sorry --non-trivial
lemma new_lemma_167680 (h0 : topological_space (finset (option (option ennreal)))) : t1_space (finset (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_167681 (h0 : monoid (distrib_lattice (random_gen linarith.ineq))) : monoid.fg (distrib_lattice (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_167682 (h0 : ring (canonically_ordered_monoid (has_Inf linarith.comp))) : is_principal_ideal_ring (canonically_ordered_monoid (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_167683 (h0 : group (has_one (has_top unsigned))) : normalizer_condition (has_one (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_167684 (h0 : functor.add_const (ring (add_group num)) unsigned) : @is_principal_ideal_ring.{0} (add_group.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (add_group.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_167685 (h0 : topological_space (has_pos_part (sub_neg_monoid Type))) : topological_space.separable_space (has_pos_part (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_167686 (h0 : monoid (option num)) : monoid.fg (option num) := sorry --non-trivial
lemma new_lemma_167687 (h0 : complete_lattice (comm_group (has_neg Type))) : is_atomistic (comm_group (has_neg Type)) := sorry --non-trivial
lemma new_lemma_167688 (h0 : list (has_zero (has_neg Type))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_167689 (h0 : functor.comp topological_space has_neg_part name) : @totally_separated_space.{0} (has_neg_part.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg_part.{0} name h0)  := sorry --non-trivial
lemma new_lemma_167690 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_167691 (h0 : add_group (simple_graph (has_add (has_Inf (boolean_algebra.core Type))))) : is_add_cyclic (simple_graph (has_add (has_Inf (boolean_algebra.core Type)))) := sorry --non-trivial
lemma new_lemma_167692 (h0 : functor.add_const (topological_space (comm_group pos)) linarith.comp) : @preirreducible_space.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_167693 (h0 : group (non_assoc_semiring unsigned)) : is_cyclic (non_assoc_semiring unsigned) := sorry --non-trivial
lemma new_lemma_167694 (h0 : group (random_gen (with_bot (random_gen string_imp)))) : is_cyclic (random_gen (with_bot (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_167695 (h0 : topological_space (has_compl (random_gen (random_gen char)))) : path_connected_space (has_compl (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_167696 (h0 : functor.add_const (add_group (has_Inf pos)) pos) : @is_add_cyclic.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (has_Inf.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_167697 (h0 : group (has_Inf (has_add (ring pos)))) : normalizer_condition (has_Inf (has_add (ring pos))) := sorry --non-trivial
lemma new_lemma_167698 (h0 : ring (option (option ennreal))) : strong_rank_condition (option (option ennreal)) := sorry --non-trivial
lemma new_lemma_167699 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (linear_ordered_cancel_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (linear_ordered_cancel_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_167700 (h0 : topological_space (boolean_algebra.core (boolean_algebra.core linarith.comp))) : preirreducible_space (boolean_algebra.core (boolean_algebra.core linarith.comp)) := sorry --non-trivial
lemma new_lemma_167701 (h0 : monoid (semigroup (ring Type))) : monoid.fg (semigroup (ring Type)) := sorry --non-trivial
lemma new_lemma_167702 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (linear_ordered_comm_group.{0} empty) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (linear_ordered_comm_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_167703 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (semigroup.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_167704 (h0 : topological_space (comm_group (mul_zero_class environment.implicit_infer_kind))) : path_connected_space (comm_group (mul_zero_class environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_167705 (h0 : not (has_mem.mem (with_bot empty) has_emptyc.emptyc -> false)) : @is_add_cyclic.{0} (with_bot.{0} empty) (@finset.pi.empty.{1 0} Type add_group.{0} (with_bot.{0} empty) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_bot.{0} empty) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_167706 (h0 : ring (has_neg_part pos)) : is_principal_ideal_ring (has_neg_part pos) := sorry --non-trivial
lemma new_lemma_167707 (h0 : group (plift congr_arg_kind)) : group.fg (plift congr_arg_kind) := sorry --non-trivial
lemma new_lemma_167708 (h0 : ring (add_left_cancel_monoid fun_info)) : strong_rank_condition (add_left_cancel_monoid fun_info) := sorry --non-trivial
lemma new_lemma_167709 (h3 : topological_space (non_unital_non_assoc_semiring to_additive.value_type)) : path_connected_space (non_unital_non_assoc_semiring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_167710 (h0 : complete_lattice (uniform_space (random_gen char))) : complete_lattice.is_Sup_finite_compact (uniform_space (random_gen char)) := sorry --non-trivial
lemma new_lemma_167711 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (canonically_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_167712 (h0 : topological_space (distrib_lattice string_imp)) : totally_disconnected_space (distrib_lattice string_imp) := sorry --non-trivial
lemma new_lemma_167713 (h0 : function.extfun Type ring) : @is_domain.{0} (add_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_167714 (h0 : functor.add_const (group (has_nndist pos)) name) : @group.fg.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_nndist.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_167715 (h0 : functor.add_const (function.extfun (Type 1) topological_space) (has_Inf linarith.comp)) : @irreducible_space.{1} Type (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) (has_Inf.{0} linarith.comp) h0) Type)  := sorry --non-trivial
lemma new_lemma_167716 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (has_bot.{0} num) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (has_bot.{0} num))  := sorry --non-trivial
lemma new_lemma_167717 (h0 : ring (has_top (random_gen linarith.ineq))) : strong_rank_condition (has_top (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_167718 (h0 : complete_lattice (measurable_space (random_gen (random_gen (random_gen num))))) : is_atomistic (measurable_space (random_gen (random_gen (random_gen num)))) := sorry --non-trivial
lemma new_lemma_167719 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (add_left_cancel_semigroup.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_left_cancel_semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_167720 (h0 : ring (has_neg (option (option (option ennreal))))) : rank_condition (has_neg (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_167721 (h0 : functor.add_const (group (normed_comm_ring linarith.comp)) Type) : @is_cyclic.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (group.{0} (normed_comm_ring.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_167722 (h0 : complete_lattice (has_top (semiring unsigned))) : complete_lattice.is_Sup_finite_compact (has_top (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_167723 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} auto.case_option (@function.extfun_app.{2 1} Type add_monoid.{0} h0 auto.case_option)  := sorry --non-trivial
lemma new_lemma_167724 (h0 : complete_lattice (normed_comm_ring (finset linarith.comp))) : complete_lattice.is_Sup_finite_compact (normed_comm_ring (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_167725 (h0 : function.extfun Type topological_space) : @normal_space.{0} (filter.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (filter.{0} empty))  := sorry --non-trivial
lemma new_lemma_167726 (h0 h1 : list std_gen) : list.is_rotated h0 h1 := sorry --non-trivial
lemma new_lemma_167727 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (has_neg_part.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_167728 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_to_string ennreal)) num) : @unique_factorization_monoid.{0} (has_to_string.{0} ennreal) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_to_string.{0} ennreal)) num h0)  := sorry --non-trivial
lemma new_lemma_167729 (h0 : functor.add_const (function.extfun Type topological_space) (finset Type)) : @preirreducible_space.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) (finset.{1} Type) h0) (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_167730 (h0 : function.extfun Type group) : @is_cyclic.{0} (normed_group.{0} (linear_ordered_add_comm_group.{0} (has_inv.{0} (comm_ring.{0} (has_inv.{0} fun_info))))) (@function.extfun_app.{2 1} Type group.{0} h0 (normed_group.{0} (linear_ordered_add_comm_group.{0} (has_inv.{0} (comm_ring.{0} (has_inv.{0} fun_info))))))  := sorry --non-trivial
lemma new_lemma_167731 (h1 : uniform_space (has_compl linarith.ineq)) : complete_space (has_compl linarith.ineq) := sorry --non-trivial
lemma new_lemma_167732 (h0 : function.extfun Type (functor.add_const (complete_lattice (add_cancel_comm_monoid empty)))) : @is_atomistic.{0} (add_cancel_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_cancel_comm_monoid.{0} empty)) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (complete_lattice.{0} (add_cancel_comm_monoid.{0} empty))) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_167733 (h0 : topological_space (canonically_ordered_monoid (has_bot Type))) : discrete_topology (canonically_ordered_monoid (has_bot Type)) := sorry --non-trivial
lemma new_lemma_167734 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @discrete_topology.{0} (has_top.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_top.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_167735 (h0 : functor.add_const (topological_space (normed_linear_ordered_group empty)) (semiring num)) : @preirreducible_space.{0} (normed_linear_ordered_group.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_linear_ordered_group.{0} empty)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_167736 (h0 : functor.add_const (filter (semigroup Type)) pos) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_167737 (h0 : functor.add_const (complete_lattice pos) unsigned) : @is_compactly_generated.{0} pos (@functor.add_const.run.{0 0} (complete_lattice.{0} pos) unsigned h0)  := sorry --non-trivial
lemma new_lemma_167738 (h0 : functor.add_const (topological_space (complete_linear_order congr_arg_kind)) num) : @irreducible_space.{0} (complete_linear_order.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_linear_order.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_167739 (h0 : finset (has_pos_part (has_Inf pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_167740 (h0 : function.extfun Type (functor.add_const (function.extfun Type topological_space))) : @regular_space.{0} (add_comm_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) environment.implicit_infer_kind (@function.extfun_app.{2 2} Type (functor.add_const.{1 0} (function.extfun.{2 1} Type topological_space.{0})) h0 environment.implicit_infer_kind)) (add_comm_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_167741 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : is_principal_ideal_ring real := sorry --non-trivial
lemma new_lemma_167742 (h0 : functor.add_const (topological_space (semiring num)) (semiring (semiring empty))) : @discrete_topology.{0} (semiring.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (semiring.{0} num)) (semiring.{0} (semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_167743 (h0 : cancel_comm_monoid_with_zero (normed_lattice_add_comm_group real)) : unique_factorization_monoid (normed_lattice_add_comm_group real) := sorry --non-trivial
lemma new_lemma_167744 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_top.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_top.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_167745 (h2 : ring (add_comm_semigroup (mul_one_class char))) : strong_rank_condition (add_comm_semigroup (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_167746 (h0 : functor.add_const (group (has_pos_part real)) real) : @normalizer_condition.{0} (has_pos_part.{0} real) (@functor.add_const.run.{0 0} (group.{0} (has_pos_part.{0} real)) real h0)  := sorry --non-trivial
lemma new_lemma_167747 (h0 : group (has_zero (boolean_algebra (has_neg linarith.comp)))) : normalizer_condition (has_zero (boolean_algebra (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_167748 (h0 : group (ordered_comm_ring (finset (finset linarith.comp)))) : normalizer_condition (ordered_comm_ring (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_167749 (h0 : ring (add_cancel_comm_monoid char)) : is_domain (add_cancel_comm_monoid char) := sorry --non-trivial
lemma new_lemma_167750 (h0 : function.extfun Type (functor.comp topological_space cancel_monoid)) : @regular_space.{0} (cancel_monoid.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} cancel_monoid.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} cancel_monoid.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_167751 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_bot.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_bot.{0} real))  := sorry --non-trivial
lemma new_lemma_167752 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (preorder.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (preorder.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_167753 (h0 : set (non_unital_non_assoc_semiring to_additive.value_type)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_167754 (h1 : set (set string.iterator_imp)) (h2 : set string.iterator_imp) : measurable_space.dynkin_system.generate_has h1 h2 := sorry --non-trivial
lemma new_lemma_167755 (h0 : not (function.extfun Type topological_space -> false)) : @totally_separated_space.{0} (partial_order.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (partial_order.{0} num))  := sorry --non-trivial
lemma new_lemma_167756 (h0 : topological_space (complete_distrib_lattice name)) : path_connected_space (complete_distrib_lattice name) := sorry --non-trivial
lemma new_lemma_167757 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (has_emptyc.{0} (random_gen.{0} (has_inv.{0} (has_inv.{0} linarith.comp_source)))) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_emptyc.{0} (random_gen.{0} (has_inv.{0} (has_inv.{0} linarith.comp_source)))))  := sorry --non-trivial
lemma new_lemma_167758 (h0 : ordered_comm_monoid (has_Inf (has_Inf pos))) : has_exists_mul_of_le (has_Inf (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_167759 (h0 : complete_lattice (has_add (has_add (has_add name)))) : is_compactly_generated (has_add (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_167760 (h0 : functor.add_const (group (normed_comm_ring name)) pos) : @group.fg.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (group.{0} (normed_comm_ring.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_167761 (h0 : group (semigroup (has_neg (has_neg (has_neg (has_neg linarith.comp)))))) : is_cyclic (semigroup (has_neg (has_neg (has_neg (has_neg linarith.comp))))) := sorry --non-trivial
lemma new_lemma_167762 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (has_emptyc num)) := sorry --non-trivial
lemma new_lemma_167763 (h0 : topological_space (mul_zero_class name)) : sequential_space (mul_zero_class name) := sorry --non-trivial
lemma new_lemma_167764 (h0 : ring (pseudo_metric_space unsigned)) : is_domain (pseudo_metric_space unsigned) := sorry --non-trivial
lemma new_lemma_167765 (h0 : uniform_space (add_comm_monoid (option pos))) : complete_space (add_comm_monoid (option pos)) := sorry --non-trivial
lemma new_lemma_167766 (h0 : group (linear_ordered_add_comm_group (has_nnnorm linarith.ineq))) : group.fg (linear_ordered_add_comm_group (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_167767 (h0 : complete_lattice (with_one (has_top fun_info))) : complete_lattice.is_Sup_finite_compact (with_one (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_167768 (h0 : function.extfun (Type 1) filter) : countable_Inter_filter (function.extfun_app h0 (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_167769 (h0 : ring (add_monoid (fintype (random_gen string_imp)))) : strong_rank_condition (add_monoid (fintype (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_167770 (h0 : functor.add_const (add_group (ordered_comm_monoid Type)) (ring Type)) : @is_add_cyclic.{1} (ordered_comm_monoid.{1} Type) (@functor.add_const.run.{1 1} (add_group.{1} (ordered_comm_monoid.{1} Type)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_167771 (h0 : ordered_add_comm_monoid (ordered_comm_monoid name)) : archimedean (ordered_comm_monoid name) := sorry --non-trivial
lemma new_lemma_167772 (h0 : has_top num -> has_top num -> Prop) : is_strict_order (has_top num) h0 := sorry --non-trivial
lemma new_lemma_167773 (h0 : uniform_space (monoid (option num))) : complete_space (monoid (option num)) := sorry --non-trivial
lemma new_lemma_167774 (h0 : ring (semi_normed_ring linarith.comp_source)) : rank_condition (semi_normed_ring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_167775 (h0 : complete_lattice (id string_imp)) : is_compactly_generated (id string_imp) := sorry --non-trivial
lemma new_lemma_167776 (h0 : group (canonically_linear_ordered_monoid name)) : group.fg (canonically_linear_ordered_monoid name) := sorry --non-trivial
lemma new_lemma_167777 (h0 : topological_space (has_to_string (has_add pos))) : totally_disconnected_space (has_to_string (has_add pos)) := sorry --non-trivial
lemma new_lemma_167778 (h0 : functor.add_const (list (finset pos)) pos) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_167779 (h0 : topological_space (normed_group (random_gen num))) : totally_separated_space (normed_group (random_gen num)) := sorry --non-trivial
lemma new_lemma_167780 (h0 : monoid (with_one unsigned)) : monoid.fg (with_one unsigned) := sorry --non-trivial
lemma new_lemma_167781 (h0 : ordered_comm_monoid (complete_distrib_lattice unsigned)) : has_exists_mul_of_le (complete_distrib_lattice unsigned) := sorry --non-trivial
lemma new_lemma_167782 (h0 : functor.add_const (add_monoid (canonically_linear_ordered_monoid name)) name) : @add_monoid.fg.{0} (canonically_linear_ordered_monoid.{0} name) (@functor.add_const.run.{0 0} (add_monoid.{0} (canonically_linear_ordered_monoid.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_167783 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (add_right_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (add_right_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_167784 (h0 : topological_space (generalized_boolean_algebra (has_Inf pos))) : locally_compact_space (generalized_boolean_algebra (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_167785 (h1 : preorder (mul_one_class char)) (h2 : set (mul_one_class char)) : set.is_pwo h2 := sorry --non-trivial
lemma new_lemma_167786 (h0 : semiring (simple_graph linarith.comp)) : is_noetherian_ring (simple_graph linarith.comp) := sorry --non-trivial
lemma new_lemma_167787 (h0 : fin has_zero.zero) : @strong_rank_condition.{0} (ordered_comm_monoid.{0} real) (@function.extfun_app.{2 1} Type ring.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ring.{0}) (@function.extfun_app.{1 1} nat fin (@matrix.vec_empty.{0} (function.extfun.{1 1} nat fin) h0) (@has_zero.zero.{0} nat nat.has_zero))) (ordered_comm_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_167788 (h0 : add_group (distrib_lattice (has_nnnorm (has_nnnorm to_additive.value_type)))) : is_add_cyclic (distrib_lattice (has_nnnorm (has_nnnorm to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_167789 (h0 : functor.add_const (group (semigroup environment.implicit_infer_kind)) linarith.comp) : @group.fg.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (semigroup.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_167790 (h0 : not (ring (random_gen congr_arg_kind) -> false)) : @is_domain.{0} (random_gen.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (ring.{0} (random_gen.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_167791 (h1 : function.extfun Type ring) : @strong_rank_condition.{0} (has_top.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h1 (has_top.{0} num))  := sorry --non-trivial
lemma new_lemma_167792 (h0 : topological_space (has_add (ordered_comm_monoid real))) : path_connected_space (has_add (ordered_comm_monoid real)) := sorry --non-trivial
lemma new_lemma_167793 (h0 : topological_space (sub_neg_monoid linarith.comp)) : locally_compact_space (sub_neg_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_167794 (h0 : fin has_zero.zero) : @t1_space.{1} (simple_graph.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (simple_graph.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_167795 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (generalized_boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (generalized_boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_167796 (h0 : topological_space (has_star empty)) : topological_space.separable_space (has_star empty) := sorry --non-trivial
lemma new_lemma_167797 (h0 : function.extfun (Type 1) (functor.comp topological_space mul_zero_class)) : @sequential_space.{1} (mul_zero_class.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} mul_zero_class.{1} Type (@function.extfun_app.{3 2} (Type 1) (functor.comp.{1 1 1} topological_space.{1} mul_zero_class.{1}) h0 Type))  := sorry --non-trivial
lemma new_lemma_167798 (h1 : add_group (nondiscrete_normed_field std_gen)) : is_add_cyclic (nondiscrete_normed_field std_gen) := sorry --non-trivial
lemma new_lemma_167799 (h0 : ordered_comm_monoid (has_to_string (finset pos))) : has_exists_mul_of_le (has_to_string (finset pos)) := sorry --non-trivial
lemma new_lemma_167800 (h0 : finset (has_neg_part (option unsigned))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_167801 (h0 : list (preorder num) -> Prop) (h1 : Exists (fun (x : list (preorder num)), h0 x)) : list.nodup (classical.some h1) := sorry --non-trivial
lemma new_lemma_167802 (h0 : monoid (has_Inf (has_Inf linarith.comp))) : monoid.fg (has_Inf (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_167803 (h0 : topological_space (non_assoc_semiring (option (option empty)))) : path_connected_space (non_assoc_semiring (option (option empty))) := sorry --non-trivial
lemma new_lemma_167804 (h0 : functor.add_const (topological_space (has_nndist linarith.comp)) pos) : @normal_space.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_167805 (h0 : topological_space (ordered_comm_monoid num)) : totally_separated_space (ordered_comm_monoid num) := sorry --non-trivial
lemma new_lemma_167806 (h0 : group (has_star (semiring (semiring (semiring (semiring (semiring empty))))))) : is_cyclic (has_star (semiring (semiring (semiring (semiring (semiring empty)))))) := sorry --non-trivial
lemma new_lemma_167807 (h0 : cancel_comm_monoid_with_zero (has_pos_part (has_bot (sub_neg_monoid real)))) : unique_factorization_monoid (has_pos_part (has_bot (sub_neg_monoid real))) := sorry --non-trivial
lemma new_lemma_167808 (h0 : topological_space (linear_ordered_comm_group (option ennreal))) : totally_disconnected_space (linear_ordered_comm_group (option ennreal)) := sorry --non-trivial
lemma new_lemma_167809 (h0 : list std_gen) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_167810 (h0 : fin has_zero.zero) : @t0_space.{1} (has_pos_part.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (has_pos_part.{1} Type)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_167811 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (encodable.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (encodable.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_167812 (h0 : topological_space (has_union (semiring (semiring unsigned)))) : totally_disconnected_space (has_union (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_167813 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @irreducible_space.{0} (has_top.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_top.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_167814 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (has_union.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_union.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_167815 (h0 : function.extfun Type (functor.add_const (topological_space (plift empty)))) : @path_connected_space.{1} (plift.{1} empty) (@functor.add_const.run.{1 0} (topological_space.{1} (plift.{1} empty)) empty (@function.extfun_app.{2 2} Type (functor.add_const.{1 0} (topological_space.{1} (plift.{1} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_167816 (h0 : functor.add_const (filter (canonically_ordered_comm_semiring pos)) (has_neg (ring (ring pos)))) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_167817 (h0 : topological_space (has_pos_part (has_Inf (has_Inf name)))) : topological_space.separable_space (has_pos_part (has_Inf (has_Inf name))) := sorry --non-trivial
lemma new_lemma_167818 (h1 : topological_space (add_comm_semigroup char)) : totally_disconnected_space (add_comm_semigroup char) := sorry --non-trivial
lemma new_lemma_167819 (h0 : topological_space (has_ssubset (has_top to_additive.value_type))) : path_connected_space (has_ssubset (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_167820 (h0 : topological_space (complete_linear_order (semiring (semiring num)))) : topological_space.separable_space (complete_linear_order (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_167821 (h0 : list (ordered_comm_monoid Type)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_167822 (h0 : functor.add_const (topological_space (is_R_or_C unsigned)) empty) : @preirreducible_space.{0} (is_R_or_C.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (is_R_or_C.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_167823 (h1 : complete_lattice (complete_semilattice_Sup linarith.comp)) : is_atomistic (complete_semilattice_Sup linarith.comp) := sorry --non-trivial
lemma new_lemma_167824 (h0 : functor.add_const (function.extfun Type complete_lattice) Type) : @is_atomistic.{0} (has_nndist.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type complete_lattice.{0}) Type h0) (has_nndist.{0} name))  := sorry --non-trivial
lemma new_lemma_167825 (h0 : sub_neg_monoid (has_pos_part (has_Inf real)) -> sub_neg_monoid (has_pos_part (has_Inf real)) -> Prop) : is_per (sub_neg_monoid (has_pos_part (has_Inf real))) h0 := sorry --non-trivial
lemma new_lemma_167826 (h0 : functor.add_const (ring (semiring congr_arg_kind)) unsigned) : @strong_rank_condition.{0} (semiring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ring.{0} (semiring.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_167827 (h0 : topological_space (random_gen (has_inner linarith.comp (has_norm (has_norm linarith.comp))))) : normal_space (random_gen (has_inner linarith.comp (has_norm (has_norm linarith.comp)))) := sorry --non-trivial
lemma new_lemma_167828 (h0 : set (has_lt (mul_one_class string_imp))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_167829 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (has_union.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_union.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_167830 (h1 : group (comm_ring (mul_one_class reducibility_hints))) : is_cyclic (comm_ring (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_167831 (h0 : function.extfun (Type 1) complete_lattice) : @complete_lattice.is_Sup_finite_compact.{1} (has_neg.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} h0 (has_neg.{1} Type))  := sorry --non-trivial
lemma new_lemma_167832 (h0 : topological_space (linear_ordered_semiring (semiring (semiring empty)))) : totally_disconnected_space (linear_ordered_semiring (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_167833 (h0 : topological_space (group_with_zero (option ennreal))) : preconnected_space (group_with_zero (option ennreal)) := sorry --non-trivial
lemma new_lemma_167834 (h0 : uniform_space (pseudo_emetric_space empty)) : separated_space (pseudo_emetric_space empty) := sorry --non-trivial
lemma new_lemma_167835 (h0 : fin has_zero.zero) : @is_cyclic.{0} (ordered_comm_ring.{0} name) (@matrix.vec_empty.{0} (group.{0} (ordered_comm_ring.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_167836 (h0 : not (group (has_ssubset fun_info) -> false)) : @is_cyclic.{0} (has_ssubset.{0} fun_info) (@classical.by_contradiction'.{1} (group.{0} (has_ssubset.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_167837 (h0 : function.extfun (finset Type) (has_mem.mem (metric_space linarith.comp))) : @discrete_topology.{0} (metric_space.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (metric_space.{0} linarith.comp) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (metric_space.{0} linarith.comp)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_167838 (h0 : finset (has_norm empty)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_167839 (h0 : topological_space (has_compl (random_gen (has_nnnorm (has_inv char))))) : totally_disconnected_space (has_compl (random_gen (has_nnnorm (has_inv char)))) := sorry --non-trivial
lemma new_lemma_167840 (h0 h1 : list (add_comm_semigroup enat)) : list.is_infix h0 h1 := sorry --non-trivial
lemma new_lemma_167841 (h0 : function.extfun Type ring) : @rank_condition.{0} (monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_167842 (h0 : topological_space (add_right_cancel_monoid unsigned)) : totally_separated_space (add_right_cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_167843 (h0 : functor.add_const (list (has_neg environment.implicit_infer_kind)) linarith.comp) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_167844 (h0 : topological_space (boolean_algebra (has_add (cancel_monoid environment.implicit_infer_kind)))) : preirreducible_space (boolean_algebra (has_add (cancel_monoid environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_167845 (h0 : list (comm_ring (random_gen linarith.ineq))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_167846 (h0 : add_group (has_Inf (has_nndist (has_neg name)))) : is_add_cyclic (has_Inf (has_nndist (has_neg name))) := sorry --non-trivial
lemma new_lemma_167847 (h0 : topological_space (semigroup (finset linarith.comp))) : irreducible_space (semigroup (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_167848 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (complete_semilattice_Sup linarith.ineq)) := sorry --non-trivial
lemma new_lemma_167849 (h0 : uniform_space (linear_ordered_comm_group num)) : complete_space (linear_ordered_comm_group num) := sorry --non-trivial
lemma new_lemma_167850 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (with_bot.{0} string_imp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (with_bot.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_167851 (h0 : ring (complete_distrib_lattice (has_add (ring linarith.comp)))) : is_principal_ideal_ring (complete_distrib_lattice (has_add (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_167852 (h0 : topological_space (has_add (ring (boolean_algebra linarith.comp)))) : discrete_topology (has_add (ring (boolean_algebra linarith.comp))) := sorry --non-trivial
lemma new_lemma_167853 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (measure_theory.measure_space.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (measure_theory.measure_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_167854 (h0 : not (function.extfun Type complete_lattice -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_emptyc.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (has_emptyc.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_167855 (h0 : functor.add_const (topological_space (ordered_comm_ring name)) pos) : @totally_separated_space.{0} (ordered_comm_ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_167856 (h0 : ring (measurable_space (random_gen fun_info))) : is_domain (measurable_space (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_167857 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @loc_path_connected_space.{0} (has_nndist.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (has_nndist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_167858 (h0 : functor.add_const (ordered_comm_monoid (has_add linarith.comp)) (has_nndist (ring linarith.comp))) : @has_exists_mul_of_le.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_add.{0} linarith.comp)) (has_nndist.{0} (ring.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_167859 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_compactly_generated.{0} (distrib_lattice.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (distrib_lattice.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_167860 (h0 : ring (linear_ordered_semiring (semiring (has_top unsigned)))) : strong_rank_condition (linear_ordered_semiring (semiring (has_top unsigned))) := sorry --non-trivial
lemma new_lemma_167861 (h0 : finset (boolean_algebra.core pos)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_167862 (h0 : not (topological_space (has_ssubset enat) -> false)) : @t0_space.{0} (has_ssubset.{0} enat) (@classical.by_contradiction'.{1} (topological_space.{0} (has_ssubset.{0} enat)) h0)  := sorry --non-trivial
lemma new_lemma_167863 (h0 : ring (distrib_lattice (has_top (random_gen fun_info)))) : rank_condition (distrib_lattice (has_top (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_167864 (h0 : ring (semi_normed_comm_ring (mul_one_class string.iterator_imp))) : rank_condition (semi_normed_comm_ring (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_167865 (h0 : topological_space (has_lt (has_nnnorm reducibility_hints))) : t0_space (has_lt (has_nnnorm reducibility_hints)) := sorry --non-trivial
lemma new_lemma_167866 (h1 : ring (has_nnnorm (group_with_zero linarith.comp_source))) : rank_condition (has_nnnorm (group_with_zero linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_167867 (h0 : function.extfun nat fin) : @group.fg.{0} (ordered_comm_ring.{0} pos) (@matrix.vec_empty.{0} (group.{0} (ordered_comm_ring.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_167868 (h0 : topological_space (pseudo_metric_space (finset ennreal))) : totally_disconnected_space (pseudo_metric_space (finset ennreal)) := sorry --non-trivial
lemma new_lemma_167869 (h1 : function.extfun (finset Type) (has_mem.mem (with_one linarith.comp_source))) : @path_connected_space.{0} (with_one.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_one.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_one.{0} linarith.comp_source)) h1 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_167870 (h0 : topological_space (mul_zero_class (has_neg (has_nndist (has_neg ennreal))))) : path_connected_space (mul_zero_class (has_neg (has_nndist (has_neg ennreal)))) := sorry --non-trivial
lemma new_lemma_167871 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (normed_comm_ring.{0} ennreal) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (normed_comm_ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_167872 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring unsigned)) pos) : @loc_path_connected_space.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_167873 (h0 : filter (linear_ordered_field empty)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_167874 (h0 : not (monoid (has_norm to_additive.value_type) -> false)) : @monoid.fg.{0} (has_norm.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (monoid.{0} (has_norm.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_167875 (h0 : uniform_space (random_gen num)) : complete_space (random_gen num) := sorry --non-trivial
lemma new_lemma_167876 (h0 : function.extfun (Type 1) complete_lattice) : @complete_lattice.is_Sup_finite_compact.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} h0 (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_167877 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (ordered_ring (option (option (option num))))) := sorry --non-trivial
lemma new_lemma_167878 (h0 : list (left_cancel_monoid (semiring congr_arg_kind))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_167879 (h0 : functor.add_const (monoid (has_to_string name)) name) : @monoid.fg.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (monoid.{0} (has_to_string.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_167880 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (filter.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (filter.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_167881 (h0 : semiring (random_gen (semiring unsigned))) : is_noetherian_ring (random_gen (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_167882 (h0 : ordered_cancel_add_comm_monoid unsigned -> ordered_cancel_add_comm_monoid unsigned -> Prop) : is_antisymm (ordered_cancel_add_comm_monoid unsigned) h0 := sorry --non-trivial
lemma new_lemma_167883 (h0 : uniform_space (has_union (semiring linarith.comp))) : separated_space (has_union (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_167884 (h0 : not (complete_lattice (has_compl (topological_space linarith.comp_source)) -> false)) : @is_compactly_generated.{0} (has_compl.{0} (topological_space.{0} linarith.comp_source)) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_compl.{0} (topological_space.{0} linarith.comp_source))) h0)  := sorry --non-trivial
lemma new_lemma_167885 (h0 : functor.add_const (topological_space (finset pos)) Type) : @normal_space.{0} (finset.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (finset.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_167886 (h0 : function.extfun (finset Type) (has_mem.mem (semiring linarith.comp_source))) : @irreducible_space.{0} (semiring.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (semiring.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} linarith.comp_source)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_167887 (h0 : topological_space (has_top (has_norm (has_norm empty)))) : totally_disconnected_space (has_top (has_norm (has_norm empty))) := sorry --non-trivial
lemma new_lemma_167888 (h0 : topological_space (has_star (semiring (semiring unsigned)))) : discrete_topology (has_star (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_167889 (h1 : topological_space (has_ssubset linarith.ineq)) : t0_space (has_ssubset linarith.ineq) := sorry --non-trivial
lemma new_lemma_167890 (h0 : group (add_cancel_monoid environment.implicit_infer_kind)) : group.fg (add_cancel_monoid environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_167891 (h0 : ring (with_bot (has_norm linarith.comp))) : strong_rank_condition (with_bot (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_167892 (h0 : topological_space (id linarith.comp)) : irreducible_space (id linarith.comp) := sorry --non-trivial
lemma new_lemma_167893 (h0 : functor.add_const (ring (ring pos)) (has_Inf pos)) : @is_domain.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (ring.{0} pos)) (has_Inf.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_167894 (h0 : functor.add_const (ring (has_star empty)) (semiring num)) : @is_principal_ideal_ring.{0} (has_star.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (has_star.{0} empty)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_167895 (h0 : add_group (has_pos_part (finset pos))) : is_add_cyclic (has_pos_part (finset pos)) := sorry --non-trivial
lemma new_lemma_167896 (h0 : topological_space (has_Inf (ring name))) : totally_separated_space (has_Inf (ring name)) := sorry --non-trivial
lemma new_lemma_167897 (h0 : uniform_space (has_emptyc (measurable_space empty))) : complete_space (has_emptyc (measurable_space empty)) := sorry --non-trivial
lemma new_lemma_167898 (h0 : functor.add_const (complete_lattice (has_neg_part unsigned)) pos) : @is_atomistic.{0} (has_neg_part.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_neg_part.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_167899 (h1 : ring (topological_space (comm_ring char))) : is_domain (topological_space (comm_ring char)) := sorry --non-trivial
lemma new_lemma_167900 (h0 : ring (lattice (mul_one_class (mul_one_class linarith.comp_source)))) : rank_condition (lattice (mul_one_class (mul_one_class linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_167901 (h0 : topological_space (generalized_boolean_algebra (has_Inf Type))) : regular_space (generalized_boolean_algebra (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_167902 (h1 : not (uniform_space linarith.comp -> false)) : @complete_space.{0} linarith.comp (@classical.by_contradiction'.{1} (uniform_space.{0} linarith.comp) h1)  := sorry --non-trivial
lemma new_lemma_167903 (h0 : complete_lattice (canonically_linear_ordered_monoid (option pos))) : is_atomistic (canonically_linear_ordered_monoid (option pos)) := sorry --non-trivial
lemma new_lemma_167904 (h1 : complete_lattice (semi_normed_ring reducibility_hints)) : complete_lattice.is_Sup_finite_compact (semi_normed_ring reducibility_hints) := sorry --non-trivial
lemma new_lemma_167905 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @preconnected_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (boolean_algebra.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_167906 (h0 : filter (filter (option (option (option (option (option num))))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_167907 (h0 : ring (ring (mul_zero_class pos))) : is_principal_ideal_ring (ring (mul_zero_class pos)) := sorry --non-trivial
lemma new_lemma_167908 (h0 : add_group (generalized_boolean_algebra pos)) : is_add_cyclic (generalized_boolean_algebra pos) := sorry --non-trivial
lemma new_lemma_167909 (h0 : ring (linear_ordered_field (option pos))) : strong_rank_condition (linear_ordered_field (option pos)) := sorry --non-trivial
lemma new_lemma_167910 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_to_string.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} num))  := sorry --non-trivial
lemma new_lemma_167911 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (has_Sup.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_Sup.{0} empty))  := sorry --non-trivial
lemma new_lemma_167912 (h0 : not (topological_space (has_sub linarith.comp) -> false)) : @preirreducible_space.{0} (has_sub.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (has_sub.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_167913 (h0 : ring (sub_neg_monoid (has_add (has_add pos)))) : is_domain (sub_neg_monoid (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_167914 (h0 : ordered_comm_monoid (has_zero (has_to_string linarith.comp))) : has_exists_mul_of_le (has_zero (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_167915 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (linear_ordered_add_comm_group.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (linear_ordered_add_comm_group.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_167916 (h0 : complete_lattice (has_compl (random_gen reducibility_hints))) : is_compactly_generated (has_compl (random_gen reducibility_hints)) := sorry --non-trivial
lemma new_lemma_167917 (h0 : has_mem.mem (linear_ordered_semiring empty) has_emptyc.emptyc) : @is_compactly_generated.{0} (linear_ordered_semiring.{0} empty) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (linear_ordered_semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_167918 (h0 : functor.comp topological_space complete_distrib_lattice name) : @discrete_topology.{0} (complete_distrib_lattice.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} complete_distrib_lattice.{0} name h0)  := sorry --non-trivial
lemma new_lemma_167919 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} (semi_normed_comm_ring.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (semi_normed_comm_ring.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_167920 (h0 : finset (add_cancel_monoid (has_neg_part pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_167921 (h0 : topological_space (pseudo_metric_space name)) : preconnected_space (pseudo_metric_space name) := sorry --non-trivial
lemma new_lemma_167922 (h0 : functor.add_const (group (canonically_ordered_comm_semiring linarith.comp)) (finset pos)) : @normalizer_condition.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (canonically_ordered_comm_semiring.{0} linarith.comp)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_167923 (h0 : functor.add_const (functor.add_const (topological_space pos) linarith.comp) (has_neg (has_neg pos))) : @normal_space.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) linarith.comp (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (topological_space.{0} pos) linarith.comp) (has_neg.{0} (has_neg.{0} pos)) h0))  := sorry --non-trivial
lemma new_lemma_167924 (h4 : topological_space (semi_normed_ring (comm_ring fun_info))) : path_connected_space (semi_normed_ring (comm_ring fun_info)) := sorry --non-trivial
lemma new_lemma_167925 (h0 : group (add_comm_monoid unsigned)) : is_simple_group (add_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_167926 (h0 : topological_space (comm_ring (random_gen linarith.ineq))) : path_connected_space (comm_ring (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_167927 (h0 : functor.add_const (group (measurable_space.dynkin_system congr_arg_kind)) congr_arg_kind) : @normalizer_condition.{0} (measurable_space.dynkin_system.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (group.{0} (measurable_space.dynkin_system.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_167928 (h0 : topological_space (add_cancel_monoid (add_cancel_monoid environment.implicit_infer_kind))) : t1_space (add_cancel_monoid (add_cancel_monoid environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_167929 (h0 : complete_lattice (has_top (add_semigroup to_additive.value_type))) : complete_lattice.is_Sup_finite_compact (has_top (add_semigroup to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_167930 (h0 : topological_space (has_inter (normed_comm_ring empty))) : path_connected_space (has_inter (normed_comm_ring empty)) := sorry --non-trivial
lemma new_lemma_167931 (h0 : not (list (has_emptyc (has_inv linarith.comp_source)) -> false)) : list.nodup (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_167932 (h0 : functor.add_const (function.extfun (Type 1) filter) environment.implicit_infer_kind) : filter.ne_bot (function.extfun_app (functor.add_const.run h0) (has_add Type)) := sorry --non-trivial
lemma new_lemma_167933 (h0 : ring (cancel_monoid (has_to_string ennreal))) : strong_rank_condition (cancel_monoid (has_to_string ennreal)) := sorry --non-trivial
lemma new_lemma_167934 (h0 : topological_space (boolean_algebra (finset linarith.comp))) : totally_separated_space (boolean_algebra (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_167935 (h0 : functor.add_const (ring (finset Type)) Type) : @rank_condition.{1} (finset.{1} Type) (@functor.add_const.run.{1 1} (ring.{1} (finset.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_167936 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (monoid.{0} num) (@function.extfun_app.{2 1} Type semiring.{0} h0 (monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_167937 (h0 : topological_space (boolean_algebra name)) : preconnected_space (boolean_algebra name) := sorry --non-trivial
lemma new_lemma_167938 (h0 : functor.add_const (filter (boolean_algebra pos)) (has_Inf (finset linarith.comp))) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_167939 (h1 : ring (semi_normed_ring reducibility_hints)) : strong_rank_condition (semi_normed_ring reducibility_hints) := sorry --non-trivial
lemma new_lemma_167940 (h0 : functor.add_const (monoid (has_zero Type)) linarith.comp) : @monoid.fg.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (monoid.{1} (has_zero.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_167941 (h0 : topological_space (has_nndist (has_add (has_add (has_to_string Type))))) : normal_space (has_nndist (has_add (has_add (has_to_string Type)))) := sorry --non-trivial
lemma new_lemma_167942 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @preirreducible_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (semigroup.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_167943 (h0 : topological_space (linear_ordered_comm_group (option unsigned))) : irreducible_space (linear_ordered_comm_group (option unsigned)) := sorry --non-trivial
lemma new_lemma_167944 (h0 : ring (add_cancel_comm_monoid (mul_one_class string_imp))) : rank_condition (add_cancel_comm_monoid (mul_one_class string_imp)) := sorry --non-trivial
lemma new_lemma_167945 (h1 : not (topological_space (with_zero fun_info) -> false)) : @totally_disconnected_space.{0} (with_zero.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (with_zero.{0} fun_info)) h1)  := sorry --non-trivial
lemma new_lemma_167946 (h0 : not (complete_lattice (semiring num) -> false)) : @is_atomistic.{0} (semiring.{0} num) (@classical.by_contradiction'.{1} (complete_lattice.{0} (semiring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_167947 (h0 : not (topological_space (has_emptyc linarith.ineq) -> false)) : @totally_disconnected_space.{0} (has_emptyc.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (has_emptyc.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_167948 (h0 : ring (linear_ordered_add_comm_group char)) : is_domain (linear_ordered_add_comm_group char) := sorry --non-trivial
lemma new_lemma_167949 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (monoid_with_zero.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (monoid_with_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_167950 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @discrete_topology.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_167951 (h0 : topological_space (linear_ordered_comm_ring (semiring num))) : totally_separated_space (linear_ordered_comm_ring (semiring num)) := sorry --non-trivial
lemma new_lemma_167952 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (monoid_with_zero.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (monoid_with_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_167953 (h0 : ring (with_bot (has_top num))) : strong_rank_condition (with_bot (has_top num)) := sorry --non-trivial
lemma new_lemma_167954 (h0 : topological_space (linear_ordered_field (option (option (option pos))))) : preconnected_space (linear_ordered_field (option (option (option pos)))) := sorry --non-trivial
lemma new_lemma_167955 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (simple_graph.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (simple_graph.{0} num))  := sorry --non-trivial
lemma new_lemma_167956 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @irreducible_space.{0} (has_emptyc.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_emptyc.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_167957 (h0 : has_mem.mem (function.extfun (Type 1)) has_emptyc.emptyc) : @is_domain.{1} Type (@function.extfun_app.{3 2} (Type 1) ring.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) (@finset.pi.empty.{3 2} ((Type 1 → Type 1) → Type 2) (function.extfun.{3 3} (Type 1 → Type 1)) (function.extfun.{3 2} (Type 1)) h0) ring.{1}) Type)  := sorry --non-trivial
lemma new_lemma_167958 (h0 : functor.add_const (group (semigroup empty)) empty) : @group.fg.{0} (semigroup.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (semigroup.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_167959 (h0 : semiring linarith.ineq) (h1 : ideal linarith.ineq) : ideal.is_prime h1 := sorry --non-trivial
lemma new_lemma_167960 (h0 : has_mem.mem uniform_space has_emptyc.emptyc) : @complete_space.{0} (random_gen.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) uniform_space.{0} h0) (random_gen.{0} num))  := sorry --non-trivial
lemma new_lemma_167961 (h0 : add_group (has_norm (has_norm fun_info))) : is_add_cyclic (has_norm (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_167962 (h0 : functor.add_const (uniform_space (has_to_string linarith.comp)) pos) : @separated_space.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_to_string.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_167963 (h0 : finset (has_add (option ennreal))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_167964 (h0 : list (linear_ordered_cancel_comm_monoid (semiring empty))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_167965 (h0 : functor.add_const (ring (mul_zero_class unsigned)) (semiring (semiring num))) : @strong_rank_condition.{0} (mul_zero_class.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (mul_zero_class.{0} unsigned)) (semiring.{0} (semiring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_167966 (h1 : not (function.extfun Type group -> false)) : @is_cyclic.{0} (with_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h1) (with_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_167967 (h0 : functor.add_const (ring (has_nndist ennreal)) ennreal) : @is_domain.{0} (has_nndist.{0} ennreal) (@functor.add_const.run.{0 0} (ring.{0} (has_nndist.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_167968 (h1 : topological_space (metric_space linarith.comp)) : discrete_topology (metric_space linarith.comp) := sorry --non-trivial
lemma new_lemma_167969 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (normed_comm_ring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_167970 (h0 : functor.add_const (topological_space (comm_group linarith.comp)) Type) : @preconnected_space.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (comm_group.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_167971 (h0 : topological_space (complete_linear_order congr_arg_kind)) : preirreducible_space (complete_linear_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_167972 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_167973 (h0 : not (group (has_nnnorm string.iterator_imp) -> false)) : @is_cyclic.{0} (has_nnnorm.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (group.{0} (has_nnnorm.{0} string.iterator_imp)) h0)  := sorry --non-trivial
lemma new_lemma_167974 (h0 : topological_space (ordered_comm_monoid pos)) : preconnected_space (ordered_comm_monoid pos) := sorry --non-trivial
lemma new_lemma_167975 (h0 : ring (semigroup (boolean_algebra name))) : is_principal_ideal_ring (semigroup (boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_167976 (h0 : ring (uniform_space (metric_space (metric_space (metric_space char))))) : strong_rank_condition (uniform_space (metric_space (metric_space (metric_space char)))) := sorry --non-trivial
lemma new_lemma_167977 (h0 : functor.add_const (semiring (semigroup Type)) linarith.comp) : @is_noetherian_ring.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (semiring.{1} (semigroup.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_167978 (h0 : functor.add_const (topological_space (has_to_string pos)) Type) : @locally_compact_space.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_to_string.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_167979 (h0 : topological_space (has_nndist (has_neg_part pos))) : loc_path_connected_space (has_nndist (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_167980 (h0 : topological_space (has_norm to_additive.value_type)) : path_connected_space (has_norm to_additive.value_type) := sorry --non-trivial
lemma new_lemma_167981 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (complete_distrib_lattice.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_distrib_lattice.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_167982 (h0 : functor.add_const (complete_lattice (free_add_monoid unsigned)) num) : @is_atomistic.{0} (free_add_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (free_add_monoid.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_167983 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (semiring.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (semiring.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_167984 (h0 : function.extfun Type topological_space) : @t1_space.{0} (add_comm_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_167985 (h0 : topological_space (generalized_boolean_algebra (sub_neg_monoid (has_bot pos)))) : preirreducible_space (generalized_boolean_algebra (sub_neg_monoid (has_bot pos))) := sorry --non-trivial
lemma new_lemma_167986 (h0 : group (mul_zero_class (boolean_algebra.core name))) : group.fg (mul_zero_class (boolean_algebra.core name)) := sorry --non-trivial
lemma new_lemma_167987 (h0 : ordered_add_comm_monoid (boolean_algebra.core congr_arg_kind)) : archimedean (boolean_algebra.core congr_arg_kind) := sorry --non-trivial
lemma new_lemma_167988 (h0 : functor.comp topological_space has_zero name) : @irreducible_space.{0} (has_zero.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} has_zero.{0} name h0)  := sorry --non-trivial
lemma new_lemma_167989 (h0 : topological_space (free_add_monoid unsigned)) : discrete_topology (free_add_monoid unsigned) := sorry --non-trivial
lemma new_lemma_167990 (h0 : ordered_comm_monoid (has_add (has_to_string (has_to_string (ring linarith.comp))))) : has_exists_mul_of_le (has_add (has_to_string (has_to_string (ring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_167991 (h0 : group (has_inv (has_nnnorm (random_gen to_additive.value_type)))) : group.fg (has_inv (has_nnnorm (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_167992 (h0 : cancel_comm_monoid_with_zero (ring (option (option empty)))) : unique_factorization_monoid (ring (option (option empty))) := sorry --non-trivial
lemma new_lemma_167993 (h0 : topological_space (has_nndist (semigroup linarith.comp))) : irreducible_space (has_nndist (semigroup linarith.comp)) := sorry --non-trivial
lemma new_lemma_167994 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (ordered_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (ordered_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_167995 (h0 : not (function.extfun Type topological_space -> false)) : @irreducible_space.{0} (with_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (with_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_167996 (h0 : functor.add_const (topological_space (comm_group pos)) (finset ennreal)) : @loc_path_connected_space.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} pos)) (finset.{0} ennreal) h0)  := sorry --non-trivial
lemma new_lemma_167997 (h0 : topological_space (complete_distrib_lattice (ring (finset Type)))) : loc_path_connected_space (complete_distrib_lattice (ring (finset Type))) := sorry --non-trivial
lemma new_lemma_167998 (h0 : functor.add_const (function.extfun Type ordered_add_comm_monoid) Type) : @archimedean.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ordered_add_comm_monoid.{0}) Type h0) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_167999 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_semilattice_Sup.{0} congr_arg_kind))  := sorry --non-trivial
