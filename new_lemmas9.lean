import imports
lemma new_lemma_72000 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring Type)) pos) : @loc_path_connected_space.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (canonically_ordered_comm_semiring.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_72001 (h0 : functor.add_const (topological_space (cancel_monoid name)) linarith.comp) : @locally_compact_space.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_72002 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (ordered_comm_monoid.{0} real) (@function.extfun_app.{2 1} Type ring.{0} h0 (ordered_comm_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_72003 (h0 : function.extfun Type ring) : @rank_condition.{0} (normed_group.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (normed_group.{0} num))  := sorry --non-trivial
lemma new_lemma_72004 (h0 : ring (has_ssubset (has_top linarith.ineq))) : rank_condition (has_ssubset (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_72005 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (add_cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (add_cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_72006 (h0 : finset (boolean_algebra (has_Inf (has_pos_part linarith.comp)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_72007 (h0 : function.extfun nat fin) : @regular_space.{0} (has_Inf.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (has_Inf.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_72008 (h0 : functor.add_const (add_group (cancel_monoid unsigned)) unsigned) : @is_add_cyclic.{0} (cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (add_group.{0} (cancel_monoid.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_72009 (h0 : function.extfun nat fin) : @is_cyclic.{0} (has_add.{0} name) (@matrix.vec_empty.{0} (group.{0} (has_add.{0} name)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_72010 (h0 : functor.add_const (topological_space (boolean_algebra unsigned)) name) : @sequential_space.{0} (boolean_algebra.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_72011 (h0 : not (topological_space (denumerable to_additive.value_type) -> false)) : @path_connected_space.{0} (denumerable.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (denumerable.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_72012 (h0 : topological_space (linear_ordered_comm_group_with_zero (mul_one_class string.iterator_imp))) (h1 : preorder (linear_ordered_comm_group_with_zero (mul_one_class string.iterator_imp))) : order_closed_topology (linear_ordered_comm_group_with_zero (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_72013 (h0 : functor.add_const (ring (mul_zero_class congr_arg_kind)) empty) : @strong_rank_condition.{0} (mul_zero_class.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ring.{0} (mul_zero_class.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_72014 (h0 : monoid (has_to_string (boolean_algebra environment.implicit_infer_kind))) : monoid.fg (has_to_string (boolean_algebra environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_72015 (h0 : ordered_add_comm_monoid (has_star unsigned)) : archimedean (has_star unsigned) := sorry --non-trivial
lemma new_lemma_72016 (h0 : topological_space (add_group (semiring unsigned))) : t1_space (add_group (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_72017 (h0 : functor.add_const (ring (generalized_boolean_algebra linarith.comp)) pos) : @rank_condition.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (generalized_boolean_algebra.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_72018 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (linear_ordered_semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (linear_ordered_semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_72019 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (with_bot.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (with_bot.{0} empty))  := sorry --non-trivial
lemma new_lemma_72020 (h0 : monoid (complete_semilattice_Sup (has_one num))) : monoid.fg (complete_semilattice_Sup (has_one num)) := sorry --non-trivial
lemma new_lemma_72021 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (canonically_ordered_add_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_72022 (h0 : uniform_space (nondiscrete_normed_field (mul_one_class (add_comm_semigroup (mul_one_class ereal))))) : complete_space (nondiscrete_normed_field (mul_one_class (add_comm_semigroup (mul_one_class ereal)))) := sorry --non-trivial
lemma new_lemma_72023 (h1 : ring (distrib_lattice (random_gen char))) : rank_condition (distrib_lattice (random_gen char)) := sorry --non-trivial
lemma new_lemma_72024 (h0 : topological_space (has_Inf (ring (has_add (ordered_ring Type))))) : normal_space (has_Inf (ring (has_add (ordered_ring Type)))) := sorry --non-trivial
lemma new_lemma_72025 (h0 : topological_space (distrib (normed_field fun_info))) : path_connected_space (distrib (normed_field fun_info)) := sorry --non-trivial
lemma new_lemma_72026 (h0 : function.extfun Type group) : @normalizer_condition.{0} (complete_distrib_lattice.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (complete_distrib_lattice.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_72027 (h0 : ring (has_dist ennreal)) : is_principal_ideal_ring (has_dist ennreal) := sorry --non-trivial
lemma new_lemma_72028 (h0 : group (has_union (has_top empty))) : normalizer_condition (has_union (has_top empty)) := sorry --non-trivial
lemma new_lemma_72029 (h0 : ring (semigroup (has_nndist (has_add (ring linarith.comp))))) : is_principal_ideal_ring (semigroup (has_nndist (has_add (ring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_72030 (h0 : ring (has_neg_part (has_add (finset (finset name))))) : rank_condition (has_neg_part (has_add (finset (finset name)))) := sorry --non-trivial
lemma new_lemma_72031 (h0 : functor.add_const (function.extfun Type ring) environment.implicit_infer_kind) : @strong_rank_condition.{0} (comm_group.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) environment.implicit_infer_kind h0) (comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_72032 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} (has_ssubset.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (has_ssubset.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_72033 (h0 : list (generalized_boolean_algebra (has_Inf real))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_72034 (h0 : topological_space (has_le environment.projection_info)) : path_connected_space (has_le environment.projection_info) := sorry --non-trivial
lemma new_lemma_72035 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (generalized_boolean_algebra.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (generalized_boolean_algebra.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_72036 (h0 : topological_space Type) : loc_path_connected_space Type := sorry --non-trivial
lemma new_lemma_72037 (h0 : functor.add_const (list (boolean_algebra linarith.comp)) linarith.comp) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_72038 (h0 : functor.add_const (topological_space (add_cancel_monoid environment.implicit_infer_kind)) pos) : @totally_disconnected_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_72039 (h1 : has_lt (add_comm_semigroup (measure_theory.measure_space char))) : no_max_order (add_comm_semigroup (measure_theory.measure_space char)) := sorry --non-trivial
lemma new_lemma_72040 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (semigroup.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_72041 (h0 : topological_space (bin_tree (semiring unsigned))) : normal_space (bin_tree (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_72042 (h0 : list (boolean_algebra (has_to_string (has_add (has_neg environment.implicit_infer_kind))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_72043 (h1 : not (topological_space (has_top fun_info) -> false)) : @path_connected_space.{0} (has_top.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (has_top.{0} fun_info)) h1)  := sorry --non-trivial
lemma new_lemma_72044 (h0 : not (uniform_space (topological_space (has_nnnorm fun_info)) -> false)) : @complete_space.{0} (topological_space.{0} (has_nnnorm.{0} fun_info)) (@classical.by_contradiction'.{1} (uniform_space.{0} (topological_space.{0} (has_nnnorm.{0} fun_info))) h0)  := sorry --non-trivial
lemma new_lemma_72045 (h0 : topological_space (group_with_zero congr_arg_kind)) : preconnected_space (group_with_zero congr_arg_kind) := sorry --non-trivial
lemma new_lemma_72046 (h0 : topological_space (has_neg (has_add (has_add (add_cancel_monoid (has_zero (has_neg pos))))))) : sequential_space (has_neg (has_add (has_add (add_cancel_monoid (has_zero (has_neg pos)))))) := sorry --non-trivial
lemma new_lemma_72047 (h0 : topological_space (has_lt (mul_one_class (mul_one_class (mul_one_class enat))))) (h1 : preorder (has_lt (mul_one_class (mul_one_class (mul_one_class enat))))) : order_topology (has_lt (mul_one_class (mul_one_class (mul_one_class enat)))) := sorry --non-trivial
lemma new_lemma_72048 (h0 : ring (ring (finset (has_neg (has_neg pos))))) : rank_condition (ring (finset (has_neg (has_neg pos)))) := sorry --non-trivial
lemma new_lemma_72049 (h0 : group (finset (finset environment.implicit_infer_kind))) : group.fg (finset (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_72050 (h0 : function.extfun Type list) : list.tfae (function.extfun_app h0 Prop) := sorry --non-trivial
lemma new_lemma_72051 (h0 : function.extfun Type (functor.add_const (complete_lattice (has_pos_part linarith.comp)))) : @complete_lattice.is_Sup_finite_compact.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_pos_part.{0} linarith.comp)) name (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (complete_lattice.{0} (has_pos_part.{0} linarith.comp))) h0 name))  := sorry --non-trivial
lemma new_lemma_72052 (h0 : uniform_space (has_add to_additive.value_type)) : complete_space (has_add to_additive.value_type) := sorry --non-trivial
lemma new_lemma_72053 (h0 : functor.add_const (semiring (normed_linear_ordered_group empty)) unsigned) : @is_noetherian_ring.{0} (normed_linear_ordered_group.{0} empty) (@functor.add_const.run.{0 0} (semiring.{0} (normed_linear_ordered_group.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_72054 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (linear_order unsigned)) := sorry --non-trivial
lemma new_lemma_72055 (h0 : function.extfun Type group) : @normalizer_condition.{0} (metric_space.{0} (semiring.{0} empty)) (@function.extfun_app.{2 1} Type group.{0} h0 (metric_space.{0} (semiring.{0} empty)))  := sorry --non-trivial
lemma new_lemma_72056 (h0 : not (complete_lattice (has_lt char) -> false)) : @is_compactly_generated.{0} (has_lt.{0} char) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_lt.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_72057 (h1 : not (topological_space (topological_space linarith.comp_source) -> false)) : @totally_disconnected_space.{0} (topological_space.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (topological_space.{0} linarith.comp_source)) h1)  := sorry --non-trivial
lemma new_lemma_72058 (h0 : group (has_top (has_top fun_info))) : group.fg (has_top (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_72059 (h0 : functor.add_const (finset (has_pos_part linarith.comp)) Type) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_72060 (h0 : list (monoid (option (option empty)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_72061 (h0 : linear_ordered_ring congr_arg_kind) (h1 : topological_space (floor_ring congr_arg_kind)) : totally_separated_space (floor_ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_72062 (h0 : has_mem.mem (has_norm empty) has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} (has_norm.{0} empty) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (has_norm.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_72063 (h2 : set (ereal -> mul_one_class enat)) : set.separates_points h2 := sorry --non-trivial
lemma new_lemma_72064 (h0 : functor.add_const (ring (has_neg pos)) name) : @is_principal_ideal_ring.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_neg.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_72065 (h0 : add_group (normed_lattice_add_comm_group (has_add pos))) : is_add_cyclic (normed_lattice_add_comm_group (has_add pos)) := sorry --non-trivial
lemma new_lemma_72066 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (dlist.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (dlist.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_72067 (h0 : complete_lattice (ordered_comm_ring (sub_neg_monoid name))) : is_compactly_generated (ordered_comm_ring (sub_neg_monoid name)) := sorry --non-trivial
lemma new_lemma_72068 (h0 : functor.add_const (ring (boolean_algebra linarith.comp)) (finset Type)) : @rank_condition.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 1} (ring.{0} (boolean_algebra.{0} linarith.comp)) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_72069 (h0 : group (ordered_comm_monoid (has_add (has_add (sub_neg_monoid (has_Inf real)))))) : normalizer_condition (ordered_comm_monoid (has_add (has_add (sub_neg_monoid (has_Inf real))))) := sorry --non-trivial
lemma new_lemma_72070 (h0 : not (group (normed_group empty) -> false)) : @normalizer_condition.{0} (normed_group.{0} empty) (@classical.by_contradiction'.{1} (group.{0} (normed_group.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_72071 (h0 : not (topological_space (has_nnnorm char) -> false)) : @totally_disconnected_space.{0} (has_nnnorm.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (has_nnnorm.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_72072 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (canonically_ordered_comm_semiring.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (canonically_ordered_comm_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_72073 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_simple_group.{0} (canonically_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (canonically_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_72074 (h1 : ring ordering) : is_domain ordering := sorry --non-trivial
lemma new_lemma_72075 (h0 : group (has_Sup empty)) : is_cyclic (has_Sup empty) := sorry --non-trivial
lemma new_lemma_72076 (h0 : topological_space (ordered_cancel_add_comm_monoid ennreal)) : totally_separated_space (ordered_cancel_add_comm_monoid ennreal) := sorry --non-trivial
lemma new_lemma_72077 (h3 : uniform_space (semi_normed_ring to_additive.value_type)) : complete_space (semi_normed_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_72078 (h0 : complete_lattice (has_nndist (has_add (has_add (has_add environment.implicit_infer_kind))))) : is_compactly_generated (has_nndist (has_add (has_add (has_add environment.implicit_infer_kind)))) := sorry --non-trivial
lemma new_lemma_72079 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (has_nndist.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_nndist.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_72080 (h0 : group (has_Inf (has_Inf pos))) : is_simple_group (has_Inf (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_72081 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (filter.{0} empty) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (filter.{0} empty))  := sorry --non-trivial
lemma new_lemma_72082 (h0 : complete_lattice (semi_normed_ring char)) : is_compactly_generated (semi_normed_ring char) := sorry --non-trivial
lemma new_lemma_72083 (h0 : topological_space (simple_graph (boolean_algebra.core Type))) : totally_disconnected_space (simple_graph (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_72084 (h0 : ordered_comm_monoid (normed_comm_ring (has_neg linarith.comp))) : has_exists_mul_of_le (normed_comm_ring (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_72085 (h0 : topological_space (normed_comm_ring (ring linarith.comp))) : sequential_space (normed_comm_ring (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_72086 (h0 : ring (ordered_comm_ring linarith.comp)) : is_domain (ordered_comm_ring linarith.comp) := sorry --non-trivial
lemma new_lemma_72087 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (add_cancel_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_cancel_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_72088 (h0 : uniform_space (partial_order (semiring congr_arg_kind))) : complete_space (partial_order (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_72089 (h0 : topological_space (with_bot (has_top fun_info))) : irreducible_space (with_bot (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_72090 (h0 : ordered_comm_monoid (boolean_algebra (has_to_string unsigned))) : has_exists_mul_of_le (boolean_algebra (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_72091 (h0 : functor.comp topological_space has_neg linarith.comp) : @locally_compact_space.{0} (has_neg.{0} linarith.comp) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_72092 (h0 : topological_space (semigroup (has_neg_part Type))) : irreducible_space (semigroup (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_72093 (h0 : ordered_comm_monoid (has_zero (has_to_string (has_to_string Type)))) : has_exists_mul_of_le (has_zero (has_to_string (has_to_string Type))) := sorry --non-trivial
lemma new_lemma_72094 (h0 : group (add_cancel_monoid unsigned)) : normalizer_condition (add_cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_72095 (h0 : topological_space (canonically_ordered_comm_semiring (boolean_algebra pos))) : t1_space (canonically_ordered_comm_semiring (boolean_algebra pos)) := sorry --non-trivial
lemma new_lemma_72096 (h0 : functor.add_const (topological_space nnreal) unsigned) : totally_separated_space nnreal := sorry --non-trivial
lemma new_lemma_72097 (h1 : Prop) (h2 : not h1) (h3 : h1) : @no_max_order.{0} (add_comm_semigroup.{0} enat) (@not.elim.{1} h1 (has_lt.{0} (add_comm_semigroup.{0} enat)) h2 h3)  := sorry --trivial
lemma new_lemma_72098 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @normalizer_condition.{0} (add_right_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) group.{0}) (add_right_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_72099 (h0 : has_coe (nondiscrete_normed_field enat) Prop) (h1 : nondiscrete_normed_field enat) : @coe_b.{1 1} (nondiscrete_normed_field.{0} enat) Prop h0 h1  := sorry --non-trivial
lemma new_lemma_72100 (h0 : topological_space (distrib (has_neg string.iterator_imp))) : path_connected_space (distrib (has_neg string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_72101 (h0 : ordered_add_comm_monoid (ordered_comm_monoid (has_nndist (has_nndist pos)))) : archimedean (ordered_comm_monoid (has_nndist (has_nndist pos))) := sorry --non-trivial
lemma new_lemma_72102 (h2 : topological_space (complete_semilattice_Sup congr_arg_kind)) : t0_space (complete_semilattice_Sup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_72103 (h0 : function.extfun (Type 1) add_group) : @is_add_cyclic.{1} (normed_lattice_add_comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_group.{1} h0 (normed_lattice_add_comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_72104 (h0 : topological_space (semigroup Type)) : t0_space (semigroup Type) := sorry --non-trivial
lemma new_lemma_72105 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_72106 (h0 : group (option (option (option (option pos))))) : is_cyclic (option (option (option (option pos)))) := sorry --non-trivial
lemma new_lemma_72107 (h0 : topological_space (semi_normed_comm_ring std_gen)) : path_connected_space (semi_normed_comm_ring std_gen) := sorry --non-trivial
lemma new_lemma_72108 (h0 : topological_space (generalized_boolean_algebra (sub_neg_monoid linarith.comp))) : regular_space (generalized_boolean_algebra (sub_neg_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_72109 (h0 : complete_lattice (option (has_to_string (has_to_string pos)))) : complete_lattice.is_Sup_finite_compact (option (has_to_string (has_to_string pos))) := sorry --non-trivial
lemma new_lemma_72110 (h0 : uniform_space (with_one linarith.ineq)) : complete_space (with_one linarith.ineq) := sorry --non-trivial
lemma new_lemma_72111 (h0 : ring (ordered_comm_ring (has_add (has_add pos)))) : is_domain (ordered_comm_ring (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_72112 (h0 : ordered_comm_monoid (has_neg (finset (finset name)))) : has_exists_mul_of_le (has_neg (finset (finset name))) := sorry --non-trivial
lemma new_lemma_72113 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (canonically_linear_ordered_monoid.{0} num) (@function.extfun_app.{2 1} Type monoid.{0} h0 (canonically_linear_ordered_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_72114 (h0 : topological_space (has_bot pos)) : totally_disconnected_space (has_bot pos) := sorry --non-trivial
lemma new_lemma_72115 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (group_with_zero.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (group_with_zero.{0} num))  := sorry --non-trivial
lemma new_lemma_72116 (h0 : complete_lattice (has_sub (semiring num))) : is_atomistic (has_sub (semiring num)) := sorry --non-trivial
lemma new_lemma_72117 (h0 : topological_space (mul_zero_class (finset (has_nndist (finset Type))))) : topological_space.separable_space (mul_zero_class (finset (has_nndist (finset Type)))) := sorry --non-trivial
lemma new_lemma_72118 (h0 : ring (cancel_monoid (comm_group ennreal))) : rank_condition (cancel_monoid (comm_group ennreal)) := sorry --non-trivial
lemma new_lemma_72119 (h0 : functor.add_const (topological_space (finset Type)) pos) : @t1_space.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (finset.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_72120 (h0 : uniform_space (pseudo_metric_space (option congr_arg_kind))) : separated_space (pseudo_metric_space (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_72121 (h0 : not (topological_space (non_unital_non_assoc_semiring to_additive.value_type) -> false)) : @t0_space.{0} (non_unital_non_assoc_semiring.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (non_unital_non_assoc_semiring.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_72122 (h0 : add_monoid (has_neg ennreal)) : add_monoid.fg (has_neg ennreal) := sorry --non-trivial
lemma new_lemma_72123 (h0 : filter (monoid_with_zero pos)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_72124 (h0 : functor.add_const (topological_space (has_zero Type)) environment.implicit_infer_kind) : @regular_space.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_zero.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_72125 (h0 : fin has_zero.zero) : @separated_space.{0} (ordered_comm_monoid.{0} real) (@matrix.vec_empty.{0} (uniform_space.{0} (ordered_comm_monoid.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_72126 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring linarith.comp)) (has_pos_part Type)) : @sequential_space.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (canonically_ordered_comm_semiring.{0} linarith.comp)) (has_pos_part.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_72127 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (monoid_with_zero.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} h0 (monoid_with_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_72128 (h1 : complete_lattice (random_gen char)) : complete_lattice.is_Sup_finite_compact (random_gen char) := sorry --non-trivial
lemma new_lemma_72129 (h0 : functor.add_const (function.extfun (Type 1) topological_space) environment.implicit_infer_kind) : @preirreducible_space.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) environment.implicit_infer_kind h0) (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_72130 (h0 : functor.add_const (uniform_space (has_add pos)) linarith.comp) : @complete_space.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_add.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_72131 (h0 : functor.add_const (topological_space (has_pos_part pos)) name) : @preconnected_space.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_72132 (h0 : partial_order (partial_order num) -> partial_order (partial_order num) -> Prop) : is_total (partial_order (partial_order num)) h0 := sorry --non-trivial
lemma new_lemma_72133 (h0 : ring (normed_field (normed_field (normed_field char)))) : strong_rank_condition (normed_field (normed_field (normed_field char))) := sorry --non-trivial
lemma new_lemma_72134 (h0 : functor.add_const (topological_space (has_to_string Type)) Type) : @totally_disconnected_space.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_to_string.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_72135 (h0 : add_monoid (ring (has_neg (has_neg (has_neg (has_neg linarith.comp)))))) : add_monoid.fg (ring (has_neg (has_neg (has_neg (has_neg linarith.comp))))) := sorry --non-trivial
lemma new_lemma_72136 (h0 : topological_space (has_lt linarith.comp_source)) : totally_disconnected_space (has_lt linarith.comp_source) := sorry --non-trivial
lemma new_lemma_72137 (h1 : group (measurable_space linarith.comp)) : is_cyclic (measurable_space linarith.comp) := sorry --non-trivial
lemma new_lemma_72138 (h0 : functor.add_const (ring (bin_tree (semiring (semiring (semiring (semiring (semiring unsigned))))))) empty) : @strong_rank_condition.{0} (bin_tree.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} unsigned)))))) (@functor.add_const.run.{0 0} (ring.{0} (bin_tree.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} unsigned))))))) empty h0)  := sorry --non-trivial
lemma new_lemma_72139 (h0 : has_neg (nondiscrete_normed_field string.iterator_imp)) (h1 : measurable_space (nondiscrete_normed_field string.iterator_imp)) : has_measurable_neg (nondiscrete_normed_field string.iterator_imp) := sorry --non-trivial
lemma new_lemma_72140 (h0 : complete_lattice (has_neg (option (option (option ennreal))))) : is_atomistic (has_neg (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_72141 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (has_nndist num)) := sorry --non-trivial
lemma new_lemma_72142 (h0 : ring (has_add (has_zero unsigned))) : is_principal_ideal_ring (has_add (has_zero unsigned)) := sorry --non-trivial
lemma new_lemma_72143 (h0 : function.extfun (Type 1) ordered_comm_monoid) : @has_exists_mul_of_le.{1} (has_zero.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_comm_monoid.{1} h0 (has_zero.{1} Type))  := sorry --non-trivial
lemma new_lemma_72144 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (complete_semilattice_Sup.{0} num) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (complete_semilattice_Sup.{0} num))  := sorry --non-trivial
lemma new_lemma_72145 (h0 : functor.add_const (ring (option ennreal)) ennreal) : @strong_rank_condition.{0} (option.{0} ennreal) (@functor.add_const.run.{0 0} (ring.{0} (option.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_72146 (h0 : function.extfun (finset Type) (has_mem.mem (with_bot linarith.comp_source))) : @irreducible_space.{0} (with_bot.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_bot.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_bot.{0} linarith.comp_source)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_72147 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_72148 (h0 : monoid (measurable_space (random_gen (random_gen to_additive.value_type)))) : monoid.fg (measurable_space (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_72149 (h0 : set (simple_graph linarith.comp_source)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_72150 (h0 : add_group (has_neg_part (semigroup name))) : is_add_cyclic (has_neg_part (semigroup name)) := sorry --non-trivial
lemma new_lemma_72151 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_72152 (h0 : not (ring (random_gen reducibility_hints) -> false)) : @is_domain.{0} (random_gen.{0} reducibility_hints) (@classical.by_contradiction'.{1} (ring.{0} (random_gen.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_72153 (h0 : complete_lattice environment.implicit_infer_kind) : is_compactly_generated environment.implicit_infer_kind := sorry --non-trivial
lemma new_lemma_72154 (h0 : uniform_space (has_nnnorm (random_gen (random_gen reducibility_hints)))) : complete_space (has_nnnorm (random_gen (random_gen reducibility_hints))) := sorry --non-trivial
lemma new_lemma_72155 (h0 : fin has_zero.zero) : @totally_separated_space.{0} (ordered_comm_ring.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (ordered_comm_ring.{0} real))  := sorry --non-trivial
lemma new_lemma_72156 (h0 : functor.add_const (topological_space (semigroup linarith.comp)) (boolean_algebra Type)) : @t0_space.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (semigroup.{0} linarith.comp)) (boolean_algebra.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_72157 (h0 : topological_space (measure_theory.measure_space unsigned)) : totally_disconnected_space (measure_theory.measure_space unsigned) := sorry --non-trivial
lemma new_lemma_72158 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (as_linear_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (as_linear_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_72159 (h0 : not (group (linear_ordered_semiring num) -> false)) : @normalizer_condition.{0} (linear_ordered_semiring.{0} num) (@classical.by_contradiction'.{1} (group.{0} (linear_ordered_semiring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_72160 (h0 : measurable_space (non_unital_non_assoc_semiring to_additive.value_type)) (h1 : filter (non_unital_non_assoc_semiring to_additive.value_type)) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_72161 (h0 : empty) : @is_domain.{0} (has_div.{0} reducibility_hints) (@empty.elim.{1} (ring.{0} (has_div.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_72162 (h0 : finset (id (semiring unsigned))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_72163 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (pseudo_metric_space.{0} (option.{0} ennreal)) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (pseudo_metric_space.{0} (option.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_72164 (h0 : functor.add_const (group (has_bot unsigned)) congr_arg_kind) : @normalizer_condition.{0} (has_bot.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (has_bot.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_72165 (h0 : complete_lattice (has_bot (sub_neg_monoid linarith.comp))) : complete_lattice.is_Sup_finite_compact (has_bot (sub_neg_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_72166 (h0 : topological_space (add_cancel_monoid (finset (has_neg environment.implicit_infer_kind)))) : loc_path_connected_space (add_cancel_monoid (finset (has_neg environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_72167 (h0 : ring (nondiscrete_normed_field reducibility_hints)) : is_domain (nondiscrete_normed_field reducibility_hints) := sorry --non-trivial
lemma new_lemma_72168 (h0 : ring (mul_zero_class empty)) : rank_condition (mul_zero_class empty) := sorry --non-trivial
lemma new_lemma_72169 (h0 : not (monoid (has_norm linarith.ineq) -> false)) : @monoid.fg.{0} (has_norm.{0} linarith.ineq) (@classical.by_contradiction'.{1} (monoid.{0} (has_norm.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_72170 (h0 : topological_space (has_Sup num)) : discrete_topology (has_Sup num) := sorry --non-trivial
lemma new_lemma_72171 (h0 : functor.add_const (topological_space (has_zero linarith.comp)) linarith.comp) : @loc_path_connected_space.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_72172 (h0 : functor.comp topological_space has_nndist ennreal) : @t0_space.{0} (has_nndist.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_72173 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (normed_comm_ring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_72174 (h0 : functor.comp add_monoid add_comm_monoid name) : @add_monoid.fg.{0} (add_comm_monoid.{0} name) (@functor.comp.run.{0 0 0} add_monoid.{0} add_comm_monoid.{0} name h0)  := sorry --non-trivial
lemma new_lemma_72175 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_72176 (h0 : uniform_space (canonically_ordered_comm_semiring (has_Inf (has_pos_part (finset linarith.comp))))) : separated_space (canonically_ordered_comm_semiring (has_Inf (has_pos_part (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_72177 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} (semiring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_72178 (h0 : complete_lattice (comm_group (has_to_string (has_to_string (has_add (has_to_string pos)))))) : is_compactly_generated (comm_group (has_to_string (has_to_string (has_add (has_to_string pos))))) := sorry --non-trivial
lemma new_lemma_72179 (h0 : uniform_space (ordered_comm_monoid unsigned)) : complete_space (ordered_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_72180 (h0 : topological_space (has_compl (has_compl (mul_one_class (mul_one_class char))))) : path_connected_space (has_compl (has_compl (mul_one_class (mul_one_class char)))) := sorry --non-trivial
lemma new_lemma_72181 (h0 : functor.add_const (uniform_space (has_zero pos)) (has_nndist (has_to_string environment.implicit_infer_kind))) : @separated_space.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_zero.{0} pos)) (has_nndist.{0} (has_to_string.{0} environment.implicit_infer_kind)) h0)  := sorry --non-trivial
lemma new_lemma_72182 (h0 : complete_lattice (generalized_boolean_algebra (sub_neg_monoid real))) : is_compactly_generated (generalized_boolean_algebra (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_72183 (h0 : group (has_inv (random_gen (random_gen fun_info)))) : is_cyclic (has_inv (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_72184 (h0 : uniform_space (linear_ordered_semiring fun_info)) : separated_space (linear_ordered_semiring fun_info) := sorry --non-trivial
lemma new_lemma_72185 (h0 : cancel_comm_monoid_with_zero (has_edist empty)) : unique_factorization_monoid (has_edist empty) := sorry --non-trivial
lemma new_lemma_72186 (h1 : uniform_space (has_ssubset linarith.comp_source)) : complete_space (has_ssubset linarith.comp_source) := sorry --non-trivial
lemma new_lemma_72187 (h1 : topological_space (fintype linarith.comp_source)) : path_connected_space (fintype linarith.comp_source) := sorry --non-trivial
lemma new_lemma_72188 (h0 : add_group (nondiscrete_normed_field (mul_one_class (mul_one_class string.iterator_imp)))) : is_add_cyclic (nondiscrete_normed_field (mul_one_class (mul_one_class string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_72189 (h0 : functor.add_const (group znum) (option (option (option (option unsigned))))) : @normalizer_condition.{0} znum (@functor.add_const.run.{0 0} (group.{0} znum) (option.{0} (option.{0} (option.{0} (option.{0} unsigned)))) h0)  := sorry --non-trivial
lemma new_lemma_72190 (h0 : topological_space (normed_comm_ring (has_add Type))) : regular_space (normed_comm_ring (has_add Type)) := sorry --non-trivial
lemma new_lemma_72191 (h0 : topological_space (plift unsigned)) : t0_space (plift unsigned) := sorry --non-trivial
lemma new_lemma_72192 (h1 : ring (mul_one_class char)) : is_domain (mul_one_class char) := sorry --non-trivial
lemma new_lemma_72193 (h0 : function.extfun Type topological_space) : @t0_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_72194 (h0 : topological_space (has_union to_additive.value_type)) : path_connected_space (has_union to_additive.value_type) := sorry --non-trivial
lemma new_lemma_72195 (h0 : finset (has_Inf (ring (has_neg Type)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_72196 (h0 : functor.add_const (function.extfun Type add_group) pos) : @is_add_cyclic.{0} (boolean_algebra.core.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_group.{0}) pos h0) (boolean_algebra.core.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_72197 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem uniform_space)) : @complete_space.{0} (has_one.{0} fun_info) (@function.extfun_app.{2 1} Type uniform_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) uniform_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) uniform_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_one.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_72198 (h1 : complete_lattice (id congr_arg_kind)) : is_compactly_generated (id congr_arg_kind) := sorry --non-trivial
lemma new_lemma_72199 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_72200 (h0 : function.extfun Type (functor.add_const (topological_space pos))) : @normal_space.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) linarith.comp (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} pos)) h0 linarith.comp))  := sorry --non-trivial
lemma new_lemma_72201 (h1 : ring (normed_field (has_ssubset (has_nnnorm (has_nnnorm (random_gen char)))))) : is_domain (normed_field (has_ssubset (has_nnnorm (has_nnnorm (random_gen char))))) := sorry --non-trivial
lemma new_lemma_72202 (h0 : uniform_space (has_union (semiring num))) : complete_space (has_union (semiring num)) := sorry --non-trivial
lemma new_lemma_72203 (h1 : ring (semi_normed_comm_ring environment.projection_info)) : rank_condition (semi_normed_comm_ring environment.projection_info) := sorry --non-trivial
lemma new_lemma_72204 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (has_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_72205 (h0 : group (comm_group (comm_group (comm_group (comm_group unsigned))))) : is_simple_group (comm_group (comm_group (comm_group (comm_group unsigned)))) := sorry --non-trivial
lemma new_lemma_72206 (h0 : fin has_zero.zero) : @locally_compact_space.{1} (ordered_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (ordered_comm_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_72207 (h0 : ring (has_add (has_pos_part (finset pos)))) : is_principal_ideal_ring (has_add (has_pos_part (finset pos))) := sorry --non-trivial
lemma new_lemma_72208 (h0 : ring (dlist string_imp)) : is_domain (dlist string_imp) := sorry --non-trivial
lemma new_lemma_72209 (h0 : functor.add_const (ring (add_cancel_monoid pos)) name) : @strong_rank_condition.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (add_cancel_monoid.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_72210 (h0 : ordered_add_comm_monoid (id linarith.ineq)) : archimedean (id linarith.ineq) := sorry --non-trivial
lemma new_lemma_72211 (h0 : group (has_zero (has_to_string (has_to_string linarith.comp)))) : normalizer_condition (has_zero (has_to_string (has_to_string linarith.comp))) := sorry --non-trivial
lemma new_lemma_72212 (h0 : functor.add_const (topological_space (mul_zero_class num)) num) : @topological_space.separable_space.{0} (mul_zero_class.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_72213 (h0 : functor.add_const (group (ring Type)) Type) : @is_simple_group.{1} (ring.{1} Type) (@functor.add_const.run.{1 1} (group.{1} (ring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_72214 (h0 : functor.add_const (ring (has_to_string name)) environment.implicit_infer_kind) : @is_principal_ideal_ring.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (has_to_string.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_72215 (h0 : ordered_add_comm_monoid (semiring unsigned)) : archimedean (semiring unsigned) := sorry --non-trivial
lemma new_lemma_72216 (h0 : add_group (normed_comm_ring (option (option unsigned)))) : is_add_cyclic (normed_comm_ring (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_72217 (h0 : functor.add_const (uniform_space (ordered_ring unsigned)) unsigned) : @separated_space.{0} (ordered_ring.{0} unsigned) (@functor.add_const.run.{0 0} (uniform_space.{0} (ordered_ring.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_72218 (h0 : has_lift (random_gen linarith.ineq) Prop) (h1 : random_gen linarith.ineq) : @lift.{1 1} (random_gen.{0} linarith.ineq) Prop h0 h1  := sorry --non-trivial
lemma new_lemma_72219 (h0 : group (add_cancel_monoid (has_add pos))) : is_cyclic (add_cancel_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_72220 (h0 : functor.add_const (filter (normed_comm_ring pos)) (finset (finset linarith.comp))) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_72221 (h0 : ordered_add_comm_monoid (has_pos_part linarith.comp)) : archimedean (has_pos_part linarith.comp) := sorry --non-trivial
lemma new_lemma_72222 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (linear_ordered_comm_ring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_72223 (h0 : add_group (normed_lattice_add_comm_group (finset name))) : is_add_cyclic (normed_lattice_add_comm_group (finset name)) := sorry --non-trivial
lemma new_lemma_72224 (h0 : topological_space (has_nnnorm (linear_ordered_add_comm_group linarith.ineq))) : locally_compact_space (has_nnnorm (linear_ordered_add_comm_group linarith.ineq)) := sorry --non-trivial
lemma new_lemma_72225 (h0 : fin has_zero.zero) : @is_noetherian_ring.{0} (ordered_comm_ring.{0} linarith.comp) (@matrix.vec_empty.{0} (semiring.{0} (ordered_comm_ring.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_72226 (h0 : topological_space (with_bot (semiring congr_arg_kind))) : locally_compact_space (with_bot (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_72227 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (has_bot.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_bot.{0} real))  := sorry --non-trivial
lemma new_lemma_72228 (h0 : functor.add_const (ring (finset linarith.comp)) name) : @strong_rank_condition.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (finset.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_72229 (h0 : not (topological_space (has_sub empty) -> false)) : @totally_disconnected_space.{0} (has_sub.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (has_sub.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_72230 (h0 : has_mem.mem (has_one empty) has_emptyc.emptyc) : @irreducible_space.{0} (has_one.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_one.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_72231 (h0 : functor.add_const (finset (has_zero Type)) Type) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_72232 (h0 : filter (metric_space (has_norm (semiring congr_arg_kind)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_72233 (h0 : ring (semi_normed_ring (has_ssubset fun_info))) : rank_condition (semi_normed_ring (has_ssubset fun_info)) := sorry --non-trivial
lemma new_lemma_72234 (h0 : ring (normed_group (has_norm linarith.ineq))) : strong_rank_condition (normed_group (has_norm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_72235 (h0 : finset (has_Inf (boolean_algebra.core (ordered_ring (ring Type))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_72236 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (complete_semilattice_Sup.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} h0 (complete_semilattice_Sup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_72237 (h0 : functor.add_const (topological_space (ordered_comm_monoid Type)) (ring (has_add linarith.comp))) : @regular_space.{1} (ordered_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ordered_comm_monoid.{1} Type)) (ring.{0} (has_add.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_72238 (h0 : functor.add_const (topological_space (has_add environment.implicit_infer_kind)) name) : @loc_path_connected_space.{0} (has_add.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_72239 (h0 : semiring (option (semiring (option unsigned)))) : is_noetherian_ring (option (semiring (option unsigned))) := sorry --non-trivial
lemma new_lemma_72240 (h0 : functor.add_const (topological_space (has_bot unsigned)) (option empty)) : @path_connected_space.{0} (has_bot.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_bot.{0} unsigned)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_72241 (h0 : uniform_space (has_pos_part (has_neg name))) : separated_space (has_pos_part (has_neg name)) := sorry --non-trivial
lemma new_lemma_72242 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_72243 (h0 : has_mem.mem (function.extfun Type) has_emptyc.emptyc) : @is_domain.{0} (normed_group.{0} linarith.ineq) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@finset.pi.empty.{2 1} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) (function.extfun.{2 1} Type) h0) ring.{0}) (normed_group.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_72244 (h0 : group (boolean_algebra (has_add (has_Inf (has_bot real))))) : normalizer_condition (boolean_algebra (has_add (has_Inf (has_bot real)))) := sorry --non-trivial
lemma new_lemma_72245 (h0 : ring (has_add pos)) : is_domain (has_add pos) := sorry --non-trivial
lemma new_lemma_72246 (h0 : semiring (has_star num)) : is_noetherian_ring (has_star num) := sorry --non-trivial
lemma new_lemma_72247 (h0 : topological_space ereal) (h1 : has_scalar char ereal) : properly_discontinuous_smul char ereal := sorry --non-trivial
lemma new_lemma_72248 (h0 : ring (has_nnnorm (has_nnnorm linarith.ineq))) : is_domain (has_nnnorm (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_72249 (h0 : uniform_space (has_add (add_left_cancel_monoid (with_zero to_additive.value_type)))) : complete_space (has_add (add_left_cancel_monoid (with_zero to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_72250 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (option.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (option.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_72251 (h0 : topological_space (has_add (ring environment.implicit_infer_kind))) : t0_space (has_add (ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_72252 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) linarith.comp) := sorry --non-trivial
lemma new_lemma_72253 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (has_dist.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_dist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_72254 (h3 : ring (semi_normed_ring linarith.ineq)) : rank_condition (semi_normed_ring linarith.ineq) := sorry --non-trivial
lemma new_lemma_72255 (h0 : group (comm_group (finset unsigned))) : group.fg (comm_group (finset unsigned)) := sorry --non-trivial
lemma new_lemma_72256 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @preconnected_space.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_72257 (h0 : cancel_comm_monoid_with_zero (canonically_ordered_comm_semiring name)) : unique_factorization_monoid (canonically_ordered_comm_semiring name) := sorry --non-trivial
lemma new_lemma_72258 (h0 : functor.add_const (finset (option empty)) congr_arg_kind) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_72259 (h0 : functor.comp topological_space pseudo_metric_space name) : @totally_separated_space.{0} (pseudo_metric_space.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} pseudo_metric_space.{0} name h0)  := sorry --non-trivial
lemma new_lemma_72260 (h0 : group (distrib_lattice (random_gen (random_gen to_additive.value_type)))) : is_cyclic (distrib_lattice (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_72261 (h0 : cancel_comm_monoid_with_zero (has_nndist (option unsigned))) : unique_factorization_monoid (has_nndist (option unsigned)) := sorry --non-trivial
lemma new_lemma_72262 (h0 : fin has_zero.zero) : @preirreducible_space.{0} (complete_distrib_lattice.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (complete_distrib_lattice.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_72263 (h0 : functor.add_const (complete_lattice (canonically_ordered_comm_semiring name)) environment.implicit_infer_kind) : @is_atomistic.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (canonically_ordered_comm_semiring.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_72264 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_inner.{0 0} empty num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inner.{0 0} empty num))  := sorry --non-trivial
lemma new_lemma_72265 (h0 : unsigned -> unsigned -> Prop) : well_founded h0 := sorry --non-trivial
lemma new_lemma_72266 (h0 : set (add_comm_semigroup (mul_one_class string.iterator_imp) -> fun_info)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_72267 (h0 : functor.add_const (topological_space (add_cancel_monoid linarith.comp)) pos) : @path_connected_space.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_72268 (h0 : functor.add_const (filter (has_pos_part linarith.comp)) pos) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_72269 (h0 : functor.add_const (monoid (has_neg pos)) name) : @monoid.fg.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (monoid.{0} (has_neg.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_72270 (h0 : topological_space (finset (comm_group (comm_group (semigroup pos))))) : totally_separated_space (finset (comm_group (comm_group (semigroup pos)))) := sorry --non-trivial
lemma new_lemma_72271 (h0 : functor.add_const (add_monoid (semigroup linarith.comp)) environment.implicit_infer_kind) : @add_monoid.fg.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_monoid.{0} (semigroup.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_72272 (h0 : group (denumerable fun_info)) : is_cyclic (denumerable fun_info) := sorry --non-trivial
lemma new_lemma_72273 (h0 : ring (normed_field (comm_ring (mul_one_class reducibility_hints)))) : is_domain (normed_field (comm_ring (mul_one_class reducibility_hints))) := sorry --non-trivial
lemma new_lemma_72274 (h0 : topological_space (cancel_monoid (semigroup pos))) : irreducible_space (cancel_monoid (semigroup pos)) := sorry --non-trivial
lemma new_lemma_72275 (h0 : ring (preorder unsigned)) : invariant_basis_number (preorder unsigned) := sorry --non-trivial
lemma new_lemma_72276 (h0 : ring (cancel_monoid (has_add (has_add (has_add Type))))) : is_domain (cancel_monoid (has_add (has_add (has_add Type)))) := sorry --non-trivial
lemma new_lemma_72277 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (linear_ordered_semiring.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_semiring.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_72278 (h0 : function.extfun nat fin) : @has_exists_mul_of_le.{0} (complete_distrib_lattice.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (complete_distrib_lattice.{0} pos))  := sorry --non-trivial
lemma new_lemma_72279 (h0 : topological_space (add_left_cancel_semigroup (option unsigned))) : t1_space (add_left_cancel_semigroup (option unsigned)) := sorry --non-trivial
lemma new_lemma_72280 (h0 : topological_space (has_to_string (has_add unsigned))) : topological_space.separable_space (has_to_string (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_72281 (h0 : group (linear_ordered_semiring (has_top empty))) : is_cyclic (linear_ordered_semiring (has_top empty)) := sorry --non-trivial
lemma new_lemma_72282 (h0 : group (add_comm_monoid (option (option pos)))) : is_simple_group (add_comm_monoid (option (option pos))) := sorry --non-trivial
lemma new_lemma_72283 (h0 : functor.add_const (function.extfun Type group) (has_neg (right_cancel_semigroup Type))) : @is_simple_group.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type group.{0}) (has_neg.{1} (right_cancel_semigroup.{1} Type)) h0) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_72284 (h0 : functor.add_const (function.extfun (Type 1) filter) pos) : countable_Inter_filter (function.extfun_app (functor.add_const.run h0) (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_72285 (h0 : list (normed_comm_ring (has_add (finset (comm_group name))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_72286 (h0 : ring (semiring (semiring (semiring (semiring congr_arg_kind))))) : is_domain (semiring (semiring (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_72287 (h0 : functor.add_const (topological_space (has_neg name)) Type) : @regular_space.{0} (has_neg.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_72288 (h0 : complete_lattice (complete_distrib_lattice empty)) : is_atomistic (complete_distrib_lattice empty) := sorry --non-trivial
lemma new_lemma_72289 (h0 : complete_lattice (with_one (semiring (semiring (semiring congr_arg_kind))))) : complete_lattice.is_Sup_finite_compact (with_one (semiring (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_72290 (h0 : ring (finset (ring environment.implicit_infer_kind))) : rank_condition (finset (ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_72291 (h0 : functor.add_const (finset (linear_ordered_comm_monoid_with_zero empty)) (semiring empty)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_72292 (h0 : topological_space (normed_comm_ring ennreal)) : t1_space (normed_comm_ring ennreal) := sorry --non-trivial
lemma new_lemma_72293 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (complete_distrib_lattice.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (complete_distrib_lattice.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_72294 (h0 : topological_space (linear_ordered_semiring num)) : totally_disconnected_space (linear_ordered_semiring num) := sorry --non-trivial
lemma new_lemma_72295 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (has_bot.{0} unsigned) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (has_bot.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_72296 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} (option.{0} ennreal) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) (option.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_72297 (h0 : monoid (measurable_space (semiring (semiring (semiring (semiring congr_arg_kind)))))) : monoid.fg (measurable_space (semiring (semiring (semiring (semiring congr_arg_kind))))) := sorry --non-trivial
lemma new_lemma_72298 (h0 : complete_lattice (distrib (boolean_algebra char))) : is_compactly_generated (distrib (boolean_algebra char)) := sorry --non-trivial
lemma new_lemma_72299 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring pos)) Type) : @sequential_space.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (canonically_ordered_comm_semiring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_72300 (h0 : not (filter (has_star congr_arg_kind) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_72301 (h0 : add_group (measurable_space (random_gen string_imp))) : is_add_cyclic (measurable_space (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_72302 (h0 : not (uniform_space (has_norm reducibility_hints) -> false)) : @separated_space.{0} (has_norm.{0} reducibility_hints) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_norm.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_72303 (h0 : complete_lattice (measurable_space string_imp)) : complete_lattice.is_Sup_finite_compact (measurable_space string_imp) := sorry --non-trivial
lemma new_lemma_72304 (h0 : not (ring (div_inv_monoid linarith.ineq) -> false)) : @rank_condition.{0} (div_inv_monoid.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (div_inv_monoid.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_72305 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (ordered_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_72306 (h0 : ring (denumerable (has_nnnorm reducibility_hints))) : strong_rank_condition (denumerable (has_nnnorm reducibility_hints)) := sorry --non-trivial
lemma new_lemma_72307 (h0 : monoid (has_norm num)) : monoid.fg (has_norm num) := sorry --non-trivial
lemma new_lemma_72308 (h0 : functor.add_const (complete_lattice (ordered_ring unsigned)) (option empty)) : @is_atomistic.{0} (ordered_ring.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ordered_ring.{0} unsigned)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_72309 (h0 : add_monoid (has_nndist (has_neg (has_neg environment.implicit_infer_kind)))) : add_monoid.fg (has_nndist (has_neg (has_neg environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_72310 (h0 : topological_space fun_info) (h2 : Prop) : is_irreducible (id (fun (h1 : fun_info), h2)) := sorry --non-trivial
lemma new_lemma_72311 (h0 : topological_space (boolean_algebra (has_pos_part pos))) : irreducible_space (boolean_algebra (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_72312 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (complete_linear_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (complete_linear_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_72313 (h0 : complete_lattice (has_neg (has_add name))) : is_atomistic (has_neg (has_add name)) := sorry --non-trivial
lemma new_lemma_72314 (h0 : lattice fun_info) : is_modular_lattice fun_info := sorry --non-trivial
lemma new_lemma_72315 (h0 : topological_space (ring environment.implicit_infer_kind)) : irreducible_space (ring environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_72316 (h0 : ring (has_to_string (has_neg (has_Inf Type)))) : rank_condition (has_to_string (has_neg (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_72317 (h0 : group (semigroup (has_add pos))) : normalizer_condition (semigroup (has_add pos)) := sorry --non-trivial
lemma new_lemma_72318 (h0 : not (topological_space (normed_group congr_arg_kind) -> false)) : @topological_space.separable_space.{0} (normed_group.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_group.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_72319 (h0 : add_comm_monoid (monoid ennreal) -> add_comm_monoid (monoid ennreal) -> Prop) : is_symm (add_comm_monoid (monoid ennreal)) h0 := sorry --non-trivial
lemma new_lemma_72320 (h2 : ring (with_zero to_additive.value_type)) : rank_condition (with_zero to_additive.value_type) := sorry --non-trivial
lemma new_lemma_72321 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} (has_top.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_top.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_72322 (h0 : not (complete_lattice (with_one linarith.comp) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (with_one.{0} linarith.comp) (@classical.by_contradiction'.{1} (complete_lattice.{0} (with_one.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_72323 (h0 : topological_space (is_R_or_C empty)) : t0_space (is_R_or_C empty) := sorry --non-trivial
lemma new_lemma_72324 (h0 : functor.add_const (filter (has_nndist linarith.comp)) pos) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_72325 (h0 : functor.add_const (list (boolean_algebra.core Type)) linarith.comp) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_72326 (h0 : ring (finset (option (option unsigned)))) : strong_rank_condition (finset (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_72327 (h0 : functor.comp topological_space has_to_string name) : @path_connected_space.{0} (has_to_string.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} has_to_string.{0} name h0)  := sorry --non-trivial
lemma new_lemma_72328 (h0 : functor.add_const (add_group (ring linarith.comp)) environment.implicit_infer_kind) : @is_add_cyclic.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_group.{0} (ring.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_72329 (h0 : functor.add_const (topological_space (ordered_comm_ring pos)) (has_pos_part linarith.comp)) : @t0_space.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} pos)) (has_pos_part.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_72330 (h0 : not (topological_space num -> false)) : @preconnected_space.{0} num (@classical.by_contradiction'.{1} (topological_space.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_72331 (h0 : ring ordering) : rank_condition ordering := sorry --non-trivial
lemma new_lemma_72332 (h1 : ring (distrib fun_info)) : strong_rank_condition (distrib fun_info) := sorry --non-trivial
lemma new_lemma_72333 (h0 : ring (uniform_space string.iterator_imp)) : rank_condition (uniform_space string.iterator_imp) := sorry --non-trivial
lemma new_lemma_72334 (h1 : ring (has_lt string_imp)) : rank_condition (has_lt string_imp) := sorry --non-trivial
lemma new_lemma_72335 (h0 : complete_lattice (has_top (semiring empty))) : complete_lattice.is_Sup_finite_compact (has_top (semiring empty)) := sorry --non-trivial
lemma new_lemma_72336 (h0 : functor.add_const (function.extfun Type semiring) pos) : @is_noetherian_ring.{0} (has_Inf.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type semiring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type semiring.{0}) pos h0) (has_Inf.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_72337 (h0 : functor.add_const (add_monoid (ring pos)) linarith.comp) : @add_monoid.fg.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (add_monoid.{0} (ring.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_72338 (h0 : functor.add_const (ring (complete_distrib_lattice pos)) (has_Inf name)) : @is_principal_ideal_ring.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (complete_distrib_lattice.{0} pos)) (has_Inf.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_72339 (h1 : ring (linear_ordered_semiring (random_gen (has_top fun_info)))) : rank_condition (linear_ordered_semiring (random_gen (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_72340 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @irreducible_space.{0} (random_gen.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) topological_space.{0}) (random_gen.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_72341 (h0 : function.extfun Type ring) : @is_domain.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_72342 (h0 : cancel_comm_monoid_with_zero (has_star unsigned)) : unique_factorization_monoid (has_star unsigned) := sorry --non-trivial
lemma new_lemma_72343 (h0 : topological_space (has_compl (mul_one_class (mul_one_class to_additive.value_type)))) : t0_space (has_compl (mul_one_class (mul_one_class to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_72344 (h0 : add_group (has_add (has_Inf real))) : is_add_cyclic (has_add (has_Inf real)) := sorry --non-trivial
lemma new_lemma_72345 (h0 : has_mem.mem (normed_group num) has_emptyc.emptyc) : @is_add_cyclic.{0} (normed_group.{0} num) (@finset.pi.empty.{1 0} Type add_group.{0} (normed_group.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_72346 (h0 : functor.add_const (semiring (boolean_algebra.core linarith.comp)) (ring (ring Type))) : @is_noetherian_ring.{0} (boolean_algebra.core.{0} linarith.comp) (@functor.add_const.run.{0 1} (semiring.{0} (boolean_algebra.core.{0} linarith.comp)) (ring.{1} (ring.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_72347 (h0 : functor.add_const (add_monoid (comm_group Type)) (finset Type)) : @add_monoid.fg.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 1} (add_monoid.{1} (comm_group.{1} Type)) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_72348 (h0 : ordered_comm_monoid (ring name)) : has_exists_mul_of_le (ring name) := sorry --non-trivial
lemma new_lemma_72349 (h0 : topological_space (has_add num)) : totally_separated_space (has_add num) := sorry --non-trivial
lemma new_lemma_72350 (h0 : functor.add_const (add_group (left_cancel_monoid num)) (semiring (semiring (semiring num)))) : @is_add_cyclic.{0} (left_cancel_monoid.{0} num) (@functor.add_const.run.{0 0} (add_group.{0} (left_cancel_monoid.{0} num)) (semiring.{0} (semiring.{0} (semiring.{0} num))) h0)  := sorry --non-trivial
lemma new_lemma_72351 (h0 : topological_space (generalized_boolean_algebra (has_Inf name))) : totally_separated_space (generalized_boolean_algebra (has_Inf name)) := sorry --non-trivial
lemma new_lemma_72352 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (finset.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (finset.{0} empty))  := sorry --non-trivial
lemma new_lemma_72353 (h0 : topological_space (linear_ordered_comm_monoid_with_zero congr_arg_kind)) : loc_path_connected_space (linear_ordered_comm_monoid_with_zero congr_arg_kind) := sorry --non-trivial
lemma new_lemma_72354 (h0 : functor.add_const (topological_space (left_cancel_monoid empty)) (semiring num)) : @t1_space.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} empty)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_72355 (h0 : functor.add_const (topological_space (mul_zero_class congr_arg_kind)) num) : @discrete_topology.{0} (mul_zero_class.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_72356 (h0 : functor.add_const (ring (measurable_space.dynkin_system unsigned)) unsigned) : @is_domain.{0} (measurable_space.dynkin_system.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (measurable_space.dynkin_system.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_72357 (h0 : topological_space (has_nnnorm (mul_one_class (mul_one_class string.iterator_imp)))) : path_connected_space (has_nnnorm (mul_one_class (mul_one_class string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_72358 (h2 : not (topological_space (has_inv to_additive.value_type) -> false)) : @totally_disconnected_space.{0} (has_inv.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (has_inv.{0} to_additive.value_type)) h2)  := sorry --non-trivial
lemma new_lemma_72359 (h0 : topological_space (has_inv (has_top linarith.comp_source))) : locally_compact_space (has_inv (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_72360 (h0 : list (finset (has_add pos))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_72361 (h0 : topological_space (canonically_ordered_comm_semiring (has_add unsigned))) : irreducible_space (canonically_ordered_comm_semiring (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_72362 (h0 : ring (left_cancel_monoid (semiring num))) : is_principal_ideal_ring (left_cancel_monoid (semiring num)) := sorry --non-trivial
lemma new_lemma_72363 (h0 h1 : multiset string.iterator_imp) : multiset.le h0 h1 := sorry --non-trivial
lemma new_lemma_72364 (h0 : semiring (simple_graph (ring pos))) : is_noetherian_ring (simple_graph (ring pos)) := sorry --non-trivial
lemma new_lemma_72365 (h0 : semiring (simple_graph (has_add linarith.comp))) : is_noetherian_ring (simple_graph (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_72366 (h0 : not (ring (semi_normed_ring to_additive.value_type) -> false)) : @is_domain.{0} (semi_normed_ring.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (semi_normed_ring.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_72367 (h0 : ring (has_Inf linarith.comp)) : rank_condition (has_Inf linarith.comp) := sorry --non-trivial
lemma new_lemma_72368 (h0 : functor.add_const (topological_space (cancel_monoid name)) unsigned) : @irreducible_space.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_72369 (h0 : topological_space (has_norm string_imp)) (h1 : preorder (has_norm string_imp)) : compact_Icc_space (has_norm string_imp) := sorry --non-trivial
lemma new_lemma_72370 (h0 : not (topological_space (mul_zero_class congr_arg_kind) -> false)) : @t1_space.{0} (mul_zero_class.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (mul_zero_class.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_72371 (h0 : ordered_add_comm_monoid (has_to_string (has_neg Type))) : archimedean (has_to_string (has_neg Type)) := sorry --non-trivial
lemma new_lemma_72372 (h0 : finset (has_zero (mul_zero_class pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_72373 (h0 : topological_space (measurable_space (has_norm linarith.comp))) : preirreducible_space (measurable_space (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_72374 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @complete_space.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 uniform_space.{1}) (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_72375 (h1 : function.extfun Type topological_space) : @t0_space.{0} (measurable_space.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (measurable_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_72376 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @t0_space.{1} (simple_graph.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (simple_graph.{1} Type))  := sorry --non-trivial
lemma new_lemma_72377 (h0 : monoid (filter (option (option empty)))) : monoid.fg (filter (option (option empty))) := sorry --non-trivial
lemma new_lemma_72378 (h0 : list (comm_monoid (option empty))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_72379 (h0 : fin has_zero.zero) : @preirreducible_space.{0} (ordered_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (ordered_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_72380 (h0 : uniform_space (plift (has_top (has_top (has_top empty))))) : separated_space (plift (has_top (has_top (has_top empty)))) := sorry --non-trivial
lemma new_lemma_72381 (h0 : topological_space (add_left_cancel_semigroup (semiring empty))) : normal_space (add_left_cancel_semigroup (semiring empty)) := sorry --non-trivial
lemma new_lemma_72382 (h0 : not (uniform_space (id num) -> false)) : @complete_space.{0} (@id.{2} Type num) (@classical.by_contradiction'.{1} (uniform_space.{0} (@id.{2} Type num)) h0)  := sorry --non-trivial
lemma new_lemma_72383 (h0 : functor.add_const (ring (has_add linarith.comp)) linarith.comp) : @is_domain.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_add.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_72384 (h0 : add_group (has_div string_imp)) : is_add_cyclic (has_div string_imp) := sorry --non-trivial
lemma new_lemma_72385 (h0 : ring (add_group empty)) : rank_condition (add_group empty) := sorry --non-trivial
lemma new_lemma_72386 (h0 : add_group (has_nnnorm linarith.ineq)) : is_add_cyclic (has_nnnorm linarith.ineq) := sorry --non-trivial
lemma new_lemma_72387 (h0 : group (add_cancel_monoid (has_nndist pos))) : normalizer_condition (add_cancel_monoid (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_72388 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (normed_comm_ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_72389 (h0 : group (measure_theory.measure_space congr_arg_kind)) : normalizer_condition (measure_theory.measure_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_72390 (h0 : topological_space (has_pos_part (ordered_comm_monoid (has_Inf (has_Inf Type))))) : totally_disconnected_space (has_pos_part (ordered_comm_monoid (has_Inf (has_Inf Type)))) := sorry --non-trivial
lemma new_lemma_72391 (h0 : functor.add_const (topological_space (has_Inf pos)) Type) : @t0_space.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_Inf.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_72392 (h0 : finset (left_cancel_semigroup (semiring num))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_72393 (h0 : cancel_comm_monoid_with_zero (complete_distrib_lattice (has_Inf (has_Inf linarith.comp)))) : unique_factorization_monoid (complete_distrib_lattice (has_Inf (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_72394 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_72395 (h0 : fin has_zero.zero) : @archimedean.{0} (has_bot.{0} real) (@matrix.vec_empty.{0} (ordered_add_comm_monoid.{0} (has_bot.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_72396 (h0 : not (add_monoid (has_top empty) -> false)) : @add_monoid.fg.{0} (has_top.{0} empty) (@classical.by_contradiction'.{1} (add_monoid.{0} (has_top.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_72397 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_nndist.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_72398 (h0 : functor.add_const (add_group (has_to_string pos)) (ordered_ring pos)) : @is_add_cyclic.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (has_to_string.{0} pos)) (ordered_ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_72399 (h0 : function.extfun Type (functor.add_const (add_group (add_cancel_comm_monoid empty)))) : @is_add_cyclic.{0} (add_cancel_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (add_group.{0} (add_cancel_comm_monoid.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (add_group.{0} (add_cancel_comm_monoid.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_72400 (h0 : functor.add_const (complete_lattice (option empty)) num) : @complete_lattice.is_Sup_finite_compact.{0} (option.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (option.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_72401 (h0 : topological_space (has_star num)) : discrete_topology (has_star num) := sorry --non-trivial
lemma new_lemma_72402 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (has_neg_part name)) := sorry --non-trivial
lemma new_lemma_72403 (h0 : topological_space (bin_tree unsigned)) : totally_disconnected_space (bin_tree unsigned) := sorry --non-trivial
lemma new_lemma_72404 (h0 : finset (cancel_monoid num)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_72405 (h0 : fin has_zero.zero) : @is_compactly_generated.{1} (boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (complete_lattice.{1} (boolean_algebra.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_72406 (h0 : ring (has_neg_part (has_add (cancel_monoid (has_add name))))) : is_domain (has_neg_part (has_add (cancel_monoid (has_add name)))) := sorry --non-trivial
lemma new_lemma_72407 (h0 : group (semigroup (cancel_monoid pos))) : normalizer_condition (semigroup (cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_72408 (h0 : topological_space (ring name)) : t1_space (ring name) := sorry --non-trivial
lemma new_lemma_72409 (h0 : uniform_space (topological_space fun_info)) : complete_space (topological_space fun_info) := sorry --non-trivial
lemma new_lemma_72410 (h0 : functor.add_const (ring (add_cancel_monoid environment.implicit_infer_kind)) pos) : @is_domain.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_72411 (h0 : topological_space (mul_zero_class ereal)) : totally_disconnected_space (mul_zero_class ereal) := sorry --non-trivial
lemma new_lemma_72412 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_72413 (h0 : functor.add_const (topological_space (semigroup empty)) num) : @irreducible_space.{0} (semigroup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_72414 (h0 : topological_space (normed_lattice_add_comm_group (has_add (has_add (has_add pos))))) : topological_space.separable_space (normed_lattice_add_comm_group (has_add (has_add (has_add pos)))) := sorry --non-trivial
lemma new_lemma_72415 (h0 : topological_space (add_comm_monoid (ring (finset linarith.comp)))) : t1_space (add_comm_monoid (ring (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_72416 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_72417 (h0 : topological_space (has_norm (has_top (has_top to_additive.value_type)))) : t0_space (has_norm (has_top (has_top to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_72418 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (add_comm_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_72419 (h0 : semiring (canonically_ordered_monoid (has_bot (sub_neg_monoid Type)))) : is_noetherian_ring (canonically_ordered_monoid (has_bot (sub_neg_monoid Type))) := sorry --non-trivial
lemma new_lemma_72420 (h2 : not (complete_lattice num -> false)) : @is_atomistic.{0} num (@classical.by_contradiction'.{1} (complete_lattice.{0} num) h2)  := sorry --non-trivial
lemma new_lemma_72421 (h0 : uniform_space (denumerable (comm_ring reducibility_hints))) : complete_space (denumerable (comm_ring reducibility_hints)) := sorry --non-trivial
lemma new_lemma_72422 (h0 : functor.add_const (uniform_space (left_cancel_semigroup num)) (semiring (semiring empty))) : @separated_space.{0} (left_cancel_semigroup.{0} num) (@functor.add_const.run.{0 0} (uniform_space.{0} (left_cancel_semigroup.{0} num)) (semiring.{0} (semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_72423 (h0 : not (group (plift congr_arg_kind) -> false)) : @normalizer_condition.{1} (plift.{1} congr_arg_kind) (@classical.by_contradiction'.{2} (group.{1} (plift.{1} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_72424 (h0 : functor.comp topological_space normed_comm_ring pos) : @discrete_topology.{0} (normed_comm_ring.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} normed_comm_ring.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_72425 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (has_emptyc linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_72426 (h0 : topological_space (ordered_comm_ring (has_Inf (has_add linarith.comp)))) : t0_space (ordered_comm_ring (has_Inf (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_72427 (h0 : list (comm_group (has_to_string Type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_72428 (h0 : functor.add_const (ring (finset pos)) (ring environment.implicit_infer_kind)) : @rank_condition.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (finset.{0} pos)) (ring.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_72429 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (sub_neg_monoid.{0} real) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (sub_neg_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_72430 (h0 : topological_space ereal) (h1 : set ereal) : is_path_connected h1 := sorry --non-trivial
lemma new_lemma_72431 (h0 : functor.add_const (topological_space (mul_zero_class num)) congr_arg_kind) : @normal_space.{0} (mul_zero_class.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_72432 (h0 : group (has_nndist (has_nndist linarith.comp))) : is_simple_group (has_nndist (has_nndist linarith.comp)) := sorry --non-trivial
lemma new_lemma_72433 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (complete_distrib_lattice.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} real))  := sorry --non-trivial
lemma new_lemma_72434 (h0 : topological_space (linear_ordered_field pos)) : normal_space (linear_ordered_field pos) := sorry --non-trivial
lemma new_lemma_72435 (h0 : has_lt (has_lt linarith.ineq)) : no_max_order (has_lt linarith.ineq) := sorry --non-trivial
lemma new_lemma_72436 (h0 : list (has_neg (boolean_algebra.core Type))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_72437 (h0 : ring (has_to_string (option (option (option (option (option ennreal))))))) : rank_condition (has_to_string (option (option (option (option (option ennreal)))))) := sorry --non-trivial
lemma new_lemma_72438 (h0 : cancel_comm_monoid_with_zero (has_zero linarith.comp)) : unique_factorization_monoid (has_zero linarith.comp) := sorry --non-trivial
lemma new_lemma_72439 (h0 : ring (has_pos_part (ordered_comm_ring Type))) : is_domain (has_pos_part (ordered_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_72440 (h0 : functor.add_const (topological_space (ring environment.implicit_infer_kind)) linarith.comp) : @totally_disconnected_space.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_72441 (h1 : topological_space (with_bot linarith.comp_source)) : t0_space (with_bot linarith.comp_source) := sorry --non-trivial
lemma new_lemma_72442 (h0 : ring (has_ssubset char)) : strong_rank_condition (has_ssubset char) := sorry --non-trivial
lemma new_lemma_72443 (h0 : semiring (with_bot unsigned)) : is_noetherian_ring (with_bot unsigned) := sorry --non-trivial
lemma new_lemma_72444 (h0 : semiring (normed_linear_ordered_group (semiring (semiring (semiring empty))))) : is_noetherian_ring (normed_linear_ordered_group (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_72445 (h0 : topological_space (has_neg_part real)) : t1_space (has_neg_part real) := sorry --non-trivial
lemma new_lemma_72446 (h0 : topological_space (has_union (has_top linarith.comp))) : totally_separated_space (has_union (has_top linarith.comp)) := sorry --non-trivial
lemma new_lemma_72447 (h0 : monoid (has_pos_part (has_Inf name))) : monoid.fg (has_pos_part (has_Inf name)) := sorry --non-trivial
lemma new_lemma_72448 (h0 : topological_space (finset (boolean_algebra.core environment.implicit_infer_kind))) : normal_space (finset (boolean_algebra.core environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_72449 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @preconnected_space.{0} (boolean_algebra.core.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (boolean_algebra.core.{0} name))  := sorry --non-trivial
lemma new_lemma_72450 (h0 : topological_space (cancel_monoid name)) : totally_separated_space (cancel_monoid name) := sorry --non-trivial
lemma new_lemma_72451 (h1 : topological_space (fintype (has_ssubset char))) : t0_space (fintype (has_ssubset char)) := sorry --non-trivial
lemma new_lemma_72452 (h0 : add_group (semi_normed_ring (has_one string_imp))) : is_add_cyclic (semi_normed_ring (has_one string_imp)) := sorry --non-trivial
lemma new_lemma_72453 (h0 : not (function.extfun Type topological_space -> false)) : @totally_disconnected_space.{0} (has_top.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_top.{0} num))  := sorry --non-trivial
lemma new_lemma_72454 (h0 : topological_space (has_union (has_union (has_union (add_group linarith.comp))))) : discrete_topology (has_union (has_union (has_union (add_group linarith.comp)))) := sorry --non-trivial
lemma new_lemma_72455 (h0 : ring (linear_ordered_add_comm_group (has_nnnorm char))) : is_domain (linear_ordered_add_comm_group (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_72456 (h0 : functor.add_const (ordered_comm_monoid (has_neg linarith.comp)) name) : @has_exists_mul_of_le.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_neg.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_72457 (h0 : functor.add_const (filter (boolean_algebra Type)) Type) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_72458 (h0 : functor.comp topological_space has_neg_part name) : @sequential_space.{0} (has_neg_part.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg_part.{0} name h0)  := sorry --non-trivial
lemma new_lemma_72459 (h0 : ordered_add_comm_monoid (cancel_monoid empty)) : archimedean (cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_72460 (h0 : functor.add_const (function.extfun Type group) pos) : @group.fg.{0} (has_to_string.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) pos h0) (has_to_string.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_72461 (h0 : fin has_zero.zero) : @path_connected_space.{0} pos (@matrix.vec_empty.{0} (topological_space.{0} pos) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_72462 (h0 : linarith.comp_source -> Prop) : zzz_forall h0 := sorry --non-trivial
lemma new_lemma_72463 (h0 : topological_space (preorder (semiring empty))) : locally_compact_space (preorder (semiring empty)) := sorry --non-trivial
lemma new_lemma_72464 (h0 : topological_space (uniform_space (mul_one_class char))) : t0_space (uniform_space (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_72465 (h0 : complete_lattice (ordered_ring (option (option (option (option (option unsigned))))))) : is_atomistic (ordered_ring (option (option (option (option (option unsigned)))))) := sorry --non-trivial
lemma new_lemma_72466 (h0 : topological_space (random_gen (random_gen linarith.comp))) : irreducible_space (random_gen (random_gen linarith.comp)) := sorry --non-trivial
lemma new_lemma_72467 (h0 : not (function.extfun Type add_monoid -> false)) : @add_monoid.fg.{0} (has_union.{0} fun_info) (@function.extfun_app.{2 1} Type add_monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_monoid.{0}) h0) (has_union.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_72468 (h0 : complete_linear_order (semiring congr_arg_kind) -> complete_linear_order (semiring congr_arg_kind) -> Prop) : is_strict_order (complete_linear_order (semiring congr_arg_kind)) h0 := sorry --non-trivial
lemma new_lemma_72469 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (comm_semigroup.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_72470 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (linear_ordered_semiring.{0} fun_info) (@function.extfun_app.{2 1} Type add_group.{0} h0 (linear_ordered_semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_72471 (h0 : functor.comp topological_space complete_distrib_lattice name) : @regular_space.{0} (complete_distrib_lattice.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} complete_distrib_lattice.{0} name h0)  := sorry --non-trivial
lemma new_lemma_72472 (h0 : not (ring (add_left_cancel_monoid (has_neg (finset to_additive.value_type))) -> false)) : @is_domain.{0} (add_left_cancel_monoid.{0} (has_neg.{0} (finset.{0} to_additive.value_type))) (@classical.by_contradiction'.{1} (ring.{0} (add_left_cancel_monoid.{0} (has_neg.{0} (finset.{0} to_additive.value_type)))) h0)  := sorry --non-trivial
lemma new_lemma_72473 (h0 : topological_space (complete_distrib_lattice congr_arg_kind)) : loc_path_connected_space (complete_distrib_lattice congr_arg_kind) := sorry --non-trivial
lemma new_lemma_72474 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} environment.implicit_infer_kind (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) environment.implicit_infer_kind)  := sorry --non-trivial
lemma new_lemma_72475 (h0 : group (fintype (has_nnnorm to_additive.value_type))) : is_cyclic (fintype (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_72476 (h0 : topological_space (mul_zero_class (semiring congr_arg_kind))) : path_connected_space (mul_zero_class (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_72477 (h0 : functor.add_const (function.extfun Type ordered_comm_monoid) pos) : @has_exists_mul_of_le.{0} (comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) pos h0) (comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_72478 (h0 : list (canonically_linear_ordered_monoid Type)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_72479 (h2 : complete_lattice environment.implicit_infer_kind) : complete_lattice.is_Sup_finite_compact environment.implicit_infer_kind := sorry --non-trivial
lemma new_lemma_72480 (h0 : monoid (simple_graph (has_add Type))) : monoid.fg (simple_graph (has_add Type)) := sorry --non-trivial
lemma new_lemma_72481 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (add_group.{0} (has_norm.{0} empty)) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_group.{0} (has_norm.{0} empty)))  := sorry --non-trivial
lemma new_lemma_72482 (h0 : functor.add_const (cancel_comm_monoid_with_zero (comm_group name)) unsigned) : @unique_factorization_monoid.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (comm_group.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_72483 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem group)) : @is_cyclic.{0} (has_emptyc.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) group.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_emptyc.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_72484 (h0 : add_monoid (has_nndist (boolean_algebra (has_to_string Type)))) : add_monoid.fg (has_nndist (boolean_algebra (has_to_string Type))) := sorry --non-trivial
lemma new_lemma_72485 (h2 : function.extfun Type group) : @normalizer_condition.{0} (with_bot.{0} num) (@function.extfun_app.{2 1} Type group.{0} h2 (with_bot.{0} num))  := sorry --non-trivial
lemma new_lemma_72486 (h0 : functor.add_const (group (add_cancel_monoid ennreal)) Type) : @is_cyclic.{0} (add_cancel_monoid.{0} ennreal) (@functor.add_const.run.{0 1} (group.{0} (add_cancel_monoid.{0} ennreal)) Type h0)  := sorry --non-trivial
lemma new_lemma_72487 (h0 : functor.add_const (filter (ring Type)) environment.implicit_infer_kind) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_72488 (h0 : functor.add_const (filter (comm_group unsigned)) (has_nndist environment.implicit_infer_kind)) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_72489 (h0 : functor.add_const (ring auto.case_option) num) : @strong_rank_condition.{0} auto.case_option (@functor.add_const.run.{0 0} (ring.{0} auto.case_option) num h0)  := sorry --non-trivial
lemma new_lemma_72490 (h0 : complete_lattice (has_pos_part (ring (has_add Type)))) : complete_lattice.is_Sup_finite_compact (has_pos_part (ring (has_add Type))) := sorry --non-trivial
lemma new_lemma_72491 (h1 : filter (has_top (has_norm (has_norm (has_top to_additive.value_type))))) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_72492 (h2 : set environment.projection_info) : set.finite h2 := sorry --non-trivial
lemma new_lemma_72493 (h0 : complete_lattice (has_edist (semiring (semiring empty)))) : is_compactly_generated (has_edist (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_72494 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (finset congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_72495 (h1 : ring (distrib (has_nnnorm to_additive.value_type))) : is_domain (distrib (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_72496 (h0 : add_group (has_neg (has_neg_part unsigned))) : is_add_cyclic (has_neg (has_neg_part unsigned)) := sorry --non-trivial
lemma new_lemma_72497 (h0 : ring (has_norm (random_gen (random_gen linarith.comp_source)))) : is_domain (has_norm (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_72498 (h0 : ring (distrib_lattice linarith.ineq)) : strong_rank_condition (distrib_lattice linarith.ineq) := sorry --non-trivial
lemma new_lemma_72499 (h0 : function.extfun Type group) : @normalizer_condition.{0} (left_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (left_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_72500 (h0 : topological_space (cancel_monoid pos)) : normal_space (cancel_monoid pos) := sorry --non-trivial
lemma new_lemma_72501 (h0 : ring (has_div string_imp)) : strong_rank_condition (has_div string_imp) := sorry --non-trivial
lemma new_lemma_72502 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (has_top.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_top.{0} empty))  := sorry --non-trivial
lemma new_lemma_72503 (h0 : group (generalized_boolean_algebra (finset (has_Inf pos)))) : normalizer_condition (generalized_boolean_algebra (finset (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_72504 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (has_neg_part.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg_part.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_72505 (h0 : ring (finset (has_neg_part (finset (has_neg_part name))))) : rank_condition (finset (has_neg_part (finset (has_neg_part name)))) := sorry --non-trivial
lemma new_lemma_72506 (h0 : topological_space (has_top (has_top num))) : totally_separated_space (has_top (has_top num)) := sorry --non-trivial
lemma new_lemma_72507 (h0 : complete_lattice (comm_ring (random_gen (random_gen (random_gen reducibility_hints))))) : is_compactly_generated (comm_ring (random_gen (random_gen (random_gen reducibility_hints)))) := sorry --non-trivial
lemma new_lemma_72508 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (add_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (add_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_72509 (h0 : complete_lattice (linear_ordered_field (comm_group ennreal))) : is_atomistic (linear_ordered_field (comm_group ennreal)) := sorry --non-trivial
lemma new_lemma_72510 (h0 : add_group (has_edist (semiring unsigned))) : is_add_cyclic (has_edist (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_72511 (h2 : ring (semi_normed_comm_ring fun_info)) : is_domain (semi_normed_comm_ring fun_info) := sorry --non-trivial
lemma new_lemma_72512 (h0 : topological_space (has_nndist (has_add (has_Inf (has_Inf linarith.comp))))) : loc_path_connected_space (has_nndist (has_add (has_Inf (has_Inf linarith.comp)))) := sorry --non-trivial
lemma new_lemma_72513 (h1 : complete_lattice (has_emptyc linarith.comp)) : is_compactly_generated (has_emptyc linarith.comp) := sorry --non-trivial
lemma new_lemma_72514 (h0 : add_group (ordered_comm_ring (canonically_linear_ordered_monoid real))) : is_add_cyclic (ordered_comm_ring (canonically_linear_ordered_monoid real)) := sorry --non-trivial
lemma new_lemma_72515 (h0 : functor.add_const (topological_space (preorder num)) num) : @irreducible_space.{0} (preorder.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (preorder.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_72516 (h0 : topological_space (has_add (finset name))) : t1_space (has_add (finset name)) := sorry --non-trivial
lemma new_lemma_72517 (h0 : functor.add_const (semiring (has_pos_part Type)) (has_Inf real)) : @is_noetherian_ring.{1} (has_pos_part.{1} Type) (@functor.add_const.run.{1 0} (semiring.{1} (has_pos_part.{1} Type)) (has_Inf.{0} real) h0)  := sorry --non-trivial
lemma new_lemma_72518 (h0 : group (has_Inf (has_neg pos))) : is_cyclic (has_Inf (has_neg pos)) := sorry --non-trivial
lemma new_lemma_72519 (h0 : functor.add_const (topological_space (monoid unsigned)) pos) : @t0_space.{0} (monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (monoid.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_72520 (h0 : topological_space (boolean_algebra.core (comm_group unsigned))) : sequential_space (boolean_algebra.core (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_72521 (h1 : not (uniform_space (random_gen fun_info) -> false)) : @separated_space.{0} (random_gen.{0} fun_info) (@classical.by_contradiction'.{1} (uniform_space.{0} (random_gen.{0} fun_info)) h1)  := sorry --non-trivial
lemma new_lemma_72522 (h0 : list (comm_group pos)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_72523 (h0 : uniform_space (distrib char)) : complete_space (distrib char) := sorry --non-trivial
lemma new_lemma_72524 (h0 : topological_space (generalized_boolean_algebra (has_nndist Type))) : locally_compact_space (generalized_boolean_algebra (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_72525 (h0 : add_group (normed_group (semiring fun_info))) : is_add_cyclic (normed_group (semiring fun_info)) := sorry --non-trivial
lemma new_lemma_72526 (h1 : add_group (id empty)) : is_add_cyclic (id empty) := sorry --non-trivial
lemma new_lemma_72527 (h0 : prod (simple_graph (option (option (option (option num))))) (simple_graph (option (option (option (option num)))))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_72528 (h0 : group (comm_group (has_to_string linarith.comp))) : is_simple_group (comm_group (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_72529 (h0 : group (add_cancel_monoid (has_add (has_to_string (has_to_string name))))) : group.fg (add_cancel_monoid (has_add (has_to_string (has_to_string name)))) := sorry --non-trivial
lemma new_lemma_72530 (h0 : add_monoid (finset (option (option unsigned)))) : add_monoid.fg (finset (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_72531 (h0 : ring (partial_order (option (option (option (option (option unsigned))))))) : is_principal_ideal_ring (partial_order (option (option (option (option (option unsigned)))))) := sorry --non-trivial
lemma new_lemma_72532 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_72533 (h0 : topological_space (partial_order empty)) : topological_space.separable_space (partial_order empty) := sorry --non-trivial
lemma new_lemma_72534 (h0 : complete_lattice (has_nndist (semigroup (has_Inf (has_Inf Type))))) : is_compactly_generated (has_nndist (semigroup (has_Inf (has_Inf Type)))) := sorry --non-trivial
lemma new_lemma_72535 (h0 : functor.add_const (group (boolean_algebra unsigned)) environment.implicit_infer_kind) : @is_simple_group.{0} (boolean_algebra.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_72536 (h0 : topological_space (denumerable (has_top fun_info))) : t0_space (denumerable (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_72537 (h0 : filter (has_zero (comm_group ennreal))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_72538 (h0 : functor.add_const (function.extfun (Type 1) monoid) Type) : @monoid.fg.{1} Type (@function.extfun_app.{3 2} (Type 1) monoid.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) monoid.{1}) Type h0) Type)  := sorry --non-trivial
lemma new_lemma_72539 (h0 : topological_space (boolean_algebra.core (ring pos))) : topological_space.separable_space (boolean_algebra.core (ring pos)) := sorry --non-trivial
lemma new_lemma_72540 (h0 : topological_space (has_inv (has_nnnorm linarith.comp_source))) : path_connected_space (has_inv (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_72541 (h0 : functor.add_const (group (complete_distrib_lattice linarith.comp)) name) : @group.fg.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (complete_distrib_lattice.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_72542 (h0 : monoid (semiring (random_gen num))) : monoid.fg (semiring (random_gen num)) := sorry --non-trivial
lemma new_lemma_72543 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (add_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_72544 (h0 : functor.add_const (uniform_space (has_nndist ennreal)) Type) : @complete_space.{0} (has_nndist.{0} ennreal) (@functor.add_const.run.{0 1} (uniform_space.{0} (has_nndist.{0} ennreal)) Type h0)  := sorry --non-trivial
lemma new_lemma_72545 (h0 : functor.add_const (topological_space (semiring num)) (semiring congr_arg_kind)) : @t1_space.{0} (semiring.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (semiring.{0} num)) (semiring.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_72546 (h0 : functor.add_const (topological_space (finset unsigned)) Type) : @path_connected_space.{0} (finset.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (finset.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_72547 (h0 : not (has_mem.mem (has_norm num) has_emptyc.emptyc -> false)) : @totally_disconnected_space.{0} (has_norm.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_norm.{0} num) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_norm.{0} num) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_72548 (h2 : topological_space (linear_ordered_add_comm_group linarith.ineq)) : totally_disconnected_space (linear_ordered_add_comm_group linarith.ineq) := sorry --non-trivial
lemma new_lemma_72549 (h0 : monoid (semigroup (has_add Type))) : monoid.fg (semigroup (has_add Type)) := sorry --non-trivial
lemma new_lemma_72550 (h0 : functor.add_const (complete_lattice (ordered_comm_ring real)) (sub_neg_monoid real)) : @is_atomistic.{0} (ordered_comm_ring.{0} real) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ordered_comm_ring.{0} real)) (sub_neg_monoid.{0} real) h0)  := sorry --non-trivial
lemma new_lemma_72551 (h0 : functor.add_const (topological_space (cancel_monoid pos)) Type) : @totally_separated_space.{0} (cancel_monoid.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (cancel_monoid.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_72552 (h0 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} (@id.{2} Type empty) (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h0) (@id.{2} Type empty))  := sorry --non-trivial
lemma new_lemma_72553 (h0 : functor.comp topological_space finset name) : @irreducible_space.{0} (finset.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} finset.{0} name h0)  := sorry --non-trivial
lemma new_lemma_72554 (h1 : uniform_space (with_one fun_info)) : complete_space (with_one fun_info) := sorry --non-trivial
lemma new_lemma_72555 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (mul_zero_class.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (mul_zero_class.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_72556 (h0 : ordered_add_comm_monoid (ring (has_to_string (has_neg Type)))) : archimedean (ring (has_to_string (has_neg Type))) := sorry --non-trivial
lemma new_lemma_72557 (h2 : topological_space (semi_normed_ring linarith.ineq)) : t0_space (semi_normed_ring linarith.ineq) := sorry --non-trivial
lemma new_lemma_72558 (h1 : function.extfun Type complete_lattice) : @is_atomistic.{0} (has_emptyc.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} h1 (has_emptyc.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_72559 (h0 : topological_space (complete_semilattice_Sup (has_norm (has_top fun_info)))) : locally_compact_space (complete_semilattice_Sup (has_norm (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_72560 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : countable_Inter_filter (function.extfun_app (function.extfun_app h0 filter) (filter empty)) := sorry --non-trivial
lemma new_lemma_72561 (h0 : ordered_add_comm_monoid (ordered_comm_ring name)) : archimedean (ordered_comm_ring name) := sorry --non-trivial
lemma new_lemma_72562 (h0 : topological_space (boolean_algebra.core (option empty))) : loc_path_connected_space (boolean_algebra.core (option empty)) := sorry --non-trivial
lemma new_lemma_72563 (h0 : topological_space (has_bot (has_Inf pos))) : discrete_topology (has_bot (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_72564 (h1 : topological_space (id congr_arg_kind)) : t0_space (id congr_arg_kind) := sorry --non-trivial
lemma new_lemma_72565 (h0 : topological_space (has_add (comm_monoid_with_zero (ring pos)))) : totally_disconnected_space (has_add (comm_monoid_with_zero (ring pos))) := sorry --non-trivial
lemma new_lemma_72566 (h2 : complete_lattice (simple_graph to_additive.value_type)) : complete_lattice.is_Sup_finite_compact (simple_graph to_additive.value_type) := sorry --non-trivial
lemma new_lemma_72567 (h0 : topological_space (linear_ordered_field (finset unsigned))) : totally_disconnected_space (linear_ordered_field (finset unsigned)) := sorry --non-trivial
lemma new_lemma_72568 (h0 : functor.add_const (ring (free_add_monoid congr_arg_kind)) congr_arg_kind) : @rank_condition.{0} (free_add_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ring.{0} (free_add_monoid.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_72569 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_inv.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inv.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_72570 (h2 : set (non_unital_non_assoc_semiring linarith.comp_source)) : set.finite h2 := sorry --non-trivial
lemma new_lemma_72571 (h0 : uniform_space (simple_graph string_imp)) : complete_space (simple_graph string_imp) := sorry --non-trivial
lemma new_lemma_72572 (h0 : semiring (option (option ennreal))) : is_noetherian_ring (option (option ennreal)) := sorry --non-trivial
lemma new_lemma_72573 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (linear_ordered_comm_monoid_with_zero.{0} (option.{0} unsigned)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_monoid_with_zero.{0} (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_72574 (h0 : topological_space (has_norm num)) : preirreducible_space (has_norm num) := sorry --non-trivial
lemma new_lemma_72575 (h0 : uniform_space (linear_ordered_semiring (has_zero (has_norm linarith.comp)))) : separated_space (linear_ordered_semiring (has_zero (has_norm linarith.comp))) := sorry --non-trivial
lemma new_lemma_72576 (h0 : not (add_monoid (linear_ordered_comm_ring num) -> false)) : @add_monoid.fg.{0} (linear_ordered_comm_ring.{0} num) (@classical.by_contradiction'.{1} (add_monoid.{0} (linear_ordered_comm_ring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_72577 (h0 : not (function.extfun Type topological_space -> false)) : @discrete_topology.{0} (with_bot.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (with_bot.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_72578 (h0 : topological_space (has_one unsigned)) : preirreducible_space (has_one unsigned) := sorry --non-trivial
lemma new_lemma_72579 (h0 : topological_space (normed_comm_ring pos)) : preirreducible_space (normed_comm_ring pos) := sorry --non-trivial
lemma new_lemma_72580 (h0 : ring (fintype (has_add fun_info))) : rank_condition (fintype (has_add fun_info)) := sorry --non-trivial
lemma new_lemma_72581 (h1 : complete_lattice (comm_ring char)) : complete_lattice.is_Sup_finite_compact (comm_ring char) := sorry --non-trivial
lemma new_lemma_72582 (h0 : functor.add_const (topological_space (has_to_string pos)) (has_Inf (has_neg linarith.comp))) : @preirreducible_space.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} pos)) (has_Inf.{0} (has_neg.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_72583 (h0 : topological_space (has_pos_part (has_Inf (has_Inf pos)))) : t0_space (has_pos_part (has_Inf (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_72584 (h0 : topological_space (has_add (has_add (ring Type)))) : normal_space (has_add (has_add (ring Type))) := sorry --non-trivial
lemma new_lemma_72585 (h0 : topological_space (has_neg (finset (finset linarith.comp)))) : t1_space (has_neg (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_72586 (h0 : functor.add_const (complete_lattice (boolean_algebra (has_to_string name))) Type) : @is_compactly_generated.{0} (boolean_algebra.{0} (has_to_string.{0} name)) (@functor.add_const.run.{0 1} (complete_lattice.{0} (boolean_algebra.{0} (has_to_string.{0} name))) Type h0)  := sorry --non-trivial
lemma new_lemma_72587 (h0 : not (ring (order_dual linarith.ineq) -> false)) : @is_domain.{0} (order_dual.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (order_dual.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_72588 (h0 : topological_space (mul_zero_class (semiring (semiring (semiring (semiring empty)))))) : path_connected_space (mul_zero_class (semiring (semiring (semiring (semiring empty))))) := sorry --non-trivial
lemma new_lemma_72589 (h1 : complete_lattice (complete_semilattice_Sup linarith.comp_source)) : is_compactly_generated (complete_semilattice_Sup linarith.comp_source) := sorry --non-trivial
lemma new_lemma_72590 (h0 : topological_space (has_sdiff (has_pos_part (finset linarith.comp)))) : totally_disconnected_space (has_sdiff (has_pos_part (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_72591 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (encodable.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (encodable.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_72592 (h0 : linear_ordered_field (option (option pos)) -> linear_ordered_field (option (option pos)) -> Prop) : is_symm (linear_ordered_field (option (option pos))) h0 := sorry --non-trivial
lemma new_lemma_72593 (h0 : functor.add_const (topological_space (cancel_monoid pos)) linarith.comp) : @discrete_topology.{0} (cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_72594 (h0 : function.extfun (Type 1) group) : @is_cyclic.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} h0 (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_72595 (h0 : function.extfun Type (functor.add_const (topological_space pos))) : @totally_disconnected_space.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) real (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} pos)) h0 real))  := sorry --non-trivial
lemma new_lemma_72596 (h0 : topological_space (finset (option pos))) : totally_disconnected_space (finset (option pos)) := sorry --non-trivial
lemma new_lemma_72597 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_simple_group.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 group.{1}) (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_72598 (h0 : functor.add_const (function.extfun Type uniform_space) environment.implicit_infer_kind) : @separated_space.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) environment.implicit_infer_kind h0) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_72599 (h0 : uniform_space (has_zero ennreal)) : complete_space (has_zero ennreal) := sorry --non-trivial
lemma new_lemma_72600 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_semilattice_Sup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_72601 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (has_neg.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_neg.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_72602 (h0 : complete_lattice (is_R_or_C (semiring (semiring (semiring empty))))) : is_compactly_generated (is_R_or_C (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_72603 (h0 : ring (plift (semiring congr_arg_kind))) : is_principal_ideal_ring (plift (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_72604 (h0 : filter (has_to_string (has_neg_part unsigned))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_72605 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_72606 (h0 : not (topological_space (non_unital_non_assoc_semiring linarith.ineq) -> false)) : @t0_space.{0} (non_unital_non_assoc_semiring.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (non_unital_non_assoc_semiring.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_72607 (h0 : functor.add_const (ring (add_group congr_arg_kind)) unsigned) : @strong_rank_condition.{0} (add_group.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ring.{0} (add_group.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_72608 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (linear_ordered_semiring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_72609 (h0 : topological_space (mul_zero_class congr_arg_kind)) : loc_path_connected_space (mul_zero_class congr_arg_kind) := sorry --non-trivial
lemma new_lemma_72610 (h0 : topological_space (sub_neg_monoid (has_Inf Type))) : sequential_space (sub_neg_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_72611 (h0 : topological_space (has_top (semiring (random_gen linarith.comp_source)))) : path_connected_space (has_top (semiring (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_72612 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_72613 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_ordered_comm_semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_72614 (h0 : function.extfun (Type 1) topological_space) : @t1_space.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_72615 (h0 : function.extfun Type group) : @group.fg.{0} (has_compl.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} h0 (has_compl.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_72616 (h0 : ordered_comm_monoid (cancel_monoid (has_neg (has_neg name)))) : has_exists_mul_of_le (cancel_monoid (has_neg (has_neg name))) := sorry --non-trivial
lemma new_lemma_72617 (h1 : ring (denumerable (comm_ring (comm_ring fun_info)))) : rank_condition (denumerable (comm_ring (comm_ring fun_info))) := sorry --non-trivial
lemma new_lemma_72618 (h0 : prod (non_assoc_semiring empty) (non_assoc_semiring empty)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_72619 (h0 : not (topological_space (add_group num) -> false)) : @path_connected_space.{0} (add_group.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (add_group.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_72620 (h0 : functor.add_const (topological_space (normed_comm_ring linarith.comp)) Type) : @topological_space.separable_space.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (normed_comm_ring.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_72621 (h0 : function.extfun Type topological_space) : @normal_space.{0} (metric_space.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (metric_space.{0} num))  := sorry --non-trivial
lemma new_lemma_72622 (h0 : complete_lattice (sub_neg_monoid (has_Inf Type))) : is_compactly_generated (sub_neg_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_72623 (h1 : add_group (dlist char)) : is_add_cyclic (dlist char) := sorry --non-trivial
lemma new_lemma_72624 (h0 : fin has_zero.zero) : @is_atomistic.{1} (finset.{1} Type) (@matrix.vec_empty.{1} (complete_lattice.{1} (finset.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_72625 (h0 : function.extfun nat fin) : @locally_compact_space.{1} (add_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (add_comm_monoid.{1} Type)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))))  := sorry --non-trivial
lemma new_lemma_72626 (h0 : add_group (option (semiring (semiring (add_group num))))) : is_add_cyclic (option (semiring (semiring (add_group num)))) := sorry --non-trivial
lemma new_lemma_72627 (h0 : ring (has_nnnorm enat)) : rank_condition (has_nnnorm enat) := sorry --non-trivial
lemma new_lemma_72628 (h0 : not (uniform_space (complete_semilattice_Sup num) -> false)) : @complete_space.{0} (complete_semilattice_Sup.{0} num) (@classical.by_contradiction'.{1} (uniform_space.{0} (complete_semilattice_Sup.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_72629 (h0 : complete_lattice (monoid (has_norm (has_norm linarith.comp_source)))) : is_compactly_generated (monoid (has_norm (has_norm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_72630 (h1 : complete_lattice (id (with_bot (with_bot string_imp)))) : is_compactly_generated (id (with_bot (with_bot string_imp))) := sorry --non-trivial
lemma new_lemma_72631 (h0 : topological_space (add_comm_monoid (ring (finset (ring name))))) : irreducible_space (add_comm_monoid (ring (finset (ring name)))) := sorry --non-trivial
lemma new_lemma_72632 (h0 : functor.add_const (ring (boolean_algebra.core linarith.comp)) linarith.comp) : @rank_condition.{0} (boolean_algebra.core.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.core.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_72633 (h0 : group (random_gen (semiring empty))) : normalizer_condition (random_gen (semiring empty)) := sorry --non-trivial
lemma new_lemma_72634 (h0 : add_group (has_add name)) : is_add_cyclic (has_add name) := sorry --non-trivial
lemma new_lemma_72635 (h0 : functor.add_const (topological_space (comm_group Type)) ennreal) : @locally_compact_space.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (comm_group.{1} Type)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_72636 (h0 : topological_space (id (has_inv fun_info))) : t0_space (id (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_72637 (h0 : functor.add_const (uniform_space (add_left_cancel_semigroup empty)) congr_arg_kind) : @separated_space.{0} (add_left_cancel_semigroup.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (add_left_cancel_semigroup.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_72638 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (ring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_72639 (h0 : ordered_add_comm_monoid (comm_monoid_with_zero unsigned)) : archimedean (comm_monoid_with_zero unsigned) := sorry --non-trivial
lemma new_lemma_72640 (h0 : functor.add_const (group (canonically_ordered_comm_semiring ennreal)) unsigned) : @group.fg.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@functor.add_const.run.{0 0} (group.{0} (canonically_ordered_comm_semiring.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_72641 (h0 : topological_space (has_Sup unsigned)) : totally_disconnected_space (has_Sup unsigned) := sorry --non-trivial
lemma new_lemma_72642 (h0 : topological_space (random_gen to_additive.value_type)) : locally_compact_space (random_gen to_additive.value_type) := sorry --non-trivial
lemma new_lemma_72643 (h0 : functor.add_const (topological_space (semigroup pos)) (has_neg environment.implicit_infer_kind)) : @loc_path_connected_space.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} pos)) (has_neg.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_72644 (h0 : functor.add_const (topological_space (cancel_monoid environment.implicit_infer_kind)) name) : @normal_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_72645 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @group.fg.{1} (plift.{1} num) (@function.extfun_app.{3 2} (Type 1) group.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 group.{1}) (plift.{1} num))  := sorry --non-trivial
lemma new_lemma_72646 (h0 : not (function.extfun Type group -> false)) : @group.fg.{0} (random_gen.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (random_gen.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_72647 (h0 : monoid (mul_zero_class ennreal)) : monoid.fg (mul_zero_class ennreal) := sorry --non-trivial
lemma new_lemma_72648 (h0 : normed_field (normed_field char) -> normed_field (normed_field char) -> Prop) (h1 : nondiscrete_normed_field fun_info -> normed_field (normed_field char)) : directed h0 h1 := sorry --non-trivial
lemma new_lemma_72649 (h0 : ring (has_append (has_nnnorm linarith.ineq))) : strong_rank_condition (has_append (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_72650 (h0 : functor.add_const (topological_space (bin_tree congr_arg_kind)) unsigned) : @locally_compact_space.{0} (bin_tree.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (bin_tree.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_72651 (h0 : group Type) : normalizer_condition Type := sorry --non-trivial
lemma new_lemma_72652 (h0 : topological_space (ordered_comm_ring (has_neg (has_neg name)))) : regular_space (ordered_comm_ring (has_neg (has_neg name))) := sorry --non-trivial
lemma new_lemma_72653 (h0 : functor.add_const (ring (boolean_algebra.core empty)) empty) : @strong_rank_condition.{0} (boolean_algebra.core.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.core.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_72654 (h0 : uniform_space (ordered_comm_monoid linarith.comp)) : separated_space (ordered_comm_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_72655 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_72656 (h0 : topological_space (complete_semilattice_Sup (has_norm linarith.ineq))) : path_connected_space (complete_semilattice_Sup (has_norm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_72657 (h0 : group (denumerable (has_nnnorm (has_nnnorm fun_info)))) : group.fg (denumerable (has_nnnorm (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_72658 (h0 : topological_space (monoid (has_to_string num))) : normal_space (monoid (has_to_string num)) := sorry --non-trivial
lemma new_lemma_72659 (h0 : group (has_nndist (comm_group (comm_group Type)))) : is_simple_group (has_nndist (comm_group (comm_group Type))) := sorry --non-trivial
lemma new_lemma_72660 (h0 : group (distrib_lattice (random_gen linarith.comp_source))) : group.fg (distrib_lattice (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_72661 (h0 : list (with_bot (has_inv (has_inv to_additive.value_type)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_72662 (h0 : group (comm_group (finset environment.implicit_infer_kind))) : normalizer_condition (comm_group (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_72663 (h0 : filter (complete_distrib_lattice (finset ennreal))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_72664 (h0 : fin has_zero.zero) : @t1_space.{0} (has_bot.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_bot.{0} name))  := sorry --non-trivial
lemma new_lemma_72665 (h0 : ordered_comm_monoid (has_Inf (has_Inf (has_add Type)))) : has_exists_mul_of_le (has_Inf (has_Inf (has_add Type))) := sorry --non-trivial
lemma new_lemma_72666 (h0 : complete_lattice (metric_space (semiring empty))) : is_compactly_generated (metric_space (semiring empty)) := sorry --non-trivial
lemma new_lemma_72667 (h0 : add_group (ordered_comm_ring (has_neg name))) : is_add_cyclic (ordered_comm_ring (has_neg name)) := sorry --non-trivial
lemma new_lemma_72668 (h0 : topological_space (omega_complete_partial_order num)) : totally_separated_space (omega_complete_partial_order num) := sorry --non-trivial
lemma new_lemma_72669 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (normed_group.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_72670 (h2 : Prop) : set.separates_points (id (fun (h1 : fun_info -> linarith.comp), h2)) := sorry --non-trivial
lemma new_lemma_72671 (h0 : comm_ring (has_nnnorm to_additive.value_type)) : local_ring (has_nnnorm to_additive.value_type) := sorry --non-trivial
lemma new_lemma_72672 (h0 : group (has_nnnorm (random_gen (random_gen string_imp)))) : is_cyclic (has_nnnorm (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_72673 (h0 : finset (ordered_cancel_add_comm_monoid (option (option unsigned)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_72674 (h0 : functor.add_const (complete_lattice (semigroup empty)) num) : @complete_lattice.is_Sup_finite_compact.{0} (semigroup.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (semigroup.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_72675 (h0 : fin has_zero.zero) : @regular_space.{0} (ordered_comm_ring.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_ring.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_72676 (h0 : has_lt (linear_ordered_comm_group_with_zero reducibility_hints)) : no_max_order (linear_ordered_comm_group_with_zero reducibility_hints) := sorry --non-trivial
lemma new_lemma_72677 (h0 : functor.add_const (list (add_cancel_monoid environment.implicit_infer_kind)) environment.implicit_infer_kind) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_72678 (h0 : functor.add_const (topological_space (sub_neg_monoid linarith.comp)) Type) : @t1_space.{0} (sub_neg_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (sub_neg_monoid.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_72679 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (mul_zero_class.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (mul_zero_class.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_72680 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (has_dist num)) := sorry --non-trivial
lemma new_lemma_72681 (h0 : preorder (add_comm_semigroup (nondiscrete_normed_field (add_comm_semigroup string.iterator_imp)))) (h1 : set (add_comm_semigroup (nondiscrete_normed_field (add_comm_semigroup string.iterator_imp)))) : set.is_pwo h1 := sorry --non-trivial
lemma new_lemma_72682 (h0 : topological_space (is_R_or_C unsigned)) : totally_disconnected_space (is_R_or_C unsigned) := sorry --non-trivial
lemma new_lemma_72683 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (has_union.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_union.{0} empty))  := sorry --non-trivial
lemma new_lemma_72684 (h0 : group (normed_lattice_add_comm_group (has_add (has_Inf linarith.comp)))) : is_simple_group (normed_lattice_add_comm_group (has_add (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_72685 (h0 : fin has_zero.zero) : @preirreducible_space.{0} (has_bot.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (has_bot.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_72686 (h0 : group (measurable_space (random_gen empty))) : group.fg (measurable_space (random_gen empty)) := sorry --non-trivial
lemma new_lemma_72687 (h1 : ring empty) : strong_rank_condition empty := sorry --non-trivial
lemma new_lemma_72688 (h0 : topological_space (semigroup (finset Type))) : preirreducible_space (semigroup (finset Type)) := sorry --non-trivial
lemma new_lemma_72689 (h0 : set (string.iterator_imp -> add_comm_semigroup ereal)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_72690 (h0 : topological_space (has_nndist (has_add Type))) : preirreducible_space (has_nndist (has_add Type)) := sorry --non-trivial
lemma new_lemma_72691 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (linear_ordered_semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_72692 (h0 : monoid (canonically_ordered_monoid (has_Inf (has_add (has_Inf (has_Inf linarith.comp)))))) : monoid.fg (canonically_ordered_monoid (has_Inf (has_add (has_Inf (has_Inf linarith.comp))))) := sorry --non-trivial
lemma new_lemma_72693 (h0 : not (complete_lattice (non_unital_non_assoc_semiring (uniform_space enat)) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (non_unital_non_assoc_semiring.{0} (uniform_space.{0} enat)) (@classical.by_contradiction'.{1} (complete_lattice.{0} (non_unital_non_assoc_semiring.{0} (uniform_space.{0} enat))) h0)  := sorry --non-trivial
lemma new_lemma_72694 (h0 : ordered_add_comm_monoid (has_nndist (has_to_string (has_to_string (has_to_string (has_to_string pos)))))) : archimedean (has_nndist (has_to_string (has_to_string (has_to_string (has_to_string pos))))) := sorry --non-trivial
lemma new_lemma_72695 (h0 : functor.add_const (monoid (cancel_monoid environment.implicit_infer_kind)) (has_add Type)) : @monoid.fg.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (monoid.{0} (cancel_monoid.{0} environment.implicit_infer_kind)) (has_add.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_72696 (h0 : functor.add_const (uniform_space (add_comm_monoid environment.implicit_infer_kind)) linarith.comp) : @complete_space.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (uniform_space.{0} (add_comm_monoid.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_72697 (h0 : uniform_space (has_compl to_additive.value_type)) : complete_space (has_compl to_additive.value_type) := sorry --non-trivial
lemma new_lemma_72698 (h0 : group (boolean_algebra.core ennreal)) : is_simple_group (boolean_algebra.core ennreal) := sorry --non-trivial
lemma new_lemma_72699 (h0 : topological_space (has_Inf (ring linarith.comp))) : preirreducible_space (has_Inf (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_72700 (h0 : monoid (has_zero (has_zero Type))) : monoid.fg (has_zero (has_zero Type)) := sorry --non-trivial
lemma new_lemma_72701 (h0 : complete_lattice (partial_order (semiring (semiring unsigned)))) : complete_lattice.is_Sup_finite_compact (partial_order (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_72702 (h0 : ring (option ennreal)) : is_principal_ideal_ring (option ennreal) := sorry --non-trivial
lemma new_lemma_72703 (h0 : topological_space (complete_distrib_lattice (semiring (semiring (semiring empty))))) : t1_space (complete_distrib_lattice (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_72704 (h1 : complete_lattice (has_compl (has_nnnorm string_imp))) : is_compactly_generated (has_compl (has_nnnorm string_imp)) := sorry --non-trivial
lemma new_lemma_72705 (h1 : function.extfun (finset (Type -> Type)) (has_mem.mem complete_lattice)) : @is_atomistic.{0} (has_norm.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) complete_lattice.{0}) h1 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_norm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_72706 (h0 : functor.add_const (topological_space (has_neg Type)) pos) : @totally_separated_space.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_neg.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_72707 (h0 : functor.add_const (complete_lattice (normed_comm_ring unsigned)) environment.implicit_infer_kind) : @is_atomistic.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (normed_comm_ring.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_72708 (h1 : topological_space (normed_field ereal)) : totally_disconnected_space (normed_field ereal) := sorry --non-trivial
lemma new_lemma_72709 (h0 : topological_space (boolean_algebra (ring name))) : t0_space (boolean_algebra (ring name)) := sorry --non-trivial
lemma new_lemma_72710 (h0 : functor.comp filter has_neg pos) : countable_Inter_filter (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_72711 (h0 : functor.add_const (ring (has_to_string unsigned)) pos) : @strong_rank_condition.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (has_to_string.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_72712 (h0 : functor.add_const (group (semigroup pos)) (ring pos)) : @group.fg.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (semigroup.{0} pos)) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_72713 (h0 : ring (has_nnnorm (random_gen char))) : rank_condition (has_nnnorm (random_gen char)) := sorry --non-trivial
lemma new_lemma_72714 (h0 : functor.add_const (group (finset Type)) pos) : @is_cyclic.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (finset.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_72715 (h0 : not (topological_space (distrib_lattice fun_info) -> false)) : @totally_disconnected_space.{0} (distrib_lattice.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (distrib_lattice.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_72716 (h0 : list (has_norm (has_ssubset (has_ssubset (has_nnnorm linarith.comp_source))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_72717 (h1 : uniform_space (normed_field linarith.comp_source)) : complete_space (normed_field linarith.comp_source) := sorry --non-trivial
lemma new_lemma_72718 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_union.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_union.{0} empty))  := sorry --non-trivial
lemma new_lemma_72719 (h0 : functor.add_const (group (add_comm_monoid environment.implicit_infer_kind)) (has_neg (has_neg Type))) : @group.fg.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (group.{0} (add_comm_monoid.{0} environment.implicit_infer_kind)) (has_neg.{1} (has_neg.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_72720 (h0 : topological_space (has_neg_part (finset Type))) : totally_disconnected_space (has_neg_part (finset Type)) := sorry --non-trivial
lemma new_lemma_72721 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (metric_space.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (metric_space.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_72722 (h0 : not (topological_space (add_right_cancel_monoid unsigned) -> false)) : @irreducible_space.{0} (add_right_cancel_monoid.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (add_right_cancel_monoid.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_72723 (h0 : not (function.extfun (finset (Type -> Type)) (has_mem.mem topological_space) -> false)) : @irreducible_space.{0} (canonically_ordered_monoid.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) (@classical.by_contradiction'.{0} (function.extfun.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0})) h0) (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (canonically_ordered_monoid.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_72724 (h0 : not (function.extfun Type topological_space -> false)) : @totally_disconnected_space.{0} (has_inv.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_inv.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_72725 (h0 : topological_space (has_neg (has_add ennreal))) : sequential_space (has_neg (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_72726 (h0 : add_monoid (has_top (has_top linarith.comp))) : add_monoid.fg (has_top (has_top linarith.comp)) := sorry --non-trivial
lemma new_lemma_72727 (h0 : function.extfun (finset ((Type -> Type) -> Type 1)) (has_mem.mem (function.extfun Type))) : @monoid.fg.{0} linarith.comp_source (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@finset.pi.empty.{2 1} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) (function.extfun.{2 1} Type) (@function.extfun_app.{3 0} (finset.{2} ((Type → Type) → Type 1)) (@has_mem.mem.{2 2} ((Type → Type) → Type 1) (finset.{2} ((Type → Type) → Type 1)) (@finset.has_mem.{2} ((Type → Type) → Type 1)) (function.extfun.{2 1} Type)) h0 (@has_emptyc.emptyc.{2} (finset.{2} ((Type → Type) → Type 1)) (@finset.has_emptyc.{2} ((Type → Type) → Type 1))))) monoid.{0}) linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_72728 (h0 : group (non_assoc_semiring (semiring congr_arg_kind))) : group.fg (non_assoc_semiring (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_72729 (h0 : functor.add_const (complete_lattice (has_neg name)) (has_add (ring name))) : @is_atomistic.{0} (has_neg.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_neg.{0} name)) (has_add.{0} (ring.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_72730 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (linear_ordered_comm_group congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_72731 (h0 : group (canonically_ordered_add_monoid (option empty))) : is_cyclic (canonically_ordered_add_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_72732 (h0 : set (has_div reducibility_hints)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_72733 (h0 : group (has_Sup (semiring empty))) : group.fg (has_Sup (semiring empty)) := sorry --non-trivial
lemma new_lemma_72734 (h0 : functor.add_const (topological_space (canonically_linear_ordered_monoid ennreal)) unsigned) : @totally_disconnected_space.{0} (canonically_linear_ordered_monoid.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_linear_ordered_monoid.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_72735 (h0 : topological_space (add_comm_monoid environment.implicit_infer_kind)) : topological_space.separable_space (add_comm_monoid environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_72736 (h0 : ring (add_comm_monoid (has_add pos))) : strong_rank_condition (add_comm_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_72737 (h0 : topological_space (has_add (option (option (option (option ennreal)))))) : t0_space (has_add (option (option (option (option ennreal))))) := sorry --non-trivial
lemma new_lemma_72738 (h1 : complete_lattice (has_nnnorm linarith.ineq)) : complete_lattice.is_Sup_finite_compact (has_nnnorm linarith.ineq) := sorry --non-trivial
lemma new_lemma_72739 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_neg_part.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg_part.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_72740 (h0 : functor.add_const (topological_space (mul_zero_class num)) empty) : @t1_space.{0} (mul_zero_class.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_72741 (h0 : topological_space (free_add_monoid num)) : t1_space (free_add_monoid num) := sorry --non-trivial
lemma new_lemma_72742 (h0 : function.extfun (Type 1) topological_space) : @sequential_space.{1} (simple_graph.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (simple_graph.{1} Type))  := sorry --non-trivial
lemma new_lemma_72743 (h0 : topological_space (ring (has_neg linarith.comp))) : regular_space (ring (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_72744 (h0 : ring (linear_ordered_semiring (semiring (semiring unsigned)))) : is_domain (linear_ordered_semiring (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_72745 (h0 : group (has_union congr_arg_kind)) : normalizer_condition (has_union congr_arg_kind) := sorry --non-trivial
lemma new_lemma_72746 (h0 : function.extfun Type (functor.add_const (uniform_space nnreal))) : complete_space nnreal := sorry --non-trivial
lemma new_lemma_72747 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_inter.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_inter.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_72748 (h0 : functor.add_const (topological_space (has_dist empty)) unsigned) : @t1_space.{0} (has_dist.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_dist.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_72749 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (has_nndist.{0} (option.{0} ennreal)) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (has_nndist.{0} (option.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_72750 (h0 : ring (simple_graph (mul_one_class (mul_one_class char)))) : rank_condition (simple_graph (mul_one_class (mul_one_class char))) := sorry --non-trivial
lemma new_lemma_72751 (h0 : add_monoid (has_Sup (semiring empty))) : add_monoid.fg (has_Sup (semiring empty)) := sorry --non-trivial
lemma new_lemma_72752 (h0 : topological_space (with_one congr_arg_kind)) : locally_compact_space (with_one congr_arg_kind) := sorry --non-trivial
lemma new_lemma_72753 (h0 : add_group (with_one (random_gen congr_arg_kind))) : is_add_cyclic (with_one (random_gen congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_72754 (h0 : filter (add_group (semiring linarith.comp))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_72755 (h0 : filter (metric_space (semiring (has_top empty)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_72756 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (add_cancel_comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_72757 (h0 : monoid (has_top (has_norm (measurable_space (has_one num))))) : monoid.fg (has_top (has_norm (measurable_space (has_one num)))) := sorry --non-trivial
lemma new_lemma_72758 (h0 : group (semi_normed_comm_ring (random_gen (random_gen string_imp)))) : group.fg (semi_normed_comm_ring (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_72759 (h0 : topological_space (has_add congr_arg_kind)) : preirreducible_space (has_add congr_arg_kind) := sorry --non-trivial
lemma new_lemma_72760 (h0 : topological_space (normed_group linarith.comp_source)) : path_connected_space (normed_group linarith.comp_source) := sorry --non-trivial
lemma new_lemma_72761 (h0 : functor.add_const (topological_space (add_comm_monoid name)) linarith.comp) : @preconnected_space.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_72762 (h0 : function.extfun (has_top linarith.comp_source) (fun (x : has_top linarith.comp_source), Prop)) : zzz_forall (function.extfun_app h0) := sorry --non-trivial
lemma new_lemma_72763 (h0 : functor.add_const (group (normed_comm_ring linarith.comp)) linarith.comp) : @normalizer_condition.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (normed_comm_ring.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_72764 (h0 : functor.add_const (monoid (add_cancel_monoid environment.implicit_infer_kind)) pos) : @monoid.fg.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (monoid.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_72765 (h0 : filter (has_one (semiring empty))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_72766 (h0 : function.extfun Type (functor.comp topological_space canonically_ordered_comm_semiring)) : @totally_separated_space.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} canonically_ordered_comm_semiring.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} canonically_ordered_comm_semiring.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_72767 (h0 : topological_space (with_bot (has_top linarith.comp_source))) : t0_space (with_bot (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_72768 (h0 : functor.comp monoid comm_group Type) : @monoid.fg.{1} (comm_group.{1} Type) (@functor.comp.run.{1 1 1} monoid.{1} comm_group.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_72769 (h0 : ring (uniform_space (mul_one_class (metric_space char)))) : rank_condition (uniform_space (mul_one_class (metric_space char))) := sorry --non-trivial
lemma new_lemma_72770 (h0 : complete_lattice (with_one (has_inv linarith.comp_source))) : complete_lattice.is_Sup_finite_compact (with_one (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_72771 (h0 : function.extfun Type group) : @group.fg.{0} (with_one.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (with_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_72772 (h0 : functor.add_const (complete_lattice (boolean_algebra.core name)) Type) : @complete_lattice.is_Sup_finite_compact.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 1} (complete_lattice.{0} (boolean_algebra.core.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_72773 (h0 : monoid (has_nndist (boolean_algebra (boolean_algebra (boolean_algebra Type))))) : monoid.fg (has_nndist (boolean_algebra (boolean_algebra (boolean_algebra Type)))) := sorry --non-trivial
lemma new_lemma_72774 (h0 : ring (linear_order empty)) : strong_rank_condition (linear_order empty) := sorry --non-trivial
lemma new_lemma_72775 : infinite fun_info := sorry --non-trivial
lemma new_lemma_72776 (h0 : functor.add_const (topological_space (add_left_cancel_semigroup unsigned)) empty) : @totally_disconnected_space.{0} (add_left_cancel_semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_left_cancel_semigroup.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_72777 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @regular_space.{0} (has_add.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_add.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_72778 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_72779 (h0 : functor.add_const (topological_space (complete_distrib_lattice linarith.comp)) pos) : @locally_compact_space.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_72780 (h0 : topological_space (has_ssubset string.iterator_imp)) : path_connected_space (has_ssubset string.iterator_imp) := sorry --non-trivial
lemma new_lemma_72781 (h0 : set (has_nnnorm char)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_72782 (h0 : functor.add_const (topological_space (normed_comm_ring pos)) (ring environment.implicit_infer_kind)) : @t1_space.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} pos)) (ring.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_72783 (h0 : topological_space (ring (option (option unsigned)))) : discrete_topology (ring (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_72784 (h0 : function.extfun Type topological_space) : @t1_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_72785 (h1 : uniform_space (random_gen (mul_one_class (mul_one_class char)))) : complete_space (random_gen (mul_one_class (mul_one_class char))) := sorry --non-trivial
lemma new_lemma_72786 (h0 : function.extfun Type (functor.add_const (ring (comm_semigroup unsigned)))) : @is_principal_ideal_ring.{0} (comm_semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (comm_semigroup.{0} unsigned)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} (comm_semigroup.{0} unsigned))) h0 empty))  := sorry --non-trivial
lemma new_lemma_72787 (h0 : topological_space (normed_comm_ring (option ennreal))) : path_connected_space (normed_comm_ring (option ennreal)) := sorry --non-trivial
lemma new_lemma_72788 (h0 : add_group (normed_comm_ring num)) : is_add_cyclic (normed_comm_ring num) := sorry --non-trivial
lemma new_lemma_72789 (h0 : functor.add_const (topological_space (normed_comm_ring name)) pos) : @discrete_topology.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_72790 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (pseudo_metric_space.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (pseudo_metric_space.{0} pos))  := sorry --non-trivial
lemma new_lemma_72791 (h0 : topological_space (bin_tree (semiring (semiring num)))) : totally_separated_space (bin_tree (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_72792 (h0 : complete_lattice (has_compl (has_nnnorm linarith.comp_source))) : is_compactly_generated (has_compl (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_72793 (h0 : uniform_space (has_le ereal)) : complete_space (has_le ereal) := sorry --non-trivial
lemma new_lemma_72794 (h0 : functor.add_const Prop (has_add (finset name))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_72795 (h0 : ring (uniform_space linarith.ineq)) : strong_rank_condition (uniform_space linarith.ineq) := sorry --non-trivial
lemma new_lemma_72796 (h0 : functor.add_const (monoid (has_zero linarith.comp)) pos) : @monoid.fg.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (monoid.{0} (has_zero.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_72797 (h0 : functor.comp topological_space has_neg_part unsigned) : @irreducible_space.{0} (has_neg_part.{0} unsigned) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg_part.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_72798 (h0 : monoid (comm_group (has_neg_part environment.implicit_infer_kind))) : monoid.fg (comm_group (has_neg_part environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_72799 (h0 : complete_lattice (linear_ordered_comm_group congr_arg_kind)) : is_atomistic (linear_ordered_comm_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_72800 (h0 : topological_space (canonically_ordered_comm_semiring (add_comm_monoid (normed_comm_ring pos)))) : path_connected_space (canonically_ordered_comm_semiring (add_comm_monoid (normed_comm_ring pos))) := sorry --non-trivial
lemma new_lemma_72801 (h0 : topological_space (ring (boolean_algebra (boolean_algebra Type)))) : totally_separated_space (ring (boolean_algebra (boolean_algebra Type))) := sorry --non-trivial
lemma new_lemma_72802 (h0 : functor.add_const (function.extfun Type semiring) Type) : @is_noetherian_ring.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type semiring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type semiring.{0}) Type h0) (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_72803 (h0 : add_group (normed_group (fintype fun_info))) : is_add_cyclic (normed_group (fintype fun_info)) := sorry --non-trivial
lemma new_lemma_72804 (h0 : plift (has_top empty) -> plift (has_top empty) -> bool) : is_dec_refl h0 := sorry --non-trivial
lemma new_lemma_72805 (h0 : add_group (with_bot (has_top (random_gen (has_top num))))) : is_add_cyclic (with_bot (has_top (random_gen (has_top num)))) := sorry --non-trivial
lemma new_lemma_72806 (h0 : functor.add_const (topological_space (mul_zero_class congr_arg_kind)) congr_arg_kind) : @t0_space.{0} (mul_zero_class.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_72807 (h0 : functor.add_const (topological_space (boolean_algebra.core unsigned)) Type) : @discrete_topology.{0} (boolean_algebra.core.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.core.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_72808 (h0 : has_mem.mem linarith.comp has_emptyc.emptyc) : @is_compactly_generated.{0} linarith.comp (@finset.pi.empty.{1 0} Type complete_lattice.{0} linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_72809 (h0 : filter (linear_ordered_semiring (add_group (has_norm linarith.comp)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_72810 (h0 : functor.add_const (topological_space (ring linarith.comp)) pos) : @irreducible_space.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_72811 (h0 : list (has_norm (random_gen (random_gen (random_gen (random_gen to_additive.value_type)))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_72812 (h0 : function.extfun (Type 1) ring) : @is_principal_ideal_ring.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_72813 (h0 : ring (has_neg_part (has_neg_part name))) : strong_rank_condition (has_neg_part (has_neg_part name)) := sorry --non-trivial
lemma new_lemma_72814 (h0 : topological_space (complete_distrib_lattice (has_neg linarith.comp))) : t1_space (complete_distrib_lattice (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_72815 (h0 : monoid (linear_ordered_field (option (option (option empty))))) : monoid.fg (linear_ordered_field (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_72816 (h0 : complete_lattice (has_pos_part pos)) : is_compactly_generated (has_pos_part pos) := sorry --non-trivial
lemma new_lemma_72817 (h0 : complete_lattice (div_inv_monoid (comm_ring fun_info))) : complete_lattice.is_Sup_finite_compact (div_inv_monoid (comm_ring fun_info)) := sorry --non-trivial
lemma new_lemma_72818 (h0 : functor.add_const (uniform_space (semigroup empty)) unsigned) : @separated_space.{0} (semigroup.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (semigroup.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_72819 (h0 : functor.comp complete_lattice has_neg pos) : @is_compactly_generated.{0} (has_neg.{0} pos) (@functor.comp.run.{0 0 0} complete_lattice.{0} has_neg.{0} pos (@functor.comp.run.{0 0 0} complete_lattice.{0} has_neg.{0} pos (@functor.comp.run.{0 0 0} complete_lattice.{0} has_neg.{0} pos h0)))  := sorry --non-trivial
lemma new_lemma_72820 (h0 : topological_space (mul_zero_class num)) : totally_disconnected_space (mul_zero_class num) := sorry --non-trivial
lemma new_lemma_72821 (h1 : set (mul_one_class std_gen -> char)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_72822 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (add_right_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (add_right_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_72823 (h0 : ring (cancel_monoid (option ennreal))) : strong_rank_condition (cancel_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_72824 (h0 : ring (id (semiring (semiring (has_norm (semiring empty)))))) : is_domain (id (semiring (semiring (has_norm (semiring empty))))) := sorry --non-trivial
lemma new_lemma_72825 (h0 : topological_space (has_neg name)) : regular_space (has_neg name) := sorry --non-trivial
lemma new_lemma_72826 (h0 : complete_lattice (has_nnnorm reducibility_hints)) : complete_lattice.is_Sup_finite_compact (has_nnnorm reducibility_hints) := sorry --non-trivial
lemma new_lemma_72827 (h0 : monoid (complete_linear_order (semiring congr_arg_kind))) : monoid.fg (complete_linear_order (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_72828 (h0 : complete_lattice (with_one linarith.comp)) : complete_lattice.is_Sup_finite_compact (with_one linarith.comp) := sorry --non-trivial
lemma new_lemma_72829 (h0 : functor.add_const (topological_space (has_to_string environment.implicit_infer_kind)) Type) : @path_connected_space.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (has_to_string.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_72830 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (group_with_zero.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (group_with_zero.{0} num))  := sorry --non-trivial
lemma new_lemma_72831 (h0 : topological_space (has_top (random_gen linarith.comp))) : discrete_topology (has_top (random_gen linarith.comp)) := sorry --non-trivial
lemma new_lemma_72832 (h0 : add_group (normed_comm_ring (add_comm_monoid name))) : is_add_cyclic (normed_comm_ring (add_comm_monoid name)) := sorry --non-trivial
lemma new_lemma_72833 (h0 : topological_space (distrib_lattice num)) : loc_path_connected_space (distrib_lattice num) := sorry --non-trivial
lemma new_lemma_72834 (h0 : topological_space (simple_graph (has_pos_part Type))) : loc_path_connected_space (simple_graph (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_72835 (h4 : topological_space (has_nnnorm char)) : path_connected_space (has_nnnorm char) := sorry --non-trivial
lemma new_lemma_72836 (h0 : has_mem.mem (has_top congr_arg_kind) has_emptyc.emptyc) : @irreducible_space.{0} (has_top.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_top.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_72837 (h0 : topological_space (has_top (has_norm (semiring (random_gen num))))) : locally_compact_space (has_top (has_norm (semiring (random_gen num)))) := sorry --non-trivial
lemma new_lemma_72838 (h0 : topological_space (has_bot (has_add (has_add (ordered_comm_monoid (has_Inf linarith.comp)))))) : discrete_topology (has_bot (has_add (has_add (ordered_comm_monoid (has_Inf linarith.comp))))) := sorry --non-trivial
lemma new_lemma_72839 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (normed_group.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_72840 (h0 : functor.add_const (topological_space (semigroup pos)) (has_to_string Type)) : @regular_space.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (semigroup.{0} pos)) (has_to_string.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_72841 (h0 : function.extfun Type ring) : @is_domain.{0} (has_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_72842 (h0 : topological_space (random_gen linarith.comp)) : totally_separated_space (random_gen linarith.comp) := sorry --non-trivial
lemma new_lemma_72843 (h0 : function.extfun Type topological_space) : @t1_space.{0} (option.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} empty))))))) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (option.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} empty))))))))  := sorry --non-trivial
lemma new_lemma_72844 (h0 : add_group (linear_order unsigned)) : is_add_cyclic (linear_order unsigned) := sorry --non-trivial
lemma new_lemma_72845 (h0 : topological_space (has_one (linear_ordered_semiring unsigned))) : preirreducible_space (has_one (linear_ordered_semiring unsigned)) := sorry --non-trivial
lemma new_lemma_72846 (h0 : topological_space (canonically_ordered_comm_semiring ennreal)) : totally_disconnected_space (canonically_ordered_comm_semiring ennreal) := sorry --non-trivial
lemma new_lemma_72847 (h0 : functor.add_const (topological_space (ordered_comm_ring linarith.comp)) pos) : @t0_space.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_72848 (h0 : group (linear_ordered_comm_ring num)) : group.fg (linear_ordered_comm_ring num) := sorry --non-trivial
lemma new_lemma_72849 (h0 : group (has_inter ennreal)) : normalizer_condition (has_inter ennreal) := sorry --non-trivial
lemma new_lemma_72850 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (canonically_linear_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (canonically_linear_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_72851 (h0 : topological_space (with_one (random_gen (random_gen (has_nnnorm to_additive.value_type))))) : locally_compact_space (with_one (random_gen (random_gen (has_nnnorm to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_72852 (h1 : topological_space (has_lt to_additive.value_type)) : path_connected_space (has_lt to_additive.value_type) := sorry --non-trivial
lemma new_lemma_72853 (h0 : ring (as_linear_order (option (option unsigned)))) : strong_rank_condition (as_linear_order (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_72854 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @regular_space.{0} (canonically_ordered_comm_semiring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (canonically_ordered_comm_semiring.{0} pos))  := sorry --non-trivial
lemma new_lemma_72855 (h0 : function.extfun Type topological_space) : @t1_space.{0} (semiring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_72856 (h0 : set (normed_field std_gen)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_72857 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (denumerable.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 topological_space.{0}) (denumerable.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_72858 (h0 h1 : multiset (simple_graph to_additive.value_type)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_72859 (h0 : functor.add_const (function.extfun Type cancel_comm_monoid_with_zero) unsigned) : @unique_factorization_monoid.{0} (normed_comm_ring.{0} name) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type cancel_comm_monoid_with_zero.{0}) unsigned h0) (normed_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_72860 (h4 : set (string.iterator_imp -> enat)) : set.separates_points h4 := sorry --non-trivial
lemma new_lemma_72861 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @locally_compact_space.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_72862 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (normed_group.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_72863 (h0 : complete_lattice (normed_group (has_top num))) : complete_lattice.is_Sup_finite_compact (normed_group (has_top num)) := sorry --non-trivial
lemma new_lemma_72864 (h0 : cancel_comm_monoid_with_zero (has_to_string (has_to_string unsigned))) : unique_factorization_monoid (has_to_string (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_72865 (h0 : ring (simple_graph (mul_one_class string_imp))) : is_domain (simple_graph (mul_one_class string_imp)) := sorry --non-trivial
lemma new_lemma_72866 (h0 : filter (semigroup (option Type))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_72867 (h0 : linear_ordered_comm_ring empty -> linear_ordered_comm_ring empty -> Prop) : is_equiv (linear_ordered_comm_ring empty) h0 := sorry --non-trivial
lemma new_lemma_72868 (h0 : uniform_space (linear_ordered_comm_group empty)) : complete_space (linear_ordered_comm_group empty) := sorry --non-trivial
lemma new_lemma_72869 (h0 : group (left_cancel_monoid (semiring num))) : normalizer_condition (left_cancel_monoid (semiring num)) := sorry --non-trivial
lemma new_lemma_72870 (h0 : topological_space (mul_zero_class (mul_zero_class Type))) : path_connected_space (mul_zero_class (mul_zero_class Type)) := sorry --non-trivial
lemma new_lemma_72871 (h0 : topological_space (linear_ordered_semiring fun_info)) : normal_space (linear_ordered_semiring fun_info) := sorry --non-trivial
lemma new_lemma_72872 (h0 : group (normed_field string.iterator_imp)) : is_cyclic (normed_field string.iterator_imp) := sorry --non-trivial
lemma new_lemma_72873 (h0 : functor.add_const Prop (has_neg ennreal)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_72874 (h0 : group (has_neg (ring (finset (finset Type))))) : group.fg (has_neg (ring (finset (finset Type)))) := sorry --non-trivial
lemma new_lemma_72875 (h0 : has_mem.mem (has_one empty) has_emptyc.emptyc) : @monoid.fg.{0} (has_one.{0} empty) (@finset.pi.empty.{1 0} Type monoid.{0} (has_one.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_72876 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (generalized_boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_72877 (h0 : not (cancel_comm_monoid_with_zero (linear_ordered_comm_ring congr_arg_kind) -> false)) : @unique_factorization_monoid.{0} (linear_ordered_comm_ring.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (cancel_comm_monoid_with_zero.{0} (linear_ordered_comm_ring.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_72878 (h0 : functor.add_const (list (has_to_string Type)) pos) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_72879 (h0 : functor.add_const (list (boolean_algebra.core unsigned)) (has_add Type)) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_72880 (h0 : functor.add_const (complete_lattice (add_comm_monoid Type)) (finset pos)) : @is_atomistic.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (add_comm_monoid.{1} Type)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_72881 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @is_cyclic.{0} (has_nndist.{0} pos) (@matrix.vec_empty.{0} (group.{0} (has_nndist.{0} pos)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_72882 (h0 : functor.add_const (cancel_comm_monoid_with_zero (add_right_cancel_monoid unsigned)) empty) : @unique_factorization_monoid.{0} (add_right_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (add_right_cancel_monoid.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_72883 (h0 : topological_space (finset (has_pos_part pos))) : path_connected_space (finset (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_72884 (h0 : function.extfun (Type 1) topological_space) : @regular_space.{1} (has_pos_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_pos_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_72885 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_72886 (h1 : complete_lattice (normed_field (semiring environment.projection_info))) : complete_lattice.is_Sup_finite_compact (normed_field (semiring environment.projection_info)) := sorry --non-trivial
lemma new_lemma_72887 (h0 : functor.add_const (uniform_space (has_Inf Type)) Type) : @separated_space.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 1} (uniform_space.{1} (has_Inf.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_72888 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (comm_semigroup.{0} name) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (comm_semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_72889 (h0 : fin has_zero.zero) : @t1_space.{1} (normed_lattice_add_comm_group.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (normed_lattice_add_comm_group.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_72890 (h0 : function.extfun Type (functor.add_const (cancel_comm_monoid_with_zero (comm_monoid empty)))) : @unique_factorization_monoid.{0} (comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (comm_monoid.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (cancel_comm_monoid_with_zero.{0} (comm_monoid.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_72891 (h0 : prod (option pos) (option pos)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_72892 (h0 : filter (measurable_space empty)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_72893 (h0 : functor.add_const (ordered_comm_monoid (has_to_string linarith.comp)) (ring linarith.comp)) : @has_exists_mul_of_le.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_to_string.{0} linarith.comp)) (ring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_72894 (h0 : functor.add_const (ring (bin_tree num)) congr_arg_kind) : @strong_rank_condition.{0} (bin_tree.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (bin_tree.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_72895 (h0 : functor.add_const (uniform_space (ring pos)) name) : @complete_space.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (ring.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_72896 (h0 : group (normed_comm_ring (option (option ennreal)))) : group.fg (normed_comm_ring (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_72897 (h0 : functor.add_const (ring (linear_order empty)) empty) : @rank_condition.{0} (linear_order.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (linear_order.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_72898 (h0 : function.extfun Type (functor.comp topological_space has_neg_part)) : @sequential_space.{0} (has_neg_part.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg_part.{0} ennreal (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} has_neg_part.{0}) h0 ennreal))  := sorry --non-trivial
lemma new_lemma_72899 (h0 : functor.add_const (group (complete_distrib_lattice unsigned)) unsigned) : @normalizer_condition.{0} (complete_distrib_lattice.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (complete_distrib_lattice.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_72900 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} to_additive.value_type (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) to_additive.value_type)  := sorry --non-trivial
lemma new_lemma_72901 (h0 : group (with_one (has_inv (has_inv linarith.comp_source)))) : normalizer_condition (with_one (has_inv (has_inv linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_72902 (h0 : not (complete_lattice (semiring (has_norm linarith.comp)) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (semiring.{0} (has_norm.{0} linarith.comp)) (@classical.by_contradiction'.{1} (complete_lattice.{0} (semiring.{0} (has_norm.{0} linarith.comp))) h0)  := sorry --non-trivial
lemma new_lemma_72903 (h0 : functor.add_const (group (complete_distrib_lattice pos)) real) : @group.fg.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (complete_distrib_lattice.{0} pos)) real h0)  := sorry --non-trivial
lemma new_lemma_72904 (h0 : topological_space (has_to_string (has_add (has_add (normed_comm_ring name))))) : preconnected_space (has_to_string (has_add (has_add (normed_comm_ring name)))) := sorry --non-trivial
lemma new_lemma_72905 (h0 : complete_lattice (with_bot empty)) : is_compactly_generated (with_bot empty) := sorry --non-trivial
lemma new_lemma_72906 (h0 : group (has_one num)) : group.fg (has_one num) := sorry --non-trivial
lemma new_lemma_72907 (h0 : has_Inf Type -> has_Inf Type -> Prop) : transitive h0 := sorry --non-trivial
lemma new_lemma_72908 (h1 : add_group (with_zero fun_info)) : is_add_cyclic (with_zero fun_info) := sorry --non-trivial
lemma new_lemma_72909 (h0 : ring (has_Inf name)) : strong_rank_condition (has_Inf name) := sorry --non-trivial
lemma new_lemma_72910 (h0 : ordered_comm_monoid (ring (has_add (has_add (has_add (has_add (has_Inf Type))))))) : has_exists_mul_of_le (ring (has_add (has_add (has_add (has_add (has_Inf Type)))))) := sorry --non-trivial
lemma new_lemma_72911 (h0 : has_mem.mem (normed_group num) has_emptyc.emptyc) : @totally_disconnected_space.{0} (normed_group.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (normed_group.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_72912 (h0 : functor.add_const (function.extfun Type group) (has_neg_part (comm_group Type))) : @normalizer_condition.{0} (has_zero.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type group.{0}) (has_neg_part.{1} (comm_group.{1} Type)) h0) (has_zero.{0} name))  := sorry --non-trivial
lemma new_lemma_72913 (h0 : topological_space (mul_one_class fun_info)) : path_connected_space (mul_one_class fun_info) := sorry --non-trivial
lemma new_lemma_72914 (h0 : not (ring (encodable fun_info) -> false)) : @is_domain.{0} (encodable.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (encodable.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_72915 (h0 : topological_space (has_top (id linarith.comp))) : normal_space (has_top (id linarith.comp)) := sorry --non-trivial
lemma new_lemma_72916 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} string_imp (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) string_imp)  := sorry --non-trivial
lemma new_lemma_72917 (h0 : fin has_zero.zero) : @t0_space.{0} (has_add.{0} name) (@matrix.vec_empty.{0} (topological_space.{0} (has_add.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_72918 (h0 : topological_space (cancel_monoid (option (option empty)))) : preirreducible_space (cancel_monoid (option (option empty))) := sorry --non-trivial
lemma new_lemma_72919 (h0 : group (linear_ordered_comm_ring (semiring (semiring (semiring empty))))) : group.fg (linear_ordered_comm_ring (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_72920 (h0 : topological_space (has_pos_part (has_add (sub_neg_monoid real)))) : totally_separated_space (has_pos_part (has_add (sub_neg_monoid real))) := sorry --non-trivial
lemma new_lemma_72921 (h0 : topological_space (simple_graph ereal)) (h1 : preorder (simple_graph ereal)) : order_closed_topology (simple_graph ereal) := sorry --non-trivial
lemma new_lemma_72922 (h3 : set (add_comm_semigroup fun_info -> std_gen)) : set.separates_points h3 := sorry --non-trivial
lemma new_lemma_72923 (h0 : functor.add_const (function.extfun Type topological_space) (has_pos_part pos)) : @discrete_topology.{0} (has_neg.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (has_pos_part.{0} pos) h0) (has_neg.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_72924 (h0 : ring (denumerable (random_gen (has_nnnorm (random_gen (random_gen char)))))) : strong_rank_condition (denumerable (random_gen (has_nnnorm (random_gen (random_gen char))))) := sorry --non-trivial
lemma new_lemma_72925 (h0 : topological_space (add_cancel_monoid (add_cancel_monoid name))) : totally_disconnected_space (add_cancel_monoid (add_cancel_monoid name)) := sorry --non-trivial
lemma new_lemma_72926 (h0 : functor.add_const (topological_space (ring pos)) (has_neg linarith.comp)) : @locally_compact_space.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} pos)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_72927 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (comm_semigroup.{0} real) (@function.extfun_app.{2 1} Type semiring.{0} h0 (comm_semigroup.{0} real))  := sorry --non-trivial
lemma new_lemma_72928 (h1 : complete_lattice (fintype (random_gen to_additive.value_type))) : complete_lattice.is_Sup_finite_compact (fintype (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_72929 (h0 : function.extfun Type topological_space) : @t0_space.{0} (boolean_algebra.core.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} empty))  := sorry --non-trivial
lemma new_lemma_72930 (h0 : group (has_to_string (has_to_string ennreal))) : group.fg (has_to_string (has_to_string ennreal)) := sorry --non-trivial
lemma new_lemma_72931 (h0 : topological_space (semiring (semiring congr_arg_kind))) : totally_separated_space (semiring (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_72932 (h0 : group (has_neg (ordered_ring pos))) : normalizer_condition (has_neg (ordered_ring pos)) := sorry --non-trivial
lemma new_lemma_72933 (h0 : topological_space (has_norm (has_nnnorm (has_nnnorm (random_gen (has_nnnorm linarith.comp_source)))))) : t0_space (has_norm (has_nnnorm (has_nnnorm (random_gen (has_nnnorm linarith.comp_source))))) := sorry --non-trivial
lemma new_lemma_72934 (h0 : functor.add_const (topological_space (cancel_monoid Type)) Type) : @t1_space.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (cancel_monoid.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_72935 (h0 : topological_space (has_one (semiring empty))) : path_connected_space (has_one (semiring empty)) := sorry --non-trivial
lemma new_lemma_72936 (h0 : complete_lattice (monoid_with_zero (has_zero (option unsigned)))) : is_atomistic (monoid_with_zero (has_zero (option unsigned))) := sorry --non-trivial
lemma new_lemma_72937 (h0 : topological_space (has_neg (has_pos_part linarith.comp))) : locally_compact_space (has_neg (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_72938 (h0 : group (monoid_with_zero congr_arg_kind)) : group.fg (monoid_with_zero congr_arg_kind) := sorry --non-trivial
lemma new_lemma_72939 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (add_comm_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (add_comm_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_72940 (h0 : topological_space (has_add Type)) : totally_separated_space (has_add Type) := sorry --non-trivial
lemma new_lemma_72941 (h0 : ring (fintype (linear_ordered_add_comm_group (random_gen to_additive.value_type)))) : is_domain (fintype (linear_ordered_add_comm_group (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_72942 (h0 : functor.comp filter has_neg_part name) : filter.ne_bot (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_72943 (h0 : function.extfun Type topological_space) : @t0_space.{0} (complete_distrib_lattice.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_72944 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_72945 (h0 : cancel_comm_monoid_with_zero (mul_zero_class (finset ennreal))) : unique_factorization_monoid (mul_zero_class (finset ennreal)) := sorry --non-trivial
lemma new_lemma_72946 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (has_to_string.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_to_string.{0} name))  := sorry --non-trivial
lemma new_lemma_72947 (h0 : ring (add_left_cancel_semigroup unsigned)) : strong_rank_condition (add_left_cancel_semigroup unsigned) := sorry --non-trivial
lemma new_lemma_72948 (h0 : topological_space (ordered_ring num)) : normal_space (ordered_ring num) := sorry --non-trivial
lemma new_lemma_72949 (h0 : list (has_add (has_pos_part linarith.comp))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_72950 (h0 : complete_lattice (monoid ennreal)) : complete_lattice.is_Sup_finite_compact (monoid ennreal) := sorry --non-trivial
lemma new_lemma_72951 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (complete_distrib_lattice.{0} pos) (@function.extfun_app.{2 1} Type add_group.{0} h0 (complete_distrib_lattice.{0} pos))  := sorry --non-trivial
lemma new_lemma_72952 (h1 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (complete_semilattice_Sup.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (complete_semilattice_Sup.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_72953 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (distrib_lattice.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (distrib_lattice.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_72954 (h0 : group (add_cancel_monoid (semiring (semiring empty)))) : is_cyclic (add_cancel_monoid (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_72955 (h0 : topological_space (filter (option unsigned))) : locally_compact_space (filter (option unsigned)) := sorry --non-trivial
lemma new_lemma_72956 (h0 : functor.add_const (list (ring linarith.comp)) pos) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_72957 (h0 : not (has_mem.mem (function.extfun Type) has_emptyc.emptyc -> false)) : @path_connected_space.{0} (has_emptyc.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@finset.pi.empty.{2 1} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{0} (@has_mem.mem.{2 2} ((Type → Type) → Type 1) (finset.{2} ((Type → Type) → Type 1)) (@finset.has_mem.{2} ((Type → Type) → Type 1)) (function.extfun.{2 1} Type) (@has_emptyc.emptyc.{2} (finset.{2} ((Type → Type) → Type 1)) (@finset.has_emptyc.{2} ((Type → Type) → Type 1)))) h0)) topological_space.{0}) (has_emptyc.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_72958 (h1 : function.extfun Type topological_space) : @t0_space.{0} (denumerable.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (denumerable.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_72959 (h0 : uniform_space (has_le linarith.ineq)) : complete_space (has_le linarith.ineq) := sorry --non-trivial
lemma new_lemma_72960 (h0 : functor.add_const (topological_space (has_nndist Type)) linarith.comp) : @topological_space.separable_space.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_nndist.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_72961 (h0 : function.extfun Type group) : @normalizer_condition.{0} (add_group.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (add_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_72962 (h2 : topological_space fun_info) : topological_space.first_countable_topology fun_info := sorry --non-trivial
lemma new_lemma_72963 (h0 : finset (add_cancel_monoid (option unsigned))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_72964 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_zero.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (has_zero.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_72965 (h0 : add_group (distrib (has_nnnorm (has_lt char)))) : is_add_cyclic (distrib (has_nnnorm (has_lt char))) := sorry --non-trivial
lemma new_lemma_72966 (h0 : function.extfun Type ring) : @is_domain.{0} (comm_group.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_72967 (h0 : complete_lattice (group_with_zero (option (option (option (option ennreal)))))) : complete_lattice.is_Sup_finite_compact (group_with_zero (option (option (option (option ennreal))))) := sorry --non-trivial
lemma new_lemma_72968 (h0 : filter (add_left_cancel_monoid to_additive.value_type)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_72969 (h0 : fin has_zero.zero) : @monoid.fg.{1} (canonically_ordered_comm_semiring.{1} Type) (@function.extfun_app.{3 2} (Type 1) monoid.{1} (@matrix.vec_empty.{2} (function.extfun.{3 2} (Type 1) monoid.{1}) h0) (canonically_ordered_comm_semiring.{1} Type))  := sorry --non-trivial
lemma new_lemma_72970 (h0 : set (non_unital_non_assoc_semiring enat)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_72971 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (finset.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (finset.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_72972 (h0 : functor.add_const (topological_space (comm_group unsigned)) (has_neg name)) : @preirreducible_space.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} unsigned)) (has_neg.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_72973 (h0 : ring (ordered_cancel_add_comm_monoid (option (option unsigned)))) : strong_rank_condition (ordered_cancel_add_comm_monoid (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_72974 (h1 : complete_lattice (has_nnnorm (has_inv to_additive.value_type))) : is_compactly_generated (has_nnnorm (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_72975 (h0 : filter (canonically_ordered_comm_semiring (comm_group (semigroup name)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_72976 (h0 : topological_space (id (semiring (semiring (semiring unsigned))))) : path_connected_space (id (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_72977 (h0 : functor.add_const (ring (finset name)) (ring (ring (ring environment.implicit_infer_kind)))) : @is_domain.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (finset.{0} name)) (ring.{0} (ring.{0} (ring.{0} environment.implicit_infer_kind))) h0)  := sorry --non-trivial
lemma new_lemma_72978 (h1 : preorder string.iterator_imp) (h2 : set string.iterator_imp) : set.is_pwo h2 := sorry --non-trivial
lemma new_lemma_72979 (h0 : functor.add_const (topological_space (has_zero name)) name) : @totally_disconnected_space.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_72980 (h0 : complete_lattice (mul_zero_class ennreal)) : is_compactly_generated (mul_zero_class ennreal) := sorry --non-trivial
lemma new_lemma_72981 (h0 : functor.add_const (topological_space (has_zero Type)) pos) : @totally_disconnected_space.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_zero.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_72982 (h0 : topological_space (boolean_algebra.core linarith.comp)) : topological_space.separable_space (boolean_algebra.core linarith.comp) := sorry --non-trivial
lemma new_lemma_72983 (h0 : complete_lattice (mul_one_class (mul_one_class string.iterator_imp))) : is_compactly_generated (mul_one_class (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_72984 (h0 : ring (has_add (option unsigned))) : is_principal_ideal_ring (has_add (option unsigned)) := sorry --non-trivial
lemma new_lemma_72985 (h0 : complete_lattice (add_comm_monoid (metric_space char))) : is_compactly_generated (add_comm_monoid (metric_space char)) := sorry --non-trivial
lemma new_lemma_72986 (h0 : complete_lattice (linear_ordered_field pos)) : is_atomistic (linear_ordered_field pos) := sorry --non-trivial
lemma new_lemma_72987 (h0 h1 : ulower pnat) : pnat.coprime (ulower.up h0) (id (id (ulower.up h1))) := sorry --non-trivial
lemma new_lemma_72988 (h0 : function.extfun Type (functor.comp group cancel_monoid)) : @group.fg.{0} (cancel_monoid.{0} name) (@functor.comp.run.{0 0 0} group.{0} cancel_monoid.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} group.{0} cancel_monoid.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_72989 (h0 : monoid (finset (option ennreal))) : monoid.fg (finset (option ennreal)) := sorry --non-trivial
lemma new_lemma_72990 (h0 : topological_space (distrib_lattice (has_inv (has_inv linarith.comp_source)))) : locally_compact_space (distrib_lattice (has_inv (has_inv linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_72991 (h1 : group to_additive.value_type) : normalizer_condition to_additive.value_type := sorry --non-trivial
lemma new_lemma_72992 (h0 : add_group (finset (has_add name))) : is_add_cyclic (finset (has_add name)) := sorry --non-trivial
lemma new_lemma_72993 (h0 : functor.add_const (group (has_nndist unsigned)) (has_add pos)) : @is_simple_group.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (has_nndist.{0} unsigned)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_72994 (h1 : function.extfun Type group) : @is_cyclic.{0} (random_gen.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} h1 (random_gen.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_72995 (h0 : topological_space (has_edist congr_arg_kind)) : preirreducible_space (has_edist congr_arg_kind) := sorry --non-trivial
lemma new_lemma_72996 (h0 : functor.add_const (topological_space (has_neg linarith.comp)) environment.implicit_infer_kind) : @regular_space.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_72997 (h0 : ring (non_unital_non_assoc_semiring linarith.comp_source)) : is_domain (non_unital_non_assoc_semiring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_72998 (h0 : filter (ordered_cancel_add_comm_monoid ennreal)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_72999 (h0 : filter (ordered_comm_group (option unsigned))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_73000 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @normal_space.{0} (generalized_boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (generalized_boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_73001 (h0 : not (has_mem.mem complete_lattice has_emptyc.emptyc -> false)) : @is_atomistic.{0} (with_one.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) complete_lattice.{0} (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type)))) h0)) (with_one.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_73002 (h0 : uniform_space (with_bot (has_inv (has_inv (random_gen linarith.comp_source))))) : complete_space (with_bot (has_inv (has_inv (random_gen linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_73003 (h0 : functor.add_const (function.extfun (Type 1) topological_space) (has_pos_part linarith.comp)) : @sequential_space.{1} (has_pos_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) (has_pos_part.{0} linarith.comp) h0) (has_pos_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_73004 (h0 : functor.add_const (filter (has_zero environment.implicit_infer_kind)) pos) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_73005 (h0 : ring (with_bot (semiring (semiring (semiring empty))))) : is_principal_ideal_ring (with_bot (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_73006 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (with_bot string_imp)) := sorry --non-trivial
lemma new_lemma_73007 (h0 : group (omega_complete_partial_order num)) : group.fg (omega_complete_partial_order num) := sorry --non-trivial
lemma new_lemma_73008 (h0 : complete_lattice (has_inv (has_norm linarith.ineq))) : complete_lattice.is_Sup_finite_compact (has_inv (has_norm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_73009 (h0 : ring (as_linear_order congr_arg_kind)) : is_domain (as_linear_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_73010 (h1 : topological_space linarith.comp_source) : t0_space linarith.comp_source := sorry --non-trivial
lemma new_lemma_73011 (h0 : topological_space (has_nnnorm (random_gen int))) : path_connected_space (has_nnnorm (random_gen int)) := sorry --non-trivial
lemma new_lemma_73012 (h2 : add_group (non_unital_non_assoc_semiring (linear_ordered_comm_group_with_zero char))) : is_add_cyclic (non_unital_non_assoc_semiring (linear_ordered_comm_group_with_zero char)) := sorry --non-trivial
lemma new_lemma_73013 (h0 : ordered_add_comm_monoid (ordered_cancel_add_comm_monoid (option (option empty)))) : archimedean (ordered_cancel_add_comm_monoid (option (option empty))) := sorry --non-trivial
lemma new_lemma_73014 (h0 : functor.add_const (list (normed_comm_ring Type)) environment.implicit_infer_kind) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_73015 (h0 : group (comm_ring (has_nnnorm linarith.comp_source))) : is_cyclic (comm_ring (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_73016 (h0 : cancel_comm_monoid_with_zero (sub_neg_monoid pos)) : unique_factorization_monoid (sub_neg_monoid pos) := sorry --non-trivial
lemma new_lemma_73017 (h0 : functor.comp topological_space canonically_ordered_comm_semiring name) : @t1_space.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} canonically_ordered_comm_semiring.{0} name h0)  := sorry --non-trivial
lemma new_lemma_73018 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_dist.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_dist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_73019 (h0 : functor.add_const (topological_space (has_add Type)) pos) : @sequential_space.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_add.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_73020 (h0 : ring (has_append (has_nnnorm (has_nnnorm (has_nnnorm reducibility_hints))))) : strong_rank_condition (has_append (has_nnnorm (has_nnnorm (has_nnnorm reducibility_hints)))) := sorry --non-trivial
lemma new_lemma_73021 (h0 : group (plift (has_Sup unsigned))) : is_cyclic (plift (has_Sup unsigned)) := sorry --non-trivial
lemma new_lemma_73022 (h0 : uniform_space (has_inv (has_inv linarith.ineq))) : complete_space (has_inv (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_73023 (h0 : functor.comp (prod (comm_group Type)) comm_group Type) : id_rel (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_73024 (h0 : topological_space (linear_ordered_comm_group ennreal)) : t0_space (linear_ordered_comm_group ennreal) := sorry --non-trivial
lemma new_lemma_73025 (h0 : function.extfun Type topological_space) : @t0_space.{0} (boolean_algebra.core.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} pos))  := sorry --non-trivial
lemma new_lemma_73026 (h0 : has_top (has_top (semiring (semiring empty))) -> has_top (has_top (semiring (semiring empty))) -> Prop) : is_strict_order (has_top (has_top (semiring (semiring empty)))) h0 := sorry --non-trivial
lemma new_lemma_73027 (h0 : complete_lattice (has_compl (has_norm (has_norm linarith.ineq)))) : complete_lattice.is_Sup_finite_compact (has_compl (has_norm (has_norm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_73028 (h0 : functor.add_const (topological_space (semigroup Type)) linarith.comp) : @discrete_topology.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (semigroup.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_73029 (h0 : add_group (option (option pos))) : is_add_cyclic (option (option pos)) := sorry --non-trivial
lemma new_lemma_73030 (h5 : uniform_space (denumerable char)) : complete_space (denumerable char) := sorry --non-trivial
lemma new_lemma_73031 (h0 : set (mul_one_class linarith.comp_source)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_73032 (h0 : functor.add_const (topological_space (has_zero unsigned)) linarith.comp) : @normal_space.{0} (has_zero.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_73033 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (@id.{2} Type congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (@id.{2} Type congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_73034 (h0 : topological_space (ordered_comm_ring (has_add name))) : normal_space (ordered_comm_ring (has_add name)) := sorry --non-trivial
lemma new_lemma_73035 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @totally_disconnected_space.{0} (comm_ring.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) topological_space.{0}) (comm_ring.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_73036 (h0 : semiring (has_pos_part (has_Inf (has_Inf pos)))) : is_noetherian_ring (has_pos_part (has_Inf (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_73037 (h0 : functor.add_const (list (has_zero environment.implicit_infer_kind)) (finset environment.implicit_infer_kind)) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_73038 (h0 : ring (has_le linarith.ineq)) : rank_condition (has_le linarith.ineq) := sorry --non-trivial
lemma new_lemma_73039 (h0 : functor.add_const (functor.add_const (topological_space nnreal) num) num) : normal_space nnreal := sorry --non-trivial
lemma new_lemma_73040 (h0 : ring (ring (ring (ring linarith.comp)))) : is_domain (ring (ring (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_73041 (h0 : ring (nondiscrete_normed_field (normed_field char))) : rank_condition (nondiscrete_normed_field (normed_field char)) := sorry --non-trivial
lemma new_lemma_73042 (h0 : functor.add_const (group (boolean_algebra.core name)) (semigroup (has_nndist pos))) : @is_simple_group.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.core.{0} name)) (semigroup.{0} (has_nndist.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_73043 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (pseudo_metric_space.{0} (option.{0} unsigned)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (pseudo_metric_space.{0} (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_73044 (h0 : add_monoid (has_one empty)) : add_monoid.fg (has_one empty) := sorry --non-trivial
lemma new_lemma_73045 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (semiring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_73046 (h0 : function.extfun Type (functor.add_const (topological_space (semigroup empty)))) : @topological_space.separable_space.{0} (semigroup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (semigroup.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_73047 (h0 : filter (finset (has_neg (has_neg (has_neg (has_neg (has_Inf (finset linarith.comp)))))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_73048 (h1 : topological_space (random_gen to_additive.value_type)) : t0_space (random_gen to_additive.value_type) := sorry --non-trivial
lemma new_lemma_73049 (h0 : topological_space (ring (has_pos_part Type))) : irreducible_space (ring (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_73050 (h0 : functor.add_const (add_group (ordered_comm_ring pos)) (has_add name)) : @is_add_cyclic.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (ordered_comm_ring.{0} pos)) (has_add.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_73051 (h0 : list (add_cancel_monoid (option unsigned))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_73052 (h0 : topological_space (boolean_algebra (semigroup environment.implicit_infer_kind))) : topological_space.separable_space (boolean_algebra (semigroup environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_73053 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (@id.{2} Type empty) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (@id.{2} Type empty))  := sorry --non-trivial
lemma new_lemma_73054 (h0 : topological_space (boolean_algebra.core name)) : loc_path_connected_space (boolean_algebra.core name) := sorry --non-trivial
lemma new_lemma_73055 (h0 : topological_space (simple_graph (has_to_string Type))) : loc_path_connected_space (simple_graph (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_73056 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (has_bot.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_bot.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_73057 (h0 : option (has_lt environment.projection_info)) (h1 : coe_sort (option.is_some h0)) : @no_max_order.{0} environment.projection_info (@option.get.{0} (has_lt.{0} environment.projection_info) h0 h1)  := sorry --non-trivial
lemma new_lemma_73058 (h0 : complete_lattice (ordered_comm_ring (boolean_algebra (has_Inf (has_Inf (has_neg real)))))) : is_atomistic (ordered_comm_ring (boolean_algebra (has_Inf (has_Inf (has_neg real))))) := sorry --non-trivial
lemma new_lemma_73059 (h0 : uniform_space (add_comm_monoid ennreal)) : separated_space (add_comm_monoid ennreal) := sorry --non-trivial
lemma new_lemma_73060 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} (normed_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (normed_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_73061 (h0 : option (topological_space (has_compl char))) (h1 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} (has_compl.{0} char) (@option.get_or_else.{0} (topological_space.{0} (has_compl.{0} char)) h0 (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h1) (has_compl.{0} char)))  := sorry --non-trivial
lemma new_lemma_73062 (h1 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h1 (measurable_space to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_73063 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_to_string.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_73064 (h1 : false) : false.elim h1 := sorry --trivial
lemma new_lemma_73065 (h0 : function.extfun Type group) : @is_simple_group.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} h0 (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_73066 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @totally_separated_space.{0} (has_emptyc.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (has_emptyc.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_73067 (h0 : set (enat -> add_comm_semigroup linarith.ineq)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_73068 (h0 : complete_lattice (boolean_algebra.core (has_nnnorm linarith.comp_source))) : complete_lattice.is_Sup_finite_compact (boolean_algebra.core (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_73069 (h0 : topological_space (add_cancel_monoid (has_to_string ennreal))) : locally_compact_space (add_cancel_monoid (has_to_string ennreal)) := sorry --non-trivial
lemma new_lemma_73070 (h0 : function.extfun Type topological_space) : @t1_space.{0} (canonically_linear_ordered_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_linear_ordered_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_73071 (h0 : uniform_space (random_gen (metric_space linarith.comp_source))) : complete_space (random_gen (metric_space linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_73072 (h0 : topological_space (has_add (has_add real))) : path_connected_space (has_add (has_add real)) := sorry --non-trivial
lemma new_lemma_73073 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semigroup.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_73074 (h0 : functor.add_const (ring (add_group unsigned)) unsigned) : @strong_rank_condition.{0} (add_group.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (add_group.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_73075 (h0 : functor.add_const (topological_space (left_cancel_monoid congr_arg_kind)) empty) : @totally_separated_space.{0} (left_cancel_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_73076 (h0 : uniform_space (mul_one_class (mul_one_class char))) : complete_space (mul_one_class (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_73077 (h0 : set (has_div linarith.comp_source)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_73078 (h0 : topological_space (normed_group empty)) : irreducible_space (normed_group empty) := sorry --non-trivial
lemma new_lemma_73079 (h0 : set (semi_normed_comm_ring (mul_one_class linarith.comp_source))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_73080 (h0 : not (ring (semi_normed_ring linarith.ineq) -> false)) : @strong_rank_condition.{0} (semi_normed_ring.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (semi_normed_ring.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_73081 (h0 : functor.add_const (function.extfun Type complete_lattice) (option (mul_zero_class name))) : @is_atomistic.{0} (has_add.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) (option.{0} (mul_zero_class.{0} name)) h0) (has_add.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_73082 (h0 : list (boolean_algebra (boolean_algebra name))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_73083 (h0 : semiring (has_bot congr_arg_kind)) : is_noetherian_ring (has_bot congr_arg_kind) := sorry --non-trivial
lemma new_lemma_73084 (h1 : ring (has_ssubset to_additive.value_type)) : rank_condition (has_ssubset to_additive.value_type) := sorry --non-trivial
lemma new_lemma_73085 (h0 : topological_space (comm_group (boolean_algebra.core name))) : preconnected_space (comm_group (boolean_algebra.core name)) := sorry --non-trivial
lemma new_lemma_73086 (h0 : functor.add_const (topological_space (has_bot real)) real) : @path_connected_space.{0} (has_bot.{0} real) (@functor.add_const.run.{0 0} (topological_space.{0} (has_bot.{0} real)) real h0)  := sorry --non-trivial
lemma new_lemma_73087 (h0 : topological_space (has_star (semiring (semiring empty)))) : locally_compact_space (has_star (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_73088 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_73089 (h0 : finset (ordered_comm_ring (finset pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_73090 (h0 : ring (add_cancel_monoid (has_Inf pos))) : rank_condition (add_cancel_monoid (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_73091 (h0 : topological_space (finset (finset (finset Type)))) : path_connected_space (finset (finset (finset Type))) := sorry --non-trivial
lemma new_lemma_73092 (h1 : ring (linear_ordered_add_comm_group (random_gen (random_gen char)))) : is_domain (linear_ordered_add_comm_group (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_73093 (h0 : topological_space (with_bot (semiring unsigned))) : irreducible_space (with_bot (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_73094 (h0 : ring (encodable (has_nnnorm (has_nnnorm (has_nnnorm linarith.ineq))))) : rank_condition (encodable (has_nnnorm (has_nnnorm (has_nnnorm linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_73095 (h0 : filter (comm_group (has_to_string unsigned))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_73096 (h0 : group (semigroup (boolean_algebra Type))) : normalizer_condition (semigroup (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_73097 (h0 : functor.add_const (add_monoid (normed_comm_ring unsigned)) linarith.comp) : @add_monoid.fg.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 0} (add_monoid.{0} (normed_comm_ring.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_73098 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @separated_space.{1} (add_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (uniform_space.{1} (add_comm_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_73099 (h2 : topological_space (comm_ring to_additive.value_type)) : totally_disconnected_space (comm_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_73100 (h0 : group (has_top (semiring empty))) : group.fg (has_top (semiring empty)) := sorry --non-trivial
lemma new_lemma_73101 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_73102 (h0 : topological_space (nondiscrete_normed_field linarith.ineq)) : totally_disconnected_space (nondiscrete_normed_field linarith.ineq) := sorry --non-trivial
lemma new_lemma_73103 (h0 : complete_lattice (has_nnnorm (has_nnnorm to_additive.value_type))) : complete_lattice.is_Sup_finite_compact (has_nnnorm (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_73104 (h0 : topological_space (left_cancel_monoid (semiring (semiring num)))) : totally_separated_space (left_cancel_monoid (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_73105 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_73106 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_73107 (h0 : functor.add_const (topological_space (has_add name)) linarith.comp) : @regular_space.{0} (has_add.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_73108 (h0 : add_comm_group (has_norm num)) (h1 : has_norm (has_norm num)) : subsingleton (normed_group.core (has_norm num)) := sorry --non-trivial
lemma new_lemma_73109 (h0 : function.extfun nat fin) : @regular_space.{1} (ordered_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (ordered_comm_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_73110 (h0 : add_group (has_ssubset (mul_one_class reducibility_hints))) : is_add_cyclic (has_ssubset (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_73111 (h0 : ring (metric_space num)) : rank_condition (metric_space num) := sorry --non-trivial
lemma new_lemma_73112 (h2 : not (topological_space (complete_semilattice_Sup congr_arg_kind) -> false)) : @totally_disconnected_space.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (complete_semilattice_Sup.{0} congr_arg_kind)) h2)  := sorry --non-trivial
lemma new_lemma_73113 (h0 : add_monoid (add_cancel_monoid (has_inter ennreal))) : add_monoid.fg (add_cancel_monoid (has_inter ennreal)) := sorry --non-trivial
lemma new_lemma_73114 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_73115 (h0 : ring (linear_ordered_comm_ring (semiring (semiring num)))) : is_domain (linear_ordered_comm_ring (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_73116 (h0 : functor.add_const (topological_space (non_assoc_semiring unsigned)) empty) : @t1_space.{0} (non_assoc_semiring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (non_assoc_semiring.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_73117 (h0 : not (topological_space (non_assoc_semiring empty) -> false)) : @locally_compact_space.{0} (non_assoc_semiring.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (non_assoc_semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_73118 (h0 : functor.add_const (finset (simple_graph name)) pos) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_73119 (h0 : topological_space (complete_distrib_lattice (has_pos_part linarith.comp))) : t1_space (complete_distrib_lattice (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_73120 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} ennreal (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) ennreal)  := sorry --non-trivial
lemma new_lemma_73121 (h0 : not (topological_space (has_union fun_info) -> false)) : @path_connected_space.{0} (has_union.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (has_union.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_73122 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (left_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} h0 (left_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_73123 (h0 : topological_space (complete_semilattice_Sup linarith.comp_source)) : locally_compact_space (complete_semilattice_Sup linarith.comp_source) := sorry --non-trivial
lemma new_lemma_73124 (h0 : functor.add_const (function.extfun Type add_group) pos) : @is_add_cyclic.{0} (ordered_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_group.{0}) pos h0) (ordered_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_73125 (h0 : topological_space (linear_ordered_comm_group (option (option empty)))) : preirreducible_space (linear_ordered_comm_group (option (option empty))) := sorry --non-trivial
lemma new_lemma_73126 (h0 : function.extfun Type (functor.comp topological_space has_to_string)) : @normal_space.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} has_to_string.{0} environment.implicit_infer_kind (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} has_to_string.{0}) h0 environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_73127 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (mul_zero_class.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (mul_zero_class.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_73128 (h0 : function.extfun Type (functor.add_const (topological_space (semigroup empty)))) : @totally_disconnected_space.{0} (semigroup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (semigroup.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_73129 (h0 : add_monoid (has_neg (ring linarith.comp))) : add_monoid.fg (has_neg (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_73130 (h0 : group (add_cancel_monoid (has_neg (boolean_algebra environment.implicit_infer_kind)))) : group.fg (add_cancel_monoid (has_neg (boolean_algebra environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_73131 (h7 : topological_space (random_gen (mul_one_class string_imp))) : totally_disconnected_space (random_gen (mul_one_class string_imp)) := sorry --non-trivial
lemma new_lemma_73132 (h0 : topological_space (boolean_algebra unsigned)) : regular_space (boolean_algebra unsigned) := sorry --non-trivial
lemma new_lemma_73133 (h0 : ring (has_div reducibility_hints)) : strong_rank_condition (has_div reducibility_hints) := sorry --non-trivial
lemma new_lemma_73134 (h0 : functor.add_const (group (has_to_string Type)) environment.implicit_infer_kind) : @group.fg.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (has_to_string.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_73135 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_73136 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (linear_ordered_add_comm_group.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_add_comm_group.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_73137 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (monoid_with_zero pos)) := sorry --non-trivial
lemma new_lemma_73138 (h0 : functor.add_const (function.extfun (Type 1) topological_space) pos) : @irreducible_space.{1} (boolean_algebra.core.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) pos h0) (boolean_algebra.core.{1} Type))  := sorry --non-trivial
lemma new_lemma_73139 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (normed_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_73140 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_73141 (h0 : filter (sub_neg_monoid (has_add linarith.comp))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_73142 (h0 : ordered_comm_monoid (has_nndist (has_to_string linarith.comp))) : has_exists_mul_of_le (has_nndist (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_73143 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : list.nodup (function.extfun_app (function.extfun_app h0 list) (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_73144 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semigroup.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_73145 (h0 : topological_space (with_bot (semiring unsigned))) : preirreducible_space (with_bot (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_73146 (h0 : topological_space (has_ssubset ereal)) : t2_5_space (has_ssubset ereal) := sorry --non-trivial
lemma new_lemma_73147 (h0 : topological_space (complete_semilattice_Sup string_imp)) (h1 : add_group (complete_semilattice_Sup string_imp)) : topological_add_group (complete_semilattice_Sup string_imp) := sorry --non-trivial
lemma new_lemma_73148 (h0 : topological_space (ring (comm_group Type))) : loc_path_connected_space (ring (comm_group Type)) := sorry --non-trivial
lemma new_lemma_73149 (h0 : ring (normed_group (has_top num))) : is_domain (normed_group (has_top num)) := sorry --non-trivial
lemma new_lemma_73150 (h0 : filter (finset (has_zero (add_cancel_monoid (has_zero linarith.comp))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_73151 (h0 : topological_space (semigroup (finset (finset linarith.comp)))) : loc_path_connected_space (semigroup (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_73152 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @sequential_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (boolean_algebra.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_73153 (h3 : filter (linear_ordered_add_comm_group to_additive.value_type)) : filter.ne_bot h3 := sorry --non-trivial
lemma new_lemma_73154 (h0 : function.extfun Type ring) : @is_domain.{0} (finset.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (finset.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_73155 (h0 : ring linarith.comp) (h1 : function.extfun (finset Type) (has_mem.mem (ring.total_positive_cone linarith.comp))) : @is_compactly_generated.{0} (@ring.total_positive_cone.{0} linarith.comp h0) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (@ring.total_positive_cone.{0} linarith.comp h0) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (@ring.total_positive_cone.{0} linarith.comp h0)) h1 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_73156 (h0 : ring (topological_space (with_zero char))) : strong_rank_condition (topological_space (with_zero char)) := sorry --non-trivial
lemma new_lemma_73157 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (linear_ordered_field.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_field.{0} name))  := sorry --non-trivial
lemma new_lemma_73158 (h0 : ring (semiring (semiring congr_arg_kind))) : rank_condition (semiring (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_73159 (h0 : topological_space (with_one (random_gen string_imp))) : t0_space (with_one (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_73160 (h0 : topological_space (semi_normed_ring (comm_ring (comm_ring char)))) : t0_space (semi_normed_ring (comm_ring (comm_ring char))) := sorry --non-trivial
lemma new_lemma_73161 (h1 : not (uniform_space (measurable_space linarith.comp) -> false)) : @complete_space.{0} (measurable_space.{0} linarith.comp) (@classical.by_contradiction'.{1} (uniform_space.{0} (measurable_space.{0} linarith.comp)) h1)  := sorry --non-trivial
lemma new_lemma_73162 (h0 : ring (has_zero (ring pos))) : is_domain (has_zero (ring pos)) := sorry --non-trivial
lemma new_lemma_73163 (h0 : functor.add_const (ring (comm_group linarith.comp)) linarith.comp) : @is_principal_ideal_ring.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (comm_group.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_73164 (h0 : ring (has_append (has_nnnorm (has_nnnorm fun_info)))) : rank_condition (has_append (has_nnnorm (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_73165 (h0 : complete_lattice (has_emptyc (has_top linarith.comp_source))) : is_compactly_generated (has_emptyc (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_73166 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (normed_comm_ring.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_73167 (h1 : topological_space (measurable_space (linear_ordered_semiring unsigned))) : preirreducible_space (measurable_space (linear_ordered_semiring unsigned)) := sorry --non-trivial
lemma new_lemma_73168 (h1 : set (has_div string.iterator_imp)) : set.finite h1 := sorry --non-trivial
lemma new_lemma_73169 (h2 : topological_space (add_monoid linarith.comp_source)) : path_connected_space (add_monoid linarith.comp_source) := sorry --non-trivial
lemma new_lemma_73170 (h0 : function.extfun (Type 1) topological_space) : @path_connected_space.{1} (ordered_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (ordered_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_73171 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @is_noetherian_ring.{0} (add_right_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) semiring.{0}) (add_right_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_73172 (h0 : not (topological_space (random_gen linarith.comp) -> false)) : @totally_disconnected_space.{0} (random_gen.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (random_gen.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_73173 (h0 : functor.add_const Prop (generalized_boolean_algebra (ring (ring linarith.comp)))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_73174 (h0 : topological_space (preorder (semiring (semiring (semiring num))))) : t0_space (preorder (semiring (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_73175 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (has_pos_part.{0} real) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_pos_part.{0} real))  := sorry --non-trivial
lemma new_lemma_73176 (h0 : cancel_comm_monoid_with_zero (canonically_ordered_monoid (has_Inf name))) : unique_factorization_monoid (canonically_ordered_monoid (has_Inf name)) := sorry --non-trivial
lemma new_lemma_73177 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_73178 (h0 : not (group (has_union empty) -> false)) : @normalizer_condition.{0} (has_union.{0} empty) (@classical.by_contradiction'.{1} (group.{0} (has_union.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_73179 (h0 : functor.add_const (topological_space Type) Type) : @normal_space.{1} Type (@functor.add_const.run.{1 1} (topological_space.{1} Type) Type h0)  := sorry --non-trivial
lemma new_lemma_73180 (h0 : functor.add_const (complete_lattice (semigroup Type)) (has_neg_part name)) : @is_compactly_generated.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (semigroup.{1} Type)) (has_neg_part.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_73181 (h0 : not (function.extfun Type cancel_comm_monoid_with_zero -> false)) : @unique_factorization_monoid.{0} (semiring.{0} unsigned) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type cancel_comm_monoid_with_zero.{0}) h0) (semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_73182 (h0 : function.extfun Type ring) : @rank_condition.{0} (encodable.{0} linarith.ineq) (@function.extfun_app.{2 1} Type ring.{0} h0 (encodable.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_73183 (h0 : topological_space (has_nnnorm (mul_one_class fun_info))) (h1 : preorder (has_nnnorm (mul_one_class fun_info))) : order_topology (has_nnnorm (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_73184 (h0 : monoid (normed_comm_ring congr_arg_kind)) : monoid.fg (normed_comm_ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_73185 (h0 : ordered_add_comm_monoid (has_Inf (ordered_comm_monoid (has_neg (has_neg (has_neg pos)))))) : archimedean (has_Inf (ordered_comm_monoid (has_neg (has_neg (has_neg pos))))) := sorry --non-trivial
lemma new_lemma_73186 (h0 : functor.add_const (monoid Type) linarith.comp) : @monoid.fg.{1} Type (@functor.add_const.run.{1 0} (monoid.{1} Type) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_73187 (h0 : ring (comm_ring (has_nnnorm linarith.comp_source))) : is_domain (comm_ring (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_73188 (h0 : complete_lattice (has_norm (random_gen (random_gen string_imp)))) : complete_lattice.is_Sup_finite_compact (has_norm (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_73189 (h0 : topological_space (has_neg linarith.comp)) : locally_compact_space (has_neg linarith.comp) := sorry --non-trivial
lemma new_lemma_73190 (h0 : uniform_space (normed_lattice_add_comm_group (has_add (has_add pos)))) : complete_space (normed_lattice_add_comm_group (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_73191 (h0 : topological_space (has_neg linarith.comp)) : path_connected_space (has_neg linarith.comp) := sorry --non-trivial
lemma new_lemma_73192 (h0 : has_neg (has_div (has_nnnorm (has_div (mul_one_class enat))))) (h1 : measurable_space (has_div (has_nnnorm (has_div (mul_one_class enat))))) : has_measurable_neg (has_div (has_nnnorm (has_div (mul_one_class enat)))) := sorry --non-trivial
lemma new_lemma_73193 (h0 : function.extfun (finset Type) (has_mem.mem to_additive.value_type)) : @group.fg.{0} to_additive.value_type (@finset.pi.empty.{1 0} Type group.{0} to_additive.value_type (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) to_additive.value_type) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_73194 (h0 : topological_space (has_edist (option (semiring (semiring empty))))) : totally_disconnected_space (has_edist (option (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_73195 (h0 : cancel_comm_monoid_with_zero (has_add unsigned)) : unique_factorization_monoid (has_add unsigned) := sorry --non-trivial
lemma new_lemma_73196 (h0 : function.extfun Type group) : @normalizer_condition.{0} (linear_ordered_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (linear_ordered_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_73197 (h0 : complete_lattice (add_group (semiring congr_arg_kind))) : complete_lattice.is_Sup_finite_compact (add_group (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_73198 (h0 : functor.add_const (topological_space (pseudo_metric_space empty)) unsigned) : @preconnected_space.{0} (pseudo_metric_space.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (pseudo_metric_space.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_73199 (h0 : filter (has_top empty)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_73200 (h0 : monoid (comm_group (has_neg linarith.comp))) : monoid.fg (comm_group (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_73201 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (cancel_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_73202 (h0 : complete_lattice (with_bot congr_arg_kind)) : is_compactly_generated (with_bot congr_arg_kind) := sorry --non-trivial
lemma new_lemma_73203 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (simple_graph unsigned)) := sorry --non-trivial
lemma new_lemma_73204 (h0 : ring (metric_space (has_norm linarith.comp))) : is_domain (metric_space (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_73205 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (ordered_comm_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_73206 (h1 : group (fintype (random_gen string_imp))) : is_cyclic (fintype (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_73207 (h0 : topological_space (generalized_boolean_algebra (has_Inf (has_Inf name)))) : regular_space (generalized_boolean_algebra (has_Inf (has_Inf name))) := sorry --non-trivial
lemma new_lemma_73208 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (complete_distrib_lattice.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_73209 (h0 : topological_space (add_group (has_norm congr_arg_kind))) : t0_space (add_group (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_73210 (h0 : topological_space (uniform_space linarith.comp_source)) : totally_disconnected_space (uniform_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_73211 (h0 : function.extfun Type topological_space) : @regular_space.{0} (has_norm.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_norm.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_73212 (h0 : topological_space (has_append (mul_one_class linarith.ineq))) : t0_space (has_append (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_73213 (h1 : complete_lattice (normed_group (has_nnnorm string_imp))) : is_compactly_generated (normed_group (has_nnnorm string_imp)) := sorry --non-trivial
lemma new_lemma_73214 (h0 : functor.add_const (topological_space (has_neg_part environment.implicit_infer_kind)) Type) : @normal_space.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg_part.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_73215 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_neg_part environment.implicit_infer_kind)) unsigned) : @unique_factorization_monoid.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_neg_part.{0} environment.implicit_infer_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_73216 (h0 : uniform_space (has_one (semiring empty))) : complete_space (has_one (semiring empty)) := sorry --non-trivial
lemma new_lemma_73217 (h0 : group (linear_ordered_add_comm_group (has_inv fun_info))) : is_cyclic (linear_ordered_add_comm_group (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_73218 (h0 : function.extfun Type (functor.add_const (functor.comp uniform_space semigroup ennreal))) : @separated_space.{0} (semigroup.{0} ennreal) (@functor.comp.run.{0 0 0} uniform_space.{0} semigroup.{0} ennreal (@functor.add_const.run.{0 0} (functor.comp.{0 0 0} uniform_space.{0} semigroup.{0} ennreal) environment.implicit_infer_kind (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (functor.comp.{0 0 0} uniform_space.{0} semigroup.{0} ennreal)) h0 environment.implicit_infer_kind)))  := sorry --non-trivial
lemma new_lemma_73219 (h0 : semiring (sub_neg_monoid (has_neg (ordered_comm_monoid real)))) : is_noetherian_ring (sub_neg_monoid (has_neg (ordered_comm_monoid real))) := sorry --non-trivial
lemma new_lemma_73220 (h0 : group (boolean_algebra (ring (has_neg linarith.comp)))) : group.fg (boolean_algebra (ring (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_73221 (h0 : list (has_nndist (has_to_string name))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_73222 (h0 : functor.add_const (topological_space (comm_group name)) Type) : @loc_path_connected_space.{0} (comm_group.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (comm_group.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_73223 (h0 : ring (distrib_lattice (random_gen (random_gen (random_gen fun_info))))) : is_domain (distrib_lattice (random_gen (random_gen (random_gen fun_info)))) := sorry --non-trivial
lemma new_lemma_73224 (h0 : topological_space (denumerable (random_gen fun_info))) : irreducible_space (denumerable (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_73225 (h0 : ring (has_nnnorm reducibility_hints)) : strong_rank_condition (has_nnnorm reducibility_hints) := sorry --non-trivial
lemma new_lemma_73226 (h0 : functor.add_const (group auto.case_option) (option (option (option num)))) : @is_cyclic.{0} auto.case_option (@functor.add_const.run.{0 0} (group.{0} auto.case_option) (option.{0} (option.{0} (option.{0} num))) h0)  := sorry --non-trivial
lemma new_lemma_73227 (h0 : finset (has_dist (comm_monoid (comm_monoid unsigned)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_73228 (h0 : semiring (has_pos_part (has_bot Type))) : is_noetherian_ring (has_pos_part (has_bot Type)) := sorry --non-trivial
lemma new_lemma_73229 (h0 : monoid (group_with_zero congr_arg_kind)) : monoid.fg (group_with_zero congr_arg_kind) := sorry --non-trivial
lemma new_lemma_73230 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (simple_graph.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (simple_graph.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_73231 (h0 : add_group (linear_ordered_semiring (semiring num))) : is_add_cyclic (linear_ordered_semiring (semiring num)) := sorry --non-trivial
lemma new_lemma_73232 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (finset congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_73233 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (has_neg.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_neg.{0} name))  := sorry --non-trivial
lemma new_lemma_73234 (h0 : functor.add_const (topological_space (semigroup unsigned)) Type) : @loc_path_connected_space.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (semigroup.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_73235 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (normed_comm_ring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_73236 (h0 : ring (semi_normed_ring (has_nnnorm to_additive.value_type))) : strong_rank_condition (semi_normed_ring (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_73237 (h0 : list (left_cancel_semigroup unsigned)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_73238 (h0 : uniform_space (random_gen linarith.ineq)) : complete_space (random_gen linarith.ineq) := sorry --non-trivial
lemma new_lemma_73239 (h0 : has_to_string (has_neg (option ennreal)) -> has_to_string (has_neg (option ennreal)) -> Prop) : is_symm (has_to_string (has_neg (option ennreal))) h0 := sorry --non-trivial
lemma new_lemma_73240 (h0 : not (topological_space (complete_semilattice_Sup (semiring congr_arg_kind)) -> false)) : @irreducible_space.{0} (complete_semilattice_Sup.{0} (semiring.{0} congr_arg_kind)) (@classical.by_contradiction'.{1} (topological_space.{0} (complete_semilattice_Sup.{0} (semiring.{0} congr_arg_kind))) h0)  := sorry --non-trivial
lemma new_lemma_73241 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (add_comm_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_73242 (h0 : has_mem.mem (has_top linarith.comp) has_emptyc.emptyc) : @is_add_cyclic.{0} (has_top.{0} linarith.comp) (@finset.pi.empty.{1 0} Type add_group.{0} (has_top.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_73243 (h0 : ring (non_assoc_semiring (semiring (semiring (semiring empty))))) : is_domain (non_assoc_semiring (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_73244 (h0 : functor.add_const (topological_space (comm_group unsigned)) ennreal) : @topological_space.separable_space.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} unsigned)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_73245 (h0 : list (semigroup (has_neg environment.implicit_infer_kind))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_73246 (h0 : functor.add_const (monoid (boolean_algebra name)) Type) : @monoid.fg.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 1} (monoid.{0} (boolean_algebra.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_73247 (h0 : topological_space (has_nnnorm environment.projection_info)) : path_connected_space (has_nnnorm environment.projection_info) := sorry --non-trivial
lemma new_lemma_73248 (h0 : ring (add_cancel_monoid (semigroup unsigned))) : rank_condition (add_cancel_monoid (semigroup unsigned)) := sorry --non-trivial
lemma new_lemma_73249 (h0 : function.extfun Type topological_space) : @t1_space.{0} (has_star.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_star.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_73250 (h0 : ring (has_Sup (option (option empty)))) : strong_rank_condition (has_Sup (option (option empty))) := sorry --non-trivial
lemma new_lemma_73251 (h0 : topological_space (has_one (semiring (semiring empty)))) : path_connected_space (has_one (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_73252 (h0 : topological_space (has_Inf (has_to_string pos))) : path_connected_space (has_Inf (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_73253 (h0 : uniform_space (with_bot string_imp)) : complete_space (with_bot string_imp) := sorry --non-trivial
lemma new_lemma_73254 (h0 : topological_space (has_norm char)) : t0_space (has_norm char) := sorry --non-trivial
lemma new_lemma_73255 (h0 : monoid (has_nndist (boolean_algebra name))) : monoid.fg (has_nndist (boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_73256 (h0 : topological_space (has_norm (semiring empty))) : t0_space (has_norm (semiring empty)) := sorry --non-trivial
lemma new_lemma_73257 (h0 : ring (id (ordered_semiring empty))) : rank_condition (id (ordered_semiring empty)) := sorry --non-trivial
lemma new_lemma_73258 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @topological_space.separable_space.{0} (has_to_string.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (has_to_string.{0} name))  := sorry --non-trivial
lemma new_lemma_73259 (h0 : topological_space (add_cancel_monoid Type)) : t0_space (add_cancel_monoid Type) := sorry --non-trivial
lemma new_lemma_73260 (h0 : not (topological_space (topological_space fun_info) -> false)) : @path_connected_space.{0} (topological_space.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (topological_space.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_73261 (h0 : functor.add_const (topological_space (partial_order num)) num) : @discrete_topology.{0} (partial_order.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (partial_order.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_73262 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (add_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_73263 (h0 : functor.comp topological_space mul_zero_class ennreal) : @irreducible_space.{0} (mul_zero_class.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} mul_zero_class.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_73264 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (add_cancel_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_73265 (h0 : topological_space (complete_linear_order (semiring (semiring empty)))) : discrete_topology (complete_linear_order (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_73266 (h0 : functor.add_const (topological_space (cancel_monoid environment.implicit_infer_kind)) Type) : @preconnected_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_73267 (h2 : complete_lattice (id linarith.ineq)) : is_atomistic (id linarith.ineq) := sorry --non-trivial
lemma new_lemma_73268 (h0 : functor.add_const (add_cancel_monoid Type) (finset Type)) : list.nodup (list.ret (functor.add_const.run h0)) := sorry --non-trivial
lemma new_lemma_73269 (h0 : functor.add_const (topological_space (has_to_string ennreal)) Type) : @t0_space.{0} (has_to_string.{0} ennreal) (@functor.add_const.run.{0 1} (topological_space.{0} (has_to_string.{0} ennreal)) Type h0)  := sorry --non-trivial
lemma new_lemma_73270 (h0 : functor.add_const (topological_space (ordered_comm_ring linarith.comp)) (finset (finset pos))) : @preirreducible_space.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} linarith.comp)) (finset.{0} (finset.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_73271 (h0 : group (has_norm (random_gen char))) : group.fg (has_norm (random_gen char)) := sorry --non-trivial
lemma new_lemma_73272 (h0 : not (group (complete_semilattice_Sup linarith.ineq) -> false)) : @normalizer_condition.{0} (complete_semilattice_Sup.{0} linarith.ineq) (@classical.by_contradiction'.{1} (group.{0} (complete_semilattice_Sup.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_73273 (h0 : not (function.extfun Type topological_space -> false)) : @discrete_topology.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (linear_ordered_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_73274 (h0 : semiring (is_R_or_C (semiring (semiring unsigned)))) : is_noetherian_ring (is_R_or_C (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_73275 (h0 : functor.add_const (function.extfun Type semiring) (has_neg (mul_one_class environment.implicit_infer_kind))) : @is_noetherian_ring.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type semiring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type semiring.{0}) (has_neg.{0} (mul_one_class.{0} environment.implicit_infer_kind)) h0) (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_73276 (h0 : group (finset (has_Inf linarith.comp))) : normalizer_condition (finset (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_73277 (h0 : ring (complete_linear_order (semiring empty))) : is_domain (complete_linear_order (semiring empty)) := sorry --non-trivial
lemma new_lemma_73278 (h0 : cancel_comm_monoid_with_zero (bin_tree (semiring (has_norm empty)))) : unique_factorization_monoid (bin_tree (semiring (has_norm empty))) := sorry --non-trivial
lemma new_lemma_73279 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (mul_zero_class.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (mul_zero_class.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_73280 (h0 : topological_space (ordered_comm_monoid (ring (ring (ring Type))))) : regular_space (ordered_comm_monoid (ring (ring (ring Type)))) := sorry --non-trivial
lemma new_lemma_73281 (h0 : functor.add_const (topological_space (add_cancel_monoid linarith.comp)) pos) : @totally_disconnected_space.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_73282 (h2 : preorder (mul_one_class (mul_one_class ereal))) (h3 : set (mul_one_class (mul_one_class ereal))) : set.is_pwo h3 := sorry --non-trivial
lemma new_lemma_73283 (h0 : topological_space (has_nndist (has_to_string name))) : t0_space (has_nndist (has_to_string name)) := sorry --non-trivial
lemma new_lemma_73284 (h0 : add_group (complete_distrib_lattice (has_Inf (has_add pos)))) : is_add_cyclic (complete_distrib_lattice (has_Inf (has_add pos))) := sorry --non-trivial
lemma new_lemma_73285 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (random_gen.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (random_gen.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_73286 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (left_cancel_monoid empty)) := sorry --non-trivial
lemma new_lemma_73287 (h0 : not (uniform_space (has_nnnorm to_additive.value_type) -> false)) : @complete_space.{0} (has_nnnorm.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_nnnorm.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_73288 (h0 : functor.add_const (topological_space (has_add Type)) name) : @topological_space.separable_space.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_add.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_73289 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (@id.{2} Type unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (@id.{2} Type unsigned))  := sorry --non-trivial
lemma new_lemma_73290 (h0 : monoid (metric_space (semiring (has_norm linarith.comp)))) : monoid.fg (metric_space (semiring (has_norm linarith.comp))) := sorry --non-trivial
lemma new_lemma_73291 (h0 : function.extfun (finset Type) (has_mem.mem (measurable_space linarith.comp_source))) : is_atomistic (measurable_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_73292 (h0 : fin has_zero.zero) : @is_domain.{0} (normed_lattice_add_comm_group.{0} real) (@matrix.vec_empty.{0} (ring.{0} (normed_lattice_add_comm_group.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_73293 (h0 : filter (boolean_algebra unsigned)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_73294 (h0 : functor.add_const (topological_space (normed_linear_ordered_group unsigned)) num) : @irreducible_space.{0} (normed_linear_ordered_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_linear_ordered_group.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_73295 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (finset.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} num))  := sorry --non-trivial
lemma new_lemma_73296 (h0 : topological_space (left_cancel_semigroup (semiring (semiring congr_arg_kind)))) : t1_space (left_cancel_semigroup (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_73297 (h0 : complete_lattice (has_edist (semiring num))) : is_atomistic (has_edist (semiring num)) := sorry --non-trivial
lemma new_lemma_73298 (h0 : functor.add_const (measurable_space (has_to_string environment.implicit_infer_kind)) pos) (h1 : has_mul (has_to_string environment.implicit_infer_kind)) : @has_measurable_mul₂.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (measurable_space.{0} (has_to_string.{0} environment.implicit_infer_kind)) pos h0) h1  := sorry --non-trivial
lemma new_lemma_73299 (h0 : function.extfun Type topological_space) (h1 : Prop) : implies (@discrete_topology.{0} (left_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (left_cancel_monoid.{0} unsigned))) h1  := sorry --non-trivial
lemma new_lemma_73300 (h0 : has_mem.mem (has_sub empty) has_zero.zero) : @irreducible_space.{0} (has_sub.{0} empty) (@multiset.pi.empty.{1 0} Type topological_space.{0} (has_sub.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_73301 (h0 : list (dlist (random_gen (random_gen (random_gen (denumerable (random_gen linarith.comp_source))))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_73302 (h0 : functor.add_const (topological_space (semigroup linarith.comp)) name) : @preconnected_space.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_73303 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (canonically_linear_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_linear_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_73304 (h1 : topological_space (encodable linarith.ineq)) : locally_compact_space (encodable linarith.ineq) := sorry --non-trivial
lemma new_lemma_73305 (h0 : topological_space (left_cancel_monoid (semiring (semiring (semiring (semiring (semiring empty))))))) : discrete_topology (left_cancel_monoid (semiring (semiring (semiring (semiring (semiring empty)))))) := sorry --non-trivial
lemma new_lemma_73306 (h0 : complete_lattice (random_gen (denumerable char))) : is_compactly_generated (random_gen (denumerable char)) := sorry --non-trivial
lemma new_lemma_73307 (h0 : not (uniform_space (normed_group congr_arg_kind) -> false)) : @complete_space.{0} (normed_group.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (uniform_space.{0} (normed_group.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_73308 (h0 : functor.add_const (group (linear_ordered_comm_monoid_with_zero num)) unsigned) : @normalizer_condition.{0} (linear_ordered_comm_monoid_with_zero.{0} num) (@functor.add_const.run.{0 0} (group.{0} (linear_ordered_comm_monoid_with_zero.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_73309 (h0 : functor.add_const (function.extfun Type group) (option Type)) : @group.fg.{0} (comm_group.{0} real) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type group.{0}) (option.{1} Type) h0) (comm_group.{0} real))  := sorry --non-trivial
lemma new_lemma_73310 (h0 : has_lt (has_le (mul_one_class (mul_one_class (mul_one_class linarith.comp_source))))) : no_max_order (has_le (mul_one_class (mul_one_class (mul_one_class linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_73311 (h0 : topological_space (add_comm_semigroup (add_comm_semigroup fun_info))) : topological_space.first_countable_topology (add_comm_semigroup (add_comm_semigroup fun_info)) := sorry --non-trivial
lemma new_lemma_73312 (h0 : topological_space (comm_group (has_add (finset pos)))) : t1_space (comm_group (has_add (finset pos))) := sorry --non-trivial
lemma new_lemma_73313 (h0 : cancel_comm_monoid_with_zero (has_to_string (add_comm_monoid pos))) : unique_factorization_monoid (has_to_string (add_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_73314 (h0 : functor.add_const (topological_space (ordered_comm_monoid linarith.comp)) pos) : @t0_space.{0} (ordered_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_monoid.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_73315 (h0 : topological_space (has_ssubset (random_gen char))) : totally_disconnected_space (has_ssubset (random_gen char)) := sorry --non-trivial
lemma new_lemma_73316 (h0 : list (linear_ordered_comm_group (option pos))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_73317 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (boolean_algebra.core.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (boolean_algebra.core.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_73318 (h0 : reducibility_hints -> reducibility_hints -> reducibility_hints) : is_associative reducibility_hints h0 := sorry --non-trivial
lemma new_lemma_73319 (h0 : complete_lattice (has_neg (has_neg (has_neg (has_neg Type))))) : is_compactly_generated (has_neg (has_neg (has_neg (has_neg Type)))) := sorry --non-trivial
lemma new_lemma_73320 (h0 : add_group (has_zero (option pos))) : is_add_cyclic (has_zero (option pos)) := sorry --non-trivial
lemma new_lemma_73321 (h0 : functor.add_const (complete_lattice (boolean_algebra Type)) (has_add pos)) : @is_atomistic.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (boolean_algebra.{1} Type)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_73322 (h0 : add_monoid (semigroup (finset name))) : add_monoid.fg (semigroup (finset name)) := sorry --non-trivial
lemma new_lemma_73323 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_neg.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_neg.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_73324 (h1 : uniform_space (normed_field (mul_one_class to_additive.value_type))) : complete_space (normed_field (mul_one_class to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_73325 (h1 : group (with_one string_imp)) : normalizer_condition (with_one string_imp) := sorry --non-trivial
lemma new_lemma_73326 (h0 : functor.add_const (topological_space (mul_zero_class name)) pos) : @topological_space.separable_space.{0} (mul_zero_class.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_73327 (h1 : uniform_space (id congr_arg_kind)) : separated_space (id congr_arg_kind) := sorry --non-trivial
lemma new_lemma_73328 (h0 : group (semigroup (ring (ring (ring linarith.comp))))) : group.fg (semigroup (ring (ring (ring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_73329 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (linear_ordered_comm_monoid_with_zero.{0} empty) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (linear_ordered_comm_monoid_with_zero.{0} empty))  := sorry --non-trivial
lemma new_lemma_73330 (h0 : add_group (measure_theory.measure_space num)) : is_add_cyclic (measure_theory.measure_space num) := sorry --non-trivial
lemma new_lemma_73331 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} congr_arg_kind (@function.extfun_app.{2 1} Type topological_space.{0} h0 congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_73332 (h0 : functor.add_const (topological_space (cancel_monoid linarith.comp)) name) : @t0_space.{0} (cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_73333 (h0 : congr_arg_kind -> Prop) (h1 : Prop) (h2 : preorder Prop) (h3 : Prop) : set.Ioc h3 (exists_unique h0) h1 := sorry --non-trivial
lemma new_lemma_73334 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} linarith.ineq (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) linarith.ineq)  := sorry --non-trivial
lemma new_lemma_73335 (h0 : functor.add_const (complete_lattice (cancel_monoid name)) (has_add pos)) : @complete_lattice.is_Sup_finite_compact.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (cancel_monoid.{0} name)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_73336 (h0 : topological_space (has_pos_part (has_pos_part (sub_neg_monoid Type)))) : t1_space (has_pos_part (has_pos_part (sub_neg_monoid Type))) := sorry --non-trivial
lemma new_lemma_73337 (h0 : has_mem.mem Prop has_emptyc.emptyc) : @Lim.{0} Prop sierpinski_space (@nonempty_of_inhabited.{1} Prop sort.inhabited.{0}) (@finset.pi.empty.{1 0} Type filter.{0} Prop (@id.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) Prop (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_73338 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring name)) (has_add pos)) : @normal_space.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} name)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_73339 (h0 : functor.add_const (group (has_neg pos)) name) : @normalizer_condition.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_neg.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_73340 (h0 : list (ordered_cancel_add_comm_monoid empty)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_73341 (h0 : with_bot (functor.add_const (topological_space (has_star congr_arg_kind)) congr_arg_kind)) (h1 : function.extfun (eq h0 has_bot.bot) (fun (x : eq h0 has_bot.bot), false)) : @totally_disconnected_space.{0} (has_star.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} congr_arg_kind)) congr_arg_kind (@with_bot.unbot.{0} (functor.add_const.{0 0} (topological_space.{0} (has_star.{0} congr_arg_kind)) congr_arg_kind) h0 (@function.extfun_app.{0 0} (@eq.{1} (with_bot.{0} (functor.add_const.{0 0} (topological_space.{0} (has_star.{0} congr_arg_kind)) congr_arg_kind)) h0 (@has_bot.bot.{0} (with_bot.{0} (functor.add_const.{0 0} (topological_space.{0} (has_star.{0} congr_arg_kind)) congr_arg_kind)) (@with_bot.has_bot.{0} (functor.add_const.{0 0} (topological_space.{0} (has_star.{0} congr_arg_kind)) congr_arg_kind)))) (λ (x : @eq.{1} (with_bot.{0} (functor.add_const.{0 0} (topological_space.{0} (has_star.{0} congr_arg_kind)) congr_arg_kind)) h0 (@has_bot.bot.{0} (with_bot.{0} (functor.add_const.{0 0} (topological_space.{0} (has_star.{0} congr_arg_kind)) congr_arg_kind)) (@with_bot.has_bot.{0} (functor.add_const.{0 0} (topological_space.{0} (has_star.{0} congr_arg_kind)) congr_arg_kind)))), false) h1)))  := sorry --non-trivial
lemma new_lemma_73342 (h0 : topological_space (preorder empty)) : preirreducible_space (preorder empty) := sorry --non-trivial
lemma new_lemma_73343 (h0 : ring (semiring (semiring (semiring linarith.comp)))) : strong_rank_condition (semiring (semiring (semiring linarith.comp))) := sorry --non-trivial
lemma new_lemma_73344 (h0 : not (topological_space (uniform_space to_additive.value_type) -> false)) : @t0_space.{0} (uniform_space.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (uniform_space.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_73345 (h0 : set (linarith.ineq -> linarith.ineq)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_73346 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (comm_group.{0} pos) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_73347 (h0 : topological_space (comm_ring string_imp)) : locally_compact_space (comm_ring string_imp) := sorry --non-trivial
lemma new_lemma_73348 (h0 : functor.comp topological_space semigroup environment.implicit_infer_kind) : @path_connected_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_73349 (h0 : topological_space (semigroup (has_neg linarith.comp))) : t0_space (semigroup (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_73350 (h0 : functor.add_const (topological_space (canonically_linear_ordered_monoid unsigned)) pos) : @regular_space.{0} (canonically_linear_ordered_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_linear_ordered_monoid.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_73351 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (with_one.{0} (has_norm.{0} linarith.comp)) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (with_one.{0} (has_norm.{0} linarith.comp)))  := sorry --non-trivial
lemma new_lemma_73352 (h1 : list (id linarith.ineq)) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_73353 (h1 : not (topological_space (measurable_space linarith.comp_source) -> false)) : @t0_space.{0} (measurable_space.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (measurable_space.{0} linarith.comp_source)) h1)  := sorry --non-trivial
lemma new_lemma_73354 (h0 : topological_space (monoid_with_zero ennreal)) : totally_separated_space (monoid_with_zero ennreal) := sorry --non-trivial
lemma new_lemma_73355 (h0 : ordered_add_comm_monoid (id empty)) : archimedean (id empty) := sorry --non-trivial
lemma new_lemma_73356 (h0 : function.extfun Type topological_space) : @t0_space.{0} (measure_theory.measure_space.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measure_theory.measure_space.{0} num))  := sorry --non-trivial
lemma new_lemma_73357 (h0 : add_group (canonically_ordered_monoid (has_add pos))) : is_add_cyclic (canonically_ordered_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_73358 (h1 : measurable_space (nondiscrete_normed_field (normed_field string.iterator_imp))) (h2 : measure_theory.measure (nondiscrete_normed_field (normed_field string.iterator_imp))) : measure_theory.is_finite_measure h2 := sorry --non-trivial
lemma new_lemma_73359 (h0 : functor.add_const (ring (has_to_string pos)) (has_add (ring linarith.comp))) : @is_principal_ideal_ring.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_to_string.{0} pos)) (has_add.{0} (ring.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_73360 (h0 : functor.add_const (ring (preorder empty)) empty) : @is_domain.{0} (preorder.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (preorder.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_73361 (h0 : finset (add_comm_monoid (has_neg (finset (has_neg (has_neg environment.implicit_infer_kind)))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_73362 (h0 : functor.add_const (topological_space (has_pos_part pos)) (has_Inf Type)) : @t1_space.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_pos_part.{0} pos)) (has_Inf.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_73363 (h0 : fin has_zero.zero) : @is_compactly_generated.{0} (has_pos_part.{0} linarith.comp) (@matrix.vec_empty.{0} (complete_lattice.{0} (has_pos_part.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_73364 (h0 : topological_space (topological_space (has_add linarith.ineq))) : path_connected_space (topological_space (has_add linarith.ineq)) := sorry --non-trivial
lemma new_lemma_73365 (h0 : complete_lattice (has_zero (mul_zero_class (option pos)))) : is_atomistic (has_zero (mul_zero_class (option pos))) := sorry --non-trivial
lemma new_lemma_73366 (h0 : cancel_comm_monoid_with_zero (has_inter (comm_monoid (comm_monoid (has_nndist unsigned))))) : unique_factorization_monoid (has_inter (comm_monoid (comm_monoid (has_nndist unsigned)))) := sorry --non-trivial
lemma new_lemma_73367 (h0 : topological_space (normed_group (has_ssubset (has_ssubset (random_gen to_additive.value_type))))) : irreducible_space (normed_group (has_ssubset (has_ssubset (random_gen to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_73368 (h0 : comm_ring num) : local_ring num := sorry --non-trivial
lemma new_lemma_73369 (h0 : functor.add_const (function.extfun (Type 1) finset) pos) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (comm_group Type)) := sorry --non-trivial
lemma new_lemma_73370 (h0 : complete_lattice (canonically_linear_ordered_monoid (sub_neg_monoid (has_Inf real)))) : is_atomistic (canonically_linear_ordered_monoid (sub_neg_monoid (has_Inf real))) := sorry --non-trivial
lemma new_lemma_73371 (h0 : not (has_mem.mem (linear_ordered_semiring linarith.comp_source) has_emptyc.emptyc -> false)) : @irreducible_space.{0} (linear_ordered_semiring.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (linear_ordered_semiring.{0} linarith.comp_source) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (linear_ordered_semiring.{0} linarith.comp_source) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_73372 (h0 : topological_space (has_pos_part (ring name))) : irreducible_space (has_pos_part (ring name)) := sorry --non-trivial
lemma new_lemma_73373 (h0 : topological_space (measurable_space.dynkin_system (semiring (semiring (semiring empty))))) : totally_separated_space (measurable_space.dynkin_system (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_73374 (h0 : topological_space (add_cancel_monoid (finset environment.implicit_infer_kind))) : totally_separated_space (add_cancel_monoid (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_73375 (h0 : list (add_comm_monoid pos)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_73376 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (linear_ordered_field.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_field.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_73377 (h0 : complete_lattice (ordered_comm_monoid (has_Inf Type))) : complete_lattice.is_Sup_finite_compact (ordered_comm_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_73378 (h0 : group (topological_space (has_nnnorm linarith.ineq))) : is_cyclic (topological_space (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_73379 (h1 : function.extfun Type topological_space) : @irreducible_space.{0} (comm_ring.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (comm_ring.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_73380 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (monoid.{0} ennreal) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_73381 (h0 : topological_space (has_top to_additive.value_type)) : path_connected_space (has_top to_additive.value_type) := sorry --non-trivial
lemma new_lemma_73382 (h0 : topological_space (has_add (has_pos_part Type))) : sequential_space (has_add (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_73383 (h0 : functor.add_const (ring (simple_graph linarith.comp)) linarith.comp) : @is_domain.{0} (simple_graph.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (simple_graph.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_73384 (h0 : topological_space (left_cancel_monoid empty)) : irreducible_space (left_cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_73385 (h0 : functor.add_const (ring (has_add pos)) unsigned) : @rank_condition.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_add.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_73386 (h0 : list (has_nndist (complete_distrib_lattice (option pos)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_73387 (h0 : filter (distrib_lattice (random_gen (has_nnnorm fun_info)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_73388 (h0 : topological_space (ordered_comm_ring (has_Inf linarith.comp))) : path_connected_space (ordered_comm_ring (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_73389 (h0 : functor.add_const (topological_space (has_add pos)) Type) : @preconnected_space.{0} (has_add.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_add.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_73390 (h0 : topological_space (ordered_cancel_add_comm_monoid (option empty))) : path_connected_space (ordered_cancel_add_comm_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_73391 (h0 : has_zero (has_add (option ennreal)) -> has_zero (has_add (option ennreal)) -> Prop) : reflexive h0 := sorry --non-trivial
lemma new_lemma_73392 (h0 : functor.add_const (complete_lattice (finset Type)) (mul_one_class environment.implicit_infer_kind)) : @is_compactly_generated.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (finset.{1} Type)) (mul_one_class.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_73393 (h0 : group (has_nndist (has_Inf Type))) : normalizer_condition (has_nndist (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_73394 (h0 : add_monoid (sub_neg_monoid real)) : add_monoid.fg (sub_neg_monoid real) := sorry --non-trivial
lemma new_lemma_73395 (h0 : topological_space (add_cancel_comm_monoid empty)) : path_connected_space (add_cancel_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_73396 (h0 : uniform_space (add_cancel_monoid pos)) : separated_space (add_cancel_monoid pos) := sorry --non-trivial
lemma new_lemma_73397 (h0 : fin has_zero.zero) : @path_connected_space.{0} (ordered_comm_monoid.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_monoid.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_73398 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (measurable_space.dynkin_system.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (measurable_space.dynkin_system.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_73399 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (canonically_linear_ordered_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_linear_ordered_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_73400 (h0 : topological_space (ordered_comm_monoid (has_neg name))) : path_connected_space (ordered_comm_monoid (has_neg name)) := sorry --non-trivial
lemma new_lemma_73401 (h0 : function.extfun Type group) : @is_cyclic.{0} (bin_tree.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (bin_tree.{0} num))  := sorry --non-trivial
lemma new_lemma_73402 (h0 : functor.add_const (ordered_comm_monoid (simple_graph pos)) (boolean_algebra.core Type)) : @has_exists_mul_of_le.{0} (simple_graph.{0} pos) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (simple_graph.{0} pos)) (boolean_algebra.core.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_73403 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @t0_space.{0} (has_emptyc.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (has_emptyc.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_73404 (h0 : topological_space (add_cancel_monoid (option (option name)))) : path_connected_space (add_cancel_monoid (option (option name))) := sorry --non-trivial
lemma new_lemma_73405 (h0 : complete_lattice (has_zero (has_neg_part Type))) : is_compactly_generated (has_zero (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_73406 (h0 : topological_space (has_add unsigned)) : preconnected_space (has_add unsigned) := sorry --non-trivial
lemma new_lemma_73407 (h0 : topological_space (is_R_or_C empty)) : irreducible_space (is_R_or_C empty) := sorry --non-trivial
lemma new_lemma_73408 (h0 : functor.add_const (function.extfun (Type 1) topological_space) name) : @discrete_topology.{1} (canonically_ordered_comm_semiring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) name h0) (canonically_ordered_comm_semiring.{1} Type))  := sorry --non-trivial
lemma new_lemma_73409 (h0 : topological_space (simple_graph linarith.comp)) : t0_space (simple_graph linarith.comp) := sorry --non-trivial
lemma new_lemma_73410 (h0 : ring (has_to_string (has_add Type))) : is_domain (has_to_string (has_add Type)) := sorry --non-trivial
lemma new_lemma_73411 (h0 : functor.add_const (complete_lattice (has_nndist num)) (option (option empty))) : @is_atomistic.{0} (has_nndist.{0} num) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_nndist.{0} num)) (option.{0} (option.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_73412 (h1 : complete_lattice (has_inv (random_gen string_imp))) : is_atomistic (has_inv (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_73413 (h0 : semiring (with_one (has_norm num))) : is_noetherian_ring (with_one (has_norm num)) := sorry --non-trivial
lemma new_lemma_73414 (h0 : function.extfun Type (functor.add_const (uniform_space auto.case_option))) : @separated_space.{0} auto.case_option (@functor.add_const.run.{0 0} (uniform_space.{0} auto.case_option) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (uniform_space.{0} auto.case_option)) h0 empty))  := sorry --non-trivial
lemma new_lemma_73415 (h0 : function.extfun Type (prod (complete_distrib_lattice unsigned))) : id_rel (function.extfun_app h0 (complete_distrib_lattice unsigned)) := sorry --non-trivial
lemma new_lemma_73416 (h0 : function.extfun nat fin) : @complete_lattice.is_Sup_finite_compact.{0} (has_bot.{0} name) (@matrix.vec_empty.{0} (complete_lattice.{0} (has_bot.{0} name)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_73417 (h0 : complete_lattice (has_to_string name)) : is_compactly_generated (has_to_string name) := sorry --non-trivial
lemma new_lemma_73418 (h1 : group (complete_distrib_lattice to_additive.value_type)) : is_cyclic (complete_distrib_lattice to_additive.value_type) := sorry --non-trivial
lemma new_lemma_73419 (h0 : function.extfun Type (functor.add_const (topological_space (plift empty)))) : @loc_path_connected_space.{1} (plift.{1} empty) (@functor.add_const.run.{1 0} (topological_space.{1} (plift.{1} empty)) (semiring.{0} empty) (@function.extfun_app.{2 2} Type (functor.add_const.{1 0} (topological_space.{1} (plift.{1} empty))) h0 (semiring.{0} empty)))  := sorry --non-trivial
lemma new_lemma_73420 (h0 : cancel_comm_monoid_with_zero (measurable_space.dynkin_system empty)) : unique_factorization_monoid (measurable_space.dynkin_system empty) := sorry --non-trivial
lemma new_lemma_73421 (h0 : function.extfun Type group) : @group.fg.{0} (denumerable.{0} char) (@function.extfun_app.{2 1} Type group.{0} h0 (denumerable.{0} char))  := sorry --non-trivial
lemma new_lemma_73422 (h0 : add_monoid (has_pos_part (has_Inf (sub_neg_monoid (has_Inf name))))) : add_monoid.fg (has_pos_part (has_Inf (sub_neg_monoid (has_Inf name)))) := sorry --non-trivial
lemma new_lemma_73423 (h0 : topological_space (linear_ordered_comm_group_with_zero string_imp)) : totally_disconnected_space (linear_ordered_comm_group_with_zero string_imp) := sorry --non-trivial
lemma new_lemma_73424 (h0 : topological_space (has_add (cancel_monoid unsigned))) : discrete_topology (has_add (cancel_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_73425 (h0 : functor.add_const (topological_space (ring Type)) (comm_group name)) : @normal_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ring.{1} Type)) (comm_group.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_73426 (h0 : functor.add_const (ordered_comm_monoid (has_to_string unsigned)) name) : @has_exists_mul_of_le.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_to_string.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_73427 (h0 : topological_space (add_cancel_monoid (has_pos_part Type))) : irreducible_space (add_cancel_monoid (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_73428 (h0 : function.extfun nat fin) : @is_add_cyclic.{1} (generalized_boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (add_group.{1} (generalized_boolean_algebra.{1} Type)) (@function.extfun_app.{1 1} nat fin (@matrix.vec_empty.{0} (function.extfun.{1 1} nat fin) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@function.extfun_app.{1 1} nat fin (@matrix.vec_empty.{0} (function.extfun.{1 1} nat fin) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))) (@has_zero.zero.{0} nat nat.has_zero)))) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_73429 (h0 : add_group (non_assoc_semiring (option unsigned))) : is_add_cyclic (non_assoc_semiring (option unsigned)) := sorry --non-trivial
lemma new_lemma_73430 (h0 : fin has_zero.zero) : @topological_space.separable_space.{0} (generalized_boolean_algebra.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (generalized_boolean_algebra.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_73431 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (has_inter.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_inter.{0} num))  := sorry --non-trivial
lemma new_lemma_73432 (h0 : functor.add_const (topological_space (has_pos_part pos)) pos) : @t1_space.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_73433 (h0 : function.extfun (Type 1) topological_space) : @discrete_topology.{1} (normed_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (normed_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_73434 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @locally_compact_space.{0} (with_bot.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (with_bot.{0} num))  := sorry --non-trivial
lemma new_lemma_73435 (h0 : topological_space (has_bot (has_Inf pos))) : topological_space.separable_space (has_bot (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_73436 (h1 : has_lt ordering) : no_max_order ordering := sorry --non-trivial
lemma new_lemma_73437 (h0 : topological_space (ordered_ring (semiring empty))) : totally_disconnected_space (ordered_ring (semiring empty)) := sorry --non-trivial
lemma new_lemma_73438 (h0 : functor.add_const (ring (generalized_boolean_algebra pos)) (ring linarith.comp)) : @rank_condition.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (generalized_boolean_algebra.{0} pos)) (ring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_73439 (h1 : ring (has_append (has_nnnorm (has_nnnorm char)))) : strong_rank_condition (has_append (has_nnnorm (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_73440 (h0 : ring (has_Inf linarith.comp)) : is_principal_ideal_ring (has_Inf linarith.comp) := sorry --non-trivial
lemma new_lemma_73441 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (monoid.{0} ennreal) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_73442 (h0 : functor.add_const (function.extfun Type filter) linarith.comp) : filter.ne_bot (function.extfun_app (functor.add_const.run h0) (add_cancel_monoid name)) := sorry --non-trivial
lemma new_lemma_73443 (h0 : group (ordered_comm_monoid (has_add Type))) : group.fg (ordered_comm_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_73444 (h0 : functor.add_const (ordered_comm_monoid (has_neg_part name)) name) : @has_exists_mul_of_le.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_neg_part.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_73445 (h1 : group (metric_space linarith.comp)) : group.fg (metric_space linarith.comp) := sorry --non-trivial
lemma new_lemma_73446 (h0 : functor.add_const (complete_lattice (finset unsigned)) unsigned) : @is_atomistic.{0} (finset.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (finset.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_73447 (h0 : finset (has_zero (has_neg linarith.comp))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_73448 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (left_cancel_monoid.{0} (semiring.{0} (semiring.{0} empty))) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (left_cancel_monoid.{0} (semiring.{0} (semiring.{0} empty))))  := sorry --non-trivial
lemma new_lemma_73449 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (monoid_with_zero.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (monoid_with_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_73450 (h0 : ring (distrib (comm_ring linarith.comp_source))) : rank_condition (distrib (comm_ring linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_73451 (h0 : ring (has_inv (random_gen (random_gen (random_gen fun_info))))) : is_domain (has_inv (random_gen (random_gen (random_gen fun_info)))) := sorry --non-trivial
lemma new_lemma_73452 (h0 : functor.add_const (function.extfun Type uniform_space) name) : @complete_space.{0} (has_Inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) name h0) (has_Inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_73453 (h0 : functor.add_const (topological_space (has_neg_part unsigned)) pos) : @locally_compact_space.{0} (has_neg_part.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_73454 (h0 : ring (has_ssubset (has_nnnorm char))) : is_domain (has_ssubset (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_73455 (h0 : ordered_comm_monoid (generalized_boolean_algebra (complete_distrib_lattice pos))) : has_exists_mul_of_le (generalized_boolean_algebra (complete_distrib_lattice pos)) := sorry --non-trivial
lemma new_lemma_73456 (h0 : topological_space (normed_group (random_gen (random_gen to_additive.value_type)))) : t0_space (normed_group (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_73457 (h0 : topological_space (random_gen linarith.comp)) : normal_space (random_gen linarith.comp) := sorry --non-trivial
lemma new_lemma_73458 (h0 : group (add_cancel_monoid num)) : normalizer_condition (add_cancel_monoid num) := sorry --non-trivial
lemma new_lemma_73459 (h1 : not (group (fintype fun_info) -> false)) : @is_cyclic.{0} (fintype.{0} fun_info) (@classical.by_contradiction'.{1} (group.{0} (fintype.{0} fun_info)) h1)  := sorry --non-trivial
lemma new_lemma_73460 (h0 : topological_space (id (has_norm (has_norm (has_norm (has_norm empty)))))) : totally_disconnected_space (id (has_norm (has_norm (has_norm (has_norm empty))))) := sorry --non-trivial
lemma new_lemma_73461 (h0 : complete_lattice (has_union (semiring num))) : complete_lattice.is_Sup_finite_compact (has_union (semiring num)) := sorry --non-trivial
lemma new_lemma_73462 (h0 : functor.add_const (topological_space (has_nndist pos)) pos) : @path_connected_space.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_73463 (h0 : not (has_mem.mem (linear_ordered_add_comm_group linarith.ineq) has_emptyc.emptyc -> false)) : @preconnected_space.{0} (linear_ordered_add_comm_group.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type topological_space.{0} (linear_ordered_add_comm_group.{0} linarith.ineq) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (linear_ordered_add_comm_group.{0} linarith.ineq) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_73464 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (denumerable string_imp)) := sorry --non-trivial
lemma new_lemma_73465 (h0 : not (topological_space (semiring linarith.ineq) -> false)) : @totally_disconnected_space.{0} (semiring.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (semiring.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_73466 (h0 : topological_space (semiring (semiring empty))) : preirreducible_space (semiring (semiring empty)) := sorry --non-trivial
lemma new_lemma_73467 (h3 : topological_space linarith.ineq) (h4 : preorder linarith.ineq) : order_topology linarith.ineq := sorry --non-trivial
lemma new_lemma_73468 (h0 : function.extfun Type topological_space) : @t0_space.{0} (encodable.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (encodable.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_73469 (h0 : ring (complete_linear_order unsigned)) : is_principal_ideal_ring (complete_linear_order unsigned) := sorry --non-trivial
lemma new_lemma_73470 (h0 : functor.add_const (semiring (finset name)) linarith.comp) : @is_noetherian_ring.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (semiring.{0} (finset.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_73471 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (comm_semigroup.{0} real) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (comm_semigroup.{0} real))  := sorry --non-trivial
lemma new_lemma_73472 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (sub_neg_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (sub_neg_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_73473 (h0 : topological_space (has_Inf (has_pos_part linarith.comp))) : normal_space (has_Inf (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_73474 (h0 : uniform_space (measurable_space linarith.comp)) : complete_space (measurable_space linarith.comp) := sorry --non-trivial
lemma new_lemma_73475 (h1 : ring (add_monoid (random_gen (fintype char)))) : rank_condition (add_monoid (random_gen (fintype char))) := sorry --non-trivial
lemma new_lemma_73476 (h0 : ring (ordered_comm_monoid (has_add (finset (has_pos_part (boolean_algebra.core Type)))))) : is_domain (ordered_comm_monoid (has_add (finset (has_pos_part (boolean_algebra.core Type))))) := sorry --non-trivial
lemma new_lemma_73477 (h0 : topological_space (complete_distrib_lattice (option pos))) : loc_path_connected_space (complete_distrib_lattice (option pos)) := sorry --non-trivial
lemma new_lemma_73478 (h0 : functor.add_const (list (semigroup linarith.comp)) (ordered_ring name)) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_73479 (h0 : topological_space real) : discrete_topology real := sorry --non-trivial
lemma new_lemma_73480 (h0 : functor.add_const (topological_space (has_zero linarith.comp)) (comm_group Type)) : @t0_space.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_zero.{0} linarith.comp)) (comm_group.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_73481 (h0 : ring (simple_graph linarith.comp_source)) (h1 : topological_space (ring_topology (simple_graph linarith.comp_source))) : totally_disconnected_space (ring_topology (simple_graph linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_73482 (h0 : topological_space (boolean_algebra Type)) : t1_space (boolean_algebra Type) := sorry --non-trivial
lemma new_lemma_73483 (h0 : monoid (cancel_monoid (has_add name))) : monoid.fg (cancel_monoid (has_add name)) := sorry --non-trivial
lemma new_lemma_73484 (h0 : complete_lattice (has_nndist (has_add pos))) : is_compactly_generated (has_nndist (has_add pos)) := sorry --non-trivial
lemma new_lemma_73485 (h0 : functor.add_const (ring (complete_distrib_lattice name)) Type) : @is_domain.{0} (complete_distrib_lattice.{0} name) (@functor.add_const.run.{0 1} (ring.{0} (complete_distrib_lattice.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_73486 (h0 : complete_lattice (semi_normed_ring (comm_ring (has_nnnorm linarith.ineq)))) : is_compactly_generated (semi_normed_ring (comm_ring (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_73487 (h0 : functor.add_const (ring (comm_group unsigned)) linarith.comp) : @rank_condition.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (comm_group.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_73488 (h0 : group (measurable_space (random_gen empty))) : is_cyclic (measurable_space (random_gen empty)) := sorry --non-trivial
lemma new_lemma_73489 (h0 : topological_space (plift (semiring congr_arg_kind))) : preirreducible_space (plift (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_73490 (h0 : topological_space (boolean_algebra (comm_group (has_add name)))) : topological_space.separable_space (boolean_algebra (comm_group (has_add name))) := sorry --non-trivial
lemma new_lemma_73491 (h0 : filter (option (semiring num))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_73492 (h0 : uniform_space (with_bot (has_inv linarith.comp_source))) : complete_space (with_bot (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_73493 (h2 : complete_lattice (semi_normed_ring linarith.ineq)) : is_compactly_generated (semi_normed_ring linarith.ineq) := sorry --non-trivial
lemma new_lemma_73494 (h0 : add_monoid (has_to_string (ring linarith.comp))) : add_monoid.fg (has_to_string (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_73495 (h0 : group (semiring (semiring num))) : is_cyclic (semiring (semiring num)) := sorry --non-trivial
lemma new_lemma_73496 (h0 : ring (linear_ordered_comm_group_with_zero environment.projection_info)) : rank_condition (linear_ordered_comm_group_with_zero environment.projection_info) := sorry --non-trivial
lemma new_lemma_73497 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} empty (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) empty)  := sorry --non-trivial
lemma new_lemma_73498 (h0 : topological_space (has_zero (finset (finset linarith.comp)))) : loc_path_connected_space (has_zero (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_73499 (h0 : topological_space (denumerable (has_nnnorm (random_gen (has_nnnorm fun_info))))) : path_connected_space (denumerable (has_nnnorm (random_gen (has_nnnorm fun_info)))) := sorry --non-trivial
lemma new_lemma_73500 (h0 : complete_lattice (left_cancel_semigroup (semiring empty))) : complete_lattice.is_Sup_finite_compact (left_cancel_semigroup (semiring empty)) := sorry --non-trivial
lemma new_lemma_73501 (h0 : group (has_pos_part (has_pos_part linarith.comp))) : is_simple_group (has_pos_part (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_73502 (h0 : functor.add_const (group (has_add linarith.comp)) (has_neg (ring (has_neg (has_zero Type))))) : @is_simple_group.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 1} (group.{0} (has_add.{0} linarith.comp)) (has_neg.{1} (ring.{1} (has_neg.{1} (has_zero.{1} Type)))) h0)  := sorry --non-trivial
lemma new_lemma_73503 (h0 : functor.add_const (finset (add_cancel_monoid Type)) Type) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_73504 (h0 : list (with_one (random_gen (random_gen string_imp)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_73505 (h0 : functor.add_const (topological_space (left_cancel_monoid congr_arg_kind)) num) : @t0_space.{0} (left_cancel_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_73506 (h0 : functor.comp group has_ssubset to_additive.value_type) : @group.fg.{0} (has_ssubset.{0} to_additive.value_type) (@functor.comp.run.{0 0 0} group.{0} has_ssubset.{0} to_additive.value_type h0)  := sorry --non-trivial
lemma new_lemma_73507 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (generalized_boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (generalized_boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_73508 (h0 : group (semigroup (has_add (ring pos)))) : group.fg (semigroup (has_add (ring pos))) := sorry --non-trivial
lemma new_lemma_73509 (h2 : ring (with_zero linarith.ineq)) : rank_condition (with_zero linarith.ineq) := sorry --non-trivial
lemma new_lemma_73510 (h0 : functor.add_const (topological_space (has_zero congr_arg_kind)) num) : @preconnected_space.{0} (has_zero.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_73511 (h1 : function.extfun Type topological_space) : @t0_space.{0} (@id.{2} Type linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (@id.{2} Type linarith.ineq))  := sorry --non-trivial
lemma new_lemma_73512 (h0 : linarith.comp_source -> functor.comp multiset semi_normed_comm_ring reducibility_hints) (h1 : not (unit -> false)) (h2 : linarith.comp_source) (h3 : multiset (semi_normed_comm_ring reducibility_hints)) : multiset.disjoint (functor.comp.run (matrix.row h0 (classical.by_contradiction' h1) h2)) h3 := sorry --non-trivial
lemma new_lemma_73513 (h0 : function.extfun Type topological_space) : @normal_space.{0} (has_dist.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_dist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_73514 (h1 : topological_space (random_gen (random_gen (random_gen (random_gen to_additive.value_type))))) : path_connected_space (random_gen (random_gen (random_gen (random_gen to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_73515 (h0 : ring (option (semiring num))) : is_domain (option (semiring num)) := sorry --non-trivial
lemma new_lemma_73516 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (add_right_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (add_right_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_73517 (h0 : functor.add_const (complete_lattice (boolean_algebra.core linarith.comp)) pos) : @is_atomistic.{0} (boolean_algebra.core.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (boolean_algebra.core.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_73518 (h0 : not (has_mem.mem add_group has_emptyc.emptyc -> false)) : @is_add_cyclic.{0} (has_top.{0} fun_info) (@function.extfun_app.{2 1} Type add_group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) add_group.{0} (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) add_group.{0} (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type)))) h0)) (has_top.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_73519 (h0 : functor.add_const (topological_space (boolean_algebra Type)) name) : @topological_space.separable_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_73520 (h0 : ordered_comm_monoid (has_neg_part (has_add Type))) : has_exists_mul_of_le (has_neg_part (has_add Type)) := sorry --non-trivial
lemma new_lemma_73521 (h0 : semiring (has_ssubset (has_ssubset (mul_one_class fun_info)))) (h1 : not (has_ssubset (has_ssubset (mul_one_class fun_info)) -> false)) : odd (classical.by_contradiction' h1) := sorry --non-trivial
lemma new_lemma_73522 (h0 : topological_space (ring (has_Inf Type))) : path_connected_space (ring (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_73523 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (complete_distrib_lattice.{0} ennreal) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (complete_distrib_lattice.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_73524 (h1 : ring (add_cancel_comm_monoid linarith.comp_source)) : rank_condition (add_cancel_comm_monoid linarith.comp_source) := sorry --non-trivial
lemma new_lemma_73525 (h0 : functor.add_const (monoid (has_to_string linarith.comp)) Type) : @monoid.fg.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 1} (monoid.{0} (has_to_string.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_73526 (h0 : topological_space (linear_ordered_cancel_comm_monoid empty)) : discrete_topology (linear_ordered_cancel_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_73527 (h0 : functor.add_const (ring (id empty)) empty) : @rank_condition.{0} (@id.{2} Type empty) (@functor.add_const.run.{0 0} (ring.{0} (@id.{2} Type empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_73528 (h0 : topological_space (has_to_string (option (option (option (option (option pos))))))) : locally_compact_space (has_to_string (option (option (option (option (option pos)))))) := sorry --non-trivial
lemma new_lemma_73529 (h0 : has_mem.mem (has_norm empty) has_emptyc.emptyc) : @normal_space.{0} (has_norm.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_norm.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_73530 (h3 : filter (fintype to_additive.value_type)) : filter.ne_bot h3 := sorry --non-trivial
lemma new_lemma_73531 (h0 : functor.add_const (add_group (has_nndist pos)) (has_neg_part Type)) : @is_add_cyclic.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 1} (add_group.{0} (has_nndist.{0} pos)) (has_neg_part.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_73532 (h0 : functor.comp group has_neg Type) : @is_cyclic.{1} (has_neg.{1} Type) (@functor.comp.run.{1 1 1} group.{1} has_neg.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_73533 (h0 : functor.add_const (topological_space (finset pos)) ennreal) : @path_connected_space.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} pos)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_73534 (h0 : group (boolean_algebra.core (finset (has_add Type)))) : is_cyclic (boolean_algebra.core (finset (has_add Type))) := sorry --non-trivial
lemma new_lemma_73535 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (mul_zero_class.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (mul_zero_class.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_73536 (h0 : filter (has_add (has_add (mul_one_class (mul_one_class Type))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_73537 (h0 : add_group (has_nnnorm (mul_one_class ereal))) : is_add_cyclic (has_nnnorm (mul_one_class ereal)) := sorry --non-trivial
lemma new_lemma_73538 (h2 h3 : multiset string.iterator_imp) : multiset.disjoint h2 h3 := sorry --non-trivial
lemma new_lemma_73539 (h0 : list (linear_ordered_comm_group (option congr_arg_kind))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_73540 (h0 : functor.add_const (ring (semigroup Type)) linarith.comp) : @rank_condition.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (semigroup.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_73541 (h0 : functor.add_const (topological_space (has_neg_part linarith.comp)) linarith.comp) : @locally_compact_space.{0} (has_neg_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_73542 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_73543 (h0 : semiring (has_nndist (has_add ennreal))) : is_noetherian_ring (has_nndist (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_73544 (h0 : functor.add_const (functor.add_const (topological_space pos) pos) unsigned) : @regular_space.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) pos (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (topological_space.{0} pos) pos) unsigned h0))  := sorry --non-trivial
lemma new_lemma_73545 (h0 : topological_space (normed_field ereal)) : path_connected_space (normed_field ereal) := sorry --non-trivial
lemma new_lemma_73546 (h0 : ordered_comm_monoid (has_Inf (has_add (has_Inf (ring (has_pos_part linarith.comp)))))) : has_exists_mul_of_le (has_Inf (has_add (has_Inf (ring (has_pos_part linarith.comp))))) := sorry --non-trivial
lemma new_lemma_73547 (h0 : not (topological_space (normed_group unsigned) -> false)) : @path_connected_space.{0} (normed_group.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_group.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_73548 (h0 : topological_space (has_star (semiring empty))) : t1_space (has_star (semiring empty)) := sorry --non-trivial
lemma new_lemma_73549 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_neg.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} num))  := sorry --non-trivial
lemma new_lemma_73550 (h0 : add_group (semi_normed_ring linarith.ineq)) : is_add_cyclic (semi_normed_ring linarith.ineq) := sorry --non-trivial
lemma new_lemma_73551 (h0 : semiring (semigroup (finset name))) : is_noetherian_ring (semigroup (finset name)) := sorry --non-trivial
lemma new_lemma_73552 (h0 : topological_space (has_zero (option name))) : totally_separated_space (has_zero (option name)) := sorry --non-trivial
lemma new_lemma_73553 (h1 : complete_lattice (has_compl (has_nnnorm linarith.comp_source))) : complete_lattice.is_Sup_finite_compact (has_compl (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_73554 (h0 : not (topological_space (has_ssubset to_additive.value_type) -> false)) : @path_connected_space.{0} (has_ssubset.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (has_ssubset.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_73555 (h0 : has_neg (option (option empty)) -> has_neg (option (option empty)) -> Prop) : is_equiv (has_neg (option (option empty))) h0 := sorry --non-trivial
lemma new_lemma_73556 (h0 : ring (normed_field (comm_ring (comm_ring (random_gen string_imp))))) : strong_rank_condition (normed_field (comm_ring (comm_ring (random_gen string_imp)))) := sorry --non-trivial
lemma new_lemma_73557 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (has_inter.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_inter.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_73558 (h0 : function.extfun Type topological_space) : @normal_space.{0} (normed_comm_ring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_73559 (h0 : topological_space (mul_zero_class (has_add ennreal))) : sequential_space (mul_zero_class (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_73560 (h0 : topological_space (has_to_string (finset (finset ennreal)))) : totally_separated_space (has_to_string (finset (finset ennreal))) := sorry --non-trivial
lemma new_lemma_73561 (h0 : functor.add_const (function.extfun Type ordered_comm_monoid) pos) : @has_exists_mul_of_le.{0} (normed_comm_ring.{0} name) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) pos h0) (normed_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_73562 (h0 : functor.add_const (topological_space (has_nndist pos)) (option name)) : @totally_disconnected_space.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} pos)) (option.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_73563 (h0 : functor.add_const (topological_space (boolean_algebra pos)) (finset linarith.comp)) : @t1_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} pos)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_73564 (h0 : topological_space (has_edist (semiring (semiring (semiring (semiring empty)))))) : totally_disconnected_space (has_edist (semiring (semiring (semiring (semiring empty))))) := sorry --non-trivial
lemma new_lemma_73565 (h0 : ring (add_cancel_monoid (has_add environment.implicit_infer_kind))) : rank_condition (add_cancel_monoid (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_73566 (h0 : function.extfun Type (functor.add_const (list (linear_ordered_cancel_comm_monoid empty)))) : palindrome (functor.add_const.run (function.extfun_app h0 empty)) := sorry --non-trivial
lemma new_lemma_73567 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (monoid.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_73568 (h0 : function.extfun (Type 1) topological_space) : @irreducible_space.{1} (normed_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (normed_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_73569 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (simple_graph.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (simple_graph.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_73570 (h0 : ring (canonically_ordered_comm_semiring environment.implicit_infer_kind)) : rank_condition (canonically_ordered_comm_semiring environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_73571 (h0 : function.extfun Type (prod (id num))) : id_rel (function.extfun_app h0 (id num)) := sorry --non-trivial
lemma new_lemma_73572 (h0 : functor.add_const (uniform_space (boolean_algebra pos)) (ring Type)) : @separated_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 1} (uniform_space.{0} (boolean_algebra.{0} pos)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_73573 (h0 : functor.comp filter canonically_ordered_comm_semiring Type) : filter.ne_bot (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_73574 (h0 : ring (has_Inf Type)) : is_principal_ideal_ring (has_Inf Type) := sorry --non-trivial
lemma new_lemma_73575 (h0 : topological_space (comm_semigroup (has_bot (has_bot (has_bot (has_bot real)))))) : locally_compact_space (comm_semigroup (has_bot (has_bot (has_bot (has_bot real))))) := sorry --non-trivial
lemma new_lemma_73576 (h0 : complete_lattice (has_le environment.projection_info)) : is_compactly_generated (has_le environment.projection_info) := sorry --non-trivial
lemma new_lemma_73577 (h0 : functor.add_const (ordered_add_comm_monoid (finset pos)) (mul_one_class linarith.comp)) : @archimedean.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (finset.{0} pos)) (mul_one_class.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_73578 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (add_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} h0 (add_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_73579 (h3 : uniform_space (with_bot fun_info)) : complete_space (with_bot fun_info) := sorry --non-trivial
lemma new_lemma_73580 (h0 : uniform_space (mul_one_class string.iterator_imp)) : complete_space (mul_one_class string.iterator_imp) := sorry --non-trivial
lemma new_lemma_73581 (h0 : function.extfun ((finset Type -> Prop) -> Prop) (function.extfun (finset Type -> Prop))) : @is_atomistic.{0} fun_info (@finset.pi.empty.{1 0} Type complete_lattice.{0} fun_info (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) fun_info) (@function.extfun_app.{2 0} (finset.{1} Type → Prop) (function.extfun.{2 0} (finset.{1} Type)) (@function.extfun_app.{2 0} ((finset.{1} Type → Prop) → Prop) (function.extfun.{2 0} (finset.{1} Type → Prop)) h0 (function.extfun.{2 0} (finset.{1} Type))) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) fun_info)) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_73582 (h0 : filter (semigroup (has_add environment.implicit_infer_kind))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_73583 (h0 : functor.add_const (function.extfun Type complete_lattice) (has_add pos)) : @is_compactly_generated.{0} (semigroup.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) (has_add.{0} pos) h0) (semigroup.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_73584 (h0 : not (uniform_space (has_norm congr_arg_kind) -> false)) : @separated_space.{0} (has_norm.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_norm.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_73585 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (has_to_string.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (has_to_string.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_73586 (h0 : fin has_zero.zero) : @loc_path_connected_space.{0} (ordered_comm_ring.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (ordered_comm_ring.{0} real))  := sorry --non-trivial
lemma new_lemma_73587 (h0 : function.extfun Type (functor.add_const (fin has_zero.zero))) : @is_cyclic.{0} (has_pos_part.{0} real) (@matrix.vec_empty.{0} (group.{0} (has_pos_part.{0} real)) (@functor.add_const.run.{0 0} (fin (@has_zero.zero.{0} nat nat.has_zero)) real (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (fin (@has_zero.zero.{0} nat nat.has_zero))) h0 real)))  := sorry --non-trivial
lemma new_lemma_73588 (h0 : filter (comm_group (option (option (option pos))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_73589 (h0 : finset (finset (has_zero Type))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_73590 (h0 : functor.add_const (group (semigroup linarith.comp)) name) : @group.fg.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (semigroup.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_73591 (h0 : topological_space (has_nndist (has_add pos))) : topological_space.separable_space (has_nndist (has_add pos)) := sorry --non-trivial
lemma new_lemma_73592 (h0 : functor.add_const (cancel_comm_monoid_with_zero (ring name)) name) : @unique_factorization_monoid.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (ring.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_73593 (h0 : topological_space (has_one (semiring (semiring (semiring congr_arg_kind))))) : normal_space (has_one (semiring (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_73594 (h0 : ring (generalized_boolean_algebra (has_Inf pos))) : is_principal_ideal_ring (generalized_boolean_algebra (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_73595 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (semigroup.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_73596 (h1 : function.extfun (finset (Type -> Type)) (has_mem.mem monoid)) : @monoid.fg.{0} (with_bot.{0} fun_info) (@function.extfun_app.{2 1} Type monoid.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) monoid.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) monoid.{0}) h1 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (with_bot.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_73597 (h0 : ring (encodable linarith.ineq)) : rank_condition (encodable linarith.ineq) := sorry --non-trivial
lemma new_lemma_73598 (h0 : fin has_zero.zero) : @t0_space.{1} (simple_graph.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (simple_graph.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_73599 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @monoid.fg.{1} (cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) monoid.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 monoid.{1}) (cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_73600 (h0 : not (topological_space (has_top unsigned) -> false)) : @t0_space.{0} (has_top.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (has_top.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_73601 (h0 : has_mem.mem complete_lattice has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} (with_one.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} h0) (with_one.{0} num))  := sorry --non-trivial
lemma new_lemma_73602 (h0 : group (has_pos_part (has_neg pos))) : is_simple_group (has_pos_part (has_neg pos)) := sorry --non-trivial
lemma new_lemma_73603 (h1 : ereal) (h2 : coe_sort (set.range (fun (h0 : Prop), h1)) -> Prop) : set.range_splitting (fun (h0 : Prop), h1) (classical.epsilon h2) := sorry --non-trivial
lemma new_lemma_73604 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (comm_semigroup.{0} real) (@function.extfun_app.{2 1} Type add_group.{0} h0 (comm_semigroup.{0} real))  := sorry --non-trivial
lemma new_lemma_73605 (h0 : ring (left_cancel_semigroup (semiring (semiring num)))) : is_domain (left_cancel_semigroup (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_73606 (h0 : topological_space (id linarith.comp)) : totally_disconnected_space (id linarith.comp) := sorry --non-trivial
lemma new_lemma_73607 (h0 : topological_space (has_nnnorm (has_nnnorm string_imp))) : t0_space (has_nnnorm (has_nnnorm string_imp)) := sorry --non-trivial
lemma new_lemma_73608 (h0 : semiring (semigroup (has_add Type))) : is_noetherian_ring (semigroup (has_add Type)) := sorry --non-trivial
lemma new_lemma_73609 (h0 : functor.add_const (ring (has_zero environment.implicit_infer_kind)) Type) : @is_domain.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (ring.{0} (has_zero.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_73610 (h0 : complete_lattice (linear_ordered_add_comm_group (has_nnnorm fun_info))) : is_compactly_generated (linear_ordered_add_comm_group (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_73611 (h0 : topological_space (ordered_cancel_add_comm_monoid pos)) : normal_space (ordered_cancel_add_comm_monoid pos) := sorry --non-trivial
lemma new_lemma_73612 (h0 : cancel_comm_monoid_with_zero (has_pos_part (has_add pos))) : unique_factorization_monoid (has_pos_part (has_add pos)) := sorry --non-trivial
lemma new_lemma_73613 (h0 : complete_lattice (has_compl (has_compl linarith.comp_source))) : is_compactly_generated (has_compl (has_compl linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_73614 (h0 : uniform_space (complete_distrib_lattice (has_nndist (ring (finset pos))))) : separated_space (complete_distrib_lattice (has_nndist (ring (finset pos)))) := sorry --non-trivial
lemma new_lemma_73615 (h0 : complete_lattice (add_right_cancel_monoid (semiring (semiring congr_arg_kind)))) : is_atomistic (add_right_cancel_monoid (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_73616 (h0 : list (boolean_algebra (finset (has_pos_part (has_add (has_to_string (has_add linarith.comp))))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_73617 (h0 : monoid (random_gen (has_top fun_info))) : monoid.fg (random_gen (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_73618 (h0 : functor.add_const (topological_space (comm_group name)) name) : @t1_space.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_73619 (h0 : functor.add_const (topological_space (has_add linarith.comp)) (finset linarith.comp)) : @path_connected_space.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} linarith.comp)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_73620 (h2 : topological_space (has_append (has_nnnorm (has_nnnorm linarith.ineq)))) : t0_space (has_append (has_nnnorm (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_73621 (h4 : topological_space enat) (h5 : set enat) : is_path_connected h5 := sorry --non-trivial
lemma new_lemma_73622 (h0 : complete_lattice (has_nnnorm environment.projection_info)) : complete_lattice.is_Sup_finite_compact (has_nnnorm environment.projection_info) := sorry --non-trivial
lemma new_lemma_73623 (h0 : topological_space (ordered_comm_ring (ordered_comm_monoid real))) : t1_space (ordered_comm_ring (ordered_comm_monoid real)) := sorry --non-trivial
lemma new_lemma_73624 (h0 : functor.add_const (topological_space (normed_comm_ring pos)) Type) : @discrete_topology.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (normed_comm_ring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_73625 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (random_gen.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (random_gen.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_73626 (h0 : functor.add_const (ring (has_Inf pos)) Type) : @rank_condition.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (has_Inf.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_73627 (h0 : multiset (has_compl char)) (h1 : not (multiset (has_compl char) -> false)) : multiset.disjoint h0 (classical.by_contradiction' h1) := sorry --non-trivial
lemma new_lemma_73628 (h0 : topological_space (has_compl (has_nnnorm char))) : locally_compact_space (has_compl (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_73629 (h0 : ordered_add_comm_monoid (has_bot linarith.comp)) : archimedean (has_bot linarith.comp) := sorry --non-trivial
lemma new_lemma_73630 (h0 : group (has_top (random_gen linarith.ineq))) : normalizer_condition (has_top (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_73631 (h0 : not (list (linear_ordered_semiring unsigned) -> false)) : list.nodup (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_73632 (h0 : functor.add_const (uniform_space (ordered_comm_monoid name)) pos) : @complete_space.{0} (ordered_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (ordered_comm_monoid.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_73633 (h0 : topological_space (has_zero environment.implicit_infer_kind)) : topological_space.separable_space (has_zero environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_73634 (h0 : group (fintype (random_gen linarith.comp_source))) : is_cyclic (fintype (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_73635 (h0 : topological_space (has_nndist (option (option ennreal)))) : discrete_topology (has_nndist (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_73636 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @normal_space.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_73637 (h0 : ring (simple_graph char)) : rank_condition (simple_graph char) := sorry --non-trivial
lemma new_lemma_73638 (h0 : topological_space (sub_neg_monoid pos)) : irreducible_space (sub_neg_monoid pos) := sorry --non-trivial
lemma new_lemma_73639 (h0 : not (function.extfun Type (functor.add_const Prop) -> false)) : functor.add_const.run (function.extfun_app (classical.by_contradiction' h0) num) := sorry --non-trivial
lemma new_lemma_73640 (h0 : ordered_add_comm_monoid name) : archimedean name := sorry --non-trivial
lemma new_lemma_73641 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (semiring.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (semiring.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_73642 (h0 : not (add_group (uniform_space reducibility_hints) -> false)) : @is_add_cyclic.{0} (uniform_space.{0} reducibility_hints) (@classical.by_contradiction'.{1} (add_group.{0} (uniform_space.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_73643 (h0 : ring (semigroup (has_neg pos))) : strong_rank_condition (semigroup (has_neg pos)) := sorry --non-trivial
lemma new_lemma_73644 (h0 : not (topological_space (has_norm linarith.comp_source) -> false)) : @path_connected_space.{0} (has_norm.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (has_norm.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_73645 (h0 : topological_space (normed_group (random_gen (random_gen (random_gen linarith.comp_source))))) : irreducible_space (normed_group (random_gen (random_gen (random_gen linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_73646 (h0 : functor.add_const (add_group (ring environment.implicit_infer_kind)) environment.implicit_infer_kind) : @is_add_cyclic.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (add_group.{0} (ring.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_73647 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (non_assoc_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (non_assoc_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_73648 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (@id.{2} Type congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (@id.{2} Type congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_73649 (h0 : not (topological_space (with_bot unsigned) -> false)) : @t0_space.{0} (with_bot.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (with_bot.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_73650 (h0 : list (has_zero (has_neg linarith.comp))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_73651 (h0 : functor.add_const (ring (has_nndist name)) name) : @is_domain.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (has_nndist.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_73652 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (has_edist.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_edist.{0} empty))  := sorry --non-trivial
lemma new_lemma_73653 (h0 : topological_space (has_add (option ennreal))) : preconnected_space (has_add (option ennreal)) := sorry --non-trivial
lemma new_lemma_73654 (h0 : group (normed_field (has_nnnorm to_additive.value_type))) : is_cyclic (normed_field (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_73655 (h0 : filter (has_compl fun_info)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_73656 (h1 : group (has_ssubset (random_gen (random_gen (random_gen string_imp))))) : group.fg (has_ssubset (random_gen (random_gen (random_gen string_imp)))) := sorry --non-trivial
lemma new_lemma_73657 (h0 : topological_space (simple_graph (has_add (finset pos)))) : path_connected_space (simple_graph (has_add (finset pos))) := sorry --non-trivial
lemma new_lemma_73658 (h0 : not (topological_space (measurable_space.dynkin_system linarith.comp) -> false)) : @normal_space.{0} (measurable_space.dynkin_system.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (measurable_space.dynkin_system.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_73659 (h0 : functor.add_const (add_monoid (free_add_monoid unsigned)) unsigned) : add_monoid.fg (free_add_monoid unsigned) := sorry --non-trivial
lemma new_lemma_73660 (h0 : set (add_comm_semigroup (add_comm_semigroup (add_comm_semigroup char)) -> char)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_73661 (h0 : complete_lattice (has_add (has_neg (has_add linarith.comp)))) : is_compactly_generated (has_add (has_neg (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_73662 (h0 : functor.add_const (add_group (linear_ordered_comm_monoid_with_zero unsigned)) empty) : @is_add_cyclic.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned) (@functor.add_const.run.{0 0} (add_group.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_73663 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (non_assoc_semiring unsigned)) := sorry --non-trivial
lemma new_lemma_73664 (h0 : semiring (linear_ordered_comm_monoid_with_zero (semiring (semiring empty)))) : is_noetherian_ring (linear_ordered_comm_monoid_with_zero (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_73665 (h0 : not (function.extfun Type topological_space -> false)) : @irreducible_space.{0} (@id.{2} Type num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (@id.{2} Type num))  := sorry --non-trivial
lemma new_lemma_73666 (h0 : group (with_one (has_nnnorm (random_gen fun_info)))) : is_cyclic (with_one (has_nnnorm (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_73667 (h0 : add_group (has_nndist (finset linarith.comp))) : is_add_cyclic (has_nndist (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_73668 (h0 : functor.add_const (topological_space (finset linarith.comp)) (has_neg (finset Type))) : @t1_space.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (finset.{0} linarith.comp)) (has_neg.{1} (finset.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_73669 (h0 : group (has_nnnorm (random_gen linarith.ineq))) : group.fg (has_nnnorm (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_73670 (h0 : group (has_bot real)) : group.fg (has_bot real) := sorry --non-trivial
lemma new_lemma_73671 (h0 : functor.add_const (topological_space (has_nndist environment.implicit_infer_kind)) environment.implicit_infer_kind) : @sequential_space.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_73672 (h1 : topological_space (add_left_cancel_monoid char)) : path_connected_space (add_left_cancel_monoid char) := sorry --non-trivial
lemma new_lemma_73673 (h0 : semiring (measurable_space.dynkin_system (has_norm empty))) : is_noetherian_ring (measurable_space.dynkin_system (has_norm empty)) := sorry --non-trivial
lemma new_lemma_73674 (h0 : functor.add_const (list (mul_zero_class pos)) Type) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_73675 (h0 : list (filter (add_cancel_monoid (add_cancel_monoid (add_comm_monoid unsigned))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_73676 (h0 : functor.add_const (topological_space (boolean_algebra name)) linarith.comp) : @preirreducible_space.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_73677 (h0 : uniform_space (canonically_ordered_comm_semiring congr_arg_kind)) : separated_space (canonically_ordered_comm_semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_73678 (h0 : not (function.extfun Type topological_space -> false)) : @preirreducible_space.{0} (option.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (option.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_73679 (h0 : list (canonically_linear_ordered_monoid congr_arg_kind)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_73680 (h0 : function.extfun (((finset Type -> Prop) -> Prop) -> Prop) (function.extfun ((finset Type -> Prop) -> Prop))) : @monoid.fg.{0} num (@finset.pi.empty.{1 0} Type monoid.{0} num (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) num) (@function.extfun_app.{2 0} (finset.{1} Type → Prop) (function.extfun.{2 0} (finset.{1} Type)) (@function.extfun_app.{2 0} ((finset.{1} Type → Prop) → Prop) (function.extfun.{2 0} (finset.{1} Type → Prop)) (@function.extfun_app.{2 0} (((finset.{1} Type → Prop) → Prop) → Prop) (function.extfun.{2 0} ((finset.{1} Type → Prop) → Prop)) h0 (function.extfun.{2 0} (finset.{1} Type → Prop))) (function.extfun.{2 0} (finset.{1} Type))) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) num)) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_73681 (h0 : add_group (has_nndist (option name))) : is_add_cyclic (has_nndist (option name)) := sorry --non-trivial
lemma new_lemma_73682 (h0 : functor.add_const (ring (simple_graph pos)) linarith.comp) : @is_principal_ideal_ring.{0} (simple_graph.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (simple_graph.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_73683 (h0 : complete_lattice (with_zero (random_gen (has_nnnorm linarith.ineq)))) : is_compactly_generated (with_zero (random_gen (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_73684 (h0 : topological_space (comm_ring (has_nnnorm char))) : t0_space (comm_ring (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_73685 (h0 : complete_lattice (semigroup (has_add (has_add environment.implicit_infer_kind)))) : is_compactly_generated (semigroup (has_add (has_add environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_73686 (h0 : group (cancel_monoid name)) : group.fg (cancel_monoid name) := sorry --non-trivial
lemma new_lemma_73687 (h0 : functor.add_const (function.extfun Type topological_space) environment.implicit_infer_kind) : @totally_disconnected_space.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) environment.implicit_infer_kind h0) (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_73688 (h0 : monoid (id fun_info)) : monoid.fg (id fun_info) := sorry --non-trivial
lemma new_lemma_73689 (h0 : functor.add_const (topological_space (has_pos_part linarith.comp)) Type) : @path_connected_space.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_pos_part.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_73690 (h0 : group (has_neg_part (semigroup (has_zero Type)))) : normalizer_condition (has_neg_part (semigroup (has_zero Type))) := sorry --non-trivial
lemma new_lemma_73691 (h0 : functor.add_const (topological_space (free_add_monoid empty)) (semiring num)) : @preirreducible_space.{0} (free_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} empty)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_73692 (h0 : add_monoid (complete_linear_order (semiring (semiring (semiring unsigned))))) : add_monoid.fg (complete_linear_order (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_73693 (h0 : has_mem.mem (has_emptyc empty) has_emptyc.emptyc) : @irreducible_space.{0} (has_emptyc.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_emptyc.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_73694 (h0 : functor.add_const (topological_space (add_cancel_monoid pos)) Type) : @locally_compact_space.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (add_cancel_monoid.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_73695 (h0 : function.extfun Type (prod (has_union unsigned))) : id_rel (function.extfun_app h0 (has_union unsigned)) := sorry --non-trivial
lemma new_lemma_73696 (h0 : ring (measure_theory.measure_space empty)) : strong_rank_condition (measure_theory.measure_space empty) := sorry --non-trivial
lemma new_lemma_73697 (h0 : topological_space (add_comm_semigroup linarith.ineq)) (h1 : preorder (add_comm_semigroup linarith.ineq)) : order_topology (add_comm_semigroup linarith.ineq) := sorry --non-trivial
lemma new_lemma_73698 (h0 : pseudo_metric_space (boolean_algebra pos)) (h1 : functor.add_const (add_monoid (boolean_algebra pos)) pos) : @has_lipschitz_add.{0} (boolean_algebra.{0} pos) h0 (@functor.add_const.run.{0 0} (add_monoid.{0} (boolean_algebra.{0} pos)) pos h1)  := sorry --non-trivial
lemma new_lemma_73699 (h0 : functor.add_const (add_group (mul_zero_class unsigned)) name) : @is_add_cyclic.{0} (mul_zero_class.{0} unsigned) (@functor.add_const.run.{0 0} (add_group.{0} (mul_zero_class.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_73700 (h0 : functor.add_const (filter (comm_monoid_with_zero empty)) unsigned) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_73701 (h0 : topological_space (canonically_ordered_monoid (has_Inf (has_Inf name)))) : t1_space (canonically_ordered_monoid (has_Inf (has_Inf name))) := sorry --non-trivial
lemma new_lemma_73702 (h0 : functor.add_const (topological_space (ring Type)) name) : @preirreducible_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ring.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_73703 (h0 : add_group (normed_group (denumerable to_additive.value_type))) : is_add_cyclic (normed_group (denumerable to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_73704 (h1 : not (topological_space (topological_space string_imp) -> false)) : @path_connected_space.{0} (topological_space.{0} string_imp) (@classical.by_contradiction'.{1} (topological_space.{0} (topological_space.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_73705 (h0 : list (normed_comm_ring (cancel_monoid Type))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_73706 (h0 : topological_space (has_add (option ennreal))) : loc_path_connected_space (has_add (option ennreal)) := sorry --non-trivial
lemma new_lemma_73707 (h0 : topological_space (option empty)) : locally_compact_space (option empty) := sorry --non-trivial
lemma new_lemma_73708 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @totally_separated_space.{0} num (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) num)  := sorry --non-trivial
lemma new_lemma_73709 (h0 : function.extfun (Type 1) topological_space) : @preirreducible_space.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_73710 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (has_inter.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (has_inter.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_73711 (h0 : filter (has_emptyc (has_emptyc fun_info))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_73712 (h0 : semiring enat) (h2 : ideal enat) : ideal.is_prime h2 := sorry --non-trivial
lemma new_lemma_73713 (h0 : topological_space (with_bot (semiring empty))) : locally_compact_space (with_bot (semiring empty)) := sorry --non-trivial
lemma new_lemma_73714 (h0 : group (add_cancel_monoid (finset (finset Type)))) : group.fg (add_cancel_monoid (finset (finset Type))) := sorry --non-trivial
lemma new_lemma_73715 (h0 : ring (add_monoid (has_nnnorm fun_info))) : rank_condition (add_monoid (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_73716 (h1 : group (encodable (denumerable to_additive.value_type))) : group.fg (encodable (denumerable to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_73717 (h0 : complete_lattice (linear_ordered_comm_group empty)) : is_atomistic (linear_ordered_comm_group empty) := sorry --non-trivial
lemma new_lemma_73718 (h0 : functor.add_const (group (boolean_algebra name)) environment.implicit_infer_kind) : @normalizer_condition.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_73719 (h0 : topological_space (with_bot (semiring num))) : locally_compact_space (with_bot (semiring num)) := sorry --non-trivial
lemma new_lemma_73720 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (with_one.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_one.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_73721 (h0 : uniform_space (measurable_space (has_top to_additive.value_type))) : separated_space (measurable_space (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_73722 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (has_nndist.{0} num) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (has_nndist.{0} num))  := sorry --non-trivial
lemma new_lemma_73723 (h0 : filter (boolean_algebra.core (has_nndist pos))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_73724 (h0 : functor.add_const (topological_space (ordered_comm_ring name)) Type) : @t0_space.{0} (ordered_comm_ring.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (ordered_comm_ring.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_73725 (h0 : function.extfun (Type 1) (functor.comp cancel_comm_monoid_with_zero has_zero)) : @unique_factorization_monoid.{1} (has_zero.{1} Type) (@functor.comp.run.{1 1 1} cancel_comm_monoid_with_zero.{1} has_zero.{1} Type (@function.extfun_app.{3 2} (Type 1) (functor.comp.{1 1 1} cancel_comm_monoid_with_zero.{1} has_zero.{1}) h0 Type))  := sorry --non-trivial
lemma new_lemma_73726 (h0 : uniform_space (has_bot (has_Inf real))) : complete_space (has_bot (has_Inf real)) := sorry --non-trivial
lemma new_lemma_73727 (h0 : topological_space (complete_linear_order congr_arg_kind)) : totally_disconnected_space (complete_linear_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_73728 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (canonically_linear_ordered_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (canonically_linear_ordered_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_73729 (h0 : not (topological_space (partial_order unsigned) -> false)) : @discrete_topology.{0} (partial_order.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (partial_order.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_73730 (h0 : functor.add_const (functor.add_const (monoid (has_nndist environment.implicit_infer_kind)) pos) name) : @monoid.fg.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (monoid.{0} (has_nndist.{0} environment.implicit_infer_kind)) pos (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (monoid.{0} (has_nndist.{0} environment.implicit_infer_kind)) pos) name h0))  := sorry --non-trivial
lemma new_lemma_73731 (h0 : topological_space (comm_ring (has_top linarith.comp_source))) : t0_space (comm_ring (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_73732 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @strong_rank_condition.{1} (normed_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ring.{1}) (normed_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_73733 (h0 : topological_space (linear_ordered_field empty)) : totally_disconnected_space (linear_ordered_field empty) := sorry --non-trivial
lemma new_lemma_73734 (h0 : function.extfun Type (functor.add_const (topological_space (has_add linarith.comp)))) : @t0_space.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} linarith.comp)) linarith.comp (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (has_add.{0} linarith.comp))) h0 linarith.comp))  := sorry --non-trivial
lemma new_lemma_73735 (h0 : cancel_comm_monoid_with_zero (has_pos_part (option congr_arg_kind))) : unique_factorization_monoid (has_pos_part (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_73736 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (has_zero (ring unsigned))) := sorry --non-trivial
lemma new_lemma_73737 (h0 : topological_space (complete_semilattice_Sup (semiring (semiring (semiring congr_arg_kind))))) : t0_space (complete_semilattice_Sup (semiring (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_73738 (h0 : topological_space (add_cancel_monoid (has_neg (has_nndist (ordered_ring (has_neg (has_neg name))))))) : irreducible_space (add_cancel_monoid (has_neg (has_nndist (ordered_ring (has_neg (has_neg name)))))) := sorry --non-trivial
lemma new_lemma_73739 (h0 : functor.add_const (ordered_add_comm_monoid (has_star unsigned)) unsigned) : @archimedean.{0} (has_star.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_star.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_73740 (h0 : functor.comp topological_space comm_group Type) : @topological_space.separable_space.{1} (comm_group.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} comm_group.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_73741 (h0 : complete_lattice (add_cancel_comm_monoid (mul_one_class reducibility_hints))) : is_compactly_generated (add_cancel_comm_monoid (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_73742 (h0 : functor.add_const (topological_space (partial_order unsigned)) empty) : @discrete_topology.{0} (partial_order.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (partial_order.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_73743 (h0 : ring (has_star (semiring (semiring num)))) : is_principal_ideal_ring (has_star (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_73744 (h0 : topological_space (has_bot congr_arg_kind)) : normal_space (has_bot congr_arg_kind) := sorry --non-trivial
lemma new_lemma_73745 (h0 : group (cancel_monoid (has_nndist ennreal))) : is_simple_group (cancel_monoid (has_nndist ennreal)) := sorry --non-trivial
lemma new_lemma_73746 (h0 : group (finset (has_add (has_add (finset linarith.comp))))) : is_cyclic (finset (has_add (has_add (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_73747 (h0 : ring (left_cancel_semigroup congr_arg_kind)) : rank_condition (left_cancel_semigroup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_73748 (h0 : functor.add_const (topological_space (finset name)) name) : @normal_space.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_73749 (h0 : topological_space (add_comm_monoid (has_neg pos))) : regular_space (add_comm_monoid (has_neg pos)) := sorry --non-trivial
lemma new_lemma_73750 (h0 : topological_space (has_nnnorm (mul_one_class char))) (h1 : preorder (has_nnnorm (mul_one_class char))) : order_closed_topology (has_nnnorm (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_73751 (h0 : complete_lattice (ring ennreal)) : complete_lattice.is_Sup_finite_compact (ring ennreal) := sorry --non-trivial
lemma new_lemma_73752 (h0 : not (ring (distrib string.iterator_imp) -> false)) : @strong_rank_condition.{0} (distrib.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (ring.{0} (distrib.{0} string.iterator_imp)) h0)  := sorry --non-trivial
lemma new_lemma_73753 (h0 : topological_space (with_one linarith.ineq)) : irreducible_space (with_one linarith.ineq) := sorry --non-trivial
lemma new_lemma_73754 (h0 : topological_space (metric_space (has_norm empty))) : path_connected_space (metric_space (has_norm empty)) := sorry --non-trivial
lemma new_lemma_73755 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (add_comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_73756 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (normed_comm_ring ennreal)) := sorry --non-trivial
lemma new_lemma_73757 (h0 : group (has_to_string (finset (has_pos_part linarith.comp)))) : is_cyclic (has_to_string (finset (has_pos_part linarith.comp))) := sorry --non-trivial
lemma new_lemma_73758 (h0 : topological_space nnreal) : t1_space nnreal := sorry --non-trivial
lemma new_lemma_73759 (h0 : topological_space (has_neg (has_pos_part (ring (has_nndist (has_neg Type)))))) : irreducible_space (has_neg (has_pos_part (ring (has_nndist (has_neg Type))))) := sorry --non-trivial
lemma new_lemma_73760 (h0 : topological_space (ordered_cancel_add_comm_monoid ennreal)) : preconnected_space (ordered_cancel_add_comm_monoid ennreal) := sorry --non-trivial
lemma new_lemma_73761 (h0 : function.extfun Type (prod (cancel_monoid pos))) : id_rel (function.extfun_app h0 (cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_73762 (h0 : functor.add_const (topological_space (add_cancel_monoid pos)) (has_add pos)) : @locally_compact_space.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} pos)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_73763 (h0 : function.extfun Type (functor.comp topological_space has_neg)) : @normal_space.{0} (has_neg.{0} unsigned) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} unsigned (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} has_neg.{0}) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_73764 (h0 : functor.add_const (finset (boolean_algebra pos)) name) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_73765 (h0 : functor.add_const (function.extfun Type group) (has_add (has_add name))) : @is_cyclic.{0} (semigroup.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) (has_add.{0} (has_add.{0} name)) h0) (semigroup.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_73766 (h0 : topological_space (normed_comm_ring (option unsigned))) : totally_separated_space (normed_comm_ring (option unsigned)) := sorry --non-trivial
lemma new_lemma_73767 (h0 : functor.add_const (group (normed_comm_ring environment.implicit_infer_kind)) name) : @is_simple_group.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (normed_comm_ring.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_73768 (h0 : group (add_left_cancel_monoid (random_gen to_additive.value_type))) : is_cyclic (add_left_cancel_monoid (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_73769 (h0 : list (has_neg (has_neg environment.implicit_infer_kind))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_73770 (h0 : topological_space (finset congr_arg_kind)) : topological_space.separable_space (finset congr_arg_kind) := sorry --non-trivial
lemma new_lemma_73771 (h0 : topological_space (monoid_with_zero congr_arg_kind)) : t1_space (monoid_with_zero congr_arg_kind) := sorry --non-trivial
lemma new_lemma_73772 (h0 : list (ordered_comm_monoid (has_Inf Type))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_73773 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_73774 (h0 : functor.add_const (topological_space (mul_zero_class ennreal)) unsigned) : @locally_compact_space.{0} (mul_zero_class.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_73775 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @totally_disconnected_space.{0} (has_Inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (has_Inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_73776 (h0 : topological_space (has_star empty)) : t0_space (has_star empty) := sorry --non-trivial
lemma new_lemma_73777 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (ordered_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (ordered_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_73778 (h0 : not (group (has_emptyc linarith.comp) -> false)) : @group.fg.{0} (has_emptyc.{0} linarith.comp) (@classical.by_contradiction'.{1} (group.{0} (has_emptyc.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_73779 (h0 : ring (normed_field (add_comm_semigroup enat))) : strong_rank_condition (normed_field (add_comm_semigroup enat)) := sorry --non-trivial
lemma new_lemma_73780 (h0 : ring (has_bot (has_Inf Type))) : is_domain (has_bot (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_73781 (h0 : function.extfun unsigned (fun (x : unsigned), Prop)) : zzz_forall (function.extfun_app h0) := sorry --non-trivial
lemma new_lemma_73782 (h0 : monoid (has_to_string (semigroup (comm_group name)))) : monoid.fg (has_to_string (semigroup (comm_group name))) := sorry --non-trivial
lemma new_lemma_73783 (h0 : has_mem.mem (measurable_space linarith.ineq) has_emptyc.emptyc) : @normalizer_condition.{0} (measurable_space.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type group.{0} (measurable_space.{0} linarith.ineq) h0)  := sorry --non-trivial
lemma new_lemma_73784 (h0 : topological_space (mul_zero_class (semiring (semiring (semiring num))))) : discrete_topology (mul_zero_class (semiring (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_73785 (h0 : functor.add_const (topological_space (has_nndist name)) Type) : @t0_space.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (has_nndist.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_73786 (h0 : function.extfun nat fin) : @is_cyclic.{1} (ring.{1} Type) (@matrix.vec_empty.{1} (group.{1} (ring.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_73787 (h0 : complete_lattice (semigroup pos)) : is_atomistic (semigroup pos) := sorry --non-trivial
lemma new_lemma_73788 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (add_cancel_comm_monoid.{0} (option.{0} unsigned)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_comm_monoid.{0} (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_73789 (h0 : group (has_pos_part (boolean_algebra.core pos))) : is_simple_group (has_pos_part (boolean_algebra.core pos)) := sorry --non-trivial
lemma new_lemma_73790 (h1 : ring (distrib_lattice to_additive.value_type)) : strong_rank_condition (distrib_lattice to_additive.value_type) := sorry --non-trivial
lemma new_lemma_73791 (h0 : topological_space (canonically_ordered_monoid (has_add real))) : sequential_space (canonically_ordered_monoid (has_add real)) := sorry --non-trivial
lemma new_lemma_73792 (h0 : functor.add_const (ring (add_cancel_monoid pos)) (finset (finset pos))) : @rank_condition.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (add_cancel_monoid.{0} pos)) (finset.{0} (finset.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_73793 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (has_top.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_top.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_73794 (h0 : semiring (has_nndist (finset environment.implicit_infer_kind))) : is_noetherian_ring (has_nndist (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_73795 (h0 : uniform_space (has_nnnorm (with_one (group_with_zero char)))) : complete_space (has_nnnorm (with_one (group_with_zero char))) := sorry --non-trivial
lemma new_lemma_73796 (h0 : ring (boolean_algebra (ring environment.implicit_infer_kind))) : is_domain (boolean_algebra (ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_73797 (h0 : cancel_comm_monoid_with_zero (has_add (boolean_algebra unsigned))) : unique_factorization_monoid (has_add (boolean_algebra unsigned)) := sorry --non-trivial
lemma new_lemma_73798 (h0 : group (has_to_string (comm_group name))) : normalizer_condition (has_to_string (comm_group name)) := sorry --non-trivial
lemma new_lemma_73799 (h0 : ring (mul_zero_class (semiring (semiring congr_arg_kind)))) : strong_rank_condition (mul_zero_class (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_73800 (h0 : ring (ordered_ring (semiring empty))) : rank_condition (ordered_ring (semiring empty)) := sorry --non-trivial
lemma new_lemma_73801 (h0 : not (has_mem.mem (random_gen linarith.comp_source) has_emptyc.emptyc -> false)) : @t0_space.{0} (random_gen.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (random_gen.{0} linarith.comp_source) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} linarith.comp_source) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_73802 (h0 : not (group (encodable (has_nnnorm (random_gen (has_nnnorm (random_gen (has_nnnorm char)))))) -> false)) : @group.fg.{0} (encodable.{0} (has_nnnorm.{0} (random_gen.{0} (has_nnnorm.{0} (random_gen.{0} (has_nnnorm.{0} char)))))) (@classical.by_contradiction'.{1} (group.{0} (encodable.{0} (has_nnnorm.{0} (random_gen.{0} (has_nnnorm.{0} (random_gen.{0} (has_nnnorm.{0} char))))))) h0)  := sorry --non-trivial
lemma new_lemma_73803 (h0 : group (sub_neg_monoid name)) : is_cyclic (sub_neg_monoid name) := sorry --non-trivial
lemma new_lemma_73804 (h0 : function.extfun Type (functor.add_const Prop)) : functor.add_const.run (function.extfun_app h0 (has_zero ennreal)) := sorry --non-trivial
lemma new_lemma_73805 (h2 : has_neg fun_info) (h3 : measurable_space fun_info) : has_measurable_neg fun_info := sorry --non-trivial
lemma new_lemma_73806 (h0 : add_group (semiring (has_norm fun_info))) : is_add_cyclic (semiring (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_73807 (h0 : topological_space (has_add (has_zero unsigned))) : path_connected_space (has_add (has_zero unsigned)) := sorry --non-trivial
lemma new_lemma_73808 (h0 : topological_space (semigroup (has_add (comm_group Type)))) : preirreducible_space (semigroup (has_add (comm_group Type))) := sorry --non-trivial
lemma new_lemma_73809 (h0 : not (finset (linear_ordered_comm_ring unsigned) -> false)) : finset.nonempty (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_73810 (h0 : ring (measurable_space.dynkin_system (option (semiring (semiring (semiring unsigned)))))) : is_domain (measurable_space.dynkin_system (option (semiring (semiring (semiring unsigned))))) := sorry --non-trivial
lemma new_lemma_73811 (h0 : functor.add_const (topological_space (has_nndist environment.implicit_infer_kind)) Type) : @path_connected_space.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (has_nndist.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_73812 (h0 : measurable_space (has_nnnorm linarith.ineq)) (h1 : filter (has_nnnorm linarith.ineq)) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_73813 (h0 : group (with_bot (has_norm (has_norm empty)))) : group.fg (with_bot (has_norm (has_norm empty))) := sorry --non-trivial
lemma new_lemma_73814 (h0 : functor.add_const (add_group (partial_order empty)) empty) : @is_add_cyclic.{0} (partial_order.{0} empty) (@functor.add_const.run.{0 0} (add_group.{0} (partial_order.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_73815 (h0 : ring (linear_ordered_add_comm_group (has_nnnorm to_additive.value_type))) : rank_condition (linear_ordered_add_comm_group (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_73816 (h0 : list (has_norm (has_norm (has_norm (has_norm linarith.ineq))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_73817 (h0 : list (has_inter (option (option (option (option (option (option empty)))))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_73818 (h0 : topological_space (boolean_algebra (has_add (has_neg Type)))) : preirreducible_space (boolean_algebra (has_add (has_neg Type))) := sorry --non-trivial
lemma new_lemma_73819 (h0 : has_mem.mem (measurable_space fun_info) has_emptyc.emptyc) : @monoid.fg.{0} (measurable_space.{0} fun_info) (@finset.pi.empty.{1 0} Type monoid.{0} (measurable_space.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_73820 (h0 : topological_space (has_nndist (group_with_zero name))) : t0_space (has_nndist (group_with_zero name)) := sorry --non-trivial
lemma new_lemma_73821 (h0 : topological_space (add_comm_monoid (finset name))) : normal_space (add_comm_monoid (finset name)) := sorry --non-trivial
lemma new_lemma_73822 (h0 : functor.add_const (filter (finset Type)) (has_add linarith.comp)) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_73823 (h0 : finset (partial_order unsigned)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_73824 (h0 : functor.add_const (topological_space (boolean_algebra Type)) (boolean_algebra name)) : @topological_space.separable_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.{1} Type)) (boolean_algebra.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_73825 (h0 : monoid (has_one (semiring congr_arg_kind))) : monoid.fg (has_one (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_73826 (h0 : topological_space (has_bot (has_add (has_Inf real)))) : normal_space (has_bot (has_add (has_Inf real))) := sorry --non-trivial
lemma new_lemma_73827 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (simple_graph.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (simple_graph.{0} num))  := sorry --non-trivial
lemma new_lemma_73828 (h0 : has_mem.mem (normed_group fun_info) has_emptyc.emptyc) : @is_domain.{0} (normed_group.{0} fun_info) (@finset.pi.empty.{1 0} Type ring.{0} (normed_group.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_73829 (h0 : topological_space (canonically_ordered_monoid (has_Inf (has_Inf real)))) : irreducible_space (canonically_ordered_monoid (has_Inf (has_Inf real))) := sorry --non-trivial
lemma new_lemma_73830 (h0 : group (finset (has_nndist pos))) : is_simple_group (finset (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_73831 (h0 : functor.add_const (topological_space (has_pos_part pos)) Type) : @normal_space.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_pos_part.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_73832 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (with_one.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (with_one.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_73833 (h0 : complete_lattice (add_cancel_monoid (has_add environment.implicit_infer_kind))) : complete_lattice.is_Sup_finite_compact (add_cancel_monoid (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_73834 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (omega_complete_partial_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (omega_complete_partial_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_73835 (h0 : not (complete_lattice (complete_linear_order num) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (complete_linear_order.{0} num) (@classical.by_contradiction'.{1} (complete_lattice.{0} (complete_linear_order.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_73836 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (option.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (option.{0} num))  := sorry --non-trivial
lemma new_lemma_73837 (h0 : ring (with_bot (random_gen (random_gen (random_gen (random_gen num)))))) : strong_rank_condition (with_bot (random_gen (random_gen (random_gen (random_gen num))))) := sorry --non-trivial
lemma new_lemma_73838 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (@id.{2} Type (semiring.{0} empty)) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (@id.{2} Type (semiring.{0} empty)))  := sorry --non-trivial
lemma new_lemma_73839 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @has_exists_mul_of_le.{1} (complete_distrib_lattice.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_comm_monoid.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ordered_comm_monoid.{1}) (complete_distrib_lattice.{1} Type))  := sorry --non-trivial
lemma new_lemma_73840 (h0 : functor.add_const (add_monoid (has_zero environment.implicit_infer_kind)) name) : @add_monoid.fg.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_zero.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_73841 (h0 : functor.add_const (topological_space pos) (option (option (option pos)))) : @irreducible_space.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) (option.{0} (option.{0} (option.{0} pos))) h0)  := sorry --non-trivial
lemma new_lemma_73842 (h0 : has_mem.mem (random_gen unsigned) has_emptyc.emptyc) : @totally_separated_space.{0} (random_gen.{0} unsigned) (@finset.pi.empty.{1 0} Type topological_space.{0} (random_gen.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_73843 (h0 : topological_space (with_one empty)) : path_connected_space (with_one empty) := sorry --non-trivial
lemma new_lemma_73844 (h0 : function.extfun Type ring) : @is_domain.{0} (canonically_linear_ordered_monoid.{0} (option.{0} ennreal)) (@function.extfun_app.{2 1} Type ring.{0} h0 (canonically_linear_ordered_monoid.{0} (option.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_73845 (h0 : group (ring (boolean_algebra (has_add environment.implicit_infer_kind)))) : is_simple_group (ring (boolean_algebra (has_add environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_73846 (h0 : add_group (has_neg ennreal)) : is_add_cyclic (has_neg ennreal) := sorry --non-trivial
lemma new_lemma_73847 (h0 : topological_space (has_bot (finset (has_Inf (has_add pos))))) : t1_space (has_bot (finset (has_Inf (has_add pos)))) := sorry --non-trivial
lemma new_lemma_73848 (h0 : functor.add_const (finset (has_Inf linarith.comp)) (finset pos)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_73849 (h0 : topological_space (with_bot to_additive.value_type)) : totally_disconnected_space (with_bot to_additive.value_type) := sorry --non-trivial
lemma new_lemma_73850 (h0 : functor.comp group has_to_string name) : @group.fg.{0} (has_to_string.{0} name) (@functor.comp.run.{0 0 0} group.{0} has_to_string.{0} name h0)  := sorry --non-trivial
lemma new_lemma_73851 (h0 : topological_space (ordered_comm_ring (comm_semigroup linarith.comp))) : sequential_space (ordered_comm_ring (comm_semigroup linarith.comp)) := sorry --non-trivial
lemma new_lemma_73852 (h0 : prod (mul_zero_class (semiring (semiring empty))) (mul_zero_class (semiring (semiring empty)))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_73853 (h0 : functor.add_const (topological_space auto.case_option) unsigned) : @t0_space.{0} auto.case_option (@functor.add_const.run.{0 0} (topological_space.{0} auto.case_option) unsigned h0)  := sorry --non-trivial
lemma new_lemma_73854 (h0 : filter (has_top (has_norm empty))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_73855 (h0 : functor.add_const (group (free_add_monoid unsigned)) unsigned) : @is_cyclic.{0} (free_add_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (free_add_monoid.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_73856 (h0 : not (function.extfun Type semiring -> false)) : @is_noetherian_ring.{0} (@id.{2} Type empty) (@function.extfun_app.{2 1} Type semiring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type semiring.{0}) h0) (@id.{2} Type empty))  := sorry --non-trivial
lemma new_lemma_73857 (h0 : measurable_space (nondiscrete_normed_field (mul_one_class enat))) (h1 : measure_theory.measure (nondiscrete_normed_field (mul_one_class enat))) : measure_theory.is_finite_measure h1 := sorry --non-trivial
lemma new_lemma_73858 (h0 : group (has_zero (has_nndist (has_add (boolean_algebra Type))))) : group.fg (has_zero (has_nndist (has_add (boolean_algebra Type)))) := sorry --non-trivial
lemma new_lemma_73859 (h0 : group (has_Inf (has_Inf Type))) : normalizer_condition (has_Inf (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_73860 (h0 : topological_space (has_nnnorm to_additive.value_type)) (h1 : preorder (has_nnnorm to_additive.value_type)) : order_closed_topology (has_nnnorm to_additive.value_type) := sorry --non-trivial
lemma new_lemma_73861 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (has_union.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_union.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_73862 (h0 : function.extfun Type (functor.add_const (group (ring pos)))) : @is_cyclic.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (ring.{0} pos)) pos (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (group.{0} (ring.{0} pos))) h0 pos))  := sorry --non-trivial
lemma new_lemma_73863 (h0 : topological_space (normed_comm_ring (comm_group (comm_group ennreal)))) : topological_space.separable_space (normed_comm_ring (comm_group (comm_group ennreal))) := sorry --non-trivial
lemma new_lemma_73864 (h0 : functor.add_const (ordered_add_comm_monoid (pseudo_metric_space pos)) pos) : @archimedean.{0} (pseudo_metric_space.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (pseudo_metric_space.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_73865 (h0 : ring (add_left_cancel_semigroup empty)) : is_principal_ideal_ring (add_left_cancel_semigroup empty) := sorry --non-trivial
lemma new_lemma_73866 (h0 : functor.add_const (list (semigroup Type)) pos) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_73867 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_73868 (h0 : topological_space (plift (semiring (semiring unsigned)))) : topological_space.separable_space (plift (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_73869 (h0 : functor.add_const (list (has_neg Type)) environment.implicit_infer_kind) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_73870 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (has_union.{0} num) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_union.{0} num))  := sorry --non-trivial
lemma new_lemma_73871 (h0 : ring (semi_normed_ring string.iterator_imp)) : strong_rank_condition (semi_normed_ring string.iterator_imp) := sorry --non-trivial
lemma new_lemma_73872 (h0 : not (topological_space (non_assoc_semiring empty) -> false)) : @path_connected_space.{0} (non_assoc_semiring.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (non_assoc_semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_73873 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (comm_ring.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (comm_ring.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_73874 (h0 : functor.add_const (semiring (has_zero linarith.comp)) environment.implicit_infer_kind) : @is_noetherian_ring.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (semiring.{0} (has_zero.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_73875 (h0 : add_group (normed_lattice_add_comm_group (sub_neg_monoid pos))) : is_add_cyclic (normed_lattice_add_comm_group (sub_neg_monoid pos)) := sorry --non-trivial
lemma new_lemma_73876 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (add_comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_73877 (h0 : group (random_gen (has_norm (has_top unsigned)))) : normalizer_condition (random_gen (has_norm (has_top unsigned))) := sorry --non-trivial
lemma new_lemma_73878 (h0 : prod (has_neg_part environment.implicit_infer_kind) (has_neg_part environment.implicit_infer_kind)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_73879 (h0 : add_monoid (semigroup (has_add (has_add name)))) : add_monoid.fg (semigroup (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_73880 (h0 : finset (normed_group (option unsigned))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_73881 (h0 : add_group (topological_space (has_inv (has_nnnorm (denumerable linarith.comp_source))))) : is_add_cyclic (topological_space (has_inv (has_nnnorm (denumerable linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_73882 (h0 : topological_space (measurable_space (semiring linarith.comp))) : totally_separated_space (measurable_space (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_73883 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_73884 (h0 : functor.add_const (complete_lattice (option empty)) (semiring (semiring empty))) : @complete_lattice.is_Sup_finite_compact.{0} (option.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (option.{0} empty)) (semiring.{0} (semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_73885 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : totally_separated_space empty := sorry --non-trivial
lemma new_lemma_73886 (h0 : functor.add_const (ring (has_nndist name)) pos) : @is_principal_ideal_ring.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (has_nndist.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_73887 (h0 : ring (comm_ring char)) : strong_rank_condition (comm_ring char) := sorry --non-trivial
lemma new_lemma_73888 (h3 : topological_space (comm_ring string.iterator_imp)) : t0_space (comm_ring string.iterator_imp) := sorry --non-trivial
lemma new_lemma_73889 (h0 : function.extfun Type ring) : @rank_condition.{0} (ordered_comm_ring.{0} real) (@function.extfun_app.{2 1} Type ring.{0} h0 (ordered_comm_ring.{0} real))  := sorry --non-trivial
lemma new_lemma_73890 (h0 : topological_space (normed_lattice_add_comm_group (has_neg name))) : t1_space (normed_lattice_add_comm_group (has_neg name)) := sorry --non-trivial
lemma new_lemma_73891 (h0 : functor.add_const (function.extfun (Type 1) ring) pos) : @is_principal_ideal_ring.{1} (generalized_boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ring.{1}) pos h0) (generalized_boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_73892 (h0 : group (ordered_comm_ring (comm_semigroup real))) : is_cyclic (ordered_comm_ring (comm_semigroup real)) := sorry --non-trivial
lemma new_lemma_73893 (h0 : functor.add_const Prop (option unsigned)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_73894 (h0 : topological_space (uniform_space (has_nnnorm string.iterator_imp))) : t0_space (uniform_space (has_nnnorm string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_73895 (h0 : group (has_norm (random_gen (has_nnnorm fun_info)))) : group.fg (has_norm (random_gen (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_73896 (h0 : functor.add_const (topological_space (plift num)) num) : @preirreducible_space.{1} (plift.{1} num) (@functor.add_const.run.{1 0} (topological_space.{1} (plift.{1} num)) num h0)  := sorry --non-trivial
lemma new_lemma_73897 (h0 : fin has_zero.zero) : @normal_space.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@matrix.vec_empty.{2} (function.extfun.{3 2} (Type 1) topological_space.{1}) h0) (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_73898 (h0 : function.extfun Type topological_space) : @regular_space.{0} (normed_lattice_add_comm_group.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_lattice_add_comm_group.{0} name))  := sorry --non-trivial
lemma new_lemma_73899 (h0 : fin has_zero.zero) : @unique_factorization_monoid.{1} (comm_semigroup.{1} Type) (@matrix.vec_empty.{1} (cancel_comm_monoid_with_zero.{1} (comm_semigroup.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_73900 (h0 : functor.add_const (finset (semigroup linarith.comp)) (mul_one_class (finset (has_Inf (has_pos_part Type))))) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_73901 (h0 : topological_space (linear_ordered_semiring (has_norm num))) : t0_space (linear_ordered_semiring (has_norm num)) := sorry --non-trivial
lemma new_lemma_73902 (h0 : functor.add_const (topological_space nnreal) congr_arg_kind) : preirreducible_space nnreal := sorry --non-trivial
lemma new_lemma_73903 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (boolean_algebra environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_73904 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (semigroup.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_73905 (h1 : set (mul_one_class enat)) : set.subsingleton h1 := sorry --non-trivial
lemma new_lemma_73906 (h0 : group (generalized_boolean_algebra (has_pos_part linarith.comp))) : normalizer_condition (generalized_boolean_algebra (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_73907 (h0 : list (ring (semi_normed_ring linarith.ineq))) (h1 : ne h0 list.nil) : @rank_condition.{0} (semi_normed_ring.{0} linarith.ineq) (@list.last.{0} (ring.{0} (semi_normed_ring.{0} linarith.ineq)) h0 h1)  := sorry --non-trivial
lemma new_lemma_73908 (h0 : topological_space (dlist (random_gen to_additive.value_type))) : irreducible_space (dlist (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_73909 (h0 : functor.add_const (topological_space (mul_zero_class pos)) pos) : @locally_compact_space.{0} (mul_zero_class.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_73910 (h0 : ring (nondiscrete_normed_field ordering)) : is_domain (nondiscrete_normed_field ordering) := sorry --non-trivial
lemma new_lemma_73911 (h0 : topological_space (has_neg (has_neg (has_neg name)))) : totally_disconnected_space (has_neg (has_neg (has_neg name))) := sorry --non-trivial
lemma new_lemma_73912 (h0 : add_monoid (has_to_string num)) : add_monoid.fg (has_to_string num) := sorry --non-trivial
lemma new_lemma_73913 (h0 : functor.add_const (complete_lattice (canonically_linear_ordered_monoid name)) unsigned) : @is_atomistic.{0} (canonically_linear_ordered_monoid.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (canonically_linear_ordered_monoid.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_73914 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (has_neg_part ennreal)) := sorry --non-trivial
lemma new_lemma_73915 (h3 : has_mem.mem (function.extfun Type) has_emptyc.emptyc) : @is_atomistic.{0} (normed_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@finset.pi.empty.{2 1} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) (function.extfun.{2 1} Type) h3) complete_lattice.{0}) (normed_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_73916 (h0 : ordered_add_comm_monoid (linear_ordered_field (has_neg_part ennreal))) : archimedean (linear_ordered_field (has_neg_part ennreal)) := sorry --non-trivial
lemma new_lemma_73917 (h0 : functor.add_const (add_monoid (has_zero Type)) (has_to_string (has_neg (has_to_string name)))) : @add_monoid.fg.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (add_monoid.{1} (has_zero.{1} Type)) (has_to_string.{0} (has_neg.{0} (has_to_string.{0} name))) h0)  := sorry --non-trivial
lemma new_lemma_73918 (h0 : topological_space (mul_zero_class (finset Type))) : path_connected_space (mul_zero_class (finset Type)) := sorry --non-trivial
lemma new_lemma_73919 (h0 : filter (normed_comm_ring num)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_73920 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (add_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (add_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_73921 (h0 : functor.comp topological_space add_cancel_monoid name) : @sequential_space.{0} (add_cancel_monoid.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} add_cancel_monoid.{0} name h0)  := sorry --non-trivial
lemma new_lemma_73922 (h0 : complete_lattice (denumerable string_imp)) : complete_lattice.is_Sup_finite_compact (denumerable string_imp) := sorry --non-trivial
lemma new_lemma_73923 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (has_bot.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_bot.{0} real))  := sorry --non-trivial
lemma new_lemma_73924 (h0 : ring (canonically_ordered_monoid (has_add real))) : strong_rank_condition (canonically_ordered_monoid (has_add real)) := sorry --non-trivial
lemma new_lemma_73925 (h0 : complete_lattice (measurable_space.dynkin_system (semiring (semiring num)))) : is_atomistic (measurable_space.dynkin_system (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_73926 (h0 : ring (linear_ordered_add_comm_group (random_gen (has_norm to_additive.value_type)))) : is_domain (linear_ordered_add_comm_group (random_gen (has_norm to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_73927 (h0 : functor.add_const (ordered_comm_monoid (normed_comm_ring linarith.comp)) (has_neg linarith.comp)) : @has_exists_mul_of_le.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (normed_comm_ring.{0} linarith.comp)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_73928 (h0 : add_monoid (has_add (has_neg real))) : add_monoid.fg (has_add (has_neg real)) := sorry --non-trivial
lemma new_lemma_73929 (h0 : complete_lattice (finset congr_arg_kind)) : is_compactly_generated (finset congr_arg_kind) := sorry --non-trivial
lemma new_lemma_73930 (h0 : topological_space (free_add_monoid (option (option (option unsigned))))) : irreducible_space (free_add_monoid (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_73931 (h0 : functor.comp (prod (measure_theory.measure_space congr_arg_kind)) measure_theory.measure_space congr_arg_kind) : id_rel (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_73932 (h0 : functor.add_const (function.extfun (Type 1) ring) environment.implicit_infer_kind) : @is_principal_ideal_ring.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ring.{1}) environment.implicit_infer_kind h0) (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_73933 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (random_gen.{0} linarith.comp) (@function.extfun_app.{2 1} Type monoid.{0} h0 (random_gen.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_73934 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (non_assoc_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} h0 (non_assoc_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_73935 (h2 : ring (simple_graph to_additive.value_type)) : strong_rank_condition (simple_graph to_additive.value_type) := sorry --non-trivial
lemma new_lemma_73936 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem complete_lattice)) : @is_compactly_generated.{0} fun_info (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) complete_lattice.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) fun_info)  := sorry --non-trivial
lemma new_lemma_73937 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_emptyc.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_emptyc.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_73938 (h0 : functor.add_const (topological_space (comm_group environment.implicit_infer_kind)) name) : @locally_compact_space.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_73939 (h1 : not (uniform_space (normed_field string_imp) -> false)) : @complete_space.{0} (normed_field.{0} string_imp) (@classical.by_contradiction'.{1} (uniform_space.{0} (normed_field.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_73940 (h0 : topological_space (has_Inf (has_add pos))) : regular_space (has_Inf (has_add pos)) := sorry --non-trivial
lemma new_lemma_73941 (h0 : functor.comp topological_space add_comm_monoid Type) : @topological_space.separable_space.{1} (add_comm_monoid.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} add_comm_monoid.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_73942 (h0 : uniform_space (with_one (random_gen (random_gen (has_top linarith.ineq))))) : separated_space (with_one (random_gen (random_gen (has_top linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_73943 (h0 : topological_space (has_inv (has_ssubset (has_ssubset fun_info)))) : irreducible_space (has_inv (has_ssubset (has_ssubset fun_info))) := sorry --non-trivial
lemma new_lemma_73944 (h1 : has_le (nondiscrete_normed_field linarith.ineq)) (h2 : nondiscrete_normed_field linarith.ineq) : is_min h2 := sorry --non-trivial
lemma new_lemma_73945 (h0 : filter (has_nndist (option unsigned))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_73946 (h0 : topological_space (boolean_algebra (has_to_string (has_to_string (has_to_string name))))) : preconnected_space (boolean_algebra (has_to_string (has_to_string (has_to_string name)))) := sorry --non-trivial
lemma new_lemma_73947 (h0 : topological_space (has_zero (has_to_string name))) : path_connected_space (has_zero (has_to_string name)) := sorry --non-trivial
lemma new_lemma_73948 (h0 : complete_lattice (has_neg_part (finset name))) : complete_lattice.is_Sup_finite_compact (has_neg_part (finset name)) := sorry --non-trivial
lemma new_lemma_73949 (h0 : topological_space (has_compl char)) (h1 : has_sub (has_compl char)) : has_continuous_sub (has_compl char) := sorry --non-trivial
lemma new_lemma_73950 (h0 : cancel_comm_monoid_with_zero (ring (has_neg name))) : unique_factorization_monoid (ring (has_neg name)) := sorry --non-trivial
lemma new_lemma_73951 (h0 : preorder (has_norm num)) (h1 : function.extfun Type topological_space) : @Inf_convergence_class.{0} (has_norm.{0} num) h0 (@function.extfun_app.{2 1} Type topological_space.{0} h1 (has_norm.{0} num))  := sorry --non-trivial
lemma new_lemma_73952 (h0 : list (monoid pos)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_73953 (h0 : functor.add_const (topological_space (cancel_monoid linarith.comp)) (boolean_algebra Type)) : @topological_space.separable_space.{0} (cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (cancel_monoid.{0} linarith.comp)) (boolean_algebra.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_73954 (h0 : has_norm (semiring empty) -> has_norm (semiring empty) -> Prop) : is_symm (has_norm (semiring empty)) h0 := sorry --non-trivial
lemma new_lemma_73955 (h0 : function.extfun Type topological_space) : @t1_space.{0} (ordered_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_73956 (h0 : monoid (has_add (has_add linarith.comp))) : monoid.fg (has_add (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_73957 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_73958 (h0 : topological_space (ring linarith.comp)) : topological_space.separable_space (ring linarith.comp) := sorry --non-trivial
lemma new_lemma_73959 (h0 : functor.add_const (finset (has_nndist environment.implicit_infer_kind)) pos) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_73960 (h0 : ring (ring (has_nndist name))) : is_principal_ideal_ring (ring (has_nndist name)) := sorry --non-trivial
lemma new_lemma_73961 (h0 : function.extfun Type ring) : @rank_condition.{0} (left_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (left_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_73962 (h0 : functor.add_const (group (left_cancel_monoid empty)) (semiring num)) : @normalizer_condition.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (left_cancel_monoid.{0} empty)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_73963 (h0 : not (topological_space (option empty) -> false)) : @totally_separated_space.{0} (option.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (option.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_73964 (h0 : topological_space (has_star congr_arg_kind)) : totally_disconnected_space (has_star congr_arg_kind) := sorry --non-trivial
lemma new_lemma_73965 (h0 : ordered_add_comm_monoid (canonically_ordered_comm_semiring (finset pos))) : archimedean (canonically_ordered_comm_semiring (finset pos)) := sorry --non-trivial
lemma new_lemma_73966 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (add_cancel_monoid num)) := sorry --non-trivial
lemma new_lemma_73967 (h0 : complete_lattice (dlist (random_gen (has_top string_imp)))) : is_compactly_generated (dlist (random_gen (has_top string_imp))) := sorry --non-trivial
lemma new_lemma_73968 (h0 : functor.add_const (topological_space (sub_neg_monoid linarith.comp)) (has_add linarith.comp)) : @preconnected_space.{0} (sub_neg_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (sub_neg_monoid.{0} linarith.comp)) (has_add.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_73969 (h0 : function.extfun Type ring) : @is_domain.{0} (has_nndist.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_nndist.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_73970 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (linear_ordered_add_comm_group.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_add_comm_group.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_73971 (h0 : functor.add_const (topological_space (has_to_string environment.implicit_infer_kind)) Type) : @irreducible_space.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (has_to_string.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_73972 (h0 : complete_lattice (has_neg unsigned)) : is_compactly_generated (has_neg unsigned) := sorry --non-trivial
lemma new_lemma_73973 (h1 : topological_space (topological_space (has_nnnorm char))) : t0_space (topological_space (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_73974 (h0 : ring (has_to_string (has_Inf (boolean_algebra.core Type)))) : is_domain (has_to_string (has_Inf (boolean_algebra.core Type))) := sorry --non-trivial
lemma new_lemma_73975 (h0 : add_group (semi_normed_comm_ring (mul_one_class fun_info))) : is_add_cyclic (semi_normed_comm_ring (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_73976 (h0 : functor.add_const (filter (normed_comm_ring Type)) name) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_73977 (h0 : functor.add_const (semiring (has_Inf pos)) Type) : @is_noetherian_ring.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 1} (semiring.{0} (has_Inf.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_73978 (h0 : topological_space (complete_distrib_lattice name)) : regular_space (complete_distrib_lattice name) := sorry --non-trivial
lemma new_lemma_73979 (h0 : topological_space (mul_zero_class (complete_distrib_lattice ennreal))) : sequential_space (mul_zero_class (complete_distrib_lattice ennreal)) := sorry --non-trivial
lemma new_lemma_73980 (h0 : not (function.extfun Type group -> false)) : @group.fg.{0} (has_inv.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (has_inv.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_73981 (h0 : topological_space (complete_distrib_lattice name)) : topological_space.separable_space (complete_distrib_lattice name) := sorry --non-trivial
lemma new_lemma_73982 (h0 : boolean_algebra name -> Type -> Type) : left_commutative h0 := sorry --non-trivial
lemma new_lemma_73983 (h0 : functor.add_const (topological_space (has_Inf pos)) Type) : @loc_path_connected_space.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_Inf.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_73984 (h0 : not (ordered_comm_monoid (denumerable char) -> false)) : @has_exists_mul_of_le.{0} (denumerable.{0} char) (@classical.by_contradiction'.{1} (ordered_comm_monoid.{0} (denumerable.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_73985 (h0 : topological_space (has_norm (random_gen (random_gen num)))) : discrete_topology (has_norm (random_gen (random_gen num))) := sorry --non-trivial
lemma new_lemma_73986 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} (has_norm.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (has_norm.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_73987 (h0 : complete_lattice (has_to_string (has_to_string Type))) : is_atomistic (has_to_string (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_73988 (h0 : functor.add_const Prop (finset (option ennreal))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_73989 (h0 : topological_space (semi_normed_comm_ring (has_ssubset string_imp))) : t0_space (semi_normed_comm_ring (has_ssubset string_imp)) := sorry --non-trivial
lemma new_lemma_73990 (h0 : topological_space (with_one (has_ssubset to_additive.value_type))) : t0_space (with_one (has_ssubset to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_73991 (h1 : filter (with_zero (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm fun_info))))))) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_73992 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (semigroup.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_73993 (h0 : group (as_linear_order linarith.ineq)) : is_cyclic (as_linear_order linarith.ineq) := sorry --non-trivial
lemma new_lemma_73994 (h0 : filter (has_norm (comm_ring fun_info))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_73995 (h1 : add_group (mv_power_series linarith.comp_source congr_arg_kind)) : is_add_cyclic (mv_power_series linarith.comp_source congr_arg_kind) := sorry --non-trivial
lemma new_lemma_73996 (h0 : functor.add_const Prop (complete_distrib_lattice ennreal)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_73997 (h0 : topological_space (has_to_string congr_arg_kind)) : preirreducible_space (has_to_string congr_arg_kind) := sorry --non-trivial
lemma new_lemma_73998 (h0 : group (with_one char)) : group.fg (with_one char) := sorry --non-trivial
lemma new_lemma_73999 (h0 : ordered_add_comm_monoid (generalized_boolean_algebra empty)) : archimedean (generalized_boolean_algebra empty) := sorry --non-trivial
lemma new_lemma_74000 (h0 : ring (add_cancel_monoid (option ennreal))) : is_principal_ideal_ring (add_cancel_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_74001 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (linear_ordered_cancel_comm_monoid congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_74002 (h0 : topological_space (has_ssubset (mul_one_class to_additive.value_type))) : t0_space (has_ssubset (mul_one_class to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_74003 (h0 : uniform_space (has_zero (finset (option (has_nndist name))))) : complete_space (has_zero (finset (option (has_nndist name)))) := sorry --non-trivial
lemma new_lemma_74004 (h0 : ring (add_right_cancel_monoid (semiring congr_arg_kind))) : rank_condition (add_right_cancel_monoid (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_74005 (h0 : complete_lattice (canonically_ordered_monoid linarith.comp)) : is_compactly_generated (canonically_ordered_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_74006 (h0 : complete_lattice (add_monoid (has_append linarith.ineq))) : complete_lattice.is_Sup_finite_compact (add_monoid (has_append linarith.ineq)) := sorry --non-trivial
lemma new_lemma_74007 (h0 : ordered_comm_monoid (has_pos_part (ring (ring (ring (ring Type)))))) : has_exists_mul_of_le (has_pos_part (ring (ring (ring (ring Type))))) := sorry --non-trivial
lemma new_lemma_74008 (h0 : filter (comm_ring fun_info)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_74009 (h0 : complete_lattice (linear_ordered_field (option (option (option ennreal))))) : complete_lattice.is_Sup_finite_compact (linear_ordered_field (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_74010 (h0 : ring (ordered_comm_ring (has_neg (has_neg name)))) : strong_rank_condition (ordered_comm_ring (has_neg (has_neg name))) := sorry --non-trivial
lemma new_lemma_74011 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (mul_zero_class.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (mul_zero_class.{0} num))  := sorry --non-trivial
lemma new_lemma_74012 (h0 : topological_space (filter (option unsigned))) : preirreducible_space (filter (option unsigned)) := sorry --non-trivial
lemma new_lemma_74013 (h0 : functor.add_const (uniform_space (normed_comm_ring Type)) Type) : @separated_space.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 1} (uniform_space.{1} (normed_comm_ring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_74014 (h0 : has_mem.mem (random_gen to_additive.value_type) has_emptyc.emptyc) : @separated_space.{0} (random_gen.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type uniform_space.{0} (random_gen.{0} to_additive.value_type) h0)  := sorry --non-trivial
lemma new_lemma_74015 (h0 : topological_space (has_norm (has_top congr_arg_kind))) : t0_space (has_norm (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_74016 (h0 : topological_space (ordered_comm_monoid (has_neg linarith.comp))) : preirreducible_space (ordered_comm_monoid (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_74017 (h0 : semiring (measurable_space (semiring empty))) : is_noetherian_ring (measurable_space (semiring empty)) := sorry --non-trivial
lemma new_lemma_74018 (h0 : topological_space (has_add (has_pos_part (finset (has_add Type))))) : t1_space (has_add (has_pos_part (finset (has_add Type)))) := sorry --non-trivial
lemma new_lemma_74019 (h0 : ring (with_one (has_top (has_top (has_top congr_arg_kind))))) : strong_rank_condition (with_one (has_top (has_top (has_top congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_74020 (h0 : group (with_bot (has_inv linarith.comp_source))) : is_cyclic (with_bot (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_74021 (h0 : topological_space (generalized_boolean_algebra (has_neg name))) : irreducible_space (generalized_boolean_algebra (has_neg name)) := sorry --non-trivial
lemma new_lemma_74022 (h0 : topological_space (simple_graph name)) : preirreducible_space (simple_graph name) := sorry --non-trivial
lemma new_lemma_74023 (h0 : functor.add_const (add_group (simple_graph pos)) linarith.comp) : @is_add_cyclic.{0} (simple_graph.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (simple_graph.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_74024 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_emptyc.{0} fun_info) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_emptyc.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_74025 (h0 : topological_space (has_sub empty)) : totally_separated_space (has_sub empty) := sorry --non-trivial
lemma new_lemma_74026 (h0 : topological_space (has_to_string (has_Inf Type))) : t0_space (has_to_string (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_74027 (h0 : complete_linear_order empty -> complete_linear_order empty -> Prop) : is_strict_order (complete_linear_order empty) h0 := sorry --non-trivial
lemma new_lemma_74028 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_74029 (h0 : topological_space (has_zero (boolean_algebra (has_neg_part linarith.comp)))) : topological_space.separable_space (has_zero (boolean_algebra (has_neg_part linarith.comp))) := sorry --non-trivial
lemma new_lemma_74030 (h0 : functor.add_const (function.extfun (Type 1) topological_space) (has_add (has_neg name))) : @sequential_space.{1} Type (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) (has_add.{0} (has_neg.{0} name)) h0) Type)  := sorry --non-trivial
lemma new_lemma_74031 (h1 : ring (add_cancel_comm_monoid linarith.comp_source)) : is_domain (add_cancel_comm_monoid linarith.comp_source) := sorry --non-trivial
lemma new_lemma_74032 (h0 : functor.add_const (topological_space (generalized_boolean_algebra linarith.comp)) name) : @loc_path_connected_space.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_74033 (h0 : functor.add_const (uniform_space (boolean_algebra linarith.comp)) (has_nndist name)) : @complete_space.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (boolean_algebra.{0} linarith.comp)) (has_nndist.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_74034 (h0 : topological_space (has_bot (has_add (has_add (has_Inf (has_add pos)))))) : preconnected_space (has_bot (has_add (has_add (has_Inf (has_add pos))))) := sorry --non-trivial
lemma new_lemma_74035 (h0 : finset (add_group (semiring (semiring empty)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_74036 (h0 : ring (has_one linarith.comp)) : rank_condition (has_one linarith.comp) := sorry --non-trivial
lemma new_lemma_74037 (h0 : cancel_comm_monoid_with_zero (mul_zero_class (has_add environment.implicit_infer_kind))) : unique_factorization_monoid (mul_zero_class (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_74038 (h0 : functor.add_const (ring (has_star num)) empty) : @is_principal_ideal_ring.{0} (has_star.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (has_star.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_74039 (h0 : group (add_right_cancel_monoid (semiring (semiring unsigned)))) : group.fg (add_right_cancel_monoid (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_74040 (h0 : complete_lattice (has_edist (option (option unsigned)))) : is_atomistic (has_edist (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_74041 (h0 : functor.add_const (topological_space (has_star congr_arg_kind)) empty) : @normal_space.{0} (has_star.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_74042 (h1 : topological_space string.iterator_imp) (h2 : preorder string.iterator_imp) : order_closed_topology string.iterator_imp := sorry --non-trivial
lemma new_lemma_74043 (h0 : functor.add_const (uniform_space (has_to_string linarith.comp)) environment.implicit_infer_kind) : @complete_space.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_to_string.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_74044 (h0 : ring (complete_semilattice_Sup (semiring unsigned))) : is_domain (complete_semilattice_Sup (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_74045 (h0 : has_mem.mem (complete_semilattice_Sup linarith.ineq) has_emptyc.emptyc) : @normalizer_condition.{0} (complete_semilattice_Sup.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type group.{0} (complete_semilattice_Sup.{0} linarith.ineq) h0)  := sorry --non-trivial
lemma new_lemma_74046 (h0 : ring (linear_ordered_comm_monoid_with_zero empty)) : rank_condition (linear_ordered_comm_monoid_with_zero empty) := sorry --non-trivial
lemma new_lemma_74047 (h0 : functor.add_const (cancel_comm_monoid_with_zero (bin_tree congr_arg_kind)) congr_arg_kind) : @unique_factorization_monoid.{0} (bin_tree.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (bin_tree.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_74048 (h0 : functor.add_const (topological_space (add_comm_monoid unsigned)) linarith.comp) : @loc_path_connected_space.{0} (add_comm_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_74049 (h0 : measurable_space (has_ssubset string.iterator_imp)) (h1 : has_sup (has_ssubset string.iterator_imp)) : has_measurable_sup₂ (has_ssubset string.iterator_imp) := sorry --non-trivial
lemma new_lemma_74050 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (distrib_lattice num)) := sorry --non-trivial
lemma new_lemma_74051 (h0 : ulower pnat) (h1 : pnat -> Prop) : pnat.coprime (ulower.up h0) (classical.epsilon h1) := sorry --non-trivial
lemma new_lemma_74052 (h0 : topological_space (random_gen (mul_one_class (mul_one_class (random_gen reducibility_hints))))) : path_connected_space (random_gen (mul_one_class (mul_one_class (random_gen reducibility_hints)))) := sorry --non-trivial
lemma new_lemma_74053 (h0 : functor.add_const (topological_space (comm_semigroup real)) name) : @t0_space.{0} (comm_semigroup.{0} real) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_semigroup.{0} real)) name h0)  := sorry --non-trivial
lemma new_lemma_74054 (h0 : uniform_space (complete_distrib_lattice (has_add pos))) : separated_space (complete_distrib_lattice (has_add pos)) := sorry --non-trivial
lemma new_lemma_74055 (h0 : functor.add_const (function.extfun Type topological_space) name) : @topological_space.separable_space.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_74056 (h0 : not (topological_space (uniform_space fun_info) -> false)) : @totally_disconnected_space.{0} (uniform_space.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (uniform_space.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_74057 (h0 : topological_space (linear_ordered_comm_ring (semiring (semiring congr_arg_kind)))) : t1_space (linear_ordered_comm_ring (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_74058 (h0 : group (option num)) : is_cyclic (option num) := sorry --non-trivial
lemma new_lemma_74059 (h0 : ring (encodable (has_nnnorm linarith.comp_source))) : rank_condition (encodable (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_74060 (h0 : functor.add_const (uniform_space (has_pos_part pos)) Type) : @separated_space.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 1} (uniform_space.{0} (has_pos_part.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_74061 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @regular_space.{0} (has_Inf.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (has_Inf.{0} name))  := sorry --non-trivial
lemma new_lemma_74062 (h0 : topological_space (comm_group (has_to_string (has_add (has_to_string (has_add ennreal)))))) : totally_separated_space (comm_group (has_to_string (has_add (has_to_string (has_add ennreal))))) := sorry --non-trivial
lemma new_lemma_74063 (h0 : functor.add_const (monoid (add_cancel_monoid Type)) environment.implicit_infer_kind) : @monoid.fg.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (monoid.{1} (add_cancel_monoid.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_74064 (h0 : topological_space (random_gen (has_nnnorm to_additive.value_type))) : totally_disconnected_space (random_gen (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_74065 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (free_add_monoid.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (free_add_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_74066 (h0 : function.extfun nat fin) : @is_noetherian_ring.{1} (canonically_ordered_comm_semiring.{1} Type) (@function.extfun_app.{3 2} (Type 1) semiring.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) (@matrix.vec_empty.{2} (function.extfun.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1))) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) semiring.{1}) (canonically_ordered_comm_semiring.{1} Type))  := sorry --non-trivial
lemma new_lemma_74067 (h0 : uniform_space (cancel_monoid name)) : separated_space (cancel_monoid name) := sorry --non-trivial
lemma new_lemma_74068 (h1 : has_lt (has_ssubset environment.projection_info)) : no_max_order (has_ssubset environment.projection_info) := sorry --non-trivial
lemma new_lemma_74069 (h0 : functor.add_const (function.extfun (Type 1) group) ennreal) : @is_simple_group.{1} (has_zero.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) group.{1}) ennreal h0) (has_zero.{1} Type))  := sorry --non-trivial
lemma new_lemma_74070 (h0 : ring (linear_order (option (option unsigned)))) : is_principal_ideal_ring (linear_order (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_74071 (h0 : not (ring (mul_zero_class empty) -> false)) : @is_domain.{0} (mul_zero_class.{0} empty) (@classical.by_contradiction'.{1} (ring.{0} (mul_zero_class.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_74072 (h0 : ring (has_zero num)) : rank_condition (has_zero num) := sorry --non-trivial
lemma new_lemma_74073 (h0 : topological_space (has_inter (option (option (option unsigned))))) : t0_space (has_inter (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_74074 (h0 : uniform_space (has_zero (has_add (normed_comm_ring Type)))) : separated_space (has_zero (has_add (normed_comm_ring Type))) := sorry --non-trivial
lemma new_lemma_74075 (h0 : not (complete_lattice (distrib_lattice linarith.ineq) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (distrib_lattice.{0} linarith.ineq) (@classical.by_contradiction'.{1} (complete_lattice.{0} (distrib_lattice.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_74076 (h0 : function.extfun Type group) : @normalizer_condition.{0} (add_cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (add_cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_74077 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (ordered_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_74078 (h0 : function.extfun Type (functor.add_const (topological_space pos))) : @preconnected_space.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) pos (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} pos)) h0 pos))  := sorry --non-trivial
lemma new_lemma_74079 (h0 : not (topological_space (has_nnnorm fun_info) -> false)) : @t0_space.{0} (has_nnnorm.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (has_nnnorm.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_74080 (h0 : complete_lattice (add_comm_semigroup linarith.ineq)) : complete_lattice.is_Sup_finite_compact (add_comm_semigroup linarith.ineq) := sorry --non-trivial
lemma new_lemma_74081 (h0 : topological_space (boolean_algebra (has_add unsigned))) : sequential_space (boolean_algebra (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_74082 (h0 : functor.add_const (function.extfun (Type -> Type) (function.extfun Type)) empty) : @is_compactly_generated.{0} (ordered_ring.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ordered_ring.{0} unsigned)) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (complete_lattice.{0} (ordered_ring.{0} unsigned))) (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@functor.add_const.run.{1 0} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) empty h0) (functor.add_const.{0 0} (complete_lattice.{0} (ordered_ring.{0} unsigned)))) num))  := sorry --non-trivial
lemma new_lemma_74083 (h0 : list (pseudo_metric_space num)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_74084 (h0 : functor.add_const (uniform_space (normed_comm_ring unsigned)) (option (option (option empty)))) : @separated_space.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 0} (uniform_space.{0} (normed_comm_ring.{0} unsigned)) (option.{0} (option.{0} (option.{0} empty))) h0)  := sorry --non-trivial
lemma new_lemma_74085 (h0 : group (mul_zero_class ennreal)) : normalizer_condition (mul_zero_class ennreal) := sorry --non-trivial
lemma new_lemma_74086 (h0 : fin has_zero.zero) : @rank_condition.{0} (sub_neg_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (ring.{0} (sub_neg_monoid.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_74087 (h0 : uniform_space (metric_space unsigned)) : separated_space (metric_space unsigned) := sorry --non-trivial
lemma new_lemma_74088 (h0 : functor.add_const (topological_space (add_cancel_monoid name)) (normed_comm_ring Type)) : @topological_space.separable_space.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (add_cancel_monoid.{0} name)) (normed_comm_ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_74089 (h0 : ring (denumerable (has_nnnorm linarith.ineq))) : strong_rank_condition (denumerable (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_74090 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (semi_normed_comm_ring linarith.ineq)) := sorry --non-trivial
lemma new_lemma_74091 (h0 : group (monoid (option pos))) : is_simple_group (monoid (option pos)) := sorry --non-trivial
lemma new_lemma_74092 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (normed_comm_ring ennreal)) := sorry --non-trivial
lemma new_lemma_74093 (h0 : list (linear_ordered_comm_ring congr_arg_kind)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_74094 (h0 : topological_space (canonically_ordered_comm_semiring (finset (finset linarith.comp)))) : t0_space (canonically_ordered_comm_semiring (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_74095 (h0 : functor.add_const (ordered_comm_monoid (boolean_algebra name)) Type) : @has_exists_mul_of_le.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (boolean_algebra.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_74096 (h0 : topological_space (add_group empty)) : irreducible_space (add_group empty) := sorry --non-trivial
lemma new_lemma_74097 (h0 : functor.add_const (topological_space (boolean_algebra.core pos)) (has_to_string linarith.comp)) : @preconnected_space.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} pos)) (has_to_string.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_74098 (h0 : complete_lattice (has_union (has_top congr_arg_kind))) : is_compactly_generated (has_union (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_74099 (h0 : has_le (add_comm_semigroup fun_info)) : no_top_order (add_comm_semigroup fun_info) := sorry --non-trivial
lemma new_lemma_74100 (h0 : topological_space (has_top linarith.ineq)) : t0_space (has_top linarith.ineq) := sorry --non-trivial
lemma new_lemma_74101 (h0 : functor.add_const (topological_space (left_cancel_monoid empty)) congr_arg_kind) : @path_connected_space.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_74102 (h0 : topological_space (has_to_string (cancel_monoid name))) : locally_compact_space (has_to_string (cancel_monoid name)) := sorry --non-trivial
lemma new_lemma_74103 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (ring ennreal)) := sorry --non-trivial
lemma new_lemma_74104 (h0 : functor.add_const (cancel_comm_monoid_with_zero (partial_order congr_arg_kind)) unsigned) : @unique_factorization_monoid.{0} (partial_order.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (partial_order.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_74105 (h0 : ring (comm_group unsigned)) : rank_condition (comm_group unsigned) := sorry --non-trivial
lemma new_lemma_74106 (h0 : functor.add_const (topological_space pos) pos) : @regular_space.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) pos h0)  := sorry --non-trivial
lemma new_lemma_74107 (h0 : functor.add_const (topological_space (has_neg_part Type)) Type) : @regular_space.{1} (has_neg_part.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_neg_part.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_74108 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (monoid_with_zero.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (monoid_with_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_74109 (h0 : not (uniform_space (linear_ordered_comm_group_with_zero to_additive.value_type) -> false)) : @complete_space.{0} (linear_ordered_comm_group_with_zero.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (uniform_space.{0} (linear_ordered_comm_group_with_zero.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_74110 (h0 : complete_lattice (has_dist num)) : is_atomistic (has_dist num) := sorry --non-trivial
lemma new_lemma_74111 (h0 : topological_space (add_right_cancel_monoid (has_top num))) : topological_space.separable_space (add_right_cancel_monoid (has_top num)) := sorry --non-trivial
lemma new_lemma_74112 (h0 : group (distrib_lattice (random_gen to_additive.value_type))) : normalizer_condition (distrib_lattice (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_74113 (h0 : functor.add_const (topological_space (semigroup pos)) name) : @t1_space.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_74114 (h1 : linarith.comp_source -> linarith.comp_source) (h2 : linarith.comp_source) (h3 : function.periodic_pts h1 h2 -> topological_space (comm_ring to_additive.value_type)) : @totally_separated_space.{0} (comm_ring.{0} to_additive.value_type) (@infi.{0 0} (topological_space.{0} (comm_ring.{0} to_additive.value_type)) (@conditionally_complete_lattice.to_has_Inf.{0} (topological_space.{0} (comm_ring.{0} to_additive.value_type)) (@complete_lattice.to_conditionally_complete_lattice.{0} (topological_space.{0} (comm_ring.{0} to_additive.value_type)) (@topological_space.complete_lattice.{0} (comm_ring.{0} to_additive.value_type)))) (@function.periodic_pts.{0} linarith.comp_source h1 h2) h3)  := sorry --non-trivial
lemma new_lemma_74115 (h0 : functor.add_const (ordered_comm_monoid (add_group linarith.comp)) environment.implicit_infer_kind) : @has_exists_mul_of_le.{0} (add_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (add_group.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_74116 (h0 : group (ordered_cancel_add_comm_monoid (semiring (semiring num)))) : normalizer_condition (ordered_cancel_add_comm_monoid (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_74117 (h0 : not (complete_lattice (has_div reducibility_hints) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_div.{0} reducibility_hints) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_div.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_74118 (h0 : complete_lattice (with_one std_gen)) : is_compactly_generated (with_one std_gen) := sorry --non-trivial
lemma new_lemma_74119 (h0 : topological_space (has_to_string (has_to_string (finset (has_to_string unsigned))))) : irreducible_space (has_to_string (has_to_string (finset (has_to_string unsigned)))) := sorry --non-trivial
lemma new_lemma_74120 (h0 : not (complete_lattice (normed_group linarith.comp_source) -> false)) : @is_atomistic.{0} (normed_group.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (complete_lattice.{0} (normed_group.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_74121 (h0 : filter (has_to_string ennreal)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_74122 (h0 : topological_space (normed_linear_ordered_group num)) : totally_separated_space (normed_linear_ordered_group num) := sorry --non-trivial
lemma new_lemma_74123 (h0 : add_monoid (pseudo_metric_space empty)) : add_monoid.fg (pseudo_metric_space empty) := sorry --non-trivial
lemma new_lemma_74124 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (measurable_space.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measurable_space.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_74125 (h0 : functor.add_const (ordered_add_comm_monoid (semigroup linarith.comp)) (has_neg environment.implicit_infer_kind)) : @archimedean.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (semigroup.{0} linarith.comp)) (has_neg.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_74126 (h0 : topological_space (has_emptyc (add_comm_semigroup enat))) : path_connected_space (has_emptyc (add_comm_semigroup enat)) := sorry --non-trivial
lemma new_lemma_74127 (h2 : ring (add_comm_semigroup char)) : strong_rank_condition (add_comm_semigroup char) := sorry --non-trivial
lemma new_lemma_74128 (h0 : functor.add_const (function.extfun Type ring) (has_Inf pos)) : @strong_rank_condition.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) (has_Inf.{0} pos) h0) (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_74129 (h0 : topological_space (add_semigroup unsigned)) : irreducible_space (add_semigroup unsigned) := sorry --non-trivial
lemma new_lemma_74130 (h0 : semiring (uniform_space (random_gen to_additive.value_type))) (h1 : uniform_space (random_gen to_additive.value_type)) : odd h1 := sorry --non-trivial
lemma new_lemma_74131 (h0 : topological_space (canonically_ordered_monoid (sub_neg_monoid (has_bot pos)))) : path_connected_space (canonically_ordered_monoid (sub_neg_monoid (has_bot pos))) := sorry --non-trivial
lemma new_lemma_74132 (h0 : ring (normed_group (random_gen (random_gen (random_gen fun_info))))) : strong_rank_condition (normed_group (random_gen (random_gen (random_gen fun_info)))) := sorry --non-trivial
lemma new_lemma_74133 (h0 : functor.add_const (topological_space (simple_graph linarith.comp)) pos) : @topological_space.separable_space.{0} (simple_graph.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (simple_graph.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_74134 (h0 : topological_space (has_norm (semiring (semiring (semiring linarith.comp))))) : discrete_topology (has_norm (semiring (semiring (semiring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_74135 (h0 : functor.add_const (ordered_comm_monoid (has_to_string environment.implicit_infer_kind)) linarith.comp) : @has_exists_mul_of_le.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_to_string.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_74136 (h0 : not (group (denumerable (has_nnnorm fun_info)) -> false)) : @is_cyclic.{0} (denumerable.{0} (has_nnnorm.{0} fun_info)) (@classical.by_contradiction'.{1} (group.{0} (denumerable.{0} (has_nnnorm.{0} fun_info))) h0)  := sorry --non-trivial
lemma new_lemma_74137 (h0 : not (ring (has_emptyc linarith.comp_source) -> false)) : @strong_rank_condition.{0} (has_emptyc.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (has_emptyc.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_74138 (h0 : topological_space (has_to_string (finset (has_add Type)))) : sequential_space (has_to_string (finset (has_add Type))) := sorry --non-trivial
lemma new_lemma_74139 (h0 : ring (has_star congr_arg_kind)) : is_domain (has_star congr_arg_kind) := sorry --non-trivial
lemma new_lemma_74140 (h0 : list (topological_space (distrib_lattice string_imp))) : @t0_space.{0} (distrib_lattice.{0} string_imp) (@list.head.{0} (topological_space.{0} (distrib_lattice.{0} string_imp)) (@inhabited_topological_space.{0} (distrib_lattice.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_74141 (h0 : semiring (normed_linear_ordered_group (semiring empty))) : is_noetherian_ring (normed_linear_ordered_group (semiring empty)) := sorry --non-trivial
lemma new_lemma_74142 (h0 : functor.add_const (topological_space (cancel_monoid unsigned)) Type) : @path_connected_space.{0} (cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (cancel_monoid.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_74143 (h0 : add_monoid (random_gen (linear_ordered_semiring (has_top linarith.comp)))) : add_monoid.fg (random_gen (linear_ordered_semiring (has_top linarith.comp))) := sorry --non-trivial
lemma new_lemma_74144 (h0 : complete_lattice (normed_group (has_top linarith.comp_source))) : complete_lattice.is_Sup_finite_compact (normed_group (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_74145 (h0 : function.extfun Type ring) : @is_domain.{0} (finset.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (finset.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_74146 (h0 : ring (measurable_space.dynkin_system congr_arg_kind)) : is_domain (measurable_space.dynkin_system congr_arg_kind) := sorry --non-trivial
lemma new_lemma_74147 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (monoid.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_74148 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @totally_separated_space.{0} (semiring.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) topological_space.{0}) (semiring.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_74149 (h0 : function.extfun Type (functor.add_const (complete_lattice (has_Sup unsigned)))) : @is_compactly_generated.{0} (has_Sup.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_Sup.{0} unsigned)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (complete_lattice.{0} (has_Sup.{0} unsigned))) h0 empty))  := sorry --non-trivial
lemma new_lemma_74150 (h0 : fin has_zero.zero) : @t0_space.{0} (normed_lattice_add_comm_group.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (normed_lattice_add_comm_group.{0} real))  := sorry --non-trivial
lemma new_lemma_74151 (h0 : cancel_comm_monoid_with_zero (has_sub (has_one (semiring empty)))) : unique_factorization_monoid (has_sub (has_one (semiring empty))) := sorry --non-trivial
lemma new_lemma_74152 (h0 : add_group (boolean_algebra.core (has_add (has_add Type)))) : is_add_cyclic (boolean_algebra.core (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_74153 (h0 : not (function.extfun Type ring -> false)) : @rank_condition.{0} (measurable_space.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (measurable_space.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_74154 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (has_nndist.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_nndist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_74155 (h0 : functor.add_const (function.extfun (Type 1) monoid) unsigned) : @monoid.fg.{1} (mul_zero_class.{1} Type) (@function.extfun_app.{3 2} (Type 1) monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) monoid.{1}) unsigned h0) (mul_zero_class.{1} Type))  := sorry --non-trivial
lemma new_lemma_74156 (h0 : topological_space (normed_group (has_norm linarith.ineq))) : totally_disconnected_space (normed_group (has_norm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_74157 (h0 : semiring (semigroup (has_neg linarith.comp))) : is_noetherian_ring (semigroup (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_74158 (h0 : topological_space (measurable_space.dynkin_system (has_top (has_top empty)))) : path_connected_space (measurable_space.dynkin_system (has_top (has_top empty))) := sorry --non-trivial
lemma new_lemma_74159 (h0 : not (function.extfun Type complete_lattice -> false)) : is_atomistic (measurable_space num) := sorry --non-trivial
lemma new_lemma_74160 (h0 : fin has_zero.zero) : @regular_space.{0} (sub_neg_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (sub_neg_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_74161 (h0 : list (semigroup (comm_group pos))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_74162 (h0 : function.extfun (Type 1) (functor.add_const (topological_space pos))) : @totally_separated_space.{0} pos (@functor.add_const.run.{0 1} (topological_space.{0} pos) Type (@function.extfun_app.{3 1} (Type 1) (functor.add_const.{0 1} (topological_space.{0} pos)) h0 Type))  := sorry --non-trivial
lemma new_lemma_74163 (h0 : ring (normed_field reducibility_hints)) : rank_condition (normed_field reducibility_hints) := sorry --non-trivial
lemma new_lemma_74164 (h0 : topological_space (with_bot (semiring (semiring congr_arg_kind)))) : totally_disconnected_space (with_bot (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_74165 (h0 : topological_space (div_inv_monoid (has_ssubset to_additive.value_type))) : t0_space (div_inv_monoid (has_ssubset to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_74166 (h0 : functor.add_const (ring (has_nndist name)) environment.implicit_infer_kind) : @is_principal_ideal_ring.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (has_nndist.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_74167 (h0 : prod (has_top num) (has_top num)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_74168 (h0 : topological_space (measurable_space (has_norm linarith.comp))) : t0_space (measurable_space (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_74169 (h0 : ring (linear_ordered_comm_group_with_zero (metric_space char))) : strong_rank_condition (linear_ordered_comm_group_with_zero (metric_space char)) := sorry --non-trivial
lemma new_lemma_74170 (h0 : uniform_space (semiring empty)) : separated_space (semiring empty) := sorry --non-trivial
lemma new_lemma_74171 (h0 : topological_space (normed_group (semiring linarith.comp_source))) : discrete_topology (normed_group (semiring linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_74172 (h0 : not (function.extfun Type topological_space -> false)) : @irreducible_space.{0} (semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_74173 (h0 : functor.add_const (topological_space (has_neg pos)) ennreal) : @t1_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} pos)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_74174 (h0 : monoid (plift (option empty))) : monoid.fg (plift (option empty)) := sorry --non-trivial
lemma new_lemma_74175 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_74176 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (canonically_linear_ordered_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (canonically_linear_ordered_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_74177 (h0 : uniform_space (normed_comm_ring environment.implicit_infer_kind)) : separated_space (normed_comm_ring environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_74178 (h0 : group (has_top (semiring (semiring congr_arg_kind)))) : group.fg (has_top (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_74179 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_74180 (h0 : not (ring (has_norm congr_arg_kind) -> false)) : @rank_condition.{0} (has_norm.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (ring.{0} (has_norm.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_74181 (h0 : function.extfun Type topological_space) : @t1_space.{0} (has_pos_part.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_pos_part.{0} name))  := sorry --non-trivial
lemma new_lemma_74182 (h0 : group (add_cancel_monoid (option (option unsigned)))) : normalizer_condition (add_cancel_monoid (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_74183 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_74184 (h0 : ordered_add_comm_monoid (has_Inf (has_Inf linarith.comp))) : archimedean (has_Inf (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_74185 (h0 : list (has_add (has_norm (has_inv (comm_ring (denumerable (has_norm (comm_ring (dlist fun_info))))))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_74186 (h0 : fin has_zero.zero) : @add_monoid.fg.{0} (comm_semigroup.{0} pos) (@matrix.vec_empty.{0} (add_monoid.{0} (comm_semigroup.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_74187 (h0 : ring (left_cancel_semigroup empty)) : strong_rank_condition (left_cancel_semigroup empty) := sorry --non-trivial
lemma new_lemma_74188 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @normal_space.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_74189 (h0 : semiring (has_to_string (has_neg Type))) : is_noetherian_ring (has_to_string (has_neg Type)) := sorry --non-trivial
lemma new_lemma_74190 (h0 : fin has_zero.zero) : @group.fg.{0} (canonically_linear_ordered_monoid.{0} real) (@matrix.vec_empty.{0} (group.{0} (canonically_linear_ordered_monoid.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_74191 (h0 : topological_space (has_nnnorm char)) : locally_compact_space (has_nnnorm char) := sorry --non-trivial
lemma new_lemma_74192 (h0 : not (add_group (add_cancel_comm_monoid reducibility_hints) -> false)) : @is_add_cyclic.{0} (add_cancel_comm_monoid.{0} reducibility_hints) (@classical.by_contradiction'.{1} (add_group.{0} (add_cancel_comm_monoid.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_74193 (h0 : fin has_zero.zero) : @topological_space.separable_space.{0} (sub_neg_monoid.{0} name) (@matrix.vec_empty.{0} (topological_space.{0} (sub_neg_monoid.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_74194 (h0 : not (topological_space (non_unital_non_assoc_semiring linarith.ineq) -> false)) : @totally_disconnected_space.{0} (non_unital_non_assoc_semiring.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (non_unital_non_assoc_semiring.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_74195 (h0 : ring (encodable (random_gen (random_gen linarith.ineq)))) : rank_condition (encodable (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_74196 (h0 : fin has_zero.zero) : @group.fg.{0} (sub_neg_monoid.{0} pos) (@matrix.vec_empty.{0} (group.{0} (sub_neg_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_74197 (h0 : topological_space (has_emptyc linarith.comp)) : discrete_topology (has_emptyc linarith.comp) := sorry --non-trivial
lemma new_lemma_74198 (h0 : topological_space (ring (has_Inf pos))) : sequential_space (ring (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_74199 (h0 : not (topological_space (has_div (mul_one_class to_additive.value_type)) -> false)) : @t0_space.{0} (has_div.{0} (mul_one_class.{0} to_additive.value_type)) (@classical.by_contradiction'.{1} (topological_space.{0} (has_div.{0} (mul_one_class.{0} to_additive.value_type))) h0)  := sorry --non-trivial
lemma new_lemma_74200 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (partial_order empty)) := sorry --non-trivial
lemma new_lemma_74201 (h0 : ring (with_bot unsigned)) : rank_condition (with_bot unsigned) := sorry --non-trivial
lemma new_lemma_74202 (h0 : topological_space (semigroup (mul_zero_class (mul_zero_class name)))) : preirreducible_space (semigroup (mul_zero_class (mul_zero_class name))) := sorry --non-trivial
lemma new_lemma_74203 (h0 : ring (has_neg (has_add (finset pos)))) : is_domain (has_neg (has_add (finset pos))) := sorry --non-trivial
lemma new_lemma_74204 (h0 : functor.add_const (semiring (boolean_algebra pos)) pos) : @is_noetherian_ring.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (semiring.{0} (boolean_algebra.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_74205 (h0 : ring (with_one (semiring (semiring linarith.comp)))) : rank_condition (with_one (semiring (semiring linarith.comp))) := sorry --non-trivial
lemma new_lemma_74206 (h0 : group (has_inter ennreal)) : group.fg (has_inter ennreal) := sorry --non-trivial
lemma new_lemma_74207 (h0 : functor.add_const (add_group (option unsigned)) (semiring num)) : @is_add_cyclic.{0} (option.{0} unsigned) (@functor.add_const.run.{0 0} (add_group.{0} (option.{0} unsigned)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_74208 (h0 : topological_space (has_pos_part (has_nndist linarith.comp))) : t0_space (has_pos_part (has_nndist linarith.comp)) := sorry --non-trivial
lemma new_lemma_74209 (h0 : topological_space (with_bot unsigned)) : discrete_topology (with_bot unsigned) := sorry --non-trivial
lemma new_lemma_74210 (h0 : topological_space (has_dist (option unsigned))) : loc_path_connected_space (has_dist (option unsigned)) := sorry --non-trivial
lemma new_lemma_74211 (h0 : functor.add_const (topological_space (pseudo_metric_space unsigned)) unsigned) : @t0_space.{0} (pseudo_metric_space.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (pseudo_metric_space.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_74212 (h0 : topological_space (has_compl (has_ssubset (has_ssubset (random_gen (has_ssubset linarith.comp_source)))))) : t0_space (has_compl (has_ssubset (has_ssubset (random_gen (has_ssubset linarith.comp_source))))) := sorry --non-trivial
lemma new_lemma_74213 (h0 : functor.comp filter has_to_string Type) : filter.ne_bot (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_74214 (h0 : list (has_pos_part (has_pos_part pos))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_74215 (h0 : functor.add_const (filter (has_to_string linarith.comp)) pos) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_74216 (h0 : list (with_bot pnat)) (h1 : ne (list.ilast h0) has_bot.bot) (h2 : not (pnat -> false)) : pnat.coprime (with_bot.unbot (list.ilast h0) h1) (classical.by_contradiction' h2) := sorry --non-trivial
lemma new_lemma_74217 (h0 : functor.add_const (function.extfun Type uniform_space) Type) : @complete_space.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type uniform_space.{0}) Type h0) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_74218 (h1 : topological_space (dlist fun_info)) : t0_space (dlist fun_info) := sorry --non-trivial
lemma new_lemma_74219 (h0 : functor.add_const (topological_space (monoid_with_zero pos)) pos) : @loc_path_connected_space.{0} (monoid_with_zero.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (monoid_with_zero.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_74220 (h0 : functor.add_const (uniform_space (has_to_string environment.implicit_infer_kind)) pos) : @separated_space.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_to_string.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_74221 (h0 : list (finset (comm_group (has_add pos)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_74222 (h0 : topological_space (has_star (semiring (semiring (semiring num))))) : totally_disconnected_space (has_star (semiring (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_74223 (h0 : ring (add_cancel_monoid (option pos))) : is_principal_ideal_ring (add_cancel_monoid (option pos)) := sorry --non-trivial
lemma new_lemma_74224 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (has_add.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_add.{0} name))  := sorry --non-trivial
lemma new_lemma_74225 (h1 : complete_lattice (has_top string_imp)) : is_compactly_generated (has_top string_imp) := sorry --non-trivial
lemma new_lemma_74226 (h0 : fin has_zero.zero) : @discrete_topology.{0} (boolean_algebra.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (boolean_algebra.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_74227 (h0 : group (linear_ordered_add_comm_monoid_with_top ennreal)) : is_cyclic (linear_ordered_add_comm_monoid_with_top ennreal) := sorry --non-trivial
lemma new_lemma_74228 (h0 : ring (normed_comm_ring (finset (has_pos_part Type)))) : is_principal_ideal_ring (normed_comm_ring (finset (has_pos_part Type))) := sorry --non-trivial
lemma new_lemma_74229 (h3 : uniform_space reducibility_hints) : complete_space reducibility_hints := sorry --non-trivial
lemma new_lemma_74230 (h0 : complete_lattice (metric_space (semiring congr_arg_kind))) : is_atomistic (metric_space (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_74231 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (is_R_or_C.{0} (semiring.{0} (option.{0} empty))) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (is_R_or_C.{0} (semiring.{0} (option.{0} empty))))  := sorry --non-trivial
lemma new_lemma_74232 (h0 : functor.add_const (fin has_zero.zero) real) : @path_connected_space.{1} (comm_semigroup.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (comm_semigroup.{1} Type)) (@functor.add_const.run.{0 0} (fin (@has_zero.zero.{0} nat nat.has_zero)) real h0))  := sorry --non-trivial
lemma new_lemma_74233 (h0 : add_group (denumerable (with_bot string_imp))) : is_add_cyclic (denumerable (with_bot string_imp)) := sorry --non-trivial
lemma new_lemma_74234 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (non_assoc_semiring empty)) := sorry --non-trivial
lemma new_lemma_74235 (h0 : group (ring (has_neg (has_zero name)))) : group.fg (ring (has_neg (has_zero name))) := sorry --non-trivial
lemma new_lemma_74236 (h0 : uniform_space (has_nndist (option name))) : separated_space (has_nndist (option name)) := sorry --non-trivial
lemma new_lemma_74237 (h0 : group (has_norm (has_nnnorm (has_nnnorm linarith.ineq)))) : group.fg (has_norm (has_nnnorm (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_74238 (h3 : not (topological_space (denumerable char) -> false)) : @totally_disconnected_space.{0} (denumerable.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (denumerable.{0} char)) h3)  := sorry --non-trivial
lemma new_lemma_74239 (h0 : topological_space (measurable_space (has_top (semiring num)))) : locally_compact_space (measurable_space (has_top (semiring num))) := sorry --non-trivial
lemma new_lemma_74240 (h0 : cancel_comm_monoid_with_zero (linear_ordered_field num)) : unique_factorization_monoid (linear_ordered_field num) := sorry --non-trivial
lemma new_lemma_74241 (h0 : topological_space (has_bot (has_Inf (has_bot (has_Inf pos))))) : preirreducible_space (has_bot (has_Inf (has_bot (has_Inf pos)))) := sorry --non-trivial
lemma new_lemma_74242 (h0 : not (topological_space (has_nnnorm string_imp) -> false)) : @path_connected_space.{0} (has_nnnorm.{0} string_imp) (@classical.by_contradiction'.{1} (topological_space.{0} (has_nnnorm.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_74243 (h0 : functor.add_const (ring (comm_group pos)) (finset linarith.comp)) : @rank_condition.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (comm_group.{0} pos)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_74244 (h0 : ring (has_Inf (has_to_string Type))) : rank_condition (has_Inf (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_74245 (h0 : functor.add_const (add_group (boolean_algebra linarith.comp)) pos) : @is_add_cyclic.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_group.{0} (boolean_algebra.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_74246 (h0 : topological_space (has_add (finset (boolean_algebra pos)))) : path_connected_space (has_add (finset (boolean_algebra pos))) := sorry --non-trivial
lemma new_lemma_74247 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} string_imp (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) string_imp)  := sorry --non-trivial
lemma new_lemma_74248 (h0 : ring linarith.ineq) : rank_condition linarith.ineq := sorry --non-trivial
lemma new_lemma_74249 (h0 : topological_space (ordered_cancel_add_comm_monoid pos)) : t1_space (ordered_cancel_add_comm_monoid pos) := sorry --non-trivial
lemma new_lemma_74250 (h0 : ring (pseudo_metric_space (option (option unsigned)))) : is_domain (pseudo_metric_space (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_74251 (h0 : functor.comp topological_space comm_group ennreal) : @sequential_space.{0} (comm_group.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} ennreal)) pos (@functor.comp.run.{0 0 0} topological_space.{0} comm_group.{0} ennreal h0))  := sorry --non-trivial
lemma new_lemma_74252 (h0 : topological_space (normed_comm_ring (has_neg (has_add linarith.comp)))) : sequential_space (normed_comm_ring (has_neg (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_74253 (h0 : functor.add_const (topological_space (finset pos)) Type) : @regular_space.{0} (finset.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (finset.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_74254 (h0 : complete_lattice (sub_neg_monoid (has_pos_part pos))) : is_compactly_generated (sub_neg_monoid (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_74255 (h0 : group (monoid (option ennreal))) : is_simple_group (monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_74256 (h0 : ring (has_bot (option unsigned))) : strong_rank_condition (has_bot (option unsigned)) := sorry --non-trivial
lemma new_lemma_74257 (h0 : topological_space (mul_one_class enat)) (h2 : preorder (mul_one_class enat)) : order_topology (mul_one_class enat) := sorry --non-trivial
lemma new_lemma_74258 (h0 : uniform_space (normed_lattice_add_comm_group (has_bot (has_add (sub_neg_monoid pos))))) : complete_space (normed_lattice_add_comm_group (has_bot (has_add (sub_neg_monoid pos)))) := sorry --non-trivial
lemma new_lemma_74259 (h0 : fin has_zero.zero) : @discrete_topology.{1} Type (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@matrix.vec_empty.{2} (function.extfun.{3 2} (Type 1) topological_space.{1}) h0) Type)  := sorry --non-trivial
lemma new_lemma_74260 (h0 : complete_lattice (normed_comm_ring (has_add Type))) : complete_lattice.is_Sup_finite_compact (normed_comm_ring (has_add Type)) := sorry --non-trivial
lemma new_lemma_74261 (h0 : topological_space (canonically_ordered_comm_semiring (finset (has_pos_part Type)))) : sequential_space (canonically_ordered_comm_semiring (finset (has_pos_part Type))) := sorry --non-trivial
lemma new_lemma_74262 (h1 : uniform_space (has_top to_additive.value_type)) : complete_space (has_top to_additive.value_type) := sorry --non-trivial
lemma new_lemma_74263 (h0 : functor.add_const (topological_space (cancel_monoid Type)) (has_add name)) : @totally_separated_space.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (cancel_monoid.{1} Type)) (has_add.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_74264 (h0 : topological_space (semigroup (has_Inf (has_Inf linarith.comp)))) : t0_space (semigroup (has_Inf (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_74265 (h0 : topological_space (has_lt char)) : path_connected_space (has_lt char) := sorry --non-trivial
lemma new_lemma_74266 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (left_cancel_semigroup.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (left_cancel_semigroup.{0} num))  := sorry --non-trivial
lemma new_lemma_74267 (h0 : functor.comp monoid normed_comm_ring name) : @monoid.fg.{0} (normed_comm_ring.{0} name) (@functor.comp.run.{0 0 0} monoid.{0} normed_comm_ring.{0} name (@functor.comp.run.{0 0 0} monoid.{0} normed_comm_ring.{0} name h0))  := sorry --non-trivial
lemma new_lemma_74268 (h1 : add_group linarith.comp_source) (h2 : add_subgroup linarith.comp_source) : add_subgroup.is_commutative h2 := sorry --non-trivial
lemma new_lemma_74269 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_neg.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_74270 (h0 : not (has_mem.mem (with_bot linarith.ineq) has_emptyc.emptyc -> false)) : @totally_separated_space.{0} (with_bot.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_bot.{0} linarith.ineq) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_bot.{0} linarith.ineq) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_74271 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_atomistic.{0} (option.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (option.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_74272 (h0 : function.extfun nat fin) : @is_cyclic.{1} (canonically_linear_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (group.{1} (canonically_linear_ordered_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_74273 (h0 : topological_space (mul_zero_class (option (with_zero empty)))) : totally_separated_space (mul_zero_class (option (with_zero empty))) := sorry --non-trivial
lemma new_lemma_74274 (h0 : not (group (has_ssubset (boolean_algebra.core char)) -> false)) : @is_cyclic.{0} (has_ssubset.{0} (boolean_algebra.core.{0} char)) (@classical.by_contradiction'.{1} (group.{0} (has_ssubset.{0} (boolean_algebra.core.{0} char))) h0)  := sorry --non-trivial
lemma new_lemma_74275 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (@id.{2} Type (semiring.{0} congr_arg_kind)) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (@id.{2} Type (semiring.{0} congr_arg_kind)))  := sorry --non-trivial
lemma new_lemma_74276 (h0 : add_group (add_comm_semigroup (mul_one_class (mul_one_class fun_info)))) : is_add_cyclic (add_comm_semigroup (mul_one_class (mul_one_class fun_info))) := sorry --non-trivial
lemma new_lemma_74277 (h0 : functor.add_const (complete_lattice (boolean_algebra linarith.comp)) pos) : @is_compactly_generated.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (boolean_algebra.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_74278 (h1 : not (topological_space (comm_ring fun_info) -> false)) : @totally_disconnected_space.{0} (comm_ring.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (comm_ring.{0} fun_info)) h1)  := sorry --non-trivial
lemma new_lemma_74279 (h0 : functor.add_const (topological_space (has_zero name)) name) : @path_connected_space.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_74280 (h1 : set (has_compl string_imp)) : set.subsingleton h1 := sorry --non-trivial
lemma new_lemma_74281 (h0 h1 : set (ordered_comm_monoid Type)) : set.subset h0 h1 := sorry --non-trivial
lemma new_lemma_74282 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (has_bot.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_bot.{0} name))  := sorry --non-trivial
lemma new_lemma_74283 (h0 : topological_space (boolean_algebra.core pos)) : totally_disconnected_space (boolean_algebra.core pos) := sorry --non-trivial
lemma new_lemma_74284 (h0 : ring (has_append linarith.ineq)) : is_domain (has_append linarith.ineq) := sorry --non-trivial
lemma new_lemma_74285 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (omega_complete_partial_order.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (omega_complete_partial_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_74286 (h0 : add_monoid (has_sub (semiring num))) : add_monoid.fg (has_sub (semiring num)) := sorry --non-trivial
lemma new_lemma_74287 (h0 : topological_space (topological_space (has_nnnorm linarith.ineq))) : totally_disconnected_space (topological_space (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_74288 (h0 : topological_space (add_cancel_monoid (has_add (has_add Type)))) : discrete_topology (add_cancel_monoid (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_74289 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (canonically_linear_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (canonically_linear_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_74290 (h0 : ring (has_to_string (has_Inf name))) : strong_rank_condition (has_to_string (has_Inf name)) := sorry --non-trivial
lemma new_lemma_74291 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem uniform_space)) : @complete_space.{0} unsigned (@function.extfun_app.{2 1} Type uniform_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) uniform_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) uniform_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) unsigned)  := sorry --non-trivial
lemma new_lemma_74292 (h0 : ring (mul_zero_class (option (option unsigned)))) : is_principal_ideal_ring (mul_zero_class (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_74293 (h0 : topological_space (has_pos_part (has_add (has_pos_part pos)))) : normal_space (has_pos_part (has_add (has_pos_part pos))) := sorry --non-trivial
lemma new_lemma_74294 (h0 : set (uniform_space std_gen)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_74295 (h0 : topological_space (canonically_ordered_monoid (has_Inf (ordered_comm_monoid Type)))) : discrete_topology (canonically_ordered_monoid (has_Inf (ordered_comm_monoid Type))) := sorry --non-trivial
lemma new_lemma_74296 (h0 : topological_space (bin_tree (semiring (semiring (semiring (semiring unsigned)))))) : t0_space (bin_tree (semiring (semiring (semiring (semiring unsigned))))) := sorry --non-trivial
lemma new_lemma_74297 (h0 : topological_space (has_Inf (has_neg linarith.comp))) : path_connected_space (has_Inf (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_74298 (h0 : add_group (preorder empty)) : is_add_cyclic (preorder empty) := sorry --non-trivial
lemma new_lemma_74299 (h0 : not (filter (fintype string_imp) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_74300 (h0 : topological_space (uniform_space reducibility_hints)) : path_connected_space (uniform_space reducibility_hints) := sorry --non-trivial
lemma new_lemma_74301 (h0 : list (has_top (has_ssubset fun_info))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_74302 (h0 : group (has_neg (boolean_algebra.core environment.implicit_infer_kind))) : normalizer_condition (has_neg (boolean_algebra.core environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_74303 (h0 : complete_lattice (has_one (semiring (has_top (has_top unsigned))))) : is_atomistic (has_one (semiring (has_top (has_top unsigned)))) := sorry --non-trivial
lemma new_lemma_74304 (h0 : uniform_space (has_pos_part (has_add (has_add Type)))) : complete_space (has_pos_part (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_74305 (h0 : topological_space (ordered_comm_monoid (has_add (has_Inf pos)))) : topological_space.separable_space (ordered_comm_monoid (has_add (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_74306 (h0 : functor.add_const (ring pos) pos) : @is_principal_ideal_ring.{0} pos (@functor.add_const.run.{0 0} (ring.{0} pos) pos h0)  := sorry --non-trivial
lemma new_lemma_74307 (h0 : topological_space (option pos)) : path_connected_space (option pos) := sorry --non-trivial
lemma new_lemma_74308 (h0 : group (has_add (ring (has_neg linarith.comp)))) : normalizer_condition (has_add (ring (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_74309 (h0 : topological_space (linear_ordered_comm_ring (semiring (semiring congr_arg_kind)))) : normal_space (linear_ordered_comm_ring (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_74310 (h0 : topological_space (has_neg (add_cancel_monoid name))) : sequential_space (has_neg (add_cancel_monoid name)) := sorry --non-trivial
lemma new_lemma_74311 (h0 : group (has_nndist (has_add (has_add environment.implicit_infer_kind)))) : group.fg (has_nndist (has_add (has_add environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_74312 (h2 : set (normed_field char)) : set.finite h2 := sorry --non-trivial
lemma new_lemma_74313 (h0 : add_group (generalized_boolean_algebra (has_nndist pos))) : is_add_cyclic (generalized_boolean_algebra (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_74314 (h0 : fin has_zero.zero) : @regular_space.{0} (canonically_ordered_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)) (canonically_ordered_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_74315 (h0 : functor.add_const (topological_space (boolean_algebra.core unsigned)) (option empty)) : @t0_space.{0} (boolean_algebra.core.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} unsigned)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_74316 (h0 : topological_space (ordered_comm_ring (has_add pos))) : loc_path_connected_space (ordered_comm_ring (has_add pos)) := sorry --non-trivial
lemma new_lemma_74317 (h0 : uniform_space (has_norm (has_top (has_top fun_info)))) : separated_space (has_norm (has_top (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_74318 (h0 : function.extfun Type (functor.comp topological_space comm_group)) : @totally_separated_space.{0} (comm_group.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} comm_group.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} comm_group.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_74319 (h0 : ring (mul_one_class to_additive.value_type) -> Prop) (h1 : Exists (fun (x : ring (mul_one_class to_additive.value_type)), h0 x)) : @rank_condition.{0} (mul_one_class.{0} to_additive.value_type) (@classical.some.{1} (ring.{0} (mul_one_class.{0} to_additive.value_type)) h0 h1)  := sorry --non-trivial
lemma new_lemma_74320 (h0 : topological_space (has_neg (finset (finset ennreal)))) : discrete_topology (has_neg (finset (finset ennreal))) := sorry --non-trivial
lemma new_lemma_74321 (h0 : function.extfun Type topological_space) : @t1_space.{0} (linear_order.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_74322 (h0 : ring (normed_field fun_info)) : strong_rank_condition (normed_field fun_info) := sorry --non-trivial
lemma new_lemma_74323 (h0 : ring (with_bot (random_gen linarith.ineq))) : is_domain (with_bot (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_74324 (h0 : ring (has_div linarith.ineq)) : strong_rank_condition (has_div linarith.ineq) := sorry --non-trivial
lemma new_lemma_74325 (h0 : functor.add_const (topological_space (metric_space num)) num) : @irreducible_space.{0} (metric_space.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (metric_space.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_74326 (h0 : complete_lattice (denumerable (has_nnnorm fun_info))) : complete_lattice.is_Sup_finite_compact (denumerable (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_74327 (h0 : topological_space (semigroup (semigroup environment.implicit_infer_kind))) : discrete_topology (semigroup (semigroup environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_74328 (h0 : topological_space (ordered_ring (semiring (semiring num)))) : totally_disconnected_space (ordered_ring (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_74329 (h0 : topological_space (comm_monoid empty)) : path_connected_space (comm_monoid empty) := sorry --non-trivial
lemma new_lemma_74330 (h0 : not (function.extfun Type group -> false)) : @group.fg.{0} (has_nnnorm.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (has_nnnorm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_74331 (h0 : group (monoid_with_zero unsigned)) : is_cyclic (monoid_with_zero unsigned) := sorry --non-trivial
lemma new_lemma_74332 (h0 : topological_space (monoid pos)) : preirreducible_space (monoid pos) := sorry --non-trivial
lemma new_lemma_74333 (h0 : filter (comm_group (semigroup Type))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_74334 (h0 : topological_space (has_nndist (has_zero (has_add (has_add (has_zero pos)))))) : t1_space (has_nndist (has_zero (has_add (has_add (has_zero pos))))) := sorry --non-trivial
lemma new_lemma_74335 (h0 : functor.add_const (topological_space (has_Inf linarith.comp)) linarith.comp) : @irreducible_space.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_74336 (h0 : complete_lattice (has_norm (has_norm fun_info))) : complete_lattice.is_Sup_finite_compact (has_norm (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_74337 (h0 : functor.add_const (function.extfun (Type 1) topological_space) name) : @irreducible_space.{1} Type (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) name h0) Type)  := sorry --non-trivial
lemma new_lemma_74338 (h0 : functor.add_const (ordered_add_comm_monoid (as_linear_order unsigned)) empty) : @archimedean.{0} (as_linear_order.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (as_linear_order.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_74339 (h0 : fin has_zero.zero) : @has_exists_mul_of_le.{0} (simple_graph.{0} name) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) h0) (simple_graph.{0} name))  := sorry --non-trivial
lemma new_lemma_74340 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_union.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_union.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_74341 (h0 : option unsigned -> Prop) : zzz_forall h0 := sorry --non-trivial
lemma new_lemma_74342 (h0 : preorder std_gen) (h1 : std_gen -> set (normed_field (has_union char))) : filter.is_antitone_basis h1 := sorry --non-trivial
lemma new_lemma_74343 (h0 : topological_space (random_gen (has_nnnorm (has_nnnorm fun_info)))) : path_connected_space (random_gen (has_nnnorm (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_74344 (h0 : fin has_zero.zero) : @normal_space.{0} (complete_distrib_lattice.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (complete_distrib_lattice.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_74345 (h0 : functor.add_const (topological_space (left_cancel_semigroup unsigned)) unsigned) : @discrete_topology.{0} (left_cancel_semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_semigroup.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_74346 (h0 : functor.add_const (ring (left_cancel_monoid empty)) empty) : @is_principal_ideal_ring.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (left_cancel_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_74347 (h0 : filter (has_to_string (has_nndist pos))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_74348 (h0 : filter (complete_distrib_lattice (has_add (has_add (has_add environment.implicit_infer_kind))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_74349 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_neg unsigned)) name) : @unique_factorization_monoid.{0} (has_neg.{0} unsigned) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_neg.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_74350 (h0 : topological_space (has_nnnorm (random_gen (random_gen (mul_one_class (random_gen linarith.ineq)))))) : t0_space (has_nnnorm (random_gen (random_gen (mul_one_class (random_gen linarith.ineq))))) := sorry --non-trivial
lemma new_lemma_74351 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (semiring.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_74352 (h0 : functor.add_const (group (bin_tree num)) (semiring empty)) : @is_cyclic.{0} (bin_tree.{0} num) (@functor.add_const.run.{0 0} (group.{0} (bin_tree.{0} num)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_74353 (h0 : uniform_space (linear_ordered_semiring empty)) : complete_space (linear_ordered_semiring empty) := sorry --non-trivial
lemma new_lemma_74354 (h0 : ring (bin_tree (semiring (semiring num)))) : rank_condition (bin_tree (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_74355 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_74356 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (measurable_space empty)) := sorry --non-trivial
lemma new_lemma_74357 (h0 : functor.add_const (function.extfun Type finset) (has_Inf linarith.comp)) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (semigroup linarith.comp)) := sorry --non-trivial
lemma new_lemma_74358 (h0 : topological_space (has_inv (has_ssubset linarith.ineq))) : path_connected_space (has_inv (has_ssubset linarith.ineq)) := sorry --non-trivial
lemma new_lemma_74359 (h0 : fin has_zero.zero) : @totally_separated_space.{0} (ordered_comm_ring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (ordered_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_74360 (h0 : ring (has_pos_part (ordered_ring (ring pos)))) : strong_rank_condition (has_pos_part (ordered_ring (ring pos))) := sorry --non-trivial
lemma new_lemma_74361 (h0 : topological_space (pseudo_metric_space (option ennreal))) : path_connected_space (pseudo_metric_space (option ennreal)) := sorry --non-trivial
lemma new_lemma_74362 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (normed_group.{0} num) (@function.extfun_app.{2 1} Type monoid.{0} h0 (normed_group.{0} num))  := sorry --non-trivial
lemma new_lemma_74363 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (has_Sup (option congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_74364 (h0 : functor.add_const (ordered_add_comm_monoid (has_zero unsigned)) linarith.comp) : @archimedean.{0} (has_zero.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_zero.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_74365 (h0 : monoid (complete_linear_order (semiring empty))) : monoid.fg (complete_linear_order (semiring empty)) := sorry --non-trivial
lemma new_lemma_74366 (h0 : add_group (has_ssubset char)) : is_add_cyclic (has_ssubset char) := sorry --non-trivial
lemma new_lemma_74367 (h0 : add_group (has_norm (has_norm linarith.comp))) : is_add_cyclic (has_norm (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_74368 (h0 : functor.add_const (topological_space (has_neg pos)) name) : @totally_separated_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_74369 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (has_sub.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_sub.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_74370 (h0 : functor.add_const (ring (has_nndist empty)) num) : @rank_condition.{0} (has_nndist.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (has_nndist.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_74371 (h0 : topological_space (canonically_ordered_comm_semiring (finset name))) : regular_space (canonically_ordered_comm_semiring (finset name)) := sorry --non-trivial
lemma new_lemma_74372 (h0 : topological_space (has_norm (measurable_space empty))) : locally_compact_space (has_norm (measurable_space empty)) := sorry --non-trivial
lemma new_lemma_74373 (h0 : monoid (has_zero (has_nndist (ring name)))) : monoid.fg (has_zero (has_nndist (ring name))) := sorry --non-trivial
lemma new_lemma_74374 (h0 : list (ordered_comm_group (has_dist num))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_74375 (h0 : topological_space (mul_zero_class (has_neg (has_neg_part ennreal)))) : normal_space (mul_zero_class (has_neg (has_neg_part ennreal))) := sorry --non-trivial
lemma new_lemma_74376 (h0 : not (function.extfun Type uniform_space -> false)) : @separated_space.{0} (bin_tree.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (bin_tree.{0} num))  := sorry --non-trivial
lemma new_lemma_74377 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (as_linear_order.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (as_linear_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_74378 (h0 : group (add_left_cancel_semigroup unsigned)) : normalizer_condition (add_left_cancel_semigroup unsigned) := sorry --non-trivial
lemma new_lemma_74379 (h0 : functor.add_const (ordered_add_comm_monoid (has_Inf name)) linarith.comp) : @archimedean.{0} (has_Inf.{0} name) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_Inf.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_74380 (h0 : functor.add_const (function.extfun (Type 1) topological_space) linarith.comp) : @topological_space.separable_space.{1} (comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) linarith.comp h0) (comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_74381 (h0 : topological_space (comm_group (has_add unsigned))) : path_connected_space (comm_group (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_74382 (h0 : function.extfun (Type 1) group) : @is_simple_group.{1} (add_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} h0 (add_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_74383 (h0 : add_monoid (add_group (semiring num))) : add_monoid.fg (add_group (semiring num)) := sorry --non-trivial
lemma new_lemma_74384 (h0 : functor.add_const (ring (ordered_comm_ring linarith.comp)) (add_cancel_monoid name)) : @strong_rank_condition.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (ordered_comm_ring.{0} linarith.comp)) (add_cancel_monoid.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_74385 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (with_bot.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (with_bot.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_74386 (h0 : functor.add_const (topological_space (has_zero name)) (comm_group name)) : @discrete_topology.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} name)) (comm_group.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_74387 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (ordered_cancel_add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_cancel_add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_74388 (h0 : topological_space (comm_semigroup (has_bot name))) : t0_space (comm_semigroup (has_bot name)) := sorry --non-trivial
lemma new_lemma_74389 (h0 : function.extfun Type topological_space) : @t1_space.{0} (linear_ordered_comm_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_74390 (h0 : topological_space (comm_semigroup real)) : preirreducible_space (comm_semigroup real) := sorry --non-trivial
lemma new_lemma_74391 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (has_nndist.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_nndist.{0} num))  := sorry --non-trivial
lemma new_lemma_74392 (h0 : function.extfun Type group) : @is_cyclic.{0} (measurable_space.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (measurable_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_74393 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_74394 (h0 : ring (normed_field linarith.ineq)) : strong_rank_condition (normed_field linarith.ineq) := sorry --non-trivial
lemma new_lemma_74395 (h0 : group (normed_group (random_gen (random_gen (random_gen (random_gen fun_info)))))) : group.fg (normed_group (random_gen (random_gen (random_gen (random_gen fun_info))))) := sorry --non-trivial
lemma new_lemma_74396 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_add linarith.comp)) unsigned) : @unique_factorization_monoid.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_add.{0} linarith.comp)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_74397 (h0 : has_lt (has_ssubset reducibility_hints)) : no_max_order (has_ssubset reducibility_hints) := sorry --non-trivial
lemma new_lemma_74398 (h2 : not (ring (denumerable to_additive.value_type) -> false)) : @rank_condition.{0} (denumerable.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (denumerable.{0} to_additive.value_type)) h2)  := sorry --non-trivial
lemma new_lemma_74399 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_74400 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (measurable_space.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (measurable_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_74401 (h0 : not (topological_space unsigned -> false)) : @t0_space.{0} unsigned (@classical.by_contradiction'.{1} (topological_space.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_74402 (h0 : topological_space (has_sdiff empty)) : discrete_topology (has_sdiff empty) := sorry --non-trivial
lemma new_lemma_74403 (h0 : empty) : @t0_space.{0} (has_top.{0} char) (@empty.elim.{1} (topological_space.{0} (has_top.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_74404 (h0 : functor.add_const (topological_space (bin_tree congr_arg_kind)) unsigned) : @t0_space.{0} (bin_tree.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (bin_tree.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_74405 (h0 : filter (dlist linarith.comp_source)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_74406 (h0 : topological_space (semiring (random_gen fun_info))) : discrete_topology (semiring (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_74407 (h0 : complete_lattice (cancel_monoid (has_add environment.implicit_infer_kind))) : complete_lattice.is_Sup_finite_compact (cancel_monoid (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_74408 (h0 : topological_space (canonically_ordered_comm_semiring (finset (ring linarith.comp)))) : t0_space (canonically_ordered_comm_semiring (finset (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_74409 (h1 : complete_lattice (nondiscrete_normed_field char)) : complete_lattice.is_Sup_finite_compact (nondiscrete_normed_field char) := sorry --non-trivial
lemma new_lemma_74410 (h0 : function.extfun (Type 1) ring) : @rank_condition.{1} (complete_distrib_lattice.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (complete_distrib_lattice.{1} Type))  := sorry --non-trivial
lemma new_lemma_74411 (h0 : ring (finset (boolean_algebra.core ennreal))) : is_domain (finset (boolean_algebra.core ennreal)) := sorry --non-trivial
lemma new_lemma_74412 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (with_one.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (with_one.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_74413 (h0 : functor.add_const (ring (cancel_monoid linarith.comp)) name) : @rank_condition.{0} (cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (cancel_monoid.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_74414 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_zero.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_zero.{0} num))  := sorry --non-trivial
lemma new_lemma_74415 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (linear_order empty)) := sorry --non-trivial
lemma new_lemma_74416 (h0 : group (left_cancel_monoid (option unsigned))) : group.fg (left_cancel_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_74417 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (preorder.{0} empty) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (preorder.{0} empty))  := sorry --non-trivial
lemma new_lemma_74418 (h0 : list (normed_lattice_add_comm_group Type)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_74419 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} (has_top.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (has_top.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_74420 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @t0_space.{0} (has_nndist.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (has_nndist.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_74421 (h0 : has_mem.mem (linear_ordered_add_comm_group linarith.comp_source) has_emptyc.emptyc) : @path_connected_space.{0} (linear_ordered_add_comm_group.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (linear_ordered_add_comm_group.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_74422 (h0 : functor.add_const (monoid (has_pos_part pos)) pos) : @monoid.fg.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 0} (monoid.{0} (has_pos_part.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_74423 (h0 : ordered_add_comm_monoid (ordered_comm_ring (ordered_ring pos))) : archimedean (ordered_comm_ring (ordered_ring pos)) := sorry --non-trivial
lemma new_lemma_74424 (h0 : topological_space (measurable_space.dynkin_system unsigned)) : totally_separated_space (measurable_space.dynkin_system unsigned) := sorry --non-trivial
lemma new_lemma_74425 (h0 : functor.add_const (ring (add_cancel_monoid Type)) linarith.comp) : @is_domain.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (add_cancel_monoid.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_74426 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : countable_Inter_filter (function.extfun_app (function.extfun_app h0 filter) (has_inter unsigned)) := sorry --non-trivial
lemma new_lemma_74427 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (has_inv.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_inv.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_74428 (h0 : ring (boolean_algebra.core (has_neg linarith.comp))) : is_domain (boolean_algebra.core (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_74429 (h0 : ordered_add_comm_monoid (linear_ordered_cancel_comm_monoid empty)) : archimedean (linear_ordered_cancel_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_74430 (h0 : set (non_unital_non_assoc_semiring (linear_ordered_add_comm_monoid_with_top std_gen))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_74431 (h0 : functor.add_const (complete_lattice (comm_group pos)) (option pos)) : @is_atomistic.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (comm_group.{0} pos)) (option.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_74432 (h0 : functor.add_const (function.extfun Type group) linarith.comp) : @normalizer_condition.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) linarith.comp h0) (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_74433 (h0 : group (generalized_boolean_algebra empty)) : normalizer_condition (generalized_boolean_algebra empty) := sorry --non-trivial
lemma new_lemma_74434 (h0 : monoid (linear_ordered_semiring (semiring (semiring empty)))) : monoid.fg (linear_ordered_semiring (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_74435 (h0 : ring (has_add (has_ssubset (has_nnnorm (has_nnnorm char))))) : strong_rank_condition (has_add (has_ssubset (has_nnnorm (has_nnnorm char)))) := sorry --non-trivial
lemma new_lemma_74436 (h0 : topological_space (complete_distrib_lattice (has_nndist name))) : t0_space (complete_distrib_lattice (has_nndist name)) := sorry --non-trivial
lemma new_lemma_74437 (h0 : topological_space (monoid_with_zero ennreal)) : discrete_topology (monoid_with_zero ennreal) := sorry --non-trivial
lemma new_lemma_74438 (h0 : topological_space (with_bot (has_top (semiring (has_top unsigned))))) : locally_compact_space (with_bot (has_top (semiring (has_top unsigned)))) := sorry --non-trivial
lemma new_lemma_74439 (h0 : complete_lattice (has_ssubset (has_nnnorm reducibility_hints))) : is_compactly_generated (has_ssubset (has_nnnorm reducibility_hints)) := sorry --non-trivial
lemma new_lemma_74440 (h0 : group (has_emptyc (has_norm (has_norm linarith.comp_source)))) : is_cyclic (has_emptyc (has_norm (has_norm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_74441 (h2 : ring (non_unital_non_assoc_semiring linarith.comp_source)) : strong_rank_condition (non_unital_non_assoc_semiring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_74442 (h0 : functor.add_const (function.extfun (Type 1) complete_lattice) (ring pos)) : @complete_lattice.is_Sup_finite_compact.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) complete_lattice.{1}) (ring.{0} pos) h0) (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_74443 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (linear_ordered_comm_group.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (linear_ordered_comm_group.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_74444 (h0 : complete_lattice (has_nndist Type)) : is_compactly_generated (has_nndist Type) := sorry --non-trivial
lemma new_lemma_74445 (h0 : functor.add_const (topological_space (add_comm_monoid Type)) pos) : @preconnected_space.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_comm_monoid.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_74446 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (denumerable linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_74447 (h0 : function.extfun nat fin) : matrix.vec_empty (function.extfun_app h0 has_zero.zero) := sorry --non-trivial
lemma new_lemma_74448 (h0 : semiring (complete_distrib_lattice pos)) : is_noetherian_ring (complete_distrib_lattice pos) := sorry --non-trivial
lemma new_lemma_74449 (h0 : filter (add_comm_monoid (has_add Type))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_74450 (h0 : set (linear_ordered_comm_group_with_zero (mul_one_class (semi_normed_comm_ring string.iterator_imp)))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_74451 (h0 : uniform_space (add_comm_semigroup (add_comm_semigroup std_gen))) : complete_space (add_comm_semigroup (add_comm_semigroup std_gen)) := sorry --non-trivial
lemma new_lemma_74452 (h0 : functor.add_const (topological_space (measurable_space.dynkin_system unsigned)) empty) : @t1_space.{0} (measurable_space.dynkin_system.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (measurable_space.dynkin_system.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_74453 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_simple_group.{0} (ordered_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (ordered_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_74454 (h0 : function.extfun Type (functor.add_const (list (bin_tree unsigned)))) : palindrome (functor.add_const.run (function.extfun_app h0 empty)) := sorry --non-trivial
lemma new_lemma_74455 (h0 : ordered_comm_monoid (finset (has_Inf Type))) : has_exists_mul_of_le (finset (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_74456 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (omega_complete_partial_order.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (omega_complete_partial_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_74457 (h1 : complete_lattice (measurable_space congr_arg_kind)) : complete_lattice.is_Sup_finite_compact (measurable_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_74458 (h0 : function.extfun (((Type -> Type) -> Type 1) -> Type 1) (function.extfun ((Type -> Type) -> Type 1))) : @monoid.fg.{0} (linear_ordered_cancel_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) (@function.extfun_app.{3 3} (((Type → Type) → Type 1) → Type 1) (function.extfun.{3 2} ((Type → Type) → Type 1)) h0 (function.extfun.{2 2} (Type → Type))) (function.extfun.{2 1} Type)) monoid.{0}) (linear_ordered_cancel_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_74459 (h0 : not (function.extfun Type complete_lattice -> false)) : complete_lattice.is_Sup_finite_compact (measurable_space linarith.comp) := sorry --non-trivial
lemma new_lemma_74460 (h0 : topological_space (has_nnnorm (random_gen string_imp))) : totally_disconnected_space (has_nnnorm (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_74461 (h1 : topological_space (nondiscrete_normed_field environment.projection_info)) : totally_disconnected_space (nondiscrete_normed_field environment.projection_info) := sorry --non-trivial
lemma new_lemma_74462 (h0 : fin has_zero.zero) : @irreducible_space.{0} (ordered_comm_ring.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_ring.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_74463 (h0 : complete_lattice (has_append string_imp)) : complete_lattice.is_Sup_finite_compact (has_append string_imp) := sorry --non-trivial
lemma new_lemma_74464 (h0 : topological_space (add_comm_monoid (ring unsigned))) : locally_compact_space (add_comm_monoid (ring unsigned)) := sorry --non-trivial
lemma new_lemma_74465 (h0 : group (has_Inf (has_add Type))) : normalizer_condition (has_Inf (has_add Type)) := sorry --non-trivial
lemma new_lemma_74466 (h0 : ring (has_to_string (boolean_algebra Type))) : rank_condition (has_to_string (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_74467 (h0 : group (semiring linarith.comp)) : group.fg (semiring linarith.comp) := sorry --non-trivial
lemma new_lemma_74468 (h0 : function.extfun Type group) : @is_cyclic.{0} (dlist.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} h0 (dlist.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_74469 (h0 : complete_lattice (comm_group (has_add unsigned))) : complete_lattice.is_Sup_finite_compact (comm_group (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_74470 (h0 : functor.add_const (topological_space (has_neg pos)) name) : @normal_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_74471 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (normed_comm_ring.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (normed_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_74472 (h0 : finset (plift num)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_74473 (h0 : complete_lattice (has_zero (has_add environment.implicit_infer_kind))) : is_compactly_generated (has_zero (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_74474 (h0 : uniform_space (metric_space (has_top empty))) : separated_space (metric_space (has_top empty)) := sorry --non-trivial
lemma new_lemma_74475 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} (with_zero.{0} linarith.ineq) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (with_zero.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_74476 (h0 : ring (has_to_string (option (option (option unsigned))))) : rank_condition (has_to_string (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_74477 (h0 : topological_space (has_nndist (has_add (has_add name)))) : t0_space (has_nndist (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_74478 (h0 : ring (linear_ordered_add_comm_group (complete_distrib_lattice string_imp))) : strong_rank_condition (linear_ordered_add_comm_group (complete_distrib_lattice string_imp)) := sorry --non-trivial
lemma new_lemma_74479 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_74480 (h0 : functor.add_const (complete_lattice (free_add_monoid unsigned)) num) : @complete_lattice.is_Sup_finite_compact.{0} (free_add_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (free_add_monoid.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_74481 (h0 : ring (measurable_space.dynkin_system congr_arg_kind)) : strong_rank_condition (measurable_space.dynkin_system congr_arg_kind) := sorry --non-trivial
lemma new_lemma_74482 (h0 : group (measurable_space.dynkin_system (semiring empty))) : is_cyclic (measurable_space.dynkin_system (semiring empty)) := sorry --non-trivial
lemma new_lemma_74483 (h1 : group (has_nnnorm char)) : is_cyclic (has_nnnorm char) := sorry --non-trivial
lemma new_lemma_74484 (h0 : functor.add_const (ordered_add_comm_monoid (boolean_algebra.core pos)) linarith.comp) : @archimedean.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (boolean_algebra.core.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_74485 (h0 : functor.add_const (group (canonically_linear_ordered_monoid linarith.comp)) (has_add real)) : @normalizer_condition.{0} (canonically_linear_ordered_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (canonically_linear_ordered_monoid.{0} linarith.comp)) (has_add.{0} real) h0)  := sorry --non-trivial
lemma new_lemma_74486 (h0 : ring (complete_semilattice_Sup (random_gen (random_gen char)))) : strong_rank_condition (complete_semilattice_Sup (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_74487 (h0 : topological_space (measurable_space (with_bot to_additive.value_type))) : locally_compact_space (measurable_space (with_bot to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_74488 (h0 : ring (add_cancel_comm_monoid unsigned)) : rank_condition (add_cancel_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_74489 (h0 : functor.add_const (uniform_space (comm_monoid empty)) empty) : @complete_space.{0} (comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (comm_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_74490 (h0 : ring (semi_normed_ring reducibility_hints)) : strong_rank_condition (semi_normed_ring reducibility_hints) := sorry --non-trivial
lemma new_lemma_74491 (h0 : not (function.extfun Type complete_lattice -> false)) : @complete_lattice.is_Sup_finite_compact.{0} linarith.comp (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) linarith.comp)  := sorry --non-trivial
lemma new_lemma_74492 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (has_sub.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} congr_arg_kind)))))) (@function.extfun_app.{2 1} Type semiring.{0} h0 (has_sub.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} congr_arg_kind)))))))  := sorry --non-trivial
lemma new_lemma_74493 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (has_one.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_one.{0} num))  := sorry --non-trivial
lemma new_lemma_74494 (h0 : uniform_space (normed_comm_ring (has_add (has_pos_part (has_add ennreal))))) : complete_space (normed_comm_ring (has_add (has_pos_part (has_add ennreal)))) := sorry --non-trivial
lemma new_lemma_74495 (h0 : prod (non_assoc_semiring congr_arg_kind) (non_assoc_semiring congr_arg_kind)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_74496 (h0 : functor.add_const (topological_space (mul_zero_class Type)) Type) : @preirreducible_space.{1} (mul_zero_class.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (mul_zero_class.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_74497 (h0 : function.extfun Type ring) : @rank_condition.{0} empty (@function.extfun_app.{2 1} Type ring.{0} h0 empty)  := sorry --non-trivial
lemma new_lemma_74498 (h1 : ring (encodable linarith.comp_source)) : rank_condition (encodable linarith.comp_source) := sorry --non-trivial
lemma new_lemma_74499 (h0 : uniform_space (has_lt enat)) : complete_space (has_lt enat) := sorry --non-trivial
lemma new_lemma_74500 (h0 : functor.comp (functor.comp complete_lattice has_zero) option pos) : @is_compactly_generated.{0} (has_zero.{0} (option.{0} pos)) (@functor.comp.run.{0 0 0} complete_lattice.{0} has_zero.{0} (option.{0} pos) (@functor.comp.run.{0 0 0} (functor.comp.{0 0 0} complete_lattice.{0} has_zero.{0}) option.{0} pos h0))  := sorry --non-trivial
lemma new_lemma_74501 (h0 : ring (boolean_algebra.core (option num))) : rank_condition (boolean_algebra.core (option num)) := sorry --non-trivial
lemma new_lemma_74502 (h0 : functor.add_const (ordered_comm_monoid (ring linarith.comp)) (has_neg name)) : @has_exists_mul_of_le.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (ring.{0} linarith.comp)) (has_neg.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_74503 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (semigroup.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_74504 (h0 : functor.add_const (topological_space (has_zero unsigned)) linarith.comp) : @totally_separated_space.{0} (has_zero.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_74505 (h0 : functor.add_const (function.extfun Type add_group) Type) : @is_add_cyclic.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type add_group.{0}) Type h0) (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_74506 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (has_pos_part.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_pos_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_74507 (h0 : functor.add_const (semiring (has_neg pos)) (has_add linarith.comp)) : @is_noetherian_ring.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (semiring.{0} (has_neg.{0} pos)) (has_add.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_74508 (h1 : function.extfun Type topological_space) : @path_connected_space.{0} (has_top.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (has_top.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_74509 (h0 : complete_lattice (mul_one_class (mul_one_class ereal))) : complete_lattice.is_Sup_finite_compact (mul_one_class (mul_one_class ereal)) := sorry --non-trivial
lemma new_lemma_74510 (h2 : complete_lattice (with_one to_additive.value_type)) : complete_lattice.is_Sup_finite_compact (with_one to_additive.value_type) := sorry --non-trivial
lemma new_lemma_74511 (h0 : function.extfun Type (functor.comp ring has_zero)) : @strong_rank_condition.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} ring.{0} has_zero.{0} environment.implicit_infer_kind (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} ring.{0} has_zero.{0}) h0 environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_74512 (h0 : filter (complete_semilattice_Sup congr_arg_kind)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_74513 (h0 : topological_space (comm_semigroup (has_add pos))) : totally_separated_space (comm_semigroup (has_add pos)) := sorry --non-trivial
lemma new_lemma_74514 (h0 : complete_lattice (linear_ordered_comm_group (option ennreal))) : complete_lattice.is_Sup_finite_compact (linear_ordered_comm_group (option ennreal)) := sorry --non-trivial
lemma new_lemma_74515 (h0 : not (add_group (with_bot empty) -> false)) : @is_add_cyclic.{0} (with_bot.{0} empty) (@classical.by_contradiction'.{1} (add_group.{0} (with_bot.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_74516 (h0 : function.extfun nat fin) : @is_domain.{0} (has_pos_part.{0} real) (@function.extfun_app.{2 1} Type ring.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ring.{0}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (has_pos_part.{0} real))  := sorry --non-trivial
lemma new_lemma_74517 (h0 : not (complete_lattice (distrib_lattice to_additive.value_type) -> false)) : @is_compactly_generated.{0} (distrib_lattice.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (complete_lattice.{0} (distrib_lattice.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_74518 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (sub_neg_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type monoid.{0} h0 (sub_neg_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_74519 (h0 : filter (pseudo_metric_space congr_arg_kind)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_74520 (h0 : ordered_comm_monoid (canonically_ordered_comm_semiring environment.implicit_infer_kind)) : has_exists_mul_of_le (canonically_ordered_comm_semiring environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_74521 (h0 : functor.add_const (topological_space (preorder unsigned)) empty) : @preirreducible_space.{0} (preorder.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (preorder.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_74522 (h0 : list (pseudo_metric_space (has_add pos))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_74523 (h0 : functor.add_const (function.extfun (Type 1) ring) (add_comm_monoid (add_comm_monoid (has_add Type)))) : @is_principal_ideal_ring.{1} (has_neg_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) ring.{1}) (add_comm_monoid.{1} (add_comm_monoid.{1} (has_add.{1} Type))) h0) (has_neg_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_74524 (h1 : topological_space (normed_field environment.projection_info)) : path_connected_space (normed_field environment.projection_info) := sorry --non-trivial
lemma new_lemma_74525 (h0 : cancel_comm_monoid_with_zero (bin_tree (semiring empty))) : unique_factorization_monoid (bin_tree (semiring empty)) := sorry --non-trivial
lemma new_lemma_74526 (h0 : uniform_space (sub_neg_monoid pos)) : separated_space (sub_neg_monoid pos) := sorry --non-trivial
lemma new_lemma_74527 (h0 : topological_space ereal) (h1 : set (enat -> measure_theory.content ereal)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_74528 (h0 : functor.add_const (topological_space (has_zero unsigned)) name) : @preirreducible_space.{0} (has_zero.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_74529 (h0 : topological_space (has_top (random_gen num))) : discrete_topology (has_top (random_gen num)) := sorry --non-trivial
lemma new_lemma_74530 (h0 : not (topological_space (linear_ordered_comm_ring unsigned) -> false)) : @t1_space.{0} (linear_ordered_comm_ring.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_comm_ring.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_74531 (h0 : ring (encodable fun_info)) : rank_condition (encodable fun_info) := sorry --non-trivial
lemma new_lemma_74532 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (ordered_cancel_add_comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (ordered_cancel_add_comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_74533 (h0 : topological_space (add_cancel_monoid (ring pos))) : preirreducible_space (add_cancel_monoid (ring pos)) := sorry --non-trivial
lemma new_lemma_74534 (h0 : measurable_space Type) (h1 : functor.add_const (has_div Type) name) : @has_measurable_div₂.{1} Type h0 (@functor.add_const.run.{1 0} (has_div.{1} Type) name h1)  := sorry --non-trivial
lemma new_lemma_74535 (h0 : topological_space (linear_ordered_semiring (random_gen congr_arg_kind))) : irreducible_space (linear_ordered_semiring (random_gen congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_74536 (h0 : functor.add_const (topological_space (complete_distrib_lattice environment.implicit_infer_kind)) name) : @discrete_topology.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_74537 (h0 : cancel_comm_monoid_with_zero (boolean_algebra.core (option (comm_monoid unsigned)))) : unique_factorization_monoid (boolean_algebra.core (option (comm_monoid unsigned))) := sorry --non-trivial
lemma new_lemma_74538 (h0 : topological_space (random_gen (random_gen linarith.comp))) : totally_disconnected_space (random_gen (random_gen linarith.comp)) := sorry --non-trivial
lemma new_lemma_74539 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (has_top.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_top.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_74540 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (add_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_74541 (h0 : functor.add_const (ring (normed_comm_ring pos)) name) : @is_domain.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (normed_comm_ring.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_74542 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_nnnorm.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nnnorm.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_74543 (h0 : semiring (has_neg_part (ring unsigned))) : is_noetherian_ring (has_neg_part (ring unsigned)) := sorry --non-trivial
lemma new_lemma_74544 (h0 : functor.add_const (topological_space (normed_comm_ring Type)) name) : @t1_space.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (normed_comm_ring.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_74545 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (boolean_algebra.core.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_74546 (h0 : functor.add_const (topological_space (has_add linarith.comp)) Type) : @sequential_space.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_add.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_74547 (h0 : monoid (has_top (with_bot num))) : monoid.fg (has_top (with_bot num)) := sorry --non-trivial
lemma new_lemma_74548 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} nnreal (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) nnreal)  := sorry --non-trivial
lemma new_lemma_74549 (h0 : functor.add_const (group (has_inter unsigned)) num) : @is_cyclic.{0} (has_inter.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (has_inter.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_74550 (h0 : functor.add_const (topological_space (normed_linear_ordered_group unsigned)) congr_arg_kind) : @loc_path_connected_space.{0} (normed_linear_ordered_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_linear_ordered_group.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_74551 (h1 : group (complete_semilattice_Sup linarith.ineq)) : normalizer_condition (complete_semilattice_Sup linarith.ineq) := sorry --non-trivial
lemma new_lemma_74552 (h0 : add_group (linear_ordered_comm_group_with_zero reducibility_hints)) : is_add_cyclic (linear_ordered_comm_group_with_zero reducibility_hints) := sorry --non-trivial
lemma new_lemma_74553 (h0 : functor.add_const (ordered_add_comm_monoid (finset Type)) name) : @archimedean.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (ordered_add_comm_monoid.{1} (finset.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_74554 (h0 : ring (has_add to_additive.value_type)) : strong_rank_condition (has_add to_additive.value_type) := sorry --non-trivial
lemma new_lemma_74555 (h0 : functor.add_const (function.extfun (Type 1) topological_space) pos) : @normal_space.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) pos h0) (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_74556 (h1 : set (uniform_space (mul_one_class linarith.ineq))) : set.subsingleton h1 := sorry --non-trivial
lemma new_lemma_74557 (h0 : topological_space (has_nndist (has_neg_part unsigned))) : t1_space (has_nndist (has_neg_part unsigned)) := sorry --non-trivial
lemma new_lemma_74558 (h0 : functor.add_const (topological_space (has_bot empty)) empty) : @path_connected_space.{0} (has_bot.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_bot.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_74559 (h0 : topological_space (has_zero (has_neg_part (ring (has_neg_part Type))))) : totally_separated_space (has_zero (has_neg_part (ring (has_neg_part Type)))) := sorry --non-trivial
lemma new_lemma_74560 (h0 : functor.add_const (functor.comp ring has_neg_part name) Type) : @strong_rank_condition.{0} (has_neg_part.{0} name) (@functor.comp.run.{0 0 0} ring.{0} has_neg_part.{0} name (@functor.add_const.run.{0 1} (functor.comp.{0 0 0} ring.{0} has_neg_part.{0} name) Type h0))  := sorry --non-trivial
lemma new_lemma_74561 (h0 : functor.add_const (topological_space (has_neg name)) (ring (has_to_string Type))) : @locally_compact_space.{0} (has_neg.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg.{0} name)) (ring.{1} (has_to_string.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_74562 (h0 : function.extfun nat fin) : @totally_separated_space.{1} (canonically_linear_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (canonically_linear_ordered_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_74563 (h0 : functor.add_const (topological_space (ring linarith.comp)) name) : @locally_compact_space.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_74564 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_Sup.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_Sup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_74565 (h2 : complete_lattice congr_arg_kind) : is_compactly_generated congr_arg_kind := sorry --non-trivial
lemma new_lemma_74566 (h0 : ring (distrib std_gen)) : rank_condition (distrib std_gen) := sorry --non-trivial
lemma new_lemma_74567 (h0 : functor.add_const (complete_lattice (normed_linear_ordered_group unsigned)) (option unsigned)) : @is_atomistic.{0} (normed_linear_ordered_group.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (normed_linear_ordered_group.{0} unsigned)) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_74568 (h1 : topological_space (semiring (has_norm linarith.ineq))) : irreducible_space (semiring (has_norm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_74569 (h0 : functor.add_const (topological_space (ring empty)) unsigned) : @normal_space.{0} (ring.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_74570 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (canonically_ordered_comm_semiring.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (canonically_ordered_comm_semiring.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_74571 (h0 : list (pseudo_metric_space (option empty))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_74572 (h0 : list (has_pos_part (has_Inf pos))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_74573 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_nndist.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_nndist.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_74574 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (complete_semilattice_Sup.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_semilattice_Sup.{0} empty))  := sorry --non-trivial
lemma new_lemma_74575 (h0 : functor.add_const (topological_space (ordered_comm_group empty)) empty) : @path_connected_space.{0} (ordered_comm_group.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_group.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_74576 (h0 : topological_space (monoid (option ennreal))) : path_connected_space (monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_74577 (h0 : uniform_space (add_comm_monoid (has_zero unsigned))) : separated_space (add_comm_monoid (has_zero unsigned)) := sorry --non-trivial
lemma new_lemma_74578 (h0 : fin has_zero.zero) : @preconnected_space.{0} (has_add.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (has_add.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_74579 (h0 : ring (add_group (has_norm (semiring num)))) : strong_rank_condition (add_group (has_norm (semiring num))) := sorry --non-trivial
lemma new_lemma_74580 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (measure_theory.measure_space.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (measure_theory.measure_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_74581 (h0 : filter (mul_zero_class (finset (finset (option ennreal))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_74582 (h0 : functor.add_const (group (add_comm_monoid environment.implicit_infer_kind)) pos) : @normalizer_condition.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (add_comm_monoid.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_74583 (h0 : group (has_star empty)) : is_simple_group (has_star empty) := sorry --non-trivial
lemma new_lemma_74584 (h0 : has_mem.mem (id linarith.comp_source) has_emptyc.emptyc) : list.nodup (finset.pi.empty list (id linarith.comp_source) h0) := sorry --non-trivial
lemma new_lemma_74585 (h0 : complete_lattice (finset (has_Inf Type))) : is_atomistic (finset (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_74586 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (omega_complete_partial_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (omega_complete_partial_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_74587 (h0 : add_group (preorder unsigned)) : is_add_cyclic (preorder unsigned) := sorry --non-trivial
lemma new_lemma_74588 (h0 : filter (comm_ring (has_nnnorm (has_nnnorm fun_info)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_74589 (h1 : complete_lattice (comm_ring (random_gen (has_nnnorm (random_gen string_imp))))) : complete_lattice.is_Sup_finite_compact (comm_ring (random_gen (has_nnnorm (random_gen string_imp)))) := sorry --non-trivial
lemma new_lemma_74590 (h0 : topological_space (has_ssubset fun_info)) : locally_compact_space (has_ssubset fun_info) := sorry --non-trivial
lemma new_lemma_74591 (h0 : ring (topological_space (has_nnnorm (has_lt (has_nnnorm linarith.ineq))))) : is_domain (topological_space (has_nnnorm (has_lt (has_nnnorm linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_74592 (h0 : function.extfun (Type 1) topological_space) : @totally_separated_space.{1} (has_zero.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_zero.{1} Type))  := sorry --non-trivial
lemma new_lemma_74593 (h0 : function.extfun Type (functor.add_const (topological_space pos))) : @preirreducible_space.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} pos)) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_74594 (h0 : functor.add_const (function.extfun (Type 1) group) Type) : @group.fg.{1} (generalized_boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) group.{1}) Type h0) (generalized_boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_74595 (h0 : functor.add_const (complete_lattice (ring pos)) (ring Type)) : @is_compactly_generated.{0} (ring.{0} pos) (@functor.add_const.run.{0 1} (complete_lattice.{0} (ring.{0} pos)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_74596 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (boolean_algebra.core.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.core.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_74597 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} unsigned (@function.extfun_app.{2 1} Type topological_space.{0} h0 unsigned)  := sorry --non-trivial
lemma new_lemma_74598 (h0 : functor.add_const (add_monoid (normed_comm_ring environment.implicit_infer_kind)) name) : @add_monoid.fg.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (add_monoid.{0} (normed_comm_ring.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_74599 (h0 : functor.add_const (topological_space (has_to_string environment.implicit_infer_kind)) name) : @path_connected_space.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_74600 (h0 : topological_space (has_inner unsigned congr_arg_kind)) : totally_separated_space (has_inner unsigned congr_arg_kind) := sorry --non-trivial
lemma new_lemma_74601 (h0 : functor.add_const (topological_space (has_pos_part Type)) linarith.comp) : @topological_space.separable_space.{1} (has_pos_part.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_pos_part.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_74602 (h0 : functor.add_const (list (normed_comm_ring pos)) unsigned) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_74603 (h1 : has_mem.mem (has_top congr_arg_kind) has_emptyc.emptyc) : @normalizer_condition.{0} (has_top.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type group.{0} (has_top.{0} congr_arg_kind) h1)  := sorry --non-trivial
lemma new_lemma_74604 (h0 : functor.add_const (function.extfun Type topological_space) (normed_comm_ring linarith.comp)) : @totally_disconnected_space.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (normed_comm_ring.{0} linarith.comp) h0) (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_74605 (h0 : filter (has_inter congr_arg_kind)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_74606 (h0 : functor.add_const (ring (left_cancel_monoid congr_arg_kind)) num) : @strong_rank_condition.{0} (left_cancel_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ring.{0} (left_cancel_monoid.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_74607 (h0 : function.extfun Type topological_space) : @normal_space.{0} (has_one.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_one.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_74608 (h0 : functor.add_const (fin has_zero.zero) Type) : @add_monoid.fg.{0} (comm_semigroup.{0} real) (@matrix.vec_empty.{0} (add_monoid.{0} (comm_semigroup.{0} real)) (@functor.add_const.run.{0 1} (fin (@has_zero.zero.{0} nat nat.has_zero)) Type h0))  := sorry --non-trivial
lemma new_lemma_74609 (h0 : group (denumerable (has_nnnorm char))) : group.fg (denumerable (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_74610 (h0 : ring (has_to_string (ring Type))) : strong_rank_condition (has_to_string (ring Type)) := sorry --non-trivial
lemma new_lemma_74611 (h0 : cancel_comm_monoid_with_zero (boolean_algebra (add_comm_monoid environment.implicit_infer_kind))) : unique_factorization_monoid (boolean_algebra (add_comm_monoid environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_74612 (h0 : topological_space (comm_group (option pos))) : irreducible_space (comm_group (option pos)) := sorry --non-trivial
lemma new_lemma_74613 (h0 : ring (has_compl linarith.comp)) : rank_condition (has_compl linarith.comp) := sorry --non-trivial
lemma new_lemma_74614 (h0 : topological_space (ring empty)) : discrete_topology (ring empty) := sorry --non-trivial
lemma new_lemma_74615 (h0 : uniform_space (has_compl enat)) : complete_space (has_compl enat) := sorry --non-trivial
lemma new_lemma_74616 (h0 : ring (semiring to_additive.value_type)) : strong_rank_condition (semiring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_74617 (h0 : not (complete_lattice (measurable_space to_additive.value_type) -> false)) : is_atomistic (measurable_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_74618 (h2 : complete_lattice (linear_ordered_add_comm_group to_additive.value_type)) : complete_lattice.is_Sup_finite_compact (linear_ordered_add_comm_group to_additive.value_type) := sorry --non-trivial
lemma new_lemma_74619 (h0 : not (add_group (random_gen (has_nnnorm linarith.ineq)) -> false)) : @is_add_cyclic.{0} (random_gen.{0} (has_nnnorm.{0} linarith.ineq)) (@classical.by_contradiction'.{1} (add_group.{0} (random_gen.{0} (has_nnnorm.{0} linarith.ineq))) h0)  := sorry --non-trivial
lemma new_lemma_74620 (h0 : ring (has_bot (option empty))) : is_domain (has_bot (option empty)) := sorry --non-trivial
lemma new_lemma_74621 (h0 : function.extfun (uniform_space Type -> false) (fun (x : uniform_space Type -> false), false)) : @separated_space.{1} Type (@classical.by_contradiction'.{2} (uniform_space.{1} Type) (@function.extfun_app.{0 0} (uniform_space.{1} Type → false) (λ (x : uniform_space.{1} Type → false), false) h0))  := sorry --non-trivial
lemma new_lemma_74622 (h1 : topological_space (random_gen string_imp)) : locally_compact_space (random_gen string_imp) := sorry --non-trivial
lemma new_lemma_74623 (h0 : topological_space (has_sub (semiring unsigned))) : discrete_topology (has_sub (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_74624 (h0 : functor.add_const (ring (ordered_comm_monoid pos)) name) : @rank_condition.{0} (ordered_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (ordered_comm_monoid.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_74625 (h0 : cancel_comm_monoid_with_zero (ordered_comm_monoid (has_neg (has_neg (has_neg Type))))) : unique_factorization_monoid (ordered_comm_monoid (has_neg (has_neg (has_neg Type)))) := sorry --non-trivial
lemma new_lemma_74626 (h0 : functor.add_const (ordered_comm_monoid (ring pos)) (has_neg_part name)) : @has_exists_mul_of_le.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (ring.{0} pos)) (has_neg_part.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_74627 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (semiring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (semiring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_74628 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (with_bot.{0} (random_gen.{0} (random_gen.{0} (has_inv.{0} (random_gen.{0} linarith.ineq))))) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (with_bot.{0} (random_gen.{0} (random_gen.{0} (has_inv.{0} (random_gen.{0} linarith.ineq))))))  := sorry --non-trivial
lemma new_lemma_74629 (h1 : topological_space (comm_ring (random_gen (random_gen (random_gen (random_gen (random_gen char))))))) : t0_space (comm_ring (random_gen (random_gen (random_gen (random_gen (random_gen char)))))) := sorry --non-trivial
lemma new_lemma_74630 (h0 : semiring (semigroup (has_sdiff Type))) : is_noetherian_ring (semigroup (has_sdiff Type)) := sorry --non-trivial
lemma new_lemma_74631 (h0 : list (with_bot (comm_ring (comm_ring (comm_ring (has_ssubset (comm_ring (random_gen (random_gen fun_info))))))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_74632 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (has_to_string.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_to_string.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_74633 (h0 : functor.add_const (topological_space (linear_ordered_comm_monoid_with_zero num)) empty) : @totally_disconnected_space.{0} (linear_ordered_comm_monoid_with_zero.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_comm_monoid_with_zero.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_74634 (h0 : list (has_add ennreal)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_74635 (h0 : complete_lattice (has_one fun_info)) : is_atomistic (has_one fun_info) := sorry --non-trivial
lemma new_lemma_74636 (h0 : add_monoid Type) : add_monoid.fg Type := sorry --non-trivial
lemma new_lemma_74637 (h0 : monoid (comm_group linarith.comp)) : monoid.fg (comm_group linarith.comp) := sorry --non-trivial
lemma new_lemma_74638 (h0 : complete_lattice (has_star (semiring (semiring unsigned)))) : complete_lattice.is_Sup_finite_compact (has_star (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_74639 (h0 : group (id (has_inv (random_gen linarith.comp_source)))) : is_cyclic (id (has_inv (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_74640 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @preconnected_space.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_74641 (h1 : set (char -> mul_one_class char)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_74642 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_dist.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_dist.{0} empty))  := sorry --non-trivial
lemma new_lemma_74643 (h0 : topological_space (canonically_linear_ordered_monoid (has_add real))) : irreducible_space (canonically_linear_ordered_monoid (has_add real)) := sorry --non-trivial
lemma new_lemma_74644 (h0 : add_comm_group (add_comm_semigroup fun_info)) (h1 : has_norm (add_comm_semigroup fun_info)) : normed_group.core (add_comm_semigroup fun_info) := sorry --non-trivial
lemma new_lemma_74645 (h1 : complete_lattice (encodable char)) : is_compactly_generated (encodable char) := sorry --non-trivial
lemma new_lemma_74646 (h0 : ring (distrib_lattice (denumerable (fintype (linear_ordered_add_comm_group char))))) : is_domain (distrib_lattice (denumerable (fintype (linear_ordered_add_comm_group char)))) := sorry --non-trivial
lemma new_lemma_74647 (h0 : topological_space (ring (boolean_algebra name))) : normal_space (ring (boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_74648 (h0 : group (has_nndist (has_to_string Type))) : is_simple_group (has_nndist (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_74649 (h0 : ordered_comm_monoid (has_nndist (option unsigned))) : has_exists_mul_of_le (has_nndist (option unsigned)) := sorry --non-trivial
lemma new_lemma_74650 (h0 : not (has_mem.mem uniform_space has_emptyc.emptyc -> false)) : @separated_space.{0} (has_emptyc.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type uniform_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) uniform_space.{0} (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) uniform_space.{0} (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type)))) h0)) (has_emptyc.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_74651 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (canonically_ordered_comm_semiring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} name))  := sorry --non-trivial
lemma new_lemma_74652 (h0 : functor.add_const (add_monoid (has_neg_part pos)) (option unsigned)) : @add_monoid.fg.{0} (has_neg_part.{0} pos) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_neg_part.{0} pos)) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_74653 (h0 : complete_lattice (topological_space to_additive.value_type)) : is_compactly_generated (topological_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_74654 (h0 : topological_space (ordered_ring (semiring (semiring (semiring (semiring empty)))))) : preirreducible_space (ordered_ring (semiring (semiring (semiring (semiring empty))))) := sorry --non-trivial
lemma new_lemma_74655 (h0 : finset (monoid_with_zero pos)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_74656 (h0 : filter (semiring (semiring congr_arg_kind))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_74657 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (mul_zero_class num)) := sorry --non-trivial
lemma new_lemma_74658 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (canonically_linear_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_linear_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_74659 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (finset.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (finset.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_74660 (h0 : semiring (simple_graph (ring (has_neg (finset (finset (finset pos))))))) : is_noetherian_ring (simple_graph (ring (has_neg (finset (finset (finset pos)))))) := sorry --non-trivial
lemma new_lemma_74661 (h0 : group (id (random_gen fun_info))) : normalizer_condition (id (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_74662 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (ordered_comm_monoid.{0} real) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (ordered_comm_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_74663 (h0 : not (ring (has_norm unsigned) -> false)) : @is_domain.{0} (has_norm.{0} unsigned) (@classical.by_contradiction'.{1} (ring.{0} (has_norm.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_74664 (h1 : uniform_space (distrib (has_compl (has_div linarith.comp_source)))) : complete_space (distrib (has_compl (has_div linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_74665 (h0 : functor.add_const (topological_space (sub_neg_monoid pos)) linarith.comp) : @totally_disconnected_space.{0} (sub_neg_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (sub_neg_monoid.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_74666 (h0 : functor.add_const (add_monoid (normed_comm_ring Type)) name) : @add_monoid.fg.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (add_monoid.{1} (normed_comm_ring.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_74667 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (has_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_74668 (h0 : cancel_comm_monoid_with_zero (has_bot (sub_neg_monoid Type))) : unique_factorization_monoid (has_bot (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_74669 (h0 : functor.add_const (ordered_comm_monoid (has_zero name)) pos) : @has_exists_mul_of_le.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_zero.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_74670 (h0 : topological_space (random_gen (has_norm num))) : discrete_topology (random_gen (has_norm num)) := sorry --non-trivial
lemma new_lemma_74671 (h0 : function.extfun nat fin) : @t0_space.{1} (ordered_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@matrix.vec_empty.{2} (function.extfun.{3 2} (Type 1) topological_space.{1}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (ordered_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_74672 (h0 : topological_space (with_bot (semiring linarith.comp))) : path_connected_space (with_bot (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_74673 (h0 : functor.add_const (function.extfun Type ring) Type) : @rank_condition.{0} (has_to_string.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ring.{0}) Type h0) (has_to_string.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_74674 (h0 : topological_space (complete_distrib_lattice (option (has_nndist pos)))) : normal_space (complete_distrib_lattice (option (has_nndist pos))) := sorry --non-trivial
lemma new_lemma_74675 (h0 : functor.add_const (topological_space (ordered_comm_monoid linarith.comp)) linarith.comp) : @irreducible_space.{0} (ordered_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_monoid.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_74676 (h0 : functor.add_const (topological_space znum) empty) : @discrete_topology.{0} znum (@functor.add_const.run.{0 0} (topological_space.{0} znum) empty h0)  := sorry --non-trivial
lemma new_lemma_74677 (h0 : topological_space (comm_group (has_to_string environment.implicit_infer_kind))) : preconnected_space (comm_group (has_to_string environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_74678 (h0 : preorder string.iterator_imp) (h1 : set string.iterator_imp) : set.is_pwo h1 := sorry --non-trivial
lemma new_lemma_74679 (h0 : function.extfun (Type 1) ring) : @strong_rank_condition.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_74680 (h0 : measurable_space (distrib char)) (h1 : filter (distrib char)) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_74681 (h0 : topological_space (simple_graph real)) : locally_compact_space (simple_graph real) := sorry --non-trivial
lemma new_lemma_74682 (h0 : group (finset (has_add linarith.comp))) : group.fg (finset (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_74683 (h0 : ring (random_gen (semiring (semiring num)))) : strong_rank_condition (random_gen (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_74684 (h0 : topological_space (semigroup linarith.comp)) : totally_separated_space (semigroup linarith.comp) := sorry --non-trivial
lemma new_lemma_74685 (h0 : topological_space (semiring (semiring (semiring num)))) : locally_compact_space (semiring (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_74686 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (add_cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_74687 (h0 : function.extfun (Type 1) (functor.add_const (filter (ring pos)))) : countable_Inter_filter (functor.add_const.run (function.extfun_app h0 Type)) := sorry --non-trivial
lemma new_lemma_74688 (h0 : topological_space (complete_linear_order unsigned)) : locally_compact_space (complete_linear_order unsigned) := sorry --non-trivial
lemma new_lemma_74689 (h0 : not (function.extfun Type monoid -> false)) : @monoid.fg.{0} unsigned (@function.extfun_app.{2 1} Type monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type monoid.{0}) h0) unsigned)  := sorry --non-trivial
lemma new_lemma_74690 (h0 : functor.add_const (add_monoid (simple_graph linarith.comp)) Type) : @add_monoid.fg.{0} (simple_graph.{0} linarith.comp) (@functor.add_const.run.{0 1} (add_monoid.{0} (simple_graph.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_74691 (h0 : finset (normed_comm_ring (has_to_string (has_to_string pos)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_74692 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (with_bot.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (with_bot.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_74693 (h1 : set (simple_graph (normed_field reducibility_hints))) : set.finite h1 := sorry --non-trivial
lemma new_lemma_74694 (h0 : ring (has_neg (option pos))) : is_domain (has_neg (option pos)) := sorry --non-trivial
lemma new_lemma_74695 (h1 : add_group bool) : is_add_cyclic bool := sorry --non-trivial
lemma new_lemma_74696 (h0 : group (generalized_boolean_algebra (ring linarith.comp))) : normalizer_condition (generalized_boolean_algebra (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_74697 (h0 : function.extfun nat fin) : @topological_space.separable_space.{1} (ring.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (ring.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_74698 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (linear_ordered_comm_monoid_with_zero.{0} empty) (@functor.add_const.run.{0 0} (add_monoid.{0} (linear_ordered_comm_monoid_with_zero.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (add_monoid.{0} (linear_ordered_comm_monoid_with_zero.{0} empty))) (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 (functor.add_const.{0 0} (add_monoid.{0} (linear_ordered_comm_monoid_with_zero.{0} empty)))) empty))  := sorry --non-trivial
lemma new_lemma_74699 (h0 : uniform_space (uniform_space (metric_space (metric_space to_additive.value_type)))) : complete_space (uniform_space (metric_space (metric_space to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_74700 (h0 : group (has_inv fun_info)) : is_cyclic (has_inv fun_info) := sorry --non-trivial
lemma new_lemma_74701 (h0 : topological_space (has_to_string (ring (has_add pos)))) : t0_space (has_to_string (ring (has_add pos))) := sorry --non-trivial
lemma new_lemma_74702 (h0 : function.extfun Type ring) : @is_domain.{0} (has_dist.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_dist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_74703 (h0 : functor.add_const (complete_lattice (measurable_space.dynkin_system unsigned)) empty) : @is_atomistic.{0} (measurable_space.dynkin_system.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (measurable_space.dynkin_system.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_74704 (h0 : functor.add_const (fin has_zero.zero) (has_Inf real)) : @is_simple_group.{1} (add_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (group.{1} (add_comm_monoid.{1} Type)) (@functor.add_const.run.{0 0} (fin (@has_zero.zero.{0} nat nat.has_zero)) real (@matrix.vec_empty.{0} (functor.add_const.{0 0} (fin (@has_zero.zero.{0} nat nat.has_zero)) real) (@functor.add_const.run.{0 0} (fin (@has_zero.zero.{0} nat nat.has_zero)) real (@matrix.vec_empty.{0} (functor.add_const.{0 0} (fin (@has_zero.zero.{0} nat nat.has_zero)) real) (@functor.add_const.run.{0 0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (has_Inf.{0} real) h0))))))  := sorry --non-trivial
lemma new_lemma_74705 (h0 : ring (non_unital_non_assoc_semiring (random_gen string_imp))) : rank_condition (non_unital_non_assoc_semiring (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_74706 (h0 : topological_space (add_cancel_monoid (ring pos))) : normal_space (add_cancel_monoid (ring pos)) := sorry --non-trivial
lemma new_lemma_74707 (h0 : finset (has_add (finset environment.implicit_infer_kind))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_74708 (h0 : topological_space (normed_group (id (semiring congr_arg_kind)))) : normal_space (normed_group (id (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_74709 (h0 : functor.add_const (topological_space (left_cancel_monoid empty)) num) : @t0_space.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_74710 (h0 : function.extfun nat fin) : @discrete_topology.{0} (has_bot.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (has_bot.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_74711 (h0 : not (complete_lattice (has_div (mul_one_class string_imp)) -> false)) : @is_compactly_generated.{0} (has_div.{0} (mul_one_class.{0} string_imp)) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_div.{0} (mul_one_class.{0} string_imp))) h0)  := sorry --non-trivial
lemma new_lemma_74712 (h0 : has_mem.mem (has_top linarith.comp_source) has_emptyc.emptyc) : @discrete_topology.{0} (has_top.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_top.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_74713 (h0 : topological_space (mul_zero_class Type)) : normal_space (mul_zero_class Type) := sorry --non-trivial
lemma new_lemma_74714 (h0 : functor.add_const (group (semigroup (has_neg linarith.comp))) (has_pos_part pos)) : @is_cyclic.{0} (semigroup.{0} (has_neg.{0} linarith.comp)) (@functor.add_const.run.{0 0} (group.{0} (semigroup.{0} (has_neg.{0} linarith.comp))) (has_pos_part.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_74715 (h0 : functor.add_const (topological_space (add_semigroup empty)) (linear_ordered_comm_monoid_with_zero empty)) : @t0_space.{0} (add_semigroup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_semigroup.{0} empty)) (linear_ordered_comm_monoid_with_zero.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_74716 (h0 : functor.add_const (add_monoid (ordered_comm_ring pos)) linarith.comp) : @add_monoid.fg.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (add_monoid.{0} (ordered_comm_ring.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_74717 (h0 : has_mem.mem (has_emptyc linarith.comp) has_emptyc.emptyc) : @is_domain.{0} (has_emptyc.{0} linarith.comp) (@finset.pi.empty.{1 0} Type ring.{0} (has_emptyc.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_74718 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @t0_space.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_74719 (h0 : functor.add_const (topological_space (boolean_algebra.core Type)) name) : @discrete_topology.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.core.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_74720 (h0 : ring (add_left_cancel_semigroup num)) : is_domain (add_left_cancel_semigroup num) := sorry --non-trivial
lemma new_lemma_74721 (h0 : topological_space (has_to_string Type)) : topological_space.separable_space (has_to_string Type) := sorry --non-trivial
lemma new_lemma_74722 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (canonically_ordered_comm_semiring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_ordered_comm_semiring.{0} pos))  := sorry --non-trivial
lemma new_lemma_74723 (h0 : has_mem.mem (has_norm (has_top empty)) has_emptyc.emptyc) : @locally_compact_space.{0} (has_norm.{0} (has_top.{0} empty)) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_norm.{0} (has_top.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_74724 (h0 : functor.add_const (uniform_space (comm_monoid empty)) empty) : @separated_space.{0} (comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (comm_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_74725 (h0 : function.extfun Type group) : @group.fg.{0} (add_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (add_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_74726 (h0 : set (add_comm_semigroup char -> std_gen)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_74727 (h0 : functor.add_const (group (semigroup linarith.comp)) pos) : @is_simple_group.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (semigroup.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_74728 (h0 : filter (finset (mul_one_class Type))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_74729 (h0 : function.extfun Type group) : @group.fg.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_74730 (h0 : not (functor.add_const Prop (has_one empty) -> false)) : functor.add_const.run (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_74731 (h0 : functor.comp topological_space has_to_string name) : @loc_path_connected_space.{0} (has_to_string.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} has_to_string.{0} name h0)  := sorry --non-trivial
lemma new_lemma_74732 (h0 : topological_space (has_nndist (comm_group (comm_group (comm_group Type))))) : preconnected_space (has_nndist (comm_group (comm_group (comm_group Type)))) := sorry --non-trivial
lemma new_lemma_74733 (h0 : group (measure_theory.measure_space unsigned)) : group.fg (measure_theory.measure_space unsigned) := sorry --non-trivial
lemma new_lemma_74734 (h0 : ordered_add_comm_monoid (has_nndist (option (option ennreal)))) : archimedean (has_nndist (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_74735 (h1 : uniform_space (random_gen char)) : complete_space (random_gen char) := sorry --non-trivial
lemma new_lemma_74736 (h0 : functor.add_const (add_group (ordered_comm_ring linarith.comp)) pos) : @is_add_cyclic.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_group.{0} (ordered_comm_ring.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_74737 (h1 : topological_space (semiring (random_gen (random_gen linarith.comp_source)))) : t0_space (semiring (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_74738 (h0 : functor.add_const (complete_lattice (mul_zero_class Type)) Type) : @is_compactly_generated.{1} (mul_zero_class.{1} Type) (@functor.add_const.run.{1 1} (complete_lattice.{1} (mul_zero_class.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_74739 (h0 : functor.add_const (ring (boolean_algebra.core Type)) linarith.comp) : @is_domain.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (boolean_algebra.core.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_74740 (h0 : topological_space (normed_group unsigned)) : t0_space (normed_group unsigned) := sorry --non-trivial
lemma new_lemma_74741 (h0 : ring (denumerable (has_nnnorm (has_nnnorm linarith.comp_source)))) : rank_condition (denumerable (has_nnnorm (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_74742 (h0 : functor.add_const (uniform_space (finset Type)) (ring environment.implicit_infer_kind)) : @separated_space.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (finset.{1} Type)) (ring.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_74743 (h0 : ring (simple_graph (mul_one_class (mul_one_class std_gen)))) : is_domain (simple_graph (mul_one_class (mul_one_class std_gen))) := sorry --non-trivial
lemma new_lemma_74744 (h0 : filter (boolean_algebra.core (option name))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_74745 (h0 : function.extfun Type group) : @group.fg.{0} (topological_space.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} h0 (topological_space.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_74746 (h0 : has_mem.mem (has_norm fun_info) has_emptyc.emptyc) : @discrete_topology.{0} (has_norm.{0} fun_info) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_norm.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_74747 (h0 : lattice (random_gen (random_gen reducibility_hints))) : is_modular_lattice (random_gen (random_gen reducibility_hints)) := sorry --non-trivial
lemma new_lemma_74748 (h0 : topological_space (distrib_lattice string_imp)) : irreducible_space (distrib_lattice string_imp) := sorry --non-trivial
lemma new_lemma_74749 (h0 : functor.add_const (uniform_space (plift empty)) empty) : @separated_space.{1} (plift.{1} empty) (@functor.add_const.run.{1 0} (uniform_space.{1} (plift.{1} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_74750 (h0 : uniform_space (has_neg (finset (ring linarith.comp)))) : separated_space (has_neg (finset (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_74751 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (left_cancel_monoid.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (left_cancel_monoid.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_74752 (h0 : functor.add_const (topological_space (normed_linear_ordered_group congr_arg_kind)) empty) : @t0_space.{0} (normed_linear_ordered_group.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_linear_ordered_group.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_74753 (h0 : topological_space (canonically_linear_ordered_monoid (sub_neg_monoid real))) : irreducible_space (canonically_linear_ordered_monoid (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_74754 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (has_Inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_Inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_74755 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (random_gen.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (random_gen.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_74756 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (ordered_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (ordered_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_74757 (h0 : topological_space (has_inter num)) : normal_space (has_inter num) := sorry --non-trivial
lemma new_lemma_74758 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (has_pos_part.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_pos_part.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_74759 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_74760 (h0 : group (encodable (random_gen (random_gen linarith.comp_source)))) : group.fg (encodable (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_74761 (h0 : has_mem.mem comm_monoid_with_zero has_emptyc.emptyc) : @wf_dvd_monoid.{0} (has_emptyc.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type comm_monoid_with_zero.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) comm_monoid_with_zero.{0} h0) (has_emptyc.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_74762 (h0 : group (has_zero (has_neg_part (has_neg_part (comm_group Type))))) : normalizer_condition (has_zero (has_neg_part (has_neg_part (comm_group Type)))) := sorry --non-trivial
lemma new_lemma_74763 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (normed_group.{0} empty) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (normed_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_74764 (h2 : complete_lattice (distrib linarith.ineq)) : is_compactly_generated (distrib linarith.ineq) := sorry --non-trivial
lemma new_lemma_74765 (h0 : cancel_comm_monoid_with_zero (add_group num)) : unique_factorization_monoid (add_group num) := sorry --non-trivial
lemma new_lemma_74766 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_group.{0} h0 (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_74767 (h0 : topological_space (has_sub (semiring (semiring unsigned)))) : irreducible_space (has_sub (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_74768 (h0 : group (semigroup (cancel_monoid name))) : is_simple_group (semigroup (cancel_monoid name)) := sorry --non-trivial
lemma new_lemma_74769 (h0 : topological_space (complete_linear_order congr_arg_kind)) : irreducible_space (complete_linear_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_74770 (h0 : topological_space (complete_semilattice_Sup (has_norm to_additive.value_type))) : t0_space (complete_semilattice_Sup (has_norm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_74771 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_74772 (h0 : uniform_space (measurable_space num)) : separated_space (measurable_space num) := sorry --non-trivial
lemma new_lemma_74773 (h0 : semiring (ordered_comm_monoid (has_Inf (ring (has_neg (has_nndist pos)))))) : is_noetherian_ring (ordered_comm_monoid (has_Inf (ring (has_neg (has_nndist pos))))) := sorry --non-trivial
lemma new_lemma_74774 (h0 : complete_lattice (boolean_algebra (has_Inf (has_Inf linarith.comp)))) : complete_lattice.is_Sup_finite_compact (boolean_algebra (has_Inf (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_74775 (h0 : complete_lattice (ring (has_neg (has_add name)))) : complete_lattice.is_Sup_finite_compact (ring (has_neg (has_add name))) := sorry --non-trivial
lemma new_lemma_74776 (h0 : functor.add_const (topological_space (linear_order unsigned)) congr_arg_kind) : @discrete_topology.{0} (linear_order.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_order.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_74777 (h0 : group (id string_imp)) : is_cyclic (id string_imp) := sorry --non-trivial
lemma new_lemma_74778 (h0 : finset (add_comm_monoid (has_to_string pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_74779 (h0 : functor.add_const (add_group (boolean_algebra.core unsigned)) (mul_zero_class unsigned)) : @is_add_cyclic.{0} (boolean_algebra.core.{0} unsigned) (@functor.add_const.run.{0 0} (add_group.{0} (boolean_algebra.core.{0} unsigned)) (mul_zero_class.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_74780 (h0 : function.extfun Type group) : @is_simple_group.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} h0 (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_74781 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (sub_neg_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (sub_neg_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_74782 (h0 : list (boolean_algebra (has_nndist Type))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_74783 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (has_inter num)) := sorry --non-trivial
lemma new_lemma_74784 (h0 : topological_space (add_cancel_monoid (finset (finset pos)))) : normal_space (add_cancel_monoid (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_74785 (h0 : fin has_zero.zero) : @sequential_space.{1} (has_add.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (has_add.{1} Type)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)))  := sorry --non-trivial
lemma new_lemma_74786 (h0 : functor.add_const (topological_space (simple_graph linarith.comp)) Type) : @preconnected_space.{0} (simple_graph.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (simple_graph.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_74787 (h0 : not (ring (has_norm linarith.ineq) -> false)) : @rank_condition.{0} (has_norm.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (has_norm.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_74788 (h0 : topological_space (normed_lattice_add_comm_group linarith.comp)) : t1_space (normed_lattice_add_comm_group linarith.comp) := sorry --non-trivial
lemma new_lemma_74789 (h0 : topological_space (comm_ring (random_gen to_additive.value_type))) : locally_compact_space (comm_ring (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_74790 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_bot.{0} (option.{0} (option.{0} empty))) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_bot.{0} (option.{0} (option.{0} empty))))  := sorry --non-trivial
lemma new_lemma_74791 (h0 : finset (cancel_monoid congr_arg_kind)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_74792 (h0 : uniform_space (semigroup (option unsigned))) : separated_space (semigroup (option unsigned)) := sorry --non-trivial
lemma new_lemma_74793 (h0 : complete_lattice (complete_semilattice_Sup (semiring empty))) : is_atomistic (complete_semilattice_Sup (semiring empty)) := sorry --non-trivial
lemma new_lemma_74794 (h0 : ring (normed_group (has_norm congr_arg_kind))) : strong_rank_condition (normed_group (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_74795 (h0 : topological_space (has_to_string name)) : discrete_topology (has_to_string name) := sorry --non-trivial
lemma new_lemma_74796 (h1 : complete_lattice (semi_normed_ring (random_gen linarith.comp_source))) : is_compactly_generated (semi_normed_ring (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_74797 (h0 : functor.add_const (list (ring Type)) pos) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_74798 (h0 : function.extfun Type topological_space) (h1 : group (boolean_algebra.core name)) : @topological_group.{0} (boolean_algebra.core.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} name)) h1  := sorry --non-trivial
lemma new_lemma_74799 (h0 : function.extfun Type group) : @is_cyclic.{0} (complete_semilattice_Sup.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (complete_semilattice_Sup.{0} empty))  := sorry --non-trivial
lemma new_lemma_74800 (h1 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} (semiring.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h1) (semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_74801 (h2 : ring enat) : is_domain enat := sorry --non-trivial
lemma new_lemma_74802 (h0 : functor.add_const (topological_space (ordered_cancel_add_comm_monoid empty)) unsigned) : @preirreducible_space.{0} (ordered_cancel_add_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_cancel_add_comm_monoid.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_74803 (h1 : ring complex) : strong_rank_condition complex := sorry --non-trivial
lemma new_lemma_74804 (h0 : functor.add_const (ordered_add_comm_monoid (has_zero unsigned)) unsigned) : @archimedean.{0} (has_zero.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_zero.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_74805 (h0 : topological_space (has_bot name)) : t1_space (has_bot name) := sorry --non-trivial
lemma new_lemma_74806 (h0 : functor.add_const (complete_lattice (ring linarith.comp)) pos) : @is_compactly_generated.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ring.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_74807 (h0 : not (ring (has_sub congr_arg_kind) -> false)) : @strong_rank_condition.{0} (has_sub.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (ring.{0} (has_sub.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_74808 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_one.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_one.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_74809 (h0 : topological_space ereal) : path_connected_space ereal := sorry --non-trivial
lemma new_lemma_74810 (h0 : semiring (with_bot (measurable_space.dynkin_system empty))) : is_noetherian_ring (with_bot (measurable_space.dynkin_system empty)) := sorry --non-trivial
lemma new_lemma_74811 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (canonically_ordered_comm_semiring.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (canonically_ordered_comm_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_74812 (h0 : ring (with_zero empty)) : strong_rank_condition (with_zero empty) := sorry --non-trivial
lemma new_lemma_74813 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} num))))) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (random_gen.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} num))))))  := sorry --non-trivial
lemma new_lemma_74814 (h0 : functor.add_const (topological_space (normed_comm_ring Type)) environment.implicit_infer_kind) : @path_connected_space.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (normed_comm_ring.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_74815 (h0 : topological_space (nondiscrete_normed_field string.iterator_imp)) (h1 : set (nondiscrete_normed_field string.iterator_imp)) : is_path_connected h1 := sorry --non-trivial
lemma new_lemma_74816 (h0 : ring (fintype (fintype (add_monoid name)))) : strong_rank_condition (fintype (fintype (add_monoid name))) := sorry --non-trivial
lemma new_lemma_74817 (h0 : filter (with_bot (has_norm linarith.comp))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_74818 (h0 : functor.add_const (monoid (has_zero name)) (finset linarith.comp)) : @monoid.fg.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (monoid.{0} (has_zero.{0} name)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_74819 (h0 : functor.add_const (function.extfun Type add_group) linarith.comp) : @is_add_cyclic.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_group.{0}) linarith.comp h0) (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_74820 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (add_group.{0} num) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (add_group.{0} num))  := sorry --non-trivial
lemma new_lemma_74821 (h0 : topological_space (distrib_lattice empty)) : normal_space (distrib_lattice empty) := sorry --non-trivial
lemma new_lemma_74822 (h2 : complete_lattice (uniform_space (mul_one_class string.iterator_imp))) : is_compactly_generated (uniform_space (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_74823 (h0 : topological_space (has_to_string (monoid (metric_space Type)))) : sequential_space (has_to_string (monoid (metric_space Type))) := sorry --non-trivial
lemma new_lemma_74824 (h0 : functor.add_const (ring (has_nndist empty)) empty) : @rank_condition.{0} (has_nndist.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (has_nndist.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_74825 (h0 : function.extfun Type ring) : @rank_condition.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_cancel_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_74826 (h0 : function.extfun (finset Type) (has_mem.mem (random_gen linarith.ineq))) : @is_domain.{0} (random_gen.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type ring.{0} (random_gen.{0} linarith.ineq) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} linarith.ineq)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_74827 (h0 : topological_space (normed_comm_ring ennreal)) : path_connected_space (normed_comm_ring ennreal) := sorry --non-trivial
lemma new_lemma_74828 (h0 : group (has_neg (has_neg pos))) : is_simple_group (has_neg (has_neg pos)) := sorry --non-trivial
lemma new_lemma_74829 (h0 : topological_space (has_nndist (option (option pos)))) : totally_disconnected_space (has_nndist (option (option pos))) := sorry --non-trivial
lemma new_lemma_74830 (h0 : not (topological_space (measure_theory.measure_space num) -> false)) : @discrete_topology.{0} (measure_theory.measure_space.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (measure_theory.measure_space.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_74831 (h0 : monoid (ring (has_neg linarith.comp))) : monoid.fg (ring (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_74832 (h0 : functor.add_const (ring (ring environment.implicit_infer_kind)) linarith.comp) : @rank_condition.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (ring.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_74833 (h0 : group (with_one (has_inv fun_info))) : group.fg (with_one (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_74834 (h0 : complete_lattice (denumerable (bin_tree string_imp))) : is_compactly_generated (denumerable (bin_tree string_imp)) := sorry --non-trivial
lemma new_lemma_74835 (h0 : uniform_space (linear_ordered_field pos)) : complete_space (linear_ordered_field pos) := sorry --non-trivial
lemma new_lemma_74836 (h0 : function.extfun Type group) : @normalizer_condition.{0} (monoid_with_zero.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (monoid_with_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_74837 (h0 : group (linear_ordered_comm_group (option (option (option (option ennreal)))))) : is_simple_group (linear_ordered_comm_group (option (option (option (option ennreal))))) := sorry --non-trivial
lemma new_lemma_74838 (h0 : fin has_zero.zero) : @is_domain.{0} (has_Inf.{0} real) (@function.extfun_app.{2 1} Type ring.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ring.{0}) h0) (has_Inf.{0} real))  := sorry --non-trivial
lemma new_lemma_74839 (h0 : functor.add_const (topological_space (finset ennreal)) num) : @preirreducible_space.{0} (finset.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} ennreal)) num h0)  := sorry --non-trivial
lemma new_lemma_74840 (h0 : list (has_top (has_nnnorm to_additive.value_type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_74841 (h0 : group (mul_zero_class empty)) : group.fg (mul_zero_class empty) := sorry --non-trivial
lemma new_lemma_74842 (h0 : uniform_space (has_add unsigned)) : separated_space (has_add unsigned) := sorry --non-trivial
lemma new_lemma_74843 (h0 : uniform_space (has_one (has_norm (has_norm (has_top (semiring num)))))) : separated_space (has_one (has_norm (has_norm (has_top (semiring num))))) := sorry --non-trivial
lemma new_lemma_74844 (h0 : group (has_zero (finset (finset linarith.comp)))) : is_simple_group (has_zero (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_74845 (h0 : functor.add_const (uniform_space (left_cancel_semigroup num)) empty) : @separated_space.{0} (left_cancel_semigroup.{0} num) (@functor.add_const.run.{0 0} (uniform_space.{0} (left_cancel_semigroup.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_74846 (h0 : semiring (has_zero (add_left_cancel_monoid (has_pos_part (finset linarith.comp))))) : is_noetherian_ring (has_zero (add_left_cancel_monoid (has_pos_part (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_74847 (h0 : list (linear_ordered_field (has_neg_part (option (option ennreal))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_74848 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (normed_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (normed_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_74849 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} h0 (metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_74850 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_74851 (h0 : group (comm_ring (random_gen (has_nnnorm (has_nnnorm linarith.comp_source))))) : is_cyclic (comm_ring (random_gen (has_nnnorm (has_nnnorm linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_74852 (h0 : topological_space (linear_ordered_comm_group (option ennreal))) : totally_separated_space (linear_ordered_comm_group (option ennreal)) := sorry --non-trivial
lemma new_lemma_74853 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @locally_compact_space.{0} (has_Inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (has_Inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_74854 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} linarith.comp (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) linarith.comp)  := sorry --non-trivial
lemma new_lemma_74855 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} h0 (add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_74856 (h0 : functor.add_const (topological_space (semigroup pos)) linarith.comp) : @totally_disconnected_space.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_74857 (h0 : fin has_zero.zero) : @totally_separated_space.{1} (has_pos_part.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (has_pos_part.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_74858 (h0 : functor.add_const (cancel_comm_monoid_with_zero (ordered_comm_ring pos)) linarith.comp) : @unique_factorization_monoid.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (ordered_comm_ring.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_74859 (h0 : functor.add_const (ring (comm_group Type)) name) : @is_principal_ideal_ring.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (comm_group.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_74860 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_nndist.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} h0 (has_nndist.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_74861 (h0 : functor.add_const (topological_space (boolean_algebra linarith.comp)) linarith.comp) : @preconnected_space.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_74862 (h0 : group (has_neg (finset (has_add name)))) : is_cyclic (has_neg (finset (has_add name))) := sorry --non-trivial
lemma new_lemma_74863 (h0 : string_imp -> string_imp -> Prop) : is_antisymm string_imp h0 := sorry --non-trivial
lemma new_lemma_74864 (h0 : measurable_space enat) (h1 : topological_space (measure_theory.measure enat)) : t0_space (measure_theory.measure enat) := sorry --non-trivial
lemma new_lemma_74865 (h0 : complete_lattice (semi_normed_ring (semi_normed_ring string_imp))) : complete_lattice.is_Sup_finite_compact (semi_normed_ring (semi_normed_ring string_imp)) := sorry --non-trivial
lemma new_lemma_74866 (h0 : monoid (ring (ring (has_neg linarith.comp)))) : monoid.fg (ring (ring (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_74867 (h0 : functor.add_const (ordered_add_comm_monoid (semiring congr_arg_kind)) empty) : @archimedean.{0} (semiring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (semiring.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_74868 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (with_one.{0} linarith.ineq) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (with_one.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_74869 (h0 : finset (has_pos_part (has_add real))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_74870 (h0 : complete_lattice (monoid num)) : is_atomistic (monoid num) := sorry --non-trivial
lemma new_lemma_74871 (h0 : topological_space (ring (boolean_algebra name))) : totally_disconnected_space (ring (boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_74872 (h0 : not (function.extfun Type ring -> false)) : @strong_rank_condition.{0} (linear_ordered_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (linear_ordered_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_74873 (h0 : function.extfun (Type 1) filter) : filter.ne_bot (function.extfun_app h0 (plift empty)) := sorry --non-trivial
lemma new_lemma_74874 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (has_to_string ennreal)) := sorry --non-trivial
lemma new_lemma_74875 (h0 : function.extfun nat fin) : @is_simple_group.{0} (has_add.{0} real) (@function.extfun_app.{2 1} Type group.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type group.{0}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (has_add.{0} real))  := sorry --non-trivial
lemma new_lemma_74876 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (has_one.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_74877 (h0 : complete_lattice (semigroup ennreal)) : is_atomistic (semigroup ennreal) := sorry --non-trivial
lemma new_lemma_74878 (h0 : topological_space (complete_distrib_lattice (add_comm_monoid Type))) : t1_space (complete_distrib_lattice (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_74879 (h0 : monoid (add_semigroup empty)) : monoid.fg (add_semigroup empty) := sorry --non-trivial
lemma new_lemma_74880 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (linear_ordered_field.{0} (option.{0} congr_arg_kind)) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (linear_ordered_field.{0} (option.{0} congr_arg_kind)))  := sorry --non-trivial
lemma new_lemma_74881 (h0 : functor.add_const (ring (has_to_string linarith.comp)) environment.implicit_infer_kind) : @rank_condition.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_to_string.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_74882 (h0 : group (pseudo_metric_space (add_comm_monoid congr_arg_kind))) : is_cyclic (pseudo_metric_space (add_comm_monoid congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_74883 (h0 : function.extfun Type topological_space) : @t0_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_74884 (h0 : functor.add_const (semiring (ring Type)) pos) : @is_noetherian_ring.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (semiring.{1} (ring.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_74885 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (add_left_cancel_semigroup.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_left_cancel_semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_74886 (h0 : uniform_space (has_nnnorm (has_nnnorm linarith.ineq))) : complete_space (has_nnnorm (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_74887 (h0 : functor.add_const (filter (ring pos)) pos) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_74888 (h0 : functor.add_const (function.extfun Type topological_space) (add_comm_monoid name)) : @topological_space.separable_space.{0} (has_nndist.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (add_comm_monoid.{0} name) h0) (has_nndist.{0} name))  := sorry --non-trivial
lemma new_lemma_74889 (h0 : topological_space (has_nnnorm char)) (h1 : preorder (has_nnnorm char)) : order_closed_topology (has_nnnorm char) := sorry --non-trivial
lemma new_lemma_74890 (h1 : topological_space (has_ssubset linarith.comp_source)) : t0_space (has_ssubset linarith.comp_source) := sorry --non-trivial
lemma new_lemma_74891 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (has_top.{0} char) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_top.{0} char))  := sorry --non-trivial
lemma new_lemma_74892 (h0 : ordered_comm_monoid (generalized_boolean_algebra (has_add real))) : has_exists_mul_of_le (generalized_boolean_algebra (has_add real)) := sorry --non-trivial
lemma new_lemma_74893 (h0 : add_group (with_bot (option (option unsigned)))) : is_add_cyclic (with_bot (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_74894 (h0 : complete_lattice (simple_graph (has_to_string pos))) : complete_lattice.is_Sup_finite_compact (simple_graph (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_74895 (h0 h1 : multiset (distrib (mul_one_class environment.projection_info))) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_74896 (h1 : function.extfun Type ring) : @rank_condition.{0} (has_top.{0} string_imp) (@function.extfun_app.{2 1} Type ring.{0} h1 (has_top.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_74897 (h0 : set (string.iterator_imp -> ereal)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_74898 (h0 : complete_lattice (has_Inf (has_add (has_neg name)))) : is_compactly_generated (has_Inf (has_add (has_neg name))) := sorry --non-trivial
lemma new_lemma_74899 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (has_add.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (has_add.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_74900 (h0 : topological_space (add_comm_monoid (has_add name))) : totally_disconnected_space (add_comm_monoid (has_add name)) := sorry --non-trivial
lemma new_lemma_74901 (h0 : topological_space (preorder congr_arg_kind)) : t0_space (preorder congr_arg_kind) := sorry --non-trivial
lemma new_lemma_74902 (h0 : ring (partial_order (semiring (semiring (semiring num))))) : strong_rank_condition (partial_order (semiring (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_74903 (h0 : ring (has_Inf (ring linarith.comp))) : strong_rank_condition (has_Inf (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_74904 (h0 : functor.add_const (complete_lattice (normed_group empty)) empty) : @is_atomistic.{0} (normed_group.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (normed_group.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_74905 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (has_compl.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_compl.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_74906 (h0 : functor.add_const (ring (boolean_algebra linarith.comp)) pos) : @strong_rank_condition.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_74907 (h0 : not (group (linear_ordered_semiring unsigned) -> false)) : @normalizer_condition.{0} (linear_ordered_semiring.{0} unsigned) (@classical.by_contradiction'.{1} (group.{0} (linear_ordered_semiring.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_74908 (h0 : not (function.extfun (finset Type) (has_mem.mem (has_one linarith.comp)) -> false)) : @normal_space.{0} (has_one.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_one.{0} linarith.comp) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_one.{0} linarith.comp)) (@classical.by_contradiction'.{0} (function.extfun.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_one.{0} linarith.comp))) h0) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_74909 (h0 : linear_ordered_comm_monoid_with_zero num -> linear_ordered_comm_monoid_with_zero num -> Prop) (h1 : set (linear_ordered_comm_monoid_with_zero num)) : set.unbounded h0 h1 := sorry --non-trivial
lemma new_lemma_74910 (h0 : topological_space (order_dual (semiring empty))) : preirreducible_space (order_dual (semiring empty)) := sorry --non-trivial
lemma new_lemma_74911 (h0 : add_group (has_compl (has_nnnorm (non_unital_non_assoc_semiring (has_nnnorm enat))))) : is_add_cyclic (has_compl (has_nnnorm (non_unital_non_assoc_semiring (has_nnnorm enat)))) := sorry --non-trivial
lemma new_lemma_74912 (h0 : topological_space (with_one (semiring (semiring (semiring (semiring unsigned)))))) : path_connected_space (with_one (semiring (semiring (semiring (semiring unsigned))))) := sorry --non-trivial
lemma new_lemma_74913 (h0 : group (measurable_space (has_norm linarith.ineq))) : normalizer_condition (measurable_space (has_norm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_74914 (h0 : ring (free_add_monoid (option unsigned))) : strong_rank_condition (free_add_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_74915 (h0 : ordered_comm_monoid (has_Inf (has_neg linarith.comp))) : has_exists_mul_of_le (has_Inf (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_74916 (h0 : topological_space (has_Inf (has_add (has_add pos)))) : path_connected_space (has_Inf (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_74917 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (ordered_comm_monoid.{0} real) (@function.extfun_app.{2 1} Type monoid.{0} h0 (ordered_comm_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_74918 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (sub_neg_monoid.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (sub_neg_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_74919 (h0 : topological_space (encodable (linear_ordered_add_comm_group linarith.ineq))) : totally_disconnected_space (encodable (linear_ordered_add_comm_group linarith.ineq)) := sorry --non-trivial
lemma new_lemma_74920 (h0 : functor.comp topological_space has_zero name) : @t1_space.{0} (has_zero.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} has_zero.{0} name h0)  := sorry --non-trivial
lemma new_lemma_74921 (h0 : topological_space (bin_tree (ordered_cancel_comm_monoid unsigned))) : preconnected_space (bin_tree (ordered_cancel_comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_74922 (h0 : topological_space (has_add (has_add (has_Inf Type)))) : t0_space (has_add (has_add (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_74923 (h0 : topological_space (canonically_ordered_monoid (has_neg real))) : totally_separated_space (canonically_ordered_monoid (has_neg real)) := sorry --non-trivial
lemma new_lemma_74924 (h0 : set (set (has_inv linarith.comp_source))) : is_countably_spanning h0 := sorry --non-trivial
lemma new_lemma_74925 (h0 : add_group (add_cancel_comm_monoid congr_arg_kind)) : is_add_cyclic (add_cancel_comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_74926 (h0 : not (ring (with_one congr_arg_kind) -> false)) : @strong_rank_condition.{0} (with_one.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (ring.{0} (with_one.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_74927 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (has_edist.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_edist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_74928 (h0 : cancel_comm_monoid_with_zero (linear_ordered_semiring (semiring (semiring unsigned)))) : unique_factorization_monoid (linear_ordered_semiring (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_74929 (h0 : ereal -> ereal -> Prop) : is_trichotomous ereal h0 := sorry --non-trivial
lemma new_lemma_74930 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_ssubset.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_ssubset.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_74931 (h1 : uniform_space (distrib char)) : complete_space (distrib char) := sorry --non-trivial
lemma new_lemma_74932 (h0 : group (linear_ordered_add_comm_group (has_ssubset fun_info))) : group.fg (linear_ordered_add_comm_group (has_ssubset fun_info)) := sorry --non-trivial
lemma new_lemma_74933 (h0 : filter (has_bot (has_add Type))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_74934 (h0 : topological_space (finset (mul_one_class (ring name)))) : topological_space.separable_space (finset (mul_one_class (ring name))) := sorry --non-trivial
lemma new_lemma_74935 (h0 : functor.add_const (topological_space (ordered_comm_ring pos)) linarith.comp) : @irreducible_space.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_74936 (h0 : functor.add_const (topological_space (complete_distrib_lattice Type)) environment.implicit_infer_kind) : @normal_space.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (complete_distrib_lattice.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_74937 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_simple_group.{0} (has_to_string.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_to_string.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_74938 (h0 : topological_space (boolean_algebra (ring (has_add linarith.comp)))) : topological_space.separable_space (boolean_algebra (ring (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_74939 (h0 : functor.add_const (complete_lattice (add_left_cancel_semigroup unsigned)) empty) : @is_atomistic.{0} (add_left_cancel_semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_left_cancel_semigroup.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_74940 (h0 : functor.add_const (topological_space (comm_group environment.implicit_infer_kind)) environment.implicit_infer_kind) : @loc_path_connected_space.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_74941 (h0 : add_group (normed_field (mul_one_class fun_info))) : is_add_cyclic (normed_field (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_74942 (h0 : has_add (normed_field ereal)) (h1 : add_group (has_compl (add_con (normed_field ereal)))) : is_add_cyclic (has_compl (add_con (normed_field ereal))) := sorry --non-trivial
lemma new_lemma_74943 (h0 : ring (random_gen (has_top to_additive.value_type))) : is_domain (random_gen (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_74944 (h1 : linarith.ineq -> linarith.ineq -> bool) : is_dec_refl h1 := sorry --non-trivial
lemma new_lemma_74945 (h0 : functor.add_const (uniform_space (has_zero environment.implicit_infer_kind)) pos) : @separated_space.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_zero.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_74946 (h0 : functor.add_const (add_monoid (comm_group ennreal)) pos) : @add_monoid.fg.{0} (comm_group.{0} ennreal) (@functor.add_const.run.{0 0} (add_monoid.{0} (comm_group.{0} ennreal)) pos h0)  := sorry --non-trivial
lemma new_lemma_74947 (h0 : has_lt (has_nnnorm (has_one char))) : no_max_order (has_nnnorm (has_one char)) := sorry --non-trivial
lemma new_lemma_74948 (h0 : not (add_group (has_nnnorm to_additive.value_type) -> false)) : @is_add_cyclic.{0} (has_nnnorm.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (add_group.{0} (has_nnnorm.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_74949 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (fintype.{0} char) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (fintype.{0} char))  := sorry --non-trivial
lemma new_lemma_74950 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @irreducible_space.{0} (ordered_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (ordered_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_74951 (h0 : complete_lattice (complete_linear_order (has_top (has_top (semiring empty))))) : is_compactly_generated (complete_linear_order (has_top (has_top (semiring empty)))) := sorry --non-trivial
lemma new_lemma_74952 (h0 : monoid (finset pos)) : monoid.fg (finset pos) := sorry --non-trivial
lemma new_lemma_74953 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (has_edist.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_edist.{0} empty))  := sorry --non-trivial
lemma new_lemma_74954 (h0 : functor.add_const (uniform_space (add_left_cancel_semigroup empty)) empty) : @separated_space.{0} (add_left_cancel_semigroup.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (add_left_cancel_semigroup.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_74955 (h0 : topological_space (has_pos_part (has_Inf Type))) : t1_space (has_pos_part (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_74956 (h0 : topological_space (add_cancel_monoid (has_to_string Type))) : regular_space (add_cancel_monoid (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_74957 (h0 : functor.add_const (function.extfun Type list) environment.implicit_infer_kind) : list.nodup (function.extfun_app (functor.add_const.run h0) (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_74958 (h0 : not (function.extfun Type filter -> false)) : filter.ne_bot (function.extfun_app (classical.by_contradiction' h0) (semiring empty)) := sorry --non-trivial
lemma new_lemma_74959 (h0 : complete_lattice (id (with_bot string_imp))) : is_compactly_generated (id (with_bot string_imp)) := sorry --non-trivial
lemma new_lemma_74960 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : countable_Inter_filter (function.extfun_app (function.extfun_app h0 filter) (has_to_string ennreal)) := sorry --non-trivial
lemma new_lemma_74961 (h0 : functor.add_const (topological_space (normed_comm_ring pos)) pos) : @totally_separated_space.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_74962 (h3 : uniform_space (nondiscrete_normed_field string.iterator_imp)) : complete_space (nondiscrete_normed_field string.iterator_imp) := sorry --non-trivial
lemma new_lemma_74963 (h0 : list (has_Inf (has_Inf Type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_74964 (h0 : topological_space (plift (has_norm (semiring empty)))) : preirreducible_space (plift (has_norm (semiring empty))) := sorry --non-trivial
lemma new_lemma_74965 (h0 : topological_space (canonically_ordered_monoid (has_add (has_add pos)))) : t0_space (canonically_ordered_monoid (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_74966 (h0 : list (ordered_comm_monoid name)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_74967 (h0 : not (semiring (with_bot unsigned) -> false)) : @is_noetherian_ring.{0} (with_bot.{0} unsigned) (@classical.by_contradiction'.{1} (semiring.{0} (with_bot.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_74968 (h0 : ring (has_star empty)) : is_domain (has_star empty) := sorry --non-trivial
lemma new_lemma_74969 (h0 : functor.add_const (add_group (ring Type)) pos) : @is_add_cyclic.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (add_group.{1} (ring.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_74970 (h1 : not (function.extfun Type ring -> false)) : @strong_rank_condition.{0} (with_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h1) (with_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_74971 (h0 : ring (semi_normed_comm_ring (has_nnnorm (has_nnnorm fun_info)))) : rank_condition (semi_normed_comm_ring (has_nnnorm (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_74972 (h0 : filter (semigroup (finset linarith.comp))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_74973 (h0 : topological_space (add_group num)) : loc_path_connected_space (add_group num) := sorry --non-trivial
lemma new_lemma_74974 (h0 : not (group (measurable_space num) -> false)) : @is_cyclic.{0} (measurable_space.{0} num) (@classical.by_contradiction'.{1} (group.{0} (measurable_space.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_74975 (h1 : filter (with_one (random_gen fun_info))) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_74976 (h2 : topological_space (linear_ordered_comm_group_with_zero linarith.ineq)) : totally_disconnected_space (linear_ordered_comm_group_with_zero linarith.ineq) := sorry --non-trivial
lemma new_lemma_74977 (h0 : functor.add_const (ring (semiring empty)) congr_arg_kind) : @is_principal_ideal_ring.{0} (semiring.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (semiring.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_74978 (h0 : complete_lattice (dlist (has_nnnorm (has_inv (has_nnnorm fun_info))))) : complete_lattice.is_Sup_finite_compact (dlist (has_nnnorm (has_inv (has_nnnorm fun_info)))) := sorry --non-trivial
lemma new_lemma_74979 (h0 : functor.add_const (ring (comm_group linarith.comp)) name) : @is_domain.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (comm_group.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_74980 (h0 : topological_space (add_comm_monoid (has_Inf Type))) : preirreducible_space (add_comm_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_74981 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @locally_compact_space.{0} (semiring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_74982 (h0 : topological_space (has_nndist (has_Inf linarith.comp))) : path_connected_space (has_nndist (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_74983 (h0 : semiring (measurable_space.dynkin_system linarith.comp)) : is_noetherian_ring (measurable_space.dynkin_system linarith.comp) := sorry --non-trivial
lemma new_lemma_74984 (h0 : function.extfun Type (functor.add_const (topological_space (ordered_comm_group empty)))) : @path_connected_space.{0} (ordered_comm_group.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_group.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (ordered_comm_group.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_74985 (h0 : has_mem.mem (id (has_norm num)) has_emptyc.emptyc) : @locally_compact_space.{0} (@id.{2} Type (has_norm.{0} num)) (@finset.pi.empty.{1 0} Type topological_space.{0} (@id.{2} Type (has_norm.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_74986 (h0 : functor.add_const (topological_space (cancel_monoid ennreal)) num) : @preconnected_space.{0} (cancel_monoid.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} ennreal)) num h0)  := sorry --non-trivial
lemma new_lemma_74987 (h0 h1 : set (mul_one_class std_gen)) (h2 : mul_one_class std_gen) : set.inter h0 h1 h2 := sorry --non-trivial
lemma new_lemma_74988 (h0 : ring (free_add_monoid (semiring (semiring empty)))) : strong_rank_condition (free_add_monoid (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_74989 (h0 : ring (generalized_boolean_algebra (has_Inf (has_Inf Type)))) : is_principal_ideal_ring (generalized_boolean_algebra (has_Inf (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_74990 (h0 : filter (has_neg (boolean_algebra pos))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_74991 (h0 : topological_space ereal) (h1 : set (set ereal)) : topological_space.is_topological_basis h1 := sorry --non-trivial
lemma new_lemma_74992 (h1 : group (semi_normed_comm_ring to_additive.value_type)) : group.fg (semi_normed_comm_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_74993 (h0 : topological_space (measurable_space (has_top (has_norm linarith.comp_source)))) : totally_disconnected_space (measurable_space (has_top (has_norm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_74994 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} to_additive.value_type (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 topological_space.{0}) to_additive.value_type)  := sorry --non-trivial
lemma new_lemma_74995 (h0 : ring (complete_semilattice_Sup fun_info)) : rank_condition (complete_semilattice_Sup fun_info) := sorry --non-trivial
lemma new_lemma_74996 (h0 : topological_space (has_compl (distrib fun_info))) (h1 : preorder (has_compl (distrib fun_info))) : order_closed_topology (has_compl (distrib fun_info)) := sorry --non-trivial
lemma new_lemma_74997 (h0 : functor.add_const (cancel_comm_monoid_with_zero (complete_distrib_lattice Type)) linarith.comp) : @unique_factorization_monoid.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 0} (cancel_comm_monoid_with_zero.{1} (complete_distrib_lattice.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_74998 (h0 : complete_lattice (has_neg_part name)) : complete_lattice.is_Sup_finite_compact (has_neg_part name) := sorry --non-trivial
lemma new_lemma_74999 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (canonically_ordered_add_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_75000 (h0 : has_mem.mem (semiring fun_info) has_emptyc.emptyc) : @is_atomistic.{0} (semiring.{0} fun_info) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (semiring.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_75001 (h1 : has_mem.mem (has_norm congr_arg_kind) has_emptyc.emptyc) : @is_cyclic.{0} (has_norm.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type group.{0} (has_norm.{0} congr_arg_kind) h1)  := sorry --non-trivial
lemma new_lemma_75002 (h0 : filter (with_bot (random_gen unsigned))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_75003 (h0 : functor.add_const (topological_space (add_cancel_monoid pos)) pos) : @irreducible_space.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_75004 (h0 : functor.add_const (group (cancel_monoid Type)) Type) : @normalizer_condition.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 1} (group.{1} (cancel_monoid.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_75005 (h0 : topological_space (with_bot (has_top (random_gen linarith.comp_source)))) : irreducible_space (with_bot (has_top (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_75006 (h0 : group (linear_ordered_add_comm_group (random_gen (comm_ring linarith.ineq)))) : is_cyclic (linear_ordered_add_comm_group (random_gen (comm_ring linarith.ineq))) := sorry --non-trivial
lemma new_lemma_75007 (h0 : ring (has_edist empty)) : is_domain (has_edist empty) := sorry --non-trivial
lemma new_lemma_75008 (h2 : has_lt (mul_one_class (add_comm_semigroup string.iterator_imp))) : no_max_order (mul_one_class (add_comm_semigroup string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_75009 (h0 : topological_space (add_right_cancel_monoid (has_top congr_arg_kind))) : totally_disconnected_space (add_right_cancel_monoid (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_75010 (h0 : list (add_group (semi_normed_comm_ring (ordered_cancel_comm_monoid to_additive.value_type)))) (h1 : nat) (h2 : has_lt.lt h1 (list.length h0)) : @is_add_cyclic.{0} (semi_normed_comm_ring.{0} (ordered_cancel_comm_monoid.{0} to_additive.value_type)) (@list.nth_le.{0} (add_group.{0} (semi_normed_comm_ring.{0} (ordered_cancel_comm_monoid.{0} to_additive.value_type))) h0 h1 h2)  := sorry --non-trivial
lemma new_lemma_75011 (h0 : group (boolean_algebra.core (has_add name))) : normalizer_condition (boolean_algebra.core (has_add name)) := sorry --non-trivial
lemma new_lemma_75012 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @monoid.fg.{0} (normed_group.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) monoid.{0}) (normed_group.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_75013 (h0 : topological_space (semigroup (cancel_monoid pos))) : totally_disconnected_space (semigroup (cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_75014 (h0 : filter (linear_ordered_add_comm_group (has_ssubset fun_info))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_75015 (h0 : functor.add_const (fin has_zero.zero) (has_Inf name)) : @is_cyclic.{0} (comm_semigroup.{0} real) (@function.extfun_app.{2 1} Type group.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type group.{0}) (@functor.add_const.run.{0 0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (has_Inf.{0} name) h0)) (comm_semigroup.{0} real))  := sorry --non-trivial
lemma new_lemma_75016 (h0 : topological_space (linear_ordered_add_comm_group num)) : normal_space (linear_ordered_add_comm_group num) := sorry --non-trivial
lemma new_lemma_75017 (h0 : uniform_space (has_nndist (has_dist (option (option (complete_distrib_lattice empty)))))) : separated_space (has_nndist (has_dist (option (option (complete_distrib_lattice empty))))) := sorry --non-trivial
lemma new_lemma_75018 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (generalized_boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (generalized_boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_75019 (h0 : has_mem.mem (has_norm congr_arg_kind) has_emptyc.emptyc) : @strong_rank_condition.{0} (has_norm.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type ring.{0} (has_norm.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_75020 (h0 : random_gen (comm_ring to_additive.value_type) -> Prop) : exists_unique h0 := sorry --non-trivial
lemma new_lemma_75021 (h0 : topological_space (ordered_comm_ring (sub_neg_monoid Type))) : totally_disconnected_space (ordered_comm_ring (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_75022 (h0 : topological_space (comm_ring (random_gen (random_gen (random_gen to_additive.value_type))))) : path_connected_space (comm_ring (random_gen (random_gen (random_gen to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_75023 (h0 : function.extfun Type (functor.add_const (topological_space linarith.comp))) : @preirreducible_space.{0} linarith.comp (@functor.add_const.run.{0 0} (topological_space.{0} linarith.comp) name (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} linarith.comp)) h0 name))  := sorry --non-trivial
lemma new_lemma_75024 (h0 : has_le (dlist (random_gen to_additive.value_type))) (h1 : bounded_order (dlist (random_gen to_additive.value_type))) : is_simple_order (dlist (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_75025 (h0 : functor.add_const (cancel_comm_monoid_with_zero (mul_zero_class name)) (finset ennreal)) : @unique_factorization_monoid.{0} (mul_zero_class.{0} name) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (mul_zero_class.{0} name)) (finset.{0} ennreal) h0)  := sorry --non-trivial
lemma new_lemma_75026 (h0 : topological_space (has_emptyc linarith.ineq)) : locally_compact_space (has_emptyc linarith.ineq) := sorry --non-trivial
lemma new_lemma_75027 (h0 : group (canonically_ordered_monoid (has_Inf (has_add (has_add linarith.comp))))) : is_cyclic (canonically_ordered_monoid (has_Inf (has_add (has_add linarith.comp)))) := sorry --non-trivial
lemma new_lemma_75028 (h0 : cancel_comm_monoid_with_zero (non_assoc_semiring (semiring congr_arg_kind))) : unique_factorization_monoid (non_assoc_semiring (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_75029 (h0 : function.extfun (Type 1) ring) : @is_principal_ideal_ring.{1} (plift.{1} congr_arg_kind) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (plift.{1} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_75030 (h0 : functor.add_const (ring (boolean_algebra.core unsigned)) environment.implicit_infer_kind) : @rank_condition.{0} (boolean_algebra.core.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.core.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_75031 (h0 : add_group (measure_theory.measure_space empty)) : is_add_cyclic (measure_theory.measure_space empty) := sorry --non-trivial
lemma new_lemma_75032 (h0 : add_monoid (has_to_string (cancel_monoid pos))) : add_monoid.fg (has_to_string (cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_75033 (h0 : fin has_zero.zero) : @unique_factorization_monoid.{0} (has_bot.{0} real) (@matrix.vec_empty.{0} (cancel_comm_monoid_with_zero.{0} (has_bot.{0} real)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_75034 (h0 : topological_space char) (h1 : has_add char) : has_continuous_add char := sorry --non-trivial
lemma new_lemma_75035 (h0 : functor.add_const (topological_space (ordered_comm_ring Type)) Type) : @loc_path_connected_space.{1} (ordered_comm_ring.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (ordered_comm_ring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_75036 (h0 : prod (has_union empty) (has_union empty)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_75037 (h0 : ordered_add_comm_monoid (boolean_algebra.core (has_neg pos))) : archimedean (boolean_algebra.core (has_neg pos)) := sorry --non-trivial
lemma new_lemma_75038 (h0 : function.extfun Type ring) : @rank_condition.{0} (linear_ordered_field.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_ordered_field.{0} num))  := sorry --non-trivial
lemma new_lemma_75039 (h0 : ring ordering -> Prop) (h1 : Exists (fun (x : ring ordering), h0 x)) : @is_domain.{0} ordering (@classical.some.{1} (ring.{0} ordering) h0 h1)  := sorry --non-trivial
lemma new_lemma_75040 (h0 h1 : list to_additive.value_type) : list.is_infix h0 h1 := sorry --non-trivial
lemma new_lemma_75041 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_75042 (h0 : function.extfun Type topological_space) : @t1_space.{0} (mul_zero_class.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (mul_zero_class.{0} name))  := sorry --non-trivial
lemma new_lemma_75043 (h0 : ring (has_top (has_top congr_arg_kind))) : is_domain (has_top (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_75044 (h0 : not (monoid (semiring unsigned) -> false)) : @monoid.fg.{0} (semiring.{0} unsigned) (@classical.by_contradiction'.{1} (monoid.{0} (semiring.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_75045 (h0 : function.extfun Type topological_space) : @t0_space.{0} (normed_lattice_add_comm_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_lattice_add_comm_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_75046 (h0 : functor.add_const (function.extfun (Type 1) group) linarith.comp) : @group.fg.{1} (generalized_boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) group.{1}) linarith.comp h0) (generalized_boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_75047 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (linear_order.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_order.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_75048 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (normed_group.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_group.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_75049 (h0 : topological_space (denumerable (comm_ring (has_nnnorm reducibility_hints)))) : t0_space (denumerable (comm_ring (has_nnnorm reducibility_hints))) := sorry --non-trivial
lemma new_lemma_75050 (h0 : ring (denumerable (has_inv to_additive.value_type))) : is_domain (denumerable (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_75051 (h0 : ring (add_cancel_monoid (has_add pos))) : is_domain (add_cancel_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_75052 (h1 : group (distrib_lattice char)) : is_cyclic (distrib_lattice char) := sorry --non-trivial
lemma new_lemma_75053 (h0 : functor.add_const (topological_space (has_neg_part environment.implicit_infer_kind)) Type) : @preirreducible_space.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg_part.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_75054 (h0 : functor.add_const (topological_space (comm_group linarith.comp)) linarith.comp) : @normal_space.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_75055 (h0 : ring (has_nnnorm (has_le (mul_one_class string_imp)))) : strong_rank_condition (has_nnnorm (has_le (mul_one_class string_imp))) := sorry --non-trivial
lemma new_lemma_75056 (h2 : add_group (has_ssubset string_imp)) : is_add_cyclic (has_ssubset string_imp) := sorry --non-trivial
lemma new_lemma_75057 (h0 : topological_space (normed_comm_ring ennreal)) : totally_disconnected_space (normed_comm_ring ennreal) := sorry --non-trivial
lemma new_lemma_75058 (h0 : topological_space (canonically_ordered_comm_semiring (boolean_algebra (boolean_algebra unsigned)))) : t1_space (canonically_ordered_comm_semiring (boolean_algebra (boolean_algebra unsigned))) := sorry --non-trivial
lemma new_lemma_75059 (h0 : not (topological_space (measurable_space.dynkin_system unsigned) -> false)) : @preirreducible_space.{0} (measurable_space.dynkin_system.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (measurable_space.dynkin_system.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_75060 (h0 : function.extfun Type (functor.add_const (topological_space (semigroup unsigned)))) : @t0_space.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} unsigned)) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (semigroup.{0} unsigned))) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_75061 (h0 : topological_space (semigroup (has_Inf (has_Inf pos)))) : regular_space (semigroup (has_Inf (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_75062 (h0 : functor.add_const (group (ring Type)) name) : @is_cyclic.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (ring.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_75063 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (add_cancel_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (add_cancel_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_75064 (h0 : topological_space (nondiscrete_normed_field std_gen)) (h1 : set (nondiscrete_normed_field std_gen)) : is_path_connected h1 := sorry --non-trivial
lemma new_lemma_75065 (h0 : topological_space (has_add (has_neg Type))) : locally_compact_space (has_add (has_neg Type)) := sorry --non-trivial
lemma new_lemma_75066 (h0 : functor.add_const (add_monoid (semigroup Type)) Type) : @add_monoid.fg.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 1} (add_monoid.{1} (semigroup.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_75067 (h0 h1 : multiset (linear_ordered_comm_group_with_zero (mul_one_class char))) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_75068 (h0 : ring (has_zero (ring Type))) : rank_condition (has_zero (ring Type)) := sorry --non-trivial
lemma new_lemma_75069 (h0 : topological_space (has_zero linarith.comp)) : sequential_space (has_zero linarith.comp) := sorry --non-trivial
lemma new_lemma_75070 (h0 : topological_space (semi_normed_comm_ring string.iterator_imp)) (h1 : add_group (semi_normed_comm_ring string.iterator_imp)) : topological_add_group (semi_normed_comm_ring string.iterator_imp) := sorry --non-trivial
lemma new_lemma_75071 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (option unsigned)) := sorry --non-trivial
lemma new_lemma_75072 (h0 : group (bin_tree (semiring (semiring (semiring (semiring empty)))))) : group.fg (bin_tree (semiring (semiring (semiring (semiring empty))))) := sorry --non-trivial
lemma new_lemma_75073 (h0 : filter (linear_ordered_field ennreal)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_75074 (h0 : functor.add_const (topological_space (complete_distrib_lattice empty)) congr_arg_kind) : @locally_compact_space.{0} (complete_distrib_lattice.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_75075 (h1 : not (topological_space (random_gen linarith.comp_source) -> false)) : @path_connected_space.{0} (random_gen.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (random_gen.{0} linarith.comp_source)) h1)  := sorry --non-trivial
lemma new_lemma_75076 (h0 : has_mem.mem (has_top (has_norm empty)) has_emptyc.emptyc) : @discrete_topology.{0} (has_top.{0} (has_norm.{0} empty)) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_top.{0} (has_norm.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_75077 (h0 : topological_space (comm_semigroup linarith.comp)) : topological_space.separable_space (comm_semigroup linarith.comp) := sorry --non-trivial
lemma new_lemma_75078 (h0 : linarith.ineq -> linarith.ineq -> Prop) (h1 h2 : linarith.ineq) : eqv_gen h0 h1 h2 := sorry --non-trivial
lemma new_lemma_75079 (h1 : has_lt environment.projection_info) : no_max_order environment.projection_info := sorry --non-trivial
lemma new_lemma_75080 (h0 : functor.add_const (topological_space (boolean_algebra unsigned)) Type) : @t1_space.{0} (boolean_algebra.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_75081 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (normed_group.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 topological_space.{0}) (normed_group.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_75082 (h0 : functor.add_const (topological_space auto.case_option) num) : @path_connected_space.{0} auto.case_option (@functor.add_const.run.{0 0} (topological_space.{0} auto.case_option) num h0)  := sorry --non-trivial
lemma new_lemma_75083 (h0 : functor.add_const (topological_space (complete_distrib_lattice name)) Type) : @path_connected_space.{0} (complete_distrib_lattice.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (complete_distrib_lattice.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_75084 (h0 : functor.add_const (monoid (ring linarith.comp)) (has_neg pos)) : @monoid.fg.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (monoid.{0} (ring.{0} linarith.comp)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_75085 (h0 : add_group (normed_comm_ring (finset name))) : is_add_cyclic (normed_comm_ring (finset name)) := sorry --non-trivial
lemma new_lemma_75086 (h0 : functor.add_const (ring (semigroup linarith.comp)) pos) : @is_principal_ideal_ring.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (semigroup.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_75087 (h0 : function.extfun Type group) : @is_cyclic.{0} nnreal (@function.extfun_app.{2 1} Type group.{0} h0 nnreal)  := sorry --non-trivial
lemma new_lemma_75088 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_75089 (h0 : list (ordered_comm_ring (ring Type))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_75090 (h0 : ring (add_group congr_arg_kind)) : is_principal_ideal_ring (add_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_75091 (h0 : uniform_space (denumerable (has_nnnorm linarith.ineq))) : complete_space (denumerable (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_75092 (h0 : uniform_space (semiring (has_top fun_info))) : separated_space (semiring (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_75093 (h0 : not (ring (with_zero fun_info) -> false)) : @is_domain.{0} (with_zero.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (with_zero.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_75094 (h0 : fin has_zero.zero) : @group.fg.{0} (comm_semigroup.{0} pos) (@matrix.vec_empty.{0} (group.{0} (comm_semigroup.{0} pos)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)))  := sorry --non-trivial
lemma new_lemma_75095 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (linear_ordered_comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_75096 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (monoid.{0} empty) (@function.extfun_app.{2 1} Type semiring.{0} h0 (monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_75097 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_75098 (h0 : group (has_emptyc linarith.ineq)) : is_cyclic (has_emptyc linarith.ineq) := sorry --non-trivial
lemma new_lemma_75099 (h0 : functor.add_const (ring (has_pos_part pos)) Type) : @is_domain.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (has_pos_part.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_75100 (h0 : topological_space (has_nndist (finset (finset (finset (has_neg_part (finset name))))))) : totally_disconnected_space (has_nndist (finset (finset (finset (has_neg_part (finset name)))))) := sorry --non-trivial
lemma new_lemma_75101 (h0 : functor.add_const (topological_space (semigroup pos)) (semigroup name)) : @normal_space.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} pos)) (semigroup.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_75102 (h0 : functor.add_const (topological_space (has_add pos)) pos) : @preirreducible_space.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_75103 (h0 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} (random_gen.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h0) (random_gen.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_75104 (h2 : ring (add_monoid fun_info)) : rank_condition (add_monoid fun_info) := sorry --non-trivial
lemma new_lemma_75105 (h0 : ring (has_Inf (has_add pos))) : strong_rank_condition (has_Inf (has_add pos)) := sorry --non-trivial
lemma new_lemma_75106 (h0 : complete_lattice (has_add (encodable char))) : complete_lattice.is_Sup_finite_compact (has_add (encodable char)) := sorry --non-trivial
lemma new_lemma_75107 (h0 : comm_semigroup real -> comm_semigroup real -> Prop) : transitive h0 := sorry --non-trivial
lemma new_lemma_75108 (h0 : filter (add_left_cancel_monoid (has_nnnorm (has_nnnorm linarith.comp_source)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_75109 (h0 : list (has_inv char)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_75110 (h0 : functor.add_const (topological_space (comm_group Type)) (has_add (has_add name))) : @totally_disconnected_space.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (comm_group.{1} Type)) (has_add.{0} (has_add.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_75111 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @loc_path_connected_space.{1} (normed_lattice_add_comm_group.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (normed_lattice_add_comm_group.{1} Type)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_75112 (h0 : topological_space (has_compl enat)) (h1 : preorder (has_compl enat)) : order_topology (has_compl enat) := sorry --non-trivial
lemma new_lemma_75113 (h0 : complete_lattice (add_cancel_monoid pos)) : is_compactly_generated (add_cancel_monoid pos) := sorry --non-trivial
lemma new_lemma_75114 (h0 : fin has_zero.zero) : preirreducible_space real := sorry --non-trivial
lemma new_lemma_75115 (h0 : functor.add_const (filter (normed_comm_ring pos)) (has_to_string pos)) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_75116 (h0 : add_group (free_add_monoid (semiring unsigned))) : is_add_cyclic (free_add_monoid (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_75117 (h0 : filter (with_one (semiring linarith.comp))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_75118 (h0 : set (has_Sup fun_info)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_75119 (h4 : uniform_space (has_top to_additive.value_type)) : complete_space (has_top to_additive.value_type) := sorry --non-trivial
lemma new_lemma_75120 (h1 : function.extfun Type topological_space) : @path_connected_space.{0} (has_top.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (has_top.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_75121 (h0 : function.extfun Type group) : @normalizer_condition.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (complete_semilattice_Sup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_75122 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (has_nndist.{0} ennreal) (@function.extfun_app.{2 1} Type semiring.{0} h0 (has_nndist.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_75123 (h0 : has_mem.mem (semiring (has_norm empty)) has_emptyc.emptyc) : @rank_condition.{0} (semiring.{0} (has_norm.{0} empty)) (@finset.pi.empty.{1 0} Type ring.{0} (semiring.{0} (has_norm.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_75124 (h0 : functor.add_const (topological_space (normed_comm_ring linarith.comp)) linarith.comp) : @irreducible_space.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_75125 (h0 : ring (simple_graph (boolean_algebra.core (finset (has_add linarith.comp))))) : is_domain (simple_graph (boolean_algebra.core (finset (has_add linarith.comp)))) := sorry --non-trivial
lemma new_lemma_75126 (h0 : group (boolean_algebra linarith.comp)) : group.fg (boolean_algebra linarith.comp) := sorry --non-trivial
lemma new_lemma_75127 (h0 : complete_lattice (dlist (random_gen (random_gen (dlist fun_info))))) : is_compactly_generated (dlist (random_gen (random_gen (dlist fun_info)))) := sorry --non-trivial
lemma new_lemma_75128 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (monoid empty)) := sorry --non-trivial
lemma new_lemma_75129 (h0 : topological_space (semiring (has_top fun_info))) : discrete_topology (semiring (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_75130 (h0 : functor.add_const (topological_space (normed_comm_ring name)) pos) : @normal_space.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_75131 (h0 : monoid (finset (has_add (has_add pos)))) : monoid.fg (finset (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_75132 (h0 : topological_space (ring (ring (normed_comm_ring (has_Inf (ring (has_nndist (semigroup Type)))))))) : regular_space (ring (ring (normed_comm_ring (has_Inf (ring (has_nndist (semigroup Type))))))) := sorry --non-trivial
lemma new_lemma_75133 (h0 : topological_space (semi_normed_ring (mul_one_class char))) : t0_space (semi_normed_ring (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_75134 (h0 : functor.add_const (ordered_add_comm_monoid (ordered_comm_ring linarith.comp)) environment.implicit_infer_kind) : @archimedean.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (ordered_comm_ring.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_75135 (h0 : topological_space (id string_imp)) : t0_space (id string_imp) := sorry --non-trivial
lemma new_lemma_75136 (h0 : semiring (has_pos_part (sub_neg_monoid (has_add name)))) : is_noetherian_ring (has_pos_part (sub_neg_monoid (has_add name))) := sorry --non-trivial
lemma new_lemma_75137 : nonempty enat := sorry --simp
lemma new_lemma_75138 (h0 : ring (has_top (comm_ring (has_norm (with_bot fun_info))))) : rank_condition (has_top (comm_ring (has_norm (with_bot fun_info)))) := sorry --non-trivial
lemma new_lemma_75139 (h0 : finset (ring (ring (ring linarith.comp)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_75140 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (with_one.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_one.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_75141 (h0 : functor.add_const (topological_space (has_neg Type)) linarith.comp) : @regular_space.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_neg.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_75142 (h0 : functor.comp topological_space ring pos) : @topological_space.separable_space.{0} (ring.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} ring.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_75143 (h0 : topological_space (random_gen fun_info)) : t0_space (random_gen fun_info) := sorry --non-trivial
lemma new_lemma_75144 (h0 : ordered_add_comm_monoid (comm_group (ring name))) : archimedean (comm_group (ring name)) := sorry --non-trivial
lemma new_lemma_75145 (h0 : ordered_comm_monoid (semigroup (option (option (option pos))))) : has_exists_mul_of_le (semigroup (option (option (option pos)))) := sorry --non-trivial
lemma new_lemma_75146 (h0 : list (linear_ordered_field ennreal)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_75147 (h2 : topological_space char) : topological_space.first_countable_topology char := sorry --non-trivial
lemma new_lemma_75148 (h0 : functor.add_const (ordered_add_comm_monoid (linear_ordered_comm_monoid_with_zero empty)) empty) : @archimedean.{0} (linear_ordered_comm_monoid_with_zero.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (linear_ordered_comm_monoid_with_zero.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_75149 (h1 : monoid (has_norm (semiring congr_arg_kind))) : monoid.fg (has_norm (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_75150 (h2 : is_empty (has_lt linarith.comp_source)) (h3 : has_lt linarith.comp_source) : is_empty.elim' h2 h3 := sorry --non-trivial
lemma new_lemma_75151 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_emptyc.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_emptyc.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_75152 (h0 : topological_space (has_to_string (ring (has_add (boolean_algebra Type))))) : totally_disconnected_space (has_to_string (ring (has_add (boolean_algebra Type)))) := sorry --non-trivial
lemma new_lemma_75153 (h0 : ring (filter std_gen)) : strong_rank_condition (filter std_gen) := sorry --non-trivial
lemma new_lemma_75154 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (ring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ring.{0} num))  := sorry --non-trivial
lemma new_lemma_75155 (h0 : ring (add_group (semiring (semiring unsigned)))) : rank_condition (add_group (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_75156 (h0 : function.extfun Type (functor.comp topological_space canonically_linear_ordered_monoid)) : @irreducible_space.{0} (canonically_linear_ordered_monoid.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} canonically_linear_ordered_monoid.{0} ennreal (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} canonically_linear_ordered_monoid.{0}) h0 ennreal))  := sorry --non-trivial
lemma new_lemma_75157 (h0 : functor.add_const (topological_space (normed_comm_ring Type)) name) : @preirreducible_space.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (normed_comm_ring.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_75158 (h0 : functor.comp topological_space has_to_string Type) : @normal_space.{1} (has_to_string.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} has_to_string.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_75159 (h0 : multiset (random_gen linarith.ineq)) (h1 : not (multiset (random_gen linarith.ineq) -> false)) : multiset.disjoint h0 (classical.by_contradiction' h1) := sorry --non-trivial
lemma new_lemma_75160 (h0 : ring (has_add Type)) : rank_condition (has_add Type) := sorry --non-trivial
lemma new_lemma_75161 (h0 : ordered_comm_monoid (ordered_comm_ring name)) : has_exists_mul_of_le (ordered_comm_ring name) := sorry --non-trivial
lemma new_lemma_75162 (h0 : topological_space (ordered_comm_ring (has_Inf real))) : topological_space.separable_space (ordered_comm_ring (has_Inf real)) := sorry --non-trivial
lemma new_lemma_75163 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_75164 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (has_to_string.{0} (option.{0} unsigned)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_75165 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_top.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_top.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_75166 (h0 : functor.add_const (topological_space (has_neg linarith.comp)) linarith.comp) : @discrete_topology.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_75167 (h1 : function.extfun (finset Type) (has_mem.mem (measurable_space linarith.comp))) : @is_domain.{0} (measurable_space.{0} linarith.comp) (@finset.pi.empty.{1 0} Type ring.{0} (measurable_space.{0} linarith.comp) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (measurable_space.{0} linarith.comp)) h1 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_75168 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_75169 (h0 : uniform_space (option (semiring congr_arg_kind))) : separated_space (option (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_75170 (h0 : topological_space (ordered_cancel_add_comm_monoid (option empty))) : locally_compact_space (ordered_cancel_add_comm_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_75171 (h0 : functor.comp topological_space mul_zero_class Type) : @loc_path_connected_space.{1} (mul_zero_class.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} mul_zero_class.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_75172 (h0 : group (simple_graph (has_add (has_Inf linarith.comp)))) : group.fg (simple_graph (has_add (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_75173 (h0 : ring (linear_order (option (option (has_edist unsigned))))) : rank_condition (linear_order (option (option (has_edist unsigned)))) := sorry --non-trivial
lemma new_lemma_75174 (h0 : functor.add_const (ring (semigroup linarith.comp)) (ring pos)) : @rank_condition.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (semigroup.{0} linarith.comp)) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_75175 (h0 : not (has_mem.mem Type has_emptyc.emptyc -> false)) : @strong_rank_condition.{1} Type (@finset.pi.empty.{2 1} (Type 1) ring.{1} Type (@classical.by_contradiction'.{0} (@has_mem.mem.{2 2} (Type 1) (finset.{2} (Type 1)) (@finset.has_mem.{2} (Type 1)) Type (@has_emptyc.emptyc.{2} (finset.{2} (Type 1)) (@finset.has_emptyc.{2} (Type 1)))) h0))  := sorry --non-trivial
lemma new_lemma_75176 (h2 : complete_lattice (comm_ring (random_gen fun_info))) : is_compactly_generated (comm_ring (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_75177 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_75178 (h0 : list (semigroup congr_arg_kind)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_75179 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @loc_path_connected_space.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_75180 (h0 : functor.add_const (ring (has_add environment.implicit_infer_kind)) Type) : @is_domain.{0} (has_add.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (ring.{0} (has_add.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_75181 (h0 : function.extfun Type topological_space) : @t0_space.{0} pos (@function.extfun_app.{2 1} Type topological_space.{0} h0 pos)  := sorry --non-trivial
lemma new_lemma_75182 (h0 : uniform_space (has_neg (has_add name))) : complete_space (has_neg (has_add name)) := sorry --non-trivial
lemma new_lemma_75183 (h1 : ring (denumerable (denumerable (denumerable (denumerable to_additive.value_type))))) : is_domain (denumerable (denumerable (denumerable (denumerable to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_75184 (h0 : topological_space (id congr_arg_kind)) : preirreducible_space (id congr_arg_kind) := sorry --non-trivial
lemma new_lemma_75185 (h0 : functor.add_const (topological_space (has_neg unsigned)) name) : @locally_compact_space.{0} (has_neg.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_75186 (h0 : filter (boolean_algebra (has_to_string (has_add pos)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_75187 (h0 : functor.add_const (add_monoid (preorder unsigned)) unsigned) : @add_monoid.fg.{0} (preorder.{0} unsigned) (@functor.add_const.run.{0 0} (add_monoid.{0} (preorder.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_75188 (h0 : topological_space (distrib_lattice (has_nnnorm char))) : t0_space (distrib_lattice (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_75189 (h0 : function.extfun Type topological_space) : @t0_space.{0} (denumerable.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (denumerable.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_75190 (h2 : topological_space (has_ssubset (has_nnnorm linarith.ineq))) : t0_space (has_ssubset (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_75191 (h0 : functor.add_const (topological_space (left_cancel_monoid unsigned)) empty) : @totally_disconnected_space.{0} (left_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_75192 (h0 : semiring (has_add (option unsigned))) : is_noetherian_ring (has_add (option unsigned)) := sorry --non-trivial
lemma new_lemma_75193 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_nndist.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_nndist.{0} name))  := sorry --non-trivial
lemma new_lemma_75194 (h0 : has_norm (has_top empty) -> has_norm (has_top empty) -> Prop) : is_strict_order (has_norm (has_top empty)) h0 := sorry --non-trivial
lemma new_lemma_75195 (h0 : functor.add_const (ring (finset pos)) Type) : @is_principal_ideal_ring.{0} (finset.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (finset.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_75196 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (has_bot.{0} name) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (has_bot.{0} name))  := sorry --non-trivial
lemma new_lemma_75197 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (has_union.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_union.{0} empty))  := sorry --non-trivial
lemma new_lemma_75198 (h0 : functor.add_const (add_monoid (has_zero Type)) linarith.comp) : @add_monoid.fg.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (add_monoid.{1} (has_zero.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_75199 (h0 : topological_space (mul_zero_class unsigned)) : topological_space.separable_space (mul_zero_class unsigned) := sorry --non-trivial
lemma new_lemma_75200 (h0 : uniform_space (ordered_comm_monoid (ordered_ring name))) : separated_space (ordered_comm_monoid (ordered_ring name)) := sorry --non-trivial
lemma new_lemma_75201 (h0 : functor.add_const (topological_space (add_cancel_monoid linarith.comp)) name) : @preconnected_space.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_75202 (h0 : functor.add_const (topological_space (has_Inf name)) linarith.comp) : @preconnected_space.{0} (has_Inf.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_75203 (h0 : function.extfun Type (prod (option pos))) : id_rel (function.extfun_app h0 (option pos)) := sorry --non-trivial
lemma new_lemma_75204 (h0 : semiring (semiring (semiring (semiring empty)))) : is_noetherian_ring (semiring (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_75205 (h0 : ring (has_to_string (has_add (has_neg Type)))) : is_principal_ideal_ring (has_to_string (has_add (has_neg Type))) := sorry --non-trivial
lemma new_lemma_75206 (h0 : complete_lattice (normed_group linarith.comp_source)) : is_compactly_generated (normed_group linarith.comp_source) := sorry --non-trivial
lemma new_lemma_75207 (h0 : functor.add_const (topological_space (mul_zero_class num)) empty) : @preirreducible_space.{0} (mul_zero_class.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_75208 (h0 : functor.add_const (function.extfun (Type 1) group) (has_neg pos)) : @group.fg.{1} (has_neg.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) group.{1}) (has_neg.{0} pos) h0) (has_neg.{1} Type))  := sorry --non-trivial
lemma new_lemma_75209 (h0 : ring (finset (sub_neg_monoid pos))) : is_domain (finset (sub_neg_monoid pos)) := sorry --non-trivial
lemma new_lemma_75210 (h0 : functor.add_const (group (has_zero environment.implicit_infer_kind)) linarith.comp) : @normalizer_condition.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (has_zero.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_75211 (h0 : functor.add_const (topological_space (add_cancel_monoid environment.implicit_infer_kind)) Type) : @totally_separated_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_75212 (h0 : topological_space (has_lt (measure_theory.measure_space (denumerable string.iterator_imp)))) : totally_disconnected_space (has_lt (measure_theory.measure_space (denumerable string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_75213 (h1 : add_group (has_top (has_norm to_additive.value_type))) : is_add_cyclic (has_top (has_norm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_75214 (h0 : topological_space (comm_ring (has_nnnorm (random_gen string.iterator_imp)))) : totally_disconnected_space (comm_ring (has_nnnorm (random_gen string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_75215 (h0 : topological_space (has_emptyc to_additive.value_type)) : totally_separated_space (has_emptyc to_additive.value_type) := sorry --non-trivial
lemma new_lemma_75216 (h0 : not (has_mem.mem (complete_semilattice_Sup num) has_emptyc.emptyc -> false)) : @is_compactly_generated.{0} (complete_semilattice_Sup.{0} num) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (complete_semilattice_Sup.{0} num) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (complete_semilattice_Sup.{0} num) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_75217 (h0 : complete_lattice (dlist (comm_ring to_additive.value_type))) : is_compactly_generated (dlist (comm_ring to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_75218 (h0 : fin has_zero.zero) : @group.fg.{1} (finset.{1} Type) (@matrix.vec_empty.{1} (group.{1} (finset.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_75219 (h0 : topological_space (has_zero (finset (finset environment.implicit_infer_kind)))) : normal_space (has_zero (finset (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_75220 (h1 : ring (has_add (has_nnnorm fun_info))) : is_domain (has_add (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_75221 (h0 : not (function.extfun Type topological_space -> false)) : @discrete_topology.{0} (with_one.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (with_one.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_75222 (h0 : ordered_comm_monoid (has_neg_part (option (mul_zero_class pos)))) : has_exists_mul_of_le (has_neg_part (option (mul_zero_class pos))) := sorry --non-trivial
lemma new_lemma_75223 (h0 : group (ring (has_neg pos))) : is_cyclic (ring (has_neg pos)) := sorry --non-trivial
lemma new_lemma_75224 (h0 : functor.add_const (list (boolean_algebra.core name)) linarith.comp) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_75225 (h0 : functor.add_const (topological_space (has_star empty)) unsigned) : @totally_disconnected_space.{0} (has_star.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_75226 (h0 : function.extfun nat fin) : @preconnected_space.{0} (has_bot.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (has_bot.{0} pos))  := sorry --non-trivial
lemma new_lemma_75227 (h0 : uniform_space (normed_comm_ring (has_add name))) : separated_space (normed_comm_ring (has_add name)) := sorry --non-trivial
lemma new_lemma_75228 (h0 : topological_space (semiring (random_gen linarith.comp_source))) : discrete_topology (semiring (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_75229 (h0 : functor.add_const (topological_space (left_cancel_monoid empty)) empty) : @t1_space.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_75230 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (mul_zero_class.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (mul_zero_class.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_75231 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (non_assoc_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (non_assoc_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_75232 (h0 : not (filter (topological_space string_imp) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_75233 (h0 : uniform_space (ring (boolean_algebra (boolean_algebra (has_add name))))) : separated_space (ring (boolean_algebra (boolean_algebra (has_add name)))) := sorry --non-trivial
lemma new_lemma_75234 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (metric_space.{0} (has_norm.{0} congr_arg_kind)) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (metric_space.{0} (has_norm.{0} congr_arg_kind)))  := sorry --non-trivial
lemma new_lemma_75235 (h0 : functor.add_const (ordered_add_comm_monoid (left_cancel_monoid empty)) empty) : @archimedean.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (left_cancel_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_75236 (h0 : complete_lattice (has_top (random_gen linarith.comp_source))) : complete_lattice.is_Sup_finite_compact (has_top (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_75237 (h1 : ring (has_compl (has_nnnorm linarith.comp_source))) : strong_rank_condition (has_compl (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_75238 (h0 : functor.add_const (ordered_add_comm_monoid (add_cancel_monoid linarith.comp)) linarith.comp) : @archimedean.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (add_cancel_monoid.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_75239 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_75240 (h0 : list (has_top (semiring (semiring (semiring empty))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_75241 (h0 : functor.add_const (functor.add_const (cancel_comm_monoid_with_zero Type) pos) pos) : @unique_factorization_monoid.{1} Type (@functor.add_const.run.{1 0} (cancel_comm_monoid_with_zero.{1} Type) pos (@functor.add_const.run.{1 0} (functor.add_const.{1 0} (cancel_comm_monoid_with_zero.{1} Type) pos) pos h0))  := sorry --non-trivial
lemma new_lemma_75242 (h0 : functor.add_const (topological_space (has_nndist unsigned)) linarith.comp) : @regular_space.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_75243 (h0 : add_monoid (has_zero (has_neg_part pos))) : add_monoid.fg (has_zero (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_75244 (h1 : group (has_norm to_additive.value_type)) : normalizer_condition (has_norm to_additive.value_type) := sorry --non-trivial
lemma new_lemma_75245 (h0 : topological_space (has_pos_part (has_pos_part (has_Inf linarith.comp)))) : preconnected_space (has_pos_part (has_pos_part (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_75246 (h0 : topological_space (has_Inf (has_neg real))) : discrete_topology (has_Inf (has_neg real)) := sorry --non-trivial
lemma new_lemma_75247 (h0 : functor.add_const (complete_lattice (add_comm_monoid environment.implicit_infer_kind)) pos) : @is_compactly_generated.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_comm_monoid.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_75248 (h0 : functor.add_const (topological_space (ring linarith.comp)) environment.implicit_infer_kind) : @discrete_topology.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_75249 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem ring)) : @strong_rank_condition.{0} to_additive.value_type (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) ring.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) to_additive.value_type)  := sorry --non-trivial
lemma new_lemma_75250 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (is_R_or_C.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (is_R_or_C.{0} num))  := sorry --non-trivial
lemma new_lemma_75251 (h0 : topological_space (linear_ordered_field (option unsigned))) : locally_compact_space (linear_ordered_field (option unsigned)) := sorry --non-trivial
lemma new_lemma_75252 (h0 : complete_lattice (complete_semilattice_Sup to_additive.value_type)) : is_atomistic (complete_semilattice_Sup to_additive.value_type) := sorry --non-trivial
lemma new_lemma_75253 (h1 : ring (ordered_cancel_comm_monoid (has_nnnorm fun_info))) : is_domain (ordered_cancel_comm_monoid (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_75254 (h0 : topological_space (ordered_comm_monoid (has_add (has_add name)))) : totally_separated_space (ordered_comm_monoid (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_75255 (h0 : functor.add_const (function.extfun Type monoid) linarith.comp) : @monoid.fg.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type monoid.{0}) linarith.comp h0) (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_75256 (h0 : topological_space (linear_ordered_field unsigned)) : t1_space (linear_ordered_field unsigned) := sorry --non-trivial
lemma new_lemma_75257 (h0 : prod (bin_tree empty) (bin_tree empty)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_75258 (h0 : functor.add_const (topological_space (has_add linarith.comp)) pos) : @totally_separated_space.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_75259 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_nndist.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_nndist.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_75260 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (add_comm_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_75261 (h0 : complete_lattice (with_bot (has_norm unsigned))) : is_atomistic (with_bot (has_norm unsigned)) := sorry --non-trivial
lemma new_lemma_75262 (h0 : functor.add_const (filter (has_add environment.implicit_infer_kind)) (boolean_algebra (finset linarith.comp))) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_75263 (h0 : functor.add_const (monoid (has_neg_part linarith.comp)) linarith.comp) : @monoid.fg.{0} (has_neg_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (monoid.{0} (has_neg_part.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_75264 (h0 : ring (boolean_algebra (ring (ring Type)))) : rank_condition (boolean_algebra (ring (ring Type))) := sorry --non-trivial
lemma new_lemma_75265 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @rank_condition.{0} (has_Inf.{0} linarith.comp) (@matrix.vec_empty.{0} (ring.{0} (has_Inf.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_75266 (h0 : uniform_space (has_lt reducibility_hints)) : complete_space (has_lt reducibility_hints) := sorry --non-trivial
lemma new_lemma_75267 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (ring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} num))  := sorry --non-trivial
lemma new_lemma_75268 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (finset pos)) := sorry --non-trivial
lemma new_lemma_75269 (h0 : topological_space (complete_distrib_lattice (semiring empty))) : totally_disconnected_space (complete_distrib_lattice (semiring empty)) := sorry --non-trivial
lemma new_lemma_75270 (h0 : has_mem.mem (random_gen (has_norm (has_norm linarith.comp))) has_emptyc.emptyc) : @strong_rank_condition.{0} (random_gen.{0} (has_norm.{0} (has_norm.{0} linarith.comp))) (@finset.pi.empty.{1 0} Type ring.{0} (random_gen.{0} (has_norm.{0} (has_norm.{0} linarith.comp))) h0)  := sorry --non-trivial
lemma new_lemma_75271 (h0 : semiring (normed_linear_ordered_field char)) (h1 : ideal (normed_linear_ordered_field char)) : nonempty (ideal.fg h1) := sorry --non-trivial
lemma new_lemma_75272 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (comm_semigroup.{0} pos) (@function.extfun_app.{2 1} Type add_group.{0} h0 (comm_semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_75273 (h0 : uniform_space (linear_ordered_semiring (semiring empty))) : complete_space (linear_ordered_semiring (semiring empty)) := sorry --non-trivial
lemma new_lemma_75274 (h0 : ring (semi_normed_ring fun_info)) : is_domain (semi_normed_ring fun_info) := sorry --non-trivial
lemma new_lemma_75275 (h0 : functor.add_const (filter (semigroup pos)) environment.implicit_infer_kind) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_75276 (h0 : ring (has_append reducibility_hints)) : rank_condition (has_append reducibility_hints) := sorry --non-trivial
lemma new_lemma_75277 (h0 : topological_space (linear_ordered_comm_monoid_with_zero (option empty))) : totally_disconnected_space (linear_ordered_comm_monoid_with_zero (option empty)) := sorry --non-trivial
lemma new_lemma_75278 (h0 : topological_space (has_add (has_Inf real))) : preirreducible_space (has_add (has_Inf real)) := sorry --non-trivial
lemma new_lemma_75279 (h0 : functor.add_const (topological_space (ordered_comm_ring real)) real) : @discrete_topology.{0} (ordered_comm_ring.{0} real) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} real)) real h0)  := sorry --non-trivial
lemma new_lemma_75280 (h0 : topological_space (has_Inf (has_neg pos))) : totally_disconnected_space (has_Inf (has_neg pos)) := sorry --non-trivial
lemma new_lemma_75281 (h0 : topological_space (linear_ordered_comm_ring (semiring (semiring unsigned)))) : t0_space (linear_ordered_comm_ring (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_75282 (h0 : functor.add_const (topological_space (has_neg environment.implicit_infer_kind)) (comm_group name)) : @totally_separated_space.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} environment.implicit_infer_kind)) (comm_group.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_75283 (h0 : not (topological_space (simple_graph linarith.ineq) -> false)) : @totally_disconnected_space.{0} (simple_graph.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (simple_graph.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_75284 (h0 : functor.add_const (ring (has_nndist unsigned)) num) : @rank_condition.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (has_nndist.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_75285 (h0 : function.extfun Type (functor.add_const (function.extfun Type topological_space))) : @preconnected_space.{0} (has_zero.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) environment.implicit_infer_kind (@function.extfun_app.{2 2} Type (functor.add_const.{1 0} (function.extfun.{2 1} Type topological_space.{0})) h0 environment.implicit_infer_kind)) (has_zero.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_75286 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (has_norm.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} congr_arg_kind)))))) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_norm.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} congr_arg_kind)))))))  := sorry --non-trivial
lemma new_lemma_75287 (h0 : semiring (semigroup (finset (finset linarith.comp)))) : is_noetherian_ring (semigroup (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_75288 (h0 : functor.add_const (complete_lattice (boolean_algebra pos)) (has_add (has_add pos))) : @is_atomistic.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (boolean_algebra.{0} pos)) (has_add.{0} (has_add.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_75289 (h0 : functor.add_const (list (ring name)) linarith.comp) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_75290 (h0 : topological_space (has_top (random_gen string_imp))) : totally_disconnected_space (has_top (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_75291 (h0 : topological_space (preorder unsigned)) : preconnected_space (preorder unsigned) := sorry --non-trivial
lemma new_lemma_75292 (h0 : group (has_top empty)) : normalizer_condition (has_top empty) := sorry --non-trivial
lemma new_lemma_75293 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_75294 (h0 : cancel_comm_monoid_with_zero (sub_neg_monoid unsigned)) : unique_factorization_monoid (sub_neg_monoid unsigned) := sorry --non-trivial
lemma new_lemma_75295 (h0 : not (function.extfun Type group -> false)) : @normalizer_condition.{0} (complete_semilattice_Sup.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (complete_semilattice_Sup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_75296 (h0 : topological_space (with_one linarith.comp)) : t0_space (with_one linarith.comp) := sorry --non-trivial
lemma new_lemma_75297 (h0 : option (function.extfun Type filter)) (h1 : function.extfun Type filter) : filter.ne_bot (function.extfun_app (option.get_or_else h0 h1) (mul_zero_class num)) := sorry --non-trivial
lemma new_lemma_75298 (h0 : finset (comm_group (finset (finset (finset pos))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_75299 (h0 : functor.add_const (group (normed_comm_ring pos)) name) : @group.fg.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (normed_comm_ring.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_75300 (h0 : functor.add_const (functor.add_const Prop (has_neg linarith.comp)) linarith.comp) : functor.add_const.run (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_75301 (h0 : add_group (has_nndist (has_to_string (finset linarith.comp)))) : is_add_cyclic (has_nndist (has_to_string (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_75302 (h0 : uniform_space (has_neg (ring pos))) : complete_space (has_neg (ring pos)) := sorry --non-trivial
lemma new_lemma_75303 (h0 : functor.add_const (complete_lattice (semigroup Type)) Type) : @is_atomistic.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 1} (complete_lattice.{1} (semigroup.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_75304 (h1 : group (normed_group to_additive.value_type)) : is_cyclic (normed_group to_additive.value_type) := sorry --non-trivial
lemma new_lemma_75305 (h0 : functor.add_const (topological_space (add_comm_monoid linarith.comp)) (finset (finset linarith.comp))) : @regular_space.{0} (add_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} linarith.comp)) (finset.{0} (finset.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_75306 (h0 : monoid (has_to_string (finset (has_neg (has_neg (finset (has_pos_part (has_zero Type)))))))) : monoid.fg (has_to_string (finset (has_neg (has_neg (finset (has_pos_part (has_zero Type))))))) := sorry --non-trivial
lemma new_lemma_75307 (h0 : topological_space (has_zero (comm_group pos))) : preirreducible_space (has_zero (comm_group pos)) := sorry --non-trivial
lemma new_lemma_75308 (h0 : functor.add_const (topological_space (option ennreal)) ennreal) : @t0_space.{0} (option.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_75309 (h0 : simple_graph empty -> simple_graph empty -> Prop) (h1 : option Prop) : option.lhoare (total h0) h1 := sorry --non-trivial
lemma new_lemma_75310 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (measurable_space.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measurable_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_75311 (h0 : function.extfun Type group) : @normalizer_condition.{0} (comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_75312 (h0 : functor.add_const (topological_space (ordered_ring num)) empty) : @totally_separated_space.{0} (ordered_ring.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_75313 (h0 : functor.add_const (topological_space (has_neg pos)) linarith.comp) : @regular_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_75314 (h0 : add_group (measurable_space (random_gen (random_gen (random_gen linarith.ineq))))) : is_add_cyclic (measurable_space (random_gen (random_gen (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_75315 (h0 : topological_space (normed_comm_ring (normed_comm_ring Type))) : normal_space (normed_comm_ring (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_75316 (h0 : fin has_zero.zero) : @totally_disconnected_space.{0} (non_assoc_semiring.{0} congr_arg_kind) (@matrix.vec_empty.{0} (topological_space.{0} (non_assoc_semiring.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_75317 (h0 : not (ring (with_zero linarith.comp_source) -> false)) : @rank_condition.{0} (with_zero.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (with_zero.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_75318 (h0 : ring (add_cancel_monoid (boolean_algebra.core unsigned))) : is_principal_ideal_ring (add_cancel_monoid (boolean_algebra.core unsigned)) := sorry --non-trivial
lemma new_lemma_75319 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (has_ssubset.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_ssubset.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_75320 (h0 : functor.add_const (topological_space (ring environment.implicit_infer_kind)) environment.implicit_infer_kind) : @t0_space.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_75321 (h0 : filter (left_cancel_semigroup (semiring congr_arg_kind))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_75322 (h0 : complete_lattice (add_comm_monoid (has_add (has_to_string Type)))) : is_compactly_generated (add_comm_monoid (has_add (has_to_string Type))) := sorry --non-trivial
lemma new_lemma_75323 (h0 : topological_space (metric_space (semiring unsigned))) : preirreducible_space (metric_space (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_75324 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @strong_rank_condition.{1} (plift.{1} empty) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ring.{1}) (plift.{1} empty))  := sorry --non-trivial
lemma new_lemma_75325 (h0 : topological_space (div_inv_monoid string_imp)) : path_connected_space (div_inv_monoid string_imp) := sorry --non-trivial
lemma new_lemma_75326 (h0 : not (topological_space (left_cancel_semigroup congr_arg_kind) -> false)) : @preirreducible_space.{0} (left_cancel_semigroup.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (left_cancel_semigroup.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_75327 (h0 : functor.add_const (topological_space (has_add pos)) environment.implicit_infer_kind) : @t1_space.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_75328 (h0 : finset (has_neg (option (canonically_linear_ordered_monoid (option (option (option pos))))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_75329 (h0 : group (semigroup (order_dual (has_add (finset (finset linarith.comp)))))) : group.fg (semigroup (order_dual (has_add (finset (finset linarith.comp))))) := sorry --non-trivial
lemma new_lemma_75330 (h0 : functor.add_const (filter (finset name)) name) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_75331 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (finset.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (finset.{0} num))  := sorry --non-trivial
lemma new_lemma_75332 (h0 : complete_lattice (monoid linarith.comp_source)) : is_compactly_generated (monoid linarith.comp_source) := sorry --non-trivial
lemma new_lemma_75333 (h0 : topological_space (has_bot (has_Inf (has_bot (has_add (has_add real)))))) : path_connected_space (has_bot (has_Inf (has_bot (has_add (has_add real))))) := sorry --non-trivial
lemma new_lemma_75334 (h0 : topological_space (measure_theory.measure_space (semiring empty))) : t0_space (measure_theory.measure_space (semiring empty)) := sorry --non-trivial
lemma new_lemma_75335 (h0 : topological_space (add_cancel_monoid (ring linarith.comp))) : totally_disconnected_space (add_cancel_monoid (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_75336 (h0 : topological_space (finset (ring pos))) : sequential_space (finset (ring pos)) := sorry --non-trivial
lemma new_lemma_75337 (h0 : uniform_space (semigroup (finset (has_to_string (has_add pos))))) : complete_space (semigroup (finset (has_to_string (has_add pos)))) := sorry --non-trivial
lemma new_lemma_75338 (h0 : functor.add_const (uniform_space (ordered_comm_monoid pos)) Type) : @complete_space.{0} (ordered_comm_monoid.{0} pos) (@functor.add_const.run.{0 1} (uniform_space.{0} (ordered_comm_monoid.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_75339 (h1 : filter (has_ssubset string_imp)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_75340 (h0 : fin has_zero.zero) : @is_cyclic.{1} (comm_semigroup.{1} Type) (@matrix.vec_empty.{1} (group.{1} (comm_semigroup.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_75341 (h0 : topological_space (boolean_algebra (has_add (has_add (has_add Type))))) : t0_space (boolean_algebra (has_add (has_add (has_add Type)))) := sorry --non-trivial
lemma new_lemma_75342 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : countable_Inter_filter (function.extfun_app (function.extfun_app h0 filter) (finset unsigned)) := sorry --non-trivial
lemma new_lemma_75343 (h0 : has_mem.mem (semiring (random_gen fun_info)) has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} (semiring.{0} (random_gen.{0} fun_info)) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (semiring.{0} (random_gen.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_75344 (h0 : topological_space (add_comm_monoid (finset environment.implicit_infer_kind))) : loc_path_connected_space (add_comm_monoid (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_75345 (h0 : group (has_nnnorm (has_compl to_additive.value_type))) : is_cyclic (has_nnnorm (has_compl to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_75346 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @locally_compact_space.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_75347 (h0 : filter (has_union (semiring (semiring congr_arg_kind)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_75348 (h0 : group (has_top (random_gen fun_info))) : is_cyclic (has_top (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_75349 (h0 : ring (comm_ring (has_ssubset linarith.comp_source))) : is_domain (comm_ring (has_ssubset linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_75350 (h0 : finset (option congr_arg_kind)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_75351 (h0 : topological_space (with_one (measurable_space empty))) : totally_disconnected_space (with_one (measurable_space empty)) := sorry --non-trivial
lemma new_lemma_75352 (h0 : uniform_space (has_lt (id string_imp))) : complete_space (has_lt (id string_imp)) := sorry --non-trivial
lemma new_lemma_75353 (h0 : functor.add_const (complete_lattice (boolean_algebra.core environment.implicit_infer_kind)) Type) : @is_atomistic.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (complete_lattice.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_75354 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (has_add.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} num))  := sorry --non-trivial
lemma new_lemma_75355 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (partial_order.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (partial_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_75356 (h0 : complete_lattice (has_zero (has_add (has_add (has_add (has_add Type)))))) : is_atomistic (has_zero (has_add (has_add (has_add (has_add Type))))) := sorry --non-trivial
lemma new_lemma_75357 (h0 : cancel_comm_monoid_with_zero (add_cancel_monoid (has_add (has_add linarith.comp)))) : unique_factorization_monoid (add_cancel_monoid (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_75358 (h0 : functor.add_const (function.extfun (Type 1) group) pos) : @is_simple_group.{1} (has_neg.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) group.{1}) pos h0) (has_neg.{1} Type))  := sorry --non-trivial
lemma new_lemma_75359 (h0 : functor.add_const (ring (semigroup congr_arg_kind)) unsigned) : @rank_condition.{0} (semigroup.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ring.{0} (semigroup.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_75360 (h0 : topological_space (has_Inf (has_Inf (has_Inf (has_add (has_Inf pos)))))) : preconnected_space (has_Inf (has_Inf (has_Inf (has_add (has_Inf pos))))) := sorry --non-trivial
lemma new_lemma_75361 (h0 : not (complete_lattice (distrib linarith.ineq) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (distrib.{0} linarith.ineq) (@classical.by_contradiction'.{1} (complete_lattice.{0} (distrib.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_75362 (h0 : not (topological_space (add_zero_class reducibility_hints) -> false)) : @totally_disconnected_space.{0} (add_zero_class.{0} reducibility_hints) (@classical.by_contradiction'.{1} (topological_space.{0} (add_zero_class.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_75363 (h0 : ring (ring (has_neg (has_neg (ring pos))))) : rank_condition (ring (has_neg (has_neg (ring pos)))) := sorry --non-trivial
lemma new_lemma_75364 (h0 : filter (random_gen (has_top (has_top congr_arg_kind)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_75365 (h1 : ring (dlist (random_gen char))) : rank_condition (dlist (random_gen char)) := sorry --non-trivial
lemma new_lemma_75366 (h0 : cancel_comm_monoid_with_zero (ring (ring Type))) : unique_factorization_monoid (ring (ring Type)) := sorry --non-trivial
lemma new_lemma_75367 (h0 : filter (has_neg (has_to_string unsigned))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_75368 (h0 : functor.add_const (functor.add_const Prop environment.implicit_infer_kind) Type) : functor.add_const.run (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_75369 (h0 : functor.add_const (topological_space (add_cancel_monoid empty)) empty) : @irreducible_space.{0} (add_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_75370 (h0 : functor.add_const (ordered_add_comm_monoid (add_comm_monoid linarith.comp)) environment.implicit_infer_kind) : @archimedean.{0} (add_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (add_comm_monoid.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_75371 (h0 : functor.add_const Prop (ordered_comm_monoid Type)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_75372 (h1 : group (measurable_space (random_gen linarith.ineq))) : normalizer_condition (measurable_space (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_75373 (h0 : functor.add_const (monoid (has_to_string pos)) Type) : @monoid.fg.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 1} (monoid.{0} (has_to_string.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_75374 (h0 : functor.add_const (filter (normed_comm_ring linarith.comp)) pos) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_75375 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (has_to_string.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_to_string.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_75376 (h0 : ordered_add_comm_monoid (complete_distrib_lattice (comm_group (comm_group name)))) : archimedean (complete_distrib_lattice (comm_group (comm_group name))) := sorry --non-trivial
lemma new_lemma_75377 (h0 : set (set (random_gen (random_gen (random_gen (random_gen fun_info)))))) : is_countably_spanning h0 := sorry --non-trivial
lemma new_lemma_75378 (h0 : functor.add_const (topological_space (partial_order empty)) congr_arg_kind) : @t0_space.{0} (partial_order.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (partial_order.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_75379 (h0 : ring (has_Inf Type)) : rank_condition (has_Inf Type) := sorry --non-trivial
lemma new_lemma_75380 (h0 : functor.add_const (complete_lattice auto.case_option) unsigned) : @is_atomistic.{0} auto.case_option (@functor.add_const.run.{0 0} (complete_lattice.{0} auto.case_option) unsigned h0)  := sorry --non-trivial
lemma new_lemma_75381 (h0 : topological_space (complete_linear_order congr_arg_kind)) : t0_space (complete_linear_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_75382 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (with_bot.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (with_bot.{0} num))  := sorry --non-trivial
lemma new_lemma_75383 (h0 : topological_space (add_cancel_monoid (has_add (normed_comm_ring (normed_comm_ring linarith.comp))))) : t1_space (add_cancel_monoid (has_add (normed_comm_ring (normed_comm_ring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_75384 (h0 : functor.add_const (add_group (normed_group empty)) empty) : @is_add_cyclic.{0} (normed_group.{0} empty) (@functor.add_const.run.{0 0} (add_group.{0} (normed_group.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_75385 (h0 : topological_space (has_neg (has_neg pos))) : loc_path_connected_space (has_neg (has_neg pos)) := sorry --non-trivial
lemma new_lemma_75386 (h3 : topological_space (comm_ring char)) : t0_space (comm_ring char) := sorry --non-trivial
lemma new_lemma_75387 (h0 : functor.add_const (ordered_add_comm_monoid (finset environment.implicit_infer_kind)) (normed_comm_ring pos)) : @archimedean.{0} (finset.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (finset.{0} environment.implicit_infer_kind)) (normed_comm_ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_75388 (h0 : group (ring (has_pos_part linarith.comp))) : normalizer_condition (ring (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_75389 (h0 : functor.add_const (topological_space (semigroup unsigned)) name) : @path_connected_space.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_75390 (h1 : filter (distrib_lattice (random_gen char))) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_75391 (h0 : set (uniform_space linarith.comp_source)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_75392 (h0 : functor.add_const (finset (has_nndist name)) name) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_75393 (h0 : ring (add_cancel_comm_monoid (mul_one_class (mul_one_class (mul_one_class char))))) : rank_condition (add_cancel_comm_monoid (mul_one_class (mul_one_class (mul_one_class char)))) := sorry --non-trivial
lemma new_lemma_75394 (h0 : add_monoid (measurable_space (has_norm linarith.comp))) : add_monoid.fg (measurable_space (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_75395 (h0 : fin has_zero.zero) : @complete_space.{0} (canonically_ordered_monoid.{0} real) (@matrix.vec_empty.{0} (uniform_space.{0} (canonically_ordered_monoid.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_75396 (h0 : filter (monoid (option (option ennreal)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_75397 (h0 : monoid (has_top (semiring (has_top real)))) : monoid.fg (has_top (semiring (has_top real))) := sorry --non-trivial
lemma new_lemma_75398 (h0 : functor.add_const (complete_lattice (has_nndist Type)) linarith.comp) : @complete_lattice.is_Sup_finite_compact.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (has_nndist.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_75399 (h0 : topological_space (has_Sup (semiring unsigned))) : path_connected_space (has_Sup (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_75400 (h0 : functor.add_const (topological_space (has_add linarith.comp)) Type) : @irreducible_space.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_add.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_75401 (h0 : add_group (has_le (has_nnnorm linarith.ineq))) : is_add_cyclic (has_le (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_75402 (h0 : topological_space (normed_lattice_add_comm_group (has_add pos))) : t1_space (normed_lattice_add_comm_group (has_add pos)) := sorry --non-trivial
lemma new_lemma_75403 (h0 : functor.add_const (add_monoid (normed_comm_ring pos)) environment.implicit_infer_kind) : @add_monoid.fg.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (add_monoid.{0} (normed_comm_ring.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_75404 (h0 : not (add_monoid (complete_linear_order unsigned) -> false)) : @add_monoid.fg.{0} (complete_linear_order.{0} unsigned) (@classical.by_contradiction'.{1} (add_monoid.{0} (complete_linear_order.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_75405 (h0 : filter (comm_ring (has_inv string_imp))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_75406 (h0 : has_lt (non_unital_non_assoc_semiring (mul_one_class (mul_one_class fun_info)))) : no_max_order (non_unital_non_assoc_semiring (mul_one_class (mul_one_class fun_info))) := sorry --non-trivial
lemma new_lemma_75407 (h0 : topological_space (has_zero (has_neg linarith.comp))) : irreducible_space (has_zero (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_75408 (h1 : topological_space (has_add string_imp)) : topological_space.first_countable_topology (has_add string_imp) := sorry --non-trivial
lemma new_lemma_75409 (h0 : not (has_mem.mem (complete_semilattice_Sup congr_arg_kind) has_emptyc.emptyc -> false)) : @normalizer_condition.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type group.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (complete_semilattice_Sup.{0} congr_arg_kind) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_75410 (h0 : topological_space (has_Inf linarith.comp)) : preconnected_space (has_Inf linarith.comp) := sorry --non-trivial
lemma new_lemma_75411 (h0 : functor.add_const (group (has_zero Type)) (has_add (has_neg linarith.comp))) : @is_simple_group.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (has_zero.{1} Type)) (has_add.{0} (has_neg.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_75412 (h0 : function.extfun Type topological_space) : @normal_space.{0} (add_right_cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_right_cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_75413 (h0 : not (topological_space (measure_theory.measure_space congr_arg_kind) -> false)) : @locally_compact_space.{0} (measure_theory.measure_space.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (measure_theory.measure_space.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_75414 (h0 : topological_space (comm_group (option pos))) : preconnected_space (comm_group (option pos)) := sorry --non-trivial
lemma new_lemma_75415 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (normed_linear_ordered_group empty)) := sorry --non-trivial
lemma new_lemma_75416 (h0 : function.extfun Type group) : @group.fg.{0} (topological_space.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} h0 (topological_space.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_75417 (h0 : topological_space (normed_linear_ordered_group (semiring empty))) : path_connected_space (normed_linear_ordered_group (semiring empty)) := sorry --non-trivial
lemma new_lemma_75418 (h0 : functor.add_const (topological_space (has_pos_part pos)) name) : @path_connected_space.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_75419 (h0 : functor.add_const (topological_space (add_cancel_monoid pos)) environment.implicit_infer_kind) : @regular_space.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_75420 (h0 : topological_space (normed_comm_ring (has_add linarith.comp))) : t0_space (normed_comm_ring (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_75421 (h0 : semiring (canonically_ordered_monoid name)) : is_noetherian_ring (canonically_ordered_monoid name) := sorry --non-trivial
lemma new_lemma_75422 (h0 : functor.add_const (topological_space (boolean_algebra linarith.comp)) Type) : @sequential_space.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_75423 (h0 : functor.add_const (filter (has_add Type)) name) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_75424 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @is_atomistic.{1} (sub_neg_monoid.{1} Type) (@matrix.vec_empty.{1} (complete_lattice.{1} (sub_neg_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_75425 (h0 : function.extfun (Type 1) topological_space) : @preirreducible_space.{1} (sub_neg_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (sub_neg_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_75426 (h0 : not (has_mem.mem (with_bot empty) has_emptyc.emptyc -> false)) : @is_atomistic.{0} (with_bot.{0} empty) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (with_bot.{0} empty) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_bot.{0} empty) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_75427 (h0 : ring (boolean_algebra (semigroup pos))) : is_principal_ideal_ring (boolean_algebra (semigroup pos)) := sorry --non-trivial
lemma new_lemma_75428 (h0 : complete_lattice (normed_lattice_add_comm_group (has_bot real))) : is_atomistic (normed_lattice_add_comm_group (has_bot real)) := sorry --non-trivial
lemma new_lemma_75429 (h0 : function.extfun Type topological_space) : @t1_space.{0} (has_Sup.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_Sup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_75430 (h0 : functor.add_const (topological_space (add_cancel_monoid pos)) environment.implicit_infer_kind) : @t1_space.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_75431 (h0 : functor.add_const (complete_lattice (canonically_ordered_comm_semiring pos)) (ring Type)) : @complete_lattice.is_Sup_finite_compact.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.add_const.run.{0 1} (complete_lattice.{0} (canonically_ordered_comm_semiring.{0} pos)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_75432 (h0 : topological_space (normed_lattice_add_comm_group (has_Inf real))) : locally_compact_space (normed_lattice_add_comm_group (has_Inf real)) := sorry --non-trivial
lemma new_lemma_75433 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_pos_part linarith.comp)) linarith.comp) : @unique_factorization_monoid.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_pos_part.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_75434 (h0 : function.extfun Type group) : @group.fg.{0} (normed_lattice_add_comm_group.{0} real) (@function.extfun_app.{2 1} Type group.{0} h0 (normed_lattice_add_comm_group.{0} real))  := sorry --non-trivial
lemma new_lemma_75435 (h0 : functor.add_const (semiring (ordered_comm_monoid pos)) (ring linarith.comp)) : @is_noetherian_ring.{0} (ordered_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (semiring.{0} (ordered_comm_monoid.{0} pos)) (ring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_75436 (h0 : functor.add_const (topological_space (left_cancel_semigroup congr_arg_kind)) num) : @totally_disconnected_space.{0} (left_cancel_semigroup.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_semigroup.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_75437 (h0 : complete_lattice (has_bot (sub_neg_monoid Type))) : is_compactly_generated (has_bot (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_75438 (h0 : function.extfun (Type 1) topological_space) : @loc_path_connected_space.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_75439 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (measure_theory.measure_space.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (measure_theory.measure_space.{0} num))  := sorry --non-trivial
lemma new_lemma_75440 (h0 : topological_space (has_dist (option congr_arg_kind))) : preirreducible_space (has_dist (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_75441 (h0 : has_mem.mem (has_norm empty) has_emptyc.emptyc) : @strong_rank_condition.{0} (has_norm.{0} empty) (@finset.pi.empty.{1 0} Type ring.{0} (has_norm.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_75442 (h0 : functor.add_const (ordered_comm_monoid (has_zero name)) linarith.comp) : @has_exists_mul_of_le.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_zero.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_75443 (h0 : add_monoid (with_one (has_top (has_top (has_top unsigned))))) : add_monoid.fg (with_one (has_top (has_top (has_top unsigned)))) := sorry --non-trivial
lemma new_lemma_75444 (h2 : topological_space (has_inv string_imp)) : totally_disconnected_space (has_inv string_imp) := sorry --non-trivial
lemma new_lemma_75445 (h0 : not (filter (with_one fun_info) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_75446 (h2 h3 : multiset fun_info) : multiset.subset h2 h3 := sorry --non-trivial
lemma new_lemma_75447 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} congr_arg_kind (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_75448 (h0 : function.extfun (finset Type) (has_mem.mem (measurable_space linarith.comp_source))) : is_compactly_generated (measurable_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_75449 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (ordered_comm_group.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} h0 (ordered_comm_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_75450 (h0 : semiring (filter congr_arg_kind)) : is_noetherian_ring (filter congr_arg_kind) := sorry --non-trivial
lemma new_lemma_75451 (h0 : functor.add_const (filter (complete_distrib_lattice linarith.comp)) Type) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_75452 (h1 : ring (has_ssubset (random_gen (random_gen string_imp)))) : is_domain (has_ssubset (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_75453 (h0 : not (topological_space (has_sub empty) -> false)) : @irreducible_space.{0} (has_sub.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (has_sub.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_75454 (h0 : not (function.extfun Type topological_space -> false)) : @t1_space.{0} (mul_zero_class.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (mul_zero_class.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_75455 (h0 : topological_space (partial_order (semiring empty))) : normal_space (partial_order (semiring empty)) := sorry --non-trivial
lemma new_lemma_75456 (h0 : has_mem.mem (linear_ordered_semiring linarith.ineq) has_emptyc.emptyc) : @complete_space.{0} (linear_ordered_semiring.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type uniform_space.{0} (linear_ordered_semiring.{0} linarith.ineq) h0)  := sorry --non-trivial
lemma new_lemma_75457 (h0 : topological_space (metric_space (semiring (has_norm empty)))) : totally_separated_space (metric_space (semiring (has_norm empty))) := sorry --non-trivial
lemma new_lemma_75458 (h0 : preorder (distrib_lattice (has_ssubset (has_inv (random_gen to_additive.value_type))))) (h1 : topological_space (distrib_lattice (has_ssubset (has_inv (random_gen to_additive.value_type))))) : Inf_convergence_class (distrib_lattice (has_ssubset (has_inv (random_gen to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_75459 (h0 : topological_space (semigroup (option unsigned))) : totally_separated_space (semigroup (option unsigned)) := sorry --non-trivial
lemma new_lemma_75460 (h0 : has_to_string (has_zero (has_add Type)) -> has_to_string (has_zero (has_add Type)) -> Prop) : is_antisymm (has_to_string (has_zero (has_add Type))) h0 := sorry --non-trivial
lemma new_lemma_75461 (h0 : topological_space (simple_graph (has_add linarith.comp))) : t0_space (simple_graph (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_75462 (h0 : topological_space (add_comm_monoid (option pos))) : locally_compact_space (add_comm_monoid (option pos)) := sorry --non-trivial
lemma new_lemma_75463 (h0 : complete_lattice (normed_field to_additive.value_type)) : is_compactly_generated (normed_field to_additive.value_type) := sorry --non-trivial
lemma new_lemma_75464 (h0 h1 : multiset occurrences) : multiset.le h0 h1 := sorry --non-trivial
lemma new_lemma_75465 (h1 : complete_lattice (semi_normed_comm_ring (random_gen (random_gen string_imp)))) : complete_lattice.is_Sup_finite_compact (semi_normed_comm_ring (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_75466 (h0 : ring (with_bot (semiring unsigned))) : rank_condition (with_bot (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_75467 (h0 : topological_space (complete_distrib_lattice (option (option empty)))) : t0_space (complete_distrib_lattice (option (option empty))) := sorry --non-trivial
lemma new_lemma_75468 (h0 : topological_space (generalized_boolean_algebra (has_pos_part linarith.comp))) : preirreducible_space (generalized_boolean_algebra (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_75469 (h0 : topological_space (linear_ordered_comm_monoid_with_zero (semiring empty))) : loc_path_connected_space (linear_ordered_comm_monoid_with_zero (semiring empty)) := sorry --non-trivial
lemma new_lemma_75470 (h0 : not (topological_space (has_one congr_arg_kind) -> false)) : @topological_space.separable_space.{0} (has_one.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (has_one.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_75471 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_nndist.{0} (option.{0} congr_arg_kind)) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_nndist.{0} (option.{0} congr_arg_kind)))  := sorry --non-trivial
lemma new_lemma_75472 (h0 : function.extfun Type topological_space) : @regular_space.{0} (generalized_boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (generalized_boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_75473 (h0 : topological_space (has_ssubset environment.projection_info)) : totally_disconnected_space (has_ssubset environment.projection_info) := sorry --non-trivial
lemma new_lemma_75474 (h0 : functor.add_const (group (has_nndist pos)) pos) : @group.fg.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_nndist.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_75475 (h0 : topological_space (simple_graph (mul_one_class string.iterator_imp))) (h1 : preorder (simple_graph (mul_one_class string.iterator_imp))) : order_topology (simple_graph (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_75476 (h0 : add_group (has_inv (comm_ring (has_inv fun_info)))) : is_add_cyclic (has_inv (comm_ring (has_inv fun_info))) := sorry --non-trivial
lemma new_lemma_75477 (h0 : topological_space (has_neg_part ennreal)) : irreducible_space (has_neg_part ennreal) := sorry --non-trivial
lemma new_lemma_75478 (h0 : ring (has_Inf (has_Inf (has_Inf (has_Inf pos))))) : rank_condition (has_Inf (has_Inf (has_Inf (has_Inf pos)))) := sorry --non-trivial
lemma new_lemma_75479 (h0 : functor.add_const (topological_space (has_pos_part linarith.comp)) (has_add Type)) : @preirreducible_space.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_pos_part.{0} linarith.comp)) (has_add.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_75480 (h0 : fin has_zero.zero) : @is_noetherian_ring.{0} (comm_semigroup.{0} linarith.comp) (@matrix.vec_empty.{0} (semiring.{0} (comm_semigroup.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_75481 (h0 : complete_lattice (semigroup (cancel_monoid pos))) : is_compactly_generated (semigroup (cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_75482 (h0 : function.extfun Type group) : @is_cyclic.{0} (with_one.{0} (denumerable.{0} fun_info)) (@function.extfun_app.{2 1} Type group.{0} h0 (with_one.{0} (denumerable.{0} fun_info)))  := sorry --non-trivial
lemma new_lemma_75483 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (ordered_cancel_add_comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_75484 (h0 : ring (add_cancel_monoid (has_add (bin_tree linarith.comp)))) : rank_condition (add_cancel_monoid (has_add (bin_tree linarith.comp))) := sorry --non-trivial
lemma new_lemma_75485 (h0 : filter (ordered_comm_ring (comm_semigroup real))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_75486 (h0 : add_monoid (has_edist (option empty))) : add_monoid.fg (has_edist (option empty)) := sorry --non-trivial
lemma new_lemma_75487 (h0 : group (option pos)) : is_cyclic (option pos) := sorry --non-trivial
lemma new_lemma_75488 (h0 : topological_space (left_cancel_monoid (semiring congr_arg_kind))) : discrete_topology (left_cancel_monoid (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_75489 (h0 : has_mem.mem complete_lattice has_emptyc.emptyc) : @is_compactly_generated.{0} (has_inv.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} h0) (has_inv.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_75490 (h0 : uniform_space (normed_comm_ring (finset (finset environment.implicit_infer_kind)))) : complete_space (normed_comm_ring (finset (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_75491 (h0 : functor.add_const (filter (semigroup Type)) linarith.comp) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_75492 (h0 : functor.add_const (monoid (sub_neg_monoid linarith.comp)) Type) : @monoid.fg.{0} (sub_neg_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (monoid.{0} (sub_neg_monoid.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_75493 (h0 : function.extfun Type (functor.comp add_monoid has_nndist)) : @add_monoid.fg.{0} (has_nndist.{0} name) (@functor.comp.run.{0 0 0} add_monoid.{0} has_nndist.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} add_monoid.{0} has_nndist.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_75494 (h0 : group (canonically_ordered_monoid (sub_neg_monoid Type))) : is_simple_group (canonically_ordered_monoid (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_75495 (h0 : monoid (random_gen (has_top num))) : monoid.fg (random_gen (has_top num)) := sorry --non-trivial
lemma new_lemma_75496 (h0 : functor.add_const (topological_space (boolean_algebra name)) name) : @preirreducible_space.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_75497 (h0 : functor.add_const (ring (add_cancel_comm_monoid empty)) empty) : @strong_rank_condition.{0} (add_cancel_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (add_cancel_comm_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_75498 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem monoid)) : @monoid.fg.{0} (linear_ordered_semiring.{0} num) (@function.extfun_app.{2 1} Type monoid.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) monoid.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) monoid.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (linear_ordered_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_75499 (h0 : topological_space (linear_ordered_comm_ring unsigned)) : t0_space (linear_ordered_comm_ring unsigned) := sorry --non-trivial
lemma new_lemma_75500 (h0 : uniform_space (with_bot (has_top num))) : separated_space (with_bot (has_top num)) := sorry --non-trivial
lemma new_lemma_75501 (h0 : functor.add_const (semiring (option pos)) pos) : @is_noetherian_ring.{0} (option.{0} pos) (@functor.add_const.run.{0 0} (semiring.{0} (option.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_75502 (h0 : functor.add_const (group (has_zero pos)) environment.implicit_infer_kind) : @is_simple_group.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_zero.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_75503 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (add_comm_monoid ennreal)) := sorry --non-trivial
lemma new_lemma_75504 (h0 : has_mem.mem (has_emptyc congr_arg_kind) has_emptyc.emptyc) : @strong_rank_condition.{0} (has_emptyc.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type ring.{0} (has_emptyc.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_75505 (h0 : function.extfun Type topological_space) : @normal_space.{0} (has_dist.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_dist.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_75506 (h0 : ring (has_to_string (has_neg environment.implicit_infer_kind))) : strong_rank_condition (has_to_string (has_neg environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_75507 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (linear_ordered_field.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} h0 (linear_ordered_field.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_75508 (h0 : functor.add_const (topological_space (preorder congr_arg_kind)) num) : @locally_compact_space.{0} (preorder.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (preorder.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_75509 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_neg unsigned)) (has_add (has_add name))) : @unique_factorization_monoid.{0} (has_neg.{0} unsigned) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_neg.{0} unsigned)) (has_add.{0} (has_add.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_75510 (h0 : topological_space (has_nndist (finset pos))) : loc_path_connected_space (has_nndist (finset pos)) := sorry --non-trivial
lemma new_lemma_75511 (h0 : topological_space (add_comm_monoid (has_nndist (has_to_string Type)))) : preconnected_space (add_comm_monoid (has_nndist (has_to_string Type))) := sorry --non-trivial
lemma new_lemma_75512 (h0 : cancel_comm_monoid_with_zero (measure_theory.measure_space num)) : unique_factorization_monoid (measure_theory.measure_space num) := sorry --non-trivial
lemma new_lemma_75513 (h0 : functor.add_const (topological_space (has_neg pos)) pos) : @sequential_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_75514 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_75515 (h0 : ring (has_neg_part (comm_group unsigned))) : strong_rank_condition (has_neg_part (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_75516 (h0 : ordered_add_comm_monoid (semiring empty)) : archimedean (semiring empty) := sorry --non-trivial
lemma new_lemma_75517 (h0 : topological_space (semi_normed_ring string_imp)) : path_connected_space (semi_normed_ring string_imp) := sorry --non-trivial
lemma new_lemma_75518 (h0 : add_group (metric_space (random_gen (has_nnnorm char)))) : is_add_cyclic (metric_space (random_gen (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_75519 (h0 : functor.add_const Prop (add_comm_monoid pos)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_75520 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (sub_neg_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (sub_neg_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_75521 (h0 : functor.add_const (topological_space (mul_zero_class ennreal)) name) : @totally_separated_space.{0} (mul_zero_class.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_75522 (h0 : topological_space (normed_comm_ring (finset (has_nndist name)))) : normal_space (normed_comm_ring (finset (has_nndist name))) := sorry --non-trivial
lemma new_lemma_75523 (h0 : functor.add_const (list (has_nndist unsigned)) unsigned) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_75524 (h0 : add_monoid (has_sub (semiring unsigned))) : add_monoid.fg (has_sub (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_75525 (h0 : topological_space (canonically_ordered_comm_semiring num)) : preirreducible_space (canonically_ordered_comm_semiring num) := sorry --non-trivial
lemma new_lemma_75526 (h0 : list (boolean_algebra (normed_comm_ring Type))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_75527 (h0 : topological_space (with_bot linarith.comp_source)) : discrete_topology (with_bot linarith.comp_source) := sorry --non-trivial
lemma new_lemma_75528 (h0 : functor.add_const (function.extfun Type uniform_space) linarith.comp) : @separated_space.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) linarith.comp h0) (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_75529 (h0 : topological_space (add_cancel_monoid (boolean_algebra.core pos))) : locally_compact_space (add_cancel_monoid (boolean_algebra.core pos)) := sorry --non-trivial
lemma new_lemma_75530 (h0 : functor.add_const (topological_space (ordered_comm_monoid Type)) name) : @locally_compact_space.{1} (ordered_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ordered_comm_monoid.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_75531 (h0 : functor.add_const (ordered_add_comm_monoid (ring unsigned)) unsigned) : @archimedean.{0} (ring.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (ring.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_75532 (h0 : not (prod num num -> false)) : id_rel (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_75533 (h0 : cancel_comm_monoid_with_zero (boolean_algebra.core (cancel_monoid name))) : unique_factorization_monoid (boolean_algebra.core (cancel_monoid name)) := sorry --non-trivial
lemma new_lemma_75534 (h0 : ring (complete_distrib_lattice string_imp)) : strong_rank_condition (complete_distrib_lattice string_imp) := sorry --non-trivial
lemma new_lemma_75535 (h0 : topological_space (linear_ordered_add_comm_group (comm_ring (random_gen linarith.comp_source)))) : t0_space (linear_ordered_add_comm_group (comm_ring (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_75536 (h0 : cancel_comm_monoid_with_zero (has_add (option unsigned))) : unique_factorization_monoid (has_add (option unsigned)) := sorry --non-trivial
lemma new_lemma_75537 (h0 : ring (semi_normed_ring (metric_space to_additive.value_type))) : strong_rank_condition (semi_normed_ring (metric_space to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_75538 (h0 : topological_space (distrib enat)) : path_connected_space (distrib enat) := sorry --non-trivial
lemma new_lemma_75539 (h0 : has_mem.mem (with_bot congr_arg_kind) has_emptyc.emptyc) : @locally_compact_space.{0} (with_bot.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_bot.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_75540 (h0 : functor.add_const (group (generalized_boolean_algebra pos)) (has_neg (has_Inf name))) : @group.fg.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (generalized_boolean_algebra.{0} pos)) (has_neg.{0} (has_Inf.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_75541 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (has_neg.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (has_neg.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_75542 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (linear_ordered_field.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (linear_ordered_field.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_75543 (h0 : functor.add_const (topological_space (has_add unsigned)) environment.implicit_infer_kind) : @locally_compact_space.{0} (has_add.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_75544 (h0 : complete_lattice std_gen) : is_compactly_generated std_gen := sorry --non-trivial
lemma new_lemma_75545 (h0 : not (topological_space (distrib_lattice linarith.ineq) -> false)) : @t0_space.{0} (distrib_lattice.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (distrib_lattice.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_75546 (h0 : ring (canonically_ordered_monoid (has_add (sub_neg_monoid (has_neg pos))))) : strong_rank_condition (canonically_ordered_monoid (has_add (sub_neg_monoid (has_neg pos)))) := sorry --non-trivial
lemma new_lemma_75547 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_75548 (h0 : has_pos_part (has_Inf Type) -> has_pos_part (has_Inf Type) -> Prop) : transitive h0 := sorry --non-trivial
lemma new_lemma_75549 (h0 : group (with_one (with_bot linarith.comp_source))) : group.fg (with_one (with_bot linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_75550 (h0 : not (topological_space (simple_graph reducibility_hints) -> false)) : @path_connected_space.{0} (simple_graph.{0} reducibility_hints) (@classical.by_contradiction'.{1} (topological_space.{0} (simple_graph.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_75551 (h0 : ring (topological_space (comm_ring linarith.ineq))) : rank_condition (topological_space (comm_ring linarith.ineq)) := sorry --non-trivial
lemma new_lemma_75552 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (list.ret (function.extfun_app (function.extfun_app h0 ring) (option ennreal))) := sorry --non-trivial
lemma new_lemma_75553 (h1 : uniform_space (topological_space (denumerable (finset char)))) : complete_space (topological_space (denumerable (finset char))) := sorry --non-trivial
lemma new_lemma_75554 (h0 : group (finset (sub_neg_monoid real))) : group.fg (finset (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_75555 (h0 : semiring (add_group (semiring congr_arg_kind))) : is_noetherian_ring (add_group (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_75556 (h0 : functor.add_const (group (linear_ordered_field name)) (option pos)) : @group.fg.{0} (linear_ordered_field.{0} name) (@functor.add_const.run.{0 0} (group.{0} (linear_ordered_field.{0} name)) (option.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_75557 (h1 : has_mul (add_comm_semigroup std_gen)) (h2 : add_comm_semigroup std_gen) : is_right_regular h2 := sorry --non-trivial
lemma new_lemma_75558 (h0 : topological_space (simple_graph fun_info)) (h1 : add_group (simple_graph fun_info)) : topological_add_group (simple_graph fun_info) := sorry --non-trivial
lemma new_lemma_75559 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (has_nndist.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_nndist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_75560 (h0 : ordered_comm_monoid (add_cancel_monoid (add_comm_monoid pos))) : has_exists_mul_of_le (add_cancel_monoid (add_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_75561 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (finset.{0} name) (@function.extfun_app.{2 1} Type monoid.{0} h0 (finset.{0} name))  := sorry --non-trivial
lemma new_lemma_75562 (h0 : functor.add_const (filter (cancel_monoid Type)) name) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_75563 (h0 : complete_lattice (has_top (has_nnnorm linarith.comp_source))) : complete_lattice.is_Sup_finite_compact (has_top (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_75564 (h0 : topological_space (ordered_comm_ring (boolean_algebra.core Type))) : preconnected_space (ordered_comm_ring (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_75565 (h0 : complete_lattice (linear_ordered_add_comm_group to_additive.value_type)) : is_atomistic (linear_ordered_add_comm_group to_additive.value_type) := sorry --non-trivial
lemma new_lemma_75566 (h0 : function.extfun nat fin) : @strong_rank_condition.{0} (ordered_comm_ring.{0} real) (@matrix.vec_empty.{0} (ring.{0} (ordered_comm_ring.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_75567 (h0 : functor.add_const (complete_lattice (ordered_ring unsigned)) congr_arg_kind) : @is_compactly_generated.{0} (ordered_ring.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ordered_ring.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_75568 (h0 : monoid (measurable_space (has_top (has_norm congr_arg_kind)))) : monoid.fg (measurable_space (has_top (has_norm congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_75569 (h0 : group (comm_ring (random_gen linarith.ineq))) : group.fg (comm_ring (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_75570 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (linear_ordered_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_75571 (h0 : add_group (has_bot (has_Inf (has_add (has_add (has_Inf (has_Inf Type))))))) : is_add_cyclic (has_bot (has_Inf (has_add (has_add (has_Inf (has_Inf Type)))))) := sorry --non-trivial
lemma new_lemma_75572 (h0 : functor.add_const (function.extfun (Type 1) semiring) linarith.comp) : @is_noetherian_ring.{1} (has_zero.{1} Type) (@function.extfun_app.{3 2} (Type 1) semiring.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) semiring.{1}) linarith.comp h0) (has_zero.{1} Type))  := sorry --non-trivial
lemma new_lemma_75573 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_nndist.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} h0 (has_nndist.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_75574 (h0 : linear_ordered_add_comm_group_with_top std_gen) (h1 : sym2 (linear_ordered_add_comm_group_with_top std_gen)) : sym2.mem h0 h1 := sorry --non-trivial
lemma new_lemma_75575 (h1 : topological_space (semi_normed_ring ennreal)) : t0_space (semi_normed_ring ennreal) := sorry --non-trivial
lemma new_lemma_75576 (h0 : ring (preorder unsigned)) : strong_rank_condition (preorder unsigned) := sorry --non-trivial
lemma new_lemma_75577 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (boolean_algebra.core.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (boolean_algebra.core.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_75578 (h0 : ordered_add_comm_monoid (has_inter (option (option ennreal)))) : archimedean (has_inter (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_75579 (h0 : topological_space (semigroup (has_add Type))) : irreducible_space (semigroup (has_add Type)) := sorry --non-trivial
lemma new_lemma_75580 (h0 : topological_space (semiring num)) : normal_space (semiring num) := sorry --non-trivial
lemma new_lemma_75581 (h0 : functor.add_const (function.extfun Type group) pos) : @is_simple_group.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) pos h0) (add_cancel_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_75582 (h0 : ordered_add_comm_monoid (pseudo_metric_space (option (comm_group pos)))) : archimedean (pseudo_metric_space (option (comm_group pos))) := sorry --non-trivial
lemma new_lemma_75583 (h0 : ring (ring (option (option empty)))) : is_domain (ring (option (option empty))) := sorry --non-trivial
lemma new_lemma_75584 (h1 : ring (has_nnnorm fun_info)) : strong_rank_condition (has_nnnorm fun_info) := sorry --non-trivial
lemma new_lemma_75585 (h0 : function.extfun Type (functor.add_const (function.extfun Type ring))) : @rank_condition.{0} (has_neg.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) name (@function.extfun_app.{2 2} Type (functor.add_const.{1 0} (function.extfun.{2 1} Type ring.{0})) h0 name)) (has_neg.{0} name))  := sorry --non-trivial
lemma new_lemma_75586 (h0 : not (topological_space linarith.comp_source -> false)) (h1 : topological_space linarith.comp_source) (h2 : pfun linarith.comp_source linarith.comp_source) : pcontinuous h2 := sorry --non-trivial
lemma new_lemma_75587 (h0 : ulower pnat) (h1 : thunk pnat) : @id.{1} Prop (pnat.coprime (@ulower.up.{0} pnat encodable.pnat h0) (@trace_call_stack.{0} pnat h1))  := sorry --non-trivial
lemma new_lemma_75588 (h0 : group (preorder empty)) : group.fg (preorder empty) := sorry --non-trivial
lemma new_lemma_75589 (h0 : function.extfun Type topological_space) (h1 : Prop) : yyy_to (@locally_compact_space.{0} (measure_theory.measure_space.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measure_theory.measure_space.{0} unsigned))) h1  := sorry --non-trivial
lemma new_lemma_75590 (h0 : add_group (simple_graph (has_neg (ring name)))) : is_add_cyclic (simple_graph (has_neg (ring name))) := sorry --non-trivial
lemma new_lemma_75591 (h0 : functor.add_const (list (has_zero Type)) linarith.comp) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_75592 (h0 : not (topological_space (linear_ordered_add_comm_group fun_info) -> false)) : @locally_compact_space.{0} (linear_ordered_add_comm_group.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_add_comm_group.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_75593 (h0 : functor.add_const (topological_space (comm_group environment.implicit_infer_kind)) name) : @t0_space.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_75594 (h0 : functor.add_const (ordered_add_comm_monoid (has_neg_part name)) name) : @archimedean.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_neg_part.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_75595 (h0 : topological_space (comm_group (comm_group (comm_group pos)))) : discrete_topology (comm_group (comm_group (comm_group pos))) := sorry --non-trivial
lemma new_lemma_75596 (h0 : complete_lattice (mul_zero_class ennreal)) : is_atomistic (mul_zero_class ennreal) := sorry --non-trivial
lemma new_lemma_75597 (h0 : monoid (measurable_space (has_norm (has_norm (has_norm fun_info))))) : monoid.fg (measurable_space (has_norm (has_norm (has_norm fun_info)))) := sorry --non-trivial
lemma new_lemma_75598 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} znum (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) znum)  := sorry --non-trivial
lemma new_lemma_75599 (h0 : ring (finset (option (option (option (option (option unsigned))))))) : is_principal_ideal_ring (finset (option (option (option (option (option unsigned)))))) := sorry --non-trivial
lemma new_lemma_75600 (h0 : not (uniform_space (simple_graph reducibility_hints) -> false)) : @complete_space.{0} (simple_graph.{0} reducibility_hints) (@classical.by_contradiction'.{1} (uniform_space.{0} (simple_graph.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_75601 (h0 : uniform_space (topological_space (random_gen (random_gen (random_gen linarith.ineq))))) : complete_space (topological_space (random_gen (random_gen (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_75602 (h0 : ring (normed_field (add_comm_semigroup linarith.ineq))) : strong_rank_condition (normed_field (add_comm_semigroup linarith.ineq)) := sorry --non-trivial
lemma new_lemma_75603 (h0 : functor.add_const (topological_space (normed_comm_ring pos)) (finset environment.implicit_infer_kind)) : @t1_space.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} pos)) (finset.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_75604 (h0 : topological_space (option (semiring (semiring (semiring num))))) : discrete_topology (option (semiring (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_75605 (h0 : topological_space (boolean_algebra (comm_group name))) : discrete_topology (boolean_algebra (comm_group name)) := sorry --non-trivial
lemma new_lemma_75606 (h0 : finset (add_comm_monoid (has_nndist (comm_group name)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_75607 (h0 : functor.add_const (ring (boolean_algebra name)) name) : @rank_condition.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_75608 (h0 : topological_space (has_nndist (mul_zero_class (option (mul_zero_class unsigned))))) : sequential_space (has_nndist (mul_zero_class (option (mul_zero_class unsigned)))) := sorry --non-trivial
lemma new_lemma_75609 (h0 : topological_space (boolean_algebra (has_pos_part (finset (has_Inf linarith.comp))))) : totally_separated_space (boolean_algebra (has_pos_part (finset (has_Inf linarith.comp)))) := sorry --non-trivial
lemma new_lemma_75610 (h0 : topological_space (finset linarith.comp)) : preirreducible_space (finset linarith.comp) := sorry --non-trivial
lemma new_lemma_75611 (h0 : topological_space (normed_group (semiring (semiring congr_arg_kind)))) : locally_compact_space (normed_group (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_75612 (h0 : topological_space (monoid ennreal)) : t0_space (monoid ennreal) := sorry --non-trivial
lemma new_lemma_75613 (h1 : ring (comm_ring (denumerable fun_info))) : is_domain (comm_ring (denumerable fun_info)) := sorry --non-trivial
lemma new_lemma_75614 (h0 : not (ring (has_ssubset string_imp) -> false)) : @is_domain.{0} (has_ssubset.{0} string_imp) (@classical.by_contradiction'.{1} (ring.{0} (has_ssubset.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_75615 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (pseudo_metric_space.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (pseudo_metric_space.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_75616 (h0 : ring (canonically_ordered_comm_semiring (boolean_algebra (has_neg_part name)))) : is_principal_ideal_ring (canonically_ordered_comm_semiring (boolean_algebra (has_neg_part name))) := sorry --non-trivial
lemma new_lemma_75617 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (has_pos_part.{0} name) (@function.extfun_app.{2 1} Type monoid.{0} h0 (has_pos_part.{0} name))  := sorry --non-trivial
lemma new_lemma_75618 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (linear_ordered_comm_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (linear_ordered_comm_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_75619 (h0 : topological_space (simple_graph (has_add pos))) : path_connected_space (simple_graph (has_add pos)) := sorry --non-trivial
lemma new_lemma_75620 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (has_Sup.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_Sup.{0} empty))  := sorry --non-trivial
lemma new_lemma_75621 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (normed_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_75622 (h2 : topological_space (nondiscrete_normed_field enat)) : totally_disconnected_space (nondiscrete_normed_field enat) := sorry --non-trivial
lemma new_lemma_75623 (h0 : group (has_norm (random_gen (random_gen (random_gen string_imp))))) : is_cyclic (has_norm (random_gen (random_gen (random_gen string_imp)))) := sorry --non-trivial
lemma new_lemma_75624 (h1 : set (semi_normed_comm_ring linarith.comp_source)) : set.finite h1 := sorry --non-trivial
lemma new_lemma_75625 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (comm_group.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (comm_group.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_75626 (h0 : complete_lattice (has_neg (ring pos))) : complete_lattice.is_Sup_finite_compact (has_neg (ring pos)) := sorry --non-trivial
lemma new_lemma_75627 (h0 : functor.add_const (topological_space (has_star num)) empty) : @totally_separated_space.{0} (has_star.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_75628 (h0 : not (group (normed_group to_additive.value_type) -> false)) : @is_cyclic.{0} (normed_group.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (group.{0} (normed_group.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_75629 (h1 : topological_space (normed_field environment.projection_info)) (h2 : add_group (normed_field environment.projection_info)) : topological_add_group (normed_field environment.projection_info) := sorry --non-trivial
lemma new_lemma_75630 (h0 : group (has_Inf (finset (finset (has_add (has_pos_part (has_add pos))))))) : is_cyclic (has_Inf (finset (finset (has_add (has_pos_part (has_add pos)))))) := sorry --non-trivial
lemma new_lemma_75631 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_neg.{0} (option.{0} ennreal)) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_neg.{0} (option.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_75632 (h0 : group (ordered_comm_monoid (has_add real))) : group.fg (ordered_comm_monoid (has_add real)) := sorry --non-trivial
lemma new_lemma_75633 (h0 : functor.add_const (filter (comm_group environment.implicit_infer_kind)) pos) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_75634 (h0 : functor.add_const (topological_space (has_Inf linarith.comp)) (ring (ring Type))) : @locally_compact_space.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_Inf.{0} linarith.comp)) (ring.{1} (ring.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_75635 (h0 : functor.add_const (function.extfun Type group) empty) (h1 : option (group (mul_zero_class empty))) : @normalizer_condition.{0} (mul_zero_class.{0} empty) (@option.lhoare.{0} (group.{0} (mul_zero_class.{0} empty)) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) empty h0) (mul_zero_class.{0} empty)) h1)  := sorry --non-trivial
lemma new_lemma_75636 (h0 : function.extfun Type ring) : @is_domain.{0} (has_bot.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_bot.{0} pos))  := sorry --non-trivial
lemma new_lemma_75637 (h0 : functor.add_const (topological_space (add_comm_monoid name)) name) : @t0_space.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_75638 (h0 : list (add_cancel_monoid (option ennreal))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_75639 (h0 : fin has_zero.zero) : @regular_space.{1} (generalized_boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (generalized_boolean_algebra.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_75640 (h0 : function.extfun Type ring) : @is_domain.{0} (monoid_with_zero.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (monoid_with_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_75641 (h0 : topological_space (has_neg_part pos)) : topological_space.separable_space (has_neg_part pos) := sorry --non-trivial
lemma new_lemma_75642 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (normed_comm_ring.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (normed_comm_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_75643 (h0 : uniform_space (linear_ordered_cancel_comm_monoid unsigned)) : separated_space (linear_ordered_cancel_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_75644 (h0 : functor.add_const (fin has_zero.zero) (has_Inf real)) : @regular_space.{0} (generalized_boolean_algebra.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (generalized_boolean_algebra.{0} real)) (@functor.add_const.run.{0 0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (has_Inf.{0} real) h0))  := sorry --non-trivial
lemma new_lemma_75645 (h0 : list (add_cancel_monoid (boolean_algebra unsigned))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_75646 (h0 : add_group (normed_field (mul_one_class (mul_one_class to_additive.value_type)))) : is_add_cyclic (normed_field (mul_one_class (mul_one_class to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_75647 (h0 : functor.add_const (topological_space (add_comm_monoid Type)) linarith.comp) : @topological_space.separable_space.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_comm_monoid.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_75648 (h0 : topological_space (dlist (has_ssubset linarith.ineq))) : t0_space (dlist (has_ssubset linarith.ineq)) := sorry --non-trivial
lemma new_lemma_75649 (h0 : functor.add_const Prop (has_neg linarith.comp)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_75650 (h0 : functor.add_const (topological_space (has_Inf name)) linarith.comp) : @t0_space.{0} (has_Inf.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_75651 (h0 : topological_space (complete_distrib_lattice num)) : t0_space (complete_distrib_lattice num) := sorry --non-trivial
lemma new_lemma_75652 (h0 : function.extfun nat fin) : @normal_space.{1} (ordered_comm_ring.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (ordered_comm_ring.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_75653 (h0 : function.extfun Type (functor.add_const (topological_space (semigroup unsigned)))) : @preirreducible_space.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} unsigned)) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (semigroup.{0} unsigned))) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_75654 (h0 : functor.add_const (cancel_comm_monoid_with_zero (cancel_monoid pos)) name) : @unique_factorization_monoid.{0} (cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (cancel_monoid.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_75655 (h0 : functor.add_const (function.extfun Type finset) pos) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (has_pos_part name)) := sorry --non-trivial
lemma new_lemma_75656 (h0 : topological_space (canonically_ordered_comm_semiring name)) : preconnected_space (canonically_ordered_comm_semiring name) := sorry --non-trivial
lemma new_lemma_75657 (h0 : function.extfun (Type 1) group) : @group.fg.{1} (plift.{1} num) (@function.extfun_app.{3 2} (Type 1) group.{1} h0 (plift.{1} num))  := sorry --non-trivial
lemma new_lemma_75658 (h0 : ring (has_pos_part (finset (has_add pos)))) : is_domain (has_pos_part (finset (has_add pos))) := sorry --non-trivial
lemma new_lemma_75659 (h0 : ring (comm_group (has_add pos))) : is_principal_ideal_ring (comm_group (has_add pos)) := sorry --non-trivial
lemma new_lemma_75660 (h0 : add_group (add_monoid (has_nnnorm linarith.ineq))) : is_add_cyclic (add_monoid (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_75661 (h0 : add_group (plift (semiring num))) : is_add_cyclic (plift (semiring num)) := sorry --non-trivial
lemma new_lemma_75662 (h0 : functor.add_const (ordered_add_comm_monoid (has_nndist unsigned)) (finset environment.implicit_infer_kind)) : @archimedean.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_nndist.{0} unsigned)) (finset.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_75663 (h0 : complete_lattice (has_zero (has_neg_part unsigned))) : is_atomistic (has_zero (has_neg_part unsigned)) := sorry --non-trivial
lemma new_lemma_75664 (h0 : topological_space (has_one (has_norm (semiring linarith.comp)))) : normal_space (has_one (has_norm (semiring linarith.comp))) := sorry --non-trivial
lemma new_lemma_75665 (h0 : functor.add_const (topological_space (finset Type)) (ring Type)) : @t0_space.{1} (finset.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (finset.{1} Type)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_75666 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (is_R_or_C.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (is_R_or_C.{0} empty))  := sorry --non-trivial
lemma new_lemma_75667 (h0 : functor.add_const (topological_space (has_Sup empty)) empty) : @totally_separated_space.{0} (has_Sup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Sup.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_75668 (h0 : functor.add_const (ring (has_inf Type)) Type) : @is_principal_ideal_ring.{1} (has_inf.{1} Type) (@functor.add_const.run.{1 1} (ring.{1} (has_inf.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_75669 (h0 : uniform_space (normed_group (semiring (semiring (semiring num))))) : separated_space (normed_group (semiring (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_75670 (h0 : filter (has_norm (semiring (semiring empty)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_75671 (h0 : ring (has_neg (ring Type))) : is_domain (has_neg (ring Type)) := sorry --non-trivial
lemma new_lemma_75672 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_75673 (h0 : set (ereal -> enat)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_75674 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (random_gen.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (random_gen.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_75675 (h0 : list (generalized_boolean_algebra (has_add (ring Type)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_75676 (h0 : has_neg (distrib environment.projection_info)) (h1 : measurable_space (distrib environment.projection_info)) : has_measurable_neg (distrib environment.projection_info) := sorry --non-trivial
lemma new_lemma_75677 (h0 : monoid (has_Inf (canonically_linear_ordered_monoid Type))) : monoid.fg (has_Inf (canonically_linear_ordered_monoid Type)) := sorry --non-trivial
lemma new_lemma_75678 (h0 : fin has_zero.zero) : @strong_rank_condition.{0} (has_Inf.{0} real) (@matrix.vec_empty.{0} (ring.{0} (has_Inf.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_75679 (h2 : set (char -> environment.implicit_infer_kind)) : set.separates_points h2 := sorry --non-trivial
lemma new_lemma_75680 (h1 : ring (has_ssubset (random_gen string_imp))) : rank_condition (has_ssubset (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_75681 (h0 : list (add_cancel_monoid (has_neg linarith.comp))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_75682 (h0 : ring (semigroup (has_to_string (has_to_string name)))) : is_principal_ideal_ring (semigroup (has_to_string (has_to_string name))) := sorry --non-trivial
lemma new_lemma_75683 (h0 : ring (has_nndist (has_nndist environment.implicit_infer_kind))) : rank_condition (has_nndist (has_nndist environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_75684 (h0 : add_group (add_comm_semigroup (add_comm_semigroup char))) : is_add_cyclic (add_comm_semigroup (add_comm_semigroup char)) := sorry --non-trivial
lemma new_lemma_75685 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (linear_ordered_cancel_comm_monoid.{0} (semiring.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_cancel_comm_monoid.{0} (semiring.{0} empty)))  := sorry --non-trivial
lemma new_lemma_75686 (h1 : function.extfun Type topological_space) : @totally_separated_space.{0} linarith.ineq (@function.extfun_app.{2 1} Type topological_space.{0} h1 linarith.ineq)  := sorry --non-trivial
lemma new_lemma_75687 (h0 : list (has_emptyc (random_gen linarith.ineq))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_75688 (h0 : group (has_union (semiring (semiring (semiring (semiring (semiring empty))))))) : is_cyclic (has_union (semiring (semiring (semiring (semiring (semiring empty)))))) := sorry --non-trivial
lemma new_lemma_75689 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (simple_graph.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (simple_graph.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_75690 (h0 : ring (measurable_space.dynkin_system (semiring congr_arg_kind))) : is_domain (measurable_space.dynkin_system (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_75691 (h0 : complete_lattice (has_neg (has_neg_part Type))) : is_atomistic (has_neg (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_75692 (h0 : set (std_gen -> ordered_add_comm_monoid ereal)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_75693 (h0 : has_lt (normed_field string.iterator_imp)) : no_max_order (normed_field string.iterator_imp) := sorry --non-trivial
lemma new_lemma_75694 (h0 : ring (semigroup (option name))) : is_domain (semigroup (option name)) := sorry --non-trivial
lemma new_lemma_75695 (h0 : semiring (ring unsigned)) : is_noetherian_ring (ring unsigned) := sorry --non-trivial
lemma new_lemma_75696 (h0 : group (denumerable (denumerable (has_inv (has_inv (has_top fun_info)))))) : normalizer_condition (denumerable (denumerable (has_inv (has_inv (has_top fun_info))))) := sorry --non-trivial
lemma new_lemma_75697 (h0 : filter (mul_zero_class ennreal)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_75698 (h0 : complete_lattice (boolean_algebra (ring (has_neg Type)))) : complete_lattice.is_Sup_finite_compact (boolean_algebra (ring (has_neg Type))) := sorry --non-trivial
lemma new_lemma_75699 (h0 : ring (simple_graph unsigned)) : is_principal_ideal_ring (simple_graph unsigned) := sorry --non-trivial
lemma new_lemma_75700 (h0 : not (multiset Prop -> false)) : @multiset.sup.{0} Prop (@lattice.to_semilattice_sup.{0} Prop (@conditionally_complete_lattice.to_lattice.{0} Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice))) (@generalized_boolean_algebra.to_order_bot.{0} Prop (@boolean_algebra.to_generalized_boolean_algebra.{0} Prop Prop.boolean_algebra)) (@classical.by_contradiction'.{1} (multiset.{0} Prop) h0)  := sorry --non-trivial
lemma new_lemma_75701 (h0 : function.extfun (Type 1) (functor.comp topological_space ring)) : @preconnected_space.{1} (ring.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} ring.{1} Type (@function.extfun_app.{3 2} (Type 1) (functor.comp.{1 1 1} topological_space.{1} ring.{1}) h0 Type))  := sorry --non-trivial
lemma new_lemma_75702 (h0 : monoid (boolean_algebra.core (has_neg linarith.comp))) : monoid.fg (boolean_algebra.core (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_75703 (h0 : functor.add_const (uniform_space (has_neg_part pos)) name) : @separated_space.{0} (has_neg_part.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_neg_part.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_75704 (h0 : topological_space (comm_group (option unsigned))) : irreducible_space (comm_group (option unsigned)) := sorry --non-trivial
lemma new_lemma_75705 (h0 : add_monoid (linear_ordered_semiring linarith.comp)) (h1 : complete_lattice (semiring (has_norm (add_units (linear_ordered_semiring linarith.comp))))) : is_atomistic (semiring (has_norm (add_units (linear_ordered_semiring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_75706 (h0 : function.extfun nat fin) : @normal_space.{1} (simple_graph.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (simple_graph.{1} Type)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))))  := sorry --non-trivial
lemma new_lemma_75707 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_75708 (h0 : ring (normed_group (semiring num))) : rank_condition (normed_group (semiring num)) := sorry --non-trivial
lemma new_lemma_75709 (h1 : ring (has_ssubset (has_ssubset (random_gen (random_gen (random_gen char)))))) : strong_rank_condition (has_ssubset (has_ssubset (random_gen (random_gen (random_gen char))))) := sorry --non-trivial
lemma new_lemma_75710 (h0 : complete_lattice (measurable_space.dynkin_system congr_arg_kind)) : is_compactly_generated (measurable_space.dynkin_system congr_arg_kind) := sorry --non-trivial
lemma new_lemma_75711 (h0 : uniform_space (simple_graph (mul_one_class string.iterator_imp))) : complete_space (simple_graph (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_75712 (h0 : function.extfun Type (functor.add_const (topological_space (has_edist empty)))) : @preirreducible_space.{0} (has_edist.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_edist.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (has_edist.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_75713 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_noetherian_ring.{1} Type (@function.extfun_app.{3 2} (Type 1) semiring.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 semiring.{1}) Type)  := sorry --non-trivial
lemma new_lemma_75714 (h0 : functor.add_const (semiring (ring environment.implicit_infer_kind)) name) : @is_noetherian_ring.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (semiring.{0} (ring.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_75715 (h0 : functor.add_const (ring (as_linear_order empty)) empty) : @is_domain.{0} (as_linear_order.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (as_linear_order.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_75716 (h0 : not (topological_space (left_cancel_semigroup num) -> false)) : @discrete_topology.{0} (left_cancel_semigroup.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (left_cancel_semigroup.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_75717 (h0 : complete_lattice (with_bot (random_gen (has_top fun_info)))) : is_compactly_generated (with_bot (random_gen (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_75718 (h0 : topological_space (complete_linear_order unsigned)) : totally_disconnected_space (complete_linear_order unsigned) := sorry --non-trivial
lemma new_lemma_75719 (h0 : function.extfun Type (functor.add_const (list (ordered_ring empty)))) : palindrome (functor.add_const.run (function.extfun_app h0 (semiring (option empty)))) := sorry --non-trivial
lemma new_lemma_75720 (h0 : functor.add_const (finset (monoid unsigned)) empty) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_75721 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (partial_order.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (partial_order.{0} num))  := sorry --non-trivial
lemma new_lemma_75722 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} to_additive.value_type (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) to_additive.value_type)  := sorry --non-trivial
lemma new_lemma_75723 (h0 : filter (normed_comm_ring (has_neg (finset (has_neg linarith.comp))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_75724 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_75725 (h0 : functor.add_const (list (has_zero linarith.comp)) (has_to_string Type)) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_75726 (h0 : functor.add_const (topological_space (has_add pos)) linarith.comp) : @t1_space.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_75727 (h0 : topological_space (linear_ordered_semiring (semiring empty))) : irreducible_space (linear_ordered_semiring (semiring empty)) := sorry --non-trivial
lemma new_lemma_75728 (h0 : topological_space (complete_semilattice_Sup to_additive.value_type)) : totally_disconnected_space (complete_semilattice_Sup to_additive.value_type) := sorry --non-trivial
lemma new_lemma_75729 (h0 : list (dlist (has_nnnorm (has_top (has_top (has_nnnorm fun_info)))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_75730 (h0 : finset (metric_space num)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_75731 (h0 : boolean_algebra.core (option unsigned)) (h1 : functor.add_const nat unsigned) : list.nodup (list.repeat h0 (functor.add_const.run h1)) := sorry --non-trivial
lemma new_lemma_75732 (h0 : functor.add_const (topological_space (has_nndist unsigned)) (option (option empty))) : @path_connected_space.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} unsigned)) (option.{0} (option.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_75733 (h0 : functor.add_const (group (semigroup linarith.comp)) pos) : @group.fg.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (semigroup.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_75734 (h0 : list (has_norm (random_gen (random_gen string_imp)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_75735 (h0 : function.extfun Type (prod nnreal)) : id_rel (function.extfun_app h0 nnreal) := sorry --non-trivial
lemma new_lemma_75736 (h0 : functor.add_const (group (has_to_string linarith.comp)) pos) : @normalizer_condition.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (has_to_string.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_75737 (h0 : functor.add_const (topological_space (has_pos_part pos)) pos) : @regular_space.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_75738 (h0 : functor.add_const (topological_space (has_zero unsigned)) (option (option pos))) : @totally_disconnected_space.{0} (has_zero.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} unsigned)) (option.{0} (option.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_75739 (h1 : function.extfun Type list) : list.nodup (function.extfun_app h1 (with_bot linarith.ineq)) := sorry --non-trivial
lemma new_lemma_75740 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_75741 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (canonically_ordered_comm_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type monoid.{0} h0 (canonically_ordered_comm_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_75742 (h0 : functor.add_const (topological_space (measurable_space.dynkin_system num)) empty) : @preirreducible_space.{0} (measurable_space.dynkin_system.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (measurable_space.dynkin_system.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_75743 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_Inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_Inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_75744 (h0 : semiring (comm_group (comm_group pos))) : is_noetherian_ring (comm_group (comm_group pos)) := sorry --non-trivial
lemma new_lemma_75745 (h0 : complete_lattice (normed_field (semi_normed_ring (random_gen linarith.comp_source)))) : is_compactly_generated (normed_field (semi_normed_ring (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_75746 (h0 : functor.add_const (function.extfun (Type 1) uniform_space) Type) : @complete_space.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) uniform_space.{1}) Type h0) (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_75747 (h0 : group (comm_group unsigned)) : normalizer_condition (comm_group unsigned) := sorry --non-trivial
lemma new_lemma_75748 (h0 : fin has_zero.zero) : @totally_separated_space.{0} (simple_graph.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (simple_graph.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_75749 (h0 : topological_space (has_norm (has_norm fun_info))) : normal_space (has_norm (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_75750 (h0 : add_monoid (free_add_monoid congr_arg_kind)) : add_monoid.fg (free_add_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_75751 (h0 : not (group (non_assoc_semiring empty) -> false)) : @normalizer_condition.{0} (non_assoc_semiring.{0} empty) (@classical.by_contradiction'.{1} (group.{0} (non_assoc_semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_75752 (h3 : topological_space (mul_one_class (mul_one_class std_gen))) : path_connected_space (mul_one_class (mul_one_class std_gen)) := sorry --non-trivial
lemma new_lemma_75753 (h0 : list (normed_comm_ring environment.implicit_infer_kind)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_75754 (h0 : list (add_comm_monoid (option (option ennreal)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_75755 (h0 : filter (has_norm (random_gen linarith.comp_source))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_75756 (h0 : list (ordered_comm_monoid (boolean_algebra Type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_75757 (h0 : complete_lattice (has_neg (option ennreal))) : is_compactly_generated (has_neg (option ennreal)) := sorry --non-trivial
lemma new_lemma_75758 (h1 : ring (has_ssubset reducibility_hints)) : is_domain (has_ssubset reducibility_hints) := sorry --non-trivial
lemma new_lemma_75759 (h0 : has_mem.mem (random_gen linarith.comp) has_emptyc.emptyc) : @complete_space.{0} (random_gen.{0} linarith.comp) (@finset.pi.empty.{1 0} Type uniform_space.{0} (random_gen.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_75760 (h0 : topological_space (cancel_monoid pos)) : sequential_space (cancel_monoid pos) := sorry --non-trivial
lemma new_lemma_75761 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (add_right_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_right_cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_75762 (h0 : functor.add_const (group (complete_distrib_lattice pos)) (ring (ring pos))) : @is_cyclic.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (complete_distrib_lattice.{0} pos)) (ring.{0} (ring.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_75763 (h0 : semiring (mul_zero_class ennreal)) : is_noetherian_ring (mul_zero_class ennreal) := sorry --non-trivial
lemma new_lemma_75764 (h0 : topological_space (generalized_boolean_algebra (has_Inf pos))) : loc_path_connected_space (generalized_boolean_algebra (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_75765 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_Inf linarith.comp)) pos) : @unique_factorization_monoid.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_Inf.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_75766 (h0 : group (has_to_string congr_arg_kind)) (h1 : subgroup (has_to_string congr_arg_kind)) : subgroup.saturated h1 := sorry --non-trivial
lemma new_lemma_75767 (h1 : topological_space (add_cancel_comm_monoid (topological_space linarith.ineq))) : t0_space (add_cancel_comm_monoid (topological_space linarith.ineq)) := sorry --non-trivial
lemma new_lemma_75768 (h0 : functor.add_const (monoid (add_left_cancel_semigroup empty)) (semiring empty)) : @monoid.fg.{0} (add_left_cancel_semigroup.{0} empty) (@functor.add_const.run.{0 0} (monoid.{0} (add_left_cancel_semigroup.{0} empty)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_75769 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (with_bot.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (with_bot.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_75770 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @add_monoid.fg.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_monoid.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 add_monoid.{1}) (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_75771 (h0 : topological_space (add_cancel_monoid (ring (has_neg linarith.comp)))) : totally_separated_space (add_cancel_monoid (ring (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_75772 (h0 : functor.add_const (add_group auto.case_option) unsigned) : @is_add_cyclic.{0} auto.case_option (@functor.add_const.run.{0 0} (add_group.{0} auto.case_option) unsigned h0)  := sorry --non-trivial
lemma new_lemma_75773 (h0 : complete_lattice (comm_ring reducibility_hints)) : is_compactly_generated (comm_ring reducibility_hints) := sorry --non-trivial
lemma new_lemma_75774 (h0 : add_group (has_inv (random_gen (random_gen linarith.comp_source)))) : is_add_cyclic (has_inv (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_75775 (h0 : functor.add_const (topological_space (finset pos)) Type) : @totally_disconnected_space.{0} (finset.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (finset.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_75776 (h0 : function.extfun nat fin) : @is_add_cyclic.{0} (add_comm_monoid.{0} real) (@matrix.vec_empty.{0} (add_group.{0} (add_comm_monoid.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_75777 (h0 : functor.add_const (topological_space (has_nndist environment.implicit_infer_kind)) unsigned) : @t1_space.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} environment.implicit_infer_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_75778 (h0 : functor.add_const (group (has_star num)) empty) : @is_cyclic.{0} (has_star.{0} num) (@functor.add_const.run.{0 0} (group.{0} (has_star.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_75779 (h0 : not (function.extfun Type ring -> false)) : @rank_condition.{0} (semiring.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} num)))))) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (semiring.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} num)))))))  := sorry --non-trivial
lemma new_lemma_75780 (h0 : functor.add_const (topological_space (has_to_string Type)) pos) : @discrete_topology.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_to_string.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_75781 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (mul_zero_class.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (mul_zero_class.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_75782 (h0 : topological_space (option (semiring (semiring (semiring (semiring empty)))))) : discrete_topology (option (semiring (semiring (semiring (semiring empty))))) := sorry --non-trivial
lemma new_lemma_75783 (h0 : functor.add_const (topological_space (normed_linear_ordered_group empty)) empty) : @irreducible_space.{0} (normed_linear_ordered_group.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_linear_ordered_group.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_75784 (h0 : uniform_space (has_zero (comm_group Type))) : separated_space (has_zero (comm_group Type)) := sorry --non-trivial
lemma new_lemma_75785 (h0 : fin has_zero.zero) : @path_connected_space.{0} (simple_graph.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (simple_graph.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_75786 (h0 : set (non_unital_non_assoc_semiring linarith.comp_source)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_75787 (h1 : topological_space (id linarith.comp)) : t0_space (id linarith.comp) := sorry --non-trivial
lemma new_lemma_75788 (h0 : topological_space (complete_semilattice_Sup (has_nnnorm linarith.ineq))) : path_connected_space (complete_semilattice_Sup (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_75789 (h0 : ring (add_cancel_monoid (semigroup pos))) : is_domain (add_cancel_monoid (semigroup pos)) := sorry --non-trivial
lemma new_lemma_75790 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (@id.{2} Type unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (@id.{2} Type unsigned))  := sorry --non-trivial
lemma new_lemma_75791 (h0 : cancel_comm_monoid_with_zero (add_comm_monoid (option (option (option num))))) : unique_factorization_monoid (add_comm_monoid (option (option (option num)))) := sorry --non-trivial
lemma new_lemma_75792 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (has_compl.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_compl.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_75793 (h0 : ring (has_nndist (has_add linarith.comp))) : strong_rank_condition (has_nndist (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_75794 (h0 : ring (filter (semiring (semiring empty)))) : is_domain (filter (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_75795 (h0 : has_mem.mem (id empty) has_emptyc.emptyc) : @locally_compact_space.{0} (@id.{2} Type empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (@id.{2} Type empty) h0)  := sorry --non-trivial
lemma new_lemma_75796 (h0 : measurable_space (pseudo_metric_space (option pos))) (h1 : set (pseudo_metric_space (option pos))) : measurable_set h1 := sorry --non-trivial
lemma new_lemma_75797 (h0 : not (complete_lattice (partial_order unsigned) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (partial_order.{0} unsigned) (@classical.by_contradiction'.{1} (complete_lattice.{0} (partial_order.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_75798 (h0 : functor.add_const (list (normed_comm_ring pos)) (has_to_string (comm_group Type))) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_75799 (h0 : list (comm_group (has_add Type))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_75800 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (linear_ordered_add_comm_group fun_info)) := sorry --non-trivial
lemma new_lemma_75801 (h0 : topological_space (ordered_comm_monoid (ordered_comm_monoid (comm_semigroup linarith.comp)))) : normal_space (ordered_comm_monoid (ordered_comm_monoid (comm_semigroup linarith.comp))) := sorry --non-trivial
lemma new_lemma_75802 (h0 : topological_space (linear_ordered_comm_ring (semiring congr_arg_kind))) : discrete_topology (linear_ordered_comm_ring (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_75803 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (linear_ordered_comm_group congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_75804 (h0 : functor.add_const (topological_space (boolean_algebra.core empty)) empty) : @normal_space.{0} (boolean_algebra.core.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_75805 (h0 : topological_space (comm_ring (has_top (has_top string_imp)))) : irreducible_space (comm_ring (has_top (has_top string_imp))) := sorry --non-trivial
lemma new_lemma_75806 (h0 : set (distrib (has_ssubset fun_info))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_75807 (h1 : function.extfun Type topological_space) : @path_connected_space.{0} (distrib_lattice.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (distrib_lattice.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_75808 (h0 : functor.add_const (filter (has_neg unsigned)) environment.implicit_infer_kind) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_75809 (h0 : functor.add_const (ring (ordered_comm_ring linarith.comp)) pos) : @rank_condition.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (ordered_comm_ring.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_75810 (h0 : has_mem.mem (linear_ordered_semiring empty) has_emptyc.emptyc) : filter.ne_bot (finset.pi.empty filter (linear_ordered_semiring empty) h0) := sorry --non-trivial
lemma new_lemma_75811 (h0 : filter (with_zero (has_inv linarith.comp_source))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_75812 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type monoid.{0} h0 (complete_semilattice_Sup.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_75813 (h0 : has_mem.mem (has_norm num) has_emptyc.emptyc) : @separated_space.{0} (has_norm.{0} num) (@finset.pi.empty.{1 0} Type uniform_space.{0} (has_norm.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_75814 (h0 : has_lt (add_comm_semigroup (has_ssubset ereal))) : no_max_order (add_comm_semigroup (has_ssubset ereal)) := sorry --non-trivial
lemma new_lemma_75815 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (measurable_space.{0} (semiring.{0} (semiring.{0} linarith.comp))) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measurable_space.{0} (semiring.{0} (semiring.{0} linarith.comp))))  := sorry --non-trivial
lemma new_lemma_75816 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (has_dist.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_dist.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_75817 (h0 : ring (filter (option unsigned))) : rank_condition (filter (option unsigned)) := sorry --non-trivial
lemma new_lemma_75818 (h0 : monoid (boolean_algebra Type)) : monoid.fg (boolean_algebra Type) := sorry --non-trivial
lemma new_lemma_75819 (h0 : not (function.extfun Type complete_lattice -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (with_bot.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (with_bot.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_75820 (h0 : functor.comp topological_space has_zero pos) : @t1_space.{0} (has_zero.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} has_zero.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_75821 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_emptyc.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_emptyc.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_75822 (h0 : functor.add_const (add_group (complete_distrib_lattice pos)) (ring (ring Type))) : @is_add_cyclic.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 1} (add_group.{0} (complete_distrib_lattice.{0} pos)) (ring.{1} (ring.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_75823 (h0 : not (ring (partial_order unsigned) -> false)) : @is_principal_ideal_ring.{0} (partial_order.{0} unsigned) (@classical.by_contradiction'.{1} (ring.{0} (partial_order.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_75824 (h0 : set (has_nnnorm (mul_one_class reducibility_hints))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_75825 (h0 : complete_lattice (has_ssubset (has_ssubset linarith.ineq))) : complete_lattice.is_Sup_finite_compact (has_ssubset (has_ssubset linarith.ineq)) := sorry --non-trivial
lemma new_lemma_75826 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (group_with_zero.{0} num) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (group_with_zero.{0} num))  := sorry --non-trivial
lemma new_lemma_75827 (h0 : topological_space (ordered_comm_monoid (has_Inf Type))) : loc_path_connected_space (ordered_comm_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_75828 (h0 : function.extfun Type (functor.comp filter mul_zero_class)) : countable_Inter_filter (functor.comp.run (function.extfun_app h0 ennreal)) := sorry --non-trivial
lemma new_lemma_75829 (h0 : functor.add_const (filter (semigroup pos)) (has_neg Type)) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_75830 (h0 : complete_lattice (semigroup (semigroup (has_neg linarith.comp)))) : complete_lattice.is_Sup_finite_compact (semigroup (semigroup (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_75831 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (has_pos_part.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_pos_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_75832 (h0 : complete_lattice (measurable_space (has_norm unsigned))) : complete_lattice.is_Sup_finite_compact (measurable_space (has_norm unsigned)) := sorry --non-trivial
lemma new_lemma_75833 (h0 : functor.add_const (function.extfun (Type 1) group) pos) : @normalizer_condition.{1} (complete_distrib_lattice.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) group.{1}) pos h0) (complete_distrib_lattice.{1} Type))  := sorry --non-trivial
lemma new_lemma_75834 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (complete_semilattice_Sup.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_semilattice_Sup.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_75835 (h0 : functor.add_const (topological_space (add_left_cancel_semigroup empty)) empty) : @normal_space.{0} (add_left_cancel_semigroup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_left_cancel_semigroup.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_75836 (h0 : topological_space (linear_ordered_semiring (has_norm fun_info))) : totally_separated_space (linear_ordered_semiring (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_75837 (h0 : filter (semigroup (comm_group (comm_group environment.implicit_infer_kind)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_75838 (h0 : ring (generalized_boolean_algebra real)) : is_domain (generalized_boolean_algebra real) := sorry --non-trivial
lemma new_lemma_75839 (h0 : functor.add_const (topological_space (ring Type)) pos) : @preconnected_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ring.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_75840 (h0 : functor.add_const (list (ordered_comm_ring pos)) (has_add Type)) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_75841 (h0 : functor.add_const (topological_space (finset linarith.comp)) environment.implicit_infer_kind) : @normal_space.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_75842 (h0 : uniform_space (mul_zero_class empty)) : complete_space (mul_zero_class empty) := sorry --non-trivial
lemma new_lemma_75843 (h0 : monoid (add_right_cancel_monoid (semiring congr_arg_kind))) : monoid.fg (add_right_cancel_monoid (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_75844 (h0 : complete_lattice (generalized_boolean_algebra real)) : is_compactly_generated (generalized_boolean_algebra real) := sorry --non-trivial
lemma new_lemma_75845 (h0 : topological_space (has_add fun_info)) : sigma_compact_space (has_add fun_info) := sorry --non-trivial
lemma new_lemma_75846 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (add_comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_75847 (h0 : topological_space (has_lt (has_nnnorm string.iterator_imp))) : t0_space (has_lt (has_nnnorm string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_75848 (h0 : functor.add_const (complete_lattice (normed_linear_ordered_group empty)) num) : @complete_lattice.is_Sup_finite_compact.{0} (normed_linear_ordered_group.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (normed_linear_ordered_group.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_75849 (h0 : ring (normed_field (mul_one_class string.iterator_imp))) : is_domain (normed_field (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_75850 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (linear_ordered_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_75851 (h0 : complete_lattice (has_add (mul_one_class (has_add pos)))) : is_compactly_generated (has_add (mul_one_class (has_add pos))) := sorry --non-trivial
lemma new_lemma_75852 (h0 : functor.add_const (topological_space (normed_comm_ring environment.implicit_infer_kind)) Type) : @locally_compact_space.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (normed_comm_ring.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_75853 (h0 : topological_space (mul_one_class (mul_one_class fun_info))) : path_connected_space (mul_one_class (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_75854 (h0 : complete_lattice (add_comm_monoid real)) : is_atomistic (add_comm_monoid real) := sorry --non-trivial
lemma new_lemma_75855 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @is_noetherian_ring.{0} (ordered_comm_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type semiring.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type semiring.{0}) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero))) (ordered_comm_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_75856 (h0 : add_group (with_bot (semiring linarith.comp))) : is_add_cyclic (with_bot (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_75857 (h0 : group (non_assoc_semiring num)) : group.fg (non_assoc_semiring num) := sorry --non-trivial
lemma new_lemma_75858 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_75859 (h0 : function.extfun Type topological_space) : @normal_space.{0} (ordered_cancel_add_comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_cancel_add_comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_75860 (h0 : list (has_zero (option pos))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_75861 (h0 : topological_space (has_inv (has_nnnorm (has_inv (random_gen (random_gen (random_gen char))))))) : locally_compact_space (has_inv (has_nnnorm (has_inv (random_gen (random_gen (random_gen char)))))) := sorry --non-trivial
lemma new_lemma_75862 (h0 : functor.add_const (uniform_space (comm_group pos)) pos) : @separated_space.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (comm_group.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_75863 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (add_left_cancel_semigroup.{0} (semiring.{0} unsigned)) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_left_cancel_semigroup.{0} (semiring.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_75864 (h0 : functor.add_const (semiring (partial_order empty)) (semiring (semiring (option unsigned)))) : @is_noetherian_ring.{0} (partial_order.{0} empty) (@functor.add_const.run.{0 0} (semiring.{0} (partial_order.{0} empty)) (semiring.{0} (semiring.{0} (option.{0} unsigned))) h0)  := sorry --non-trivial
lemma new_lemma_75865 (h0 : functor.add_const (complete_lattice (semigroup linarith.comp)) (finset Type)) : @complete_lattice.is_Sup_finite_compact.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 1} (complete_lattice.{0} (semigroup.{0} linarith.comp)) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_75866 (h0 : semiring (has_bot empty)) : is_noetherian_ring (has_bot empty) := sorry --non-trivial
lemma new_lemma_75867 (h1 : list (with_bot (random_gen (random_gen to_additive.value_type)))) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_75868 (h1 : filter (topological_space fun_info)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_75869 (h0 : topological_space (boolean_algebra (has_add (has_bot real)))) : preconnected_space (boolean_algebra (has_add (has_bot real))) := sorry --non-trivial
lemma new_lemma_75870 (h0 : functor.add_const (ring (ring stieltjes_function)) name) : @strong_rank_condition.{0} (ring.{0} stieltjes_function) (@functor.add_const.run.{0 0} (ring.{0} (ring.{0} stieltjes_function)) name h0)  := sorry --non-trivial
lemma new_lemma_75871 (h0 : not (topological_space (has_div string_imp) -> false)) : @path_connected_space.{0} (has_div.{0} string_imp) (@classical.by_contradiction'.{1} (topological_space.{0} (has_div.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_75872 (h0 : functor.add_const (ordered_add_comm_monoid (boolean_algebra pos)) (finset linarith.comp)) : @archimedean.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (boolean_algebra.{0} pos)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_75873 (h0 : semiring (ordered_comm_ring (has_nndist linarith.comp))) : is_noetherian_ring (ordered_comm_ring (has_nndist linarith.comp)) := sorry --non-trivial
lemma new_lemma_75874 (h1 : topological_space (add_comm_semigroup char)) (h4 : preorder (add_comm_semigroup char)) : order_topology (add_comm_semigroup char) := sorry --non-trivial
lemma new_lemma_75875 (h0 : topological_space (comm_group (comm_group pos))) : regular_space (comm_group (comm_group pos)) := sorry --non-trivial
lemma new_lemma_75876 (h0 : functor.add_const (list (complete_distrib_lattice Type)) pos) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_75877 (h0 : functor.comp topological_space add_comm_monoid linarith.comp) : @normal_space.{0} (add_comm_monoid.{0} linarith.comp) (@functor.comp.run.{0 0 0} topological_space.{0} add_comm_monoid.{0} linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_75878 (h0 : not (functor.add_const Prop (has_union empty) -> false)) : functor.add_const.run (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_75879 (h0 : group (measurable_space (has_norm linarith.comp))) : normalizer_condition (measurable_space (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_75880 (h0 : function.extfun Type (functor.comp topological_space has_neg)) : @totally_separated_space.{0} (has_neg.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} pos (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} pos (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} pos (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} pos (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} pos (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} pos (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} has_neg.{0}) h0 pos))))))))  := sorry --non-trivial
lemma new_lemma_75881 (h0 : topological_space (mul_zero_class ennreal)) : totally_separated_space (mul_zero_class ennreal) := sorry --non-trivial
lemma new_lemma_75882 (h0 : topological_space (comm_group (finset environment.implicit_infer_kind))) : preconnected_space (comm_group (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_75883 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (cancel_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_75884 (h0 : function.extfun (finset Type) (has_mem.mem (measurable_space empty))) : @locally_compact_space.{0} (measurable_space.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (measurable_space.{0} empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (measurable_space.{0} empty)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_75885 (h1 : set (ereal -> nondiscrete_normed_field char)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_75886 (h0 : topological_space (boolean_algebra real)) : path_connected_space (boolean_algebra real) := sorry --non-trivial
lemma new_lemma_75887 (h1 : complete_lattice (distrib (normed_field (comm_ring char)))) : complete_lattice.is_Sup_finite_compact (distrib (normed_field (comm_ring char))) := sorry --non-trivial
lemma new_lemma_75888 (h0 : ordered_add_comm_monoid (add_left_cancel_semigroup num)) : archimedean (add_left_cancel_semigroup num) := sorry --non-trivial
lemma new_lemma_75889 (h0 : semiring (linear_ordered_comm_group empty)) : is_noetherian_ring (linear_ordered_comm_group empty) := sorry --non-trivial
lemma new_lemma_75890 (h0 : topological_space (filter name)) : loc_path_connected_space (filter name) := sorry --non-trivial
lemma new_lemma_75891 (h2 : topological_space (with_zero to_additive.value_type)) : totally_disconnected_space (with_zero to_additive.value_type) := sorry --non-trivial
lemma new_lemma_75892 (h0 : function.extfun (finset Type) (has_mem.mem linarith.comp_source)) : @totally_separated_space.{0} linarith.comp_source (@finset.pi.empty.{1 0} Type topological_space.{0} linarith.comp_source (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) linarith.comp_source) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_75893 (h0 : uniform_space (has_zero (finset name))) : complete_space (has_zero (finset name)) := sorry --non-trivial
lemma new_lemma_75894 (h0 : functor.add_const (function.extfun Type ring) linarith.comp) : @rank_condition.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) linarith.comp h0) (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_75895 (h0 : functor.add_const (group (complete_distrib_lattice name)) linarith.comp) : @is_cyclic.{0} (complete_distrib_lattice.{0} name) (@functor.add_const.run.{0 0} (group.{0} (complete_distrib_lattice.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_75896 (h0 : semiring (semigroup (finset unsigned))) : is_noetherian_ring (semigroup (finset unsigned)) := sorry --non-trivial
lemma new_lemma_75897 (h0 : uniform_space (canonically_linear_ordered_monoid ennreal)) : separated_space (canonically_linear_ordered_monoid ennreal) := sorry --non-trivial
lemma new_lemma_75898 (h0 : fin has_zero.zero) : @monoid.fg.{0} (has_Inf.{0} linarith.comp) (@matrix.vec_empty.{0} (monoid.{0} (has_Inf.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_75899 (h0 : ring (add_group (semiring congr_arg_kind))) : strong_rank_condition (add_group (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_75900 (h0 : topological_space (random_gen (has_top fun_info))) : normal_space (random_gen (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_75901 (h0 : monoid (boolean_algebra (boolean_algebra (boolean_algebra pos)))) : monoid.fg (boolean_algebra (boolean_algebra (boolean_algebra pos))) := sorry --non-trivial
lemma new_lemma_75902 (h0 : set (has_compl (mul_one_class (mul_one_class std_gen)))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_75903 (h0 : filter (cancel_monoid (mul_zero_class (option name)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_75904 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (has_inv.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 topological_space.{0}) (has_inv.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_75905 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (normed_comm_ring.{0} name) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (normed_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_75906 (h0 : left_cancel_semigroup num -> left_cancel_semigroup num -> Prop) : is_strict_order (left_cancel_semigroup num) h0 := sorry --non-trivial
lemma new_lemma_75907 (h0 : measurable_space (has_ssubset reducibility_hints)) (h1 : filter (has_ssubset reducibility_hints)) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_75908 (h0 : functor.add_const (group (has_zero environment.implicit_infer_kind)) pos) : @group.fg.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (has_zero.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_75909 (h0 : add_monoid (preorder num)) : add_monoid.fg (preorder num) := sorry --non-trivial
lemma new_lemma_75910 (h0 : complete_lattice (normed_group unsigned)) : is_compactly_generated (normed_group unsigned) := sorry --non-trivial
lemma new_lemma_75911 (h0 : complete_lattice (add_right_cancel_monoid num)) : is_compactly_generated (add_right_cancel_monoid num) := sorry --non-trivial
lemma new_lemma_75912 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (normed_comm_ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (normed_comm_ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_75913 (h0 : uniform_space (canonically_ordered_add_monoid (semiring empty))) : separated_space (canonically_ordered_add_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_75914 (h0 : not (monoid (linear_ordered_comm_ring empty) -> false)) : @monoid.fg.{0} (linear_ordered_comm_ring.{0} empty) (@classical.by_contradiction'.{1} (monoid.{0} (linear_ordered_comm_ring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_75915 (h1 : topological_space (nondiscrete_normed_field linarith.ineq)) (h2 : preorder (nondiscrete_normed_field linarith.ineq)) : order_closed_topology (nondiscrete_normed_field linarith.ineq) := sorry --non-trivial
lemma new_lemma_75916 (h0 : functor.add_const (complete_lattice (has_dist ennreal)) ennreal) : @is_atomistic.{0} (has_dist.{0} ennreal) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_dist.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_75917 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem add_group)) : @is_add_cyclic.{0} (measurable_space.{0} num) (@function.extfun_app.{2 1} Type add_group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) add_group.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) add_group.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (measurable_space.{0} num))  := sorry --non-trivial
lemma new_lemma_75918 (h0 : functor.add_const (uniform_space (comm_group Type)) Type) : @complete_space.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 1} (uniform_space.{1} (comm_group.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_75919 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (dlist.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (dlist.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_75920 (h0 : functor.add_const (topological_space nnreal) num) : totally_separated_space nnreal := sorry --non-trivial
lemma new_lemma_75921 (h0 : functor.add_const (add_monoid (has_zero pos)) Type) : @add_monoid.fg.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 1} (add_monoid.{0} (has_zero.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_75922 (h0 : functor.add_const (function.extfun Type ring) pos) : @strong_rank_condition.{0} (has_nndist.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) pos h0) (has_nndist.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_75923 (h0 : function.extfun nat fin) : @sequential_space.{1} (ordered_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (ordered_comm_monoid.{1} Type)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))))  := sorry --non-trivial
lemma new_lemma_75924 (h0 : complete_lattice (has_div char)) : complete_lattice.is_Sup_finite_compact (has_div char) := sorry --non-trivial
lemma new_lemma_75925 (h0 : not (monoid (has_to_string linarith.comp) -> false)) : @monoid.fg.{0} (has_to_string.{0} linarith.comp) (@classical.by_contradiction'.{1} (monoid.{0} (has_to_string.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_75926 (h0 : ring (add_group (semiring fun_info))) : is_domain (add_group (semiring fun_info)) := sorry --non-trivial
lemma new_lemma_75927 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (ring.{0} num) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (ring.{0} num))  := sorry --non-trivial
lemma new_lemma_75928 (h0 : function.extfun fun_info (fun (x : fun_info), Prop)) (h1 : fun_info) : set.set_semiring.down (function.extfun_app h0) h1 := sorry --non-trivial
lemma new_lemma_75929 (h0 : not (topological_space (random_gen fun_info) -> false)) : @irreducible_space.{0} (random_gen.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (random_gen.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_75930 (h0 : functor.add_const (topological_space (has_nndist congr_arg_kind)) congr_arg_kind) : @irreducible_space.{0} (has_nndist.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_75931 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (complete_distrib_lattice.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} real))  := sorry --non-trivial
lemma new_lemma_75932 (h0 : topological_space (semigroup (option pos))) : t1_space (semigroup (option pos)) := sorry --non-trivial
lemma new_lemma_75933 (h0 : topological_space (normed_group (has_inv (has_emptyc (normed_group congr_arg_kind))))) : totally_disconnected_space (normed_group (has_inv (has_emptyc (normed_group congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_75934 (h0 : functor.add_const (ordered_add_comm_monoid (add_right_cancel_monoid unsigned)) empty) : @archimedean.{0} (add_right_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (add_right_cancel_monoid.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_75935 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_union.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_union.{0} num))  := sorry --non-trivial
lemma new_lemma_75936 (h0 : functor.add_const (complete_lattice (is_R_or_C unsigned)) empty) : @is_compactly_generated.{0} (is_R_or_C.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (is_R_or_C.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_75937 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_75938 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (finset name)) := sorry --non-trivial
lemma new_lemma_75939 (h0 : topological_space (normed_lattice_add_comm_group (has_add (has_add pos)))) : preconnected_space (normed_lattice_add_comm_group (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_75940 (h0 : ring (add_cancel_comm_monoid string.iterator_imp)) : rank_condition (add_cancel_comm_monoid string.iterator_imp) := sorry --non-trivial
lemma new_lemma_75941 (h0 : functor.add_const (topological_space (comm_group ennreal)) name) : @irreducible_space.{0} (comm_group.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_75942 (h0 : add_monoid (with_one (semiring (has_top empty)))) : add_monoid.fg (with_one (semiring (has_top empty))) := sorry --non-trivial
lemma new_lemma_75943 (h0 : functor.add_const (ring (add_comm_monoid name)) Type) : @strong_rank_condition.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 1} (ring.{0} (add_comm_monoid.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_75944 (h0 : complete_lattice (normed_lattice_add_comm_group (finset Type))) : is_compactly_generated (normed_lattice_add_comm_group (finset Type)) := sorry --non-trivial
lemma new_lemma_75945 (h0 : functor.add_const (function.extfun (Type 1) topological_space) (has_neg (ring (has_neg pos)))) : @discrete_topology.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) (has_neg.{0} (ring.{0} (has_neg.{0} pos))) h0) (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_75946 (h0 : functor.add_const (filter (finset linarith.comp)) (has_to_string (has_to_string (finset (ring Type))))) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_75947 (h0 : complete_lattice (add_cancel_monoid (add_comm_monoid (has_add name)))) : complete_lattice.is_Sup_finite_compact (add_cancel_monoid (add_comm_monoid (has_add name))) := sorry --non-trivial
lemma new_lemma_75948 (h4 : topological_space (random_gen (random_gen char))) : t0_space (random_gen (random_gen char)) := sorry --non-trivial
lemma new_lemma_75949 (h0 : uniform_space (measurable_space linarith.comp)) : separated_space (measurable_space linarith.comp) := sorry --non-trivial
lemma new_lemma_75950 (h0 : ring (non_unital_non_assoc_semiring (has_nnnorm reducibility_hints))) : strong_rank_condition (non_unital_non_assoc_semiring (has_nnnorm reducibility_hints)) := sorry --non-trivial
lemma new_lemma_75951 (h0 : ring (boolean_algebra (has_Inf real))) : is_principal_ideal_ring (boolean_algebra (has_Inf real)) := sorry --non-trivial
lemma new_lemma_75952 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (boolean_algebra.core pos)) := sorry --non-trivial
lemma new_lemma_75953 (h0 : ordered_add_comm_monoid (has_inner empty (option empty))) : archimedean (has_inner empty (option empty)) := sorry --non-trivial
lemma new_lemma_75954 (h0 : ring (semigroup (has_to_string environment.implicit_infer_kind))) : is_domain (semigroup (has_to_string environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_75955 (h0 : topological_space (normed_field (random_gen (has_nnnorm char)))) : totally_disconnected_space (normed_field (random_gen (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_75956 (h0 : prod (linear_ordered_cancel_comm_monoid (option empty)) (linear_ordered_cancel_comm_monoid (option empty))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_75957 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @loc_path_connected_space.{0} (complete_distrib_lattice.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (complete_distrib_lattice.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_75958 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_neg_part.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_neg_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_75959 (h0 : function.extfun Type (functor.comp ring add_comm_monoid)) : @is_domain.{0} (add_comm_monoid.{0} name) (@functor.comp.run.{0 0 0} ring.{0} add_comm_monoid.{0} name (@functor.comp.run.{0 0 0} ring.{0} add_comm_monoid.{0} name (@functor.comp.run.{0 0 0} ring.{0} add_comm_monoid.{0} name (@functor.comp.run.{0 0 0} ring.{0} add_comm_monoid.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} ring.{0} add_comm_monoid.{0}) h0 name)))))  := sorry --non-trivial
lemma new_lemma_75960 (h0 : topological_space (add_cancel_monoid (finset name))) : preconnected_space (add_cancel_monoid (finset name)) := sorry --non-trivial
lemma new_lemma_75961 (h0 : uniform_space linarith.ineq) (h1 : add_group linarith.ineq) : uniform_add_group linarith.ineq := sorry --non-trivial
lemma new_lemma_75962 (h0 : uniform_space (has_neg_part ennreal)) : complete_space (has_neg_part ennreal) := sorry --non-trivial
lemma new_lemma_75963 (h0 : uniform_space (ordered_comm_monoid (has_neg linarith.comp))) : complete_space (ordered_comm_monoid (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_75964 (h0 : topological_space (cancel_monoid pos)) : topological_space.separable_space (cancel_monoid pos) := sorry --non-trivial
lemma new_lemma_75965 (h0 : ordered_add_comm_monoid (add_cancel_monoid (option unsigned))) : archimedean (add_cancel_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_75966 (h0 : topological_space (normed_group (has_norm (has_norm (has_top congr_arg_kind))))) : locally_compact_space (normed_group (has_norm (has_norm (has_top congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_75967 (h0 : functor.add_const (ring (has_Sup unsigned)) unsigned) : @rank_condition.{0} (has_Sup.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (has_Sup.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_75968 (h0 : not (ring (has_ssubset (has_ssubset linarith.comp_source)) -> false)) : @is_domain.{0} (has_ssubset.{0} (has_ssubset.{0} linarith.comp_source)) (@classical.by_contradiction'.{1} (ring.{0} (has_ssubset.{0} (has_ssubset.{0} linarith.comp_source))) h0)  := sorry --non-trivial
lemma new_lemma_75969 (h0 : topological_space (has_to_string (has_add environment.implicit_infer_kind))) : loc_path_connected_space (has_to_string (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_75970 (h0 : add_monoid (add_group (semiring (semiring (semiring unsigned))))) : add_monoid.fg (add_group (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_75971 (h0 : function.extfun Type (functor.add_const (finset (linear_order empty)))) : finset.nonempty (functor.add_const.run (function.extfun_app h0 empty)) := sorry --non-trivial
lemma new_lemma_75972 (h0 : functor.add_const (topological_space (has_neg_part name)) (mul_zero_class (option unsigned))) : @path_connected_space.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} name)) (mul_zero_class.{0} (option.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_75973 (h0 : add_group (complete_semilattice_Sup (random_gen (random_gen string_imp)))) : is_add_cyclic (complete_semilattice_Sup (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_75974 (h0 : functor.add_const (topological_space (canonically_ordered_monoid linarith.comp)) name) : @preconnected_space.{0} (canonically_ordered_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_monoid.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_75975 (h0 : complete_lattice (has_emptyc (has_top linarith.comp_source))) : is_atomistic (has_emptyc (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_75976 (h0 : topological_space (add_comm_monoid (has_add (has_add name)))) : totally_separated_space (add_comm_monoid (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_75977 (h1 : topological_space (semiring (has_top (has_top fun_info)))) : locally_compact_space (semiring (has_top (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_75978 (h0 : functor.add_const (topological_space (cancel_monoid pos)) name) : @normal_space.{0} (cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_75979 (h0 : complete_lattice (option (option ennreal))) : is_atomistic (option (option ennreal)) := sorry --non-trivial
lemma new_lemma_75980 (h0 : topological_space (normed_field (mul_one_class (mul_one_class fun_info)))) (h1 : preorder (normed_field (mul_one_class (mul_one_class fun_info)))) : order_closed_topology (normed_field (mul_one_class (mul_one_class fun_info))) := sorry --non-trivial
lemma new_lemma_75981 (h0 : functor.add_const (uniform_space (left_cancel_semigroup num)) (normed_linear_ordered_group empty)) : @complete_space.{0} (left_cancel_semigroup.{0} num) (@functor.add_const.run.{0 0} (uniform_space.{0} (left_cancel_semigroup.{0} num)) (normed_linear_ordered_group.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_75982 (h0 : not (complete_lattice (has_append reducibility_hints) -> false)) : @is_compactly_generated.{0} (has_append.{0} reducibility_hints) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_append.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_75983 (h0 : topological_space (non_unital_non_assoc_semiring (mul_one_class (mul_one_class linarith.ineq)))) : path_connected_space (non_unital_non_assoc_semiring (mul_one_class (mul_one_class linarith.ineq))) := sorry --non-trivial
lemma new_lemma_75984 (h0 : ring (is_R_or_C unsigned)) : strong_rank_condition (is_R_or_C unsigned) := sorry --non-trivial
lemma new_lemma_75985 (h0 : complete_lattice (random_gen (metric_space linarith.ineq))) : complete_lattice.is_Sup_finite_compact (random_gen (metric_space linarith.ineq)) := sorry --non-trivial
lemma new_lemma_75986 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @path_connected_space.{0} (with_one.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (with_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_75987 (h0 : functor.add_const (complete_lattice (free_add_monoid empty)) empty) : @is_compactly_generated.{0} (free_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (free_add_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_75988 (h0 : functor.add_const (uniform_space (option empty)) congr_arg_kind) : @separated_space.{0} (option.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (option.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_75989 (h0 : ring (measurable_space.dynkin_system (semiring linarith.comp))) : is_domain (measurable_space.dynkin_system (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_75990 (h0 : list (complete_distrib_lattice (option unsigned))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_75991 (h0 : not (function.extfun Type topological_space -> false)) : @totally_disconnected_space.{0} (semiring.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (semiring.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_75992 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @totally_separated_space.{0} (has_nndist.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (has_nndist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_75993 (h0 : topological_space (random_gen (has_inv (has_inv (has_inv linarith.comp_source))))) : totally_separated_space (random_gen (has_inv (has_inv (has_inv linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_75994 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (monoid.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_75995 (h0 : not (group reducibility_hints -> false)) : @is_cyclic.{0} reducibility_hints (@classical.by_contradiction'.{1} (group.{0} reducibility_hints) h0)  := sorry --non-trivial
lemma new_lemma_75996 (h0 : complete_lattice (with_bot to_additive.value_type)) : is_atomistic (with_bot to_additive.value_type) := sorry --non-trivial
lemma new_lemma_75997 (h0 : ordered_comm_monoid (ring (has_Inf (has_Inf pos)))) : has_exists_mul_of_le (ring (has_Inf (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_75998 (h0 : functor.add_const (complete_lattice (has_nndist pos)) Type) : @is_compactly_generated.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 1} (complete_lattice.{0} (has_nndist.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_75999 (h0 : ring (add_cancel_monoid (ring (boolean_algebra linarith.comp)))) : is_principal_ideal_ring (add_cancel_monoid (ring (boolean_algebra linarith.comp))) := sorry --non-trivial
lemma new_lemma_76000 (h0 : complete_lattice (ordered_comm_monoid (ring Type))) : is_compactly_generated (ordered_comm_monoid (ring Type)) := sorry --non-trivial
lemma new_lemma_76001 (h0 : complete_lattice (add_cancel_monoid (has_neg linarith.comp))) : complete_lattice.is_Sup_finite_compact (add_cancel_monoid (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_76002 (h0 : add_group (normed_field (has_lt enat))) : is_add_cyclic (normed_field (has_lt enat)) := sorry --non-trivial
lemma new_lemma_76003 (h6 : add_group (has_ssubset linarith.ineq)) : is_add_cyclic (has_ssubset linarith.ineq) := sorry --non-trivial
lemma new_lemma_76004 (h0 : complete_lattice (has_bot (has_bot Type))) : is_compactly_generated (has_bot (has_bot Type)) := sorry --non-trivial
lemma new_lemma_76005 (h0 : ring (boolean_algebra.core (has_to_string congr_arg_kind))) : rank_condition (boolean_algebra.core (has_to_string congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_76006 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (ring ennreal)) := sorry --non-trivial
lemma new_lemma_76007 (h0 : topological_space (has_nndist (canonically_ordered_comm_semiring ennreal))) : topological_space.separable_space (has_nndist (canonically_ordered_comm_semiring ennreal)) := sorry --non-trivial
lemma new_lemma_76008 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @add_monoid.fg.{0} (has_neg.{0} num) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) add_monoid.{0}) (has_neg.{0} num))  := sorry --non-trivial
lemma new_lemma_76009 (h0 : group (has_norm (random_gen (random_gen fun_info)))) : normalizer_condition (has_norm (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_76010 (h0 : fin has_zero.zero) : @complete_space.{1} (comm_semigroup.{1} Type) (@matrix.vec_empty.{1} (uniform_space.{1} (comm_semigroup.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_76011 (h1 : ring (linear_ordered_comm_group_with_zero to_additive.value_type)) : is_domain (linear_ordered_comm_group_with_zero to_additive.value_type) := sorry --non-trivial
lemma new_lemma_76012 (h0 : not (group (has_append linarith.comp_source) -> false)) : @is_cyclic.{0} (has_append.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (group.{0} (has_append.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_76013 (h0 : function.extfun Type (functor.add_const (complete_lattice auto.case_option))) : @is_compactly_generated.{0} auto.case_option (@functor.add_const.run.{0 0} (complete_lattice.{0} auto.case_option) congr_arg_kind (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (complete_lattice.{0} auto.case_option)) h0 congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_76014 (h0 : finset (ring (has_to_string Type))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_76015 (h0 : filter (comm_group (has_neg (semigroup (semigroup name))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_76016 (h0 : function.extfun (finset Type) (has_mem.mem num)) : @strong_rank_condition.{0} num (@finset.pi.empty.{1 0} Type ring.{0} num (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) num) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_76017 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (canonically_ordered_comm_semiring unsigned)) := sorry --non-trivial
lemma new_lemma_76018 (h0 : topological_space (has_Inf (finset linarith.comp))) : regular_space (has_Inf (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_76019 (h0 : filter (has_Inf linarith.comp)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_76020 (h0 : ring (canonically_ordered_comm_semiring (finset (finset name)))) : strong_rank_condition (canonically_ordered_comm_semiring (finset (finset name))) := sorry --non-trivial
lemma new_lemma_76021 (h0 : functor.add_const (function.extfun (Type 1) topological_space) name) : @locally_compact_space.{1} (generalized_boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) name h0) (generalized_boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_76022 (h0 : functor.add_const (group (has_Inf pos)) pos) : @normalizer_condition.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_Inf.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_76023 (h0 : function.extfun (Type 1) topological_space) : @discrete_topology.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_76024 (h1 : not (topological_space (has_nnnorm to_additive.value_type) -> false)) : @t0_space.{0} (has_nnnorm.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (has_nnnorm.{0} to_additive.value_type)) h1)  := sorry --non-trivial
lemma new_lemma_76025 (h0 : topological_space (with_bot (has_inv to_additive.value_type))) : totally_disconnected_space (with_bot (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_76026 (h0 : filter (monoid (option (option unsigned)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_76027 (h0 : group (linear_ordered_add_comm_group (random_gen (has_nnnorm to_additive.value_type)))) : group.fg (linear_ordered_add_comm_group (random_gen (has_nnnorm to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_76028 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_emptyc.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_emptyc.{0} num))  := sorry --non-trivial
lemma new_lemma_76029 (h0 : function.extfun Type topological_space) : @t0_space.{0} (canonically_linear_ordered_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_linear_ordered_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_76030 (h0 : not (uniform_space (has_append (topological_space (has_nnnorm (has_nnnorm linarith.ineq)))) -> false)) : @complete_space.{0} (has_append.{0} (topological_space.{0} (has_nnnorm.{0} (has_nnnorm.{0} linarith.ineq)))) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_append.{0} (topological_space.{0} (has_nnnorm.{0} (has_nnnorm.{0} linarith.ineq))))) h0)  := sorry --non-trivial
lemma new_lemma_76031 (h0 : functor.add_const (ordered_comm_monoid (simple_graph pos)) pos) : @has_exists_mul_of_le.{0} (simple_graph.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (simple_graph.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_76032 (h0 : topological_space (generalized_boolean_algebra (has_add name))) : totally_disconnected_space (generalized_boolean_algebra (has_add name)) := sorry --non-trivial
lemma new_lemma_76033 (h2 : function.extfun Type group) : @group.fg.{0} (with_one.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} h2 (with_one.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_76034 (h0 : functor.add_const (ring (add_cancel_monoid pos)) name) : @is_principal_ideal_ring.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (add_cancel_monoid.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_76035 (h0 : topological_space (free_add_monoid (semiring unsigned))) : t0_space (free_add_monoid (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_76036 (h0 : topological_space (has_emptyc linarith.comp_source)) : discrete_topology (has_emptyc linarith.comp_source) := sorry --non-trivial
lemma new_lemma_76037 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (linear_ordered_comm_monoid_with_zero.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (linear_ordered_comm_monoid_with_zero.{0} empty))  := sorry --non-trivial
lemma new_lemma_76038 (h0 : group (preorder (semiring empty))) : group.fg (preorder (semiring empty)) := sorry --non-trivial
lemma new_lemma_76039 (h0 : complete_lattice (has_neg_part unsigned)) : complete_lattice.is_Sup_finite_compact (has_neg_part unsigned) := sorry --non-trivial
lemma new_lemma_76040 (h0 : functor.add_const (ring (has_zero Type)) environment.implicit_infer_kind) : @is_domain.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_zero.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_76041 (h1 : has_add char) (h2 : has_le char) (h3 : char) : add_le_cancellable h3 := sorry --non-trivial
lemma new_lemma_76042 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_cyclic.{1} (has_zero.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 group.{1}) (has_zero.{1} Type))  := sorry --non-trivial
lemma new_lemma_76043 (h0 : functor.comp topological_space comm_group Type) : @t1_space.{1} (comm_group.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} comm_group.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_76044 (h1 : complete_lattice (has_ssubset string_imp)) : complete_lattice.is_Sup_finite_compact (has_ssubset string_imp) := sorry --non-trivial
lemma new_lemma_76045 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @normalizer_condition.{0} (has_emptyc.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) group.{0}) (has_emptyc.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_76046 (h0 : functor.add_const (topological_space (has_to_string Type)) (boolean_algebra environment.implicit_infer_kind)) : @path_connected_space.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_to_string.{1} Type)) (boolean_algebra.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_76047 (h0 : ring (has_append string_imp)) : strong_rank_condition (has_append string_imp) := sorry --non-trivial
lemma new_lemma_76048 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (generalized_boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (generalized_boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_76049 (h1 : topological_space (distrib_lattice (random_gen to_additive.value_type))) : totally_disconnected_space (distrib_lattice (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_76050 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (mul_zero_class.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type add_group.{0} h0 (mul_zero_class.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_76051 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_76052 (h0 : topological_space (has_pos_part (has_Inf pos))) : sequential_space (has_pos_part (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_76053 (h0 : ring (add_cancel_monoid (has_neg_part linarith.comp))) : is_domain (add_cancel_monoid (has_neg_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_76054 (h0 : ring (linear_ordered_field (option empty))) : is_principal_ideal_ring (linear_ordered_field (option empty)) := sorry --non-trivial
lemma new_lemma_76055 (h0 : functor.add_const (ring (preorder unsigned)) empty) : @rank_condition.{0} (preorder.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (preorder.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_76056 (h0 : finset (boolean_algebra.core (has_neg (has_add linarith.comp)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_76057 (h0 : ring (has_div (mul_one_class (mul_one_class to_additive.value_type)))) : strong_rank_condition (has_div (mul_one_class (mul_one_class to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_76058 (h0 : topological_space (mul_zero_class (semiring (semiring empty)))) : path_connected_space (mul_zero_class (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_76059 (h0 : uniform_space (random_gen (denumerable (has_nnnorm (denumerable reducibility_hints))))) : complete_space (random_gen (denumerable (has_nnnorm (denumerable reducibility_hints)))) := sorry --non-trivial
lemma new_lemma_76060 (h0 : has_neg (has_nnnorm linarith.ineq)) (h1 : measurable_space (has_nnnorm linarith.ineq)) : has_measurable_neg (has_nnnorm linarith.ineq) := sorry --non-trivial
lemma new_lemma_76061 (h1 : has_lt (mul_one_class (normed_field ereal))) : no_max_order (mul_one_class (normed_field ereal)) := sorry --non-trivial
lemma new_lemma_76062 (h1 : ring string_imp) : rank_condition string_imp := sorry --non-trivial
lemma new_lemma_76063 (h0 : topological_space (has_nndist (has_neg (finset linarith.comp)))) : topological_space.separable_space (has_nndist (has_neg (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_76064 (h0 : function.extfun Type ring) : @is_domain.{0} (add_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_76065 (h0 : functor.add_const (add_monoid (linear_ordered_comm_ring empty)) num) : @add_monoid.fg.{0} (linear_ordered_comm_ring.{0} empty) (@functor.add_const.run.{0 0} (add_monoid.{0} (linear_ordered_comm_ring.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_76066 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_76067 (h0 : functor.add_const (complete_lattice (finset environment.implicit_infer_kind)) Type) : @is_compactly_generated.{0} (finset.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (complete_lattice.{0} (finset.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_76068 (h0 : complete_lattice (has_one unsigned)) : complete_lattice.is_Sup_finite_compact (has_one unsigned) := sorry --non-trivial
lemma new_lemma_76069 (h0 : function.extfun Type group) : @group.fg.{0} (normed_group.{0} string_imp) (@function.extfun_app.{2 1} Type group.{0} h0 (normed_group.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_76070 (h0 : group (has_sub (has_top empty))) : group.fg (has_sub (has_top empty)) := sorry --non-trivial
lemma new_lemma_76071 (h0 : topological_space (add_cancel_monoid (has_neg pos))) : path_connected_space (add_cancel_monoid (has_neg pos)) := sorry --non-trivial
lemma new_lemma_76072 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_76073 (h0 : functor.add_const (ordered_comm_monoid (add_group Type)) linarith.comp) : @has_exists_mul_of_le.{1} (add_group.{1} Type) (@functor.add_const.run.{1 0} (ordered_comm_monoid.{1} (add_group.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_76074 (h0 : not (topological_space (denumerable (random_gen reducibility_hints)) -> false)) : @t0_space.{0} (denumerable.{0} (random_gen.{0} reducibility_hints)) (@classical.by_contradiction'.{1} (topological_space.{0} (denumerable.{0} (random_gen.{0} reducibility_hints))) h0)  := sorry --non-trivial
lemma new_lemma_76075 (h0 : cancel_comm_monoid_with_zero (sub_neg_monoid Type)) : unique_factorization_monoid (sub_neg_monoid Type) := sorry --non-trivial
lemma new_lemma_76076 (h0 : topological_space (simple_graph fun_info)) : t0_space (simple_graph fun_info) := sorry --non-trivial
lemma new_lemma_76077 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring pos)) Type) : @totally_disconnected_space.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (canonically_ordered_comm_semiring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_76078 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (has_dist.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_dist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_76079 (h0 : functor.add_const (topological_space (cancel_monoid unsigned)) Type) : @preconnected_space.{0} (cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (cancel_monoid.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_76080 (h0 : ordered_comm_monoid (ring (boolean_algebra Type))) : has_exists_mul_of_le (ring (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_76081 (h0 : topological_space (has_edist num)) : irreducible_space (has_edist num) := sorry --non-trivial
lemma new_lemma_76082 (h0 : functor.add_const (ring (has_to_string pos)) linarith.comp) : @rank_condition.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_to_string.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_76083 (h0 : ring (normed_group (has_inv fun_info))) : rank_condition (normed_group (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_76084 (h0 : uniform_space (add_cancel_monoid (finset (boolean_algebra Type)))) : separated_space (add_cancel_monoid (finset (boolean_algebra Type))) := sorry --non-trivial
lemma new_lemma_76085 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (add_cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_76086 (h0 : functor.add_const (topological_space (has_to_string pos)) linarith.comp) : @sequential_space.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_76087 (h0 : topological_space auto.case_option) : t1_space auto.case_option := sorry --non-trivial
lemma new_lemma_76088 (h0 : topological_space (measurable_space.dynkin_system (semiring (semiring (semiring empty))))) : discrete_topology (measurable_space.dynkin_system (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_76089 (h0 : topological_space (sub_neg_monoid (has_add (has_add Type)))) : topological_space.separable_space (sub_neg_monoid (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_76090 (h0 : not (ring (fintype linarith.comp_source) -> false)) : @is_domain.{0} (fintype.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (fintype.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_76091 (h0 : fin has_zero.zero) : @is_compactly_generated.{0} (comm_semigroup.{0} real) (@matrix.vec_empty.{0} (complete_lattice.{0} (comm_semigroup.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_76092 (h0 : function.extfun nat fin) : @discrete_topology.{0} (ordered_comm_monoid.{0} name) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_monoid.{0} name)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_76093 (h0 : group (has_zero (has_Inf (finset (finset environment.implicit_infer_kind))))) : normalizer_condition (has_zero (has_Inf (finset (finset environment.implicit_infer_kind)))) := sorry --non-trivial
lemma new_lemma_76094 (h0 : not (ring (random_gen linarith.comp_source) -> false)) : @strong_rank_condition.{0} (random_gen.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (random_gen.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_76095 (h0 : topological_space (add_monoid (comm_ring linarith.comp_source))) : path_connected_space (add_monoid (comm_ring linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_76096 (h0 : topological_space (semi_normed_comm_ring to_additive.value_type)) : totally_disconnected_space (semi_normed_comm_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_76097 (h0 : functor.add_const (topological_space (add_group unsigned)) unsigned) : @totally_disconnected_space.{0} (add_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_group.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_76098 (h0 : topological_space (has_inter ennreal)) : t0_space (has_inter ennreal) := sorry --non-trivial
lemma new_lemma_76099 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (measure_theory.measure_space.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measure_theory.measure_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_76100 (h0 : not (function.extfun Type topological_space -> false)) : @normal_space.{0} (has_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_76101 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (with_bot.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_bot.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_76102 (h0 : uniform_space (measurable_space (semiring (random_gen congr_arg_kind)))) : separated_space (measurable_space (semiring (random_gen congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_76103 (h0 : not (ring (with_zero char) -> false)) : @rank_condition.{0} (with_zero.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (with_zero.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_76104 (h0 : fin has_zero.zero) : @complete_space.{0} (generalized_boolean_algebra.{0} real) (@matrix.vec_empty.{0} (uniform_space.{0} (generalized_boolean_algebra.{0} real)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)))  := sorry --non-trivial
lemma new_lemma_76105 (h0 : functor.add_const (functor.add_const (ring Type) (ring (ring (ring (ordered_ring linarith.comp))))) pos) : @is_principal_ideal_ring.{1} Type (@functor.add_const.run.{1 0} (ring.{1} Type) (ring.{0} (ring.{0} (ring.{0} (ordered_ring.{0} linarith.comp)))) (@functor.add_const.run.{1 0} (functor.add_const.{1 0} (ring.{1} Type) (ring.{0} (ring.{0} (ring.{0} (ordered_ring.{0} linarith.comp))))) pos h0))  := sorry --non-trivial
lemma new_lemma_76106 (h0 : complete_lattice (has_add linarith.comp)) : is_atomistic (has_add linarith.comp) := sorry --non-trivial
lemma new_lemma_76107 (h0 : functor.add_const (topological_space (has_neg unsigned)) Type) : @totally_disconnected_space.{0} (has_neg.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_76108 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (ordered_cancel_add_comm_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_cancel_add_comm_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_76109 (h0 : group (complete_distrib_lattice (has_add linarith.comp))) : normalizer_condition (complete_distrib_lattice (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_76110 (h0 : filter (complete_semilattice_Sup (semiring unsigned))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_76111 (h0 : monoid (has_emptyc to_additive.value_type)) : monoid.fg (has_emptyc to_additive.value_type) := sorry --non-trivial
lemma new_lemma_76112 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (option.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (option.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_76113 (h0 : semiring (add_comm_monoid (has_bot linarith.comp))) : is_noetherian_ring (add_comm_monoid (has_bot linarith.comp)) := sorry --non-trivial
lemma new_lemma_76114 (h0 : ordered_comm_monoid (has_to_string (has_to_string (has_nndist (ring linarith.comp))))) : has_exists_mul_of_le (has_to_string (has_to_string (has_nndist (ring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_76115 (h0 : ring (mul_zero_class (finset ennreal))) : is_principal_ideal_ring (mul_zero_class (finset ennreal)) := sorry --non-trivial
lemma new_lemma_76116 (h0 : topological_space (random_gen (has_norm (random_gen string_imp)))) : totally_separated_space (random_gen (has_norm (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_76117 (h0 : complete_lattice (has_add (has_add (has_add Type)))) : is_atomistic (has_add (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_76118 (h0 : not (function.extfun Type topological_space -> false)) : @totally_disconnected_space.{0} unsigned (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) unsigned)  := sorry --non-trivial
lemma new_lemma_76119 (h0 : has_mem.mem (with_one num) has_emptyc.emptyc) : @is_atomistic.{0} (with_one.{0} num) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (with_one.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_76120 (h0 : list (id (option (option (option (option (option empty))))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_76121 (h0 : topological_space (cancel_monoid (has_add (has_add name)))) : irreducible_space (cancel_monoid (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_76122 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (canonically_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (canonically_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_76123 (h0 : functor.add_const (uniform_space (boolean_algebra.core Type)) (boolean_algebra pos)) : @complete_space.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (boolean_algebra.core.{1} Type)) (boolean_algebra.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_76124 (h0 : functor.add_const (topological_space (complete_linear_order num)) congr_arg_kind) : @preirreducible_space.{0} (complete_linear_order.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_linear_order.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_76125 (h0 : group (has_Inf (has_pos_part linarith.comp))) : group.fg (has_Inf (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_76126 (h0 : ordered_add_comm_monoid (has_to_string (has_add (has_add (has_add Type))))) : archimedean (has_to_string (has_add (has_add (has_add Type)))) := sorry --non-trivial
lemma new_lemma_76127 (h0 : monoid (add_comm_monoid (has_add pos))) : monoid.fg (add_comm_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_76128 (h0 : functor.add_const (topological_space (has_nndist pos)) Type) : @path_connected_space.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_nndist.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_76129 (h0 : functor.add_const (semiring (linear_order unsigned)) unsigned) : @is_noetherian_ring.{0} (linear_order.{0} unsigned) (@functor.add_const.run.{0 0} (semiring.{0} (linear_order.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_76130 (h0 : ring (linear_ordered_comm_group_with_zero (has_lt string_imp))) : rank_condition (linear_ordered_comm_group_with_zero (has_lt string_imp)) := sorry --non-trivial
lemma new_lemma_76131 (h0 : not (ring (non_unital_non_assoc_semiring to_additive.value_type) -> false)) : @rank_condition.{0} (non_unital_non_assoc_semiring.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (non_unital_non_assoc_semiring.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_76132 (h0 : topological_space (encodable (has_nnnorm (has_nnnorm fun_info)))) : totally_disconnected_space (encodable (has_nnnorm (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_76133 (h0 : cancel_comm_monoid_with_zero (metric_space unsigned)) : unique_factorization_monoid (metric_space unsigned) := sorry --non-trivial
lemma new_lemma_76134 (h0 : functor.add_const (group (comm_group unsigned)) name) : @is_simple_group.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (comm_group.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_76135 (h0 : topological_space (option (has_neg_part pos))) : preirreducible_space (option (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_76136 (h0 : topological_space (filter num)) : t0_space (filter num) := sorry --non-trivial
lemma new_lemma_76137 (h0 : functor.add_const (ring pos) environment.implicit_infer_kind) : @rank_condition.{0} pos (@functor.add_const.run.{0 0} (ring.{0} pos) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_76138 (h0 : add_monoid (id unsigned)) : add_monoid.fg (id unsigned) := sorry --non-trivial
lemma new_lemma_76139 (h0 : topological_space (normed_linear_ordered_group unsigned)) : path_connected_space (normed_linear_ordered_group unsigned) := sorry --non-trivial
lemma new_lemma_76140 (h0 : functor.add_const (complete_lattice (add_group empty)) (semiring empty)) : @is_compactly_generated.{0} (add_group.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_group.{0} empty)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_76141 (h0 : ring (has_bot (ordered_comm_monoid (sub_neg_monoid real)))) : rank_condition (has_bot (ordered_comm_monoid (sub_neg_monoid real))) := sorry --non-trivial
lemma new_lemma_76142 (h0 : functor.add_const (function.extfun (Type 1) group) linarith.comp) : @is_cyclic.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) group.{1}) linarith.comp h0) (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_76143 (h0 : ring (linear_ordered_semiring linarith.comp)) : is_domain (linear_ordered_semiring linarith.comp) := sorry --non-trivial
lemma new_lemma_76144 (h0 : functor.add_const (topological_space (cancel_monoid environment.implicit_infer_kind)) name) : @discrete_topology.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_76145 (h0 : group (canonically_linear_ordered_monoid (option (option (option (option unsigned)))))) : is_cyclic (canonically_linear_ordered_monoid (option (option (option (option unsigned))))) := sorry --non-trivial
lemma new_lemma_76146 (h0 : not (ring (measurable_space linarith.ineq) -> false)) : @is_domain.{0} (measurable_space.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (measurable_space.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_76147 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (normed_linear_ordered_group.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (normed_linear_ordered_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_76148 (h3 : add_group ereal) : is_add_cyclic ereal := sorry --non-trivial
lemma new_lemma_76149 (h0 : functor.add_const (filter (linear_ordered_comm_monoid_with_zero empty)) num) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_76150 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (pseudo_metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (pseudo_metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_76151 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_star.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (has_star.{0} num))  := sorry --non-trivial
lemma new_lemma_76152 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} real.angle (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) real.angle)  := sorry --non-trivial
lemma new_lemma_76153 (h0 : add_group (nondiscrete_normed_field (add_comm_semigroup (add_comm_semigroup enat)))) : is_add_cyclic (nondiscrete_normed_field (add_comm_semigroup (add_comm_semigroup enat))) := sorry --non-trivial
lemma new_lemma_76154 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (add_left_cancel_monoid.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_left_cancel_monoid.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_76155 (h0 : not (function.extfun Type filter -> false)) : filter.ne_bot (function.extfun_app (classical.by_contradiction' h0) (measurable_space fun_info)) := sorry --non-trivial
lemma new_lemma_76156 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (linear_ordered_add_comm_group.{0} char) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (linear_ordered_add_comm_group.{0} char))  := sorry --non-trivial
lemma new_lemma_76157 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (left_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (left_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_76158 (h0 : uniform_space (has_inv linarith.ineq)) : complete_space (has_inv linarith.ineq) := sorry --non-trivial
lemma new_lemma_76159 (h0 : topological_space (linear_order (semiring empty))) : path_connected_space (linear_order (semiring empty)) := sorry --non-trivial
lemma new_lemma_76160 (h0 : functor.add_const (ring (normed_comm_ring ennreal)) name) : @is_principal_ideal_ring.{0} (normed_comm_ring.{0} ennreal) (@functor.add_const.run.{0 0} (ring.{0} (normed_comm_ring.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_76161 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_76162 (h0 : ring (non_assoc_semiring (option unsigned))) : rank_condition (non_assoc_semiring (option unsigned)) := sorry --non-trivial
lemma new_lemma_76163 (h0 : topological_space (monoid_with_zero (option unsigned))) : topological_space.separable_space (monoid_with_zero (option unsigned)) := sorry --non-trivial
lemma new_lemma_76164 (h0 : filter (has_add name)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_76165 (h1 : topological_space (has_div std_gen)) : totally_disconnected_space (has_div std_gen) := sorry --non-trivial
lemma new_lemma_76166 (h0 : group (random_gen (random_gen to_additive.value_type))) : is_cyclic (random_gen (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_76167 (h0 : topological_space (has_add (has_Inf (has_Inf (has_add (has_add real)))))) : t0_space (has_add (has_Inf (has_Inf (has_add (has_add real))))) := sorry --non-trivial
lemma new_lemma_76168 (h1 : topological_space (denumerable (has_inv to_additive.value_type))) : totally_disconnected_space (denumerable (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_76169 (h0 : not (filter (random_gen unsigned) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_76170 (h0 : add_group (comm_ring (has_nnnorm linarith.comp_source))) : is_add_cyclic (comm_ring (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_76171 (h0 : group (normed_lattice_add_comm_group name)) : group.fg (normed_lattice_add_comm_group name) := sorry --non-trivial
lemma new_lemma_76172 (h0 : functor.add_const (ordered_add_comm_monoid (has_add Type)) Type) : @archimedean.{1} (has_add.{1} Type) (@functor.add_const.run.{1 1} (ordered_add_comm_monoid.{1} (has_add.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_76173 (h0 : function.extfun (Type 1) semiring) : @is_noetherian_ring.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) semiring.{1} h0 (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_76174 (h0 : topological_space (normed_group empty)) : normal_space (normed_group empty) := sorry --non-trivial
lemma new_lemma_76175 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @is_add_cyclic.{0} (normed_group.{0} linarith.ineq) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) add_group.{0}) (normed_group.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_76176 (h0 h1 : multiset (mul_one_class linarith.ineq)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_76177 (h0 : functor.add_const (ordered_comm_monoid (semigroup environment.implicit_infer_kind)) Type) : @has_exists_mul_of_le.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (semigroup.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_76178 (h0 : semiring (option (semiring unsigned)) -> semiring (option (semiring unsigned)) -> Prop) : transitive h0 := sorry --non-trivial
lemma new_lemma_76179 (h0 : ring (comm_ring (metric_space to_additive.value_type))) : rank_condition (comm_ring (metric_space to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_76180 (h0 : group (monoid_with_zero pos)) : normalizer_condition (monoid_with_zero pos) := sorry --non-trivial
lemma new_lemma_76181 (h0 : functor.add_const (function.extfun Type filter) pos) : countable_Inter_filter (function.extfun_app (functor.add_const.run h0) (has_neg pos)) := sorry --non-trivial
lemma new_lemma_76182 (h0 : function.extfun (finset (Type -> Type) -> Prop) (function.extfun (finset (Type -> Type)))) : @group.fg.{0} linarith.comp_source (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) group.{0}) (@function.extfun_app.{2 0} (finset.{1} (Type → Type) → Prop) (function.extfun.{2 0} (finset.{1} (Type → Type))) h0 (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) group.{0})) (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_76183 (h0 : functor.comp group has_add Type) : @is_simple_group.{1} (has_add.{1} Type) (@functor.comp.run.{1 1 1} group.{1} has_add.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_76184 (h0 : finset (monoid_with_zero (option num)) -> finset (monoid_with_zero (option num)) -> Prop) : is_symm (finset (monoid_with_zero (option num))) h0 := sorry --non-trivial
lemma new_lemma_76185 (h0 : topological_space (add_comm_monoid environment.implicit_infer_kind)) : totally_separated_space (add_comm_monoid environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_76186 (h0 : uniform_space (finset (finset (finset linarith.comp)))) : complete_space (finset (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_76187 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (random_gen.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (random_gen.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_76188 (h0 : topological_space (boolean_algebra (has_add (has_add (has_add name))))) : totally_separated_space (boolean_algebra (has_add (has_add (has_add name)))) := sorry --non-trivial
lemma new_lemma_76189 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} congr_arg_kind (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 topological_space.{0}) congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_76190 (h0 : ring (has_neg_part name)) : is_domain (has_neg_part name) := sorry --non-trivial
lemma new_lemma_76191 (h0 : semiring (has_union (has_top unsigned))) : is_noetherian_ring (has_union (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_76192 (h0 : topological_space (add_cancel_monoid linarith.comp)) : path_connected_space (add_cancel_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_76193 (h0 : functor.add_const (topological_space environment.implicit_infer_kind) Type) : @preirreducible_space.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 1} (topological_space.{0} environment.implicit_infer_kind) Type h0)  := sorry --non-trivial
lemma new_lemma_76194 (h0 : complete_lattice (normed_field (random_gen string_imp))) : complete_lattice.is_Sup_finite_compact (normed_field (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_76195 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_simple_group.{0} (mul_zero_class.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (mul_zero_class.{0} name))  := sorry --non-trivial
lemma new_lemma_76196 (h0 : functor.add_const (function.extfun (Type 1) ring) name) : @is_domain.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ring.{1}) name h0) (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_76197 (h0 : ring (denumerable (add_cancel_comm_monoid linarith.comp_source))) : is_domain (denumerable (add_cancel_comm_monoid linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_76198 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (pseudo_metric_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (pseudo_metric_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_76199 (h0 : functor.add_const (function.extfun Type ring) (finset Type)) : @is_domain.{0} (simple_graph.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ring.{0}) (finset.{1} Type) h0) (simple_graph.{0} pos))  := sorry --non-trivial
lemma new_lemma_76200 (h0 : topological_space (denumerable (has_nnnorm (has_nnnorm char)))) : t0_space (denumerable (has_nnnorm (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_76201 (h0 : topological_space (has_bot (has_add (has_add linarith.comp)))) : t1_space (has_bot (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_76202 (h0 : group (linear_ordered_semiring (has_top empty))) : normalizer_condition (linear_ordered_semiring (has_top empty)) := sorry --non-trivial
lemma new_lemma_76203 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (has_neg_part.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_76204 (h0 : not (has_lt (normed_field to_additive.value_type) -> false)) : @densely_ordered.{0} (normed_field.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (has_lt.{0} (normed_field.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_76205 (h0 : ordered_comm_monoid (sub_neg_monoid (has_add (has_add pos)))) : has_exists_mul_of_le (sub_neg_monoid (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_76206 (h0 : not (ring (add_monoid char) -> false)) : @rank_condition.{0} (add_monoid.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (add_monoid.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_76207 (h0 : function.extfun (Type 1) (functor.add_const (topological_space (boolean_algebra.core linarith.comp)))) : @totally_separated_space.{0} (boolean_algebra.core.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.core.{0} linarith.comp)) Type (@function.extfun_app.{3 1} (Type 1) (functor.add_const.{0 1} (topological_space.{0} (boolean_algebra.core.{0} linarith.comp))) h0 Type))  := sorry --non-trivial
lemma new_lemma_76208 (h0 : functor.comp group has_zero name) : @is_cyclic.{0} (has_zero.{0} name) (@functor.comp.run.{0 0 0} group.{0} has_zero.{0} name h0)  := sorry --non-trivial
lemma new_lemma_76209 (h0 : complete_lattice (has_norm (has_norm num))) : is_compactly_generated (has_norm (has_norm num)) := sorry --non-trivial
lemma new_lemma_76210 (h0 : functor.add_const (topological_space (add_comm_monoid unsigned)) environment.implicit_infer_kind) : @preconnected_space.{0} (add_comm_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_76211 (h0 : uniform_space (random_gen (random_gen (random_gen (random_gen fun_info))))) : complete_space (random_gen (random_gen (random_gen (random_gen fun_info)))) := sorry --non-trivial
lemma new_lemma_76212 (h0 : uniform_space (linear_ordered_add_comm_group string_imp)) : complete_space (linear_ordered_add_comm_group string_imp) := sorry --non-trivial
lemma new_lemma_76213 (h0 : fin has_zero.zero) : @irreducible_space.{1} (ordered_comm_ring.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (ordered_comm_ring.{1} Type)) (@function.extfun_app.{1 1} nat fin (@matrix.vec_empty.{0} (function.extfun.{1 1} nat fin) h0) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_76214 (h0 : ring (distrib_lattice (has_norm to_additive.value_type))) : is_domain (distrib_lattice (has_norm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_76215 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (comm_semigroup.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_76216 (h0 : functor.add_const (cancel_comm_monoid_with_zero (generalized_boolean_algebra linarith.comp)) (has_neg Type)) : @unique_factorization_monoid.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 1} (cancel_comm_monoid_with_zero.{0} (generalized_boolean_algebra.{0} linarith.comp)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_76217 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (has_norm.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_norm.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_76218 (h0 : topological_space (has_bot (has_add Type))) : totally_disconnected_space (has_bot (has_add Type)) := sorry --non-trivial
lemma new_lemma_76219 (h0 : complete_lattice (has_nndist (has_neg_part (has_add name)))) : is_compactly_generated (has_nndist (has_neg_part (has_add name))) := sorry --non-trivial
lemma new_lemma_76220 (h0 : group (boolean_algebra.core congr_arg_kind)) : normalizer_condition (boolean_algebra.core congr_arg_kind) := sorry --non-trivial
lemma new_lemma_76221 (h0 : functor.comp topological_space finset Type) : @locally_compact_space.{1} (finset.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} finset.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_76222 (h0 : cancel_comm_monoid_with_zero num) : unique_factorization_monoid num := sorry --non-trivial
lemma new_lemma_76223 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_76224 (h0 : cancel_comm_monoid_with_zero (preorder unsigned)) : unique_factorization_monoid (preorder unsigned) := sorry --non-trivial
lemma new_lemma_76225 (h0 : complete_lattice (normed_linear_ordered_group (semiring (option empty)))) : is_compactly_generated (normed_linear_ordered_group (semiring (option empty))) := sorry --non-trivial
lemma new_lemma_76226 (h0 : functor.add_const (ordered_add_comm_monoid (normed_comm_ring pos)) pos) : @archimedean.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (normed_comm_ring.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_76227 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_neg.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_76228 (h0 : topological_space (has_zero (ring Type))) : regular_space (has_zero (ring Type)) := sorry --non-trivial
lemma new_lemma_76229 (h0 : functor.add_const (topological_space (comm_group environment.implicit_infer_kind)) Type) : @regular_space.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (comm_group.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_76230 (h0 : functor.add_const (complete_lattice (has_to_string pos)) (has_to_string pos)) : @is_compactly_generated.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_to_string.{0} pos)) (has_to_string.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_76231 (h0 : functor.add_const (ring (cancel_monoid unsigned)) name) : @rank_condition.{0} (cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (cancel_monoid.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_76232 (h0 : topological_space (normed_linear_ordered_group congr_arg_kind)) : totally_separated_space (normed_linear_ordered_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_76233 (h0 : ordered_comm_monoid (has_add (ring Type))) : has_exists_mul_of_le (has_add (ring Type)) := sorry --non-trivial
lemma new_lemma_76234 (h0 : ring (add_cancel_monoid (finset pos))) : strong_rank_condition (add_cancel_monoid (finset pos)) := sorry --non-trivial
lemma new_lemma_76235 (h0 : functor.add_const (group (mul_zero_class congr_arg_kind)) congr_arg_kind) : @is_cyclic.{0} (mul_zero_class.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (group.{0} (mul_zero_class.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_76236 (h0 : uniform_space (boolean_algebra.core (boolean_algebra.core pos))) : complete_space (boolean_algebra.core (boolean_algebra.core pos)) := sorry --non-trivial
lemma new_lemma_76237 (h0 : group (add_left_cancel_semigroup empty)) : normalizer_condition (add_left_cancel_semigroup empty) := sorry --non-trivial
lemma new_lemma_76238 (h0 : monoid (linear_ordered_add_comm_group (random_gen (has_inv to_additive.value_type)))) : monoid.fg (linear_ordered_add_comm_group (random_gen (has_inv to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_76239 (h0 : topological_space (with_bot unsigned)) : path_connected_space (with_bot unsigned) := sorry --non-trivial
lemma new_lemma_76240 (h0 : monoid (partial_order (semiring empty))) : monoid.fg (partial_order (semiring empty)) := sorry --non-trivial
lemma new_lemma_76241 (h0 : group (normed_comm_ring (finset (finset (finset linarith.comp))))) : normalizer_condition (normed_comm_ring (finset (finset (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_76242 (h0 : finset (linear_order (option (option (option (option empty)))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_76243 (h0 : not (topological_space (has_emptyc linarith.comp_source) -> false)) : @discrete_topology.{0} (has_emptyc.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (has_emptyc.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_76244 (h1 : ring (has_ssubset (random_gen char))) : is_domain (has_ssubset (random_gen char)) := sorry --non-trivial
lemma new_lemma_76245 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (@id.{2} Type linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (@id.{2} Type linarith.ineq))  := sorry --non-trivial
lemma new_lemma_76246 (h0 : not (function.extfun Type topological_space -> false)) : @totally_separated_space.{0} (semiring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_76247 (h0 : topological_space (has_add (ring environment.implicit_infer_kind))) : regular_space (has_add (ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_76248 (h0 : function.extfun Type (functor.add_const (add_group linarith.comp))) : @is_add_cyclic.{0} linarith.comp (@functor.add_const.run.{0 0} (add_group.{0} linarith.comp) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (add_group.{0} linarith.comp)) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_76249 (h1 : uniform_space (has_emptyc linarith.comp_source)) : complete_space (has_emptyc linarith.comp_source) := sorry --non-trivial
lemma new_lemma_76250 (h0 : cancel_comm_monoid_with_zero (has_to_string (has_neg num))) : unique_factorization_monoid (has_to_string (has_neg num)) := sorry --non-trivial
lemma new_lemma_76251 (h0 : list (has_norm (random_gen fun_info))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_76252 (h0 : functor.add_const (ordered_add_comm_monoid (canonically_ordered_add_monoid empty)) congr_arg_kind) : @archimedean.{0} (canonically_ordered_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (canonically_ordered_add_monoid.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_76253 (h0 : function.extfun Type (functor.add_const (monoid (has_nndist empty)))) : @monoid.fg.{0} (has_nndist.{0} empty) (@functor.add_const.run.{0 0} (monoid.{0} (has_nndist.{0} empty)) ennreal (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (monoid.{0} (has_nndist.{0} empty))) h0 ennreal))  := sorry --non-trivial
lemma new_lemma_76254 (h0 : not (function.extfun Type monoid -> false)) : @monoid.fg.{0} (measurable_space.dynkin_system.{0} num) (@function.extfun_app.{2 1} Type monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type monoid.{0}) h0) (measurable_space.dynkin_system.{0} num))  := sorry --non-trivial
lemma new_lemma_76255 (h2 : complete_lattice (comm_ring reducibility_hints)) : complete_lattice.is_Sup_finite_compact (comm_ring reducibility_hints) := sorry --non-trivial
lemma new_lemma_76256 (h0 : functor.add_const (ring (bin_tree empty)) empty) : @is_principal_ideal_ring.{0} (bin_tree.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (bin_tree.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_76257 (h0 : complete_lattice (metric_space unsigned)) : is_compactly_generated (metric_space unsigned) := sorry --non-trivial
lemma new_lemma_76258 (h0 : topological_space (has_Inf (has_Inf linarith.comp))) : regular_space (has_Inf (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_76259 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} (has_emptyc.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (has_emptyc.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_76260 (h0 : not (add_group (normed_group char) -> false)) : @is_add_cyclic.{0} (normed_group.{0} char) (@classical.by_contradiction'.{1} (add_group.{0} (normed_group.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_76261 (h0 : ring (has_edist (add_comm_monoid unsigned))) : is_domain (has_edist (add_comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_76262 (h0 : function.extfun (Type 1) uniform_space) : @separated_space.{1} (plift.{1} unsigned) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} h0 (plift.{1} unsigned))  := sorry --non-trivial
lemma new_lemma_76263 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (left_cancel_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (left_cancel_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_76264 (h0 : topological_space (with_one char)) : t0_space (with_one char) := sorry --non-trivial
lemma new_lemma_76265 (h0 : not (uniform_space (has_star unsigned) -> false)) : @complete_space.{0} (has_star.{0} unsigned) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_star.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_76266 (h3 : uniform_space (non_unital_non_assoc_semiring string_imp)) : complete_space (non_unital_non_assoc_semiring string_imp) := sorry --non-trivial
lemma new_lemma_76267 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (boolean_algebra.core.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (boolean_algebra.core.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_76268 (h0 : complete_lattice (left_cancel_monoid congr_arg_kind)) : is_compactly_generated (left_cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_76269 (h0 : functor.add_const (topological_space Type) Type) : @discrete_topology.{1} Type (@functor.add_const.run.{1 1} (topological_space.{1} Type) Type h0)  := sorry --non-trivial
lemma new_lemma_76270 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (has_norm.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_norm.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_76271 (h0 : functor.add_const (function.extfun Type monoid) pos) : @monoid.fg.{0} (has_Inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type monoid.{0}) pos h0) (has_Inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_76272 (h0 : group (with_bot (has_top num))) : group.fg (with_bot (has_top num)) := sorry --non-trivial
lemma new_lemma_76273 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (semigroup unsigned)) := sorry --non-trivial
lemma new_lemma_76274 (h0 : not (complete_lattice (has_norm linarith.ineq) -> false)) : @is_compactly_generated.{0} (has_norm.{0} linarith.ineq) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_norm.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_76275 (h0 : functor.add_const (ordered_add_comm_monoid (pseudo_metric_space name)) pos) : @archimedean.{0} (pseudo_metric_space.{0} name) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (pseudo_metric_space.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_76276 (h0 : group (has_neg (ring (option pos)))) : is_cyclic (has_neg (ring (option pos))) := sorry --non-trivial
lemma new_lemma_76277 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_zero.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_zero.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_76278 (h0 : complete_lattice (has_zero pos)) : is_compactly_generated (has_zero pos) := sorry --non-trivial
lemma new_lemma_76279 (h0 : group (ring (option empty))) : is_cyclic (ring (option empty)) := sorry --non-trivial
lemma new_lemma_76280 (h0 : functor.add_const (cancel_comm_monoid_with_zero (ordered_comm_ring Type)) linarith.comp) : @unique_factorization_monoid.{1} (ordered_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (cancel_comm_monoid_with_zero.{1} (ordered_comm_ring.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_76281 (h1 : topological_space (normed_group string_imp)) : path_connected_space (normed_group string_imp) := sorry --non-trivial
lemma new_lemma_76282 (h0 : functor.add_const (function.extfun Type group) name) : @group.fg.{0} (generalized_boolean_algebra.{0} (has_add.{0} pos)) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) name h0) (generalized_boolean_algebra.{0} (has_add.{0} pos)))  := sorry --non-trivial
lemma new_lemma_76283 (h0 : topological_space (comm_ring (random_gen linarith.comp_source))) : t0_space (comm_ring (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_76284 (h0 : functor.comp uniform_space has_neg Type) : @separated_space.{1} (has_neg.{1} Type) (@functor.comp.run.{1 1 1} uniform_space.{1} has_neg.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_76285 (h0 : not (function.extfun Type filter -> false)) : filter.ne_bot (function.extfun_app (classical.by_contradiction' h0) (has_emptyc empty)) := sorry --non-trivial
lemma new_lemma_76286 (h0 : topological_space (free_add_monoid num)) : irreducible_space (free_add_monoid num) := sorry --non-trivial
lemma new_lemma_76287 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (has_pos_part.{0} pos) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (has_pos_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_76288 (h0 : monoid (has_union (has_norm empty))) : monoid.fg (has_union (has_norm empty)) := sorry --non-trivial
lemma new_lemma_76289 (h0 : function.extfun (finset Type) (has_mem.mem (id congr_arg_kind))) : @normalizer_condition.{0} (@id.{2} Type congr_arg_kind) (@finset.pi.empty.{1 0} Type group.{0} (@id.{2} Type congr_arg_kind) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (@id.{2} Type congr_arg_kind)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_76290 (h0 : not (function.extfun Type topological_space -> false)) : @totally_separated_space.{0} (has_norm.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_norm.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_76291 (h0 : topological_space (has_ssubset (has_ssubset (has_nnnorm fun_info)))) : path_connected_space (has_ssubset (has_ssubset (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_76292 (h1 : fun_info -> Prop) : zzz_forall h1 := sorry --non-trivial
lemma new_lemma_76293 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (has_nndist unsigned)) := sorry --non-trivial
lemma new_lemma_76294 (h4 : uniform_space (has_nnnorm (comm_ring reducibility_hints))) : complete_space (has_nnnorm (comm_ring reducibility_hints)) := sorry --non-trivial
lemma new_lemma_76295 (h0 : ordered_add_comm_monoid (add_cancel_monoid (mul_one_class Type))) : archimedean (add_cancel_monoid (mul_one_class Type)) := sorry --non-trivial
lemma new_lemma_76296 (h0 : topological_space (ring (has_nndist name))) : path_connected_space (ring (has_nndist name)) := sorry --non-trivial
lemma new_lemma_76297 (h0 : topological_space (ring (option (option (option empty))))) : t1_space (ring (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_76298 (h0 : topological_space (has_union (semiring empty))) : totally_disconnected_space (has_union (semiring empty)) := sorry --non-trivial
lemma new_lemma_76299 (h0 : functor.add_const (group (complete_distrib_lattice pos)) name) : @normalizer_condition.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (complete_distrib_lattice.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_76300 (h0 : topological_space (has_pos_part (generalized_boolean_algebra linarith.comp))) : t0_space (has_pos_part (generalized_boolean_algebra linarith.comp)) := sorry --non-trivial
lemma new_lemma_76301 (h0 : functor.add_const (complete_lattice (has_to_string unsigned)) Type) : @is_compactly_generated.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 1} (complete_lattice.{0} (has_to_string.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_76302 (h0 : ordered_add_comm_monoid (rel empty unsigned)) : archimedean (rel empty unsigned) := sorry --non-trivial
lemma new_lemma_76303 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (has_to_string ennreal)) := sorry --non-trivial
lemma new_lemma_76304 (h0 : complete_lattice (linear_ordered_comm_group (option (option unsigned)))) : is_atomistic (linear_ordered_comm_group (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_76305 (h0 : not (topological_space (has_compl (mul_one_class (mul_one_class (mul_one_class linarith.ineq)))) -> false)) : @totally_disconnected_space.{0} (has_compl.{0} (mul_one_class.{0} (mul_one_class.{0} (mul_one_class.{0} linarith.ineq)))) (@classical.by_contradiction'.{1} (topological_space.{0} (has_compl.{0} (mul_one_class.{0} (mul_one_class.{0} (mul_one_class.{0} linarith.ineq))))) h0)  := sorry --non-trivial
lemma new_lemma_76306 (h0 : topological_space (partial_order (semiring (semiring (semiring (semiring empty)))))) : normal_space (partial_order (semiring (semiring (semiring (semiring empty))))) := sorry --non-trivial
lemma new_lemma_76307 (h0 : functor.add_const (topological_space (ring linarith.comp)) linarith.comp) : @topological_space.separable_space.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_76308 (h0 : topological_space (has_lt fun_info)) : discrete_topology (has_lt fun_info) := sorry --non-trivial
lemma new_lemma_76309 (h0 : function.extfun Type ring) : is_domain real := sorry --non-trivial
lemma new_lemma_76310 (h0 : functor.add_const (function.extfun (Type 1) topological_space) pos) : @locally_compact_space.{1} (has_zero.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) pos h0) (has_zero.{1} Type))  := sorry --non-trivial
lemma new_lemma_76311 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (comm_semigroup.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_76312 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (canonically_linear_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (canonically_linear_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_76313 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_star.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_star.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_76314 (h0 : complete_lattice (has_to_string (has_add (has_add Type)))) : is_compactly_generated (has_to_string (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_76315 (h0 : uniform_space (has_to_string (has_neg_part pos))) : separated_space (has_to_string (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_76316 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (ordered_ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_76317 (h0 : complete_lattice (comm_group (has_to_string name))) : complete_lattice.is_Sup_finite_compact (comm_group (has_to_string name)) := sorry --non-trivial
lemma new_lemma_76318 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (boolean_algebra.core.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.core.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_76319 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (normed_lattice_add_comm_group.{0} real) (@function.extfun_app.{2 1} Type monoid.{0} h0 (normed_lattice_add_comm_group.{0} real))  := sorry --non-trivial
lemma new_lemma_76320 (h0 : functor.add_const (filter (has_pos_part pos)) pos) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_76321 (h0 : functor.add_const Prop (normed_comm_ring (pseudo_metric_space name))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_76322 (h0 : functor.add_const (complete_lattice (generalized_boolean_algebra linarith.comp)) pos) : @complete_lattice.is_Sup_finite_compact.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (generalized_boolean_algebra.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_76323 (h0 : not (function.extfun Type ring -> false)) : @rank_condition.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (linear_ordered_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_76324 (h0 : topological_space (nondiscrete_normed_field char)) : path_connected_space (nondiscrete_normed_field char) := sorry --non-trivial
lemma new_lemma_76325 (h0 : functor.add_const (topological_space (add_cancel_monoid ennreal)) Type) : @totally_separated_space.{0} (add_cancel_monoid.{0} ennreal) (@functor.add_const.run.{0 1} (topological_space.{0} (add_cancel_monoid.{0} ennreal)) Type h0)  := sorry --non-trivial
lemma new_lemma_76326 (h0 : functor.add_const (functor.add_const (complete_lattice pos) pos) (finset linarith.comp)) : @is_compactly_generated.{0} pos (@functor.add_const.run.{0 0} (complete_lattice.{0} pos) pos (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (complete_lattice.{0} pos) pos) (finset.{0} linarith.comp) h0))  := sorry --non-trivial
lemma new_lemma_76327 (h0 : list (distrib_lattice (has_nnnorm (has_top fun_info)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_76328 (h1 : add_group (denumerable (comm_ring char))) : is_add_cyclic (denumerable (comm_ring char)) := sorry --non-trivial
lemma new_lemma_76329 (h0 : set (ordered_comm_group pos)) : set.infinite h0 := sorry --non-trivial
lemma new_lemma_76330 (h0 : complete_lattice (has_nndist (has_neg_part Type))) : complete_lattice.is_Sup_finite_compact (has_nndist (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_76331 (h0 : functor.add_const (function.extfun (Type 1) finset) environment.implicit_infer_kind) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (has_neg Type)) := sorry --non-trivial
lemma new_lemma_76332 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (dlist.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (dlist.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_76333 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (metric_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_group.{0} h0 (metric_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_76334 (h0 : functor.add_const (group (comm_group pos)) Type) : @is_simple_group.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (comm_group.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_76335 (h0 : ring (has_append (comm_ring (comm_ring reducibility_hints)))) : rank_condition (has_append (comm_ring (comm_ring reducibility_hints))) := sorry --non-trivial
lemma new_lemma_76336 (h0 : uniform_space (boolean_algebra.core (option (option empty)))) : complete_space (boolean_algebra.core (option (option empty))) := sorry --non-trivial
lemma new_lemma_76337 (h0 : functor.comp topological_space has_zero pos) : @totally_disconnected_space.{0} (has_zero.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} has_zero.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_76338 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (omega_complete_partial_order.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (omega_complete_partial_order.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_76339 (h0 : topological_space (semigroup (boolean_algebra.core (boolean_algebra.core linarith.comp)))) : normal_space (semigroup (boolean_algebra.core (boolean_algebra.core linarith.comp))) := sorry --non-trivial
lemma new_lemma_76340 (h0 : functor.add_const (function.extfun (Type 1) ordered_add_comm_monoid) Type) : @archimedean.{1} Type (@function.extfun_app.{3 2} (Type 1) ordered_add_comm_monoid.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) ordered_add_comm_monoid.{1}) Type h0) Type)  := sorry --non-trivial
lemma new_lemma_76341 (h0 : functor.add_const (functor.add_const (list environment.implicit_infer_kind) (finset pos)) pos) : palindrome (functor.add_const.run (functor.add_const.run h0)) := sorry --non-trivial
lemma new_lemma_76342 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 name) := sorry --non-trivial
lemma new_lemma_76343 (h0 : ring (has_to_string (has_add (has_add name)))) : is_principal_ideal_ring (has_to_string (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_76344 (h0 : set (has_ssubset (mul_one_class environment.projection_info))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_76345 (h0 : ordered_add_comm_monoid (canonically_ordered_comm_semiring (has_neg (has_neg_part (has_neg_part Type))))) : archimedean (canonically_ordered_comm_semiring (has_neg (has_neg_part (has_neg_part Type)))) := sorry --non-trivial
lemma new_lemma_76346 (h0 : ordered_comm_monoid (has_add (has_neg environment.implicit_infer_kind))) : has_exists_mul_of_le (has_add (has_neg environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_76347 (h0 : not (function.extfun Type ring -> false)) : @rank_condition.{0} (measurable_space.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (measurable_space.{0} num))  := sorry --non-trivial
lemma new_lemma_76348 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @discrete_topology.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_76349 (h0 : functor.add_const (functor.add_const (group name) num) (semiring empty)) : @normalizer_condition.{0} name (@functor.add_const.run.{0 0} (group.{0} name) num (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (group.{0} name) num) (semiring.{0} empty) h0))  := sorry --non-trivial
lemma new_lemma_76350 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} (normed_group.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (normed_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_76351 (h0 : multiset ereal) : multiset.nodup h0 := sorry --non-trivial
lemma new_lemma_76352 (h0 : functor.add_const (ring (cancel_monoid name)) pos) : @strong_rank_condition.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (cancel_monoid.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_76353 (h0 : ring (topological_space (has_nnnorm reducibility_hints))) : rank_condition (topological_space (has_nnnorm reducibility_hints)) := sorry --non-trivial
lemma new_lemma_76354 (h0 : topological_space (has_add (boolean_algebra name))) : t0_space (has_add (boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_76355 (h0 : prod (add_cancel_monoid num) (add_cancel_monoid num)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_76356 (h0 : group (has_append char)) : is_cyclic (has_append char) := sorry --non-trivial
lemma new_lemma_76357 (h0 : topological_space (boolean_algebra (has_to_string pos))) : locally_compact_space (boolean_algebra (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_76358 (h0 : semiring (canonically_ordered_comm_semiring name)) : is_noetherian_ring (canonically_ordered_comm_semiring name) := sorry --non-trivial
lemma new_lemma_76359 (h0 : ordered_comm_monoid (linear_ordered_field (option (option (option pos))))) : has_exists_mul_of_le (linear_ordered_field (option (option (option pos)))) := sorry --non-trivial
lemma new_lemma_76360 (h0 : fin has_zero.zero) : @is_add_cyclic.{0} (simple_graph.{0} pos) (@matrix.vec_empty.{0} (add_group.{0} (simple_graph.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_76361 (h0 : complete_lattice (normed_field (has_lt string_imp))) : is_compactly_generated (normed_field (has_lt string_imp)) := sorry --non-trivial
lemma new_lemma_76362 (h0 : list (cancel_monoid name)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_76363 (h0 : Prop -> linarith.ineq) (h1 : coe_sort (set.range h0)) : set.range_splitting h0 h1 := sorry --non-trivial
lemma new_lemma_76364 (h0 : topological_space (comm_monoid char)) : path_connected_space (comm_monoid char) := sorry --non-trivial
lemma new_lemma_76365 (h0 : functor.add_const (filter (boolean_algebra name)) environment.implicit_infer_kind) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_76366 (h0 : not (ring (complete_linear_order unsigned) -> false)) : @strong_rank_condition.{0} (complete_linear_order.{0} unsigned) (@classical.by_contradiction'.{1} (ring.{0} (complete_linear_order.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_76367 (h0 : topological_space (complete_distrib_lattice (mul_zero_class (has_add Type)))) : totally_disconnected_space (complete_distrib_lattice (mul_zero_class (has_add Type))) := sorry --non-trivial
lemma new_lemma_76368 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (ring.{0} (option.{0} ennreal)) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (ring.{0} (option.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_76369 (h0 : list (has_Inf (has_Inf (has_Inf pos)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_76370 (h0 : functor.add_const (monoid (normed_comm_ring pos)) (has_neg Type)) : @monoid.fg.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 1} (monoid.{0} (normed_comm_ring.{0} pos)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_76371 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (preorder.{0} (semiring.{0} empty)) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (preorder.{0} (semiring.{0} empty)))  := sorry --non-trivial
lemma new_lemma_76372 (h0 : topological_space (boolean_algebra (has_Inf (has_add linarith.comp)))) : normal_space (boolean_algebra (has_Inf (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_76373 (h0 : functor.add_const (ring (add_cancel_monoid linarith.comp)) (has_Inf name)) : @rank_condition.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (add_cancel_monoid.{0} linarith.comp)) (has_Inf.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_76374 (h0 : functor.add_const (monoid (has_neg pos)) (has_add pos)) : @monoid.fg.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (monoid.{0} (has_neg.{0} pos)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_76375 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (canonically_ordered_add_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_ordered_add_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_76376 (h0 : not (group (complete_linear_order empty) -> false)) : @is_cyclic.{0} (complete_linear_order.{0} empty) (@classical.by_contradiction'.{1} (group.{0} (complete_linear_order.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_76377 (h0 : complete_lattice (has_to_string (has_nndist Type))) : is_atomistic (has_to_string (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_76378 (h0 : topological_space (omega_complete_partial_order (option empty))) : totally_separated_space (omega_complete_partial_order (option empty)) := sorry --non-trivial
lemma new_lemma_76379 (h0 : add_group (comm_group (has_to_string (has_neg_part Type)))) : is_add_cyclic (comm_group (has_to_string (has_neg_part Type))) := sorry --non-trivial
lemma new_lemma_76380 (h0 : monoid (free_add_monoid congr_arg_kind)) : monoid.fg (free_add_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_76381 (h0 : add_group (finset (has_nndist name))) : is_add_cyclic (finset (has_nndist name)) := sorry --non-trivial
lemma new_lemma_76382 (h0 : fin has_zero.zero) : @is_simple_group.{0} (has_to_string.{0} linarith.comp) (@matrix.vec_empty.{0} (group.{0} (has_to_string.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_76383 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (distrib_lattice.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (distrib_lattice.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_76384 (h0 : complete_lattice (pseudo_metric_space (option (option ennreal)))) : complete_lattice.is_Sup_finite_compact (pseudo_metric_space (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_76385 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (finset.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} empty))  := sorry --non-trivial
lemma new_lemma_76386 (h0 : functor.add_const (function.extfun Type filter) pos) : countable_Inter_filter (function.extfun_app (functor.add_const.run h0) (boolean_algebra unsigned)) := sorry --non-trivial
lemma new_lemma_76387 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (monoid_with_zero.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (monoid_with_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_76388 (h0 : topological_space (has_zero (comm_group Type))) : discrete_topology (has_zero (comm_group Type)) := sorry --non-trivial
lemma new_lemma_76389 (h0 : topological_space (non_assoc_semiring (semiring (semiring (semiring (semiring congr_arg_kind)))))) : path_connected_space (non_assoc_semiring (semiring (semiring (semiring (semiring congr_arg_kind))))) := sorry --non-trivial
lemma new_lemma_76390 (h0 : functor.add_const (function.extfun Type topological_space) (ring linarith.comp)) : @preconnected_space.{0} (complete_distrib_lattice.{0} (ring.{0} linarith.comp)) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (ring.{0} linarith.comp) h0) (complete_distrib_lattice.{0} (ring.{0} linarith.comp)))  := sorry --non-trivial
lemma new_lemma_76391 (h1 : function.extfun Type topological_space) : @totally_separated_space.{0} (with_bot.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (with_bot.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_76392 (h0 : group (add_comm_monoid (has_neg name))) : is_simple_group (add_comm_monoid (has_neg name)) := sorry --non-trivial
lemma new_lemma_76393 (h0 : monoid (add_group congr_arg_kind)) : monoid.fg (add_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_76394 (h0 : topological_space (semiring (has_norm (has_norm num)))) : t0_space (semiring (has_norm (has_norm num))) := sorry --non-trivial
lemma new_lemma_76395 (h0 : topological_space (has_neg (finset (has_neg linarith.comp)))) : t1_space (has_neg (finset (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_76396 (h0 : filter (div_inv_monoid (has_nnnorm fun_info))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_76397 (h0 : complete_lattice (comm_monoid num)) : is_compactly_generated (comm_monoid num) := sorry --non-trivial
lemma new_lemma_76398 (h0 : topological_space (normed_field (has_ssubset reducibility_hints))) : totally_disconnected_space (normed_field (has_ssubset reducibility_hints)) := sorry --non-trivial
lemma new_lemma_76399 (h0 : topological_space (has_le fun_info)) (h1 : preorder (has_le fun_info)) : order_closed_topology (has_le fun_info) := sorry --non-trivial
lemma new_lemma_76400 (h0 : topological_space (has_bot unsigned)) : totally_disconnected_space (has_bot unsigned) := sorry --non-trivial
lemma new_lemma_76401 (h0 : ring (distrib (has_nnnorm linarith.comp_source))) : rank_condition (distrib (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_76402 (h0 : not (has_mem.mem group has_emptyc.emptyc -> false)) : @normalizer_condition.{0} (has_norm.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) group.{0} (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type)))) h0)) (has_norm.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_76403 (h0 : monoid (has_nndist (boolean_algebra (has_add (cancel_monoid pos))))) : monoid.fg (has_nndist (boolean_algebra (has_add (cancel_monoid pos)))) := sorry --non-trivial
lemma new_lemma_76404 (h0 : function.extfun (Type 1) cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{1} (has_pos_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1} h0 (has_pos_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_76405 (h0 : not (filter (comm_ring fun_info) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_76406 (h0 : ring (encodable (has_ssubset linarith.ineq))) : rank_condition (encodable (has_ssubset linarith.ineq)) := sorry --non-trivial
lemma new_lemma_76407 (h0 : functor.add_const (topological_space (left_cancel_monoid num)) num) : @topological_space.separable_space.{0} (left_cancel_monoid.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_76408 (h0 : topological_space (boolean_algebra.core (add_comm_monoid Type))) : discrete_topology (boolean_algebra.core (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_76409 (h0 : topological_space (has_add linarith.comp)) : t0_space (has_add linarith.comp) := sorry --non-trivial
lemma new_lemma_76410 (h0 : function.extfun nat fin) : @has_exists_mul_of_le.{1} (has_Inf.{1} Type) (@matrix.vec_empty.{1} (ordered_comm_monoid.{1} (has_Inf.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_76411 (h0 : group (ring congr_arg_kind)) : normalizer_condition (ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_76412 (h0 : finset (has_star (option (option empty)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_76413 (h0 : fin has_zero.zero) : @unique_factorization_monoid.{0} (has_bot.{0} real) (@matrix.vec_empty.{0} (cancel_comm_monoid_with_zero.{0} (has_bot.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_76414 (h0 : ring (div_inv_monoid linarith.ineq)) : strong_rank_condition (div_inv_monoid linarith.ineq) := sorry --non-trivial
lemma new_lemma_76415 (h0 : topological_space (random_gen (complete_semilattice_Sup num))) : locally_compact_space (random_gen (complete_semilattice_Sup num)) := sorry --non-trivial
lemma new_lemma_76416 (h0 : ordered_comm_monoid (semigroup (has_pos_part (ring (ring linarith.comp))))) : has_exists_mul_of_le (semigroup (has_pos_part (ring (ring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_76417 (h0 : functor.add_const (topological_space (has_star empty)) num) : @path_connected_space.{0} (has_star.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_76418 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @normal_space.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_76419 (h0 : uniform_space (has_zero environment.implicit_infer_kind)) : separated_space (has_zero environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_76420 (h0 : functor.add_const (complete_lattice (has_nndist num)) ennreal) : @is_compactly_generated.{0} (has_nndist.{0} num) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_nndist.{0} num)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_76421 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (group_with_zero.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (group_with_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_76422 (h0 : topological_space (has_pos_part (has_add (has_neg (add_cancel_monoid (has_neg linarith.comp)))))) : preirreducible_space (has_pos_part (has_add (has_neg (add_cancel_monoid (has_neg linarith.comp))))) := sorry --non-trivial
lemma new_lemma_76423 (h0 : complete_lattice (add_left_cancel_monoid fun_info)) : complete_lattice.is_Sup_finite_compact (add_left_cancel_monoid fun_info) := sorry --non-trivial
lemma new_lemma_76424 (h0 : topological_space (comm_group (has_to_string pos))) : regular_space (comm_group (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_76425 (h1 : set (set (nondiscrete_normed_field (mul_one_class (normed_field enat))))) (h2 : set (nondiscrete_normed_field (mul_one_class (normed_field enat)))) : measurable_space.dynkin_system.generate_has h1 h2 := sorry --non-trivial
lemma new_lemma_76426 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (linear_ordered_cancel_comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_76427 (h0 : uniform_space (finset (normed_comm_ring pos))) : complete_space (finset (normed_comm_ring pos)) := sorry --non-trivial
lemma new_lemma_76428 (h0 : topological_space (boolean_algebra (semigroup pos))) : preconnected_space (boolean_algebra (semigroup pos)) := sorry --non-trivial
lemma new_lemma_76429 (h0 : add_group (linear_ordered_add_comm_group_with_top reducibility_hints)) : is_add_cyclic (linear_ordered_add_comm_group_with_top reducibility_hints) := sorry --non-trivial
lemma new_lemma_76430 (h0 : complete_lattice (has_norm (with_bot linarith.comp))) : is_atomistic (has_norm (with_bot linarith.comp)) := sorry --non-trivial
lemma new_lemma_76431 (h0 : topological_space (boolean_algebra (boolean_algebra.core unsigned))) : totally_separated_space (boolean_algebra (boolean_algebra.core unsigned)) := sorry --non-trivial
lemma new_lemma_76432 (h0 : ring (has_Sup (option (comm_monoid unsigned)))) : is_principal_ideal_ring (has_Sup (option (comm_monoid unsigned))) := sorry --non-trivial
lemma new_lemma_76433 (h0 : functor.add_const (ring (normed_group unsigned)) empty) : @strong_rank_condition.{0} (normed_group.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (normed_group.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_76434 (h0 : topological_space (metric_space (semiring (semiring (semiring linarith.comp))))) : preirreducible_space (metric_space (semiring (semiring (semiring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_76435 (h0 : functor.add_const (ring (semigroup pos)) (has_add Type)) : @is_principal_ideal_ring.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (semigroup.{0} pos)) (has_add.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_76436 (h1 : group (semi_normed_ring reducibility_hints)) : is_cyclic (semi_normed_ring reducibility_hints) := sorry --non-trivial
lemma new_lemma_76437 (h0 : functor.add_const (cancel_comm_monoid_with_zero (ordered_comm_ring pos)) pos) : @unique_factorization_monoid.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (ordered_comm_ring.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_76438 (h0 : functor.add_const (cancel_comm_monoid_with_zero (comm_monoid empty)) empty) : @unique_factorization_monoid.{0} (comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (comm_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_76439 (h0 : functor.add_const (functor.add_const Prop (normed_comm_ring linarith.comp)) name) : functor.add_const.run (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_76440 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_star.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_star.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_76441 (h0 : topological_space (has_nnnorm (has_ssubset to_additive.value_type))) : path_connected_space (has_nnnorm (has_ssubset to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_76442 (h0 : ring (has_norm congr_arg_kind)) : strong_rank_condition (has_norm congr_arg_kind) := sorry --non-trivial
lemma new_lemma_76443 (h0 : functor.add_const (monoid (has_zero name)) (finset environment.implicit_infer_kind)) : @monoid.fg.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (monoid.{0} (has_zero.{0} name)) (finset.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_76444 (h1 : add_group num) : is_add_cyclic num := sorry --non-trivial
lemma new_lemma_76445 (h0 : nat) (h1 : list Prop) : list.head (list.take h0 h1) := sorry --non-trivial
lemma new_lemma_76446 (h0 : group (linear_ordered_add_comm_group string_imp)) : group.fg (linear_ordered_add_comm_group string_imp) := sorry --non-trivial
lemma new_lemma_76447 (h0 : ring (add_cancel_monoid pos)) : is_principal_ideal_ring (add_cancel_monoid pos) := sorry --non-trivial
lemma new_lemma_76448 (h0 : complete_lattice (has_to_string (has_neg_part (has_neg_part Type)))) : is_atomistic (has_to_string (has_neg_part (has_neg_part Type))) := sorry --non-trivial
lemma new_lemma_76449 (h0 : functor.add_const (filter (add_cancel_monoid linarith.comp)) pos) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_76450 (h0 : functor.add_const (add_monoid (sub_neg_monoid real)) real) : @add_monoid.fg.{0} (sub_neg_monoid.{0} real) (@functor.add_const.run.{0 0} (add_monoid.{0} (sub_neg_monoid.{0} real)) real h0)  := sorry --non-trivial
lemma new_lemma_76451 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (has_top.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_top.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_76452 (h0 : topological_space char) (h1 : preorder char) : order_topology char := sorry --non-trivial
lemma new_lemma_76453 (h0 : functor.add_const (add_monoid (normed_comm_ring unsigned)) (option empty)) : @add_monoid.fg.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 0} (add_monoid.{0} (normed_comm_ring.{0} unsigned)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_76454 (h2 : uniform_space (add_comm_semigroup enat)) : complete_space (add_comm_semigroup enat) := sorry --non-trivial
lemma new_lemma_76455 (h1 : topological_space (nondiscrete_normed_field (mul_one_class (mul_one_class fun_info)))) : t0_space (nondiscrete_normed_field (mul_one_class (mul_one_class fun_info))) := sorry --non-trivial
lemma new_lemma_76456 (h0 : not (topological_space (has_norm (random_gen linarith.comp_source)) -> false)) : @locally_compact_space.{0} (has_norm.{0} (random_gen.{0} linarith.comp_source)) (@classical.by_contradiction'.{1} (topological_space.{0} (has_norm.{0} (random_gen.{0} linarith.comp_source))) h0)  := sorry --non-trivial
lemma new_lemma_76457 (h0 : function.extfun Type (functor.comp ordered_comm_monoid has_nndist)) : @has_exists_mul_of_le.{0} (has_nndist.{0} pos) (@functor.comp.run.{0 0 0} ordered_comm_monoid.{0} has_nndist.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} ordered_comm_monoid.{0} has_nndist.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_76458 (h0 : complete_lattice (topological_space (has_nnnorm (has_nnnorm fun_info)))) : is_compactly_generated (topological_space (has_nnnorm (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_76459 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_top.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_top.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_76460 (h0 : topological_space (with_bot (has_top fun_info))) : locally_compact_space (with_bot (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_76461 (h0 : uniform_space (mul_one_class (random_gen (mul_one_class string_imp)))) : complete_space (mul_one_class (random_gen (mul_one_class string_imp))) := sorry --non-trivial
lemma new_lemma_76462 (h0 : functor.add_const (group (has_add Type)) linarith.comp) : @is_cyclic.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (has_add.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_76463 (h0 : filter (has_neg (has_pos_part pos))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_76464 (h0 : topological_space (has_Sup (semiring unsigned))) : loc_path_connected_space (has_Sup (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_76465 (h0 : ring (has_emptyc (has_inv fun_info))) : is_domain (has_emptyc (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_76466 (h0 : topological_space (with_one char)) : totally_disconnected_space (with_one char) := sorry --non-trivial
lemma new_lemma_76467 (h0 : complete_lattice (canonically_ordered_comm_semiring Type)) : is_atomistic (canonically_ordered_comm_semiring Type) := sorry --non-trivial
lemma new_lemma_76468 (h0 : functor.add_const (topological_space (has_bot empty)) (semiring empty)) : @totally_disconnected_space.{0} (has_bot.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_bot.{0} empty)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_76469 (h0 : uniform_space (has_to_string (has_add pos))) : complete_space (has_to_string (has_add pos)) := sorry --non-trivial
lemma new_lemma_76470 (h0 : semiring congr_arg_kind -> semiring congr_arg_kind -> Prop) : is_strict_order (semiring congr_arg_kind) h0 := sorry --non-trivial
lemma new_lemma_76471 (h0 : add_monoid (add_group fun_info)) : add_monoid.fg (add_group fun_info) := sorry --non-trivial
lemma new_lemma_76472 (h0 : add_monoid (add_comm_semigroup ereal)) : add_monoid.fg (add_comm_semigroup ereal) := sorry --non-trivial
lemma new_lemma_76473 (h0 : topological_space (sub_neg_monoid (has_add (has_pos_part (has_add linarith.comp))))) : loc_path_connected_space (sub_neg_monoid (has_add (has_pos_part (has_add linarith.comp)))) := sorry --non-trivial
lemma new_lemma_76474 (h0 : ring (has_norm (distrib_lattice (has_norm to_additive.value_type)))) : rank_condition (has_norm (distrib_lattice (has_norm to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_76475 (h0 : complete_lattice (has_neg (comm_group (comm_group Type)))) : is_atomistic (has_neg (comm_group (comm_group Type))) := sorry --non-trivial
lemma new_lemma_76476 (h0 : function.extfun Type ring) : @is_domain.{0} (linear_ordered_field.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_ordered_field.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_76477 (h0 : functor.add_const (topological_space (add_cancel_monoid linarith.comp)) name) : @t0_space.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_76478 (h0 : topological_space (ordered_comm_ring (has_neg pos))) : regular_space (ordered_comm_ring (has_neg pos)) := sorry --non-trivial
lemma new_lemma_76479 (h0 : functor.add_const (topological_space (has_Inf pos)) Type) : @t1_space.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_Inf.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_76480 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (ordered_cancel_add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (ordered_cancel_add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_76481 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (has_star.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} unsigned)) (option.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (has_star.{0} unsigned))) (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 (functor.add_const.{0 0} (topological_space.{0} (has_star.{0} unsigned)))) (option.{0} (option.{0} empty))))  := sorry --non-trivial
lemma new_lemma_76482 (h0 : functor.add_const (topological_space (cancel_monoid congr_arg_kind)) congr_arg_kind) : @path_connected_space.{0} (cancel_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_76483 (h0 : complete_lattice (boolean_algebra.core (add_comm_monoid (has_add pos)))) : is_atomistic (boolean_algebra.core (add_comm_monoid (has_add pos))) := sorry --non-trivial
lemma new_lemma_76484 (h0 : has_mem.mem uniform_space has_emptyc.emptyc) : @separated_space.{0} (has_top.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) uniform_space.{0} h0) (has_top.{0} num))  := sorry --non-trivial
lemma new_lemma_76485 (h0 : functor.add_const (finset (add_right_cancel_monoid unsigned)) (semiring (semiring (semiring num)))) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_76486 (h0 : list (normed_comm_ring (boolean_algebra (has_neg Type)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_76487 (h4 : semiring (mul_one_class enat)) (h5 : ideal (mul_one_class enat)) : ideal.is_prime h5 := sorry --non-trivial
lemma new_lemma_76488 (h0 : uniform_space (has_top string_imp)) : complete_space (has_top string_imp) := sorry --non-trivial
lemma new_lemma_76489 (h0 : group (ordered_comm_ring (has_add linarith.comp))) : group.fg (ordered_comm_ring (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_76490 (h0 : topological_space (has_norm (random_gen linarith.ineq))) : totally_separated_space (has_norm (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_76491 (h0 : monoid (measurable_space.dynkin_system (semiring empty))) : monoid.fg (measurable_space.dynkin_system (semiring empty)) := sorry --non-trivial
lemma new_lemma_76492 (h0 : function.extfun (Type 1) ring) : @rank_condition.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_76493 (h0 : complete_lattice (has_add (option (option (option pos))))) : complete_lattice.is_Sup_finite_compact (has_add (option (option (option pos)))) := sorry --non-trivial
lemma new_lemma_76494 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @t0_space.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_76495 (h0 h1 : multiset (add_comm_semigroup (add_comm_semigroup fun_info))) : multiset.le h0 h1 := sorry --non-trivial
lemma new_lemma_76496 (h0 : functor.add_const (function.extfun Type group) name) : @group.fg.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) name h0) (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_76497 (h0 : functor.add_const (filter (add_cancel_monoid unsigned)) (finset linarith.comp)) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_76498 (h0 : function.extfun Type topological_space) : @t0_space.{0} (as_linear_order.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (as_linear_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_76499 (h1 : topological_space (has_ssubset (random_gen linarith.ineq))) : locally_compact_space (has_ssubset (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_76500 (h0 : not (cancel_comm_monoid_with_zero (id empty) -> false)) : @unique_factorization_monoid.{0} (@id.{2} Type empty) (@classical.by_contradiction'.{1} (cancel_comm_monoid_with_zero.{0} (@id.{2} Type empty)) h0)  := sorry --non-trivial
lemma new_lemma_76501 (h1 : not (ring (random_gen linarith.comp_source) -> false)) : @is_domain.{0} (random_gen.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (random_gen.{0} linarith.comp_source)) h1)  := sorry --non-trivial
lemma new_lemma_76502 (h0 : complete_lattice (has_top (semiring (semiring (semiring (semiring empty)))))) : is_atomistic (has_top (semiring (semiring (semiring (semiring empty))))) := sorry --non-trivial
lemma new_lemma_76503 (h0 : complete_lattice (with_one (has_top linarith.comp_source))) : is_compactly_generated (with_one (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_76504 (h0 : add_group (distrib_lattice (random_gen to_additive.value_type))) : is_add_cyclic (distrib_lattice (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_76505 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (linear_ordered_comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_76506 (h0 : functor.add_const (ordered_comm_monoid (boolean_algebra unsigned)) Type) : @has_exists_mul_of_le.{0} (boolean_algebra.{0} unsigned) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (boolean_algebra.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_76507 (h0 : functor.add_const (topological_space (ring name)) linarith.comp) : @loc_path_connected_space.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_76508 (h0 : filter (comm_ring (random_gen linarith.ineq))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_76509 (h0 : ring (has_compl (has_compl enat))) : is_domain (has_compl (has_compl enat)) := sorry --non-trivial
lemma new_lemma_76510 (h0 : topological_space (finset (has_Inf (has_Inf real)))) : t1_space (finset (has_Inf (has_Inf real))) := sorry --non-trivial
lemma new_lemma_76511 (h0 : group (ring pos)) : normalizer_condition (ring pos) := sorry --non-trivial
lemma new_lemma_76512 (h3 : add_group (semi_normed_ring char)) : is_add_cyclic (semi_normed_ring char) := sorry --non-trivial
lemma new_lemma_76513 (h0 : topological_space (finset (has_nndist pos))) : preconnected_space (finset (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_76514 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (with_bot.{0} (has_norm.{0} fun_info)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_bot.{0} (has_norm.{0} fun_info)))  := sorry --non-trivial
lemma new_lemma_76515 (h0 : function.extfun Type (functor.add_const (group (omega_complete_partial_order empty)))) : @group.fg.{0} (omega_complete_partial_order.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (omega_complete_partial_order.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (group.{0} (omega_complete_partial_order.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_76516 (h0 : add_monoid (ordered_comm_monoid (sub_neg_monoid (ordered_comm_monoid Type)))) : add_monoid.fg (ordered_comm_monoid (sub_neg_monoid (ordered_comm_monoid Type))) := sorry --non-trivial
lemma new_lemma_76517 (h0 : functor.add_const (uniform_space (has_neg_part Type)) (mul_zero_class (finset Type))) : @complete_space.{1} (has_neg_part.{1} Type) (@functor.add_const.run.{1 1} (uniform_space.{1} (has_neg_part.{1} Type)) (mul_zero_class.{1} (finset.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_76518 (h0 : not (function.extfun Type topological_space -> false)) : @totally_separated_space.{0} (has_inv.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_inv.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_76519 (h0 : uniform_space (has_neg (has_neg linarith.comp))) : complete_space (has_neg (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_76520 (h0 : topological_space (normed_group (has_union (has_norm linarith.comp)))) : locally_compact_space (normed_group (has_union (has_norm linarith.comp))) := sorry --non-trivial
lemma new_lemma_76521 (h0 : functor.comp topological_space finset name) : @sequential_space.{0} (finset.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} finset.{0} name h0)  := sorry --non-trivial
lemma new_lemma_76522 (h0 : list (linear_ordered_add_comm_group (random_gen to_additive.value_type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_76523 (h0 : topological_space (uniform_space (random_gen (comm_ring reducibility_hints)))) : totally_disconnected_space (uniform_space (random_gen (comm_ring reducibility_hints))) := sorry --non-trivial
lemma new_lemma_76524 (h1 : group (with_one linarith.comp_source)) : group.fg (with_one linarith.comp_source) := sorry --non-trivial
lemma new_lemma_76525 (h0 : functor.add_const (functor.add_const (group Type) Type) pos) : @group.fg.{1} Type (@functor.add_const.run.{1 1} (group.{1} Type) Type (@functor.add_const.run.{1 0} (functor.add_const.{1 1} (group.{1} Type) Type) pos h0))  := sorry --non-trivial
lemma new_lemma_76526 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (finset.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (finset.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_76527 (h1 : topological_space (has_ssubset linarith.ineq)) : totally_disconnected_space (has_ssubset linarith.ineq) := sorry --non-trivial
lemma new_lemma_76528 (h2 : uniform_space (semi_normed_ring linarith.comp_source)) : complete_space (semi_normed_ring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_76529 (h0 : functor.add_const (ring (complete_distrib_lattice name)) linarith.comp) : @strong_rank_condition.{0} (complete_distrib_lattice.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (complete_distrib_lattice.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_76530 (h0 : topological_space (has_neg (has_to_string Type))) : regular_space (has_neg (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_76531 (h0 : functor.add_const (function.extfun Type ring) empty) : @is_principal_ideal_ring.{0} (option.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) empty h0) (option.{0} num))  := sorry --non-trivial
lemma new_lemma_76532 (h0 : function.extfun nat fin) : @is_compactly_generated.{0} (simple_graph.{0} name) (@matrix.vec_empty.{0} (complete_lattice.{0} (simple_graph.{0} name)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_76533 (h0 : ordered_comm_monoid (linear_ordered_field (option (option unsigned)))) : has_exists_mul_of_le (linear_ordered_field (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_76534 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (has_bot.{0} real) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (has_bot.{0} real))  := sorry --non-trivial
lemma new_lemma_76535 (h0 : list (complete_semilattice_Sup (complete_semilattice_Sup (complete_semilattice_Sup to_additive.value_type)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_76536 (h0 : not (filter (has_ssubset fun_info) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_76537 (h0 : uniform_space (uniform_space (mul_one_class (mul_one_class reducibility_hints)))) : complete_space (uniform_space (mul_one_class (mul_one_class reducibility_hints))) := sorry --non-trivial
lemma new_lemma_76538 (h0 : topological_space (has_union (semiring (semiring linarith.comp)))) : totally_separated_space (has_union (semiring (semiring linarith.comp))) := sorry --non-trivial
lemma new_lemma_76539 (h0 : functor.comp topological_space boolean_algebra.core name) : @discrete_topology.{0} (boolean_algebra.core.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} boolean_algebra.core.{0} name h0)  := sorry --non-trivial
lemma new_lemma_76540 (h0 : uniform_space (has_top (random_gen to_additive.value_type))) : complete_space (has_top (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_76541 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (finset.{0} num) (@function.extfun_app.{2 1} Type monoid.{0} h0 (finset.{0} num))  := sorry --non-trivial
lemma new_lemma_76542 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} znum (@function.extfun_app.{2 1} Type topological_space.{0} h0 znum)  := sorry --non-trivial
lemma new_lemma_76543 (h0 : topological_space (has_neg (finset (semigroup (finset (finset linarith.comp)))))) : preconnected_space (has_neg (finset (semigroup (finset (finset linarith.comp))))) := sorry --non-trivial
lemma new_lemma_76544 (h0 : topological_space (has_ssubset string_imp)) : totally_disconnected_space (has_ssubset string_imp) := sorry --non-trivial
lemma new_lemma_76545 (h0 : topological_space (semigroup (semiring empty))) : totally_disconnected_space (semigroup (semiring empty)) := sorry --non-trivial
lemma new_lemma_76546 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @totally_separated_space.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_76547 (h1 : ring (dlist linarith.comp_source)) : rank_condition (dlist linarith.comp_source) := sorry --non-trivial
lemma new_lemma_76548 (h0 : monoid (emetric_space congr_arg_kind)) : monoid.fg (emetric_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_76549 (h0 : random_gen fun_info -> random_gen fun_info -> bool) : is_dec_refl h0 := sorry --non-trivial
lemma new_lemma_76550 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_76551 (h0 : function.extfun Type (functor.add_const (ring ennreal))) : @is_principal_ideal_ring.{0} ennreal (@functor.add_const.run.{0 0} (ring.{0} ennreal) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} ennreal)) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_76552 (h0 : functor.add_const (topological_space (boolean_algebra.core unsigned)) Type) : @sequential_space.{0} (boolean_algebra.core.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.core.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_76553 (h0 : uniform_space (finset unsigned)) : complete_space (finset unsigned) := sorry --non-trivial
lemma new_lemma_76554 (h0 : functor.add_const (ring (has_add environment.implicit_infer_kind)) pos) : @is_domain.{0} (has_add.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (has_add.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_76555 (h0 : group (has_to_string (finset linarith.comp))) : normalizer_condition (has_to_string (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_76556 (h0 : has_mem.mem (semiring (random_gen num)) has_emptyc.emptyc) : @path_connected_space.{0} (semiring.{0} (random_gen.{0} num)) (@finset.pi.empty.{1 0} Type topological_space.{0} (semiring.{0} (random_gen.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_76557 (h0 : functor.add_const (filter (has_dist num)) ennreal) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_76558 (h0 : cancel_comm_monoid_with_zero (linear_ordered_comm_ring empty)) : unique_factorization_monoid (linear_ordered_comm_ring empty) := sorry --non-trivial
lemma new_lemma_76559 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (finset.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (finset.{0} name))  := sorry --non-trivial
lemma new_lemma_76560 (h0 : functor.add_const (add_group (has_nndist environment.implicit_infer_kind)) linarith.comp) : @is_add_cyclic.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (add_group.{0} (has_nndist.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_76561 (h0 : not (complete_lattice (topological_space char) -> false)) : complete_lattice.is_Sup_finite_compact (topological_space char) := sorry --non-trivial
lemma new_lemma_76562 (h0 : topological_space (complete_linear_order (semiring (semiring (semiring congr_arg_kind))))) : discrete_topology (complete_linear_order (semiring (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_76563 (h0 : complete_lattice (id to_additive.value_type)) : complete_lattice.is_Sup_finite_compact (id to_additive.value_type) := sorry --non-trivial
lemma new_lemma_76564 (h0 : function.extfun Type topological_space) : @t0_space.{0} (add_cancel_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_76565 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_add.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_76566 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (has_top.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_top.{0} empty))  := sorry --non-trivial
lemma new_lemma_76567 (h0 : not (topological_space (linear_ordered_semiring fun_info) -> false)) : @totally_separated_space.{0} (linear_ordered_semiring.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_semiring.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_76568 (h0 : topological_space (has_inner empty (semiring (semiring empty)))) : loc_path_connected_space (has_inner empty (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_76569 (h0 : function.extfun Type (functor.add_const (complete_lattice (left_cancel_monoid empty)))) : @complete_lattice.is_Sup_finite_compact.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (left_cancel_monoid.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (complete_lattice.{0} (left_cancel_monoid.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_76570 (h0 : uniform_space (ordered_comm_ring (has_bot pos))) : complete_space (ordered_comm_ring (has_bot pos)) := sorry --non-trivial
lemma new_lemma_76571 (h0 : topological_space (topological_space (metric_space to_additive.value_type))) : t0_space (topological_space (metric_space to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_76572 (h0 : not (function.extfun Type topological_space -> false)) : @irreducible_space.{0} (with_bot.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (with_bot.{0} empty))  := sorry --non-trivial
lemma new_lemma_76573 (h0 : complete_lattice (semigroup (comm_group (comm_group name)))) : is_atomistic (semigroup (comm_group (comm_group name))) := sorry --non-trivial
lemma new_lemma_76574 (h0 : topological_space (generalized_boolean_algebra (has_add (has_nndist pos)))) : loc_path_connected_space (generalized_boolean_algebra (has_add (has_nndist pos))) := sorry --non-trivial
lemma new_lemma_76575 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (@id.{2} Type fun_info) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (@id.{2} Type fun_info))  := sorry --non-trivial
lemma new_lemma_76576 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_top.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_top.{0} empty))  := sorry --non-trivial
lemma new_lemma_76577 (h0 : functor.add_const (complete_lattice (has_zero linarith.comp)) pos) : @is_atomistic.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_zero.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_76578 (h1 : pfun ereal Prop) (h2 : coe_sort (pfun.dom h1)) : pfun.as_subtype h1 h2 := sorry --non-trivial
lemma new_lemma_76579 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type monoid.{0} h0 (boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_76580 (h0 : functor.add_const (function.extfun (Type 1) topological_space) linarith.comp) : @sequential_space.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) linarith.comp h0) (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_76581 (h0 : not (function.extfun (finset Type) (has_mem.mem (semiring linarith.comp_source)) -> false)) : @t0_space.{0} (semiring.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (semiring.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} linarith.comp_source)) (@classical.by_contradiction'.{0} (function.extfun.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} linarith.comp_source))) h0) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_76582 (h0 : set (has_div (mul_one_class (has_compl (mul_one_class (mul_one_class (mul_one_class char))))))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_76583 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (has_bot.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_bot.{0} name))  := sorry --non-trivial
lemma new_lemma_76584 (h0 : topological_space (random_gen (has_nnnorm linarith.ineq))) : totally_disconnected_space (random_gen (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_76585 (h0 : topological_space (cancel_monoid ennreal)) : locally_compact_space (cancel_monoid ennreal) := sorry --non-trivial
lemma new_lemma_76586 (h0 : topological_space (option unsigned)) : locally_compact_space (option unsigned) := sorry --non-trivial
lemma new_lemma_76587 (h0 : linarith.ineq -> linarith.ineq) (h1 : linarith.ineq) : function.is_fixed_pt h0 h1 := sorry --non-trivial
lemma new_lemma_76588 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (canonically_ordered_comm_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_76589 (h0 : semiring (id (semiring (semiring (semiring (semiring (semiring (semiring unsigned)))))))) : is_noetherian_ring (id (semiring (semiring (semiring (semiring (semiring (semiring unsigned))))))) := sorry --non-trivial
lemma new_lemma_76590 (h0 : add_group (has_Sup to_additive.value_type)) : is_add_cyclic (has_Sup to_additive.value_type) := sorry --non-trivial
lemma new_lemma_76591 (h0 : monoid (ordered_cancel_add_comm_monoid (option (option unsigned)))) : monoid.fg (ordered_cancel_add_comm_monoid (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_76592 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (left_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (left_cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_76593 (h1 : fun_info -> fun_info -> bool) : is_dec_refl h1 := sorry --non-trivial
lemma new_lemma_76594 (h0 : topological_space (complete_distrib_lattice (has_add pos))) : irreducible_space (complete_distrib_lattice (has_add pos)) := sorry --non-trivial
lemma new_lemma_76595 (h0 : topological_space (has_top (has_nnnorm fun_info))) : locally_compact_space (has_top (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_76596 (h0 : function.extfun Type topological_space) : @normal_space.{0} (filter.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (filter.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_76597 (h0 : group (has_zero ennreal)) : is_simple_group (has_zero ennreal) := sorry --non-trivial
lemma new_lemma_76598 (h0 : ring (has_add (finset environment.implicit_infer_kind))) : rank_condition (has_add (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_76599 (h1 : ring (has_norm num)) : is_domain (has_norm num) := sorry --non-trivial
lemma new_lemma_76600 (h0 : functor.add_const (topological_space (has_zero Type)) pos) : @locally_compact_space.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_zero.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_76601 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @is_cyclic.{0} (add_left_cancel_monoid.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) group.{0}) (add_left_cancel_monoid.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_76602 (h0 : complete_lattice (has_one linarith.comp)) : complete_lattice.is_Sup_finite_compact (has_one linarith.comp) := sorry --non-trivial
lemma new_lemma_76603 (h0 : add_group (measurable_space (random_gen (random_gen num)))) : is_add_cyclic (measurable_space (random_gen (random_gen num))) := sorry --non-trivial
lemma new_lemma_76604 (h3 : uniform_space (mul_one_class ereal)) : complete_space (mul_one_class ereal) := sorry --non-trivial
lemma new_lemma_76605 (h0 : denumerable (random_gen string_imp) -> denumerable (random_gen string_imp) -> Prop) : transitive h0 := sorry --non-trivial
lemma new_lemma_76606 (h0 : filter (canonically_ordered_comm_semiring (has_add name))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_76607 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (monoid unsigned)) := sorry --non-trivial
lemma new_lemma_76608 (h0 : functor.add_const (topological_space (normed_comm_ring ennreal)) unsigned) : @t0_space.{0} (normed_comm_ring.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_76609 (h0 : empty) : @is_add_cyclic.{0} (denumerable.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@empty.elim.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) add_group.{0}) (denumerable.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_76610 (h0 : ring (with_bot (semiring (semiring linarith.comp)))) : rank_condition (with_bot (semiring (semiring linarith.comp))) := sorry --non-trivial
lemma new_lemma_76611 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (normed_comm_ring.{0} name) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (normed_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_76612 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (ordered_ring.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ordered_ring.{0} unsigned)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (complete_lattice.{0} (ordered_ring.{0} unsigned))) (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 (functor.add_const.{0 0} (complete_lattice.{0} (ordered_ring.{0} unsigned)))) empty))  := sorry --non-trivial
lemma new_lemma_76613 (h0 : not (topological_space (has_lt char) -> false)) : @t0_space.{0} (has_lt.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (has_lt.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_76614 (h0 : function.extfun Type ring) : @rank_condition.{0} (ordered_comm_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (ordered_comm_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_76615 (h0 : ring (has_pos_part (has_Inf Type))) : is_domain (has_pos_part (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_76616 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (has_zero.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_zero.{0} name))  := sorry --non-trivial
lemma new_lemma_76617 (h0 : not (monoid (non_assoc_semiring empty) -> false)) : @monoid.fg.{0} (non_assoc_semiring.{0} empty) (@classical.by_contradiction'.{1} (monoid.{0} (non_assoc_semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_76618 (h0 : not (add_group (sub_neg_monoid reducibility_hints) -> false)) : @is_add_cyclic.{0} (sub_neg_monoid.{0} reducibility_hints) (@classical.by_contradiction'.{1} (add_group.{0} (sub_neg_monoid.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_76619 (h0 : ring (uniform_space (linear_ordered_field string_imp))) : strong_rank_condition (uniform_space (linear_ordered_field string_imp)) := sorry --non-trivial
lemma new_lemma_76620 (h0 : has_mem.mem group has_emptyc.emptyc) : @normalizer_condition.{0} (linear_ordered_semiring.{0} num) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} h0) (linear_ordered_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_76621 (h0 : topological_space (simple_graph (has_Inf linarith.comp))) : totally_separated_space (simple_graph (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_76622 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @t0_space.{0} (has_emptyc.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_emptyc.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_76623 (h0 : complete_lattice (group_with_zero (option (option num)))) : is_atomistic (group_with_zero (option (option num))) := sorry --non-trivial
lemma new_lemma_76624 (h0 : fin has_zero.zero) : @separated_space.{0} (sub_neg_monoid.{0} pos) (@matrix.vec_empty.{0} (uniform_space.{0} (sub_neg_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_76625 (h0 : topological_space (boolean_algebra (has_pos_part (ring linarith.comp)))) : discrete_topology (boolean_algebra (has_pos_part (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_76626 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_76627 (h0 : uniform_space (random_gen fun_info)) : complete_space (random_gen fun_info) := sorry --non-trivial
lemma new_lemma_76628 (h0 : group (preorder (semiring num))) : normalizer_condition (preorder (semiring num)) := sorry --non-trivial
lemma new_lemma_76629 (h0 : not (ring (linear_ordered_add_comm_group to_additive.value_type) -> false)) : @rank_condition.{0} (linear_ordered_add_comm_group.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (linear_ordered_add_comm_group.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_76630 (h0 : not (topological_space (has_norm congr_arg_kind) -> false)) : @locally_compact_space.{0} (has_norm.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (has_norm.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_76631 (h1 : uniform_space (random_gen to_additive.value_type)) : complete_space (random_gen to_additive.value_type) := sorry --non-trivial
lemma new_lemma_76632 (h0 : list (cancel_monoid pos)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_76633 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_atomistic.{0} (metric_space.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (metric_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_76634 (h0 : function.extfun nat fin) : @is_cyclic.{0} (normed_lattice_add_comm_group.{0} linarith.comp) (@matrix.vec_empty.{0} (group.{0} (normed_lattice_add_comm_group.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_76635 (h0 : complete_lattice (canonically_linear_ordered_monoid name)) : is_compactly_generated (canonically_linear_ordered_monoid name) := sorry --non-trivial
lemma new_lemma_76636 (h0 : list (add_cancel_monoid (has_Inf (boolean_algebra Type)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_76637 (h1 : filter linarith.comp_source) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_76638 (h0 : ring (distrib (has_nnnorm to_additive.value_type))) : strong_rank_condition (distrib (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_76639 (h1 : topological_space (add_comm_semigroup ereal)) (h4 : Prop) : is_path_connected (id (fun (h2 : add_comm_semigroup ereal), h4)) := sorry --non-trivial
lemma new_lemma_76640 (h0 : functor.add_const (topological_space (has_zero environment.implicit_infer_kind)) linarith.comp) : @preirreducible_space.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_76641 (h0 : functor.add_const (topological_space (left_cancel_monoid empty)) congr_arg_kind) : @t0_space.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_76642 (h0 : topological_space (preorder (semiring (semiring empty)))) : locally_compact_space (preorder (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_76643 (h0 : ring (random_gen (has_nnnorm fun_info))) : rank_condition (random_gen (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_76644 (h0 : ring (cancel_monoid (comm_group name))) : is_principal_ideal_ring (cancel_monoid (comm_group name)) := sorry --non-trivial
lemma new_lemma_76645 (h0 : topological_space (comm_semigroup (has_Inf real))) : totally_separated_space (comm_semigroup (has_Inf real)) := sorry --non-trivial
lemma new_lemma_76646 (h0 : topological_space (boolean_algebra pos)) : t1_space (boolean_algebra pos) := sorry --non-trivial
lemma new_lemma_76647 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (has_to_string.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_to_string.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_76648 (h0 : prod (has_neg_part Type) (has_neg_part Type)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_76649 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (is_R_or_C.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (is_R_or_C.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_76650 (h0 : functor.add_const (add_group (normed_comm_ring Type)) (has_neg_part Type)) : @is_add_cyclic.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 1} (add_group.{1} (normed_comm_ring.{1} Type)) (has_neg_part.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_76651 (h0 : uniform_space (has_zero (ring (ring (ring Type))))) : separated_space (has_zero (ring (ring (ring Type)))) := sorry --non-trivial
lemma new_lemma_76652 (h0 : functor.add_const (ring (has_zero ennreal)) name) : @is_principal_ideal_ring.{0} (has_zero.{0} ennreal) (@functor.add_const.run.{0 0} (ring.{0} (has_zero.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_76653 (h0 : functor.add_const (uniform_space (semigroup unsigned)) pos) : @complete_space.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (uniform_space.{0} (semigroup.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_76654 (h0 : complete_lattice (boolean_algebra.core (has_neg name))) : is_compactly_generated (boolean_algebra.core (has_neg name)) := sorry --non-trivial
lemma new_lemma_76655 (h0 : ordered_add_comm_monoid (ordered_comm_ring (ordered_ring Type))) : archimedean (ordered_comm_ring (ordered_ring Type)) := sorry --non-trivial
lemma new_lemma_76656 (h0 : functor.add_const (ordered_add_comm_monoid (normed_comm_ring pos)) environment.implicit_infer_kind) : @archimedean.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (normed_comm_ring.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_76657 (h0 : function.extfun (random_gen string_imp) (fun (x : random_gen string_imp), Prop)) : Exists (function.extfun_app h0) := sorry --non-trivial
lemma new_lemma_76658 (h0 : topological_space (has_emptyc (has_inv (has_top linarith.ineq)))) : path_connected_space (has_emptyc (has_inv (has_top linarith.ineq))) := sorry --non-trivial
lemma new_lemma_76659 (h0 : functor.add_const (group pos) (option (option pos))) : @is_simple_group.{0} pos (@functor.add_const.run.{0 0} (group.{0} pos) (option.{0} (option.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_76660 (h0 : topological_space (has_zero (normed_comm_ring name))) : t1_space (has_zero (normed_comm_ring name)) := sorry --non-trivial
lemma new_lemma_76661 (h0 : function.extfun Type (functor.add_const (topological_space pos))) : @t0_space.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) pos (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} pos)) h0 pos))  := sorry --non-trivial
lemma new_lemma_76662 (h0 : functor.add_const (ring (finset name)) pos) : @is_principal_ideal_ring.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (finset.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_76663 (h0 : add_monoid (normed_comm_ring (option ennreal))) : add_monoid.fg (normed_comm_ring (option ennreal)) := sorry --non-trivial
lemma new_lemma_76664 (h0 : functor.add_const (filter (finset pos)) (finset pos)) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_76665 (h0 : function.extfun (Type 1) topological_space) : @discrete_topology.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_76666 (h0 : functor.add_const (add_monoid (has_neg unsigned)) linarith.comp) : @add_monoid.fg.{0} (has_neg.{0} unsigned) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_neg.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_76667 (h1 : group string_imp) (h2 : complete_lattice (group_topology string_imp)) : is_compactly_generated (group_topology string_imp) := sorry --non-trivial
lemma new_lemma_76668 (h0 : monoid (ordered_ring unsigned)) : monoid.fg (ordered_ring unsigned) := sorry --non-trivial
lemma new_lemma_76669 (h0 : ring (canonically_ordered_monoid (random_gen string_imp))) : is_domain (canonically_ordered_monoid (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_76670 (h0 : finset (has_add num)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_76671 (h0 : topological_space (has_norm linarith.comp)) : preirreducible_space (has_norm linarith.comp) := sorry --non-trivial
lemma new_lemma_76672 (h0 : Type -> Type -> Prop) : is_antisymm Type h0 := sorry --non-trivial
lemma new_lemma_76673 (h0 : cancel_comm_monoid_with_zero (plift (bin_tree unsigned))) : unique_factorization_monoid (plift (bin_tree unsigned)) := sorry --non-trivial
lemma new_lemma_76674 (h0 : topological_space (has_norm (random_gen (random_gen linarith.comp_source)))) : locally_compact_space (has_norm (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_76675 (h0 : topological_space (canonically_linear_ordered_add_monoid num)) : totally_separated_space (canonically_linear_ordered_add_monoid num) := sorry --non-trivial
lemma new_lemma_76676 (h0 : functor.add_const (topological_space (ordered_ring num)) num) : @path_connected_space.{0} (ordered_ring.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_76677 (h0 : fin has_zero.zero) : @preconnected_space.{1} (generalized_boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (generalized_boolean_algebra.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_76678 (h0 : functor.add_const (finset (left_cancel_monoid empty)) (option congr_arg_kind)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_76679 (h0 : list (has_pos_part (has_add pos))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_76680 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_union.{0} (semiring.{0} (semiring.{0} (has_norm.{0} (has_union.{0} empty))))) (@function.extfun_app.{2 1} Type group.{0} h0 (has_union.{0} (semiring.{0} (semiring.{0} (has_norm.{0} (has_union.{0} empty))))))  := sorry --non-trivial
lemma new_lemma_76681 (h0 : ordered_comm_monoid (has_add (has_nndist Type))) : has_exists_mul_of_le (has_add (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_76682 (h0 : functor.add_const (ordered_add_comm_monoid (preorder congr_arg_kind)) unsigned) : @archimedean.{0} (preorder.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (preorder.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_76683 (h1 : topological_space (complete_semilattice_Sup (has_top char))) : t0_space (complete_semilattice_Sup (has_top char)) := sorry --non-trivial
lemma new_lemma_76684 (h1 : ring (topological_space (comm_ring reducibility_hints))) : strong_rank_condition (topological_space (comm_ring reducibility_hints)) := sorry --non-trivial
lemma new_lemma_76685 (h0 : ring (canonically_linear_ordered_monoid (option (option (option unsigned))))) : strong_rank_condition (canonically_linear_ordered_monoid (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_76686 (h0 : list (filter (is_R_or_C (option (option (option unsigned)))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_76687 (h0 : topological_space (add_cancel_monoid (has_to_string Type))) : loc_path_connected_space (add_cancel_monoid (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_76688 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_ssubset.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_ssubset.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_76689 (h0 h1 : multiset (has_lt to_additive.value_type)) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_76690 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (partial_order.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (partial_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_76691 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @irreducible_space.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_76692 (h0 : function.extfun Type topological_space) : loc_path_connected_space real := sorry --non-trivial
lemma new_lemma_76693 (h0 : functor.add_const (topological_space (add_comm_monoid Type)) linarith.comp) : @t1_space.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_comm_monoid.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_76694 (h0 : functor.add_const (topological_space (semigroup Type)) unsigned) : @path_connected_space.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (semigroup.{1} Type)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_76695 (h2 : uniform_space string.iterator_imp) (h3 : add_group (uniform_space.separation_quotient string.iterator_imp)) : is_add_cyclic (uniform_space.separation_quotient string.iterator_imp) := sorry --non-trivial
lemma new_lemma_76696 (h0 : not (topological_space (has_sub num) -> false)) : @preirreducible_space.{0} (has_sub.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (has_sub.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_76697 (h0 : functor.add_const (group (complete_distrib_lattice environment.implicit_infer_kind)) name) : @group.fg.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_76698 (h0 : group (random_gen (has_top num))) : is_cyclic (random_gen (has_top num)) := sorry --non-trivial
lemma new_lemma_76699 (h0 : functor.add_const (topological_space (has_pos_part Type)) (ring pos)) : @preconnected_space.{1} (has_pos_part.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_pos_part.{1} Type)) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_76700 (h0 : ring (has_lt std_gen)) : rank_condition (has_lt std_gen) := sorry --non-trivial
lemma new_lemma_76701 (h0 : not (topological_space (has_top (has_top linarith.comp_source)) -> false)) : @irreducible_space.{0} (has_top.{0} (has_top.{0} linarith.comp_source)) (@classical.by_contradiction'.{1} (topological_space.{0} (has_top.{0} (has_top.{0} linarith.comp_source))) h0)  := sorry --non-trivial
lemma new_lemma_76702 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_nndist.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} empty))  := sorry --non-trivial
lemma new_lemma_76703 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (measurable_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type semiring.{0} h0 (measurable_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_76704 (h0 : ring (has_top num)) : is_domain (has_top num) := sorry --non-trivial
lemma new_lemma_76705 (h0 : functor.add_const (topological_space (has_Inf name)) linarith.comp) : @preirreducible_space.{0} (has_Inf.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_76706 (h0 : function.extfun Type group) : @group.fg.{0} (denumerable.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} h0 (denumerable.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_76707 (h0 : fin has_zero.zero) : @is_atomistic.{0} (comm_semigroup.{0} linarith.comp) (@matrix.vec_empty.{0} (complete_lattice.{0} (comm_semigroup.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_76708 (h0 : topological_space (canonically_ordered_add_monoid unsigned)) : discrete_topology (canonically_ordered_add_monoid unsigned) := sorry --non-trivial
lemma new_lemma_76709 (h1 : ring (semi_normed_comm_ring (metric_space to_additive.value_type))) : is_domain (semi_normed_comm_ring (metric_space to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_76710 (h0 : complete_lattice (left_cancel_monoid (option unsigned))) : complete_lattice.is_Sup_finite_compact (left_cancel_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_76711 (h0 : semiring (finset (option (finset name)))) : is_noetherian_ring (finset (option (finset name))) := sorry --non-trivial
lemma new_lemma_76712 (h0 : function.extfun Type group) : @normalizer_condition.{0} (canonically_ordered_monoid.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (canonically_ordered_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_76713 (h0 : has_mem.mem complete_lattice has_emptyc.emptyc) : @is_compactly_generated.{0} (normed_group.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} h0) (normed_group.{0} num))  := sorry --non-trivial
lemma new_lemma_76714 (h0 : fin has_zero.zero) : @add_monoid.fg.{0} (has_add.{0} real) (@matrix.vec_empty.{0} (add_monoid.{0} (has_add.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_76715 (h0 : topological_space (linear_ordered_comm_monoid_with_zero congr_arg_kind)) : discrete_topology (linear_ordered_comm_monoid_with_zero congr_arg_kind) := sorry --non-trivial
lemma new_lemma_76716 (h0 : ring (normed_group (has_top (normed_group (has_top fun_info))))) : is_domain (normed_group (has_top (normed_group (has_top fun_info)))) := sorry --non-trivial
lemma new_lemma_76717 (h0 : functor.add_const (group (add_cancel_monoid name)) (option name)) : @normalizer_condition.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (group.{0} (add_cancel_monoid.{0} name)) (option.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_76718 (h0 : complete_lattice (has_union (has_top (has_top linarith.comp)))) : complete_lattice.is_Sup_finite_compact (has_union (has_top (has_top linarith.comp))) := sorry --non-trivial
lemma new_lemma_76719 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (left_cancel_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (left_cancel_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_76720 (h0 : uniform_space (ordered_comm_ring pos)) : complete_space (ordered_comm_ring pos) := sorry --non-trivial
lemma new_lemma_76721 (h0 : uniform_space (has_emptyc (has_norm congr_arg_kind))) : complete_space (has_emptyc (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_76722 (h0 : functor.add_const (topological_space (boolean_algebra unsigned)) Type) : @locally_compact_space.{0} (boolean_algebra.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_76723 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (add_left_cancel_semigroup.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_left_cancel_semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_76724 (h1 : complete_lattice (add_comm_semigroup (mul_one_class enat))) : complete_lattice.is_Sup_finite_compact (add_comm_semigroup (mul_one_class enat)) := sorry --non-trivial
lemma new_lemma_76725 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (has_pos_part.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_pos_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_76726 (h0 : functor.add_const (topological_space (add_comm_monoid pos)) pos) : @preconnected_space.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_76727 (h0 : functor.add_const (topological_space (simple_graph linarith.comp)) (has_add linarith.comp)) : @totally_disconnected_space.{0} (simple_graph.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (simple_graph.{0} linarith.comp)) (has_add.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_76728 (h0 : topological_space (boolean_algebra real)) : t0_space (boolean_algebra real) := sorry --non-trivial
lemma new_lemma_76729 (h0 : topological_space (has_top (has_top linarith.comp))) : preirreducible_space (has_top (has_top linarith.comp)) := sorry --non-trivial
lemma new_lemma_76730 (h0 : complete_lattice (cancel_monoid unsigned)) : is_atomistic (cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_76731 (h0 : functor.add_const (cancel_comm_monoid_with_zero (boolean_algebra unsigned)) Type) : @unique_factorization_monoid.{0} (boolean_algebra.{0} unsigned) (@functor.add_const.run.{0 1} (cancel_comm_monoid_with_zero.{0} (boolean_algebra.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_76732 (h0 h1 : multiset (has_le char)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_76733 (h0 : ring (with_bot (semiring fun_info))) : rank_condition (with_bot (semiring fun_info)) := sorry --non-trivial
lemma new_lemma_76734 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_zero.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_76735 (h0 : topological_space (complete_linear_order num)) : t1_space (complete_linear_order num) := sorry --non-trivial
lemma new_lemma_76736 (h0 : monoid (semigroup pos)) : monoid.fg (semigroup pos) := sorry --non-trivial
lemma new_lemma_76737 (h0 : complete_lattice (add_comm_semigroup enat)) : complete_lattice.is_Sup_finite_compact (add_comm_semigroup enat) := sorry --non-trivial
lemma new_lemma_76738 (h1 : group (id (with_bot string_imp))) : is_cyclic (id (with_bot string_imp)) := sorry --non-trivial
lemma new_lemma_76739 (h0 : functor.comp ring has_to_string name) : @strong_rank_condition.{0} (has_to_string.{0} name) (@functor.comp.run.{0 0 0} ring.{0} has_to_string.{0} name h0)  := sorry --non-trivial
lemma new_lemma_76740 (h0 : not (topological_space (with_one congr_arg_kind) -> false)) : @totally_separated_space.{0} (with_one.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (with_one.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_76741 (h0 : uniform_space (with_zero char)) : complete_space (with_zero char) := sorry --non-trivial
lemma new_lemma_76742 (h0 : uniform_space (semi_normed_comm_ring (has_ssubset reducibility_hints))) : complete_space (semi_normed_comm_ring (has_ssubset reducibility_hints)) := sorry --non-trivial
lemma new_lemma_76743 (h0 : functor.add_const (topological_space (has_neg_part unsigned)) Type) : @preconnected_space.{0} (has_neg_part.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg_part.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_76744 (h0 : complete_lattice (add_comm_monoid pos)) : is_compactly_generated (add_comm_monoid pos) := sorry --non-trivial
lemma new_lemma_76745 (h0 : complete_lattice (add_cancel_monoid (has_add unsigned))) : is_compactly_generated (add_cancel_monoid (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_76746 (h0 : complete_lattice (has_norm (has_ssubset fun_info))) : complete_lattice.is_Sup_finite_compact (has_norm (has_ssubset fun_info)) := sorry --non-trivial
lemma new_lemma_76747 (h0 : topological_space (complete_distrib_lattice (has_nndist (has_nndist pos)))) : preirreducible_space (complete_distrib_lattice (has_nndist (has_nndist pos))) := sorry --non-trivial
lemma new_lemma_76748 (h0 : topological_space (has_inter (comm_monoid (option (option (option (option empty))))))) : normal_space (has_inter (comm_monoid (option (option (option (option empty)))))) := sorry --non-trivial
lemma new_lemma_76749 (h0 : group (has_top linarith.comp_source)) : is_cyclic (has_top linarith.comp_source) := sorry --non-trivial
lemma new_lemma_76750 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} (canonically_ordered_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) (canonically_ordered_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_76751 (h1 : not (ring (add_cancel_comm_monoid char) -> false)) : @is_domain.{0} (add_cancel_comm_monoid.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (add_cancel_comm_monoid.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_76752 (h0 : add_group (normed_group (semiring congr_arg_kind))) : is_add_cyclic (normed_group (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_76753 (h0 : topological_space (preorder unsigned)) : totally_separated_space (preorder unsigned) := sorry --non-trivial
lemma new_lemma_76754 (h0 : function.extfun (finset Type) (has_mem.mem (normed_group num))) : @irreducible_space.{0} (normed_group.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (normed_group.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (normed_group.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_76755 (h0 : ordered_comm_monoid (has_add unsigned)) : has_exists_mul_of_le (has_add unsigned) := sorry --non-trivial
lemma new_lemma_76756 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (has_neg name)) := sorry --non-trivial
lemma new_lemma_76757 (h0 : not (function.extfun Type monoid -> false)) : @monoid.fg.{0} (random_gen.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type monoid.{0}) h0) (random_gen.{0} empty))  := sorry --non-trivial
lemma new_lemma_76758 (h0 : functor.add_const (uniform_space (has_zero pos)) linarith.comp) : @complete_space.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_zero.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_76759 (h0 : functor.add_const (function.extfun Type add_group) Type) : @is_add_cyclic.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type add_group.{0}) Type h0) (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_76760 (h0 : group (has_ssubset (has_nnnorm (has_nnnorm to_additive.value_type)))) : group.fg (has_ssubset (has_nnnorm (has_nnnorm to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_76761 (h0 : finset (canonically_ordered_comm_semiring num)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_76762 (h0 : complete_lattice (uniform_space (mul_one_class string_imp))) : is_compactly_generated (uniform_space (mul_one_class string_imp)) := sorry --non-trivial
lemma new_lemma_76763 (h1 : add_group (has_norm (has_norm fun_info))) : is_add_cyclic (has_norm (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_76764 (h0 : char -> string.iterator_imp -> string.iterator_imp) (h1 : string.iterator_imp -> string.iterator_imp -> Prop) : contravariant char string.iterator_imp h0 h1 := sorry --non-trivial
lemma new_lemma_76765 (h1 : has_lt string.iterator) : no_max_order string.iterator := sorry --non-trivial
lemma new_lemma_76766 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (measurable_space.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (measurable_space.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_76767 (h0 : topological_space (ring (has_to_string (has_to_string unsigned)))) : irreducible_space (ring (has_to_string (has_to_string unsigned))) := sorry --non-trivial
lemma new_lemma_76768 (h0 : complete_lattice (has_emptyc (random_gen fun_info))) : complete_lattice.is_Sup_finite_compact (has_emptyc (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_76769 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_neg.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_76770 (h0 : complete_lattice (normed_group linarith.comp)) : is_atomistic (normed_group linarith.comp) := sorry --non-trivial
lemma new_lemma_76771 (h0 : ring (has_nndist (has_add name))) : strong_rank_condition (has_nndist (has_add name)) := sorry --non-trivial
lemma new_lemma_76772 (h0 : semiring (normed_comm_ring (has_add Type))) : is_noetherian_ring (normed_comm_ring (has_add Type)) := sorry --non-trivial
lemma new_lemma_76773 (h0 : functor.add_const (topological_space nnreal) num) : t1_space nnreal := sorry --non-trivial
lemma new_lemma_76774 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (with_bot.{0} (random_gen.{0} fun_info)) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (with_bot.{0} (random_gen.{0} fun_info)))  := sorry --non-trivial
lemma new_lemma_76775 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_76776 (h0 : topological_space (ring (has_neg name))) : t0_space (ring (has_neg name)) := sorry --non-trivial
lemma new_lemma_76777 (h0 : functor.add_const (topological_space (has_pos_part real)) (sub_neg_monoid (ordered_comm_monoid Type))) : @preirreducible_space.{0} (has_pos_part.{0} real) (@functor.add_const.run.{0 1} (topological_space.{0} (has_pos_part.{0} real)) (sub_neg_monoid.{1} (ordered_comm_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_76778 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (has_one congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_76779 (h0 : topological_space (ring (has_Inf Type))) : totally_separated_space (ring (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_76780 (h0 : function.extfun Type (functor.comp filter semigroup)) : countable_Inter_filter (functor.comp.run (function.extfun_app h0 pos)) := sorry --non-trivial
lemma new_lemma_76781 (h0 : functor.add_const (topological_space (comm_group environment.implicit_infer_kind)) pos) : @loc_path_connected_space.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_76782 (h0 : add_group (non_unital_non_assoc_semiring (mul_one_class linarith.ineq))) : is_add_cyclic (non_unital_non_assoc_semiring (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_76783 (h0 : functor.add_const (topological_space (normed_group empty)) num) : @normal_space.{0} (normed_group.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_group.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_76784 (h1 : topological_space (semi_normed_comm_ring linarith.ineq)) : path_connected_space (semi_normed_comm_ring linarith.ineq) := sorry --non-trivial
lemma new_lemma_76785 (h0 : uniform_space (semigroup empty)) : complete_space (semigroup empty) := sorry --non-trivial
lemma new_lemma_76786 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @sequential_space.{0} (has_zero.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_zero.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_76787 (h0 : topological_space (has_Sup (add_cancel_monoid unsigned))) : t1_space (has_Sup (add_cancel_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_76788 (h0 : list (complete_distrib_lattice (finset name))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_76789 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (canonically_linear_ordered_monoid num)) := sorry --non-trivial
lemma new_lemma_76790 (h0 : list (with_bot (has_top linarith.ineq))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_76791 (h0 : ring (distrib_lattice (random_gen (has_nnnorm fun_info)))) : is_domain (distrib_lattice (random_gen (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_76792 (h0 : topological_space environment.implicit_infer_kind) : discrete_topology environment.implicit_infer_kind := sorry --non-trivial
lemma new_lemma_76793 (h0 : topological_space (metric_space empty)) : t1_space (metric_space empty) := sorry --non-trivial
lemma new_lemma_76794 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_76795 (h0 : topological_space (has_compl (mul_one_class enat))) : path_connected_space (has_compl (mul_one_class enat)) := sorry --non-trivial
lemma new_lemma_76796 (h0 : not (topological_space (normed_group congr_arg_kind) -> false)) : @path_connected_space.{0} (normed_group.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_group.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_76797 (h0 : has_add (has_add (option ennreal)) -> has_add (has_add (option ennreal)) -> Prop) : is_symm (has_add (has_add (option ennreal))) h0 := sorry --non-trivial
lemma new_lemma_76798 (h0 : topological_space (comm_group (finset (option (option (has_add (has_add pos))))))) : t0_space (comm_group (finset (option (option (has_add (has_add pos)))))) := sorry --non-trivial
lemma new_lemma_76799 (h0 : topological_space (ring (add_comm_monoid pos))) : sequential_space (ring (add_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_76800 (h0 : function.extfun Type (functor.add_const (uniform_space (filter empty)))) : @separated_space.{0} (filter.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (filter.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (uniform_space.{0} (filter.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_76801 (h0 : topological_space (has_pos_part (has_pos_part (has_add Type)))) : totally_separated_space (has_pos_part (has_pos_part (has_add Type))) := sorry --non-trivial
lemma new_lemma_76802 (h0 : cancel_comm_monoid_with_zero (complete_distrib_lattice (has_add linarith.comp))) : unique_factorization_monoid (complete_distrib_lattice (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_76803 (h1 : not (topological_space (has_norm to_additive.value_type) -> false)) : @totally_disconnected_space.{0} (has_norm.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (has_norm.{0} to_additive.value_type)) h1)  := sorry --non-trivial
lemma new_lemma_76804 (h0 : functor.add_const (function.extfun Type filter) linarith.comp) : filter.ne_bot (function.extfun_app (functor.add_const.run h0) (semigroup pos)) := sorry --non-trivial
lemma new_lemma_76805 (h0 : functor.add_const (topological_space name) num) : @t0_space.{0} name (@functor.add_const.run.{0 0} (topological_space.{0} name) num h0)  := sorry --non-trivial
lemma new_lemma_76806 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_76807 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : archimedean nnreal := sorry --non-trivial
lemma new_lemma_76808 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (has_nndist.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_nndist.{0} name))  := sorry --non-trivial
lemma new_lemma_76809 (h0 : group (has_to_string linarith.comp)) : is_simple_group (has_to_string linarith.comp) := sorry --non-trivial
lemma new_lemma_76810 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_76811 (h0 : topological_space (ordered_comm_monoid (has_add (boolean_algebra.core linarith.comp)))) : totally_disconnected_space (ordered_comm_monoid (has_add (boolean_algebra.core linarith.comp))) := sorry --non-trivial
lemma new_lemma_76812 (h0 : topological_space (has_to_string (finset linarith.comp))) : regular_space (has_to_string (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_76813 (h0 : function.extfun Type topological_space) (h1 : functor.add_const (measurable_space (ordered_ring unsigned)) unsigned) : @opens_measurable_space.{0} (ordered_ring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_ring.{0} unsigned)) (@functor.add_const.run.{0 0} (measurable_space.{0} (ordered_ring.{0} unsigned)) unsigned h1)  := sorry --non-trivial
lemma new_lemma_76814 (h1 : ring (distrib_lattice (add_monoid string_imp))) : strong_rank_condition (distrib_lattice (add_monoid string_imp)) := sorry --non-trivial
lemma new_lemma_76815 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (has_to_string.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_to_string.{0} empty))  := sorry --non-trivial
lemma new_lemma_76816 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (generalized_boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type monoid.{0} h0 (generalized_boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_76817 (h0 : fin has_zero.zero) : @strong_rank_condition.{1} (has_Inf.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (has_Inf.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_76818 (h0 : ring (has_pos_part (has_nndist linarith.comp))) : strong_rank_condition (has_pos_part (has_nndist linarith.comp)) := sorry --non-trivial
lemma new_lemma_76819 (h0 : topological_space (measurable_space.dynkin_system (semiring num))) : irreducible_space (measurable_space.dynkin_system (semiring num)) := sorry --non-trivial
lemma new_lemma_76820 (h0 : ordered_add_comm_monoid (has_zero (has_neg_part (has_neg_part Type)))) : archimedean (has_zero (has_neg_part (has_neg_part Type))) := sorry --non-trivial
lemma new_lemma_76821 (h0 : add_group (ring (option pos))) : is_add_cyclic (ring (option pos)) := sorry --non-trivial
lemma new_lemma_76822 (h0 : topological_space (has_bot (option empty))) : totally_separated_space (has_bot (option empty)) := sorry --non-trivial
lemma new_lemma_76823 (h0 : topological_space (has_union (has_union linarith.comp))) : t0_space (has_union (has_union linarith.comp)) := sorry --non-trivial
lemma new_lemma_76824 (h1 : ring (id (has_top fun_info))) : rank_condition (id (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_76825 (h1 : complete_lattice (linear_ordered_add_comm_group to_additive.value_type)) : complete_lattice.is_Sup_finite_compact (linear_ordered_add_comm_group to_additive.value_type) := sorry --non-trivial
lemma new_lemma_76826 (h0 : ring (ordered_cancel_add_comm_monoid empty)) : strong_rank_condition (ordered_cancel_add_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_76827 (h0 : fin has_zero.zero) : @is_noetherian_ring.{1} (complete_distrib_lattice.{1} Type) (@matrix.vec_empty.{1} (semiring.{1} (complete_distrib_lattice.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_76828 (h0 : not (monoid (random_gen empty) -> false)) : @monoid.fg.{0} (random_gen.{0} empty) (@classical.by_contradiction'.{1} (monoid.{0} (random_gen.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_76829 (h0 : functor.add_const (ring (boolean_algebra.core Type)) (has_neg pos)) : @is_principal_ideal_ring.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (boolean_algebra.core.{1} Type)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_76830 (h0 : ring (canonically_ordered_add_monoid (option (option (option empty))))) : is_domain (canonically_ordered_add_monoid (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_76831 (h0 : semiring string.iterator_imp) (h1 h2 : nat) (h3 : thunk (ideal string.iterator_imp)) : ideal.is_prime (scope_trace h3) := sorry --non-trivial
lemma new_lemma_76832 (h0 : function.extfun Type ring) : @is_domain.{0} (has_append.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_append.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_76833 (h0 : topological_space (canonically_linear_ordered_monoid (has_Inf real))) : path_connected_space (canonically_linear_ordered_monoid (has_Inf real)) := sorry --non-trivial
lemma new_lemma_76834 (h0 : topological_space (has_ssubset (add_comm_semigroup fun_info))) : totally_disconnected_space (has_ssubset (add_comm_semigroup fun_info)) := sorry --non-trivial
lemma new_lemma_76835 (h0 : topological_space (id (has_top (has_top linarith.ineq)))) : locally_compact_space (id (has_top (has_top linarith.ineq))) := sorry --non-trivial
lemma new_lemma_76836 (h0 : group (comm_group (ring environment.implicit_infer_kind))) : normalizer_condition (comm_group (ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_76837 (h0 : not (complete_lattice (complete_semilattice_Sup linarith.ineq) -> false)) : @is_compactly_generated.{0} (complete_semilattice_Sup.{0} linarith.ineq) (@classical.by_contradiction'.{1} (complete_lattice.{0} (complete_semilattice_Sup.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_76838 (h0 : has_mem.mem (random_gen empty) has_emptyc.emptyc) : @group.fg.{0} (random_gen.{0} empty) (@finset.pi.empty.{1 0} Type group.{0} (random_gen.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_76839 (h0 : functor.add_const (topological_space (normed_linear_ordered_group num)) unsigned) : @topological_space.separable_space.{0} (normed_linear_ordered_group.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_linear_ordered_group.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_76840 (h2 : ring (nondiscrete_normed_field char)) : is_domain (nondiscrete_normed_field char) := sorry --non-trivial
lemma new_lemma_76841 (h0 : topological_space (normed_group (comm_ring to_additive.value_type))) : path_connected_space (normed_group (comm_ring to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_76842 (h0 : option (add_monoid (semiring unsigned))) (h1 : not (add_monoid (semiring unsigned) -> false)) : @add_monoid.fg.{0} (semiring.{0} unsigned) (@option.get_or_else.{0} (add_monoid.{0} (semiring.{0} unsigned)) h0 (@classical.by_contradiction'.{1} (add_monoid.{0} (semiring.{0} unsigned)) h1))  := sorry --non-trivial
lemma new_lemma_76843 (h0 : functor.add_const (add_group (semigroup pos)) pos) : @is_add_cyclic.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (semigroup.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_76844 (h0 : topological_space (complete_distrib_lattice (has_add Type))) : loc_path_connected_space (complete_distrib_lattice (has_add Type)) := sorry --non-trivial
lemma new_lemma_76845 (h0 : ring auto.case_option) : is_principal_ideal_ring auto.case_option := sorry --non-trivial
lemma new_lemma_76846 (h0 : functor.add_const (function.extfun Type topological_space) name) : @preirreducible_space.{0} (semigroup.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_76847 (h0 : topological_space (has_ssubset (has_nnnorm (has_nnnorm (has_nnnorm linarith.ineq))))) : path_connected_space (has_ssubset (has_nnnorm (has_nnnorm (has_nnnorm linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_76848 (h0 : topological_space (complete_distrib_lattice (option unsigned))) : loc_path_connected_space (complete_distrib_lattice (option unsigned)) := sorry --non-trivial
lemma new_lemma_76849 (h0 : has_lt (mul_one_class reducibility_hints)) : no_max_order (mul_one_class reducibility_hints) := sorry --non-trivial
lemma new_lemma_76850 (h0 : functor.add_const (add_group (boolean_algebra name)) unsigned) : @is_add_cyclic.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (add_group.{0} (boolean_algebra.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_76851 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_atomistic.{0} (partial_order.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (partial_order.{0} num))  := sorry --non-trivial
lemma new_lemma_76852 (h0 : filter (has_one (semiring unsigned))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_76853 (h0 : functor.add_const (group (canonically_ordered_comm_semiring linarith.comp)) pos) : @is_cyclic.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (canonically_ordered_comm_semiring.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_76854 (h0 : monoid (ring (finset (has_neg Type)))) : monoid.fg (ring (finset (has_neg Type))) := sorry --non-trivial
lemma new_lemma_76855 (h0 : ring (semiring (add_group (has_union congr_arg_kind)))) : is_domain (semiring (add_group (has_union congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_76856 (h0 : ring fun_info) (h1 : function.extfun Type group) : @is_cyclic.{0} (@subring.{0} fun_info h0) (@function.extfun_app.{2 1} Type group.{0} h1 (@subring.{0} fun_info h0))  := sorry --non-trivial
lemma new_lemma_76857 (h1 : function.extfun Type group) : @is_cyclic.{0} (has_norm.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} h1 (has_norm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_76858 (h0 : function.extfun nat fin) : @preirreducible_space.{0} (canonically_linear_ordered_monoid.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (canonically_linear_ordered_monoid.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_76859 (h0 : topological_space (plift (option (has_norm unsigned)))) : discrete_topology (plift (option (has_norm unsigned))) := sorry --non-trivial
lemma new_lemma_76860 (h0 : functor.add_const (ordered_comm_monoid (normed_comm_ring pos)) pos) : @has_exists_mul_of_le.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (normed_comm_ring.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_76861 (h0 : complete_lattice (has_pos_part (has_neg pos))) : is_compactly_generated (has_pos_part (has_neg pos)) := sorry --non-trivial
lemma new_lemma_76862 (h0 : topological_space (ordered_comm_ring (has_add linarith.comp))) : preconnected_space (ordered_comm_ring (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_76863 (h0 : functor.add_const (ring (semiring unsigned)) congr_arg_kind) : @is_domain.{0} (semiring.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (semiring.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_76864 (h0 : topological_space (sub_neg_monoid (has_neg real))) : topological_space.separable_space (sub_neg_monoid (has_neg real)) := sorry --non-trivial
lemma new_lemma_76865 (h0 : not (ring (fintype linarith.ineq) -> false)) : @is_domain.{0} (fintype.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (fintype.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_76866 (h0 : uniform_space (mul_zero_class pos)) : complete_space (mul_zero_class pos) := sorry --non-trivial
lemma new_lemma_76867 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (ordered_comm_ring.{0} name) (@function.extfun_app.{2 1} Type monoid.{0} h0 (ordered_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_76868 (h0 : functor.add_const (ordered_add_comm_monoid (has_add linarith.comp)) (finset environment.implicit_infer_kind)) : @archimedean.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_add.{0} linarith.comp)) (finset.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_76869 (h0 : complete_lattice (has_neg_part (has_add (has_add linarith.comp)))) : is_atomistic (has_neg_part (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_76870 (h0 : list (normed_group string_imp)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_76871 (h1 : not (topological_space (random_gen (semi_normed_ring char)) -> false)) : @totally_disconnected_space.{0} (random_gen.{0} (semi_normed_ring.{0} char)) (@classical.by_contradiction'.{1} (topological_space.{0} (random_gen.{0} (semi_normed_ring.{0} char))) h1)  := sorry --non-trivial
lemma new_lemma_76872 (h0 : not (ring (semi_normed_ring enat) -> false)) : @rank_condition.{0} (semi_normed_ring.{0} enat) (@classical.by_contradiction'.{1} (ring.{0} (semi_normed_ring.{0} enat)) h0)  := sorry --non-trivial
lemma new_lemma_76873 (h0 : complete_lattice (has_dist empty)) : is_compactly_generated (has_dist empty) := sorry --non-trivial
lemma new_lemma_76874 (h0 : list (boolean_algebra.core (mul_zero_class name))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_76875 (h0 : functor.add_const (semiring (boolean_algebra linarith.comp)) pos) : @is_noetherian_ring.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (semiring.{0} (boolean_algebra.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_76876 (h0 : functor.add_const (complete_lattice (finset Type)) (has_neg Type)) : @is_atomistic.{1} (finset.{1} Type) (@functor.add_const.run.{1 1} (complete_lattice.{1} (finset.{1} Type)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_76877 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (has_union.{0} (semiring.{0} congr_arg_kind)) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_union.{0} (semiring.{0} congr_arg_kind)))  := sorry --non-trivial
lemma new_lemma_76878 (h0 : function.extfun (Type 1) topological_space) : @totally_disconnected_space.{1} (canonically_ordered_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (canonically_ordered_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_76879 (h0 : complete_lattice (has_pos_part (finset (ring name)))) : complete_lattice.is_Sup_finite_compact (has_pos_part (finset (ring name))) := sorry --non-trivial
lemma new_lemma_76880 (h0 : uniform_space (pseudo_metric_space (option num))) : separated_space (pseudo_metric_space (option num)) := sorry --non-trivial
lemma new_lemma_76881 (h0 : functor.add_const (cancel_comm_monoid_with_zero (boolean_algebra.core name)) (has_add pos)) : @unique_factorization_monoid.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (boolean_algebra.core.{0} name)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_76882 (h0 : add_group (has_zero (finset Type))) : is_add_cyclic (has_zero (finset Type)) := sorry --non-trivial
lemma new_lemma_76883 (h0 : topological_space (boolean_algebra (sub_neg_monoid real))) : t1_space (boolean_algebra (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_76884 (h0 : functor.add_const (topological_space (option unsigned)) num) : @discrete_topology.{0} (option.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_76885 (h0 : function.extfun Type ring) : @rank_condition.{0} (add_right_cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_right_cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_76886 (h1 : function.extfun Type ring) : @strong_rank_condition.{0} (has_top.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} h1 (has_top.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_76887 (h0 : functor.add_const (topological_space (add_cancel_monoid pos)) (has_Inf Type)) : @locally_compact_space.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (add_cancel_monoid.{0} pos)) (has_Inf.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_76888 (h0 : functor.add_const (finset (semigroup pos)) (finset linarith.comp)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_76889 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (canonically_ordered_comm_semiring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_ordered_comm_semiring.{0} pos))  := sorry --non-trivial
lemma new_lemma_76890 (h0 : add_group (has_bot (has_Inf (has_Inf real)))) : is_add_cyclic (has_bot (has_Inf (has_Inf real))) := sorry --non-trivial
lemma new_lemma_76891 (h0 h1 : multiset (add_comm_semigroup environment.projection_info)) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_76892 (h0 : functor.add_const (ordered_add_comm_monoid (boolean_algebra linarith.comp)) pos) : @archimedean.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (boolean_algebra.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_76893 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (normed_group.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (normed_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_76894 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_76895 (h0 : not (complete_lattice (normed_field char) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (normed_field.{0} char) (@classical.by_contradiction'.{1} (complete_lattice.{0} (normed_field.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_76896 (h0 : add_group (complete_distrib_lattice (has_pos_part linarith.comp))) : is_add_cyclic (complete_distrib_lattice (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_76897 (h0 : not (topological_space (has_union empty) -> false)) : @totally_separated_space.{0} (has_union.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (has_union.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_76898 (h0 : functor.comp ring cancel_monoid pos) : @rank_condition.{0} (cancel_monoid.{0} pos) (@functor.comp.run.{0 0 0} ring.{0} cancel_monoid.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_76899 (h0 : group (has_Inf (has_neg (has_neg (has_neg Type))))) : is_cyclic (has_Inf (has_neg (has_neg (has_neg Type)))) := sorry --non-trivial
lemma new_lemma_76900 (h0 : functor.add_const (topological_space (semigroup name)) name) : @loc_path_connected_space.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_76901 (h0 : filter (monoid_with_zero (option pos))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_76902 (h0 : functor.add_const (topological_space (has_to_string environment.implicit_infer_kind)) Type) : @topological_space.separable_space.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (has_to_string.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_76903 (h0 : not (has_mem.mem (measurable_space congr_arg_kind) has_emptyc.emptyc -> false)) : @is_add_cyclic.{0} (measurable_space.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type add_group.{0} (measurable_space.{0} congr_arg_kind) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (measurable_space.{0} congr_arg_kind) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_76904 (h0 : topological_space (ring (has_add (has_add (boolean_algebra (has_add name)))))) : topological_space.separable_space (ring (has_add (has_add (boolean_algebra (has_add name))))) := sorry --non-trivial
lemma new_lemma_76905 (h0 : has_le (add_comm_semigroup std_gen)) (h1 : add_comm_semigroup std_gen) : is_bot h1 := sorry --non-trivial
lemma new_lemma_76906 (h0 : filter (with_one fun_info)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_76907 (h0 : has_le (has_emptyc linarith.comp)) (h1 : function.extfun Type has_emptyc) : is_max (function.extfun_app h1 linarith.comp) := sorry --non-trivial
lemma new_lemma_76908 (h0 : ereal -> ereal -> Prop) : total h0 := sorry --non-trivial
lemma new_lemma_76909 (h0 : function.extfun Type group) : @is_cyclic.{0} (cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_76910 (h1 : complete_lattice (random_gen (uniform_space (has_lt (random_gen reducibility_hints))))) : is_compactly_generated (random_gen (uniform_space (has_lt (random_gen reducibility_hints)))) := sorry --non-trivial
lemma new_lemma_76911 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @regular_space.{0} (has_neg_part.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} pos)) pos (@functor.comp.run.{0 0 0} topological_space.{0} has_neg_part.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} has_neg_part.{0}) (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 (functor.comp.{0 0 0} topological_space.{0} has_neg_part.{0})) pos)))  := sorry --non-trivial
lemma new_lemma_76912 (h0 : cancel_comm_monoid_with_zero (complete_distrib_lattice real)) : unique_factorization_monoid (complete_distrib_lattice real) := sorry --non-trivial
lemma new_lemma_76913 (h0 : complete_lattice (finset (finset pos))) : complete_lattice.is_Sup_finite_compact (finset (finset pos)) := sorry --non-trivial
lemma new_lemma_76914 (h0 : functor.add_const (group (has_add pos)) Type) : @normalizer_condition.{0} (has_add.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (has_add.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_76915 (h0 : topological_space (id (semiring (has_top to_additive.value_type)))) : totally_disconnected_space (id (semiring (has_top to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_76916 (h0 : functor.add_const (topological_space (comm_group unsigned)) Type) : @loc_path_connected_space.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (comm_group.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_76917 (h0 : ring (is_R_or_C (add_comm_semigroup char))) : strong_rank_condition (is_R_or_C (add_comm_semigroup char)) := sorry --non-trivial
lemma new_lemma_76918 (h0 : add_group (with_bot (semiring (semiring (semiring unsigned))))) : is_add_cyclic (with_bot (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_76919 (h0 : topological_space (has_pos_part linarith.comp)) : regular_space (has_pos_part linarith.comp) := sorry --non-trivial
lemma new_lemma_76920 (h0 : not (has_mem.mem (has_top linarith.comp_source) has_emptyc.emptyc -> false)) : @monoid.fg.{0} (has_top.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type monoid.{0} (has_top.{0} linarith.comp_source) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_top.{0} linarith.comp_source) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_76921 (h0 : function.extfun Type group) : @group.fg.{0} (complete_linear_order.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (complete_linear_order.{0} num))  := sorry --non-trivial
lemma new_lemma_76922 (h0 : add_group (semigroup (finset (finset environment.implicit_infer_kind)))) : is_add_cyclic (semigroup (finset (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_76923 (h0 : function.extfun nat fin) : @separated_space.{0} (generalized_boolean_algebra.{0} name) (@matrix.vec_empty.{0} (uniform_space.{0} (generalized_boolean_algebra.{0} name)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_76924 (h0 : measurable_space (mul_one_class (add_comm_semigroup enat))) (h1 : has_mul (mul_one_class (add_comm_semigroup enat))) : has_measurable_mul₂ (mul_one_class (add_comm_semigroup enat)) := sorry --non-trivial
lemma new_lemma_76925 (h0 : topological_space (has_neg_part (has_to_string (finset unsigned)))) : discrete_topology (has_neg_part (has_to_string (finset unsigned))) := sorry --non-trivial
lemma new_lemma_76926 (h0 : function.extfun nat fin) : @path_connected_space.{0} (simple_graph.{0} (has_neg.{0} name)) (@matrix.vec_empty.{0} (topological_space.{0} (simple_graph.{0} (has_neg.{0} name))) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_76927 (h0 : functor.add_const (uniform_space nnreal) (semiring (semiring (semiring empty)))) : separated_space nnreal := sorry --non-trivial
lemma new_lemma_76928 (h0 : has_mem.mem (with_one empty) has_emptyc.emptyc) : @t0_space.{0} (with_one.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_one.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_76929 (h0 : monoid (metric_space (semiring (semiring (semiring congr_arg_kind))))) : monoid.fg (metric_space (semiring (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_76930 (h0 : not (add_group (has_star num) -> false)) : @is_add_cyclic.{0} (has_star.{0} num) (@classical.by_contradiction'.{1} (add_group.{0} (has_star.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_76931 (h0 : complete_lattice (normed_group linarith.comp_source)) : is_atomistic (normed_group linarith.comp_source) := sorry --non-trivial
lemma new_lemma_76932 (h1 : complete_lattice (semi_normed_ring reducibility_hints)) : is_compactly_generated (semi_normed_ring reducibility_hints) := sorry --non-trivial
lemma new_lemma_76933 (h2 : measurable_space environment.projection_info) (h3 : measure_theory.measure environment.projection_info) : measure_theory.is_finite_measure h3 := sorry --non-trivial
lemma new_lemma_76934 (h0 : fin has_zero.zero) : @is_simple_group.{1} (has_bot.{1} Type) (@matrix.vec_empty.{1} (group.{1} (has_bot.{1} Type)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))))  := sorry --non-trivial
lemma new_lemma_76935 (h0 : add_group (div_inv_monoid (has_nnnorm fun_info))) : is_add_cyclic (div_inv_monoid (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_76936 (h0 : ring (has_inv (has_nnnorm string_imp))) : strong_rank_condition (has_inv (has_nnnorm string_imp)) := sorry --non-trivial
lemma new_lemma_76937 (h0 : topological_space (has_bot (has_neg name))) : topological_space.separable_space (has_bot (has_neg name)) := sorry --non-trivial
lemma new_lemma_76938 (h0 : group (has_top unsigned)) : normalizer_condition (has_top unsigned) := sorry --non-trivial
lemma new_lemma_76939 (h0 : not (topological_space (measure_theory.measure_space unsigned) -> false)) : @topological_space.separable_space.{0} (measure_theory.measure_space.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (measure_theory.measure_space.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_76940 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (free_add_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (free_add_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_76941 (h0 : functor.add_const (complete_lattice (boolean_algebra.core environment.implicit_infer_kind)) name) : @is_atomistic.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_76942 (h0 : topological_space (measure_theory.measure_space (semiring congr_arg_kind))) : topological_space.separable_space (measure_theory.measure_space (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_76943 (h0 : topological_space (random_gen (semiring empty))) : discrete_topology (random_gen (semiring empty)) := sorry --non-trivial
lemma new_lemma_76944 (h0 : add_group (has_compl (mul_one_class (mul_one_class enat)))) : is_add_cyclic (has_compl (mul_one_class (mul_one_class enat))) := sorry --non-trivial
lemma new_lemma_76945 (h0 : topological_space (has_zero num)) : sequential_space (has_zero num) := sorry --non-trivial
lemma new_lemma_76946 (h1 : ring (distrib (mul_one_class char))) : is_domain (distrib (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_76947 (h0 : functor.add_const (uniform_space (semigroup name)) name) : @complete_space.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (semigroup.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_76948 (h0 : functor.add_const (topological_space (add_cancel_monoid Type)) linarith.comp) : @path_connected_space.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_cancel_monoid.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_76949 (h0 : group (has_neg (has_add Type))) : is_simple_group (has_neg (has_add Type)) := sorry --non-trivial
lemma new_lemma_76950 (h0 : list (has_top (semiring unsigned))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_76951 (h0 : function.extfun (Type -> Type) (function.extfun Type)) (h1 : option (function.extfun Type topological_space)) : @path_connected_space.{0} (dlist.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@option.lhoare.{1} (function.extfun.{2 1} Type topological_space.{0}) (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) h1) (dlist.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_76952 (h0 : functor.add_const (topological_space (plift unsigned)) congr_arg_kind) : @irreducible_space.{1} (plift.{1} unsigned) (@functor.add_const.run.{1 0} (topological_space.{1} (plift.{1} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_76953 (h0 : topological_space (has_add (ring (comm_group Type)))) : t1_space (has_add (ring (comm_group Type))) := sorry --non-trivial
lemma new_lemma_76954 (h0 : not (topological_space (option unsigned) -> false)) : @irreducible_space.{0} (option.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (option.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_76955 (h0 : ring (semigroup (has_add name))) : is_principal_ideal_ring (semigroup (has_add name)) := sorry --non-trivial
lemma new_lemma_76956 (h0 : functor.add_const (ring (has_neg_part name)) ennreal) : @strong_rank_condition.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (has_neg_part.{0} name)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_76957 (h0 : functor.add_const (filter (add_comm_monoid pos)) environment.implicit_infer_kind) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_76958 (h0 : functor.add_const (ordered_add_comm_monoid (generalized_boolean_algebra linarith.comp)) (has_neg pos)) : @archimedean.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (generalized_boolean_algebra.{0} linarith.comp)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_76959 (h0 : topological_space (left_cancel_monoid linarith.comp_source)) : locally_compact_space (left_cancel_monoid linarith.comp_source) := sorry --non-trivial
lemma new_lemma_76960 (h0 : uniform_space (linear_ordered_comm_ring (semiring (semiring unsigned)))) : complete_space (linear_ordered_comm_ring (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_76961 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (comm_ring.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (comm_ring.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_76962 (h0 : topological_space (boolean_algebra (boolean_algebra (finset linarith.comp)))) : totally_separated_space (boolean_algebra (boolean_algebra (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_76963 (h0 : functor.add_const (semiring (finset Type)) name) : @is_noetherian_ring.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (semiring.{1} (finset.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_76964 (h0 : ordered_comm_monoid (has_nndist (cancel_monoid Type))) : has_exists_mul_of_le (has_nndist (cancel_monoid Type)) := sorry --non-trivial
lemma new_lemma_76965 (h0 : measurable_space (has_ssubset (metric_space to_additive.value_type))) (h1 : measure_theory.measure (has_ssubset (metric_space to_additive.value_type))) : measure_theory.has_no_atoms h1 := sorry --non-trivial
lemma new_lemma_76966 (h0 : filter (ordered_comm_group empty)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_76967 (h0 : not (complete_lattice (dlist string_imp) -> false)) : @is_compactly_generated.{0} (dlist.{0} string_imp) (@classical.by_contradiction'.{1} (complete_lattice.{0} (dlist.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_76968 (h0 : topological_space (normed_linear_ordered_group unsigned)) : locally_compact_space (normed_linear_ordered_group unsigned) := sorry --non-trivial
lemma new_lemma_76969 (h0 : ring (canonically_ordered_add_monoid congr_arg_kind)) : is_domain (canonically_ordered_add_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_76970 (h0 : complete_lattice (add_cancel_comm_monoid (has_nnnorm reducibility_hints))) : complete_lattice.is_Sup_finite_compact (add_cancel_comm_monoid (has_nnnorm reducibility_hints)) := sorry --non-trivial
lemma new_lemma_76971 (h0 : ring (measure_theory.measure_space (semiring (semiring (semiring (semiring empty)))))) : rank_condition (measure_theory.measure_space (semiring (semiring (semiring (semiring empty))))) := sorry --non-trivial
lemma new_lemma_76972 (h0 : ring (semi_normed_ring (comm_ring reducibility_hints))) : rank_condition (semi_normed_ring (comm_ring reducibility_hints)) := sorry --non-trivial
lemma new_lemma_76973 (h0 : fin has_zero.zero) : @is_compactly_generated.{0} (has_pos_part.{0} pos) (@matrix.vec_empty.{0} (complete_lattice.{0} (has_pos_part.{0} pos)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_76974 (h0 : function.extfun nat fin) : @is_atomistic.{1} (ordered_comm_ring.{1} Type) (@matrix.vec_empty.{1} (complete_lattice.{1} (ordered_comm_ring.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_76975 (h0 : uniform_space (has_div (mul_one_class fun_info))) : complete_space (has_div (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_76976 (h0 : ring (has_zero Type)) : rank_condition (has_zero Type) := sorry --non-trivial
lemma new_lemma_76977 (h0 : functor.add_const (topological_space (as_linear_order empty)) num) : @t0_space.{0} (as_linear_order.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (as_linear_order.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_76978 (h0 : uniform_space (semiring (has_top (random_gen congr_arg_kind)))) : separated_space (semiring (has_top (random_gen congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_76979 (h0 : complete_lattice (has_top (has_top to_additive.value_type))) : is_compactly_generated (has_top (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_76980 (h1 : topological_space (has_add string_imp)) : path_connected_space (has_add string_imp) := sorry --non-trivial
lemma new_lemma_76981 (h0 : function.extfun nat fin) : @t0_space.{0} (sub_neg_monoid.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (sub_neg_monoid.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_76982 (h0 : topological_space (add_comm_monoid (has_add (sub_neg_monoid (has_add Type))))) : loc_path_connected_space (add_comm_monoid (has_add (sub_neg_monoid (has_add Type)))) := sorry --non-trivial
lemma new_lemma_76983 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (mul_zero_class.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (mul_zero_class.{0} pos))  := sorry --non-trivial
lemma new_lemma_76984 (h2 : uniform_space (div_inv_monoid linarith.comp_source)) : complete_space (div_inv_monoid linarith.comp_source) := sorry --non-trivial
lemma new_lemma_76985 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @totally_separated_space.{0} to_additive.value_type (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) to_additive.value_type)  := sorry --non-trivial
lemma new_lemma_76986 (h0 : functor.add_const (ring (has_zero linarith.comp)) Type) : @strong_rank_condition.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 1} (ring.{0} (has_zero.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_76987 (h0 : fin has_zero.zero) : @path_connected_space.{0} (comm_semigroup.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (comm_semigroup.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_76988 (h0 : complete_lattice (measurable_space (random_gen (random_gen string_imp)))) : is_atomistic (measurable_space (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_76989 (h0 : list (add_comm_monoid (option empty))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_76990 (h0 : functor.add_const (ring (add_comm_monoid Type)) pos) : @strong_rank_condition.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (add_comm_monoid.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_76991 (h0 : has_mem.mem (complete_semilattice_Sup empty) has_emptyc.emptyc) : @group.fg.{0} (complete_semilattice_Sup.{0} empty) (@finset.pi.empty.{1 0} Type group.{0} (complete_semilattice_Sup.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_76992 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (has_to_string.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (has_to_string.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_76993 (h0 : functor.add_const (topological_space (normed_linear_ordered_group unsigned)) congr_arg_kind) : @t0_space.{0} (normed_linear_ordered_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_linear_ordered_group.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_76994 (h0 : functor.add_const (uniform_space linarith.comp) (has_Inf linarith.comp)) : @complete_space.{0} linarith.comp (@functor.add_const.run.{0 0} (uniform_space.{0} linarith.comp) (has_Inf.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_76995 (h1 : topological_space (topological_space to_additive.value_type)) : t0_space (topological_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_76996 (h0 : functor.add_const (group (boolean_algebra.core environment.implicit_infer_kind)) name) : @is_simple_group.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_76997 (h0 : functor.add_const (ordered_comm_monoid (ring pos)) (ring name)) : @has_exists_mul_of_le.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (ring.{0} pos)) (ring.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_76998 (h0 : not (monoid (add_right_cancel_monoid empty) -> false)) : @monoid.fg.{0} (add_right_cancel_monoid.{0} empty) (@classical.by_contradiction'.{1} (monoid.{0} (add_right_cancel_monoid.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_76999 (h0 : topological_space (normed_comm_ring (option unsigned))) : loc_path_connected_space (normed_comm_ring (option unsigned)) := sorry --non-trivial
lemma new_lemma_77000 (h0 : functor.add_const (group (has_neg name)) environment.implicit_infer_kind) : @group.fg.{0} (has_neg.{0} name) (@functor.add_const.run.{0 0} (group.{0} (has_neg.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_77001 (h0 : topological_space (has_emptyc (random_gen linarith.ineq))) : totally_disconnected_space (has_emptyc (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_77002 (h0 : filter znum) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_77003 (h0 : functor.add_const (topological_space (ordered_comm_group num)) (option empty)) : @preirreducible_space.{0} (ordered_comm_group.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_group.{0} num)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_77004 (h0 : complete_lattice (simple_graph (mul_one_class (has_neg enat)))) : is_compactly_generated (simple_graph (mul_one_class (has_neg enat))) := sorry --non-trivial
lemma new_lemma_77005 (h1 : has_lt (semi_normed_ring (mul_one_class ereal))) : no_max_order (semi_normed_ring (mul_one_class ereal)) := sorry --non-trivial
lemma new_lemma_77006 (h0 : group (measurable_space (random_gen (with_bot (with_bot (random_gen string_imp)))))) : group.fg (measurable_space (random_gen (with_bot (with_bot (random_gen string_imp))))) := sorry --non-trivial
lemma new_lemma_77007 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_inv.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inv.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_77008 (h0 : complete_lattice (has_star (semiring num))) : is_compactly_generated (has_star (semiring num)) := sorry --non-trivial
lemma new_lemma_77009 (h0 : uniform_space (canonically_ordered_comm_semiring (linear_ordered_comm_ring name))) : complete_space (canonically_ordered_comm_semiring (linear_ordered_comm_ring name)) := sorry --non-trivial
lemma new_lemma_77010 (h0 : to_additive.value_type -> to_additive.value_type -> Prop) (h1 : symmetric h0) (h2 : sym2 to_additive.value_type) : sym2.from_rel h1 h2 := sorry --non-trivial
lemma new_lemma_77011 (h0 : functor.add_const (function.extfun Type ring) (boolean_algebra Type)) : @is_principal_ideal_ring.{0} (boolean_algebra.core.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ring.{0}) (boolean_algebra.{1} Type) h0) (boolean_algebra.core.{0} name))  := sorry --non-trivial
lemma new_lemma_77012 (h0 : ring (has_Inf name)) : rank_condition (has_Inf name) := sorry --non-trivial
lemma new_lemma_77013 (h0 : topological_space (mul_zero_class congr_arg_kind)) : totally_disconnected_space (mul_zero_class congr_arg_kind) := sorry --non-trivial
lemma new_lemma_77014 (h1 : ring (has_emptyc (has_top (has_top num)))) : strong_rank_condition (has_emptyc (has_top (has_top num))) := sorry --non-trivial
lemma new_lemma_77015 (h0 : monoid (has_zero (finset (finset pos)))) : monoid.fg (has_zero (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_77016 (h0 : fin has_zero.zero) : @is_cyclic.{0} (canonically_linear_ordered_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (group.{0} (canonically_linear_ordered_monoid.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_77017 (h0 : functor.add_const (functor.add_const (group Type) linarith.comp) pos) : @group.fg.{1} Type (@functor.add_const.run.{1 0} (group.{1} Type) linarith.comp (@functor.add_const.run.{1 0} (functor.add_const.{1 0} (group.{1} Type) linarith.comp) pos h0))  := sorry --non-trivial
lemma new_lemma_77018 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_77019 (h0 : add_monoid (complete_linear_order (semiring empty))) : add_monoid.fg (complete_linear_order (semiring empty)) := sorry --non-trivial
lemma new_lemma_77020 (h0 : complete_lattice (left_cancel_semigroup (semiring congr_arg_kind))) : complete_lattice.is_Sup_finite_compact (left_cancel_semigroup (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_77021 (h0 : ring (simple_graph string_imp)) : rank_condition (simple_graph string_imp) := sorry --non-trivial
lemma new_lemma_77022 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} unsigned (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) unsigned)  := sorry --non-trivial
lemma new_lemma_77023 (h0 : functor.add_const (function.extfun Type list) Type) : palindrome (function.extfun_app (functor.add_const.run h0) (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_77024 (h0 : filter (has_norm (has_top (has_top fun_info)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_77025 (h0 : functor.add_const (ring (has_add Type)) (finset (finset pos))) : @is_domain.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_add.{1} Type)) (finset.{0} (finset.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_77026 (h2 : pfun std_gen (topological_space fun_info)) (h3 : coe_sort (pfun.dom h2)) : @t0_space.{0} fun_info (@pfun.as_subtype.{0 0} std_gen (topological_space.{0} fun_info) h2 h3)  := sorry --non-trivial
lemma new_lemma_77027 (h0 : functor.add_const (topological_space (has_Inf linarith.comp)) pos) : @totally_separated_space.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_77028 (h0 : ring (has_edist empty)) : strong_rank_condition (has_edist empty) := sorry --non-trivial
lemma new_lemma_77029 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (normed_group.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (normed_group.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_77030 (h0 : functor.comp group comm_group Type) : @is_simple_group.{1} (comm_group.{1} Type) (@functor.comp.run.{1 1 1} group.{1} comm_group.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_77031 (h0 : ring (normed_lattice_add_comm_group (has_bot (sub_neg_monoid real)))) : is_principal_ideal_ring (normed_lattice_add_comm_group (has_bot (sub_neg_monoid real))) := sorry --non-trivial
lemma new_lemma_77032 (h0 : topological_space (with_one (has_nnnorm (has_nnnorm fun_info)))) : path_connected_space (with_one (has_nnnorm (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_77033 (h0 : functor.add_const (add_group (comm_group unsigned)) Type) : @is_add_cyclic.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 1} (add_group.{0} (comm_group.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_77034 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_norm.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} h0 (has_norm.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_77035 (h0 : topological_space (add_cancel_comm_monoid (add_cancel_comm_monoid (mul_one_class string_imp)))) : path_connected_space (add_cancel_comm_monoid (add_cancel_comm_monoid (mul_one_class string_imp))) := sorry --non-trivial
lemma new_lemma_77036 (h0 : functor.add_const (topological_space (complete_distrib_lattice environment.implicit_infer_kind)) pos) : @preirreducible_space.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_77037 (h0 : topological_space (canonically_linear_ordered_monoid (has_Inf linarith.comp))) : irreducible_space (canonically_linear_ordered_monoid (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_77038 (h0 : add_monoid (linear_ordered_field (option pos))) : add_monoid.fg (linear_ordered_field (option pos)) := sorry --non-trivial
lemma new_lemma_77039 (h0 : topological_space (pseudo_metric_space (has_add ennreal))) : loc_path_connected_space (pseudo_metric_space (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_77040 (h0 : topological_space (measurable_space (semiring (semiring congr_arg_kind)))) : preirreducible_space (measurable_space (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_77041 (h0 : functor.comp topological_space random_gen (random_gen (random_gen (random_gen linarith.comp_source)))) : @irreducible_space.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} linarith.comp_source)))) (@functor.comp.run.{0 0 0} topological_space.{0} random_gen.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} linarith.comp_source))) h0)  := sorry --non-trivial
lemma new_lemma_77042 (h0 : not (function.extfun Type semiring -> false)) : @is_noetherian_ring.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@id.{1} (semiring.{0} (complete_semilattice_Sup.{0} congr_arg_kind)) (@function.extfun_app.{2 1} Type semiring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type semiring.{0}) h0) (complete_semilattice_Sup.{0} congr_arg_kind)))  := sorry --non-trivial
lemma new_lemma_77043 (h0 : functor.add_const (topological_space (has_zero unsigned)) linarith.comp) : @loc_path_connected_space.{0} (has_zero.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_77044 (h0 : functor.add_const (topological_space (option pos)) pos) : @totally_disconnected_space.{0} (option.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_77045 (h0 : add_group (semi_normed_ring (has_ssubset reducibility_hints))) : is_add_cyclic (semi_normed_ring (has_ssubset reducibility_hints)) := sorry --non-trivial
lemma new_lemma_77046 (h0 : not (function.extfun Type topological_space -> false)) : @totally_disconnected_space.{0} (has_top.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_top.{0} empty))  := sorry --non-trivial
lemma new_lemma_77047 (h0 : ring (has_pos_part (has_add (ordered_ring name)))) : rank_condition (has_pos_part (has_add (ordered_ring name))) := sorry --non-trivial
lemma new_lemma_77048 (h1 : complete_lattice (has_ssubset char)) : is_compactly_generated (has_ssubset char) := sorry --non-trivial
lemma new_lemma_77049 (h0 : uniform_space (semiring congr_arg_kind)) : complete_space (semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_77050 (h0 : function.extfun Type (functor.add_const (ring nnreal))) : @is_domain.{0} nnreal (@functor.add_const.run.{0 0} (ring.{0} nnreal) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} nnreal)) h0 empty))  := sorry --non-trivial
lemma new_lemma_77051 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (canonically_ordered_comm_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (canonically_ordered_comm_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_77052 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (with_bot.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (with_bot.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_77053 (h1 : not (topological_space (div_inv_monoid char) -> false)) : @path_connected_space.{0} (div_inv_monoid.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (div_inv_monoid.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_77054 (h0 : monoid (with_one (has_top (has_top (semiring fun_info))))) : monoid.fg (with_one (has_top (has_top (semiring fun_info)))) := sorry --non-trivial
lemma new_lemma_77055 (h0 : topological_space (comm_group (option pos))) : topological_space.separable_space (comm_group (option pos)) := sorry --non-trivial
lemma new_lemma_77056 (h0 : list (add_comm_monoid (has_add (add_cancel_monoid name)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_77057 (h0 : functor.add_const (group (canonically_ordered_comm_semiring pos)) name) : @group.fg.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (canonically_ordered_comm_semiring.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_77058 (h0 : topological_space (has_add (finset (normed_comm_ring (has_Inf pos))))) : preirreducible_space (has_add (finset (normed_comm_ring (has_Inf pos)))) := sorry --non-trivial
lemma new_lemma_77059 (h0 : topological_space (boolean_algebra.core (has_neg_part pos))) : t1_space (boolean_algebra.core (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_77060 (h0 : ring (measurable_space (has_inv (has_inv to_additive.value_type)))) : is_domain (measurable_space (has_inv (has_inv to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_77061 (h0 : ring (has_add (has_nndist (has_add Type)))) : is_principal_ideal_ring (has_add (has_nndist (has_add Type))) := sorry --non-trivial
lemma new_lemma_77062 (h0 : not (ring (uniform_space enat) -> false)) : @is_domain.{0} (uniform_space.{0} enat) (@classical.by_contradiction'.{1} (ring.{0} (uniform_space.{0} enat)) h0)  := sorry --non-trivial
lemma new_lemma_77063 (h0 : ring (has_zero (ring Type))) : is_principal_ideal_ring (has_zero (ring Type)) := sorry --non-trivial
lemma new_lemma_77064 (h0 : add_monoid (finset (finset pos))) : add_monoid.fg (finset (finset pos)) := sorry --non-trivial
lemma new_lemma_77065 (h0 : functor.add_const (ring (measure_theory.measure_space congr_arg_kind)) unsigned) : @strong_rank_condition.{0} (measure_theory.measure_space.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ring.{0} (measure_theory.measure_space.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_77066 (h0 : topological_space (simple_graph (has_Inf linarith.comp))) : t1_space (simple_graph (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_77067 (h0 : nat) (h1 : fin has_zero.zero) : nat.min_sq_fac_prop h0 (matrix.vec_empty h1) := sorry --non-trivial
lemma new_lemma_77068 (h0 : add_group (complete_semilattice_Sup (semiring empty))) : is_add_cyclic (complete_semilattice_Sup (semiring empty)) := sorry --non-trivial
lemma new_lemma_77069 (h0 : not (function.extfun (Type 1) topological_space -> false)) : @preirreducible_space.{1} (plift.{1} unsigned) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@classical.by_contradiction'.{3} (function.extfun.{3 2} (Type 1) topological_space.{1}) h0) (plift.{1} unsigned))  := sorry --non-trivial
lemma new_lemma_77070 (h0 : has_le linarith.ineq) : no_bot_order linarith.ineq := sorry --non-trivial
lemma new_lemma_77071 (h0 : functor.add_const (function.extfun Type ring) (finset (finset linarith.comp))) : @strong_rank_condition.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) (finset.{0} (finset.{0} linarith.comp)) h0) (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_77072 (h0 : function.extfun (finset Type) (has_mem.mem (has_norm fun_info))) : @t0_space.{0} (has_norm.{0} fun_info) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_norm.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_norm.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_77073 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (has_norm.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_norm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_77074 (h0 : add_monoid (semigroup (finset (has_neg Type)))) : add_monoid.fg (semigroup (finset (has_neg Type))) := sorry --non-trivial
lemma new_lemma_77075 (h0 : function.extfun (Type 1) topological_space) : @path_connected_space.{1} (mul_zero_class.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (mul_zero_class.{1} Type))  := sorry --non-trivial
lemma new_lemma_77076 (h0 : ring (semigroup (semigroup (has_add (semigroup Type))))) : rank_condition (semigroup (semigroup (has_add (semigroup Type)))) := sorry --non-trivial
lemma new_lemma_77077 (h0 : ring (mv_power_series empty unsigned)) : is_domain (mv_power_series empty unsigned) := sorry --non-trivial
lemma new_lemma_77078 (h0 : not (function.extfun Type complete_lattice -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_union.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (has_union.{0} num))  := sorry --non-trivial
lemma new_lemma_77079 (h0 : topological_space (simple_graph (has_Inf (finset linarith.comp)))) : totally_disconnected_space (simple_graph (has_Inf (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_77080 (h0 : not (function.extfun Type ring -> false)) : @rank_condition.{0} (@id.{2} Type congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (@id.{2} Type congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_77081 (h1 : function.extfun Type uniform_space) : @complete_space.{0} (with_one.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type uniform_space.{0} h1 (with_one.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_77082 (h0 : topological_space (semiring linarith.ineq)) : locally_compact_space (semiring linarith.ineq) := sorry --non-trivial
lemma new_lemma_77083 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (canonically_linear_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_linear_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_77084 (h0 : topological_space (has_norm (random_gen (random_gen num)))) : irreducible_space (has_norm (random_gen (random_gen num))) := sorry --non-trivial
lemma new_lemma_77085 (h0 : functor.add_const (ring (has_add unsigned)) Type) : @is_domain.{0} (has_add.{0} unsigned) (@functor.add_const.run.{0 1} (ring.{0} (has_add.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_77086 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (ordered_cancel_add_comm_monoid.{0} (option.{0} ennreal)) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (ordered_cancel_add_comm_monoid.{0} (option.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_77087 (h0 : functor.add_const (topological_space (finset pos)) linarith.comp) : @t0_space.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_77088 (h0 h1 : pnat) : pnat.coprime h0 (id (id h1)) := sorry --non-trivial
lemma new_lemma_77089 (h0 : ring (mul_one_class string_imp)) : rank_condition (mul_one_class string_imp) := sorry --non-trivial
lemma new_lemma_77090 (h0 : topological_space (comm_group pos)) : t0_space (comm_group pos) := sorry --non-trivial
lemma new_lemma_77091 (h0 : topological_space (has_nndist (normed_comm_ring pos))) : preconnected_space (has_nndist (normed_comm_ring pos)) := sorry --non-trivial
lemma new_lemma_77092 (h0 : fin has_zero.zero) : @is_compactly_generated.{0} (canonically_ordered_monoid.{0} name) (@matrix.vec_empty.{0} (complete_lattice.{0} (canonically_ordered_monoid.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_77093 (h5 : topological_space (has_compl char)) : t0_space (has_compl char) := sorry --non-trivial
lemma new_lemma_77094 (h0 : functor.add_const (function.extfun Type topological_space) name) : @totally_separated_space.{0} (mul_zero_class.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (mul_zero_class.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_77095 (h0 : fin has_zero.zero) : @archimedean.{0} (ordered_comm_monoid.{0} name) (@matrix.vec_empty.{0} (ordered_add_comm_monoid.{0} (ordered_comm_monoid.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_77096 (h0 : not (topological_space (dlist linarith.ineq) -> false)) : @locally_compact_space.{0} (dlist.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (dlist.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_77097 (h0 : ring (id (has_norm (semiring linarith.comp)))) : rank_condition (id (has_norm (semiring linarith.comp))) := sorry --non-trivial
lemma new_lemma_77098 (h0 : topological_space (linear_ordered_comm_group ennreal)) : totally_disconnected_space (linear_ordered_comm_group ennreal) := sorry --non-trivial
lemma new_lemma_77099 (h0 : group (canonically_linear_ordered_monoid (sub_neg_monoid Type))) : group.fg (canonically_linear_ordered_monoid (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_77100 (h0 : functor.add_const (topological_space (measurable_space.dynkin_system congr_arg_kind)) congr_arg_kind) : @path_connected_space.{0} (measurable_space.dynkin_system.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (measurable_space.dynkin_system.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_77101 (h0 : function.extfun Type (functor.comp topological_space has_to_string)) : @t0_space.{0} (has_to_string.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} has_to_string.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} has_to_string.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_77102 (h0 : ring (has_neg pos)) : strong_rank_condition (has_neg pos) := sorry --non-trivial
lemma new_lemma_77103 (h0 : finset (monoid (option (option empty)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_77104 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_inter.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inter.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_77105 (h1 : complete_lattice (comm_ring to_additive.value_type)) : complete_lattice.is_Sup_finite_compact (comm_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_77106 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_77107 (h0 : complete_lattice (add_right_cancel_monoid num)) : complete_lattice.is_Sup_finite_compact (add_right_cancel_monoid num) := sorry --non-trivial
lemma new_lemma_77108 (h0 : topological_space (has_add (option (option (option (option (option (option (option (option unsigned)))))))))) : t1_space (has_add (option (option (option (option (option (option (option (option unsigned))))))))) := sorry --non-trivial
lemma new_lemma_77109 (h0 : functor.add_const (monoid (semigroup linarith.comp)) (has_neg (ring Type))) : @monoid.fg.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 1} (monoid.{0} (semigroup.{0} linarith.comp)) (has_neg.{1} (ring.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_77110 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (semi_normed_comm_ring.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (semi_normed_comm_ring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_77111 (h0 : functor.add_const (add_group (ring pos)) (has_pos_part (has_Inf (normed_comm_ring pos)))) : @is_add_cyclic.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (ring.{0} pos)) (has_pos_part.{0} (has_Inf.{0} (normed_comm_ring.{0} pos))) h0)  := sorry --non-trivial
lemma new_lemma_77112 (h0 : not (complete_lattice (linear_ordered_comm_ring empty) -> false)) : @is_compactly_generated.{0} (linear_ordered_comm_ring.{0} empty) (@classical.by_contradiction'.{1} (complete_lattice.{0} (linear_ordered_comm_ring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_77113 (h0 : not (function.extfun Type topological_space -> false)) : @normal_space.{0} (has_one.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_77114 (h0 : topological_space (add_comm_monoid (option ennreal))) : topological_space.separable_space (add_comm_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_77115 (h0 : fin has_zero.zero) : @irreducible_space.{0} (has_nndist.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (has_nndist.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_77116 (h0 : functor.add_const (monoid (semigroup pos)) environment.implicit_infer_kind) : @monoid.fg.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (monoid.{0} (semigroup.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_77117 (h0 : char -> char) (h1 : nat) (h2 : char) : function.is_periodic_pt h0 h1 h2 := sorry --non-trivial
lemma new_lemma_77118 (h0 : topological_space (complete_distrib_lattice (sub_neg_monoid pos))) : path_connected_space (complete_distrib_lattice (sub_neg_monoid pos)) := sorry --non-trivial
lemma new_lemma_77119 (h0 : functor.add_const (list (boolean_algebra.core environment.implicit_infer_kind)) unsigned) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_77120 (h0 : functor.add_const (complete_lattice (canonically_ordered_comm_semiring name)) (normed_comm_ring Type)) : @is_compactly_generated.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.add_const.run.{0 1} (complete_lattice.{0} (canonically_ordered_comm_semiring.{0} name)) (normed_comm_ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_77121 (h0 : complete_lattice (measurable_space num)) : complete_lattice.is_Sup_finite_compact (measurable_space num) := sorry --non-trivial
lemma new_lemma_77122 (h0 : functor.add_const (topological_space (add_cancel_monoid pos)) (normed_comm_ring Type)) : @irreducible_space.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (add_cancel_monoid.{0} pos)) (normed_comm_ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_77123 (h0 : function.extfun nat fin) : @group.fg.{0} (has_add.{0} real) (@matrix.vec_empty.{0} (group.{0} (has_add.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_77124 (h0 : functor.add_const (complete_lattice (boolean_algebra.core unsigned)) (option unsigned)) : @complete_lattice.is_Sup_finite_compact.{0} (boolean_algebra.core.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (boolean_algebra.core.{0} unsigned)) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_77125 (h0 : functor.add_const (ring (left_cancel_semigroup unsigned)) (semiring num)) : @is_principal_ideal_ring.{0} (left_cancel_semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (left_cancel_semigroup.{0} unsigned)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_77126 (h0 : topological_space (simple_graph pos)) : totally_separated_space (simple_graph pos) := sorry --non-trivial
lemma new_lemma_77127 (h0 : complete_lattice (mul_zero_class (semiring unsigned))) : is_atomistic (mul_zero_class (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_77128 (h0 : functor.add_const (filter (ring linarith.comp)) linarith.comp) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_77129 (h0 : semiring (simple_graph (ordered_comm_ring (has_add linarith.comp)))) : is_noetherian_ring (simple_graph (ordered_comm_ring (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_77130 (h0 : functor.add_const (cancel_comm_monoid_with_zero (canonically_ordered_add_monoid empty)) empty) : @unique_factorization_monoid.{0} (canonically_ordered_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (canonically_ordered_add_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_77131 (h0 : function.extfun Type group) : @normalizer_condition.{0} (left_cancel_semigroup.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (left_cancel_semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_77132 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_77133 (h0 : functor.add_const (function.extfun (Type 1) group) linarith.comp) : @normalizer_condition.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) group.{1}) linarith.comp h0) (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_77134 (h0 : function.extfun (finset Type) (has_mem.mem (id empty))) : @complete_space.{0} (@id.{2} Type empty) (@finset.pi.empty.{1 0} Type uniform_space.{0} (@id.{2} Type empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (@id.{2} Type empty)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_77135 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (metric_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (metric_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_77136 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (ring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_77137 (h0 : not (function.extfun Type semiring -> false)) : @is_noetherian_ring.{0} (linear_ordered_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type semiring.{0}) h0) (linear_ordered_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_77138 (h0 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} (has_norm.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_norm.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_77139 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (with_one.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_one.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_77140 (h0 : functor.add_const (topological_space (ordered_comm_ring pos)) Type) : @normal_space.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (ordered_comm_ring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_77141 (h0 : topological_space (add_cancel_monoid (add_cancel_monoid (has_add (has_neg_part (has_add name)))))) : regular_space (add_cancel_monoid (add_cancel_monoid (has_add (has_neg_part (has_add name))))) := sorry --non-trivial
lemma new_lemma_77142 (h0 : ring (has_inter (option (option ennreal)))) : rank_condition (has_inter (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_77143 (h0 : functor.add_const (group (has_zero unsigned)) unsigned) : @is_cyclic.{0} (has_zero.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (has_zero.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_77144 (h2 : not (ring (distrib_lattice fun_info) -> false)) : @rank_condition.{0} (distrib_lattice.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (distrib_lattice.{0} fun_info)) h2)  := sorry --non-trivial
lemma new_lemma_77145 (h0 : topological_space (metric_space empty)) : totally_separated_space (metric_space empty) := sorry --non-trivial
lemma new_lemma_77146 (h0 : functor.add_const (uniform_space (has_to_string Type)) name) : @complete_space.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (has_to_string.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_77147 (h0 : ring (semi_normed_ring (has_dist string_imp))) : rank_condition (semi_normed_ring (has_dist string_imp)) := sorry --non-trivial
lemma new_lemma_77148 (h0 : topological_space (comm_ring string.iterator_imp)) : totally_disconnected_space (comm_ring string.iterator_imp) := sorry --non-trivial
lemma new_lemma_77149 (h0 : functor.add_const (ring (normed_comm_ring environment.implicit_infer_kind)) linarith.comp) : @is_domain.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (normed_comm_ring.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_77150 (h0 : not (ring (has_one num) -> false)) : @is_principal_ideal_ring.{0} (has_one.{0} num) (@classical.by_contradiction'.{1} (ring.{0} (has_one.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_77151 (h0 : function.extfun (finset Type) (has_mem.mem (random_gen fun_info))) : @rank_condition.{0} (random_gen.{0} fun_info) (@finset.pi.empty.{1 0} Type ring.{0} (random_gen.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_77152 (h0 : functor.add_const (topological_space (has_neg Type)) pos) : @preconnected_space.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_neg.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_77153 (h0 : fin has_zero.zero) : @irreducible_space.{1} (has_pos_part.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (has_pos_part.{1} Type)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)))  := sorry --non-trivial
lemma new_lemma_77154 (h0 : topological_space int) : t0_space int := sorry --non-trivial
lemma new_lemma_77155 (h0 : set (ereal -> add_comm_semigroup enat)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_77156 (h0 : topological_space (add_cancel_monoid (finset (has_add (finset Type))))) : topological_space.separable_space (add_cancel_monoid (finset (has_add (finset Type)))) := sorry --non-trivial
lemma new_lemma_77157 (h0 : group (has_Inf (has_Inf Type))) : group.fg (has_Inf (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_77158 (h0 : function.extfun Type topological_space) : @t0_space.{0} (add_right_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_right_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_77159 (h0 : function.extfun Type topological_space) : @t0_space.{0} (linear_ordered_comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_77160 (h0 : function.extfun Type ring) : @rank_condition.{0} (linear_ordered_semiring.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_ordered_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_77161 (h1 : ring (add_left_cancel_monoid to_additive.value_type)) : is_domain (add_left_cancel_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_77162 (h0 : ring (has_div enat)) : rank_condition (has_div enat) := sorry --non-trivial
lemma new_lemma_77163 (h0 : not (list (non_assoc_semiring congr_arg_kind) -> false)) : list.nodup (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_77164 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (has_bot.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_bot.{0} pos))  := sorry --non-trivial
lemma new_lemma_77165 (h0 : functor.comp topological_space has_neg unsigned) : @path_connected_space.{0} (has_neg.{0} unsigned) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_77166 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (has_add pos)) := sorry --non-trivial
lemma new_lemma_77167 (h0 : functor.add_const (function.extfun (Type 1) add_monoid) linarith.comp) : @add_monoid.fg.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) add_monoid.{1}) linarith.comp h0) (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_77168 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (mul_zero_class.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (mul_zero_class.{0} pos))  := sorry --non-trivial
lemma new_lemma_77169 (h0 : ring (ring (normed_comm_ring (normed_comm_ring Type)))) : is_domain (ring (normed_comm_ring (normed_comm_ring Type))) := sorry --non-trivial
lemma new_lemma_77170 (h0 : ordered_add_comm_monoid (semigroup (comm_group unsigned))) : archimedean (semigroup (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_77171 (h0 : functor.add_const (ordered_add_comm_monoid (is_R_or_C unsigned)) unsigned) : @archimedean.{0} (is_R_or_C.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (is_R_or_C.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_77172 (h0 : uniform_space (id (random_gen (random_gen (has_inv (random_gen linarith.ineq)))))) : complete_space (id (random_gen (random_gen (has_inv (random_gen linarith.ineq))))) := sorry --non-trivial
lemma new_lemma_77173 (h0 : functor.add_const (topological_space (add_comm_monoid Type)) linarith.comp) : @regular_space.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_comm_monoid.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_77174 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (ordered_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (ordered_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_77175 (h0 : functor.add_const (topological_space (has_neg environment.implicit_infer_kind)) pos) : @totally_disconnected_space.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_77176 (h0 : topological_space (complete_distrib_lattice (has_add (comm_group (has_add Type))))) : totally_disconnected_space (complete_distrib_lattice (has_add (comm_group (has_add Type)))) := sorry --non-trivial
lemma new_lemma_77177 (h0 : functor.add_const (cancel_comm_monoid_with_zero (mul_zero_class environment.implicit_infer_kind)) unsigned) : @unique_factorization_monoid.{0} (mul_zero_class.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (mul_zero_class.{0} environment.implicit_infer_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_77178 (h0 : topological_space (measure_theory.measure_space (semiring num))) : preirreducible_space (measure_theory.measure_space (semiring num)) := sorry --non-trivial
lemma new_lemma_77179 (h0 : complete_lattice (normed_comm_ring (measurable_space.dynkin_system Type))) : complete_lattice.is_Sup_finite_compact (normed_comm_ring (measurable_space.dynkin_system Type)) := sorry --non-trivial
lemma new_lemma_77180 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (linear_ordered_semiring.{0} (has_top.{0} congr_arg_kind)) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_semiring.{0} (has_top.{0} congr_arg_kind)))  := sorry --non-trivial
lemma new_lemma_77181 (h0 : ring (topological_space char)) : is_domain (topological_space char) := sorry --non-trivial
lemma new_lemma_77182 (h0 : topological_space (semigroup (option (option (option (option (option unsigned))))))) : path_connected_space (semigroup (option (option (option (option (option unsigned)))))) := sorry --non-trivial
lemma new_lemma_77183 (h0 : list (boolean_algebra.core (has_zero name))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_77184 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (ordered_comm_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_77185 (h0 : functor.add_const (topological_space (add_cancel_comm_monoid empty)) empty) : @t0_space.{0} (add_cancel_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_comm_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_77186 (h0 : complete_lattice (add_left_cancel_semigroup num)) : is_compactly_generated (add_left_cancel_semigroup num) := sorry --non-trivial
lemma new_lemma_77187 (h0 : function.extfun (finset Type) (has_mem.mem (normed_group linarith.ineq))) : @monoid.fg.{0} (normed_group.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type monoid.{0} (normed_group.{0} linarith.ineq) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (normed_group.{0} linarith.ineq)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_77188 (h0 : topological_space (has_ssubset linarith.ineq)) : irreducible_space (has_ssubset linarith.ineq) := sorry --non-trivial
lemma new_lemma_77189 (h0 : add_monoid (generalized_boolean_algebra name)) : add_monoid.fg (generalized_boolean_algebra name) := sorry --non-trivial
lemma new_lemma_77190 (h0 : monoid (random_gen (has_inv (random_gen to_additive.value_type)))) : monoid.fg (random_gen (has_inv (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_77191 (h2 : topological_space (topological_space (denumerable (denumerable to_additive.value_type)))) : t0_space (topological_space (denumerable (denumerable to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_77192 (h0 : functor.add_const (topological_space (semigroup unsigned)) name) : @irreducible_space.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_77193 (h0 : fin has_zero.zero) : @unique_factorization_monoid.{1} (measurable_space.dynkin_system.{1} Type) (@matrix.vec_empty.{1} (cancel_comm_monoid_with_zero.{1} (measurable_space.dynkin_system.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_77194 (h0 : complete_lattice (has_emptyc (random_gen num))) : is_compactly_generated (has_emptyc (random_gen num)) := sorry --non-trivial
lemma new_lemma_77195 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (cancel_monoid name)) := sorry --non-trivial
lemma new_lemma_77196 (h1 : topological_space (has_top (measurable_space (has_inv string_imp)))) : path_connected_space (has_top (measurable_space (has_inv string_imp))) := sorry --non-trivial
lemma new_lemma_77197 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem group)) : @is_cyclic.{0} fun_info (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) group.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) fun_info)  := sorry --non-trivial
lemma new_lemma_77198 (h0 : functor.add_const (ring (has_add linarith.comp)) (has_zero (has_zero pos))) : @is_principal_ideal_ring.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_add.{0} linarith.comp)) (has_zero.{0} (has_zero.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_77199 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (linear_ordered_field.{0} (option.{0} unsigned)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_field.{0} (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_77200 (h0 : functor.add_const (monoid (boolean_algebra environment.implicit_infer_kind)) (has_to_string (has_to_string pos))) : @monoid.fg.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (monoid.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) (has_to_string.{0} (has_to_string.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_77201 (h1 : not (ring (uniform_space linarith.comp_source) -> false)) : @strong_rank_condition.{0} (uniform_space.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (uniform_space.{0} linarith.comp_source)) h1)  := sorry --non-trivial
lemma new_lemma_77202 (h0 : fin has_zero.zero) : @regular_space.{0} (comm_semigroup.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (comm_semigroup.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_77203 (h0 : functor.add_const (semiring (partial_order empty)) (semiring (semiring (semiring unsigned)))) : @is_noetherian_ring.{0} (partial_order.{0} empty) (@functor.add_const.run.{0 0} (semiring.{0} (partial_order.{0} empty)) (semiring.{0} (semiring.{0} (semiring.{0} unsigned))) h0)  := sorry --non-trivial
lemma new_lemma_77204 (h0 : functor.add_const (function.extfun Type topological_space) (finset Type)) : @normal_space.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) (finset.{1} Type) h0) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_77205 (h0 : functor.add_const (ring (has_to_string environment.implicit_infer_kind)) Type) : @rank_condition.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (ring.{0} (has_to_string.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_77206 (h0 : empty) : @t0_space.{0} (has_lt.{0} (mul_one_class.{0} (mul_one_class.{0} (mul_one_class.{0} (mul_one_class.{0} enat))))) (@empty.elim.{1} (topological_space.{0} (has_lt.{0} (mul_one_class.{0} (mul_one_class.{0} (mul_one_class.{0} (mul_one_class.{0} enat)))))) h0)  := sorry --non-trivial
lemma new_lemma_77207 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (normed_comm_ring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_77208 (h0 : add_group (encodable (random_gen (has_ssubset fun_info)))) : is_add_cyclic (encodable (random_gen (has_ssubset fun_info))) := sorry --non-trivial
lemma new_lemma_77209 (h0 : uniform_space (has_Inf (ordered_ring linarith.comp))) : separated_space (has_Inf (ordered_ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_77210 (h0 : complete_lattice (comm_ring (random_gen to_additive.value_type))) : is_compactly_generated (comm_ring (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_77211 (h0 : topological_space (has_to_string (option (option ennreal)))) : normal_space (has_to_string (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_77212 (h0 : topological_space (normed_group (semiring num))) : irreducible_space (normed_group (semiring num)) := sorry --non-trivial
lemma new_lemma_77213 (h2 : topological_space string.iterator_imp) (h3 : preorder string.iterator_imp) : order_closed_topology string.iterator_imp := sorry --non-trivial
lemma new_lemma_77214 (h0 : functor.add_const (function.extfun (Type 1) filter) (finset pos)) : filter.ne_bot (function.extfun_app (functor.add_const.run h0) Type) := sorry --non-trivial
lemma new_lemma_77215 (h0 : topological_space (has_Inf (has_neg (has_add (has_nndist (has_Inf (ring linarith.comp))))))) : discrete_topology (has_Inf (has_neg (has_add (has_nndist (has_Inf (ring linarith.comp)))))) := sorry --non-trivial
lemma new_lemma_77216 (h0 : topological_space (complete_distrib_lattice (has_add (has_add linarith.comp)))) : sequential_space (complete_distrib_lattice (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_77217 (h0 : topological_space (has_lt string.iterator_imp)) (h1 : preorder (has_lt string.iterator_imp)) : order_topology (has_lt string.iterator_imp) := sorry --non-trivial
lemma new_lemma_77218 (h0 : add_group (add_comm_semigroup (add_comm_semigroup (add_comm_semigroup linarith.ineq)))) : is_add_cyclic (add_comm_semigroup (add_comm_semigroup (add_comm_semigroup linarith.ineq))) := sorry --non-trivial
lemma new_lemma_77219 (h0 : topological_space (has_zero (add_cancel_monoid (has_add unsigned)))) : preconnected_space (has_zero (add_cancel_monoid (has_add unsigned))) := sorry --non-trivial
lemma new_lemma_77220 (h0 : fin has_zero.zero) : @preirreducible_space.{1} (comm_semigroup.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (comm_semigroup.{1} Type)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_77221 (h0 : function.extfun Type group) : @group.fg.{0} (comm_ring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} h0 (comm_ring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_77222 (h0 : topological_space (complete_semilattice_Sup linarith.comp)) : t0_space (complete_semilattice_Sup linarith.comp) := sorry --non-trivial
lemma new_lemma_77223 (h0 : functor.add_const (add_monoid (has_to_string pos)) (has_neg (has_neg linarith.comp))) : @add_monoid.fg.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_to_string.{0} pos)) (has_neg.{0} (has_neg.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_77224 (h0 : topological_space (has_pos_part (has_add (boolean_algebra.core pos)))) : sequential_space (has_pos_part (has_add (boolean_algebra.core pos))) := sorry --non-trivial
lemma new_lemma_77225 (h0 : topological_space (pseudo_metric_space (option unsigned))) : irreducible_space (pseudo_metric_space (option unsigned)) := sorry --non-trivial
lemma new_lemma_77226 (h0 : not (has_mem.mem (semiring to_additive.value_type) has_emptyc.emptyc -> false)) : @is_atomistic.{0} (semiring.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (semiring.{0} to_additive.value_type) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} to_additive.value_type) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_77227 (h0 : add_group (id (semiring (has_norm (semiring (semiring congr_arg_kind)))))) : is_add_cyclic (id (semiring (has_norm (semiring (semiring congr_arg_kind))))) := sorry --non-trivial
lemma new_lemma_77228 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @totally_separated_space.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_77229 (h0 : functor.add_const (semiring (semiring empty)) empty) : @is_noetherian_ring.{0} (semiring.{0} empty) (@functor.add_const.run.{0 0} (semiring.{0} (semiring.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_77230 (h0 : topological_space (canonically_ordered_comm_semiring (boolean_algebra Type))) : preconnected_space (canonically_ordered_comm_semiring (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_77231 (h0 : group (finset (comm_group (has_add (comm_group Type))))) : is_cyclic (finset (comm_group (has_add (comm_group Type)))) := sorry --non-trivial
lemma new_lemma_77232 (h0 : not (ring (normed_field (comm_ring (random_gen (comm_ring linarith.comp_source)))) -> false)) : @strong_rank_condition.{0} (normed_field.{0} (comm_ring.{0} (random_gen.{0} (comm_ring.{0} linarith.comp_source)))) (@classical.by_contradiction'.{1} (ring.{0} (normed_field.{0} (comm_ring.{0} (random_gen.{0} (comm_ring.{0} linarith.comp_source))))) h0)  := sorry --non-trivial
lemma new_lemma_77233 (h0 : add_group (add_comm_monoid (comm_group (comm_group Type)))) : is_add_cyclic (add_comm_monoid (comm_group (comm_group Type))) := sorry --non-trivial
lemma new_lemma_77234 (h0 : ring (normed_comm_ring (option unsigned))) : is_principal_ideal_ring (normed_comm_ring (option unsigned)) := sorry --non-trivial
lemma new_lemma_77235 (h0 : topological_space (comm_semigroup (has_Inf Type))) : normal_space (comm_semigroup (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_77236 (h0 : function.extfun nat fin) : @group.fg.{1} (canonically_linear_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (group.{1} (canonically_linear_ordered_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_77237 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (has_sub.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_sub.{0} empty))  := sorry --non-trivial
lemma new_lemma_77238 (h1 : function.extfun Type group) : @normalizer_condition.{0} string_imp (@function.extfun_app.{2 1} Type group.{0} h1 string_imp)  := sorry --non-trivial
lemma new_lemma_77239 (h0 : set (non_unital_non_assoc_semiring char)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_77240 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring linarith.comp)) (has_pos_part Type)) : @locally_compact_space.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (canonically_ordered_comm_semiring.{0} linarith.comp)) (has_pos_part.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_77241 (h1 : uniform_space (has_top (has_norm (measurable_space (with_bot linarith.comp_source))))) : complete_space (has_top (has_norm (measurable_space (with_bot linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_77242 (h0 : topological_space (preorder (option (option (option (has_edist empty)))))) : irreducible_space (preorder (option (option (option (has_edist empty))))) := sorry --non-trivial
lemma new_lemma_77243 (h0 : fun_info -> fun_info -> Prop) : is_equiv fun_info h0 := sorry --non-trivial
lemma new_lemma_77244 (h3 : set (ereal -> linarith.ineq)) : set.separates_points h3 := sorry --non-trivial
lemma new_lemma_77245 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (add_semigroup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_semigroup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_77246 (h0 : topological_space (has_pos_part (has_neg pos))) : locally_compact_space (has_pos_part (has_neg pos)) := sorry --non-trivial
lemma new_lemma_77247 (h0 : topological_space (complete_distrib_lattice (boolean_algebra.core pos))) : loc_path_connected_space (complete_distrib_lattice (boolean_algebra.core pos)) := sorry --non-trivial
lemma new_lemma_77248 (h0 : complete_lattice (with_one unsigned)) : complete_lattice.is_Sup_finite_compact (with_one unsigned) := sorry --non-trivial
lemma new_lemma_77249 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (canonically_linear_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type ring.{0} h0 (canonically_linear_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_77250 (h0 : list (random_gen (random_gen to_additive.value_type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_77251 (h0 : topological_space (comm_group (semigroup (has_add unsigned)))) : regular_space (comm_group (semigroup (has_add unsigned))) := sorry --non-trivial
lemma new_lemma_77252 (h0 : list (has_inner unsigned congr_arg_kind)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_77253 (h0 : ring (has_append (random_gen (has_ssubset (random_gen string_imp))))) : is_domain (has_append (random_gen (has_ssubset (random_gen string_imp)))) := sorry --non-trivial
lemma new_lemma_77254 (h1 : has_lt (mul_one_class (normed_field (normed_field environment.projection_info)))) : no_max_order (mul_one_class (normed_field (normed_field environment.projection_info))) := sorry --non-trivial
lemma new_lemma_77255 (h0 : semiring (partial_order (semiring (semiring empty)))) : is_noetherian_ring (partial_order (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_77256 (h0 : ring (option (semiring num))) : strong_rank_condition (option (semiring num)) := sorry --non-trivial
lemma new_lemma_77257 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (has_Sup unsigned)) := sorry --non-trivial
lemma new_lemma_77258 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (has_nndist name)) := sorry --non-trivial
lemma new_lemma_77259 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_77260 (h0 : function.extfun (finset Type) (has_mem.mem fun_info)) : @is_compactly_generated.{0} fun_info (@finset.pi.empty.{1 0} Type complete_lattice.{0} fun_info (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) fun_info) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_77261 (h0 : function.extfun Type (functor.add_const (group pos))) : @group.fg.{0} pos (@functor.add_const.run.{0 0} (group.{0} pos) pos (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (group.{0} pos)) h0 pos))  := sorry --non-trivial
lemma new_lemma_77262 (h0 : topological_space (cancel_monoid (has_neg linarith.comp))) : topological_space.separable_space (cancel_monoid (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_77263 (h1 : group (has_ssubset (normed_field (comm_ring linarith.comp_source)))) : is_cyclic (has_ssubset (normed_field (comm_ring linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_77264 (h0 : complete_lattice (has_nndist (has_to_string unsigned))) : is_compactly_generated (has_nndist (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_77265 (h0 : function.extfun Type topological_space) : @t1_space.{0} environment.implicit_infer_kind (@function.extfun_app.{2 1} Type topological_space.{0} h0 environment.implicit_infer_kind)  := sorry --non-trivial
lemma new_lemma_77266 (h1 : ring (has_top linarith.ineq)) : rank_condition (has_top linarith.ineq) := sorry --non-trivial
lemma new_lemma_77267 (h0 : fin has_zero.zero) : @rank_condition.{0} (normed_lattice_add_comm_group.{0} pos) (@matrix.vec_empty.{0} (ring.{0} (normed_lattice_add_comm_group.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_77268 (h0 : group (has_to_string (ring name))) : is_cyclic (has_to_string (ring name)) := sorry --non-trivial
lemma new_lemma_77269 (h0 h2 : multiset std_gen) : multiset.le h0 h2 := sorry --non-trivial
lemma new_lemma_77270 (h0 : functor.add_const (functor.add_const (cancel_comm_monoid_with_zero (normed_comm_ring pos)) name) (has_add pos)) : @unique_factorization_monoid.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (normed_comm_ring.{0} pos)) name (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (cancel_comm_monoid_with_zero.{0} (normed_comm_ring.{0} pos)) name) (has_add.{0} pos) h0))  := sorry --non-trivial
lemma new_lemma_77271 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (boolean_algebra.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_77272 (h0 : ring (ordered_comm_ring (has_nndist (has_pos_part Type)))) : strong_rank_condition (ordered_comm_ring (has_nndist (has_pos_part Type))) := sorry --non-trivial
lemma new_lemma_77273 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (monoid_with_zero pos)) := sorry --non-trivial
lemma new_lemma_77274 (h0 : group (semigroup (ring (ring pos)))) : normalizer_condition (semigroup (ring (ring pos))) := sorry --non-trivial
lemma new_lemma_77275 (h0 : functor.add_const (finset (left_cancel_semigroup num)) num) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_77276 (h0 : group (canonically_linear_ordered_monoid (has_Inf (has_Inf Type)))) : is_cyclic (canonically_linear_ordered_monoid (has_Inf (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_77277 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_sub.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_sub.{0} empty))  := sorry --non-trivial
lemma new_lemma_77278 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (finset.{0} ennreal) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (finset.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_77279 (h0 : topological_space (has_neg (add_comm_monoid (emetric_space pos)))) : totally_separated_space (has_neg (add_comm_monoid (emetric_space pos))) := sorry --non-trivial
lemma new_lemma_77280 (h0 : uniform_space (free_add_monoid num)) : separated_space (free_add_monoid num) := sorry --non-trivial
lemma new_lemma_77281 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (canonically_linear_ordered_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_linear_ordered_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_77282 (h0 : group (normed_comm_ring (comm_group (comm_group unsigned)))) : normalizer_condition (normed_comm_ring (comm_group (comm_group unsigned))) := sorry --non-trivial
lemma new_lemma_77283 (h0 : functor.add_const (list (option congr_arg_kind)) empty) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_77284 (h0 : add_group (measure_theory.measure_space (semiring congr_arg_kind))) : is_add_cyclic (measure_theory.measure_space (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_77285 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (complete_distrib_lattice.{0} name) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (complete_distrib_lattice.{0} name))  := sorry --non-trivial
lemma new_lemma_77286 (h0 : not (function.extfun Type uniform_space -> false)) : @separated_space.{0} (add_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (add_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_77287 (h1 : has_mem.mem uniform_space has_emptyc.emptyc) : @complete_space.{0} (measurable_space.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) uniform_space.{0} h1) (measurable_space.{0} num))  := sorry --non-trivial
lemma new_lemma_77288 (h0 : not (function.extfun Type topological_space -> false)) : @normal_space.{0} (with_one.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (with_one.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_77289 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_to_string.{0} (option.{0} ennreal)) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_to_string.{0} (option.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_77290 (h0 : topological_space (ordered_comm_ring (finset linarith.comp))) : locally_compact_space (ordered_comm_ring (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_77291 (h0 : topological_space (ordered_comm_ring (has_neg linarith.comp))) : path_connected_space (ordered_comm_ring (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_77292 (h0 : not (has_mem.mem (has_emptyc to_additive.value_type) has_emptyc.emptyc -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_emptyc.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (has_emptyc.{0} to_additive.value_type) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_emptyc.{0} to_additive.value_type) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_77293 (h0 : topological_space Prop) (h1 : filter Prop) (h2 : filter.ne_bot h1) : @Lim'.{0} Prop (@id.{1} (topological_space.{0} Prop) h0) h1 h2  := sorry --non-trivial
lemma new_lemma_77294 (h0 : topological_space (canonically_ordered_comm_semiring environment.implicit_infer_kind)) : preconnected_space (canonically_ordered_comm_semiring environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_77295 (h0 : uniform_space (comm_group (comm_group (comm_group unsigned)))) : complete_space (comm_group (comm_group (comm_group unsigned))) := sorry --non-trivial
lemma new_lemma_77296 (h0 : list (as_linear_order (option (option unsigned)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_77297 (h0 : functor.add_const (topological_space (add_cancel_monoid environment.implicit_infer_kind)) Type) : @discrete_topology.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_77298 (h0 : group (canonically_ordered_monoid (has_add (has_neg (has_add (has_neg real)))))) : is_cyclic (canonically_ordered_monoid (has_add (has_neg (has_add (has_neg real))))) := sorry --non-trivial
lemma new_lemma_77299 (h0 : cancel_comm_monoid_with_zero (has_inner (option empty) congr_arg_kind)) : unique_factorization_monoid (has_inner (option empty) congr_arg_kind) := sorry --non-trivial
lemma new_lemma_77300 (h0 : topological_space (normed_comm_ring (has_nndist environment.implicit_infer_kind))) : topological_space.separable_space (normed_comm_ring (has_nndist environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_77301 (h0 : functor.add_const (topological_space (ring Type)) Type) : @irreducible_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (ring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_77302 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @group.fg.{0} (@id.{2} Type linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) group.{0}) (@id.{2} Type linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_77303 (h0 : functor.add_const (filter (ring unsigned)) pos) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_77304 (h0 : prod (canonically_linear_ordered_monoid pos) (canonically_linear_ordered_monoid pos)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_77305 (h0 : filter (fintype (fintype fun_info))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_77306 (h0 h1 : multiset (normed_field linarith.comp_source)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_77307 (h0 : topological_space (partial_order (semiring num))) : totally_disconnected_space (partial_order (semiring num)) := sorry --non-trivial
lemma new_lemma_77308 (h0 : topological_space (uniform_space (has_ssubset to_additive.value_type))) : totally_disconnected_space (uniform_space (has_ssubset to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_77309 (h0 : topological_space (add_cancel_monoid (measurable_space.dynkin_system pos))) : irreducible_space (add_cancel_monoid (measurable_space.dynkin_system pos)) := sorry --non-trivial
lemma new_lemma_77310 (h0 : topological_space (has_nnnorm environment.projection_info)) (h1 : add_group (has_nnnorm environment.projection_info)) : topological_add_group (has_nnnorm environment.projection_info) := sorry --non-trivial
lemma new_lemma_77311 (h0 : ring (has_inter (option (option (option (option (option (option (option ennreal))))))))) : rank_condition (has_inter (option (option (option (option (option (option (option ennreal)))))))) := sorry --non-trivial
lemma new_lemma_77312 (h0 : ring (has_append (random_gen char))) : rank_condition (has_append (random_gen char)) := sorry --non-trivial
lemma new_lemma_77313 (h0 : topological_space (has_union congr_arg_kind)) : irreducible_space (has_union congr_arg_kind) := sorry --non-trivial
lemma new_lemma_77314 (h0 : ring (linear_ordered_comm_monoid_with_zero unsigned)) : is_principal_ideal_ring (linear_ordered_comm_monoid_with_zero unsigned) := sorry --non-trivial
lemma new_lemma_77315 (h0 : functor.add_const (functor.add_const (function.extfun Type ring) name) (finset pos)) : @rank_condition.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) name (@functor.add_const.run.{1 0} (functor.add_const.{1 0} (function.extfun.{2 1} Type ring.{0}) name) (finset.{0} pos) h0)) (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_77316 (h0 : functor.add_const (complete_lattice (semiring num)) empty) : @complete_lattice.is_Sup_finite_compact.{0} (semiring.{0} num) (@functor.add_const.run.{0 0} (complete_lattice.{0} (semiring.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_77317 (h0 : ring (has_append (has_ssubset linarith.comp_source))) : rank_condition (has_append (has_ssubset linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_77318 (h0 : set (semi_normed_comm_ring (mul_one_class char))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_77319 (h0 : topological_space (simple_graph pos)) : path_connected_space (simple_graph pos) := sorry --non-trivial
lemma new_lemma_77320 (h0 : semiring (add_semigroup empty)) : is_noetherian_ring (add_semigroup empty) := sorry --non-trivial
lemma new_lemma_77321 (h0 : has_inv fun_info -> topological_space (with_one (has_inv linarith.ineq))) : @totally_disconnected_space.{0} (with_one.{0} (has_inv.{0} linarith.ineq)) (@infi.{0 1} (topological_space.{0} (with_one.{0} (has_inv.{0} linarith.ineq))) (@conditionally_complete_lattice.to_has_Inf.{0} (topological_space.{0} (with_one.{0} (has_inv.{0} linarith.ineq))) (@complete_lattice.to_conditionally_complete_lattice.{0} (topological_space.{0} (with_one.{0} (has_inv.{0} linarith.ineq))) (@topological_space.complete_lattice.{0} (with_one.{0} (has_inv.{0} linarith.ineq))))) (has_inv.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_77322 (h0 : functor.add_const (ring (semigroup linarith.comp)) linarith.comp) : @is_domain.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (semigroup.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_77323 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : totally_separated_space ennreal := sorry --non-trivial
lemma new_lemma_77324 (h0 : semiring (div_inv_monoid linarith.ineq)) (h1 : div_inv_monoid linarith.ineq) : even h1 := sorry --non-trivial
lemma new_lemma_77325 (h0 : fin has_zero.zero) : @normalizer_condition.{1} (boolean_algebra.core.{1} Type) (@matrix.vec_empty.{1} (group.{1} (boolean_algebra.core.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_77326 (h0 : function.extfun Type group) : @group.fg.{0} (with_one.{0} string_imp) (@function.extfun_app.{2 1} Type group.{0} h0 (with_one.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_77327 (h0 : monoid (simple_graph linarith.comp)) : monoid.fg (simple_graph linarith.comp) := sorry --non-trivial
lemma new_lemma_77328 (h0 : add_monoid (has_to_string (finset environment.implicit_infer_kind))) : add_monoid.fg (has_to_string (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_77329 (h0 : function.extfun (finset Type) (has_mem.mem (semiring fun_info))) : @is_compactly_generated.{0} (semiring.{0} fun_info) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (semiring.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_77330 (h0 : topological_space (has_to_string (finset (finset pos)))) : locally_compact_space (has_to_string (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_77331 (h0 : functor.comp group has_neg_part Type) : @is_cyclic.{1} (has_neg_part.{1} Type) (@functor.comp.run.{1 1 1} group.{1} has_neg_part.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_77332 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_77333 (h0 : functor.add_const (monoid (cancel_monoid name)) Type) : @monoid.fg.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 1} (monoid.{0} (cancel_monoid.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_77334 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_77335 (h0 : topological_space (normed_comm_ring (finset (has_add (finset (finset (finset pos))))))) : loc_path_connected_space (normed_comm_ring (finset (has_add (finset (finset (finset pos)))))) := sorry --non-trivial
lemma new_lemma_77336 (h0 : functor.add_const (ring (has_nndist environment.implicit_infer_kind)) Type) : @is_principal_ideal_ring.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (ring.{0} (has_nndist.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_77337 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @t0_space.{0} (has_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_77338 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @discrete_topology.{0} (semiring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_77339 (h0 : topological_space (mul_one_class enat)) : t0_space (mul_one_class enat) := sorry --non-trivial
lemma new_lemma_77340 (h0 : functor.add_const (topological_space (measurable_space.dynkin_system unsigned)) congr_arg_kind) : @normal_space.{0} (measurable_space.dynkin_system.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (measurable_space.dynkin_system.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_77341 (h0 : functor.add_const (complete_lattice (has_add unsigned)) Type) : @is_compactly_generated.{0} (has_add.{0} unsigned) (@functor.add_const.run.{0 1} (complete_lattice.{0} (has_add.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_77342 (h0 : not (add_group (add_monoid (has_nnnorm fun_info)) -> false)) : @is_add_cyclic.{0} (add_monoid.{0} (has_nnnorm.{0} fun_info)) (@classical.by_contradiction'.{1} (add_group.{0} (add_monoid.{0} (has_nnnorm.{0} fun_info))) h0)  := sorry --non-trivial
lemma new_lemma_77343 (h0 : topological_space (has_nnnorm (encodable (has_add (random_gen to_additive.value_type))))) : path_connected_space (has_nnnorm (encodable (has_add (random_gen to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_77344 (h0 : filter (semiring fun_info)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_77345 (h0 : filter (comm_ring (random_gen (has_ssubset (random_gen linarith.comp_source))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_77346 (h0 : ring (distrib_lattice fun_info)) : rank_condition (distrib_lattice fun_info) := sorry --non-trivial
lemma new_lemma_77347 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring pos)) ennreal) : @totally_separated_space.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} pos)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_77348 (h0 : functor.add_const (semiring (add_comm_monoid Type)) name) : @is_noetherian_ring.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (semiring.{1} (add_comm_monoid.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_77349 (h0 : functor.add_const (topological_space (boolean_algebra (has_to_string pos))) Type) : @regular_space.{0} (boolean_algebra.{0} (has_to_string.{0} pos)) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.{0} (has_to_string.{0} pos))) Type h0)  := sorry --non-trivial
lemma new_lemma_77350 (h0 : ring (metric_space (random_gen (random_gen char)))) : strong_rank_condition (metric_space (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_77351 (h0 : fin has_zero.zero) : @group.fg.{0} (add_comm_monoid.{0} pos) (@matrix.vec_empty.{0} (group.{0} (add_comm_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_77352 (h0 : not (group (has_norm congr_arg_kind) -> false)) : @is_cyclic.{0} (has_norm.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (group.{0} (has_norm.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_77353 (h0 : group (with_bot (has_top (has_inv (comm_ring (has_inv linarith.ineq)))))) : is_cyclic (with_bot (has_top (has_inv (comm_ring (has_inv linarith.ineq))))) := sorry --non-trivial
lemma new_lemma_77354 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (monoid.{0} ennreal) (@function.extfun_app.{2 1} Type add_group.{0} h0 (monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_77355 (h0 : topological_space (normed_comm_ring name)) : loc_path_connected_space (normed_comm_ring name) := sorry --non-trivial
lemma new_lemma_77356 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (finset.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} name))  := sorry --non-trivial
lemma new_lemma_77357 (h0 : complete_lattice (semi_normed_ring linarith.comp_source)) : is_compactly_generated (semi_normed_ring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_77358 (h0 : monoid (bin_tree empty)) : monoid.fg (bin_tree empty) := sorry --non-trivial
lemma new_lemma_77359 (h0 : topological_space (has_star empty)) : totally_disconnected_space (has_star empty) := sorry --non-trivial
lemma new_lemma_77360 (h0 : function.extfun (finset Type) (has_mem.mem (semiring empty))) : @irreducible_space.{0} (semiring.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (semiring.{0} empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} empty)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_77361 (h0 : function.extfun Type ring) : @rank_condition.{0} (generalized_boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (generalized_boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_77362 (h0 : add_group (linear_ordered_field unsigned)) : is_add_cyclic (linear_ordered_field unsigned) := sorry --non-trivial
lemma new_lemma_77363 (h0 : ordered_comm_monoid (add_comm_monoid Type)) : has_exists_mul_of_le (add_comm_monoid Type) := sorry --non-trivial
lemma new_lemma_77364 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (filter.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} h0 (filter.{0} empty))  := sorry --non-trivial
lemma new_lemma_77365 (h0 : topological_space (finset (finset pos))) : regular_space (finset (finset pos)) := sorry --non-trivial
lemma new_lemma_77366 (h0 : group (partial_order empty)) : normalizer_condition (partial_order empty) := sorry --non-trivial
lemma new_lemma_77367 (h0 : functor.add_const (semiring (normed_comm_ring name)) linarith.comp) : @is_noetherian_ring.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (semiring.{0} (normed_comm_ring.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_77368 (h0 : ring (measure_theory.measure_space unsigned)) : is_domain (measure_theory.measure_space unsigned) := sorry --non-trivial
lemma new_lemma_77369 (h0 : not (function.extfun Type ring -> false)) : @rank_condition.{0} empty (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) empty)  := sorry --non-trivial
lemma new_lemma_77370 (h0 : functor.add_const (cancel_comm_monoid_with_zero (cancel_monoid name)) linarith.comp) : @unique_factorization_monoid.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (cancel_monoid.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_77371 (h0 : ring (has_top (random_gen (has_top fun_info)))) : rank_condition (has_top (random_gen (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_77372 (h0 : not (function.extfun Type topological_space -> false)) : @discrete_topology.{0} (add_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (add_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_77373 (h0 : topological_space (normed_comm_ring (comm_group unsigned))) : sequential_space (normed_comm_ring (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_77374 (h0 : functor.add_const (topological_space (normed_comm_ring Type)) Type) : @locally_compact_space.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (normed_comm_ring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_77375 (h0 : topological_space (ordered_cancel_add_comm_monoid (has_neg pos))) : preconnected_space (ordered_cancel_add_comm_monoid (has_neg pos)) := sorry --non-trivial
lemma new_lemma_77376 (h0 : complete_lattice (semigroup (option name))) : is_compactly_generated (semigroup (option name)) := sorry --non-trivial
lemma new_lemma_77377 (h0 : ring (has_norm (has_norm fun_info))) : is_domain (has_norm (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_77378 (h0 : topological_space (has_pos_part (has_neg (has_neg name)))) : irreducible_space (has_pos_part (has_neg (has_neg name))) := sorry --non-trivial
lemma new_lemma_77379 (h0 : group (denumerable (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm string.iterator_imp)))))) : is_cyclic (denumerable (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm string.iterator_imp))))) := sorry --non-trivial
lemma new_lemma_77380 (h0 : list (normed_comm_ring (ring environment.implicit_infer_kind))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_77381 (h0 : group (has_add (sub_neg_monoid real))) : group.fg (has_add (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_77382 (h0 : not (complete_lattice (has_top linarith.comp_source) -> false)) : @is_compactly_generated.{0} (has_top.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_top.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_77383 (h0 : function.extfun Type (prod (linear_order empty))) : id_rel (function.extfun_app h0 (linear_order empty)) := sorry --non-trivial
lemma new_lemma_77384 (h0 : function.extfun Type group) : @group.fg.{0} (comm_ring.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} h0 (comm_ring.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_77385 (h0 : not (topological_space (complete_semilattice_Sup unsigned) -> false)) : @preirreducible_space.{0} (complete_semilattice_Sup.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (complete_semilattice_Sup.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_77386 (h0 : topological_space (has_sub num)) : irreducible_space (has_sub num) := sorry --non-trivial
lemma new_lemma_77387 (h0 : ring (linear_ordered_comm_monoid_with_zero unsigned)) : strong_rank_condition (linear_ordered_comm_monoid_with_zero unsigned) := sorry --non-trivial
lemma new_lemma_77388 (h0 : ordered_add_comm_monoid (has_dist (option (option (option (option (option (option (option congr_arg_kind))))))))) : archimedean (has_dist (option (option (option (option (option (option (option congr_arg_kind)))))))) := sorry --non-trivial
lemma new_lemma_77389 (h0 : not (ring (plift (has_top (has_top (has_top (semiring (semiring num)))))) -> false)) : @is_domain.{1} (plift.{1} (has_top.{0} (has_top.{0} (has_top.{0} (semiring.{0} (semiring.{0} num)))))) (@classical.by_contradiction'.{2} (ring.{1} (plift.{1} (has_top.{0} (has_top.{0} (has_top.{0} (semiring.{0} (semiring.{0} num))))))) h0)  := sorry --non-trivial
lemma new_lemma_77390 (h1 : filter (has_nnnorm string_imp)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_77391 (h0 : topological_space (option pos)) : t1_space (option pos) := sorry --non-trivial
lemma new_lemma_77392 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (ordered_cancel_add_comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type semiring.{0} h0 (ordered_cancel_add_comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_77393 (h0 : function.extfun Type topological_space) : @t0_space.{0} (random_gen.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (random_gen.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_77394 (h0 : add_monoid (has_union (semiring linarith.comp))) : add_monoid.fg (has_union (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_77395 (h0 : functor.add_const (topological_space (boolean_algebra.core environment.implicit_infer_kind)) Type) : @t1_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_77396 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (normed_comm_ring.{0} num) (@function.extfun_app.{2 1} Type monoid.{0} h0 (normed_comm_ring.{0} num))  := sorry --non-trivial
lemma new_lemma_77397 (h0 : function.extfun Type ring) : @is_domain.{0} (normed_group.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (normed_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_77398 (h1 : uniform_space enat) : complete_space enat := sorry --non-trivial
lemma new_lemma_77399 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (finset.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_77400 (h0 : semiring (normed_lattice_add_comm_group (has_Inf Type))) : is_noetherian_ring (normed_lattice_add_comm_group (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_77401 (h0 : functor.add_const (topological_space (boolean_algebra.core pos)) linarith.comp) : @normal_space.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_77402 (h0 : mul_zero_class (semiring empty) -> mul_zero_class (semiring empty) -> Prop) : is_symm (mul_zero_class (semiring empty)) h0 := sorry --non-trivial
lemma new_lemma_77403 (h0 : list (semi_normed_comm_ring (random_gen fun_info))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_77404 (h0 : semiring (has_neg unsigned)) : is_noetherian_ring (has_neg unsigned) := sorry --non-trivial
lemma new_lemma_77405 (h0 : topological_space (non_assoc_semiring empty)) : loc_path_connected_space (non_assoc_semiring empty) := sorry --non-trivial
lemma new_lemma_77406 (h0 : functor.add_const (topological_space (ring environment.implicit_infer_kind)) pos) : @locally_compact_space.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_77407 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (filter num)) := sorry --non-trivial
lemma new_lemma_77408 (h0 : ring (linear_ordered_field num) -> ring (linear_ordered_field num) -> Prop) : is_symm (ring (linear_ordered_field num)) h0 := sorry --non-trivial
lemma new_lemma_77409 (h0 : not (list (has_star congr_arg_kind) -> false)) : list.nodup (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_77410 (h0 : group (add_comm_monoid (comm_group (has_nndist Type)))) : normalizer_condition (add_comm_monoid (comm_group (has_nndist Type))) := sorry --non-trivial
lemma new_lemma_77411 (h3 : set (std_gen -> linarith.ineq)) : set.separates_points h3 := sorry --non-trivial
lemma new_lemma_77412 (h0 : topological_space (with_bot (has_top num))) : t0_space (with_bot (has_top num)) := sorry --non-trivial
lemma new_lemma_77413 (h0 : topological_space (has_top unsigned)) : totally_disconnected_space (has_top unsigned) := sorry --non-trivial
lemma new_lemma_77414 (h0 : not (add_group (has_div char) -> false)) : @is_add_cyclic.{0} (has_div.{0} char) (@classical.by_contradiction'.{1} (add_group.{0} (has_div.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_77415 (h0 : functor.add_const (topological_space (semigroup pos)) (has_to_string Type)) : @irreducible_space.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (semigroup.{0} pos)) (has_to_string.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_77416 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (sub_neg_monoid.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (sub_neg_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_77417 (h0 : complete_lattice (normed_field (mul_one_class string_imp))) : is_compactly_generated (normed_field (mul_one_class string_imp)) := sorry --non-trivial
lemma new_lemma_77418 (h0 : functor.add_const (topological_space (bin_tree empty)) num) : @t0_space.{0} (bin_tree.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (bin_tree.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_77419 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @totally_separated_space.{0} linarith.comp_source (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_77420 (h0 : topological_space (ring (has_add (has_add Type)))) : irreducible_space (ring (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_77421 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (comm_group.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (comm_group.{0} name))  := sorry --non-trivial
lemma new_lemma_77422 (h0 : functor.comp topological_space has_nndist environment.implicit_infer_kind) : @totally_disconnected_space.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_77423 (h0 : topological_space (sub_neg_monoid (boolean_algebra name))) : normal_space (sub_neg_monoid (boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_77424 (h0 : ring (linear_ordered_add_comm_group (has_nnnorm linarith.comp_source))) : strong_rank_condition (linear_ordered_add_comm_group (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_77425 (h0 : semiring (semiring congr_arg_kind)) : is_noetherian_ring (semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_77426 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} ennreal (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) ennreal)  := sorry --non-trivial
lemma new_lemma_77427 (h0 : ring (has_Inf (has_Inf name))) : rank_condition (has_Inf (has_Inf name)) := sorry --non-trivial
lemma new_lemma_77428 (h0 : has_top (random_gen num) -> Prop) : zzz_forall h0 := sorry --non-trivial
lemma new_lemma_77429 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} environment.implicit_infer_kind (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) environment.implicit_infer_kind)  := sorry --non-trivial
lemma new_lemma_77430 (h1 : topological_space (add_cancel_comm_monoid string_imp)) : totally_disconnected_space (add_cancel_comm_monoid string_imp) := sorry --non-trivial
lemma new_lemma_77431 (h0 : topological_space (boolean_algebra (add_comm_monoid (add_comm_monoid Type)))) : regular_space (boolean_algebra (add_comm_monoid (add_comm_monoid Type))) := sorry --non-trivial
lemma new_lemma_77432 (h0 : pnat -> pnat -> Prop) (h1 : well_founded h0) (h2 h3 : pnat) : pnat.coprime (well_founded.succ h1 h2) h3 := sorry --non-trivial
lemma new_lemma_77433 (h0 : functor.add_const (topological_space (ring pos)) pos) : @preconnected_space.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_77434 (h0 : uniform_space (omega_complete_partial_order (ordered_comm_group (option unsigned)))) : separated_space (omega_complete_partial_order (ordered_comm_group (option unsigned))) := sorry --non-trivial
lemma new_lemma_77435 (h0 : has_mem.mem (has_norm fun_info) has_emptyc.emptyc) : @strong_rank_condition.{0} (has_norm.{0} fun_info) (@finset.pi.empty.{1 0} Type ring.{0} (has_norm.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_77436 (h0 : not (topological_space (fintype (random_gen (random_gen to_additive.value_type))) -> false)) : @totally_disconnected_space.{0} (fintype.{0} (random_gen.{0} (random_gen.{0} to_additive.value_type))) (@classical.by_contradiction'.{1} (topological_space.{0} (fintype.{0} (random_gen.{0} (random_gen.{0} to_additive.value_type)))) h0)  := sorry --non-trivial
lemma new_lemma_77437 (h0 : ring (bin_tree (semiring unsigned))) : strong_rank_condition (bin_tree (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_77438 (h0 : topological_space (has_neg (has_add (normed_comm_ring (has_add name))))) : locally_compact_space (has_neg (has_add (normed_comm_ring (has_add name)))) := sorry --non-trivial
lemma new_lemma_77439 (h0 : group (semigroup (comm_group name))) : is_cyclic (semigroup (comm_group name)) := sorry --non-trivial
lemma new_lemma_77440 (h0 : prod (uniform_space congr_arg_kind) (uniform_space congr_arg_kind)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_77441 (h0 : add_group (ordered_cancel_add_comm_monoid pos)) : is_add_cyclic (ordered_cancel_add_comm_monoid pos) := sorry --non-trivial
lemma new_lemma_77442 (h0 : enat -> enat -> Prop) : is_total enat h0 := sorry --non-trivial
lemma new_lemma_77443 (h0 : functor.add_const (function.extfun Type add_group) (has_Inf pos)) : @is_add_cyclic.{0} pos (@function.extfun_app.{2 1} Type add_group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_group.{0}) (has_Inf.{0} pos) h0) pos)  := sorry --non-trivial
lemma new_lemma_77444 (h0 : nat) (h1 : topological_space (left_cancel_semigroup (array h0 (ordered_cancel_comm_monoid unsigned)))) : locally_compact_space (left_cancel_semigroup (array h0 (ordered_cancel_comm_monoid unsigned))) := sorry --non-trivial
lemma new_lemma_77445 (h1 : uniform_space (has_top congr_arg_kind)) : complete_space (has_top congr_arg_kind) := sorry --non-trivial
lemma new_lemma_77446 (h0 : functor.add_const (topological_space (boolean_algebra Type)) pos) : @t1_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_77447 (h0 : measurable_space (nondiscrete_normed_field fun_info)) (h1 : measure_theory.measure (nondiscrete_normed_field fun_info)) : measure_theory.is_finite_measure h1 := sorry --non-trivial
lemma new_lemma_77448 (h0 : functor.add_const (topological_space (has_neg linarith.comp)) name) : @path_connected_space.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_77449 (h0 : topological_space (has_lt to_additive.value_type)) : totally_disconnected_space (has_lt to_additive.value_type) := sorry --non-trivial
lemma new_lemma_77450 (h0 : list (plift (semiring (semiring empty)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_77451 (h0 : ring (complete_semilattice_Sup (random_gen (random_gen string_imp)))) : rank_condition (complete_semilattice_Sup (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_77452 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (canonically_linear_ordered_monoid.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_linear_ordered_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_77453 (h1 : ring (linear_ordered_add_comm_group char)) : rank_condition (linear_ordered_add_comm_group char) := sorry --non-trivial
lemma new_lemma_77454 (h0 : functor.add_const (ring (has_neg_part ennreal)) pos) : @rank_condition.{0} (has_neg_part.{0} ennreal) (@functor.add_const.run.{0 0} (ring.{0} (has_neg_part.{0} ennreal)) pos h0)  := sorry --non-trivial
lemma new_lemma_77455 (h0 : functor.comp ring finset pos) : @is_domain.{0} (finset.{0} pos) (@functor.comp.run.{0 0 0} ring.{0} finset.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_77456 (h0 : topological_space (ordered_comm_monoid (has_Inf (has_add linarith.comp)))) : regular_space (ordered_comm_monoid (has_Inf (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_77457 (h0 : uniform_space (semi_normed_ring (normed_group reducibility_hints))) : complete_space (semi_normed_ring (normed_group reducibility_hints)) := sorry --non-trivial
lemma new_lemma_77458 (h0 : functor.add_const (topological_space (semigroup linarith.comp)) (has_Inf (finset linarith.comp))) : @sequential_space.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} linarith.comp)) (has_Inf.{0} (finset.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_77459 (h0 : not (ring (add_left_cancel_monoid to_additive.value_type) -> false)) : @rank_condition.{0} (add_left_cancel_monoid.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (add_left_cancel_monoid.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_77460 (h0 : functor.add_const (topological_space (has_neg linarith.comp)) pos) : @loc_path_connected_space.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_77461 (h0 : filter (has_norm (random_gen linarith.ineq))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_77462 (h0 : functor.add_const (topological_space (measurable_space.dynkin_system num)) congr_arg_kind) : @totally_disconnected_space.{0} (measurable_space.dynkin_system.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (measurable_space.dynkin_system.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_77463 (h0 : topological_space (ordered_comm_monoid (ring (has_neg linarith.comp)))) : preirreducible_space (ordered_comm_monoid (ring (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_77464 (h0 : monoid (has_norm (random_gen fun_info))) : monoid.fg (has_norm (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_77465 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (linear_ordered_comm_ring.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (linear_ordered_comm_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_77466 (h3 : topological_space (mul_one_class (mul_one_class fun_info))) : path_connected_space (mul_one_class (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_77467 (h1 : add_group (encodable (has_ssubset (dlist (free_add_monoid (div_inv_monoid linarith.ineq)))))) : is_add_cyclic (encodable (has_ssubset (dlist (free_add_monoid (div_inv_monoid linarith.ineq))))) := sorry --non-trivial
lemma new_lemma_77468 (h0 h1 : list (has_ssubset (mul_one_class fun_info))) : list.is_rotated h0 h1 := sorry --non-trivial
lemma new_lemma_77469 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (has_zero.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_zero.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_77470 (h0 : topological_space (has_bot (has_neg (has_neg Type)))) : locally_compact_space (has_bot (has_neg (has_neg Type))) := sorry --non-trivial
lemma new_lemma_77471 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_77472 (h1 : add_group (topological_space to_additive.value_type)) : is_add_cyclic (topological_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_77473 (h0 : ring (comm_semigroup (sub_neg_monoid Type))) : rank_condition (comm_semigroup (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_77474 (h0 : ordered_add_comm_monoid (has_neg_part (option (cancel_monoid name)))) : archimedean (has_neg_part (option (cancel_monoid name))) := sorry --non-trivial
lemma new_lemma_77475 (h0 : topological_space (canonically_linear_ordered_monoid (finset pos))) : path_connected_space (canonically_linear_ordered_monoid (finset pos)) := sorry --non-trivial
lemma new_lemma_77476 (h1 : has_le (add_comm_semigroup linarith.ineq)) (h2 : add_comm_semigroup linarith.ineq) : is_bot h2 := sorry --non-trivial
lemma new_lemma_77477 (h1 : filter (encodable char)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_77478 (h0 : topological_space (random_gen empty)) : t0_space (random_gen empty) := sorry --non-trivial
lemma new_lemma_77479 (h0 : not (complete_lattice (encodable string_imp) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (encodable.{0} string_imp) (@classical.by_contradiction'.{1} (complete_lattice.{0} (encodable.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_77480 (h0 : add_group (complete_linear_order (semiring (semiring (semiring (semiring congr_arg_kind)))))) : is_add_cyclic (complete_linear_order (semiring (semiring (semiring (semiring congr_arg_kind))))) := sorry --non-trivial
lemma new_lemma_77481 (h3 : function.extfun Type topological_space) : @t0_space.{0} linarith.comp_source (@function.extfun_app.{2 1} Type topological_space.{0} h3 linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_77482 (h0 : semiring (is_R_or_C empty)) : is_noetherian_ring (is_R_or_C empty) := sorry --non-trivial
lemma new_lemma_77483 (h0 : list (has_emptyc linarith.ineq)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_77484 (h0 : topological_space (normed_comm_ring (has_add environment.implicit_infer_kind))) : discrete_topology (normed_comm_ring (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_77485 (h0 : topological_space (with_bot (has_norm (has_norm linarith.comp)))) : totally_disconnected_space (with_bot (has_norm (has_norm linarith.comp))) := sorry --non-trivial
lemma new_lemma_77486 (h0 : topological_space (comm_semigroup pos)) : preirreducible_space (comm_semigroup pos) := sorry --non-trivial
lemma new_lemma_77487 (h0 : functor.add_const (monoid (has_neg_part name)) (has_add Type)) : @monoid.fg.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 1} (monoid.{0} (has_neg_part.{0} name)) (has_add.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_77488 (h0 : topological_space (comm_semigroup (sub_neg_monoid (comm_semigroup pos)))) : totally_disconnected_space (comm_semigroup (sub_neg_monoid (comm_semigroup pos))) := sorry --non-trivial
lemma new_lemma_77489 (h0 : functor.add_const (topological_space (add_group unsigned)) unsigned) : @preirreducible_space.{0} (add_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_group.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_77490 (h0 : pnat) (h1 : thunk pnat) : pnat.coprime (@id.{1} pnat h0) (@trace_call_stack.{0} pnat h1)  := sorry --non-trivial
lemma new_lemma_77491 (h0 : topological_space (div_inv_monoid linarith.ineq)) : t0_space (div_inv_monoid linarith.ineq) := sorry --non-trivial
lemma new_lemma_77492 (h1 : list char) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_77493 (h0 : topological_space (has_Inf (ring Type))) : preirreducible_space (has_Inf (ring Type)) := sorry --non-trivial
lemma new_lemma_77494 (h0 : complete_lattice (distrib (mul_one_class (random_gen (mul_one_class reducibility_hints))))) : is_compactly_generated (distrib (mul_one_class (random_gen (mul_one_class reducibility_hints)))) := sorry --non-trivial
lemma new_lemma_77495 (h0 : add_group (has_lt empty)) : is_add_cyclic (has_lt empty) := sorry --non-trivial
lemma new_lemma_77496 (h0 : functor.add_const (semiring Type) Type) : @is_noetherian_ring.{1} Type (@functor.add_const.run.{1 1} (semiring.{1} Type) Type h0)  := sorry --non-trivial
lemma new_lemma_77497 (h0 : functor.add_const (ordered_add_comm_monoid (finset unsigned)) Type) : @archimedean.{0} (finset.{0} unsigned) (@functor.add_const.run.{0 1} (ordered_add_comm_monoid.{0} (finset.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_77498 (h0 : functor.add_const (cancel_comm_monoid_with_zero (partial_order unsigned)) unsigned) : @unique_factorization_monoid.{0} (partial_order.{0} unsigned) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (partial_order.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_77499 (h0 : cancel_comm_monoid_with_zero (add_cancel_monoid congr_arg_kind)) : unique_factorization_monoid (add_cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_77500 (h0 : preorder (add_comm_semigroup string.iterator_imp)) (h2 : Prop) : set.is_pwo (id (fun (h1 : add_comm_semigroup string.iterator_imp), h2)) := sorry --non-trivial
lemma new_lemma_77501 (h0 : ordered_add_comm_monoid (comm_group (option (option unsigned)))) : archimedean (comm_group (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_77502 (h0 : add_group (add_comm_monoid (option (option (option unsigned))))) : is_add_cyclic (add_comm_monoid (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_77503 (h0 : ring (distrib_lattice linarith.comp_source)) : rank_condition (distrib_lattice linarith.comp_source) := sorry --non-trivial
lemma new_lemma_77504 (h0 : topological_space (has_bot (has_bot linarith.comp))) : t0_space (has_bot (has_bot linarith.comp)) := sorry --non-trivial
lemma new_lemma_77505 (h0 : has_add Type -> linarith.comp -> Prop) : relator.bi_total h0 := sorry --non-trivial
lemma new_lemma_77506 (h0 : complete_lattice (cancel_monoid Type)) : is_atomistic (cancel_monoid Type) := sorry --non-trivial
lemma new_lemma_77507 (h0 : not (function.extfun Type filter -> false)) : filter.ne_bot (function.extfun_app (classical.by_contradiction' h0) (random_gen unsigned)) := sorry --non-trivial
lemma new_lemma_77508 (h0 : functor.comp topological_space boolean_algebra Type) : @normal_space.{1} (boolean_algebra.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} boolean_algebra.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_77509 (h0 : semiring (has_Inf Type)) : is_noetherian_ring (has_Inf Type) := sorry --non-trivial
lemma new_lemma_77510 (h0 : topological_space (has_neg_part (finset unsigned))) : normal_space (has_neg_part (finset unsigned)) := sorry --non-trivial
lemma new_lemma_77511 (h0 : not (function.extfun Type topological_space -> false)) : @preirreducible_space.{0} (has_sub.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_sub.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_77512 (h0 : cancel_comm_monoid_with_zero (group_with_zero unsigned)) : unique_factorization_monoid (group_with_zero unsigned) := sorry --non-trivial
lemma new_lemma_77513 (h0 : finset (has_add pos)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_77514 (h0 : ring (comm_monoid congr_arg_kind)) : is_domain (comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_77515 (h0 : functor.add_const (finset (add_comm_monoid real)) linarith.comp) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_77516 (h0 : functor.add_const (complete_lattice (has_add linarith.comp)) linarith.comp) : @is_compactly_generated.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_add.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_77517 (h0 : multiset Prop) (h1 : Prop) : @multiset.inf.{0} Prop (@lattice.to_semilattice_inf.{0} Prop (@conditionally_complete_lattice.to_lattice.{0} Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice))) (@bounded_order.to_order_top.{0} Prop (@preorder.to_has_le.{0} Prop (@partial_order.to_preorder.{0} Prop (@semilattice_inf.to_partial_order.{0} Prop (@lattice.to_semilattice_inf.{0} Prop (@conditionally_complete_lattice.to_lattice.{0} Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice)))))) Prop.bounded_order) (@multiset.erase.{0} Prop (λ (a b : Prop), @eq.decidable.{0} Prop Prop.linear_order a b) h0 h1)  := sorry --non-trivial
lemma new_lemma_77518 (h0 : topological_space (normed_comm_ring (has_add (finset (finset pos))))) : preirreducible_space (normed_comm_ring (has_add (finset (finset pos)))) := sorry --non-trivial
lemma new_lemma_77519 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @strong_rank_condition.{1} (has_pos_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ring.{1}) (has_pos_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_77520 (h0 : topological_space (has_Inf (has_pos_part linarith.comp))) : loc_path_connected_space (has_Inf (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_77521 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (has_top.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_top.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_77522 (h0 : ring (semigroup (finset environment.implicit_infer_kind))) : is_domain (semigroup (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_77523 (h0 : topological_space (with_bot (has_norm string_imp))) : irreducible_space (with_bot (has_norm string_imp)) := sorry --non-trivial
lemma new_lemma_77524 (h0 : functor.add_const (add_monoid (mul_zero_class empty)) unsigned) : @add_monoid.fg.{0} (mul_zero_class.{0} empty) (@functor.add_const.run.{0 0} (add_monoid.{0} (mul_zero_class.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_77525 (h0 : ring (has_neg environment.implicit_infer_kind)) : is_domain (has_neg environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_77526 (h0 : group (has_to_string (has_add (has_add (has_add Type))))) : is_cyclic (has_to_string (has_add (has_add (has_add Type)))) := sorry --non-trivial
lemma new_lemma_77527 (h0 : group (comm_ring (random_gen char))) : is_cyclic (comm_ring (random_gen char)) := sorry --non-trivial
lemma new_lemma_77528 (h0 : not (group (complete_semilattice_Sup linarith.comp) -> false)) : @group.fg.{0} (complete_semilattice_Sup.{0} linarith.comp) (@classical.by_contradiction'.{1} (group.{0} (complete_semilattice_Sup.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_77529 (h0 : functor.add_const (list (has_Inf pos)) Type) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_77530 (h0 : monoid (random_gen (has_norm num))) : monoid.fg (random_gen (has_norm num)) := sorry --non-trivial
lemma new_lemma_77531 (h0 : topological_space (measurable_space.dynkin_system linarith.comp)) (h1 : has_inf (measurable_space.dynkin_system linarith.comp)) : has_continuous_inf (measurable_space.dynkin_system linarith.comp) := sorry --non-trivial
lemma new_lemma_77532 (h0 : semiring (linear_ordered_cancel_comm_monoid unsigned)) : is_noetherian_ring (linear_ordered_cancel_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_77533 (h0 : finset (option (semiring unsigned))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_77534 (h0 : finset (has_dist (option unsigned))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_77535 (h0 : functor.add_const (ring (ordered_comm_ring pos)) (has_Inf (has_neg linarith.comp))) : @strong_rank_condition.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (ordered_comm_ring.{0} pos)) (has_Inf.{0} (has_neg.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_77536 (h0 : topological_space (ordered_comm_monoid linarith.comp)) : t0_space (ordered_comm_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_77537 (h0 : group (has_norm linarith.comp)) : normalizer_condition (has_norm linarith.comp) := sorry --non-trivial
lemma new_lemma_77538 (h0 : functor.add_const (topological_space (linear_ordered_field ennreal)) unsigned) : @irreducible_space.{0} (linear_ordered_field.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_field.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_77539 (h0 : list (ring (option ennreal))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_77540 (h0 : filter (canonically_ordered_comm_semiring congr_arg_kind)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_77541 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_inter.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_inter.{0} num))  := sorry --non-trivial
lemma new_lemma_77542 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (denumerable.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (denumerable.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_77543 (h0 : uniform_space (has_Inf (has_Inf linarith.comp))) : separated_space (has_Inf (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_77544 (h0 : set (add_comm_semigroup (add_comm_semigroup string.iterator_imp) -> linarith.ineq)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_77545 (h0 : topological_space (measurable_space (random_gen (random_gen congr_arg_kind)))) : t0_space (measurable_space (random_gen (random_gen congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_77546 (h0 : topological_space (denumerable (random_gen linarith.ineq))) : totally_separated_space (denumerable (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_77547 (h1 : function.extfun Type uniform_space) : @complete_space.{0} congr_arg_kind (@function.extfun_app.{2 1} Type uniform_space.{0} h1 congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_77548 (h0 : functor.add_const (group (semigroup linarith.comp)) pos) : @is_cyclic.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (semigroup.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_77549 (h0 : semiring (add_cancel_monoid pos)) : is_noetherian_ring (add_cancel_monoid pos) := sorry --non-trivial
lemma new_lemma_77550 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (mul_zero_class.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (mul_zero_class.{0} num))  := sorry --non-trivial
lemma new_lemma_77551 (h0 : uniform_space (has_bot empty)) : separated_space (has_bot empty) := sorry --non-trivial
lemma new_lemma_77552 (h0 : semiring (group_with_zero (has_to_string congr_arg_kind))) : is_noetherian_ring (group_with_zero (has_to_string congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_77553 (h0 : not (function.extfun Type topological_space -> false)) : @totally_separated_space.{0} (mul_zero_class.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (mul_zero_class.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_77554 (h0 : list (semigroup ennreal)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_77555 (h1 : function.extfun Type topological_space) : @t0_space.{0} (distrib_lattice.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (distrib_lattice.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_77556 (h0 : functor.add_const (monoid (has_neg (has_neg_part environment.implicit_infer_kind))) linarith.comp) : @monoid.fg.{0} (has_neg.{0} (has_neg_part.{0} environment.implicit_infer_kind)) (@functor.add_const.run.{0 0} (monoid.{0} (has_neg.{0} (has_neg_part.{0} environment.implicit_infer_kind))) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_77557 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem group)) : @normalizer_condition.{0} (normed_group.{0} empty) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) group.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (normed_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_77558 (h0 : topological_space (cancel_monoid (has_neg (semigroup name)))) : preconnected_space (cancel_monoid (has_neg (semigroup name))) := sorry --non-trivial
lemma new_lemma_77559 (h0 : topological_space (ordered_ring unsigned)) : normal_space (ordered_ring unsigned) := sorry --non-trivial
lemma new_lemma_77560 (h0 : functor.add_const Prop (has_union linarith.comp)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_77561 (h0 : fin has_zero.zero) : @is_atomistic.{1} (ordered_comm_ring.{1} Type) (@matrix.vec_empty.{1} (complete_lattice.{1} (ordered_comm_ring.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_77562 (h0 : topological_space (has_add (normed_comm_ring pos))) : topological_space.separable_space (has_add (normed_comm_ring pos)) := sorry --non-trivial
lemma new_lemma_77563 (h0 : fintype char) (h1 : comm_ring char) (h2 : matrix char char char) : matrix.nondegenerate h2 := sorry --non-trivial
lemma new_lemma_77564 (h0 : semiring (cancel_monoid (finset pos))) : is_noetherian_ring (cancel_monoid (finset pos)) := sorry --non-trivial
lemma new_lemma_77565 (h0 : complete_lattice (finset (encodable (has_add name)))) : is_atomistic (finset (encodable (has_add name))) := sorry --non-trivial
lemma new_lemma_77566 (h0 : functor.add_const (topological_space (ordered_comm_ring Type)) (has_add name)) : @irreducible_space.{1} (ordered_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ordered_comm_ring.{1} Type)) (has_add.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_77567 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (has_dist empty)) := sorry --non-trivial
lemma new_lemma_77568 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (has_union.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_union.{0} empty))  := sorry --non-trivial
lemma new_lemma_77569 (h0 : functor.add_const (cancel_comm_monoid_with_zero (preorder num)) num) : @unique_factorization_monoid.{0} (preorder.{0} num) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (preorder.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_77570 (h0 : topological_space (plift num)) : normal_space (plift num) := sorry --non-trivial
lemma new_lemma_77571 (h0 : add_monoid (add_semigroup (option empty))) : add_monoid.fg (add_semigroup (option empty)) := sorry --non-trivial
lemma new_lemma_77572 (h1 : topological_space (ordered_comm_monoid string_imp)) : t0_space (ordered_comm_monoid string_imp) := sorry --non-trivial
lemma new_lemma_77573 (h0 : topological_space (add_comm_monoid (has_neg (normed_comm_ring Type)))) : loc_path_connected_space (add_comm_monoid (has_neg (normed_comm_ring Type))) := sorry --non-trivial
lemma new_lemma_77574 (h0 : not (has_mem.mem (has_emptyc linarith.ineq) has_emptyc.emptyc -> false)) : @totally_disconnected_space.{0} (has_emptyc.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_emptyc.{0} linarith.ineq) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_emptyc.{0} linarith.ineq) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_77575 (h0 : topological_space (has_bot (has_pos_part pos))) : discrete_topology (has_bot (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_77576 (h0 : topological_space (add_cancel_monoid name)) : normal_space (add_cancel_monoid name) := sorry --non-trivial
lemma new_lemma_77577 (h0 : has_mem.mem (random_gen (has_ssubset fun_info)) has_emptyc.emptyc) : @rank_condition.{0} (random_gen.{0} (has_ssubset.{0} fun_info)) (@finset.pi.empty.{1 0} Type ring.{0} (random_gen.{0} (has_ssubset.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_77578 (h0 : topological_space (complete_distrib_lattice (option congr_arg_kind))) : t0_space (complete_distrib_lattice (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_77579 (h0 : ring (finset (has_add Type))) : is_principal_ideal_ring (finset (has_add Type)) := sorry --non-trivial
lemma new_lemma_77580 (h0 : group (measurable_space (has_top (random_gen linarith.ineq)))) : is_cyclic (measurable_space (has_top (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_77581 (h0 : functor.add_const (function.extfun (Type 1) ordered_comm_monoid) linarith.comp) : @has_exists_mul_of_le.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_comm_monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ordered_comm_monoid.{1}) linarith.comp h0) (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_77582 (h0 : semiring (sub_neg_monoid pos)) : is_noetherian_ring (sub_neg_monoid pos) := sorry --non-trivial
lemma new_lemma_77583 (h0 : function.extfun (Type 1) semiring) : @is_noetherian_ring.{1} (simple_graph.{1} Type) (@function.extfun_app.{3 2} (Type 1) semiring.{1} h0 (simple_graph.{1} Type))  := sorry --non-trivial
lemma new_lemma_77584 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (normed_comm_ring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_comm_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_77585 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (simple_graph empty)) := sorry --non-trivial
lemma new_lemma_77586 (h0 : ring (has_nndist (finset (has_add (finset Type))))) : rank_condition (has_nndist (finset (has_add (finset Type)))) := sorry --non-trivial
lemma new_lemma_77587 (h0 : group (id (random_gen to_additive.value_type))) : normalizer_condition (id (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_77588 (h0 : ring (with_bot (random_gen linarith.comp_source))) : rank_condition (with_bot (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_77589 (h0 : linarith.comp_source -> linarith.comp_source) (h1 : linarith.comp_source) : function.periodic_pts h0 h1 := sorry --non-trivial
lemma new_lemma_77590 (h0 : function.extfun Type (functor.add_const (ordered_add_comm_monoid pos))) : @archimedean.{0} pos (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} pos) pos (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ordered_add_comm_monoid.{0} pos)) h0 pos))  := sorry --non-trivial
lemma new_lemma_77591 (h0 : function.extfun Type group) : @group.fg.{0} (bin_tree.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (bin_tree.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_77592 (h1 : topological_space (has_compl to_additive.value_type)) : t0_space (has_compl to_additive.value_type) := sorry --non-trivial
lemma new_lemma_77593 (h0 : topological_space (add_cancel_monoid (has_add (has_Inf pos)))) : totally_disconnected_space (add_cancel_monoid (has_add (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_77594 (h0 : function.extfun (finset Type) (has_mem.mem (has_emptyc to_additive.value_type))) : @irreducible_space.{0} (has_emptyc.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_emptyc.{0} to_additive.value_type) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_emptyc.{0} to_additive.value_type)) (@id.{0} (function.extfun.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_emptyc.{0} to_additive.value_type))) h0) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_77595 (h0 : topological_space (add_comm_monoid pos)) : totally_disconnected_space (add_comm_monoid pos) := sorry --non-trivial
lemma new_lemma_77596 (h0 : group (linear_ordered_cancel_comm_monoid congr_arg_kind)) : group.fg (linear_ordered_cancel_comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_77597 (h0 : ring (semi_normed_ring (mul_one_class environment.projection_info))) : is_domain (semi_normed_ring (mul_one_class environment.projection_info)) := sorry --non-trivial
lemma new_lemma_77598 (h0 : ring (mul_zero_class (has_neg_part (has_nndist (boolean_algebra.core unsigned))))) : is_domain (mul_zero_class (has_neg_part (has_nndist (boolean_algebra.core unsigned)))) := sorry --non-trivial
lemma new_lemma_77599 (h0 : functor.add_const (topological_space Type) (finset pos)) : @path_connected_space.{1} Type (@functor.add_const.run.{1 0} (topological_space.{1} Type) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_77600 (h0 : topological_space (comm_group (has_add (has_add (has_add linarith.comp))))) : locally_compact_space (comm_group (has_add (has_add (has_add linarith.comp)))) := sorry --non-trivial
lemma new_lemma_77601 (h0 : topological_space (semigroup (finset (has_add (finset pos))))) : normal_space (semigroup (finset (has_add (finset pos)))) := sorry --non-trivial
lemma new_lemma_77602 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (has_norm.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_norm.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_77603 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (partial_order num)) := sorry --non-trivial
lemma new_lemma_77604 (h0 : functor.add_const (function.extfun (Type 1) monoid) (has_add Type)) : @monoid.fg.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) monoid.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) monoid.{1}) (has_add.{1} Type) h0) (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_77605 (h1 : not (add_group (fintype char) -> false)) : @is_add_cyclic.{0} (fintype.{0} char) (@classical.by_contradiction'.{1} (add_group.{0} (fintype.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_77606 (h0 : topological_space (linear_ordered_cancel_comm_monoid (option unsigned))) : loc_path_connected_space (linear_ordered_cancel_comm_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_77607 (h0 : topological_space (has_top (has_inv char))) : t0_space (has_top (has_inv char)) := sorry --non-trivial
lemma new_lemma_77608 (h0 : group (ordered_comm_monoid (has_add (has_pos_part pos)))) : is_cyclic (ordered_comm_monoid (has_add (has_pos_part pos))) := sorry --non-trivial
lemma new_lemma_77609 (h0 : functor.add_const (ring (has_to_string unsigned)) Type) : @rank_condition.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 1} (ring.{0} (has_to_string.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_77610 (h0 : not (complete_lattice (random_gen linarith.ineq) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (random_gen.{0} linarith.ineq) (@classical.by_contradiction'.{1} (complete_lattice.{0} (random_gen.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_77611 (h0 : filter (pseudo_metric_space unsigned)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_77612 (h0 : not (uniform_space (has_one empty) -> false)) : @complete_space.{0} (has_one.{0} empty) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_one.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_77613 (h0 : set (string.iterator_imp -> fun_info)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_77614 (h0 : topological_space (has_top (has_ssubset char))) : t0_space (has_top (has_ssubset char)) := sorry --non-trivial
lemma new_lemma_77615 (h0 : complete_lattice (random_gen (random_gen linarith.comp_source))) : complete_lattice.is_Sup_finite_compact (random_gen (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_77616 (h0 : functor.add_const (topological_space (has_zero pos)) environment.implicit_infer_kind) : @sequential_space.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_77617 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @unique_factorization_monoid.{1} (add_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 cancel_comm_monoid_with_zero.{1}) (add_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_77618 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (ordered_comm_group.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (ordered_comm_group.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_77619 (h0 : not (filter (comm_ring linarith.comp_source) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_77620 (h0 : ordered_comm_monoid (has_pos_part (has_add (has_pos_part (has_add linarith.comp))))) : has_exists_mul_of_le (has_pos_part (has_add (has_pos_part (has_add linarith.comp)))) := sorry --non-trivial
lemma new_lemma_77621 (h0 : add_monoid (has_nndist (has_to_string Type))) : add_monoid.fg (has_nndist (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_77622 (h0 : topological_space (plift (semiring num))) : t1_space (plift (semiring num)) := sorry --non-trivial
lemma new_lemma_77623 (h0 : topological_space (add_cancel_comm_monoid (mul_one_class char))) : path_connected_space (add_cancel_comm_monoid (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_77624 (h0 : monoid (ring (has_add Type))) : monoid.fg (ring (has_add Type)) := sorry --non-trivial
lemma new_lemma_77625 (h0 : fin has_zero.zero) : @path_connected_space.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@matrix.vec_empty.{2} (function.extfun.{3 2} (Type 1) topological_space.{1}) h0) (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_77626 (h0 : functor.add_const (function.extfun (Type 1) complete_lattice) name) : @complete_lattice.is_Sup_finite_compact.{1} (simple_graph.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) complete_lattice.{1}) name h0) (simple_graph.{1} Type))  := sorry --non-trivial
lemma new_lemma_77627 (h0 : functor.add_const (function.extfun (Type 1) topological_space) (has_pos_part (has_to_string linarith.comp))) : @preirreducible_space.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) (has_pos_part.{0} (has_to_string.{0} linarith.comp)) h0) (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_77628 (h0 : topological_space (measurable_space (has_norm congr_arg_kind))) : discrete_topology (measurable_space (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_77629 (h0 : functor.add_const (function.extfun (Type 1) topological_space) Type) : @t0_space.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) Type h0) (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_77630 (h0 : finset ereal) (h1 : ereal) : set.sInter (finset.inf h0) h1 := sorry --non-trivial
lemma new_lemma_77631 (h1 : complete_lattice (semi_normed_comm_ring (semi_normed_ring char))) : is_compactly_generated (semi_normed_comm_ring (semi_normed_ring char)) := sorry --non-trivial
lemma new_lemma_77632 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @totally_separated_space.{1} (normed_lattice_add_comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (normed_lattice_add_comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_77633 (h0 : uniform_space (ordered_comm_ring (finset (has_Inf (ring (ring (has_nndist (ring (ring Type))))))))) : separated_space (ordered_comm_ring (finset (has_Inf (ring (ring (has_nndist (ring (ring Type)))))))) := sorry --non-trivial
lemma new_lemma_77634 (h0 : not (has_mem.mem uniform_space has_emptyc.emptyc -> false)) : @complete_space.{0} (with_one.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type uniform_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) uniform_space.{0} (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) uniform_space.{0} (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type)))) h0)) (with_one.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_77635 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @t0_space.{0} (has_inv.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (has_inv.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_77636 (h0 : topological_space (complete_distrib_lattice (option (option congr_arg_kind)))) : preirreducible_space (complete_distrib_lattice (option (option congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_77637 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @totally_disconnected_space.{0} (linear_ordered_add_comm_group.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) topological_space.{0}) (linear_ordered_add_comm_group.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_77638 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (ordered_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (ordered_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_77639 (h0 : filter (has_add num)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_77640 (h0 : functor.add_const (topological_space (finset linarith.comp)) Type) : @locally_compact_space.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (finset.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_77641 (h0 : topological_space (random_gen (random_gen string_imp))) : totally_disconnected_space (random_gen (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_77642 (h0 : functor.add_const (topological_space (comm_group unsigned)) name) : @totally_disconnected_space.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_77643 (h0 : uniform_space (has_inv (comm_ring to_additive.value_type))) : complete_space (has_inv (comm_ring to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_77644 (h0 : functor.add_const (topological_space (boolean_algebra Type)) name) : @t0_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_77645 (h0 : function.extfun nat fin) : @add_monoid.fg.{0} (has_pos_part.{0} linarith.comp) (@matrix.vec_empty.{0} (add_monoid.{0} (has_pos_part.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_77646 (h0 : not (function.extfun Type ring -> false)) : @strong_rank_condition.{0} (with_bot.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (with_bot.{0} num))  := sorry --non-trivial
lemma new_lemma_77647 (h1 : group (has_nnnorm string_imp)) : is_cyclic (has_nnnorm string_imp) := sorry --non-trivial
lemma new_lemma_77648 (h0 : ordered_add_comm_monoid (add_cancel_comm_monoid (option empty))) : archimedean (add_cancel_comm_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_77649 (h1 : group (denumerable string_imp)) : group.fg (denumerable string_imp) := sorry --non-trivial
lemma new_lemma_77650 (h0 : group (mul_zero_class unsigned)) : normalizer_condition (mul_zero_class unsigned) := sorry --non-trivial
lemma new_lemma_77651 (h0 : topological_space (canonically_linear_ordered_monoid (has_pos_part real))) : preconnected_space (canonically_linear_ordered_monoid (has_pos_part real)) := sorry --non-trivial
lemma new_lemma_77652 (h0 : ring (distrib (has_ssubset fun_info))) : is_domain (distrib (has_ssubset fun_info)) := sorry --non-trivial
lemma new_lemma_77653 (h0 : topological_space (has_pos_part pos)) : path_connected_space (has_pos_part pos) := sorry --non-trivial
lemma new_lemma_77654 (h0 : monoid (has_Inf linarith.comp)) : monoid.fg (has_Inf linarith.comp) := sorry --non-trivial
lemma new_lemma_77655 (h0 : measurable_space (mul_one_class (mul_one_class (add_comm_semigroup std_gen)))) (h1 : measure_theory.measure (mul_one_class (mul_one_class (add_comm_semigroup std_gen)))) : measure_theory.is_finite_measure h1 := sorry --non-trivial
lemma new_lemma_77656 (h0 : group (normed_lattice_add_comm_group Type)) : is_simple_group (normed_lattice_add_comm_group Type) := sorry --non-trivial
lemma new_lemma_77657 (h0 : filter (distrib_lattice (has_norm (random_gen string_imp)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_77658 (h0 : function.extfun (Type 1) (functor.comp topological_space finset)) : @preirreducible_space.{1} (finset.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} finset.{1} Type (@function.extfun_app.{3 2} (Type 1) (functor.comp.{1 1 1} topological_space.{1} finset.{1}) h0 Type))  := sorry --non-trivial
lemma new_lemma_77659 (h0 : function.extfun Type (prod (ordered_ring empty))) : id_rel (function.extfun_app h0 (ordered_ring empty)) := sorry --non-trivial
lemma new_lemma_77660 (h0 : not (topological_space (has_append linarith.comp_source) -> false)) : @totally_disconnected_space.{0} (has_append.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (has_append.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_77661 (h0 : ring (boolean_algebra.core (has_add (has_add (finset ennreal))))) : strong_rank_condition (boolean_algebra.core (has_add (has_add (finset ennreal)))) := sorry --non-trivial
lemma new_lemma_77662 (h0 : functor.add_const (topological_space (has_to_string unsigned)) linarith.comp) : @preconnected_space.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_77663 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_dist.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_dist.{0} empty))  := sorry --non-trivial
lemma new_lemma_77664 (h0 : ring (has_star (semiring (semiring (semiring empty))))) : strong_rank_condition (has_star (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_77665 (h0 : uniform_space fun_info) : complete_space fun_info := sorry --non-trivial
lemma new_lemma_77666 (h0 : topological_space (boolean_algebra (has_neg linarith.comp))) : loc_path_connected_space (boolean_algebra (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_77667 (h0 : functor.add_const (topological_space (semigroup name)) name) : @totally_disconnected_space.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_77668 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (boolean_algebra.core.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} real))  := sorry --non-trivial
lemma new_lemma_77669 (h0 : group (dlist (random_gen (has_nnnorm fun_info)))) : is_cyclic (dlist (random_gen (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_77670 (h1 : topological_space (has_le linarith.ineq)) (h2 : preorder (has_le linarith.ineq)) : order_closed_topology (has_le linarith.ineq) := sorry --non-trivial
lemma new_lemma_77671 (h0 : ring (has_norm (has_top num))) : rank_condition (has_norm (has_top num)) := sorry --non-trivial
lemma new_lemma_77672 (h0 : function.extfun (finset Type) (has_mem.mem linarith.comp)) : @strong_rank_condition.{0} linarith.comp (@finset.pi.empty.{1 0} Type ring.{0} linarith.comp (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) linarith.comp) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_77673 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (add_cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type add_group.{0} h0 (add_cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_77674 (h0 : functor.add_const (group (ring Type)) (ring pos)) : @group.fg.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (ring.{1} Type)) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_77675 (h0 : functor.add_const (monoid (add_comm_monoid num)) empty) : @monoid.fg.{0} (add_comm_monoid.{0} num) (@functor.add_const.run.{0 0} (monoid.{0} (add_comm_monoid.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_77676 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (ring.{0} (option.{0} ennreal)) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ring.{0} (option.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_77677 (h0 : group (simple_graph (ring (ring (ring pos))))) : normalizer_condition (simple_graph (ring (ring (ring pos)))) := sorry --non-trivial
lemma new_lemma_77678 (h0 : group (encodable (has_top linarith.ineq))) : is_cyclic (encodable (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_77679 (h0 : topological_space (boolean_algebra.core (comm_group Type))) : locally_compact_space (boolean_algebra.core (comm_group Type)) := sorry --non-trivial
lemma new_lemma_77680 (h0 : filter (comm_ring (random_gen linarith.comp_source))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_77681 (h0 : functor.add_const (complete_lattice (mul_zero_class empty)) (semiring num)) : @is_compactly_generated.{0} (mul_zero_class.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (mul_zero_class.{0} empty)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_77682 (h0 : topological_space (has_compl (has_nnnorm (has_nnnorm linarith.comp_source)))) : path_connected_space (has_compl (has_nnnorm (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_77683 (h0 : functor.add_const (topological_space (has_to_string linarith.comp)) Type) : @t1_space.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_to_string.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_77684 (h0 : functor.comp filter has_neg_part ennreal) : countable_Inter_filter (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_77685 (h0 : function.extfun (Type 1) group) : @group.fg.{1} (add_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} h0 (add_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_77686 (h0 : complete_lattice (distrib string.iterator_imp)) : complete_lattice.is_Sup_finite_compact (distrib string.iterator_imp) := sorry --non-trivial
lemma new_lemma_77687 (h0 : functor.add_const (topological_space (has_to_string name)) Type) : @t1_space.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (has_to_string.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_77688 (h0 : ring (id linarith.comp)) : rank_condition (id linarith.comp) := sorry --non-trivial
lemma new_lemma_77689 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_77690 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (ordered_cancel_add_comm_monoid.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (ordered_cancel_add_comm_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_77691 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (normed_lattice_add_comm_group.{0} real) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (normed_lattice_add_comm_group.{0} real))  := sorry --non-trivial
lemma new_lemma_77692 (h0 : uniform_space (semigroup pos)) : separated_space (semigroup pos) := sorry --non-trivial
lemma new_lemma_77693 (h0 h1 : multiset (nondiscrete_normed_field string.iterator_imp)) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_77694 (h0 : cancel_comm_monoid_with_zero (has_to_string (has_add (finset (finset pos))))) : unique_factorization_monoid (has_to_string (has_add (finset (finset pos)))) := sorry --non-trivial
lemma new_lemma_77695 (h0 : function.extfun nat fin) : @discrete_topology.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_77696 (h0 : function.extfun Type topological_space) : @t0_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_77697 (h0 : false) : @Lim.{0} Prop sierpinski_space (@nonempty_of_inhabited.{1} Prop sort.inhabited.{0}) (@false.elim.{1} (filter.{0} Prop) h0)  := sorry --trivial
lemma new_lemma_77698 (h0 : complete_lattice (measurable_space (has_inv linarith.comp_source))) : is_atomistic (measurable_space (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_77699 (h2 : comm_semiring (add_comm_semigroup (mul_one_class enat))) (h3 : ideal (add_comm_semigroup (mul_one_class enat))) : ideal.is_primary h3 := sorry --non-trivial
lemma new_lemma_77700 (h1 : topological_space (has_ssubset (random_gen (random_gen (random_gen (random_gen reducibility_hints)))))) : t0_space (has_ssubset (random_gen (random_gen (random_gen (random_gen reducibility_hints))))) := sorry --non-trivial
lemma new_lemma_77701 (h0 : topological_space (has_to_string (has_to_string Type))) : t1_space (has_to_string (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_77702 (h0 : ring (normed_comm_ring reducibility_hints)) : strong_rank_condition (normed_comm_ring reducibility_hints) := sorry --non-trivial
lemma new_lemma_77703 (h0 : has_mem.mem Type has_emptyc.emptyc) : @irreducible_space.{1} Type (@finset.pi.empty.{2 1} (Type 1) topological_space.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_77704 (h0 : functor.add_const (topological_space (cancel_monoid name)) pos) : @irreducible_space.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_77705 (h1 : ring (has_append (random_gen (random_gen char)))) : strong_rank_condition (has_append (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_77706 (h0 : complete_lattice (bin_tree empty)) : is_atomistic (bin_tree empty) := sorry --non-trivial
lemma new_lemma_77707 (h0 : topological_space (boolean_algebra (has_add unsigned))) : locally_compact_space (boolean_algebra (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_77708 (h0 : ordered_comm_monoid (finset (finset (boolean_algebra.core name)))) : has_exists_mul_of_le (finset (finset (boolean_algebra.core name))) := sorry --non-trivial
lemma new_lemma_77709 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (with_bot.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_bot.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_77710 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @normal_space.{1} (canonically_ordered_comm_semiring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (canonically_ordered_comm_semiring.{1} Type))  := sorry --non-trivial
lemma new_lemma_77711 (h0 : functor.comp monoid complete_distrib_lattice environment.implicit_infer_kind) : @monoid.fg.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} monoid.{0} complete_distrib_lattice.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_77712 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_77713 (h0 : functor.add_const (group (preorder unsigned)) congr_arg_kind) : @normalizer_condition.{0} (preorder.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (preorder.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_77714 (h0 : finset (has_pos_part (has_neg (has_neg name)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_77715 (h1 : uniform_space (measurable_space (has_norm (has_norm congr_arg_kind)))) : complete_space (measurable_space (has_norm (has_norm congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_77716 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_77717 (h0 : functor.add_const (function.extfun Type ordered_comm_monoid) (finset pos)) : @has_exists_mul_of_le.{0} (complete_distrib_lattice.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) (finset.{0} pos) h0) (complete_distrib_lattice.{0} pos))  := sorry --non-trivial
lemma new_lemma_77718 (h0 : ring (simple_graph (has_add name))) : is_domain (simple_graph (has_add name)) := sorry --non-trivial
lemma new_lemma_77719 (h0 : functor.add_const (finset (linear_ordered_cancel_comm_monoid empty)) empty) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_77720 (h0 : monoid (normed_group (has_top linarith.comp_source))) : monoid.fg (normed_group (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_77721 (h0 : uniform_space (mul_zero_class (has_nndist pos))) : separated_space (mul_zero_class (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_77722 (h0 : group (has_norm (random_gen (random_gen linarith.ineq)))) : normalizer_condition (has_norm (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_77723 (h0 : list auto.case_option) : palindrome h0 := sorry --non-trivial
lemma new_lemma_77724 (h0 : list (linear_ordered_add_comm_group (linear_ordered_add_comm_group string_imp))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_77725 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (normed_comm_ring.{0} ennreal) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (normed_comm_ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_77726 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_norm.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_norm.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_77727 (h0 : add_group (has_norm to_additive.value_type)) : is_add_cyclic (has_norm to_additive.value_type) := sorry --non-trivial
lemma new_lemma_77728 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (linear_ordered_comm_ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (linear_ordered_comm_ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_77729 (h0 : topological_space (has_edist num)) : topological_space.separable_space (has_edist num) := sorry --non-trivial
lemma new_lemma_77730 (h1 : topological_space (distrib_lattice string_imp)) : path_connected_space (distrib_lattice string_imp) := sorry --non-trivial
lemma new_lemma_77731 (h0 : functor.add_const (topological_space (ordered_comm_ring Type)) pos) : @totally_disconnected_space.{1} (ordered_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ordered_comm_ring.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_77732 (h0 : ring (canonically_linear_ordered_monoid (option ennreal))) : is_domain (canonically_linear_ordered_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_77733 (h0 : topological_space (has_emptyc (random_gen congr_arg_kind))) : irreducible_space (has_emptyc (random_gen congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_77734 (h0 : topological_space (linear_ordered_comm_ring (semiring (semiring unsigned)))) : topological_space.separable_space (linear_ordered_comm_ring (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_77735 (h0 : functor.add_const (monoid (option empty)) num) : @monoid.fg.{0} (option.{0} empty) (@functor.add_const.run.{0 0} (monoid.{0} (option.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_77736 (h0 : complete_lattice (comm_group (has_add Type))) : is_atomistic (comm_group (has_add Type)) := sorry --non-trivial
lemma new_lemma_77737 (h0 : functor.add_const (cancel_comm_monoid_with_zero (left_cancel_monoid num)) empty) : @unique_factorization_monoid.{0} (left_cancel_monoid.{0} num) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (left_cancel_monoid.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_77738 (h0 : topological_space (simple_graph (generalized_boolean_algebra linarith.comp))) : totally_disconnected_space (simple_graph (generalized_boolean_algebra linarith.comp)) := sorry --non-trivial
lemma new_lemma_77739 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (linear_order.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (linear_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_77740 (h0 : ring (add_monoid (has_lt reducibility_hints))) : rank_condition (add_monoid (has_lt reducibility_hints)) := sorry --non-trivial
lemma new_lemma_77741 (h0 : list (comm_group (linear_ordered_field (finset unsigned)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_77742 (h0 : topological_space (topological_space fun_info)) : path_connected_space (topological_space fun_info) := sorry --non-trivial
lemma new_lemma_77743 (h0 : topological_space (add_cancel_monoid (comm_group pos))) : totally_disconnected_space (add_cancel_monoid (comm_group pos)) := sorry --non-trivial
lemma new_lemma_77744 (h0 : has_coe (nondiscrete_normed_field enat) Prop) (h3 : nondiscrete_normed_field enat) : @coe_b.{1 1} (nondiscrete_normed_field.{0} enat) Prop h0 h3  := sorry --non-trivial
lemma new_lemma_77745 (h0 : topological_space (add_comm_monoid (comm_group unsigned))) : t0_space (add_comm_monoid (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_77746 (h0 : functor.comp topological_space complete_distrib_lattice environment.implicit_infer_kind) : @t0_space.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} complete_distrib_lattice.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_77747 (h0 : fin has_zero.zero) : @complete_space.{0} (ordered_comm_ring.{0} real) (@matrix.vec_empty.{0} (uniform_space.{0} (ordered_comm_ring.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_77748 (h0 : group (measurable_space (has_norm (has_norm linarith.ineq)))) : group.fg (measurable_space (has_norm (has_norm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_77749 (h0 : topological_space (boolean_algebra (add_comm_monoid linarith.comp))) : regular_space (boolean_algebra (add_comm_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_77750 (h0 : group (comm_group (option name))) : is_cyclic (comm_group (option name)) := sorry --non-trivial
lemma new_lemma_77751 (h0 : functor.add_const (uniform_space (canonically_ordered_monoid real)) (has_Inf Type)) : @separated_space.{0} (canonically_ordered_monoid.{0} real) (@functor.add_const.run.{0 1} (uniform_space.{0} (canonically_ordered_monoid.{0} real)) (has_Inf.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_77752 (h0 : topological_space (pseudo_metric_space (option unsigned))) : preconnected_space (pseudo_metric_space (option unsigned)) := sorry --non-trivial
lemma new_lemma_77753 (h0 : functor.add_const (topological_space (add_cancel_monoid linarith.comp)) Type) : @preirreducible_space.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (add_cancel_monoid.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_77754 (h0 : has_lt (nondiscrete_normed_field (mul_one_class ereal))) : no_max_order (nondiscrete_normed_field (mul_one_class ereal)) := sorry --non-trivial
lemma new_lemma_77755 (h0 : topological_space (boolean_algebra (has_bot pos))) : totally_separated_space (boolean_algebra (has_bot pos)) := sorry --non-trivial
lemma new_lemma_77756 (h0 : ring (has_to_string (comm_group (has_add (comm_group pos))))) : strong_rank_condition (has_to_string (comm_group (has_add (comm_group pos)))) := sorry --non-trivial
lemma new_lemma_77757 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (generalized_boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (generalized_boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_77758 (h0 : topological_space (filter unsigned)) : discrete_topology (filter unsigned) := sorry --non-trivial
lemma new_lemma_77759 (h0 : add_monoid (non_assoc_semiring (semiring empty))) : add_monoid.fg (non_assoc_semiring (semiring empty)) := sorry --non-trivial
lemma new_lemma_77760 (h0 : topological_space (ordered_comm_ring (ring (has_add pos)))) : preirreducible_space (ordered_comm_ring (ring (has_add pos))) := sorry --non-trivial
lemma new_lemma_77761 (h0 : group (ring (ring (has_neg (ring Type))))) : group.fg (ring (ring (has_neg (ring Type)))) := sorry --non-trivial
lemma new_lemma_77762 (h0 : filter (semigroup (comm_group name))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_77763 (h1 : complete_lattice (denumerable fun_info)) : complete_lattice.is_Sup_finite_compact (denumerable fun_info) := sorry --non-trivial
lemma new_lemma_77764 (h0 : topological_space (measurable_space (semiring fun_info))) : discrete_topology (measurable_space (semiring fun_info)) := sorry --non-trivial
lemma new_lemma_77765 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_inv.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_inv.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_77766 (h0 : ordered_add_comm_monoid (normed_comm_ring (has_pos_part (normed_comm_ring linarith.comp)))) : archimedean (normed_comm_ring (has_pos_part (normed_comm_ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_77767 (h0 : topological_space (has_zero (ring linarith.comp))) : t0_space (has_zero (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_77768 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (@id.{2} Type linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (@id.{2} Type linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_77769 (h0 : topological_space (free_add_monoid congr_arg_kind)) : locally_compact_space (free_add_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_77770 (h0 : monoid reducibility_hints) (h1 : not (nat -> false)) (h2 : complete_lattice (sym (conj_classes reducibility_hints) (classical.by_contradiction' h1))) : is_compactly_generated (sym (conj_classes reducibility_hints) (classical.by_contradiction' h1)) := sorry --non-trivial
lemma new_lemma_77771 (h0 : topological_space (has_pos_part (has_add (has_add linarith.comp)))) : preconnected_space (has_pos_part (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_77772 (h0 : not (topological_space (semi_normed_comm_ring to_additive.value_type) -> false)) : @locally_compact_space.{0} (semi_normed_comm_ring.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (semi_normed_comm_ring.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_77773 (h0 : not (topological_space (semi_normed_ring reducibility_hints) -> false)) : @path_connected_space.{0} (semi_normed_ring.{0} reducibility_hints) (@classical.by_contradiction'.{1} (topological_space.{0} (semi_normed_ring.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_77774 (h0 : complete_lattice (has_lt char)) : is_compactly_generated (has_lt char) := sorry --non-trivial
lemma new_lemma_77775 (h0 : cancel_comm_monoid_with_zero (ordered_comm_ring Type)) : unique_factorization_monoid (ordered_comm_ring Type) := sorry --non-trivial
lemma new_lemma_77776 (h0 : topological_space (semigroup (finset (has_nndist Type)))) : totally_separated_space (semigroup (finset (has_nndist Type))) := sorry --non-trivial
lemma new_lemma_77777 (h0 : functor.add_const (topological_space environment.implicit_infer_kind) name) : @preirreducible_space.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 0} (topological_space.{0} environment.implicit_infer_kind) name h0)  := sorry --non-trivial
lemma new_lemma_77778 (h0 : topological_space (comm_group (canonically_linear_ordered_monoid name))) : preconnected_space (comm_group (canonically_linear_ordered_monoid name)) := sorry --non-trivial
lemma new_lemma_77779 (h0 : functor.add_const (topological_space (has_add linarith.comp)) (ring pos)) : @irreducible_space.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} linarith.comp)) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_77780 (h0 : ordered_add_comm_monoid (has_to_string (finset (finset linarith.comp)))) : archimedean (has_to_string (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_77781 (h0 : filter (has_to_string (canonically_ordered_comm_semiring (has_neg_part name)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_77782 (h0 : not (measurable_space (uniform_space linarith.ineq) -> false)) (h1 : filter (uniform_space linarith.ineq)) : @filter.is_measurably_generated.{0} (uniform_space.{0} linarith.ineq) (@classical.by_contradiction'.{1} (measurable_space.{0} (uniform_space.{0} linarith.ineq)) h0) h1  := sorry --non-trivial
lemma new_lemma_77783 (h0 : functor.add_const (topological_space (ring linarith.comp)) name) : @discrete_topology.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_77784 (h0 : functor.add_const (complete_lattice (canonically_linear_ordered_monoid real)) pos) : @is_atomistic.{0} (canonically_linear_ordered_monoid.{0} real) (@functor.add_const.run.{0 0} (complete_lattice.{0} (canonically_linear_ordered_monoid.{0} real)) pos h0)  := sorry --non-trivial
lemma new_lemma_77785 (h0 : topological_space (monoid_with_zero (option (has_add name)))) : t0_space (monoid_with_zero (option (has_add name))) := sorry --non-trivial
lemma new_lemma_77786 (h0 : functor.add_const (ring (bin_tree empty)) num) : @strong_rank_condition.{0} (bin_tree.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (bin_tree.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_77787 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @preirreducible_space.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_77788 (h0 : group (has_neg_part Type)) : is_simple_group (has_neg_part Type) := sorry --non-trivial
lemma new_lemma_77789 (h0 : functor.add_const (topological_space (free_add_monoid empty)) num) : @irreducible_space.{0} (free_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_77790 (h0 : functor.add_const (function.extfun Type topological_space) (finset linarith.comp)) : @preirreducible_space.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (finset.{0} linarith.comp) h0) (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_77791 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (is_R_or_C.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (is_R_or_C.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_77792 (h0 : group (complete_distrib_lattice (has_bot real))) : is_cyclic (complete_distrib_lattice (has_bot real)) := sorry --non-trivial
lemma new_lemma_77793 (h0 : monoid (has_pos_part (canonically_ordered_monoid Type))) : monoid.fg (has_pos_part (canonically_ordered_monoid Type)) := sorry --non-trivial
lemma new_lemma_77794 (h0 : not (complete_lattice (has_union num) -> false)) : @is_atomistic.{0} (has_union.{0} num) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_union.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_77795 (h0 : functor.add_const (function.extfun Type topological_space) (has_neg (has_pos_part linarith.comp))) : @discrete_topology.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (has_neg.{0} (has_pos_part.{0} linarith.comp)) h0) (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_77796 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (canonically_ordered_comm_semiring.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} h0 (canonically_ordered_comm_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_77797 (h1 : ring (normed_group to_additive.value_type)) : rank_condition (normed_group to_additive.value_type) := sorry --non-trivial
lemma new_lemma_77798 (h0 : complete_lattice (complete_semilattice_Sup (semiring unsigned))) : is_compactly_generated (complete_semilattice_Sup (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_77799 (h0 : functor.comp topological_space add_cancel_monoid environment.implicit_infer_kind) : @topological_space.separable_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} add_cancel_monoid.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_77800 (h0 : function.extfun nat fin) : discrete_topology real := sorry --non-trivial
lemma new_lemma_77801 (h0 : functor.add_const (cancel_comm_monoid_with_zero (linear_ordered_cancel_comm_monoid unsigned)) unsigned) : @unique_factorization_monoid.{0} (linear_ordered_cancel_comm_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (linear_ordered_cancel_comm_monoid.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_77802 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (has_union.{0} unsigned) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (has_union.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_77803 (h0 : function.extfun (Type 1) (functor.add_const (topological_space (has_nndist linarith.comp)))) : @totally_disconnected_space.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_nndist.{0} linarith.comp)) Type (@function.extfun_app.{3 1} (Type 1) (functor.add_const.{0 1} (topological_space.{0} (has_nndist.{0} linarith.comp))) h0 Type))  := sorry --non-trivial
lemma new_lemma_77804 (h0 : complete_lattice (mul_zero_class (option unsigned))) : complete_lattice.is_Sup_finite_compact (mul_zero_class (option unsigned)) := sorry --non-trivial
lemma new_lemma_77805 (h0 : filter (boolean_algebra.core Type)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_77806 (h0 : uniform_space (ring (option (option unsigned)))) : complete_space (ring (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_77807 (h0 : complete_lattice (has_norm (has_top num))) : is_atomistic (has_norm (has_top num)) := sorry --non-trivial
lemma new_lemma_77808 (h0 : functor.add_const (complete_lattice (has_neg_part name)) unsigned) : @is_atomistic.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_neg_part.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_77809 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_neg.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (has_neg.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_77810 (h0 : group (normed_comm_ring Type)) : is_cyclic (normed_comm_ring Type) := sorry --non-trivial
lemma new_lemma_77811 (h0 : ring (dlist linarith.ineq)) : is_domain (dlist linarith.ineq) := sorry --non-trivial
lemma new_lemma_77812 (h0 : topological_space (has_zero (has_nndist ennreal))) : locally_compact_space (has_zero (has_nndist ennreal)) := sorry --non-trivial
lemma new_lemma_77813 (h3 : measurable_space fun_info) (h4 : filter fun_info) : filter.is_measurably_generated h4 := sorry --non-trivial
lemma new_lemma_77814 (h0 : add_group (has_div (metric_space (metric_space linarith.comp_source)))) : is_add_cyclic (has_div (metric_space (metric_space linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_77815 (h0 : function.extfun Type ring) : @rank_condition.{0} (linear_ordered_comm_group.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_ordered_comm_group.{0} num))  := sorry --non-trivial
lemma new_lemma_77816 (h0 : ring (comm_ring (mul_one_class (mul_one_class reducibility_hints)))) : rank_condition (comm_ring (mul_one_class (mul_one_class reducibility_hints))) := sorry --non-trivial
lemma new_lemma_77817 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @sequential_space.{0} (has_to_string.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_to_string.{0} name))  := sorry --non-trivial
lemma new_lemma_77818 (h0 : list (has_emptyc (has_top linarith.ineq))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_77819 (h0 : functor.add_const (uniform_space (has_Inf name)) pos) : @separated_space.{0} (has_Inf.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_Inf.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_77820 (h0 : function.extfun nat fin) : @regular_space.{0} (generalized_boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (generalized_boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_77821 (h0 : monoid (emetric_space (semiring empty))) : monoid.fg (emetric_space (semiring empty)) := sorry --non-trivial
lemma new_lemma_77822 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_77823 (h0 : not (topological_space fun_info -> false)) : @totally_disconnected_space.{0} fun_info (@classical.by_contradiction'.{1} (topological_space.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_77824 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @loc_path_connected_space.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_77825 (h0 : functor.add_const (add_monoid (comm_group environment.implicit_infer_kind)) name) : @add_monoid.fg.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (add_monoid.{0} (comm_group.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_77826 (h0 : topological_space (has_bot (has_Inf (has_Inf real)))) : totally_disconnected_space (has_bot (has_Inf (has_Inf real))) := sorry --non-trivial
lemma new_lemma_77827 (h0 : functor.comp topological_space has_zero ennreal) : @totally_separated_space.{0} (has_zero.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} has_zero.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_77828 (h0 : functor.add_const (topological_space (linear_ordered_field empty)) (option (option num))) : @topological_space.separable_space.{0} (linear_ordered_field.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_field.{0} empty)) (option.{0} (option.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_77829 (h0 : complete_lattice (ring (option (option num)))) : complete_lattice.is_Sup_finite_compact (ring (option (option num))) := sorry --non-trivial
lemma new_lemma_77830 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} fun_info (@function.extfun_app.{2 1} Type topological_space.{0} h0 fun_info)  := sorry --non-trivial
lemma new_lemma_77831 (h0 : metric_space char) (h1 : set char) : euclidean_geometry.cospherical h1 := sorry --non-trivial
lemma new_lemma_77832 (h0 : topological_space (has_sub (has_top (has_top empty)))) : totally_separated_space (has_sub (has_top (has_top empty))) := sorry --non-trivial
lemma new_lemma_77833 (h0 : topological_space (has_emptyc (has_norm to_additive.value_type))) : totally_separated_space (has_emptyc (has_norm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_77834 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_77835 (h0 : group (random_gen linarith.ineq)) : normalizer_condition (random_gen linarith.ineq) := sorry --non-trivial
lemma new_lemma_77836 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} (generalized_boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) (generalized_boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_77837 (h0 : functor.comp group has_add name) : @group.fg.{0} (has_add.{0} name) (@functor.comp.run.{0 0 0} group.{0} has_add.{0} name h0)  := sorry --non-trivial
lemma new_lemma_77838 (h1 : not (complete_lattice (normed_field linarith.comp_source) -> false)) : @is_compactly_generated.{0} (normed_field.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (complete_lattice.{0} (normed_field.{0} linarith.comp_source)) h1)  := sorry --non-trivial
lemma new_lemma_77839 (h0 : functor.add_const (topological_space (mul_zero_class unsigned)) unsigned) : @irreducible_space.{0} (mul_zero_class.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_77840 (h0 : functor.comp ring has_neg pos) : @is_domain.{0} (has_neg.{0} pos) (@functor.comp.run.{0 0 0} ring.{0} has_neg.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_77841 (h0 : topological_space (normed_comm_ring ennreal)) : irreducible_space (normed_comm_ring ennreal) := sorry --non-trivial
lemma new_lemma_77842 (h0 : functor.add_const (topological_space (normed_comm_ring environment.implicit_infer_kind)) (has_add Type)) : @loc_path_connected_space.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (normed_comm_ring.{0} environment.implicit_infer_kind)) (has_add.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_77843 (h0 : functor.add_const (add_group (left_cancel_monoid empty)) (option unsigned)) : @is_add_cyclic.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (add_group.{0} (left_cancel_monoid.{0} empty)) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_77844 (h1 : topological_space (has_nnnorm reducibility_hints)) (h2 : preorder (has_nnnorm reducibility_hints)) : order_closed_topology (has_nnnorm reducibility_hints) := sorry --non-trivial
lemma new_lemma_77845 (h0 : topological_space (finset (comm_group name))) : preconnected_space (finset (comm_group name)) := sorry --non-trivial
lemma new_lemma_77846 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} auto.case_option (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) auto.case_option)  := sorry --non-trivial
lemma new_lemma_77847 (h0 : group (has_add (option (option ennreal)))) : is_cyclic (has_add (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_77848 (h0 : functor.add_const (function.extfun Type ring) (finset Type)) : @is_domain.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ring.{0}) (finset.{1} Type) h0) (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_77849 (h0 : topological_space (distrib (has_nnnorm (has_nnnorm fun_info)))) : path_connected_space (distrib (has_nnnorm (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_77850 (h0 : topological_space (add_comm_monoid (sub_neg_monoid name))) : preconnected_space (add_comm_monoid (sub_neg_monoid name)) := sorry --non-trivial
lemma new_lemma_77851 (h0 : functor.add_const (functor.add_const (topological_space environment.implicit_infer_kind) name) name) : @locally_compact_space.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 0} (topological_space.{0} environment.implicit_infer_kind) name (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (topological_space.{0} environment.implicit_infer_kind) name) name h0))  := sorry --non-trivial
lemma new_lemma_77852 (h0 : nat) (h1 : with_bot (vector Prop (has_add.add h0 has_one.one))) (h2 : ne h1 has_bot.bot) : vector.last (with_bot.unbot h1 h2) := sorry --non-trivial
lemma new_lemma_77853 (h0 : topological_space (has_union (has_union (has_union linarith.comp)))) : normal_space (has_union (has_union (has_union linarith.comp))) := sorry --non-trivial
lemma new_lemma_77854 (h0 : topological_space (canonically_ordered_comm_semiring (finset name))) : t0_space (canonically_ordered_comm_semiring (finset name)) := sorry --non-trivial
lemma new_lemma_77855 (h0 : group (has_zero (has_add (has_add linarith.comp)))) : group.fg (has_zero (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_77856 (h1 : ring (has_compl (topological_space (has_nnnorm (comm_ring reducibility_hints))))) : rank_condition (has_compl (topological_space (has_nnnorm (comm_ring reducibility_hints)))) := sorry --non-trivial
lemma new_lemma_77857 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_norm.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_norm.{0} empty))  := sorry --non-trivial
lemma new_lemma_77858 (h0 : uniform_space (canonically_ordered_monoid Type)) : separated_space (canonically_ordered_monoid Type) := sorry --non-trivial
lemma new_lemma_77859 (h0 : group (add_left_cancel_semigroup (semiring (semiring unsigned)))) : is_cyclic (add_left_cancel_semigroup (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_77860 (h1 : filter (with_bot to_additive.value_type)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_77861 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @normal_space.{0} (normed_lattice_add_comm_group.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (normed_lattice_add_comm_group.{0} real))  := sorry --non-trivial
lemma new_lemma_77862 (h0 : not (add_group (has_div (mul_one_class (mul_one_class fun_info))) -> false)) : @is_add_cyclic.{0} (has_div.{0} (mul_one_class.{0} (mul_one_class.{0} fun_info))) (@classical.by_contradiction'.{1} (add_group.{0} (has_div.{0} (mul_one_class.{0} (mul_one_class.{0} fun_info)))) h0)  := sorry --non-trivial
lemma new_lemma_77863 (h0 : functor.add_const (group (normed_comm_ring linarith.comp)) Type) : @normalizer_condition.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (group.{0} (normed_comm_ring.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_77864 (h0 : topological_space (has_add (finset Type))) : normal_space (has_add (finset Type)) := sorry --non-trivial
lemma new_lemma_77865 (h0 : functor.add_const (topological_space (has_emptyc (has_top (has_top (has_top (has_top linarith.ineq)))))) num) : @totally_separated_space.{0} (has_emptyc.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} linarith.ineq))))) (@functor.add_const.run.{0 0} (topological_space.{0} (has_emptyc.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} linarith.ineq)))))) num h0)  := sorry --non-trivial
lemma new_lemma_77866 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (semiring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semiring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_77867 (h0 : functor.add_const (functor.add_const Prop (ring pos)) linarith.comp) : functor.add_const.run (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_77868 (h0 : topological_space (semi_normed_comm_ring (has_ssubset (has_ssubset linarith.ineq)))) : totally_disconnected_space (semi_normed_comm_ring (has_ssubset (has_ssubset linarith.ineq))) := sorry --non-trivial
lemma new_lemma_77869 (h0 : group (distrib (has_append (denumerable linarith.ineq)))) : is_cyclic (distrib (has_append (denumerable linarith.ineq))) := sorry --non-trivial
lemma new_lemma_77870 (h0 : complete_lattice (has_neg_part ennreal)) : is_compactly_generated (has_neg_part ennreal) := sorry --non-trivial
lemma new_lemma_77871 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (topological_space fun_info)) := sorry --non-trivial
lemma new_lemma_77872 (h0 : semiring (has_pos_part (has_add name))) : is_noetherian_ring (has_pos_part (has_add name)) := sorry --non-trivial
lemma new_lemma_77873 (h0 : topological_space (complete_linear_order (has_top (has_top (has_one (has_top unsigned)))))) : path_connected_space (complete_linear_order (has_top (has_top (has_one (has_top unsigned))))) := sorry --non-trivial
lemma new_lemma_77874 (h0 : topological_space (add_cancel_monoid (has_bot unsigned))) : totally_separated_space (add_cancel_monoid (has_bot unsigned)) := sorry --non-trivial
lemma new_lemma_77875 (h0 : functor.add_const (uniform_space (simple_graph name)) pos) : @complete_space.{0} (simple_graph.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (simple_graph.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_77876 (h0 : topological_space (with_bot (random_gen linarith.ineq))) : locally_compact_space (with_bot (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_77877 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (random_gen.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (random_gen.{0} num))  := sorry --non-trivial
lemma new_lemma_77878 (h0 : to_additive.value_type) (h1 : function.extfun to_additive.value_type (fun (x : to_additive.value_type), Prop)) : set.mem h0 (function.extfun_app h1) := sorry --non-trivial
lemma new_lemma_77879 (h0 : functor.add_const (topological_space (has_add Type)) linarith.comp) : @totally_disconnected_space.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_add.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_77880 (h0 : topological_space (has_nnnorm (semi_normed_comm_ring fun_info))) : path_connected_space (has_nnnorm (semi_normed_comm_ring fun_info)) := sorry --non-trivial
lemma new_lemma_77881 (h0 : function.extfun nat fin) : @is_add_cyclic.{0} (sub_neg_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (add_group.{0} (sub_neg_monoid.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_77882 (h0 : topological_space (add_comm_monoid (comm_group linarith.comp))) : preconnected_space (add_comm_monoid (comm_group linarith.comp)) := sorry --non-trivial
lemma new_lemma_77883 (h0 : topological_space (ordered_comm_ring name)) : preconnected_space (ordered_comm_ring name) := sorry --non-trivial
lemma new_lemma_77884 (h0 : semiring (normed_comm_ring (complete_semilattice_Sup Type))) : is_noetherian_ring (normed_comm_ring (complete_semilattice_Sup Type)) := sorry --non-trivial
lemma new_lemma_77885 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_cyclic.{1} (ordered_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 group.{1}) (ordered_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_77886 (h1 : ring (normed_group (has_inv (has_inv (denumerable (has_add string_imp)))))) : rank_condition (normed_group (has_inv (has_inv (denumerable (has_add string_imp))))) := sorry --non-trivial
lemma new_lemma_77887 (h0 : topological_space (complete_distrib_lattice (has_neg (has_neg Type)))) : preconnected_space (complete_distrib_lattice (has_neg (has_neg Type))) := sorry --non-trivial
lemma new_lemma_77888 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (semi_normed_comm_ring linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_77889 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (partial_order.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (partial_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_77890 (h0 : ring (generalized_boolean_algebra (ring (has_neg Type)))) : strong_rank_condition (generalized_boolean_algebra (ring (has_neg Type))) := sorry --non-trivial
lemma new_lemma_77891 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem complete_lattice)) : @complete_lattice.is_Sup_finite_compact.{0} (with_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) complete_lattice.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (with_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_77892 (h1 : group (add_cancel_comm_monoid linarith.comp_source)) : is_cyclic (add_cancel_comm_monoid linarith.comp_source) := sorry --non-trivial
lemma new_lemma_77893 (h0 : topological_space (add_cancel_monoid (has_neg (finset pos)))) : loc_path_connected_space (add_cancel_monoid (has_neg (finset pos))) := sorry --non-trivial
lemma new_lemma_77894 (h0 : functor.comp ring cancel_monoid Type) : @strong_rank_condition.{1} (cancel_monoid.{1} Type) (@functor.comp.run.{1 1 1} ring.{1} cancel_monoid.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_77895 (h0 : semiring (mul_zero_class congr_arg_kind)) : is_noetherian_ring (mul_zero_class congr_arg_kind) := sorry --non-trivial
lemma new_lemma_77896 (h0 : topological_space (add_comm_monoid (boolean_algebra linarith.comp))) : t1_space (add_comm_monoid (boolean_algebra linarith.comp)) := sorry --non-trivial
lemma new_lemma_77897 (h1 : group (has_append char)) : is_cyclic (has_append char) := sorry --non-trivial
lemma new_lemma_77898 (h0 : filter (has_top (metric_space num))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_77899 (h0 : uniform_space (has_norm (has_top (semiring empty)))) : separated_space (has_norm (has_top (semiring empty))) := sorry --non-trivial
lemma new_lemma_77900 (h0 : add_monoid (semigroup (mul_one_class Type))) : add_monoid.fg (semigroup (mul_one_class Type)) := sorry --non-trivial
lemma new_lemma_77901 (h0 : uniform_space (canonically_ordered_monoid (sub_neg_monoid (has_Inf pos)))) : separated_space (canonically_ordered_monoid (sub_neg_monoid (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_77902 (h0 : functor.add_const (topological_space (normed_comm_ring linarith.comp)) (ring environment.implicit_infer_kind)) : @loc_path_connected_space.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} linarith.comp)) (ring.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_77903 (h1 : group environment.projection_info) (h2 : uniform_space (mul_one_class (group_topology environment.projection_info))) : complete_space (mul_one_class (group_topology environment.projection_info)) := sorry --non-trivial
lemma new_lemma_77904 (h0 : functor.add_const (ring (has_nndist unsigned)) (finset (has_nndist (has_nndist Type)))) : @is_principal_ideal_ring.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 1} (ring.{0} (has_nndist.{0} unsigned)) (finset.{1} (has_nndist.{1} (has_nndist.{1} Type))) h0)  := sorry --non-trivial
lemma new_lemma_77905 (h0 : ring (distrib (mul_one_class (mul_one_class string_imp)))) : rank_condition (distrib (mul_one_class (mul_one_class string_imp))) := sorry --non-trivial
lemma new_lemma_77906 (h1 : uniform_space (has_inv (has_nnnorm to_additive.value_type))) : complete_space (has_inv (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_77907 (h0 : list (measure_theory.measure_space unsigned)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_77908 (h0 : functor.add_const (finset (generalized_boolean_algebra pos)) (ring name)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_77909 (h0 : functor.add_const (add_monoid (mul_zero_class Type)) (normed_comm_ring unsigned)) : @add_monoid.fg.{1} (mul_zero_class.{1} Type) (@functor.add_const.run.{1 0} (add_monoid.{1} (mul_zero_class.{1} Type)) (normed_comm_ring.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_77910 (h0 : functor.add_const (topological_space (measurable_space.dynkin_system unsigned)) unsigned) : @normal_space.{0} (measurable_space.dynkin_system.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (measurable_space.dynkin_system.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_77911 (h0 : functor.comp topological_space has_zero (has_add (ring Type))) : @preirreducible_space.{1} (has_zero.{1} (has_add.{1} (ring.{1} Type))) (@functor.comp.run.{1 1 1} topological_space.{1} has_zero.{1} (has_add.{1} (ring.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_77912 (h1 : group (has_append (with_bot (with_bot linarith.comp_source)))) : normalizer_condition (has_append (with_bot (with_bot linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_77913 (h0 : add_monoid (ring (ring pos))) : add_monoid.fg (ring (ring pos)) := sorry --non-trivial
lemma new_lemma_77914 (h0 : topological_space (semigroup (semigroup (has_to_string linarith.comp)))) : topological_space.separable_space (semigroup (semigroup (has_to_string linarith.comp))) := sorry --non-trivial
lemma new_lemma_77915 (h0 : topological_space (ring environment.implicit_infer_kind)) : locally_compact_space (ring environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_77916 (h0 : filter (complete_distrib_lattice congr_arg_kind)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_77917 (h0 : ordered_add_comm_monoid (ordered_comm_ring (finset Type))) : archimedean (ordered_comm_ring (finset Type)) := sorry --non-trivial
lemma new_lemma_77918 (h0 : ring (mul_one_class std_gen)) : strong_rank_condition (mul_one_class std_gen) := sorry --non-trivial
lemma new_lemma_77919 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (boolean_algebra.core.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (boolean_algebra.core.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_77920 (h0 : add_monoid real) : add_monoid.fg real := sorry --non-trivial
lemma new_lemma_77921 (h0 : add_group (mul_zero_class (semiring (semiring (semiring empty))))) : is_add_cyclic (mul_zero_class (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_77922 (h0 : group (linear_ordered_comm_monoid_with_zero (semiring (semiring empty)))) : normalizer_condition (linear_ordered_comm_monoid_with_zero (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_77923 (h2 : set reducibility_hints) : set.finite h2 := sorry --non-trivial
lemma new_lemma_77924 (h0 : group (comm_ring (has_nnnorm (random_gen char)))) : is_cyclic (comm_ring (has_nnnorm (random_gen char))) := sorry --non-trivial
lemma new_lemma_77925 (h0 : topological_space (canonically_ordered_comm_semiring (finset pos))) : topological_space.separable_space (canonically_ordered_comm_semiring (finset pos)) := sorry --non-trivial
lemma new_lemma_77926 (h0 : topological_space (semigroup (option (option unsigned)))) : locally_compact_space (semigroup (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_77927 (h0 : topological_space (simple_graph (ring linarith.comp))) : t1_space (simple_graph (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_77928 (h0 : topological_space (add_comm_monoid (comm_group unsigned))) : topological_space.separable_space (add_comm_monoid (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_77929 (h0 : finset (normed_comm_ring (option unsigned))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_77930 (h0 : group (random_gen fun_info) -> Prop) (h1 : not (Exists (fun (x : group (random_gen fun_info)), h0 x) -> false)) : @is_cyclic.{0} (random_gen.{0} fun_info) (@classical.some.{1} (group.{0} (random_gen.{0} fun_info)) h0 (@classical.by_contradiction'.{0} (@Exists.{1} (group.{0} (random_gen.{0} fun_info)) (λ (x : group.{0} (random_gen.{0} fun_info)), h0 x)) h1))  := sorry --non-trivial
lemma new_lemma_77931 (h0 : functor.add_const (topological_space (ordered_comm_ring Type)) linarith.comp) : @regular_space.{1} (ordered_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ordered_comm_ring.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_77932 (h0 : functor.add_const (topological_space (has_add pos)) Type) : @t1_space.{0} (has_add.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_add.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_77933 (h0 : ordered_comm_monoid (mul_zero_class unsigned)) : has_exists_mul_of_le (mul_zero_class unsigned) := sorry --non-trivial
lemma new_lemma_77934 (h0 : functor.add_const (complete_lattice (semigroup name)) Type) : @is_atomistic.{0} (semigroup.{0} name) (@functor.add_const.run.{0 1} (complete_lattice.{0} (semigroup.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_77935 (h0 : group (denumerable (linear_ordered_add_comm_group fun_info))) : group.fg (denumerable (linear_ordered_add_comm_group fun_info)) := sorry --non-trivial
lemma new_lemma_77936 (h0 : functor.comp ring has_neg_part name) : @rank_condition.{0} (has_neg_part.{0} name) (@functor.comp.run.{0 0 0} ring.{0} has_neg_part.{0} name h0)  := sorry --non-trivial
lemma new_lemma_77937 (h0 : functor.add_const (group (add_cancel_monoid pos)) Type) : @group.fg.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (add_cancel_monoid.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_77938 (h0 : functor.add_const Prop (boolean_algebra Type)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_77939 (h0 : fin has_zero.zero) : @is_add_cyclic.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_group.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type add_group.{0}) h0) (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_77940 (h0 : topological_space (ordered_comm_ring (has_nndist (has_neg (has_add linarith.comp))))) : totally_separated_space (ordered_comm_ring (has_nndist (has_neg (has_add linarith.comp)))) := sorry --non-trivial
lemma new_lemma_77941 (h2 : function.extfun (finset (Type -> Type)) (has_mem.mem complete_lattice)) : @is_compactly_generated.{0} (has_emptyc.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) complete_lattice.{0}) h2 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_emptyc.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_77942 (h1 : add_group (with_one num)) : is_add_cyclic (with_one num) := sorry --non-trivial
lemma new_lemma_77943 (h0 : functor.add_const (add_monoid (has_neg_part name)) unsigned) : @add_monoid.fg.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_neg_part.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_77944 (h0 : functor.add_const (topological_space (pseudo_metric_space ennreal)) congr_arg_kind) : @t0_space.{0} (pseudo_metric_space.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (pseudo_metric_space.{0} ennreal)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_77945 (h0 : function.extfun (Type 1) ordered_add_comm_monoid) : @archimedean.{1} (complete_distrib_lattice.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_add_comm_monoid.{1} h0 (complete_distrib_lattice.{1} Type))  := sorry --non-trivial
lemma new_lemma_77946 (h0 : complete_lattice (add_comm_monoid name)) : complete_lattice.is_Sup_finite_compact (add_comm_monoid name) := sorry --non-trivial
lemma new_lemma_77947 (h0 : ring (has_norm linarith.comp)) : rank_condition (has_norm linarith.comp) := sorry --non-trivial
lemma new_lemma_77948 (h0 : not (function.extfun Type ring -> false)) : @strong_rank_condition.{0} (semiring.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_77949 (h0 : ordered_add_comm_monoid (linear_ordered_comm_monoid_with_zero congr_arg_kind)) : archimedean (linear_ordered_comm_monoid_with_zero congr_arg_kind) := sorry --non-trivial
lemma new_lemma_77950 (h0 : list (normed_comm_ring (option pos))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_77951 (h0 : ordered_add_comm_monoid (has_add (finset pos))) : archimedean (has_add (finset pos)) := sorry --non-trivial
lemma new_lemma_77952 (h0 : topological_space (has_lt (random_gen (random_gen (has_nnnorm (has_nnnorm reducibility_hints)))))) : t0_space (has_lt (random_gen (random_gen (has_nnnorm (has_nnnorm reducibility_hints))))) := sorry --non-trivial
lemma new_lemma_77953 (h0 : functor.add_const (topological_space (mul_zero_class Type)) Type) : @topological_space.separable_space.{1} (mul_zero_class.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (mul_zero_class.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_77954 (h0 : add_monoid (ring (has_add (has_pos_part (has_to_string pos))))) : add_monoid.fg (ring (has_add (has_pos_part (has_to_string pos)))) := sorry --non-trivial
lemma new_lemma_77955 (h1 : not (function.extfun Type complete_lattice -> false)) : is_compactly_generated (measurable_space linarith.comp) := sorry --non-trivial
lemma new_lemma_77956 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (option (option (option pos)))) := sorry --non-trivial
lemma new_lemma_77957 (h0 : topological_space (ordered_comm_ring (ring (ordered_comm_monoid Type)))) : discrete_topology (ordered_comm_ring (ring (ordered_comm_monoid Type))) := sorry --non-trivial
lemma new_lemma_77958 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (canonically_ordered_comm_semiring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_ordered_comm_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_77959 (h0 : functor.add_const (topological_space (complete_distrib_lattice Type)) linarith.comp) : @totally_separated_space.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (complete_distrib_lattice.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_77960 (h0 : ring (has_Inf (has_add (has_Inf (has_Inf pos))))) : rank_condition (has_Inf (has_add (has_Inf (has_Inf pos)))) := sorry --non-trivial
lemma new_lemma_77961 (h0 : has_mem.mem (semiring linarith.ineq) has_emptyc.emptyc) : @is_compactly_generated.{0} (semiring.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (semiring.{0} linarith.ineq) h0)  := sorry --non-trivial
lemma new_lemma_77962 (h0 : topological_space (has_add name)) : loc_path_connected_space (has_add name) := sorry --non-trivial
lemma new_lemma_77963 (h0 : topological_space (has_edist (semiring unsigned))) : totally_disconnected_space (has_edist (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_77964 (h0 : topological_space (with_one (semiring (random_gen linarith.comp)))) : locally_compact_space (with_one (semiring (random_gen linarith.comp))) := sorry --non-trivial
lemma new_lemma_77965 (h0 : functor.add_const (topological_space (boolean_algebra environment.implicit_infer_kind)) pos) : @normal_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_77966 (h0 : prod (complete_distrib_lattice ennreal) (complete_distrib_lattice ennreal)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_77967 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (canonically_ordered_add_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (canonically_ordered_add_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_77968 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (add_monoid linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_77969 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (has_bot unsigned)) := sorry --non-trivial
lemma new_lemma_77970 (h0 : not (function.extfun Type topological_space -> false)) : @irreducible_space.{0} (left_cancel_semigroup.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (left_cancel_semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_77971 (h0 : topological_space (has_Inf (boolean_algebra Type))) : preirreducible_space (has_Inf (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_77972 (h0 : topological_space (with_bot (has_norm congr_arg_kind))) : discrete_topology (with_bot (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_77973 (h0 : functor.add_const (complete_lattice (normed_comm_ring linarith.comp)) (semigroup (finset Type))) : @is_compactly_generated.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (complete_lattice.{0} (normed_comm_ring.{0} linarith.comp)) (semigroup.{1} (finset.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_77974 (h0 : topological_space (has_bot congr_arg_kind)) : irreducible_space (has_bot congr_arg_kind) := sorry --non-trivial
lemma new_lemma_77975 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (boolean_algebra.core.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (boolean_algebra.core.{0} num))  := sorry --non-trivial
lemma new_lemma_77976 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @regular_space.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_77977 (h0 : add_group (has_nnnorm reducibility_hints)) : is_add_cyclic (has_nnnorm reducibility_hints) := sorry --non-trivial
lemma new_lemma_77978 (h0 : functor.comp group has_nndist ennreal) : @group.fg.{0} (has_nndist.{0} ennreal) (@functor.comp.run.{0 0 0} group.{0} has_nndist.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_77979 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (pseudo_metric_space.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (pseudo_metric_space.{0} num))  := sorry --non-trivial
lemma new_lemma_77980 (h0 : function.extfun nat fin) : @normalizer_condition.{0} (has_pos_part.{0} name) (@matrix.vec_empty.{0} (group.{0} (has_pos_part.{0} name)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_77981 (h0 : ring (random_gen (random_gen linarith.ineq))) : is_domain (random_gen (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_77982 (h0 : functor.add_const (topological_space environment.implicit_infer_kind) Type) : @locally_compact_space.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 1} (topological_space.{0} environment.implicit_infer_kind) Type h0)  := sorry --non-trivial
lemma new_lemma_77983 (h0 : ring (has_add (finset (finset pos)))) : strong_rank_condition (has_add (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_77984 (h0 : functor.add_const (finset (ring environment.implicit_infer_kind)) Type) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_77985 (h0 : topological_space (has_pos_part (has_bot Type))) : totally_separated_space (has_pos_part (has_bot Type)) := sorry --non-trivial
lemma new_lemma_77986 (h0 h1 : multiset (has_div std_gen)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_77987 (h0 : not (complete_lattice (with_one num) -> false)) : @is_atomistic.{0} (with_one.{0} num) (@classical.by_contradiction'.{1} (complete_lattice.{0} (with_one.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_77988 (h0 : topological_space (measurable_space (semiring (semiring unsigned)))) : t0_space (measurable_space (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_77989 (h0 : topological_space (complete_distrib_lattice (add_comm_monoid ennreal))) : loc_path_connected_space (complete_distrib_lattice (add_comm_monoid ennreal)) := sorry --non-trivial
lemma new_lemma_77990 (h0 : list (add_left_cancel_semigroup (semiring empty))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_77991 (h0 : topological_space (ordered_cancel_add_comm_monoid (option (option (option (option empty)))))) : locally_compact_space (ordered_cancel_add_comm_monoid (option (option (option (option empty))))) := sorry --non-trivial
lemma new_lemma_77992 (h0 : function.extfun Type ring) : @is_domain.{0} (normed_comm_ring.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (normed_comm_ring.{0} num))  := sorry --non-trivial
lemma new_lemma_77993 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (linear_ordered_cancel_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_cancel_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_77994 (h0 : topological_space (comm_group (random_gen num))) : path_connected_space (comm_group (random_gen num)) := sorry --non-trivial
lemma new_lemma_77995 (h2 : not (monoid (has_top to_additive.value_type) -> false)) : @monoid.fg.{0} (has_top.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (monoid.{0} (has_top.{0} to_additive.value_type)) h2)  := sorry --non-trivial
lemma new_lemma_77996 (h0 : list (has_neg_part (has_neg_part Type))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_77997 (h1 : add_group (has_top fun_info)) : is_add_cyclic (has_top fun_info) := sorry --non-trivial
lemma new_lemma_77998 (h0 : functor.add_const (topological_space (canonically_ordered_monoid real)) (has_Inf (ordered_comm_monoid real))) : @topological_space.separable_space.{0} (canonically_ordered_monoid.{0} real) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_monoid.{0} real)) (has_Inf.{0} (ordered_comm_monoid.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_77999 (h0 : not (uniform_space (measurable_space num) -> false)) : @complete_space.{0} (measurable_space.{0} num) (@classical.by_contradiction'.{1} (uniform_space.{0} (measurable_space.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_78000 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (with_bot.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (with_bot.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_78001 (h0 : decidable_eq (nondiscrete_normed_field linarith.ineq)) (h1 : equiv.perm (nondiscrete_normed_field linarith.ineq)) : equiv.perm.is_swap h1 := sorry --non-trivial
lemma new_lemma_78002 (h0 : topological_space (ordered_comm_monoid (has_add (ring linarith.comp)))) : t0_space (ordered_comm_monoid (has_add (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_78003 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (has_nndist.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_nndist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_78004 (h0 : topological_space (measurable_space (has_norm (random_gen (id linarith.ineq))))) : path_connected_space (measurable_space (has_norm (random_gen (id linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_78005 (h0 : topological_space (add_group (semiring unsigned))) : irreducible_space (add_group (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_78006 (h0 : ring (monoid num)) : strong_rank_condition (monoid num) := sorry --non-trivial
lemma new_lemma_78007 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_78008 (h0 : group (normed_group unsigned)) : normalizer_condition (normed_group unsigned) := sorry --non-trivial
lemma new_lemma_78009 (h0 : group (boolean_algebra.core (has_add linarith.comp))) : is_cyclic (boolean_algebra.core (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_78010 (h0 : topological_space (finset pos)) : locally_compact_space (finset pos) := sorry --non-trivial
lemma new_lemma_78011 (h0 : group (linear_ordered_semiring unsigned)) : is_cyclic (linear_ordered_semiring unsigned) := sorry --non-trivial
lemma new_lemma_78012 (h0 : topological_space (dlist (has_nnnorm linarith.comp_source))) : t0_space (dlist (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_78013 (h0 : semiring (add_cancel_comm_monoid unsigned)) : is_noetherian_ring (add_cancel_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_78014 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (mul_zero_class.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (mul_zero_class.{0} name))  := sorry --non-trivial
lemma new_lemma_78015 (h0 : function.extfun Type (functor.add_const (list (has_pos_part empty)))) : list.nodup (functor.add_const.run (function.extfun_app h0 (semiring empty))) := sorry --non-trivial
lemma new_lemma_78016 (h0 : functor.add_const (topological_space (has_nndist Type)) pos) : @preirreducible_space.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_nndist.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_78017 (h0 : functor.add_const (ordered_comm_monoid (has_to_string unsigned)) unsigned) : @has_exists_mul_of_le.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_to_string.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_78018 (h0 : functor.add_const (topological_space (semigroup linarith.comp)) (has_neg_part pos)) : @totally_disconnected_space.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} linarith.comp)) (has_neg_part.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_78019 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (boolean_algebra.core.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (boolean_algebra.core.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_78020 (h0 : topological_space (has_ssubset environment.projection_info)) : t0_space (has_ssubset environment.projection_info) := sorry --non-trivial
lemma new_lemma_78021 (h0 : topological_space (add_cancel_monoid (finset (finset pos)))) : sequential_space (add_cancel_monoid (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_78022 (h0 : topological_space (has_to_string (has_add name))) : irreducible_space (has_to_string (has_add name)) := sorry --non-trivial
lemma new_lemma_78023 (h0 : topological_space (denumerable (preorder (complete_semilattice_Sup complex)))) : locally_compact_space (denumerable (preorder (complete_semilattice_Sup complex))) := sorry --non-trivial
lemma new_lemma_78024 (h0 : complete_lattice (semi_normed_comm_ring (metric_space char))) : complete_lattice.is_Sup_finite_compact (semi_normed_comm_ring (metric_space char)) := sorry --non-trivial
lemma new_lemma_78025 (h0 : topological_space (dlist (has_nnnorm int))) : path_connected_space (dlist (has_nnnorm int)) := sorry --non-trivial
lemma new_lemma_78026 (h0 : topological_space (plift congr_arg_kind)) : preirreducible_space (plift congr_arg_kind) := sorry --non-trivial
lemma new_lemma_78027 (h0 : functor.add_const (complete_lattice (has_to_string linarith.comp)) linarith.comp) : @is_compactly_generated.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_to_string.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_78028 (h0 : topological_space (add_comm_monoid (comm_group pos))) : preconnected_space (add_comm_monoid (comm_group pos)) := sorry --non-trivial
lemma new_lemma_78029 (h0 : semiring (sub_neg_monoid (has_Inf pos))) : is_noetherian_ring (sub_neg_monoid (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_78030 (h0 : ring (has_div (has_nnnorm enat))) : strong_rank_condition (has_div (has_nnnorm enat)) := sorry --non-trivial
lemma new_lemma_78031 (h1 : function.extfun Type add_group) : @is_add_cyclic.{0} (complete_semilattice_Sup.{0} string_imp) (@function.extfun_app.{2 1} Type add_group.{0} h1 (complete_semilattice_Sup.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_78032 (h1 : not (ring (has_lt string_imp) -> false)) : @is_domain.{0} (has_lt.{0} string_imp) (@classical.by_contradiction'.{1} (ring.{0} (has_lt.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_78033 (h0 : monoid (semiring (has_top (has_top linarith.ineq)))) : monoid.fg (semiring (has_top (has_top linarith.ineq))) := sorry --non-trivial
lemma new_lemma_78034 (h0 : topological_space (complete_distrib_lattice string_imp)) : totally_disconnected_space (complete_distrib_lattice string_imp) := sorry --non-trivial
lemma new_lemma_78035 (h0 : topological_space (add_cancel_monoid ennreal)) : t1_space (add_cancel_monoid ennreal) := sorry --non-trivial
lemma new_lemma_78036 (h0 : has_lt (has_div enat)) : no_max_order (has_div enat) := sorry --non-trivial
lemma new_lemma_78037 (h0 : group (add_comm_monoid empty)) : is_cyclic (add_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_78038 (h0 : functor.add_const (topological_space environment.implicit_infer_kind) Type) : @preconnected_space.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 1} (topological_space.{0} environment.implicit_infer_kind) Type h0)  := sorry --non-trivial
lemma new_lemma_78039 (h0 : not (list (normed_group to_additive.value_type) -> false)) : list.nodup (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_78040 (h0 : topological_space (comm_group (comm_group Type))) : normal_space (comm_group (comm_group Type)) := sorry --non-trivial
lemma new_lemma_78041 (h0 : functor.add_const (topological_space (mul_zero_class empty)) congr_arg_kind) : @path_connected_space.{0} (mul_zero_class.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_78042 (h0 : filter (has_nndist empty)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_78043 (h0 : topological_space (has_ssubset (add_comm_semigroup string.iterator_imp))) : totally_disconnected_space (has_ssubset (add_comm_semigroup string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_78044 (h0 : group (ordered_comm_monoid (ordered_comm_monoid Type))) : normalizer_condition (ordered_comm_monoid (ordered_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_78045 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (finset.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (finset.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_78046 (h0 : complete_lattice (canonically_ordered_monoid num)) : is_compactly_generated (canonically_ordered_monoid num) := sorry --non-trivial
lemma new_lemma_78047 (h0 : list (simple_graph (has_Inf pos))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_78048 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (random_gen.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (random_gen.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_78049 (h0 : group (pseudo_metric_space (option (option (option pos))))) : normalizer_condition (pseudo_metric_space (option (option (option pos)))) := sorry --non-trivial
lemma new_lemma_78050 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (canonically_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (canonically_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_78051 (h0 : functor.add_const (topological_space (has_to_string name)) Type) : @t0_space.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (has_to_string.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_78052 (h0 : topological_space (complete_semilattice_Sup (semiring unsigned))) : path_connected_space (complete_semilattice_Sup (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_78053 (h0 : filter (has_compl (complete_distrib_lattice char))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_78054 (h0 : topological_space (normed_group linarith.comp_source)) : totally_separated_space (normed_group linarith.comp_source) := sorry --non-trivial
lemma new_lemma_78055 (h0 : functor.add_const (ordered_comm_monoid (ordered_comm_monoid pos)) pos) : @has_exists_mul_of_le.{0} (ordered_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (ordered_comm_monoid.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_78056 (h0 : function.extfun nat fin) : @preirreducible_space.{0} (comm_semigroup.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (comm_semigroup.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_78057 (h0 : with_bot (topological_space (add_right_cancel_monoid num))) (h1 : ne h0 has_bot.bot) : @locally_compact_space.{0} (add_right_cancel_monoid.{0} num) (@with_bot.unbot.{0} (topological_space.{0} (add_right_cancel_monoid.{0} num)) h0 h1)  := sorry --non-trivial
lemma new_lemma_78058 (h0 : topological_space (add_right_cancel_monoid congr_arg_kind)) : totally_separated_space (add_right_cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_78059 (h0 : functor.add_const (complete_lattice (add_comm_monoid Type)) (has_to_string environment.implicit_infer_kind)) : @is_compactly_generated.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (add_comm_monoid.{1} Type)) (has_to_string.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_78060 (h0 : functor.add_const (complete_lattice (left_cancel_monoid empty)) congr_arg_kind) : @is_compactly_generated.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (left_cancel_monoid.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_78061 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (preorder.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (preorder.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_78062 (h0 : functor.add_const (add_monoid (add_comm_monoid linarith.comp)) name) : @add_monoid.fg.{0} (add_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_monoid.{0} (add_comm_monoid.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_78063 (h0 : function.extfun Type monoid) : @monoid.fg.{0} pos (@function.extfun_app.{2 1} Type monoid.{0} h0 pos)  := sorry --non-trivial
lemma new_lemma_78064 (h0 : semiring (boolean_algebra (finset pos))) : is_noetherian_ring (boolean_algebra (finset pos)) := sorry --non-trivial
lemma new_lemma_78065 (h0 : filter (comm_ring (random_gen (comm_ring linarith.ineq)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_78066 (h0 : topological_space (with_bot (random_gen (random_gen (random_gen to_additive.value_type))))) : t0_space (with_bot (random_gen (random_gen (random_gen to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_78067 (h0 : ring (mul_zero_class (semiring num))) : strong_rank_condition (mul_zero_class (semiring num)) := sorry --non-trivial
lemma new_lemma_78068 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (group_with_zero congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_78069 (h0 : group (normed_comm_ring (has_add linarith.comp))) : is_simple_group (normed_comm_ring (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_78070 (h0 : functor.add_const (add_monoid (has_neg_part Type)) linarith.comp) : @add_monoid.fg.{1} (has_neg_part.{1} Type) (@functor.add_const.run.{1 0} (add_monoid.{1} (has_neg_part.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_78071 (h0 : ring (monoid (option empty))) : is_principal_ideal_ring (monoid (option empty)) := sorry --non-trivial
lemma new_lemma_78072 (h0 : list (add_comm_monoid (has_neg_part (has_add pos)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_78073 (h0 : topological_space (has_neg_part ennreal)) : discrete_topology (has_neg_part ennreal) := sorry --non-trivial
lemma new_lemma_78074 (h0 : topological_space (semiring (has_top fun_info))) : path_connected_space (semiring (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_78075 (h1 : topological_space (distrib_lattice (random_gen linarith.ineq))) : totally_disconnected_space (distrib_lattice (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_78076 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (id congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_78077 (h0 : not (add_monoid (id empty) -> false)) : @add_monoid.fg.{0} (@id.{2} Type empty) (@classical.by_contradiction'.{1} (add_monoid.{0} (@id.{2} Type empty)) h0)  := sorry --non-trivial
lemma new_lemma_78078 (h0 : complete_lattice (random_gen (has_norm (has_norm linarith.comp)))) : is_compactly_generated (random_gen (has_norm (has_norm linarith.comp))) := sorry --non-trivial
lemma new_lemma_78079 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (canonically_ordered_comm_semiring unsigned)) := sorry --non-trivial
lemma new_lemma_78080 (h0 : functor.add_const (topological_space (has_neg pos)) Type) : @regular_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_78081 (h0 : functor.add_const (topological_space (left_cancel_monoid empty)) num) : @preirreducible_space.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_78082 (h2 : uniform_space linarith.ineq) : complete_space linarith.ineq := sorry --non-trivial
lemma new_lemma_78083 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (ring.{0} ennreal) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_78084 (h0 : not (ring (simple_graph reducibility_hints) -> false)) : @strong_rank_condition.{0} (simple_graph.{0} reducibility_hints) (@classical.by_contradiction'.{1} (ring.{0} (simple_graph.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_78085 (h0 : topological_space (ordered_comm_ring (has_Inf name))) : preconnected_space (ordered_comm_ring (has_Inf name)) := sorry --non-trivial
lemma new_lemma_78086 (h0 : topological_space (semigroup (option empty))) : discrete_topology (semigroup (option empty)) := sorry --non-trivial
lemma new_lemma_78087 (h0 : complete_lattice (uniform_space (random_gen linarith.comp_source))) : is_compactly_generated (uniform_space (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_78088 (h0 : topological_space (canonically_linear_ordered_monoid (option ennreal))) : locally_compact_space (canonically_linear_ordered_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_78089 (h0 : filter (comm_group (has_add (has_add (has_add Type))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_78090 (h0 : functor.add_const (topological_space (ordered_comm_ring name)) name) : @loc_path_connected_space.{0} (ordered_comm_ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_78091 (h0 : functor.add_const (filter (add_cancel_monoid ennreal)) pos) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_78092 (h0 : list (has_Inf (has_neg linarith.comp))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_78093 (h0 : ring (with_one (comm_ring (random_gen fun_info)))) : rank_condition (with_one (comm_ring (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_78094 (h1 : semiring (add_comm_semigroup fun_info)) (h2 : ideal (add_comm_semigroup fun_info)) : ideal.is_prime h2 := sorry --non-trivial
lemma new_lemma_78095 (h0 : ring (has_compl environment.projection_info)) : strong_rank_condition (has_compl environment.projection_info) := sorry --non-trivial
lemma new_lemma_78096 (h0 : has_mem.mem (complete_semilattice_Sup linarith.ineq) has_emptyc.emptyc) : filter.ne_bot (finset.pi.empty filter (complete_semilattice_Sup linarith.ineq) h0) := sorry --non-trivial
lemma new_lemma_78097 (h0 : topological_space (finset (has_Inf linarith.comp))) : path_connected_space (finset (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_78098 (h0 : topological_space (finset (semigroup pos))) : discrete_topology (finset (semigroup pos)) := sorry --non-trivial
lemma new_lemma_78099 (h0 : filter (distrib_lattice (has_top linarith.ineq))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_78100 (h0 : functor.add_const (topological_space (has_zero environment.implicit_infer_kind)) environment.implicit_infer_kind) : @irreducible_space.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_78101 (h0 : list (has_zero (has_neg_part Type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_78102 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (normed_linear_ordered_group.{0} (semiring.{0} congr_arg_kind)) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (normed_linear_ordered_group.{0} (semiring.{0} congr_arg_kind)))  := sorry --non-trivial
lemma new_lemma_78103 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (linear_ordered_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_78104 (h0 : topological_space (id (semiring (semiring unsigned)))) : discrete_topology (id (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_78105 (h0 : cancel_comm_monoid_with_zero (has_nndist (option (option empty)))) : unique_factorization_monoid (has_nndist (option (option empty))) := sorry --non-trivial
lemma new_lemma_78106 (h0 : measurable_space char) (h1 : set char) : measurable_set h1 := sorry --non-trivial
lemma new_lemma_78107 (h1 : ring (has_add fun_info)) : rank_condition (has_add fun_info) := sorry --non-trivial
lemma new_lemma_78108 (h0 : functor.add_const (complete_lattice (has_edist unsigned)) empty) : @is_atomistic.{0} (has_edist.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_edist.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_78109 (h0 : functor.add_const (ring (left_cancel_monoid num)) (semiring (semiring num))) : @is_domain.{0} (left_cancel_monoid.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (left_cancel_monoid.{0} num)) (semiring.{0} (semiring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_78110 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_emptyc.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_emptyc.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_78111 (h0 : topological_space (semigroup (finset linarith.comp))) : regular_space (semigroup (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_78112 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @t0_space.{0} (measurable_space.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (measurable_space.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_78113 (h0 : group (has_Inf (has_add pos))) : normalizer_condition (has_Inf (has_add pos)) := sorry --non-trivial
lemma new_lemma_78114 (h0 : semiring (ring (mul_one_class linarith.comp))) : is_noetherian_ring (ring (mul_one_class linarith.comp)) := sorry --non-trivial
lemma new_lemma_78115 (h0 : functor.add_const (list (add_left_cancel_semigroup empty)) empty) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_78116 (h0 : functor.add_const (ring (has_nndist ennreal)) pos) : @strong_rank_condition.{0} (has_nndist.{0} ennreal) (@functor.add_const.run.{0 0} (ring.{0} (has_nndist.{0} ennreal)) pos h0)  := sorry --non-trivial
lemma new_lemma_78117 (h0 : topological_space (canonically_ordered_comm_semiring ennreal)) : discrete_topology (canonically_ordered_comm_semiring ennreal) := sorry --non-trivial
lemma new_lemma_78118 (h0 : functor.add_const (ring (complete_distrib_lattice pos)) (boolean_algebra Type)) : @strong_rank_condition.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (complete_distrib_lattice.{0} pos)) (boolean_algebra.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_78119 (h0 : functor.add_const (topological_space (add_comm_monoid Type)) name) : @locally_compact_space.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_comm_monoid.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_78120 (h0 : complete_lattice (ring (ring (has_add Type)))) : is_atomistic (ring (ring (has_add Type))) := sorry --non-trivial
lemma new_lemma_78121 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem ring)) : @strong_rank_condition.{0} (normed_group.{0} linarith.ineq) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) ring.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (normed_group.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_78122 (h0 : group (has_add (has_pos_part linarith.comp))) : normalizer_condition (has_add (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_78123 (h0 : semiring (ring (has_neg (finset linarith.comp)))) : is_noetherian_ring (ring (has_neg (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_78124 (h1 : topological_space (metric_space linarith.comp)) : normal_space (metric_space linarith.comp) := sorry --non-trivial
lemma new_lemma_78125 (h0 : topological_space (normed_group (has_ssubset fun_info))) : irreducible_space (normed_group (has_ssubset fun_info)) := sorry --non-trivial
lemma new_lemma_78126 (h0 : function.extfun Type (functor.add_const (finset (left_cancel_monoid unsigned)))) : finset.nonempty (functor.add_const.run (function.extfun_app h0 unsigned)) := sorry --non-trivial
lemma new_lemma_78127 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (add_cancel_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type semiring.{0} h0 (add_cancel_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_78128 (h0 : ordered_add_comm_monoid (add_right_cancel_monoid (semiring empty))) : archimedean (add_right_cancel_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_78129 (h0 : fin has_zero.zero) : @is_noetherian_ring.{1} (simple_graph.{1} Type) (@matrix.vec_empty.{1} (semiring.{1} (simple_graph.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_78130 (h0 : topological_space (with_bot (dlist linarith.ineq))) : t0_space (with_bot (dlist linarith.ineq)) := sorry --non-trivial
lemma new_lemma_78131 (h1 : topological_space (has_ssubset to_additive.value_type)) : t0_space (has_ssubset to_additive.value_type) := sorry --non-trivial
lemma new_lemma_78132 (h0 : filter (add_right_cancel_monoid unsigned)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_78133 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (@id.{2} Type unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (@id.{2} Type unsigned))  := sorry --non-trivial
lemma new_lemma_78134 (h0 : not (add_group (has_add fun_info) -> false)) : @is_add_cyclic.{0} (has_add.{0} fun_info) (@classical.by_contradiction'.{1} (add_group.{0} (has_add.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_78135 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (with_bot.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (with_bot.{0} num))  := sorry --non-trivial
lemma new_lemma_78136 (h0 : functor.add_const (add_group (boolean_algebra.core pos)) environment.implicit_infer_kind) : @is_add_cyclic.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (boolean_algebra.core.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_78137 (h1 : topological_space (has_top (has_top (has_top linarith.comp_source)))) : t0_space (has_top (has_top (has_top linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_78138 (h0 : has_mem.mem (with_one num) has_emptyc.emptyc) : @is_domain.{0} (with_one.{0} num) (@finset.pi.empty.{1 0} Type ring.{0} (with_one.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_78139 (h0 : group (has_Sup (semiring empty))) : normalizer_condition (has_Sup (semiring empty)) := sorry --non-trivial
lemma new_lemma_78140 (h0 : group (linear_ordered_semiring (semiring (semiring congr_arg_kind)))) : is_cyclic (linear_ordered_semiring (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_78141 (h0 : ring (ring (option unsigned))) : rank_condition (ring (option unsigned)) := sorry --non-trivial
lemma new_lemma_78142 (h0 : group (canonically_ordered_comm_semiring Type)) : group.fg (canonically_ordered_comm_semiring Type) := sorry --non-trivial
lemma new_lemma_78143 (h0 : filter (has_add (finset (finset (finset (finset (finset linarith.comp))))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_78144 (h0 : add_group (ordered_cancel_add_comm_monoid pos)) (h1 : add_subgroup (ordered_cancel_add_comm_monoid pos)) : add_subgroup.normal h1 := sorry --non-trivial
lemma new_lemma_78145 (h0 : functor.add_const (topological_space (comm_group environment.implicit_infer_kind)) linarith.comp) : @t0_space.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_78146 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (add_cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_78147 (h0 : functor.add_const (group (has_nndist linarith.comp)) pos) : @group.fg.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (has_nndist.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_78148 (h0 : ring (id (semiring congr_arg_kind))) : rank_condition (id (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_78149 (h0 : filter (complete_distrib_lattice (finset unsigned))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_78150 (h0 : complete_lattice (has_emptyc (has_norm congr_arg_kind))) : complete_lattice.is_Sup_finite_compact (has_emptyc (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_78151 (h0 : not (topological_space (left_cancel_semigroup unsigned) -> false)) : @path_connected_space.{0} (left_cancel_semigroup.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (left_cancel_semigroup.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_78152 (h2 : set (char -> string.iterator_imp)) : set.separates_points h2 := sorry --non-trivial
lemma new_lemma_78153 (h0 : functor.comp topological_space add_comm_monoid Type) : @loc_path_connected_space.{1} (add_comm_monoid.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} add_comm_monoid.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_78154 (h2 : function.extfun Type group) : @group.fg.{0} linarith.comp_source (@function.extfun_app.{2 1} Type group.{0} h2 linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_78155 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} linarith.comp (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) linarith.comp)  := sorry --non-trivial
lemma new_lemma_78156 (h0 : semiring (finset (finset (ordered_ring (has_neg linarith.comp))))) : is_noetherian_ring (finset (finset (ordered_ring (has_neg linarith.comp)))) := sorry --non-trivial
lemma new_lemma_78157 (h0 : functor.add_const (uniform_space (has_neg_part environment.implicit_infer_kind)) name) : @separated_space.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_neg_part.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_78158 (h0 : preorder (semi_normed_comm_ring linarith.ineq)) (h1 : set (semi_normed_comm_ring linarith.ineq)) : set.ord_connected h1 := sorry --non-trivial
lemma new_lemma_78159 (h0 : monoid (add_cancel_comm_monoid unsigned)) : monoid.fg (add_cancel_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_78160 (h0 : functor.comp topological_space boolean_algebra.core name) : @preirreducible_space.{0} (boolean_algebra.core.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} boolean_algebra.core.{0} name h0)  := sorry --non-trivial
lemma new_lemma_78161 (h0 : functor.add_const (function.extfun Type ring) (has_neg environment.implicit_infer_kind)) : @is_principal_ideal_ring.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) (has_neg.{0} environment.implicit_infer_kind) h0) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_78162 (h0 : not (ring (add_group congr_arg_kind) -> false)) : @strong_rank_condition.{0} (add_group.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (ring.{0} (add_group.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_78163 (h0 : group (comm_group (has_nndist (canonically_linear_ordered_monoid pos)))) : group.fg (comm_group (has_nndist (canonically_linear_ordered_monoid pos))) := sorry --non-trivial
lemma new_lemma_78164 (h0 : functor.add_const (topological_space (add_group num)) congr_arg_kind) : @t0_space.{0} (add_group.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (add_group.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_78165 (h0 : ring (has_union (has_top (has_top (has_top num))))) : rank_condition (has_union (has_top (has_top (has_top num)))) := sorry --non-trivial
lemma new_lemma_78166 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (bin_tree.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (bin_tree.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_78167 (h0 : functor.add_const (filter (boolean_algebra.core pos)) Type) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_78168 (h0 : ring (has_neg (has_add (has_add (has_add environment.implicit_infer_kind))))) : is_principal_ideal_ring (has_neg (has_add (has_add (has_add environment.implicit_infer_kind)))) := sorry --non-trivial
lemma new_lemma_78169 (h0 : list (normed_comm_ring linarith.comp)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_78170 (h0 : function.extfun (Type 1) complete_lattice) : @is_atomistic.{1} (normed_comm_ring.{1} (add_comm_monoid.{1} (semigroup.{1} (finset.{1} (add_comm_monoid.{1} Type))))) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} h0 (normed_comm_ring.{1} (add_comm_monoid.{1} (semigroup.{1} (finset.{1} (add_comm_monoid.{1} Type))))))  := sorry --non-trivial
lemma new_lemma_78171 (h0 : ring (has_neg (has_add (has_add (has_add Type))))) : is_domain (has_neg (has_add (has_add (has_add Type)))) := sorry --non-trivial
lemma new_lemma_78172 (h0 : ring (id (random_gen (has_top (random_gen (has_top num)))))) : rank_condition (id (random_gen (has_top (random_gen (has_top num))))) := sorry --non-trivial
lemma new_lemma_78173 (h0 : uniform_space (has_union (has_top (linear_ordered_semiring unsigned)))) : separated_space (has_union (has_top (linear_ordered_semiring unsigned))) := sorry --non-trivial
lemma new_lemma_78174 (h0 : add_comm_group reducibility_hints) (h1 : topological_space (random_gen (add_comm_group.total_positive_cone reducibility_hints))) : path_connected_space (random_gen (add_comm_group.total_positive_cone reducibility_hints)) := sorry --non-trivial
lemma new_lemma_78175 (h1 : topological_space (id (random_gen to_additive.value_type))) : totally_separated_space (id (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_78176 (h0 : function.extfun nat fin) : @is_simple_group.{0} (canonically_linear_ordered_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (group.{0} (canonically_linear_ordered_monoid.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_78177 (h0 : uniform_space (with_bot (has_norm (has_norm num)))) : complete_space (with_bot (has_norm (has_norm num))) := sorry --non-trivial
lemma new_lemma_78178 (h0 : semiring (canonically_ordered_comm_semiring (has_add (ring (has_neg (ring pos)))))) : is_noetherian_ring (canonically_ordered_comm_semiring (has_add (ring (has_neg (ring pos))))) := sorry --non-trivial
lemma new_lemma_78179 (h0 : ordered_comm_monoid (ring (option pos))) : has_exists_mul_of_le (ring (option pos)) := sorry --non-trivial
lemma new_lemma_78180 (h0 : functor.add_const (ring (cancel_monoid environment.implicit_infer_kind)) name) : @strong_rank_condition.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (cancel_monoid.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_78181 (h0 : fin has_zero.zero) : @irreducible_space.{0} (has_bot.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (has_bot.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_78182 (h0 : function.extfun Type ring) : @is_domain.{0} (boolean_algebra.core.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} h0 (boolean_algebra.core.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_78183 (h0 : topological_space (semiring (random_gen (random_gen (random_gen (semiring num)))))) : totally_disconnected_space (semiring (random_gen (random_gen (random_gen (semiring num))))) := sorry --non-trivial
lemma new_lemma_78184 (h0 : group (ring (option ennreal))) : normalizer_condition (ring (option ennreal)) := sorry --non-trivial
lemma new_lemma_78185 (h0 : filter (filter unsigned)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_78186 (h0 : complete_lattice (dlist (distrib_lattice to_additive.value_type))) : complete_lattice.is_Sup_finite_compact (dlist (distrib_lattice to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_78187 (h0 : ring (add_right_cancel_semigroup linarith.comp_source)) : is_domain (add_right_cancel_semigroup linarith.comp_source) := sorry --non-trivial
lemma new_lemma_78188 (h0 : functor.add_const (topological_space auto.case_option) (option (option unsigned))) : @path_connected_space.{0} auto.case_option (@functor.add_const.run.{0 0} (topological_space.{0} auto.case_option) (option.{0} (option.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_78189 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (linear_ordered_semiring.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (linear_ordered_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_78190 (h0 : topological_space (simple_graph (finset (has_neg linarith.comp)))) : locally_compact_space (simple_graph (finset (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_78191 (h1 : uniform_space char) : complete_space char := sorry --non-trivial
lemma new_lemma_78192 (h0 : add_group (comm_ring linarith.ineq)) : is_add_cyclic (comm_ring linarith.ineq) := sorry --non-trivial
lemma new_lemma_78193 (h0 : topological_space (fintype (comm_ring char))) : totally_disconnected_space (fintype (comm_ring char)) := sorry --non-trivial
lemma new_lemma_78194 (h0 : topological_space (comm_group (ring Type))) : totally_disconnected_space (comm_group (ring Type)) := sorry --non-trivial
lemma new_lemma_78195 (h0 : not (topological_space linarith.comp_source -> false)) : @t0_space.{0} linarith.comp_source (@classical.by_contradiction'.{1} (topological_space.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_78196 (h0 : fin has_zero.zero) : @t1_space.{1} (canonically_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (canonically_ordered_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_78197 (h0 : functor.add_const (ring (has_add linarith.comp)) name) : @is_domain.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_add.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_78198 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_neg.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_neg.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_78199 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_dist.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_dist.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_78200 (h0 : ring (plift (semiring unsigned))) : strong_rank_condition (plift (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_78201 (h1 : complete_lattice (dlist fun_info)) : complete_lattice.is_Sup_finite_compact (dlist fun_info) := sorry --non-trivial
lemma new_lemma_78202 (h0 : functor.add_const (topological_space (has_nndist unsigned)) (option (option (option unsigned)))) : @t0_space.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} unsigned)) (option.{0} (option.{0} (option.{0} unsigned))) h0)  := sorry --non-trivial
lemma new_lemma_78203 (h0 : uniform_space (comm_semigroup (comm_semigroup pos))) : complete_space (comm_semigroup (comm_semigroup pos)) := sorry --non-trivial
lemma new_lemma_78204 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (has_to_string.{0} unsigned) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (has_to_string.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_78205 (h0 : topological_space (with_one (metric_space linarith.comp))) : totally_separated_space (with_one (metric_space linarith.comp)) := sorry --non-trivial
lemma new_lemma_78206 (h0 : uniform_space (linear_ordered_field congr_arg_kind)) : separated_space (linear_ordered_field congr_arg_kind) := sorry --non-trivial
lemma new_lemma_78207 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (add_cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (add_cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_78208 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (monoid_with_zero (option pos))) := sorry --non-trivial
lemma new_lemma_78209 (h0 : topological_space (has_star (semiring unsigned))) : topological_space.separable_space (has_star (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_78210 (h0 : topological_space (generalized_boolean_algebra linarith.comp)) : totally_separated_space (generalized_boolean_algebra linarith.comp) := sorry --non-trivial
lemma new_lemma_78211 (h0 : monoid (measurable_space (bin_tree unsigned))) : monoid.fg (measurable_space (bin_tree unsigned)) := sorry --non-trivial
lemma new_lemma_78212 (h0 : functor.add_const (semiring (add_comm_monoid empty)) (option empty)) : @is_noetherian_ring.{0} (add_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (semiring.{0} (add_comm_monoid.{0} empty)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_78213 (h0 : ring (normed_field (random_gen reducibility_hints))) : is_domain (normed_field (random_gen reducibility_hints)) := sorry --non-trivial
lemma new_lemma_78214 (h0 : functor.add_const (topological_space (has_Inf name)) linarith.comp) : @t1_space.{0} (has_Inf.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_78215 (h6 : add_group (non_unital_non_assoc_semiring string_imp)) : is_add_cyclic (non_unital_non_assoc_semiring string_imp) := sorry --non-trivial
lemma new_lemma_78216 (h0 : functor.add_const (topological_space (has_zero pos)) linarith.comp) : @normal_space.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_78217 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (normed_linear_ordered_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_linear_ordered_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_78218 (h0 : topological_space (with_one (has_norm (semiring unsigned)))) : locally_compact_space (with_one (has_norm (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_78219 (h0 : functor.add_const (add_monoid (normed_linear_ordered_group congr_arg_kind)) empty) : @add_monoid.fg.{0} (normed_linear_ordered_group.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (add_monoid.{0} (normed_linear_ordered_group.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_78220 (h1 : topological_space (encodable (random_gen fun_info))) : t0_space (encodable (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_78221 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (linear_ordered_add_comm_group fun_info)) := sorry --non-trivial
lemma new_lemma_78222 (h0 : functor.add_const (function.extfun Type list) Type) : palindrome (function.extfun_app (functor.add_const.run h0) (simple_graph linarith.comp)) := sorry --non-trivial
lemma new_lemma_78223 (h0 : add_monoid (canonically_ordered_comm_semiring (has_Inf Type))) : add_monoid.fg (canonically_ordered_comm_semiring (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_78224 (h1 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} to_additive.value_type (@function.extfun_app.{2 1} Type complete_lattice.{0} h1 to_additive.value_type)  := sorry --non-trivial
lemma new_lemma_78225 (h0 : topological_space (has_nnnorm (mul_one_class environment.projection_info))) : totally_disconnected_space (has_nnnorm (mul_one_class environment.projection_info)) := sorry --non-trivial
lemma new_lemma_78226 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (add_cancel_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_cancel_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_78227 (h0 : complete_lattice (random_gen (has_norm (has_inv linarith.ineq)))) : is_atomistic (random_gen (has_norm (has_inv linarith.ineq))) := sorry --non-trivial
lemma new_lemma_78228 (h0 : ring (has_nnnorm (has_nnnorm (has_nnnorm (has_lt char))))) : strong_rank_condition (has_nnnorm (has_nnnorm (has_nnnorm (has_lt char)))) := sorry --non-trivial
lemma new_lemma_78229 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} (normed_group.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (normed_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_78230 (h0 : complete_lattice (normed_lattice_add_comm_group real)) : complete_lattice.is_Sup_finite_compact (normed_lattice_add_comm_group real) := sorry --non-trivial
lemma new_lemma_78231 (h0 : topological_space (add_cancel_monoid num)) : totally_disconnected_space (add_cancel_monoid num) := sorry --non-trivial
lemma new_lemma_78232 (h0 : complete_lattice (ring (boolean_algebra.core Type))) : is_compactly_generated (ring (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_78233 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (canonically_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_78234 (h0 : uniform_space (semiring fun_info)) : complete_space (semiring fun_info) := sorry --non-trivial
lemma new_lemma_78235 (h0 : not (uniform_space (has_norm linarith.ineq) -> false)) : @separated_space.{0} (has_norm.{0} linarith.ineq) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_norm.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_78236 (h0 : functor.add_const (topological_space (add_comm_monoid Type)) name) : @irreducible_space.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_comm_monoid.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_78237 (h0 : functor.add_const (function.extfun Type semiring) empty) : @is_noetherian_ring.{0} (add_left_cancel_semigroup.{0} (semiring.{0} empty)) (@function.extfun_app.{2 1} Type semiring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type semiring.{0}) empty h0) (add_left_cancel_semigroup.{0} (semiring.{0} empty)))  := sorry --non-trivial
lemma new_lemma_78238 (h0 : complete_lattice (random_gen (has_norm linarith.comp_source))) : complete_lattice.is_Sup_finite_compact (random_gen (has_norm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_78239 (h0 : topological_space (ring unsigned)) : totally_separated_space (ring unsigned) := sorry --non-trivial
lemma new_lemma_78240 (h0 : semiring (finset (has_add linarith.comp))) : is_noetherian_ring (finset (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_78241 (h1 : set (comm_ring environment.projection_info)) : set.subsingleton h1 := sorry --non-trivial
lemma new_lemma_78242 (h0 : functor.add_const (topological_space (has_nndist name)) pos) : @regular_space.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_78243 (h1 : topological_space (semi_normed_comm_ring std_gen)) (h2 : add_group (semi_normed_comm_ring std_gen)) : topological_add_group (semi_normed_comm_ring std_gen) := sorry --non-trivial
lemma new_lemma_78244 (h0 : topological_space (has_nndist (normed_comm_ring linarith.comp))) : t1_space (has_nndist (normed_comm_ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_78245 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (ordered_cancel_add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_cancel_add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_78246 (h0 : monoid (monoid (option (option empty)))) : monoid.fg (monoid (option (option empty))) := sorry --non-trivial
lemma new_lemma_78247 (h0 : functor.add_const (topological_space (has_pos_part pos)) pos) : @sequential_space.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_78248 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type semiring.{0} h0 (cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_78249 (h0 : group (metric_space (semiring congr_arg_kind))) : is_cyclic (metric_space (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_78250 (h0 : group (has_add (cancel_monoid (has_zero (ring congr_arg_kind))))) : is_cyclic (has_add (cancel_monoid (has_zero (ring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_78251 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (linear_ordered_semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_78252 (h0 : functor.add_const (filter (finset ennreal)) unsigned) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_78253 (h0 : not (filter (plift empty) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_78254 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (complete_linear_order.{0} num) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (complete_linear_order.{0} num))  := sorry --non-trivial
lemma new_lemma_78255 (h0 : topological_space (complete_linear_order (semiring num))) : irreducible_space (complete_linear_order (semiring num)) := sorry --non-trivial
lemma new_lemma_78256 (h0 : topological_space (has_add (normed_comm_ring Type))) : irreducible_space (has_add (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_78257 (h0 : pos -> name -> Prop) : relator.right_total h0 := sorry --non-trivial
lemma new_lemma_78258 (h0 : not (list (dlist fun_info) -> false)) : list.nodup (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_78259 (h0 : functor.add_const (function.extfun Type topological_space) name) : @t1_space.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_78260 (h0 : uniform_space (dlist (random_gen to_additive.value_type))) : complete_space (dlist (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_78261 (h0 : functor.add_const (ring (has_neg pos)) (ring name)) : @strong_rank_condition.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_neg.{0} pos)) (ring.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_78262 (h0 : functor.add_const (add_group (finset name)) name) : @is_add_cyclic.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (add_group.{0} (finset.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_78263 (h0 : topological_space (has_neg (has_add environment.implicit_infer_kind))) : totally_separated_space (has_neg (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_78264 (h0 : add_group (ordered_comm_monoid (has_add (has_add pos)))) : is_add_cyclic (ordered_comm_monoid (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_78265 (h0 : measurable_space (has_lt string.iterator_imp)) (h1 : filter (has_lt string.iterator_imp)) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_78266 (h0 : functor.add_const Prop (plift empty)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_78267 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (has_to_string.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (has_to_string.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_78268 (h0 : function.extfun nat fin) : @normalizer_condition.{0} (ordered_comm_monoid.{0} name) (@matrix.vec_empty.{0} (group.{0} (ordered_comm_monoid.{0} name)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_78269 (h0 : topological_space (mul_zero_class (has_neg_part Type))) : loc_path_connected_space (mul_zero_class (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_78270 (h0 : functor.add_const (function.extfun Type ring) environment.implicit_infer_kind) : @is_principal_ideal_ring.{0} (has_nndist.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) environment.implicit_infer_kind h0) (has_nndist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_78271 (h0 : functor.add_const (topological_space (boolean_algebra.core environment.implicit_infer_kind)) pos) : @irreducible_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_78272 (h0 : functor.add_const (add_monoid (has_Inf real)) (has_bot (sub_neg_monoid real))) : @add_monoid.fg.{0} (has_Inf.{0} real) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_Inf.{0} real)) (has_bot.{0} (sub_neg_monoid.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_78273 (h0 : ring (normed_lattice_add_comm_group (has_Inf (has_add pos)))) : is_domain (normed_lattice_add_comm_group (has_Inf (has_add pos))) := sorry --non-trivial
lemma new_lemma_78274 (h0 : topological_space (simple_graph (has_neg name))) : preconnected_space (simple_graph (has_neg name)) := sorry --non-trivial
lemma new_lemma_78275 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} (encodable.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (encodable.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_78276 (h0 : not (function.extfun (finset Type) (has_mem.mem empty) -> false)) : @is_add_cyclic.{0} empty (@finset.pi.empty.{1 0} Type add_group.{0} empty (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) empty) (@classical.by_contradiction'.{0} (function.extfun.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) empty)) h0) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_78277 (h0 : group (has_neg (has_add linarith.comp))) : is_cyclic (has_neg (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_78278 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (has_norm.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_norm.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_78279 (h0 : uniform_space (generalized_boolean_algebra linarith.comp_source)) : complete_space (generalized_boolean_algebra linarith.comp_source) := sorry --non-trivial
lemma new_lemma_78280 (h0 : function.extfun Type ring) : @is_domain.{0} string_imp (@function.extfun_app.{2 1} Type ring.{0} h0 string_imp)  := sorry --non-trivial
lemma new_lemma_78281 (h0 : cancel_comm_monoid_with_zero (ordered_comm_group empty)) : unique_factorization_monoid (ordered_comm_group empty) := sorry --non-trivial
lemma new_lemma_78282 (h0 : complete_lattice (comm_group (finset (has_neg_part (has_nndist ennreal))))) : complete_lattice.is_Sup_finite_compact (comm_group (finset (has_neg_part (has_nndist ennreal)))) := sorry --non-trivial
lemma new_lemma_78283 (h0 : group (sub_neg_monoid (has_Inf (has_add pos)))) : is_simple_group (sub_neg_monoid (has_Inf (has_add pos))) := sorry --non-trivial
lemma new_lemma_78284 (h0 : add_group (mul_zero_class (finset (has_add (complete_distrib_lattice pos))))) : is_add_cyclic (mul_zero_class (finset (has_add (complete_distrib_lattice pos)))) := sorry --non-trivial
lemma new_lemma_78285 (h0 : group (has_neg (has_nndist ennreal))) : normalizer_condition (has_neg (has_nndist ennreal)) := sorry --non-trivial
lemma new_lemma_78286 (h0 : ordered_comm_monoid (ordered_comm_monoid (ordered_comm_ring Type))) : has_exists_mul_of_le (ordered_comm_monoid (ordered_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_78287 (h0 : functor.add_const (filter (linear_ordered_field ennreal)) ennreal) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_78288 (h0 : functor.add_const (monoid (add_cancel_monoid environment.implicit_infer_kind)) linarith.comp) : @monoid.fg.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (monoid.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_78289 (h0 : uniform_space (add_comm_semigroup fun_info)) : complete_space (add_comm_semigroup fun_info) := sorry --non-trivial
lemma new_lemma_78290 (h0 : functor.add_const (topological_space (mul_zero_class congr_arg_kind)) unsigned) : @loc_path_connected_space.{0} (mul_zero_class.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_78291 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (monoid_with_zero.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (monoid_with_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_78292 (h0 : functor.comp topological_space has_to_string Type) : @t0_space.{1} (has_to_string.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} has_to_string.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_78293 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_78294 (h0 : ring (has_div (has_lt string_imp))) : rank_condition (has_div (has_lt string_imp)) := sorry --non-trivial
lemma new_lemma_78295 (h0 : semiring (has_Inf (has_neg name))) : is_noetherian_ring (has_Inf (has_neg name)) := sorry --non-trivial
lemma new_lemma_78296 (h0 : cancel_comm_monoid_with_zero (has_zero (comm_group (comm_group ennreal)))) : unique_factorization_monoid (has_zero (comm_group (comm_group ennreal))) := sorry --non-trivial
lemma new_lemma_78297 (h1 : has_mem.mem (measurable_space linarith.comp) has_emptyc.emptyc) : @discrete_topology.{0} (measurable_space.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (measurable_space.{0} linarith.comp) h1)  := sorry --non-trivial
lemma new_lemma_78298 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_78299 (h0 : not (function.extfun Type uniform_space -> false)) : @separated_space.{0} (random_gen.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (random_gen.{0} empty))  := sorry --non-trivial
lemma new_lemma_78300 (h0 : list (omega_complete_partial_order unsigned)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_78301 (h0 : topological_space (complete_distrib_lattice (ring (ring name)))) : regular_space (complete_distrib_lattice (ring (ring name))) := sorry --non-trivial
lemma new_lemma_78302 (h0 : semiring (option (semiring unsigned))) : is_noetherian_ring (option (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_78303 (h0 : ring (add_comm_semigroup (has_Sup linarith.ineq))) : is_domain (add_comm_semigroup (has_Sup linarith.ineq)) := sorry --non-trivial
lemma new_lemma_78304 (h0 : topological_space (add_cancel_comm_monoid congr_arg_kind)) : totally_disconnected_space (add_cancel_comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_78305 (h0 : group (has_pos_part (has_add real))) : group.fg (has_pos_part (has_add real)) := sorry --non-trivial
lemma new_lemma_78306 (h0 : functor.add_const (function.extfun (Type 1) topological_space) environment.implicit_infer_kind) : @locally_compact_space.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) environment.implicit_infer_kind h0) (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_78307 (h0 : group (has_one fun_info)) : group.fg (has_one fun_info) := sorry --non-trivial
lemma new_lemma_78308 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (omega_complete_partial_order.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (omega_complete_partial_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_78309 (h0 : functor.add_const (topological_space (complete_distrib_lattice pos)) Type) : @discrete_topology.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (complete_distrib_lattice.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_78310 (h0 : not (topological_space (partial_order unsigned) -> false)) : @locally_compact_space.{0} (partial_order.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (partial_order.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_78311 (h0 : functor.add_const (semiring znum) (option (option (option (option (option (option (option empty)))))))) : @is_noetherian_ring.{0} znum (@functor.add_const.run.{0 0} (semiring.{0} znum) (option.{0} (option.{0} (option.{0} (option.{0} (option.{0} (option.{0} (option.{0} empty))))))) h0)  := sorry --non-trivial
lemma new_lemma_78312 (h0 : topological_space (generalized_boolean_algebra (has_bot (has_Inf real)))) : loc_path_connected_space (generalized_boolean_algebra (has_bot (has_Inf real))) := sorry --non-trivial
lemma new_lemma_78313 (h0 : ring (metric_space (random_gen char))) : rank_condition (metric_space (random_gen char)) := sorry --non-trivial
lemma new_lemma_78314 (h0 : topological_space (normed_comm_ring environment.implicit_infer_kind)) : loc_path_connected_space (normed_comm_ring environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_78315 (h0 : fin has_zero.zero) : @regular_space.{1} (has_pos_part.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (has_pos_part.{1} Type)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_78316 (h0 : functor.add_const (group (has_to_string name)) Type) : @group.fg.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 1} (group.{0} (has_to_string.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_78317 (h0 : functor.add_const (ring (generalized_boolean_algebra name)) name) : @rank_condition.{0} (generalized_boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (generalized_boolean_algebra.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_78318 (h0 : set (prod Type Type)) (h1 : prod Type Type) : symmetrize_rel h0 h1 := sorry --non-trivial
lemma new_lemma_78319 (h0 : ring (semigroup (semigroup Type))) : is_principal_ideal_ring (semigroup (semigroup Type)) := sorry --non-trivial
lemma new_lemma_78320 (h0 : topological_space (cancel_monoid linarith.comp)) : normal_space (cancel_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_78321 (h0 : functor.add_const (group (has_zero environment.implicit_infer_kind)) (has_Inf linarith.comp)) : @normalizer_condition.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (has_zero.{0} environment.implicit_infer_kind)) (has_Inf.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_78322 (h1 : uniform_space (measurable_space num)) : complete_space (measurable_space num) := sorry --non-trivial
lemma new_lemma_78323 (h0 : functor.add_const (topological_space (add_cancel_monoid pos)) pos) : @topological_space.separable_space.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_78324 (h0 : functor.add_const (ring (finset linarith.comp)) (has_neg name)) : @is_principal_ideal_ring.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (finset.{0} linarith.comp)) (has_neg.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_78325 (h0 : topological_space (linear_ordered_comm_monoid_with_zero congr_arg_kind)) : topological_space.separable_space (linear_ordered_comm_monoid_with_zero congr_arg_kind) := sorry --non-trivial
lemma new_lemma_78326 (h0 : functor.add_const (function.extfun Type ring) name) : @rank_condition.{0} (has_add.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) name h0) (has_add.{0} name))  := sorry --non-trivial
lemma new_lemma_78327 (h0 : functor.add_const (topological_space (has_nndist name)) linarith.comp) : @preconnected_space.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_78328 (h0 : topological_space (add_group (has_top unsigned))) : normal_space (add_group (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_78329 (h0 : topological_space (with_bot (random_gen num))) : discrete_topology (with_bot (random_gen num)) := sorry --non-trivial
lemma new_lemma_78330 (h4 : ring (has_compl char)) : rank_condition (has_compl char) := sorry --non-trivial
lemma new_lemma_78331 (h0 : topological_space (add_cancel_comm_monoid empty)) : normal_space (add_cancel_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_78332 (h0 : list (with_one (has_nnnorm (random_gen linarith.ineq)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_78333 (h0 : add_monoid (has_add (has_Inf (has_Inf (has_Inf (has_pos_part Type)))))) : add_monoid.fg (has_add (has_Inf (has_Inf (has_Inf (has_pos_part Type))))) := sorry --non-trivial
lemma new_lemma_78334 (h0 : functor.add_const (list (canonically_ordered_comm_semiring unsigned)) (option (option unsigned))) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_78335 (h0 : functor.add_const (ring (has_neg_part Type)) pos) : @is_domain.{1} (has_neg_part.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_neg_part.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_78336 (h0 : topological_space (add_comm_monoid (boolean_algebra.core Type))) : preirreducible_space (add_comm_monoid (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_78337 (h0 : ring (boolean_algebra.core (boolean_algebra.core Type))) : is_principal_ideal_ring (boolean_algebra.core (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_78338 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (normed_lattice_add_comm_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (normed_lattice_add_comm_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_78339 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (measurable_space.dynkin_system.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (measurable_space.dynkin_system.{0} num))  := sorry --non-trivial
lemma new_lemma_78340 (h0 : functor.add_const (ring (has_zero name)) linarith.comp) : @strong_rank_condition.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (has_zero.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_78341 (h1 : uniform_space (with_one (with_bot (random_gen linarith.comp_source)))) : complete_space (with_one (with_bot (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_78342 (h0 : list (comm_group (comm_group unsigned))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_78343 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_78344 (h0 : uniform_space (as_linear_order unsigned)) : separated_space (as_linear_order unsigned) := sorry --non-trivial
lemma new_lemma_78345 (h0 : functor.comp semiring boolean_algebra.core Type) : @is_noetherian_ring.{1} (boolean_algebra.core.{1} Type) (@functor.comp.run.{1 1 1} semiring.{1} boolean_algebra.core.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_78346 (h0 : not (cancel_comm_monoid_with_zero (linear_ordered_semiring num) -> false)) : @unique_factorization_monoid.{0} (linear_ordered_semiring.{0} num) (@classical.by_contradiction'.{1} (cancel_comm_monoid_with_zero.{0} (linear_ordered_semiring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_78347 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_sub.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_sub.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_78348 (h0 : not (function.extfun (Type 1) ring -> false)) : @is_domain.{1} (plift.{1} congr_arg_kind) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@classical.by_contradiction'.{3} (function.extfun.{3 2} (Type 1) ring.{1}) h0) (plift.{1} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_78349 (h0 : function.extfun Type (prod ennreal)) : id_rel (function.extfun_app h0 ennreal) := sorry --non-trivial
lemma new_lemma_78350 (h0 : complete_lattice (comm_semigroup (has_Inf real))) : is_compactly_generated (comm_semigroup (has_Inf real)) := sorry --non-trivial
lemma new_lemma_78351 (h0 : functor.add_const (topological_space (preorder num)) empty) : @path_connected_space.{0} (preorder.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (preorder.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_78352 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (with_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (with_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_78353 (h0 : topological_space (has_emptyc (random_gen (has_norm fun_info)))) : locally_compact_space (has_emptyc (random_gen (has_norm fun_info))) := sorry --non-trivial
lemma new_lemma_78354 (h0 : group (sub_neg_monoid (has_Inf Type))) : group.fg (sub_neg_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_78355 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (has_inter.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_inter.{0} num))  := sorry --non-trivial
lemma new_lemma_78356 (h1 h2 : multiset (has_zero char)) : multiset.subset h1 h2 := sorry --non-trivial
lemma new_lemma_78357 (h0 : ring (has_one linarith.ineq)) : strong_rank_condition (has_one linarith.ineq) := sorry --non-trivial
lemma new_lemma_78358 (h0 : topological_space (ring (boolean_algebra pos))) : sequential_space (ring (boolean_algebra pos)) := sorry --non-trivial
lemma new_lemma_78359 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (has_zero.{0} ennreal) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (has_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_78360 (h0 : cancel_comm_monoid_with_zero (left_cancel_semigroup (div_inv_monoid (option empty)))) : unique_factorization_monoid (left_cancel_semigroup (div_inv_monoid (option empty))) := sorry --non-trivial
lemma new_lemma_78361 (h0 : monoid (complete_semilattice_Sup (comm_ring to_additive.value_type))) : monoid.fg (complete_semilattice_Sup (comm_ring to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_78362 (h0 : topological_space (comm_group (has_add ennreal))) : normal_space (comm_group (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_78363 (h0 : fin has_zero.zero) : @is_noetherian_ring.{0} (has_bot.{0} pos) (@function.extfun_app.{2 1} Type semiring.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type semiring.{0}) h0) (has_bot.{0} pos))  := sorry --non-trivial
lemma new_lemma_78364 (h0 : topological_space empty) : topological_space.separable_space empty := sorry --non-trivial
lemma new_lemma_78365 (h0 : semiring (has_pos_part (sub_neg_monoid Type))) : is_noetherian_ring (has_pos_part (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_78366 (h0 : topological_space (has_nndist (has_to_string (ring environment.implicit_infer_kind)))) : normal_space (has_nndist (has_to_string (ring environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_78367 (h0 : fin has_zero.zero) : @complete_lattice.is_Sup_finite_compact.{0} (finset.{0} linarith.comp) (@matrix.vec_empty.{0} (complete_lattice.{0} (finset.{0} linarith.comp)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_78368 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (ordered_cancel_add_comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type monoid.{0} h0 (ordered_cancel_add_comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_78369 (h0 : topological_space fun_info) (h1 : add_group fun_info) : topological_add_group fun_info := sorry --non-trivial
lemma new_lemma_78370 (h0 : topological_space ordering) (h1 : preorder ordering) : order_topology ordering := sorry --non-trivial
lemma new_lemma_78371 (h0 : function.extfun Type group) : @is_cyclic.{0} (canonically_ordered_comm_semiring.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (canonically_ordered_comm_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_78372 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (@id.{2} Type congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (@id.{2} Type congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_78373 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_78374 (h0 : topological_space (linear_ordered_semiring (semiring num))) : path_connected_space (linear_ordered_semiring (semiring num)) := sorry --non-trivial
lemma new_lemma_78375 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (has_edist empty)) := sorry --non-trivial
lemma new_lemma_78376 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (has_add.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_add.{0} name))  := sorry --non-trivial
lemma new_lemma_78377 (h0 : functor.add_const (finset (simple_graph Type)) name) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_78378 (h0 : add_group (has_compl (mul_one_class (mul_one_class (mul_one_class fun_info))))) : is_add_cyclic (has_compl (mul_one_class (mul_one_class (mul_one_class fun_info)))) := sorry --non-trivial
lemma new_lemma_78379 (h0 : function.extfun Type ring) : @is_domain.{0} (has_Inf.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_Inf.{0} name))  := sorry --non-trivial
lemma new_lemma_78380 (h0 : not (ring (semi_normed_comm_ring (has_nnnorm fun_info)) -> false)) : @rank_condition.{0} (semi_normed_comm_ring.{0} (has_nnnorm.{0} fun_info)) (@classical.by_contradiction'.{1} (ring.{0} (semi_normed_comm_ring.{0} (has_nnnorm.{0} fun_info))) h0)  := sorry --non-trivial
lemma new_lemma_78381 (h0 : topological_space (has_add (ring (ring Type)))) : topological_space.separable_space (has_add (ring (ring Type))) := sorry --non-trivial
lemma new_lemma_78382 (h0 : functor.add_const (topological_space (simple_graph empty)) congr_arg_kind) : @path_connected_space.{0} (simple_graph.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (simple_graph.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_78383 (h0 : group (has_add (has_Inf (has_Inf Type)))) : is_simple_group (has_add (has_Inf (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_78384 (h0 : topological_space (semi_normed_ring (comm_ring (comm_ring linarith.comp_source)))) : totally_disconnected_space (semi_normed_ring (comm_ring (comm_ring linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_78385 (h0 : topological_space (sub_neg_monoid linarith.comp)) : normal_space (sub_neg_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_78386 (h0 : topological_space (mul_zero_class (has_nndist name))) : preirreducible_space (mul_zero_class (has_nndist name)) := sorry --non-trivial
lemma new_lemma_78387 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_cyclic.{1} (has_neg.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 group.{1}) (has_neg.{1} Type))  := sorry --non-trivial
lemma new_lemma_78388 (h1 : ring (normed_field (has_ssubset (comm_ring (random_gen char))))) : strong_rank_condition (normed_field (has_ssubset (comm_ring (random_gen char)))) := sorry --non-trivial
lemma new_lemma_78389 (h0 : group (distrib_lattice (has_inv (random_gen linarith.ineq)))) : group.fg (distrib_lattice (has_inv (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_78390 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (comm_group.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_group.{0} name))  := sorry --non-trivial
lemma new_lemma_78391 (h0 : uniform_space (has_bot (has_add (comm_semigroup (has_bot real))))) : separated_space (has_bot (has_add (comm_semigroup (has_bot real)))) := sorry --non-trivial
lemma new_lemma_78392 (h0 : functor.add_const (cancel_comm_monoid_with_zero (add_group empty)) num) : @unique_factorization_monoid.{0} (add_group.{0} empty) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (add_group.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_78393 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_emptyc.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_emptyc.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_78394 (h0 : complete_lattice (measurable_space (random_gen linarith.ineq))) : is_compactly_generated (measurable_space (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_78395 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_bot.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_bot.{0} real))  := sorry --non-trivial
lemma new_lemma_78396 (h0 : complete_lattice (bin_tree num)) : complete_lattice.is_Sup_finite_compact (bin_tree num) := sorry --non-trivial
lemma new_lemma_78397 (h0 : function.extfun Type (functor.add_const (topological_space (linear_ordered_cancel_comm_monoid num)))) : @totally_separated_space.{0} (linear_ordered_cancel_comm_monoid.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_cancel_comm_monoid.{0} num)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (linear_ordered_cancel_comm_monoid.{0} num))) h0 empty))  := sorry --non-trivial
lemma new_lemma_78398 (h0 : ring (finset (has_to_string pos))) : strong_rank_condition (finset (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_78399 (h0 : group (sub_neg_monoid (has_Inf linarith.comp))) : normalizer_condition (sub_neg_monoid (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_78400 (h0 : prod (is_R_or_C empty) (is_R_or_C empty)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_78401 (h0 : functor.add_const (topological_space (has_zero environment.implicit_infer_kind)) (finset Type)) : @regular_space.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (has_zero.{0} environment.implicit_infer_kind)) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_78402 (h0 : fin has_zero.zero) : @discrete_topology.{0} (sub_neg_monoid.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (sub_neg_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_78403 (h1 : topological_space (denumerable (random_gen char))) : totally_disconnected_space (denumerable (random_gen char)) := sorry --non-trivial
lemma new_lemma_78404 (h0 : functor.comp group finset Type) : @normalizer_condition.{1} (finset.{1} Type) (@functor.comp.run.{1 1 1} group.{1} finset.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_78405 (h0 : functor.add_const (topological_space (normed_comm_ring empty)) empty) : @irreducible_space.{0} (normed_comm_ring.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_78406 (h0 : topological_space (has_Inf (ring name))) : preirreducible_space (has_Inf (ring name)) := sorry --non-trivial
lemma new_lemma_78407 (h0 : functor.add_const (ring (normed_comm_ring unsigned)) empty) : @is_principal_ideal_ring.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (normed_comm_ring.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_78408 (h0 : function.extfun (finset Type) (has_mem.mem (with_one unsigned))) : @complete_lattice.is_Sup_finite_compact.{0} (with_one.{0} unsigned) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (with_one.{0} unsigned) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_one.{0} unsigned)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_78409 (h0 : ordered_comm_monoid (canonically_ordered_comm_semiring (has_to_string Type))) : has_exists_mul_of_le (canonically_ordered_comm_semiring (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_78410 (h0 : complete_lattice (has_lt linarith.ineq)) : is_compactly_generated (has_lt linarith.ineq) := sorry --non-trivial
lemma new_lemma_78411 (h0 : functor.add_const (function.extfun Type finset) name) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_78412 (h0 : topological_space (canonically_ordered_monoid (has_Inf (has_Inf pos)))) : locally_compact_space (canonically_ordered_monoid (has_Inf (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_78413 (h0 : group (random_gen (semiring (semiring empty)))) : group.fg (random_gen (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_78414 (h0 : functor.add_const (topological_space (normed_comm_ring unsigned)) environment.implicit_infer_kind) : @discrete_topology.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_78415 (h0 : ring (sub_neg_monoid (finset linarith.comp))) : is_principal_ideal_ring (sub_neg_monoid (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_78416 (h0 : functor.add_const (add_group (has_neg_part unsigned)) linarith.comp) : @is_add_cyclic.{0} (has_neg_part.{0} unsigned) (@functor.add_const.run.{0 0} (add_group.{0} (has_neg_part.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_78417 (h0 : cancel_comm_monoid_with_zero (complete_semilattice_Sup (semiring (has_top (semiring num))))) : unique_factorization_monoid (complete_semilattice_Sup (semiring (has_top (semiring num)))) := sorry --non-trivial
lemma new_lemma_78418 (h0 : ring (metric_space num)) : is_domain (metric_space num) := sorry --non-trivial
lemma new_lemma_78419 (h0 : complete_lattice (has_inv linarith.comp_source)) : complete_lattice.is_Sup_finite_compact (has_inv linarith.comp_source) := sorry --non-trivial
lemma new_lemma_78420 (h2 : has_lt reducibility_hints) : no_max_order reducibility_hints := sorry --non-trivial
lemma new_lemma_78421 (h0 : monoid (has_to_string pos)) : monoid.fg (has_to_string pos) := sorry --non-trivial
lemma new_lemma_78422 (h0 : topological_space (generalized_boolean_algebra (has_add pos))) : locally_compact_space (generalized_boolean_algebra (has_add pos)) := sorry --non-trivial
lemma new_lemma_78423 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (bin_tree.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (bin_tree.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_78424 (h0 : functor.add_const (complete_lattice linarith.comp) Type) : @complete_lattice.is_Sup_finite_compact.{0} linarith.comp (@functor.add_const.run.{0 1} (complete_lattice.{0} linarith.comp) Type h0)  := sorry --non-trivial
lemma new_lemma_78425 (h0 : topological_space (semiring (has_norm congr_arg_kind))) : totally_disconnected_space (semiring (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_78426 (h0 : functor.add_const (function.extfun Type cancel_comm_monoid_with_zero) (ring pos)) : @unique_factorization_monoid.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type cancel_comm_monoid_with_zero.{0}) (ring.{0} pos) h0) (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_78427 (h0 : topological_space (has_lt linarith.ineq)) (h1 : add_group (has_lt linarith.ineq)) : topological_add_group (has_lt linarith.ineq) := sorry --non-trivial
lemma new_lemma_78428 (h0 : functor.add_const (list (canonically_ordered_comm_semiring ennreal)) name) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_78429 (h0 : finset (has_zero (option ennreal))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_78430 (h0 : topological_space (comm_semigroup (generalized_boolean_algebra linarith.comp))) : t0_space (comm_semigroup (generalized_boolean_algebra linarith.comp)) := sorry --non-trivial
lemma new_lemma_78431 (h0 : group (comm_group (ring Type))) : normalizer_condition (comm_group (ring Type)) := sorry --non-trivial
lemma new_lemma_78432 (h0 : not (ring (normed_group string.iterator_imp) -> false)) : @strong_rank_condition.{0} (normed_group.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (ring.{0} (normed_group.{0} string.iterator_imp)) h0)  := sorry --non-trivial
lemma new_lemma_78433 (h0 : functor.add_const (uniform_space (boolean_algebra pos)) linarith.comp) : @separated_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (boolean_algebra.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_78434 (h0 : topological_space (has_one string_imp)) (h1 : preorder (has_one string_imp)) : order_topology (has_one string_imp) := sorry --non-trivial
lemma new_lemma_78435 (h0 : cancel_comm_monoid_with_zero (mul_zero_class (finset environment.implicit_infer_kind))) : unique_factorization_monoid (mul_zero_class (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_78436 (h0 : functor.add_const (function.extfun Type uniform_space) Type) : @separated_space.{0} (has_add.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type uniform_space.{0}) Type h0) (has_add.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_78437 (h0 : group (has_to_string (comm_group Type))) : is_simple_group (has_to_string (comm_group Type)) := sorry --non-trivial
lemma new_lemma_78438 (h0 : cancel_comm_monoid_with_zero (has_neg_part (option (option (cancel_monoid unsigned))))) : unique_factorization_monoid (has_neg_part (option (option (cancel_monoid unsigned)))) := sorry --non-trivial
lemma new_lemma_78439 (h2 : set (add_comm_semigroup linarith.ineq -> metric_space linarith.ineq)) : set.separates_points h2 := sorry --non-trivial
lemma new_lemma_78440 (h1 : topological_space (distrib fun_info)) : totally_disconnected_space (distrib fun_info) := sorry --non-trivial
lemma new_lemma_78441 (h0 : ring (normed_group (has_inv string_imp))) : rank_condition (normed_group (has_inv string_imp)) := sorry --non-trivial
lemma new_lemma_78442 (h0 : multiset (has_top fun_info)) : multiset.nodup h0 := sorry --non-trivial
lemma new_lemma_78443 (h0 : functor.add_const (ring (has_neg Type)) linarith.comp) : @is_domain.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_neg.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_78444 (h0 : ordered_add_comm_monoid (linear_ordered_comm_group (option (option (option (option (option empty))))))) : archimedean (linear_ordered_comm_group (option (option (option (option (option empty)))))) := sorry --non-trivial
lemma new_lemma_78445 (h0 : fin has_zero.zero) : @complete_lattice.is_Sup_finite_compact.{0} (normed_lattice_add_comm_group.{0} name) (@matrix.vec_empty.{0} (complete_lattice.{0} (normed_lattice_add_comm_group.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_78446 (h0 : add_group (has_append (random_gen string_imp))) : is_add_cyclic (has_append (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_78447 (h0 : function.extfun nat fin) : @monoid.fg.{1} (simple_graph.{1} Type) (@matrix.vec_empty.{1} (monoid.{1} (simple_graph.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_78448 (h0 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} (measurable_space.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (measurable_space.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_78449 (h0 : not (complete_lattice (has_append linarith.comp_source) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_append.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_append.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_78450 (h0 : ring (non_assoc_semiring (option empty))) : rank_condition (non_assoc_semiring (option empty)) := sorry --non-trivial
lemma new_lemma_78451 (h0 : topological_space (ordered_comm_monoid name)) : topological_space.separable_space (ordered_comm_monoid name) := sorry --non-trivial
lemma new_lemma_78452 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (linear_ordered_comm_group.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_group.{0} num))  := sorry --non-trivial
lemma new_lemma_78453 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (ordered_cancel_add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (ordered_cancel_add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_78454 (h0 : ring (has_inv (has_inv (random_gen linarith.comp_source)))) : is_domain (has_inv (has_inv (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_78455 (h1 : add_group (nondiscrete_normed_field (add_comm_semigroup fun_info))) : is_add_cyclic (nondiscrete_normed_field (add_comm_semigroup fun_info)) := sorry --non-trivial
lemma new_lemma_78456 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (distrib_lattice.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (distrib_lattice.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_78457 (h0 : ring (has_one (has_norm num))) : rank_condition (has_one (has_norm num)) := sorry --non-trivial
lemma new_lemma_78458 (h0 : group (ring (boolean_algebra (boolean_algebra name)))) : is_simple_group (ring (boolean_algebra (boolean_algebra name))) := sorry --non-trivial
lemma new_lemma_78459 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_zero.{0} pos) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_78460 (h0 : list (canonically_ordered_comm_semiring fun_info)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_78461 (h0 : functor.add_const (complete_lattice znum) unsigned) : @is_compactly_generated.{0} znum (@functor.add_const.run.{0 0} (complete_lattice.{0} znum) unsigned h0)  := sorry --non-trivial
lemma new_lemma_78462 (h0 : topological_space (option (semiring congr_arg_kind))) : discrete_topology (option (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_78463 (h0 : topological_space (random_gen to_additive.value_type)) : totally_disconnected_space (random_gen to_additive.value_type) := sorry --non-trivial
lemma new_lemma_78464 (h0 : topological_space (has_bot (has_Inf (has_Inf (has_Inf (has_Inf (has_Inf (has_Inf pos)))))))) : preirreducible_space (has_bot (has_Inf (has_Inf (has_Inf (has_Inf (has_Inf (has_Inf pos))))))) := sorry --non-trivial
lemma new_lemma_78465 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (has_inv.{0} linarith.ineq) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (has_inv.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_78466 (h0 : function.extfun (Type 1) monoid) : @monoid.fg.{1} (has_neg.{1} Type) (@function.extfun_app.{3 2} (Type 1) monoid.{1} h0 (has_neg.{1} Type))  := sorry --non-trivial
lemma new_lemma_78467 (h0 : group (add_comm_monoid (has_add (has_add (has_add Type))))) : is_simple_group (add_comm_monoid (has_add (has_add (has_add Type)))) := sorry --non-trivial
lemma new_lemma_78468 (h0 : has_neg (has_ssubset (add_comm_semigroup string.iterator_imp))) (h1 : measurable_space (has_ssubset (add_comm_semigroup string.iterator_imp))) : has_measurable_neg (has_ssubset (add_comm_semigroup string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_78469 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_zero.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_78470 (h0 : not (topological_space (add_monoid fun_info) -> false)) : @t0_space.{0} (add_monoid.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (add_monoid.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_78471 (h0 : topological_space (measurable_space unsigned)) : preirreducible_space (measurable_space unsigned) := sorry --non-trivial
lemma new_lemma_78472 (h0 : ring (has_top (random_gen (comm_ring (comm_ring to_additive.value_type))))) : rank_condition (has_top (random_gen (comm_ring (comm_ring to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_78473 (h0 : ring (has_Inf (has_pos_part Type))) : rank_condition (has_Inf (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_78474 (h0 : finset num -> finset num -> Prop) : is_symm (finset num) h0 := sorry --non-trivial
lemma new_lemma_78475 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (has_top.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_top.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_78476 (h0 : group (finset (has_nndist environment.implicit_infer_kind))) : is_simple_group (finset (has_nndist environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_78477 (h0 : uniform_space (random_gen (has_nnnorm (has_nnnorm (random_gen char))))) : complete_space (random_gen (has_nnnorm (has_nnnorm (random_gen char)))) := sorry --non-trivial
lemma new_lemma_78478 (h0 : function.extfun (finset Type) (has_mem.mem linarith.comp_source)) : @rank_condition.{0} linarith.comp_source (@finset.pi.empty.{1 0} Type ring.{0} linarith.comp_source (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) linarith.comp_source) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_78479 (h0 : topological_space (ring (ring (ring (ordered_ring (ring (has_add Type))))))) : preirreducible_space (ring (ring (ring (ordered_ring (ring (has_add Type)))))) := sorry --non-trivial
lemma new_lemma_78480 (h0 : group (with_one (measurable_space (has_norm congr_arg_kind)))) : is_cyclic (with_one (measurable_space (has_norm congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_78481 (h0 : topological_space (cancel_monoid name)) : preirreducible_space (cancel_monoid name) := sorry --non-trivial
lemma new_lemma_78482 (h0 : functor.add_const (topological_space (boolean_algebra pos)) (finset linarith.comp)) : @t0_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} pos)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_78483 (h0 : filter (has_inv (random_gen linarith.ineq))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_78484 (h0 : topological_space (add_left_cancel_semigroup (option empty))) : path_connected_space (add_left_cancel_semigroup (option empty)) := sorry --non-trivial
lemma new_lemma_78485 (h0 : topological_space (omega_complete_partial_order unsigned)) : locally_compact_space (omega_complete_partial_order unsigned) := sorry --non-trivial
lemma new_lemma_78486 (h0 : functor.add_const (topological_space (normed_comm_ring pos)) Type) : @regular_space.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (normed_comm_ring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_78487 (h0 : prod (finset (option ennreal)) (finset (option ennreal))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_78488 (h0 : semiring (normed_comm_ring congr_arg_kind)) : is_noetherian_ring (normed_comm_ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_78489 (h0 : add_monoid (semigroup Type)) : add_monoid.fg (semigroup Type) := sorry --non-trivial
lemma new_lemma_78490 (h0 : add_monoid (has_to_string (finset name))) : add_monoid.fg (has_to_string (finset name)) := sorry --non-trivial
lemma new_lemma_78491 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (has_nndist.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_nndist.{0} empty))  := sorry --non-trivial
lemma new_lemma_78492 (h0 : not (ring (id linarith.comp) -> false)) : @is_domain.{0} (@id.{2} Type linarith.comp) (@classical.by_contradiction'.{1} (ring.{0} (@id.{2} Type linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_78493 (h1 : complete_lattice (denumerable (random_gen (random_gen (random_gen char))))) : is_compactly_generated (denumerable (random_gen (random_gen (random_gen char)))) := sorry --non-trivial
lemma new_lemma_78494 (h0 : ring (topological_space (has_nnnorm (has_nnnorm linarith.ineq)))) : is_domain (topological_space (has_nnnorm (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_78495 (h0 : finset (ordered_comm_monoid Type)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_78496 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (with_one.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_one.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_78497 (h0 : measurable_space (add_comm_semigroup linarith.ineq)) (h1 : filter (add_comm_semigroup linarith.ineq)) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_78498 (h0 : uniform_space (has_one (semiring (semiring unsigned)))) : complete_space (has_one (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_78499 (h0 : not (monoid (linear_ordered_comm_ring unsigned) -> false)) : @monoid.fg.{0} (linear_ordered_comm_ring.{0} unsigned) (@classical.by_contradiction'.{1} (monoid.{0} (linear_ordered_comm_ring.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_78500 (h0 : ring (ordered_comm_monoid (boolean_algebra.core Type))) : is_domain (ordered_comm_monoid (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_78501 (h0 : topological_space (has_Inf (ring (ring Type)))) : irreducible_space (has_Inf (ring (ring Type))) := sorry --non-trivial
lemma new_lemma_78502 (h0 : not (function.extfun Type topological_space -> false)) : @totally_disconnected_space.{0} (semiring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (semiring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_78503 (h0 : functor.add_const (topological_space (add_comm_monoid unsigned)) name) : @totally_separated_space.{0} (add_comm_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_78504 (h0 : add_group (has_union (has_norm (semiring linarith.comp)))) : is_add_cyclic (has_union (has_norm (semiring linarith.comp))) := sorry --non-trivial
lemma new_lemma_78505 (h0 : topological_space (complete_distrib_lattice (option unsigned))) : preirreducible_space (complete_distrib_lattice (option unsigned)) := sorry --non-trivial
lemma new_lemma_78506 (h0 : functor.comp complete_lattice semigroup (has_add environment.implicit_infer_kind)) : @complete_lattice.is_Sup_finite_compact.{0} (semigroup.{0} (has_add.{0} environment.implicit_infer_kind)) (@functor.comp.run.{0 0 0} complete_lattice.{0} semigroup.{0} (has_add.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_78507 (h1 : topological_space (random_gen num)) : discrete_topology (random_gen num) := sorry --non-trivial
lemma new_lemma_78508 (h0 : topological_space (option pos)) : preirreducible_space (option pos) := sorry --non-trivial
lemma new_lemma_78509 (h2 : complete_lattice (div_inv_monoid fun_info)) : complete_lattice.is_Sup_finite_compact (div_inv_monoid fun_info) := sorry --non-trivial
lemma new_lemma_78510 (h0 : topological_space (canonically_linear_ordered_monoid (has_Inf (has_add real)))) : totally_separated_space (canonically_linear_ordered_monoid (has_Inf (has_add real))) := sorry --non-trivial
lemma new_lemma_78511 (h0 : finset (add_comm_monoid environment.implicit_infer_kind)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_78512 (h0 : functor.add_const (finset (option num)) (semiring empty)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_78513 (h0 : functor.add_const (group (normed_comm_ring unsigned)) name) : @normalizer_condition.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (normed_comm_ring.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_78514 (h0 : uniform_space (has_add (finset (has_nndist linarith.comp)))) : complete_space (has_add (finset (has_nndist linarith.comp))) := sorry --non-trivial
lemma new_lemma_78515 (h0 : complete_lattice (canonically_linear_ordered_monoid (has_add (has_add (has_add real))))) : is_atomistic (canonically_linear_ordered_monoid (has_add (has_add (has_add real)))) := sorry --non-trivial
lemma new_lemma_78516 (h0 : cancel_comm_monoid_with_zero (canonically_linear_ordered_monoid (has_Inf pos))) : unique_factorization_monoid (canonically_linear_ordered_monoid (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_78517 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @totally_separated_space.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_78518 (h0 : uniform_space (mul_zero_class (has_neg_part Type))) : separated_space (mul_zero_class (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_78519 (h0 : uniform_space (random_gen (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm char))))))) : complete_space (random_gen (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm char)))))) := sorry --non-trivial
lemma new_lemma_78520 (h0 : has_neg (linear_ordered_comm_group_with_zero reducibility_hints)) (h1 : measurable_space (linear_ordered_comm_group_with_zero reducibility_hints)) : has_measurable_neg (linear_ordered_comm_group_with_zero reducibility_hints) := sorry --non-trivial
lemma new_lemma_78521 (h0 : topological_space (measure_theory.measure_space (finset (finset (has_bot linarith.comp))))) : t1_space (measure_theory.measure_space (finset (finset (has_bot linarith.comp)))) := sorry --non-trivial
lemma new_lemma_78522 (h0 : ring (denumerable (has_nnnorm linarith.comp_source))) : is_domain (denumerable (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_78523 (h0 : functor.add_const (topological_space (cancel_monoid empty)) ennreal) : @loc_path_connected_space.{0} (cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} empty)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_78524 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (as_linear_order.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (as_linear_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_78525 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (filter congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_78526 (h0 : function.extfun Type group) : @is_cyclic.{0} (complete_distrib_lattice.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (complete_distrib_lattice.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_78527 (h0 : ring (mul_zero_class (boolean_algebra.core (add_comm_monoid Type)))) : rank_condition (mul_zero_class (boolean_algebra.core (add_comm_monoid Type))) := sorry --non-trivial
lemma new_lemma_78528 (h0 : not (topological_space (has_one empty) -> false)) : @normal_space.{0} (has_one.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (has_one.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_78529 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (normed_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (normed_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_78530 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (has_add.{0} (option.{0} unsigned)) (@functor.comp.run.{0 0 0} ring.{0} has_add.{0} (option.{0} unsigned) (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} ring.{0} has_add.{0}) (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 (functor.comp.{0 0 0} ring.{0} has_add.{0})) (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_78531 (h0 : topological_space (has_norm linarith.comp)) : totally_separated_space (has_norm linarith.comp) := sorry --non-trivial
lemma new_lemma_78532 (h0 : topological_space (left_cancel_monoid congr_arg_kind)) : preirreducible_space (left_cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_78533 (h0 : monoid (ordered_comm_monoid (has_neg Type))) : monoid.fg (ordered_comm_monoid (has_neg Type)) := sorry --non-trivial
lemma new_lemma_78534 (h0 : uniform_space (omega_complete_partial_order empty)) : complete_space (omega_complete_partial_order empty) := sorry --non-trivial
lemma new_lemma_78535 (h0 : fin has_zero.zero) : @rank_condition.{1} (has_add.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (has_add.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_78536 (h1 : uniform_space (topological_space (random_gen char))) : complete_space (topological_space (random_gen char)) := sorry --non-trivial
lemma new_lemma_78537 (h0 : functor.add_const (topological_space (has_zero linarith.comp)) pos) : @preconnected_space.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_78538 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_ssubset.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_ssubset.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_78539 (h0 : function.extfun fun_info (fun (x : fun_info), Prop)) : Exists (function.extfun_app h0) := sorry --non-trivial
lemma new_lemma_78540 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} linarith.comp_source (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_78541 (h0 : complete_lattice (normed_group (semiring (has_norm unsigned)))) : is_atomistic (normed_group (semiring (has_norm unsigned))) := sorry --non-trivial
lemma new_lemma_78542 (h2 h3 : multiset (nondiscrete_normed_field char)) : multiset.subset h2 h3 := sorry --non-trivial
lemma new_lemma_78543 (h0 : topological_space (has_to_string (has_neg_part (has_add (has_add (cancel_monoid pos)))))) : path_connected_space (has_to_string (has_neg_part (has_add (has_add (cancel_monoid pos))))) := sorry --non-trivial
lemma new_lemma_78544 (h0 : topological_space (complete_distrib_lattice (has_add (has_add unsigned)))) : loc_path_connected_space (complete_distrib_lattice (has_add (has_add unsigned))) := sorry --non-trivial
lemma new_lemma_78545 (h0 : add_group (option pos)) : is_add_cyclic (option pos) := sorry --non-trivial
lemma new_lemma_78546 (h0 : functor.add_const (topological_space (boolean_algebra.core unsigned)) Type) : @preconnected_space.{0} (boolean_algebra.core.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.core.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_78547 (h1 : function.extfun Type group) : @group.fg.{0} (has_top.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h1 (has_top.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_78548 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (has_pos_part.{0} (has_add.{0} linarith.comp)) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_pos_part.{0} (has_add.{0} linarith.comp)))  := sorry --non-trivial
lemma new_lemma_78549 (h0 : not (complete_lattice to_additive.value_type -> false)) : @is_atomistic.{0} to_additive.value_type (@classical.by_contradiction'.{1} (complete_lattice.{0} to_additive.value_type) h0)  := sorry --non-trivial
lemma new_lemma_78550 (h0 : filter (comm_group (option name))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_78551 (h0 : topological_space (has_nnnorm (random_gen (comm_ring (random_gen char))))) : t0_space (has_nnnorm (random_gen (comm_ring (random_gen char)))) := sorry --non-trivial
lemma new_lemma_78552 (h0 : topological_space (add_comm_monoid (has_pos_part linarith.comp))) : topological_space.separable_space (add_comm_monoid (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_78553 (h0 : not (topological_space (has_ssubset linarith.comp_source) -> false)) : @locally_compact_space.{0} (has_ssubset.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (has_ssubset.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_78554 (h0 : functor.add_const (complete_lattice (has_to_string Type)) environment.implicit_infer_kind) : @is_compactly_generated.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (has_to_string.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_78555 (h0 : complete_lattice (semi_normed_ring (has_ssubset (has_ssubset (has_ssubset linarith.ineq))))) : is_compactly_generated (semi_normed_ring (has_ssubset (has_ssubset (has_ssubset linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_78556 (h0 : topological_space (has_bot (has_add (has_add (has_pos_part (has_Inf name)))))) : totally_separated_space (has_bot (has_add (has_add (has_pos_part (has_Inf name))))) := sorry --non-trivial
lemma new_lemma_78557 (h0 : topological_space (add_comm_monoid (has_add pos))) : t0_space (add_comm_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_78558 (h0 : functor.add_const (topological_space (complete_linear_order num)) (semiring unsigned)) : @normal_space.{0} (complete_linear_order.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_linear_order.{0} num)) (semiring.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_78559 (h0 : topological_space (measurable_space (random_gen string_imp))) : totally_separated_space (measurable_space (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_78560 (h0 : functor.add_const (ordered_add_comm_monoid (has_to_string Type)) (has_pos_part pos)) : @archimedean.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (ordered_add_comm_monoid.{1} (has_to_string.{1} Type)) (has_pos_part.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_78561 (h0 : filter (semiring (semiring num))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_78562 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (canonically_linear_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_linear_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_78563 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_norm.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} h0 (has_norm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_78564 (h0 : functor.add_const (topological_space (add_comm_monoid Type)) unsigned) : @loc_path_connected_space.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_comm_monoid.{1} Type)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_78565 (h0 : not (function.extfun Type group -> false)) : @group.fg.{0} (has_emptyc.{0} (has_norm.{0} (has_norm.{0} (has_norm.{0} (semiring.{0} (has_norm.{0} linarith.comp)))))) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (has_emptyc.{0} (has_norm.{0} (has_norm.{0} (has_norm.{0} (semiring.{0} (has_norm.{0} linarith.comp)))))))  := sorry --non-trivial
lemma new_lemma_78566 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_neg_part.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_neg_part.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_78567 (h0 : functor.add_const (topological_space (add_semigroup unsigned)) empty) : @locally_compact_space.{0} (add_semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_semigroup.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_78568 (h2 : list (measurable_space to_additive.value_type)) : list.nodup h2 := sorry --non-trivial
lemma new_lemma_78569 (h0 : functor.add_const (topological_space (has_nndist Type)) pos) : @discrete_topology.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_nndist.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_78570 (h0 : topological_space (has_nnnorm (mul_one_class reducibility_hints))) (h1 : set (has_nnnorm (mul_one_class reducibility_hints))) : is_path_connected h1 := sorry --non-trivial
lemma new_lemma_78571 (h0 : not (complete_lattice (uniform_space enat) -> false)) : complete_lattice.is_Sup_finite_compact (uniform_space enat) := sorry --non-trivial
lemma new_lemma_78572 (h0 : topological_space (boolean_algebra.core (finset (has_to_string (finset linarith.comp))))) : irreducible_space (boolean_algebra.core (finset (has_to_string (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_78573 (h0 : topological_space (has_inner (has_union empty) (has_union congr_arg_kind))) : normal_space (has_inner (has_union empty) (has_union congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_78574 (h0 : filter (linear_ordered_add_comm_group (has_norm (random_gen fun_info)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_78575 (h0 : topological_space (complete_lattice empty)) : locally_compact_space (complete_lattice empty) := sorry --non-trivial
lemma new_lemma_78576 (h0 : topological_space Type) (h1 : set Type) : frontier h1 (normed_lattice_add_comm_group char) := sorry --non-trivial
lemma new_lemma_78577 (h0 : complete_lattice (add_cancel_comm_monoid (normed_field char))) : is_compactly_generated (add_cancel_comm_monoid (normed_field char)) := sorry --non-trivial
lemma new_lemma_78578 (h0 : complete_lattice (random_gen (semiring linarith.comp))) : complete_lattice.is_Sup_finite_compact (random_gen (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_78579 (h0 : ring (id num)) : rank_condition (id num) := sorry --non-trivial
lemma new_lemma_78580 (h0 : complete_lattice (complete_linear_order (semiring (semiring unsigned)))) : is_atomistic (complete_linear_order (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_78581 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @totally_separated_space.{0} (with_bot.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (with_bot.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_78582 (h0 : topological_space (canonically_ordered_monoid (has_neg name))) : t1_space (canonically_ordered_monoid (has_neg name)) := sorry --non-trivial
lemma new_lemma_78583 (h0 : functor.add_const (topological_space (semigroup linarith.comp)) linarith.comp) : @t0_space.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_78584 (h0 : topological_space (add_cancel_monoid Type)) : sequential_space (add_cancel_monoid Type) := sorry --non-trivial
lemma new_lemma_78585 (h0 : add_monoid (semigroup (boolean_algebra.core name))) : add_monoid.fg (semigroup (boolean_algebra.core name)) := sorry --non-trivial
lemma new_lemma_78586 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (semigroup.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} h0 (semigroup.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_78587 (h0 : functor.add_const (topological_space (ordered_comm_ring Type)) name) : @totally_separated_space.{1} (ordered_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ordered_comm_ring.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_78588 (h0 : topological_space (complete_distrib_lattice ennreal)) : irreducible_space (complete_distrib_lattice ennreal) := sorry --non-trivial
lemma new_lemma_78589 (h3 : set (nondiscrete_normed_field linarith.ineq)) : set.finite h3 := sorry --non-trivial
lemma new_lemma_78590 (h0 : topological_space (encodable (random_gen (random_gen char)))) : locally_compact_space (encodable (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_78591 (h0 h2 : nat) (h3 : thunk Prop) : scope_trace h3 := sorry --non-trivial
lemma new_lemma_78592 (h0 : functor.add_const (topological_space environment.implicit_infer_kind) Type) : @path_connected_space.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 1} (topological_space.{0} environment.implicit_infer_kind) Type h0)  := sorry --non-trivial
lemma new_lemma_78593 (h1 : ring (non_unital_non_assoc_semiring (random_gen (random_gen (has_union char))))) : strong_rank_condition (non_unital_non_assoc_semiring (random_gen (random_gen (has_union char)))) := sorry --non-trivial
lemma new_lemma_78594 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (simple_graph.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (simple_graph.{0} pos))  := sorry --non-trivial
lemma new_lemma_78595 (h0 : functor.comp topological_space add_comm_monoid name) : @regular_space.{0} (add_comm_monoid.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} add_comm_monoid.{0} name h0)  := sorry --non-trivial
lemma new_lemma_78596 (h0 : topological_space (add_cancel_monoid (has_add (boolean_algebra Type)))) : path_connected_space (add_cancel_monoid (has_add (boolean_algebra Type))) := sorry --non-trivial
lemma new_lemma_78597 (h0 : group (boolean_algebra (finset environment.implicit_infer_kind))) : is_cyclic (boolean_algebra (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_78598 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (complete_distrib_lattice.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (complete_distrib_lattice.{0} empty))  := sorry --non-trivial
lemma new_lemma_78599 (h0 : topological_space (complete_linear_order congr_arg_kind)) : normal_space (complete_linear_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_78600 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} auto.case_option (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) auto.case_option)  := sorry --non-trivial
lemma new_lemma_78601 (h0 : complete_lattice (normed_group (semiring fun_info))) : is_atomistic (normed_group (semiring fun_info)) := sorry --non-trivial
lemma new_lemma_78602 (h0 : functor.add_const (cancel_comm_monoid_with_zero (complete_distrib_lattice Type)) (ring pos)) : @unique_factorization_monoid.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 0} (cancel_comm_monoid_with_zero.{1} (complete_distrib_lattice.{1} Type)) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_78603 (h0 : functor.add_const (topological_space (add_group num)) num) : @topological_space.separable_space.{0} (add_group.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (add_group.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_78604 (h0 : uniform_space (bin_tree (semiring empty))) : complete_space (bin_tree (semiring empty)) := sorry --non-trivial
lemma new_lemma_78605 (h0 : filter (boolean_algebra (has_Inf (has_Inf (has_Inf pos))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_78606 (h0 : not (topological_space (has_norm congr_arg_kind) -> false)) : @normal_space.{0} (has_norm.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (has_norm.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_78607 (h0 : not (topological_space (add_right_cancel_monoid congr_arg_kind) -> false)) : @path_connected_space.{0} (add_right_cancel_monoid.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (add_right_cancel_monoid.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_78608 (h0 : functor.add_const (filter (ring linarith.comp)) (normed_comm_ring (normed_comm_ring pos))) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_78609 (h0 : not (topological_space (non_assoc_semiring empty) -> false)) : @preirreducible_space.{0} (non_assoc_semiring.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (non_assoc_semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_78610 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (has_neg_part.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_neg_part.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_78611 (h0 : functor.add_const (topological_space (simple_graph name)) (has_pos_part linarith.comp)) : @totally_disconnected_space.{0} (simple_graph.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (simple_graph.{0} name)) (has_pos_part.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_78612 (h0 : option (topological_space (has_neg_part (cancel_monoid unsigned)))) (h1 : topological_space (has_neg_part (cancel_monoid unsigned))) : totally_separated_space (has_neg_part (cancel_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_78613 (h0 : group (has_one (semiring (semiring (semiring empty))))) : group.fg (has_one (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_78614 (h0 : topological_space (has_add (has_add name))) : preconnected_space (has_add (has_add name)) := sorry --non-trivial
lemma new_lemma_78615 (h0 : group (semi_normed_ring (mul_one_class fun_info))) : is_cyclic (semi_normed_ring (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_78616 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (complete_linear_order.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (complete_linear_order.{0} num))  := sorry --non-trivial
lemma new_lemma_78617 (h0 : topological_space (has_pos_part (has_add (has_neg linarith.comp)))) : totally_disconnected_space (has_pos_part (has_add (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_78618 (h0 : function.extfun Type (functor.comp topological_space add_cancel_monoid)) : @path_connected_space.{0} (add_cancel_monoid.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} add_cancel_monoid.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} add_cancel_monoid.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_78619 (h1 h2 : multiset (mul_one_class (add_comm_semigroup char))) : multiset.disjoint h1 h2 := sorry --non-trivial
lemma new_lemma_78620 (h0 : topological_space (has_div fun_info)) : totally_disconnected_space (has_div fun_info) := sorry --non-trivial
lemma new_lemma_78621 (h2 : set (semi_normed_comm_ring linarith.comp_source)) : set.finite h2 := sorry --non-trivial
lemma new_lemma_78622 (h0 : function.extfun Type topological_space) : @t0_space.{0} (ordered_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_78623 (h0 : topological_space (add_comm_monoid real)) : normal_space (add_comm_monoid real) := sorry --non-trivial
lemma new_lemma_78624 (h0 : function.extfun Type (functor.comp topological_space comm_group)) : @sequential_space.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} comm_group.{0} environment.implicit_infer_kind (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} comm_group.{0}) h0 environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_78625 (h0 : topological_space (complete_distrib_lattice ennreal)) : normal_space (complete_distrib_lattice ennreal) := sorry --non-trivial
lemma new_lemma_78626 (h0 : functor.comp topological_space finset name) : @discrete_topology.{0} (finset.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} finset.{0} name h0)  := sorry --non-trivial
lemma new_lemma_78627 (h0 : functor.add_const (ring (has_zero pos)) (ring Type)) : @is_principal_ideal_ring.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (has_zero.{0} pos)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_78628 (h0 : functor.add_const (topological_space (has_nndist unsigned)) num) : @totally_separated_space.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_78629 (h0 : topological_space (comm_semigroup (sub_neg_monoid pos))) : preirreducible_space (comm_semigroup (sub_neg_monoid pos)) := sorry --non-trivial
lemma new_lemma_78630 (h0 : prod (simple_graph empty) (simple_graph empty)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_78631 (h0 : ulower (fin has_zero.zero)) : matrix.vec_empty (matrix.vec_empty (id (matrix.vec_empty (ulower.up h0)))) := sorry --non-trivial
lemma new_lemma_78632 (h0 : functor.add_const (function.extfun (Type 1) topological_space) Type) : @t0_space.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) Type h0) (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_78633 (h0 : fin has_zero.zero) : @normal_space.{1} (canonically_linear_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (canonically_linear_ordered_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_78634 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem ring)) : @is_domain.{0} (random_gen.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) ring.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (random_gen.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_78635 (h0 : functor.add_const (topological_space (semiring unsigned)) unsigned) : @discrete_topology.{0} (semiring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (semiring.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_78636 (h0 : group (random_gen (has_nnnorm (has_nnnorm (random_gen linarith.comp_source))))) : is_cyclic (random_gen (has_nnnorm (has_nnnorm (random_gen linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_78637 (h0 : not (group (has_top to_additive.value_type) -> false)) : @is_cyclic.{0} (has_top.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (group.{0} (has_top.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_78638 (h0 : finset (plift (semiring (semiring num)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_78639 (h0 : topological_space (simple_graph (has_pos_part linarith.comp))) : preconnected_space (simple_graph (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_78640 (h0 : topological_space (distrib_lattice (has_nnnorm linarith.comp_source))) : locally_compact_space (distrib_lattice (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_78641 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_Sup.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_Sup.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_78642 (h0 : ordered_comm_monoid (boolean_algebra (ring Type))) : has_exists_mul_of_le (boolean_algebra (ring Type)) := sorry --non-trivial
lemma new_lemma_78643 (h0 : function.extfun nat fin) : @normalizer_condition.{0} (has_add.{0} real) (@matrix.vec_empty.{0} (group.{0} (has_add.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_78644 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (denumerable.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (denumerable.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_78645 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (add_semigroup.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (add_semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_78646 (h0 : topological_space (free_add_monoid (semiring empty))) : discrete_topology (free_add_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_78647 (h0 : topological_space (encodable (random_gen (random_gen (random_gen (random_gen char)))))) : locally_compact_space (encodable (random_gen (random_gen (random_gen (random_gen char))))) := sorry --non-trivial
lemma new_lemma_78648 (h0 : group (dlist string_imp)) : is_cyclic (dlist string_imp) := sorry --non-trivial
lemma new_lemma_78649 (h0 : ring (div_inv_monoid (option empty))) : is_principal_ideal_ring (div_inv_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_78650 (h0 : topological_space (has_neg (has_pos_part pos))) : t1_space (has_neg (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_78651 (h0 : functor.add_const (ring (left_cancel_monoid empty)) congr_arg_kind) : @strong_rank_condition.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (left_cancel_monoid.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_78652 (h0 : add_group (comm_semigroup (sub_neg_monoid (sub_neg_monoid real)))) : is_add_cyclic (comm_semigroup (sub_neg_monoid (sub_neg_monoid real))) := sorry --non-trivial
lemma new_lemma_78653 (h0 : topological_space (canonically_ordered_comm_semiring (has_neg_part pos))) : totally_disconnected_space (canonically_ordered_comm_semiring (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_78654 (h0 : not (topological_space (encodable linarith.ineq) -> false)) : @totally_disconnected_space.{0} (encodable.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (encodable.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_78655 (h0 : topological_space (comm_group (option (has_add pos)))) : discrete_topology (comm_group (option (has_add pos))) := sorry --non-trivial
lemma new_lemma_78656 (h0 : list (has_inter num)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_78657 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_78658 (h0 : functor.add_const (ordered_add_comm_monoid (complete_distrib_lattice name)) unsigned) : @archimedean.{0} (complete_distrib_lattice.{0} name) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (complete_distrib_lattice.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_78659 (h0 : ring (topological_space fun_info)) : strong_rank_condition (topological_space fun_info) := sorry --non-trivial
lemma new_lemma_78660 (h0 : filter (boolean_algebra (has_pos_part pos))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_78661 (h0 : ring (has_sub empty)) : rank_condition (has_sub empty) := sorry --non-trivial
lemma new_lemma_78662 (h0 : has_mem.mem (functor.add_const (topological_space (comm_monoid empty))) has_zero.zero) : @loc_path_connected_space.{0} (comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_monoid.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (comm_monoid.{0} empty))) (@multiset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) (functor.add_const.{0 0} (topological_space.{0} (comm_monoid.{0} empty))) h0) empty))  := sorry --non-trivial
lemma new_lemma_78663 (h0 : functor.add_const (function.extfun (Type 1) topological_space) (ring Type)) : @irreducible_space.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) (ring.{1} Type) h0) (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_78664 (h0 : functor.add_const (filter (semigroup pos)) linarith.comp) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_78665 (h0 : group (add_cancel_monoid (has_add (has_to_string linarith.comp)))) : normalizer_condition (add_cancel_monoid (has_add (has_to_string linarith.comp))) := sorry --non-trivial
lemma new_lemma_78666 (h0 : functor.add_const (ring (has_edist empty)) congr_arg_kind) : @is_domain.{0} (has_edist.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (has_edist.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_78667 (h0 : thunk (fin has_zero.zero)) : @matrix.vec_empty.{0} Prop (@trace_call_stack.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)  := sorry --non-trivial
lemma new_lemma_78668 (h0 : has_lt (has_nnnorm (mul_one_class ereal))) : no_max_order (has_nnnorm (mul_one_class ereal)) := sorry --non-trivial
lemma new_lemma_78669 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} (has_one.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (has_one.{0} num))  := sorry --non-trivial
lemma new_lemma_78670 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (fintype.{0} unsigned) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (fintype.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_78671 (h0 : functor.add_const (function.extfun Type ring) (ring linarith.comp)) : @is_domain.{0} (boolean_algebra.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) (ring.{0} linarith.comp) h0) (boolean_algebra.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_78672 (h0 : finset (normed_comm_ring (option (option ennreal)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_78673 (h0 : functor.add_const (semiring (boolean_algebra.core pos)) linarith.comp) : @is_noetherian_ring.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 0} (semiring.{0} (boolean_algebra.core.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_78674 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_78675 (h0 : measurable_space (comm_monoid (option empty))) (h1 : topological_space (measure_theory.measure (comm_monoid (option empty)))) : totally_separated_space (measure_theory.measure (comm_monoid (option empty))) := sorry --non-trivial
lemma new_lemma_78676 (h0 : ring (has_to_string (option (option ennreal)))) : is_principal_ideal_ring (has_to_string (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_78677 (h0 : functor.add_const Prop (monoid_with_zero unsigned)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_78678 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @regular_space.{0} (has_neg.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_neg.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_78679 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (normed_lattice_add_comm_group.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (normed_lattice_add_comm_group.{0} name))  := sorry --non-trivial
lemma new_lemma_78680 (h0 : group (mul_zero_class (semiring (semiring num)))) : normalizer_condition (mul_zero_class (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_78681 (h0 : topological_space (has_nnnorm (random_gen string_imp))) : locally_compact_space (has_nnnorm (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_78682 (h0 : ordered_add_comm_monoid (complete_distrib_lattice (sub_neg_monoid real))) : archimedean (complete_distrib_lattice (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_78683 (h0 : functor.add_const (ordered_comm_monoid (ordered_comm_ring name)) linarith.comp) : @has_exists_mul_of_le.{0} (ordered_comm_ring.{0} name) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (ordered_comm_ring.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_78684 (h0 : topological_space (add_right_cancel_monoid (semiring unsigned))) : topological_space.separable_space (add_right_cancel_monoid (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_78685 (h0 : fin has_zero.zero) : @topological_space.separable_space.{0} (has_add.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (has_add.{0} pos)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_78686 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (as_linear_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (as_linear_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_78687 (h1 : filter (dlist string_imp)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_78688 (h0 : functor.add_const (function.extfun Type group) environment.implicit_infer_kind) : @is_simple_group.{0} (has_nndist.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) environment.implicit_infer_kind h0) (has_nndist.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_78689 (h0 : functor.add_const (ring (preorder pos)) name) : @is_domain.{0} (preorder.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (preorder.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_78690 (h0 : add_group (has_sub (semiring (semiring (add_group (semiring congr_arg_kind)))))) : is_add_cyclic (has_sub (semiring (semiring (add_group (semiring congr_arg_kind))))) := sorry --non-trivial
lemma new_lemma_78691 (h0 : has_mem.mem add_group has_emptyc.emptyc) : @is_add_cyclic.{0} (random_gen.{0} num) (@function.extfun_app.{2 1} Type add_group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) add_group.{0} h0) (random_gen.{0} num))  := sorry --non-trivial
lemma new_lemma_78692 (h0 : add_group (has_neg (semigroup pos))) : is_add_cyclic (has_neg (semigroup pos)) := sorry --non-trivial
lemma new_lemma_78693 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (ring num)) := sorry --non-trivial
lemma new_lemma_78694 (h0 : list (finset (option unsigned))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_78695 (h0 : uniform_space (canonically_ordered_comm_semiring (has_add Type))) : complete_space (canonically_ordered_comm_semiring (has_add Type)) := sorry --non-trivial
lemma new_lemma_78696 (h0 : functor.add_const (ring (option empty)) unsigned) : @strong_rank_condition.{0} (option.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (option.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_78697 (h0 : function.extfun Type topological_space) : @normal_space.{0} (semigroup.{0} (semiring.{0} (semiring.{0} unsigned))) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} (semiring.{0} (semiring.{0} unsigned))))  := sorry --non-trivial
lemma new_lemma_78698 (h0 : functor.add_const (topological_space (has_to_string linarith.comp)) Type) : @normal_space.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_to_string.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_78699 (h0 : group (measure_theory.measure_space (semiring (semiring unsigned)))) : is_cyclic (measure_theory.measure_space (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_78700 (h0 : complete_lattice (has_neg (option (option pos)))) : is_atomistic (has_neg (option (option pos))) := sorry --non-trivial
lemma new_lemma_78701 (h0 : ring (normed_field (metric_space reducibility_hints))) : is_domain (normed_field (metric_space reducibility_hints)) := sorry --non-trivial
lemma new_lemma_78702 (h0 : semiring (has_Inf pos)) : is_noetherian_ring (has_Inf pos) := sorry --non-trivial
lemma new_lemma_78703 (h0 : set (mul_one_class (mul_one_class (mul_one_class (mul_one_class (mul_one_class reducibility_hints)))))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_78704 (h0 : functor.add_const (function.extfun Type group) pos) : @is_cyclic.{0} (has_neg.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) pos h0) (has_neg.{0} name))  := sorry --non-trivial
lemma new_lemma_78705 (h0 : function.extfun nat fin) : @separated_space.{1} (boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (uniform_space.{1} (boolean_algebra.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_78706 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} linarith.comp (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) linarith.comp)  := sorry --non-trivial
lemma new_lemma_78707 (h0 : uniform_space (comm_semigroup pos)) : complete_space (comm_semigroup pos) := sorry --non-trivial
lemma new_lemma_78708 (h0 : function.extfun Type group) : @is_cyclic.{0} (normed_group.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} h0 (normed_group.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_78709 (h2 : not (topological_space (has_ssubset linarith.ineq) -> false)) : @totally_disconnected_space.{0} (has_ssubset.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (has_ssubset.{0} linarith.ineq)) h2)  := sorry --non-trivial
lemma new_lemma_78710 (h0 : topological_space (boolean_algebra (finset environment.implicit_infer_kind))) : totally_separated_space (boolean_algebra (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_78711 (h0 : topological_space (semigroup (finset Type))) : topological_space.separable_space (semigroup (finset Type)) := sorry --non-trivial
lemma new_lemma_78712 (h2 : complete_lattice (fintype (distrib linarith.ineq))) : is_compactly_generated (fintype (distrib linarith.ineq)) := sorry --non-trivial
lemma new_lemma_78713 (h0 : uniform_space (complete_distrib_lattice (has_nndist name))) : separated_space (complete_distrib_lattice (has_nndist name)) := sorry --non-trivial
lemma new_lemma_78714 (h0 : functor.add_const (topological_space (has_to_string unsigned)) environment.implicit_infer_kind) : @locally_compact_space.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_78715 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (free_add_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (free_add_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_78716 (h0 : complete_lattice (mv_power_series enat linarith.comp_source)) : complete_lattice.is_Sup_finite_compact (mv_power_series enat linarith.comp_source) := sorry --non-trivial
lemma new_lemma_78717 (h0 : functor.add_const Prop (has_add (option ennreal))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_78718 (h0 : filter (dlist (denumerable linarith.ineq))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_78719 (h0 : ordered_add_comm_monoid (finset (has_neg pos))) : archimedean (finset (has_neg pos)) := sorry --non-trivial
lemma new_lemma_78720 (h0 : topological_space (pseudo_metric_space to_additive.value_type)) : totally_separated_space (pseudo_metric_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_78721 (h0 : fin has_zero.zero) : @group.fg.{0} (has_add.{0} pos) (@matrix.vec_empty.{0} (group.{0} (has_add.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_78722 (h0 : topological_space (comm_group (finset pos))) : topological_space.separable_space (comm_group (finset pos)) := sorry --non-trivial
lemma new_lemma_78723 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @complete_space.{0} (complete_linear_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) uniform_space.{0}) (complete_linear_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_78724 (h0 : not (topological_space (has_top empty) -> false)) : @locally_compact_space.{0} (has_top.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (has_top.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_78725 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (complete_distrib_lattice.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_distrib_lattice.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_78726 (h0 : topological_space (has_ssubset (has_nnnorm (random_gen to_additive.value_type)))) : locally_compact_space (has_ssubset (has_nnnorm (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_78727 (h0 : measurable_space linarith.comp_source) (h1 : measure_theory.measure linarith.comp_source) : measure_theory.is_finite_measure h1 := sorry --non-trivial
lemma new_lemma_78728 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (has_nndist.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_nndist.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_78729 (h0 : not (topological_space (has_emptyc congr_arg_kind) -> false)) : @path_connected_space.{0} (has_emptyc.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (has_emptyc.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_78730 (h0 : functor.add_const (group (has_nndist unsigned)) Type) : @group.fg.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 1} (group.{0} (has_nndist.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_78731 (h0 : ring (id (has_top linarith.ineq))) : rank_condition (id (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_78732 (h0 : function.extfun (Type 1) topological_space) : @totally_disconnected_space.{1} (generalized_boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (generalized_boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_78733 (h0 : ring (semilattice_inf (option empty))) : is_domain (semilattice_inf (option empty)) := sorry --non-trivial
lemma new_lemma_78734 (h0 : add_group (canonically_linear_ordered_monoid Type)) : is_add_cyclic (canonically_linear_ordered_monoid Type) := sorry --non-trivial
lemma new_lemma_78735 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @normalizer_condition.{1} Type (@function.extfun_app.{3 2} (Type 1) group.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 group.{1}) Type)  := sorry --non-trivial
lemma new_lemma_78736 (h0 : topological_space (has_neg unsigned)) : t1_space (has_neg unsigned) := sorry --non-trivial
lemma new_lemma_78737 (h0 : topological_space (has_zero pos)) : t1_space (has_zero pos) := sorry --non-trivial
lemma new_lemma_78738 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @sequential_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (semigroup.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_78739 (h0 : has_mem.mem fun_info has_emptyc.emptyc) : @rank_condition.{0} fun_info (@finset.pi.empty.{1 0} Type ring.{0} fun_info h0)  := sorry --non-trivial
lemma new_lemma_78740 (h0 : cancel_comm_monoid_with_zero (add_cancel_comm_monoid unsigned)) : unique_factorization_monoid (add_cancel_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_78741 (h0 : function.extfun nat fin) : @monoid.fg.{0} (has_bot.{0} pos) (@matrix.vec_empty.{0} (monoid.{0} (has_bot.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_78742 (h1 : topological_space (random_gen to_additive.value_type)) : discrete_topology (random_gen to_additive.value_type) := sorry --non-trivial
lemma new_lemma_78743 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring Type)) name) : @locally_compact_space.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (canonically_ordered_comm_semiring.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_78744 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} (add_right_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (add_right_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_78745 (h0 : filter (ring (has_pos_part (has_neg Type)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_78746 (h0 : functor.comp monoid add_comm_monoid Type) : @monoid.fg.{1} (add_comm_monoid.{1} Type) (@functor.comp.run.{1 1 1} monoid.{1} add_comm_monoid.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_78747 (h0 : not (topological_space (has_inv fun_info) -> false)) : @totally_disconnected_space.{0} (has_inv.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (has_inv.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_78748 (h0 : group (monoid_with_zero unsigned)) : group.fg (monoid_with_zero unsigned) := sorry --non-trivial
lemma new_lemma_78749 (h0 : functor.add_const (topological_space znum) (option (option empty))) : @preirreducible_space.{0} znum (@functor.add_const.run.{0 0} (topological_space.{0} znum) (option.{0} (option.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_78750 (h0 : group (has_inv (has_inv fun_info))) : is_cyclic (has_inv (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_78751 (h0 : set (rel (mul_one_class char) string.iterator_imp)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_78752 (h0 : group (has_Inf (finset linarith.comp))) : group.fg (has_Inf (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_78753 (h0 : fin has_zero.zero) : @normalizer_condition.{0} (comm_semigroup.{0} real) (@matrix.vec_empty.{0} (group.{0} (comm_semigroup.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_78754 (h0 : group (has_ssubset (random_gen to_additive.value_type))) : group.fg (has_ssubset (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_78755 (h0 : functor.add_const (functor.add_const (filter Type) linarith.comp) linarith.comp) : countable_Inter_filter (functor.add_const.run (functor.add_const.run h0)) := sorry --non-trivial
lemma new_lemma_78756 (h0 : monoid unsigned) (h1 : topological_space (star_monoid unsigned)) : topological_space.separable_space (star_monoid unsigned) := sorry --non-trivial
lemma new_lemma_78757 (h0 : functor.add_const (topological_space (complete_linear_order num)) congr_arg_kind) : @irreducible_space.{0} (complete_linear_order.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_linear_order.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_78758 (h0 : topological_space (add_comm_monoid (normed_comm_ring environment.implicit_infer_kind))) : sequential_space (add_comm_monoid (normed_comm_ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_78759 (h0 : functor.add_const (function.extfun (Type 1) group) linarith.comp) : @is_cyclic.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) group.{1}) linarith.comp h0) (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_78760 (h0 : add_monoid (add_group num)) : add_monoid.fg (add_group num) := sorry --non-trivial
lemma new_lemma_78761 (h0 : empty) (h1 : option empty) : @is_cyclic.{0} (has_nnnorm.{0} (has_nnnorm.{0} char)) (@empty.elim.{1} (group.{0} (has_nnnorm.{0} (has_nnnorm.{0} char))) (@option.lhoare.{0} empty h0 h1))  := sorry --non-trivial
lemma new_lemma_78762 (h0 : topological_space (add_comm_monoid (comm_group (comm_group (comm_group pos))))) : irreducible_space (add_comm_monoid (comm_group (comm_group (comm_group pos)))) := sorry --non-trivial
lemma new_lemma_78763 (h0 : topological_space (add_group (semiring linarith.comp))) : totally_disconnected_space (add_group (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_78764 (h0 : group (id (semiring (semiring empty)))) : normalizer_condition (id (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_78765 (h0 : functor.add_const (ring (boolean_algebra.core name)) name) : @rank_condition.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.core.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_78766 (h0 : not (complete_lattice (non_assoc_semiring empty) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (non_assoc_semiring.{0} empty) (@classical.by_contradiction'.{1} (complete_lattice.{0} (non_assoc_semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_78767 (h1 : has_mem.mem (complete_semilattice_Sup congr_arg_kind) has_emptyc.emptyc) : @is_domain.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type ring.{0} (complete_semilattice_Sup.{0} congr_arg_kind) h1)  := sorry --non-trivial
lemma new_lemma_78768 (h1 : list (has_inv string_imp)) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_78769 (h0 : functor.add_const (ordered_comm_monoid (has_neg_part pos)) (comm_group (has_nndist (has_add pos)))) : @has_exists_mul_of_le.{0} (has_neg_part.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_neg_part.{0} pos)) (comm_group.{0} (has_nndist.{0} (has_add.{0} pos))) h0)  := sorry --non-trivial
lemma new_lemma_78770 (h0 : functor.add_const (function.extfun Type complete_lattice) unsigned) : @complete_lattice.is_Sup_finite_compact.{0} pos (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) unsigned h0) pos)  := sorry --non-trivial
lemma new_lemma_78771 (h0 : filter (cancel_monoid unsigned)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_78772 (h0 : add_group (linear_ordered_add_comm_group (has_inter char))) : is_add_cyclic (linear_ordered_add_comm_group (has_inter char)) := sorry --non-trivial
lemma new_lemma_78773 (h0 : function.extfun nat fin) : @t1_space.{1} (comm_semigroup.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (comm_semigroup.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_78774 (h0 : ring (nondiscrete_normed_field std_gen)) : is_domain (nondiscrete_normed_field std_gen) := sorry --non-trivial
lemma new_lemma_78775 (h0 : topological_space (normed_comm_ring (option (option (option (option ennreal)))))) : preconnected_space (normed_comm_ring (option (option (option (option ennreal))))) := sorry --non-trivial
lemma new_lemma_78776 (h0 : functor.add_const Prop (has_neg (has_to_string (add_comm_monoid ennreal)))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_78777 (h0 : topological_space ereal) (h1 : group ereal) : topological_group ereal := sorry --non-trivial
lemma new_lemma_78778 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (has_neg.{0} name) (@function.extfun_app.{2 1} Type semiring.{0} h0 (has_neg.{0} name))  := sorry --non-trivial
lemma new_lemma_78779 (h0 : has_lt (normed_field char)) : no_max_order (normed_field char) := sorry --non-trivial
lemma new_lemma_78780 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @t0_space.{0} (has_emptyc.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (has_emptyc.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_78781 (h0 : topological_space (has_to_string unsigned)) : preconnected_space (has_to_string unsigned) := sorry --non-trivial
lemma new_lemma_78782 (h1 : group (linear_ordered_add_comm_group char)) : group.fg (linear_ordered_add_comm_group char) := sorry --non-trivial
lemma new_lemma_78783 (h0 : topological_space (boolean_algebra.core (option (option ennreal)))) : irreducible_space (boolean_algebra.core (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_78784 (h0 : functor.add_const (complete_lattice (mul_zero_class name)) name) : @is_compactly_generated.{0} (mul_zero_class.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (mul_zero_class.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_78785 (h0 : filter (distrib_lattice linarith.ineq)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_78786 (h0 : topological_space (with_one (dlist (complete_semilattice_Inf char)))) : locally_compact_space (with_one (dlist (complete_semilattice_Inf char))) := sorry --non-trivial
lemma new_lemma_78787 (h0 : functor.add_const (function.extfun Type group) (mul_zero_class Type)) : @group.fg.{0} (has_neg_part.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type group.{0}) (mul_zero_class.{1} Type) h0) (has_neg_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_78788 (h0 : group (add_group (has_norm unsigned))) : normalizer_condition (add_group (has_norm unsigned)) := sorry --non-trivial
lemma new_lemma_78789 (h0 : functor.add_const (complete_lattice (cancel_monoid Type)) environment.implicit_infer_kind) : @is_compactly_generated.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (cancel_monoid.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_78790 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (has_nnnorm.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_nnnorm.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_78791 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_inter.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (has_inter.{0} empty))  := sorry --non-trivial
lemma new_lemma_78792 (h0 : functor.add_const (topological_space (left_cancel_monoid unsigned)) unsigned) : @locally_compact_space.{0} (left_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_78793 (h0 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h0) (complete_semilattice_Sup.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_78794 (h0 : uniform_space (add_comm_semigroup ereal)) : complete_space (add_comm_semigroup ereal) := sorry --non-trivial
lemma new_lemma_78795 (h0 : topological_space (linear_ordered_semiring linarith.ineq)) : totally_separated_space (linear_ordered_semiring linarith.ineq) := sorry --non-trivial
lemma new_lemma_78796 (h0 : not (complete_lattice (plift empty) -> false)) : @is_compactly_generated.{1} (plift.{1} empty) (@classical.by_contradiction'.{2} (complete_lattice.{1} (plift.{1} empty)) h0)  := sorry --non-trivial
lemma new_lemma_78797 (h0 : add_group (linear_ordered_comm_monoid_with_zero empty)) : is_add_cyclic (linear_ordered_comm_monoid_with_zero empty) := sorry --non-trivial
lemma new_lemma_78798 (h1 : function.extfun Type topological_space) : @path_connected_space.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (linear_ordered_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_78799 (h0 : list (distrib_lattice (has_inv (has_inv linarith.ineq)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_78800 (h0 : has_lt (linear_ordered_comm_group_with_zero ereal)) : no_max_order (linear_ordered_comm_group_with_zero ereal) := sorry --non-trivial
lemma new_lemma_78801 (h0 : filter linarith.ineq) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_78802 (h0 : list (semigroup (option pos))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_78803 (h0 : complete_lattice (has_zero (has_add linarith.comp))) : is_compactly_generated (has_zero (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_78804 (h0 : add_monoid (metric_space (semiring congr_arg_kind))) : add_monoid.fg (metric_space (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_78805 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @complete_lattice.is_Sup_finite_compact.{1} (plift.{1} unsigned) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 complete_lattice.{1}) (plift.{1} unsigned))  := sorry --non-trivial
lemma new_lemma_78806 (h0 : topological_space (boolean_algebra (has_neg_part Type))) : discrete_topology (boolean_algebra (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_78807 (h0 : functor.comp topological_space boolean_algebra.core Type) : @topological_space.separable_space.{1} (boolean_algebra.core.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} boolean_algebra.core.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_78808 (h0 : group (ring (comm_group (has_neg_part (has_neg_part Type))))) : is_cyclic (ring (comm_group (has_neg_part (has_neg_part Type)))) := sorry --non-trivial
lemma new_lemma_78809 (h0 : group (complete_distrib_lattice (sub_neg_monoid (has_add real)))) : is_cyclic (complete_distrib_lattice (sub_neg_monoid (has_add real))) := sorry --non-trivial
lemma new_lemma_78810 (h0 : complete_lattice (with_one (has_nnnorm linarith.ineq))) : is_compactly_generated (with_one (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_78811 (h0 : semiring (has_nndist pos)) : is_noetherian_ring (has_nndist pos) := sorry --non-trivial
lemma new_lemma_78812 (h0 : function.extfun Type (functor.add_const (functor.add_const (list (add_left_cancel_semigroup empty)) empty))) : list.nodup (functor.add_const.run (functor.add_const.run (function.extfun_app h0 empty))) := sorry --non-trivial
lemma new_lemma_78813 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (distrib_lattice.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (distrib_lattice.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_78814 (h0 : topological_space (random_gen string_imp)) : path_connected_space (random_gen string_imp) := sorry --non-trivial
lemma new_lemma_78815 (h0 : functor.add_const (group (mul_zero_class environment.implicit_infer_kind)) Type) : @is_cyclic.{0} (mul_zero_class.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (group.{0} (mul_zero_class.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_78816 (h0 : not (ring (has_one fun_info) -> false)) : @strong_rank_condition.{0} (has_one.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (has_one.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_78817 (h0 : finset (has_pos_part (has_add (ring linarith.comp)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_78818 (h0 : topological_space (has_neg_part (has_to_string unsigned))) : loc_path_connected_space (has_neg_part (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_78819 (h0 : not (topological_space (semiring congr_arg_kind) -> false)) : @totally_disconnected_space.{0} (semiring.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (semiring.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_78820 (h0 : finset (normed_comm_ring (finset linarith.comp))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_78821 (h1 : group (with_bot linarith.ineq)) : normalizer_condition (with_bot linarith.ineq) := sorry --non-trivial
lemma new_lemma_78822 (h0 : ring (monoid (option empty))) : rank_condition (monoid (option empty)) := sorry --non-trivial
lemma new_lemma_78823 (h0 : filter (has_union linarith.comp)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_78824 (h0 : finset (semigroup (has_add (has_add (option ennreal))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_78825 (h0 : function.extfun (Type 1) complete_lattice) : @is_compactly_generated.{1} Type (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} h0 Type)  := sorry --non-trivial
lemma new_lemma_78826 (h0 : functor.add_const (topological_space (has_to_string name)) pos) : @preconnected_space.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_78827 (h0 : group (canonically_ordered_add_monoid (semiring empty))) : is_cyclic (canonically_ordered_add_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_78828 (h0 : group (finset (option (option (option unsigned))))) : is_simple_group (finset (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_78829 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @topological_space.separable_space.{0} (semigroup.{0} (has_add.{0} pos)) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (semigroup.{0} (has_add.{0} pos)))  := sorry --non-trivial
lemma new_lemma_78830 (h0 : cancel_comm_monoid_with_zero (canonically_ordered_comm_semiring (option (option (option unsigned))))) : unique_factorization_monoid (canonically_ordered_comm_semiring (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_78831 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (has_top linarith.comp)) := sorry --non-trivial
lemma new_lemma_78832 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (has_bot (option ennreal))) := sorry --non-trivial
lemma new_lemma_78833 (h1 : group (semi_normed_ring linarith.comp_source)) : is_cyclic (semi_normed_ring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_78834 (h0 : filter (left_cancel_monoid (option empty))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_78835 (h0 : complete_lattice (has_neg (has_neg_part pos))) : complete_lattice.is_Sup_finite_compact (has_neg (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_78836 (h0 : group (has_neg_part (has_neg (ring pos)))) : normalizer_condition (has_neg_part (has_neg (ring pos))) := sorry --non-trivial
lemma new_lemma_78837 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (has_dist.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_dist.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_78838 (h1 : complete_lattice (has_nnnorm (random_gen (has_ssubset string_imp)))) : is_compactly_generated (has_nnnorm (random_gen (has_ssubset string_imp))) := sorry --non-trivial
lemma new_lemma_78839 (h0 : add_monoid (ordered_comm_group (option (option (option (option (option empty))))))) : add_monoid.fg (ordered_comm_group (option (option (option (option (option empty)))))) := sorry --non-trivial
lemma new_lemma_78840 (h0 : topological_space (has_emptyc (has_norm fun_info))) : irreducible_space (has_emptyc (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_78841 (h0 : topological_space (boolean_algebra (canonically_ordered_monoid real))) : irreducible_space (boolean_algebra (canonically_ordered_monoid real)) := sorry --non-trivial
lemma new_lemma_78842 (h0 : functor.add_const (ordered_add_comm_monoid (normed_comm_ring name)) Type) : @archimedean.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 1} (ordered_add_comm_monoid.{0} (normed_comm_ring.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_78843 (h0 : group (mul_zero_class (finset name))) : group.fg (mul_zero_class (finset name)) := sorry --non-trivial
lemma new_lemma_78844 (h0 : topological_space (add_cancel_monoid Type)) : totally_separated_space (add_cancel_monoid Type) := sorry --non-trivial
lemma new_lemma_78845 (h0 : complete_lattice (linear_ordered_comm_group pos)) : is_compactly_generated (linear_ordered_comm_group pos) := sorry --non-trivial
lemma new_lemma_78846 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_78847 (h1 : topological_space (mul_one_class enat)) : t0_space (mul_one_class enat) := sorry --non-trivial
lemma new_lemma_78848 (h0 : topological_space (complete_distrib_lattice (has_add (has_Inf (has_add (ring Type)))))) : totally_separated_space (complete_distrib_lattice (has_add (has_Inf (has_add (ring Type))))) := sorry --non-trivial
lemma new_lemma_78849 (h0 : monoid (with_one (random_gen (random_gen (random_gen fun_info))))) : monoid.fg (with_one (random_gen (random_gen (random_gen fun_info)))) := sorry --non-trivial
lemma new_lemma_78850 (h0 : functor.add_const (topological_space (boolean_algebra unsigned)) name) : @totally_disconnected_space.{0} (boolean_algebra.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_78851 (h0 : functor.add_const (monoid (has_to_string name)) linarith.comp) : @monoid.fg.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (monoid.{0} (has_to_string.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_78852 (h0 : group (has_zero environment.implicit_infer_kind)) : group.fg (has_zero environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_78853 (h0 : topological_space (comm_group (boolean_algebra (has_neg (has_add linarith.comp))))) : regular_space (comm_group (boolean_algebra (has_neg (has_add linarith.comp)))) := sorry --non-trivial
lemma new_lemma_78854 (h0 : fun_info) (h1 : set fun_info) : set.mem h0 h1 := sorry --non-trivial
lemma new_lemma_78855 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (finset.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (finset.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_78856 (h0 : topological_space (has_inter num)) : loc_path_connected_space (has_inter num) := sorry --non-trivial
lemma new_lemma_78857 (h0 : uniform_space (normed_group (has_inv (has_inv to_additive.value_type)))) : complete_space (normed_group (has_inv (has_inv to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_78858 (h1 h2 : multiset (add_comm_semigroup fun_info)) : multiset.le h1 h2 := sorry --non-trivial
lemma new_lemma_78859 (h0 : uniform_space (has_pos_part (has_pos_part name))) : complete_space (has_pos_part (has_pos_part name)) := sorry --non-trivial
lemma new_lemma_78860 (h0 : topological_space (has_pos_part (has_Inf linarith.comp))) : locally_compact_space (has_pos_part (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_78861 (h0 : topological_space (cancel_monoid (option unsigned))) : discrete_topology (cancel_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_78862 (h0 : not (function.extfun Type topological_space -> false)) : @preirreducible_space.{0} (has_star.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_star.{0} num))  := sorry --non-trivial
lemma new_lemma_78863 (h0 : functor.add_const (topological_space (has_to_string pos)) (has_Inf pos)) : @path_connected_space.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} pos)) (has_Inf.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_78864 (h0 : functor.add_const (function.extfun Type filter) pos) : filter.ne_bot (function.extfun_app (functor.add_const.run h0) (semigroup pos)) := sorry --non-trivial
lemma new_lemma_78865 (h0 : functor.add_const (topological_space (boolean_algebra environment.implicit_infer_kind)) (has_pos_part Type)) : @totally_disconnected_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) (has_pos_part.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_78866 (h0 : group (add_comm_monoid (finset linarith.comp))) : is_cyclic (add_comm_monoid (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_78867 (h0 : complete_lattice (complete_semilattice_Sup (has_inv linarith.ineq))) : complete_lattice.is_Sup_finite_compact (complete_semilattice_Sup (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_78868 (h0 : functor.add_const (function.extfun (Type 1) complete_lattice) linarith.comp) : @complete_lattice.is_Sup_finite_compact.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) complete_lattice.{1}) linarith.comp h0) (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_78869 (h0 : topological_space (ordered_comm_ring (sub_neg_monoid linarith.comp))) : preconnected_space (ordered_comm_ring (sub_neg_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_78870 (h0 : topological_space (has_Inf (finset name))) : preconnected_space (has_Inf (finset name)) := sorry --non-trivial
lemma new_lemma_78871 (h0 : functor.add_const (topological_space (has_neg linarith.comp)) linarith.comp) : @regular_space.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_78872 (h0 : list (dlist (random_gen (has_top fun_info)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_78873 (h1 : not (ring (normed_group congr_arg_kind) -> false)) : @strong_rank_condition.{0} (normed_group.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (ring.{0} (normed_group.{0} congr_arg_kind)) h1)  := sorry --non-trivial
lemma new_lemma_78874 (h0 : functor.add_const (list (has_add unsigned)) unsigned) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_78875 (h0 : set (add_comm_semigroup (mul_one_class (add_comm_semigroup std_gen)) -> enat)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_78876 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (pseudo_metric_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_group.{0} h0 (pseudo_metric_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_78877 (h0 : list (has_nndist (has_to_string pos))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_78878 (h0 : group (metric_space (has_norm num))) : is_cyclic (metric_space (has_norm num)) := sorry --non-trivial
lemma new_lemma_78879 (h0 : add_group (topological_space (has_nnnorm linarith.ineq))) : is_add_cyclic (topological_space (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_78880 (h0 : topological_space (with_zero (has_nnnorm string_imp))) : totally_disconnected_space (with_zero (has_nnnorm string_imp)) := sorry --non-trivial
lemma new_lemma_78881 (h0 : ring (non_unital_non_assoc_semiring (has_div reducibility_hints))) : strong_rank_condition (non_unital_non_assoc_semiring (has_div reducibility_hints)) := sorry --non-trivial
lemma new_lemma_78882 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (ordered_cancel_add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_cancel_add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_78883 (h0 : has_mem.mem group has_emptyc.emptyc) : @normalizer_condition.{0} (measurable_space.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} h0) (measurable_space.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_78884 (h0 : not (topological_space (linear_ordered_comm_ring empty) -> false)) : @locally_compact_space.{0} (linear_ordered_comm_ring.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_comm_ring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_78885 (h0 : complete_lattice (has_add (finset pos))) : is_compactly_generated (has_add (finset pos)) := sorry --non-trivial
lemma new_lemma_78886 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @totally_separated_space.{0} (with_bot.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) topological_space.{0}) (with_bot.{0} num))  := sorry --non-trivial
lemma new_lemma_78887 (h0 : functor.add_const (monoid (add_left_cancel_semigroup unsigned)) (semiring empty)) : @monoid.fg.{0} (add_left_cancel_semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (monoid.{0} (add_left_cancel_semigroup.{0} unsigned)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_78888 (h0 : uniform_space (monoid_with_zero (option (option pos)))) : complete_space (monoid_with_zero (option (option pos))) := sorry --non-trivial
lemma new_lemma_78889 (h0 : not (uniform_space (has_sub empty) -> false)) : @separated_space.{0} (has_sub.{0} empty) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_sub.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_78890 (h0 : functor.add_const (ordered_comm_monoid (add_cancel_monoid linarith.comp)) pos) : @has_exists_mul_of_le.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (add_cancel_monoid.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_78891 (h0 : ring (boolean_algebra.core congr_arg_kind)) : strong_rank_condition (boolean_algebra.core congr_arg_kind) := sorry --non-trivial
lemma new_lemma_78892 (h0 : functor.add_const (complete_lattice (comm_group pos)) ennreal) : @is_compactly_generated.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (comm_group.{0} pos)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_78893 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (has_nndist.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_nndist.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_78894 (h1 : filter (denumerable string_imp)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_78895 (h0 : fin has_zero.zero) : @complete_space.{0} (canonically_ordered_comm_semiring.{0} name) (@matrix.vec_empty.{0} (uniform_space.{0} (canonically_ordered_comm_semiring.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_78896 (h0 : ring (linear_ordered_comm_group empty)) : is_domain (linear_ordered_comm_group empty) := sorry --non-trivial
lemma new_lemma_78897 (h0 : topological_space (has_ssubset (has_ssubset to_additive.value_type))) : t0_space (has_ssubset (has_ssubset to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_78898 (h0 : functor.add_const (functor.add_const Prop (has_Inf pos)) pos) : functor.add_const.run (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_78899 (h0 : cancel_comm_monoid_with_zero (canonically_linear_ordered_monoid (ordered_comm_monoid Type))) : unique_factorization_monoid (canonically_linear_ordered_monoid (ordered_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_78900 (h0 : add_monoid (canonically_ordered_monoid (has_neg name))) : add_monoid.fg (canonically_ordered_monoid (has_neg name)) := sorry --non-trivial
lemma new_lemma_78901 (h2 : function.extfun Type monoid) : @monoid.fg.{0} (with_bot.{0} linarith.ineq) (@function.extfun_app.{2 1} Type monoid.{0} h2 (with_bot.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_78902 (h0 : function.extfun Type group) : @group.fg.{0} (monoid_with_zero.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (monoid_with_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_78903 (h0 : cancel_comm_monoid_with_zero (add_comm_monoid (option ennreal))) : unique_factorization_monoid (add_comm_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_78904 (h4 : not (ring (distrib linarith.ineq) -> false)) : @strong_rank_condition.{0} (distrib.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (distrib.{0} linarith.ineq)) h4)  := sorry --non-trivial
lemma new_lemma_78905 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} to_additive.value_type (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) to_additive.value_type)  := sorry --non-trivial
lemma new_lemma_78906 (h0 : functor.add_const (uniform_space (comm_group Type)) environment.implicit_infer_kind) : @complete_space.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (comm_group.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_78907 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (preorder.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (preorder.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_78908 (h0 : functor.add_const (group (has_neg linarith.comp)) pos) : @group.fg.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (has_neg.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_78909 (h0 : group (complete_distrib_lattice ennreal)) : is_cyclic (complete_distrib_lattice ennreal) := sorry --non-trivial
lemma new_lemma_78910 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (has_dist.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_dist.{0} empty))  := sorry --non-trivial
lemma new_lemma_78911 (h0 : functor.add_const (list (complete_distrib_lattice Type)) Type) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_78912 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_78913 (h0 : topological_space (linear_ordered_semiring num)) : locally_compact_space (linear_ordered_semiring num) := sorry --non-trivial
lemma new_lemma_78914 (h1 : topological_space (linear_ordered_add_comm_group to_additive.value_type)) : totally_disconnected_space (linear_ordered_add_comm_group to_additive.value_type) := sorry --non-trivial
lemma new_lemma_78915 (h0 : function.extfun Type ring) : @is_domain.{0} (has_ssubset.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_ssubset.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_78916 (h0 : topological_space (has_dist (option (option (option (option unsigned)))))) : discrete_topology (has_dist (option (option (option (option unsigned))))) := sorry --non-trivial
lemma new_lemma_78917 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (semigroup.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_78918 (h0 : functor.add_const (ordered_comm_monoid (sub_neg_monoid linarith.comp)) linarith.comp) : @has_exists_mul_of_le.{0} (sub_neg_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (sub_neg_monoid.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_78919 (h0 : ordered_add_comm_monoid (semigroup (option unsigned))) : archimedean (semigroup (option unsigned)) := sorry --non-trivial
lemma new_lemma_78920 (h0 : topological_space (mul_zero_class (has_add (option ennreal)))) : t0_space (mul_zero_class (has_add (option ennreal))) := sorry --non-trivial
lemma new_lemma_78921 (h0 : not (filter (has_ssubset char) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_78922 (h1 : function.extfun Type ring) : @rank_condition.{0} (measurable_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h1 (measurable_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_78923 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_78924 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (has_bot.{0} linarith.comp) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (has_bot.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_78925 (h0 : functor.add_const (topological_space (has_nndist environment.implicit_infer_kind)) pos) : @t1_space.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_78926 (h4 : topological_space char) : totally_disconnected_space char := sorry --non-trivial
lemma new_lemma_78927 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (complete_distrib_lattice.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_78928 (h0 : add_group (topological_space (encodable (random_gen (fintype linarith.comp_source))))) : is_add_cyclic (topological_space (encodable (random_gen (fintype linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_78929 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem uniform_space)) : @complete_space.{0} congr_arg_kind (@function.extfun_app.{2 1} Type uniform_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) uniform_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) uniform_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_78930 (h0 : topological_space (as_linear_order (left_cancel_monoid (option empty)))) : normal_space (as_linear_order (left_cancel_monoid (option empty))) := sorry --non-trivial
lemma new_lemma_78931 (h0 : group (has_to_string linarith.comp)) : group.fg (has_to_string linarith.comp) := sorry --non-trivial
lemma new_lemma_78932 (h0 : functor.add_const (list (plift unsigned)) (semiring empty)) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_78933 (h0 : group (ordered_semiring (random_gen (has_top (random_gen linarith.comp_source))))) : is_cyclic (ordered_semiring (random_gen (has_top (random_gen linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_78934 (h0 : functor.add_const (topological_space (has_pos_part pos)) pos) : @locally_compact_space.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_78935 (h0 : not (uniform_space (has_emptyc (random_gen linarith.comp_source)) -> false)) : @complete_space.{0} (has_emptyc.{0} (random_gen.{0} linarith.comp_source)) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_emptyc.{0} (random_gen.{0} linarith.comp_source))) h0)  := sorry --non-trivial
lemma new_lemma_78936 (h0 : functor.add_const (function.extfun Type uniform_space) empty) : @separated_space.{0} (has_nndist.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) empty h0) (has_nndist.{0} empty))  := sorry --non-trivial
lemma new_lemma_78937 (h0 : function.extfun nat fin) : @preirreducible_space.{1} (normed_lattice_add_comm_group.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (normed_lattice_add_comm_group.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_78938 (h0 : topological_space (boolean_algebra.core (add_cancel_monoid (add_cancel_monoid linarith.comp)))) (h1 : set (boolean_algebra.core (add_cancel_monoid (add_cancel_monoid linarith.comp)))) : is_seq_compact h1 := sorry --non-trivial
lemma new_lemma_78939 (h0 : add_group (has_nndist (comm_group Type))) : is_add_cyclic (has_nndist (comm_group Type)) := sorry --non-trivial
lemma new_lemma_78940 (h0 : complete_lattice (linear_ordered_add_comm_group (random_gen char))) : complete_lattice.is_Sup_finite_compact (linear_ordered_add_comm_group (random_gen char)) := sorry --non-trivial
lemma new_lemma_78941 (h0 : not (complete_lattice (metric_space linarith.comp) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (metric_space.{0} linarith.comp) (@classical.by_contradiction'.{1} (complete_lattice.{0} (metric_space.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_78942 (h0 : complete_lattice (normed_comm_ring empty)) : is_compactly_generated (normed_comm_ring empty) := sorry --non-trivial
lemma new_lemma_78943 (h0 : functor.add_const (add_monoid (has_add environment.implicit_infer_kind)) (ring environment.implicit_infer_kind)) : @add_monoid.fg.{0} (has_add.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_add.{0} environment.implicit_infer_kind)) (ring.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_78944 (h0 : topological_space (uniform_space (metric_space char))) (h1 : preorder (uniform_space (metric_space char))) : order_topology (uniform_space (metric_space char)) := sorry --non-trivial
lemma new_lemma_78945 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (comm_ring to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_78946 (h0 : functor.add_const (topological_space (add_cancel_monoid pos)) environment.implicit_infer_kind) : @path_connected_space.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_78947 (h0 : semiring (has_bot (has_bot Type))) : is_noetherian_ring (has_bot (has_bot Type)) := sorry --non-trivial
lemma new_lemma_78948 (h0 : functor.add_const (function.extfun (Type 1) uniform_space) Type) : @complete_space.{1} (add_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) uniform_space.{1}) Type h0) (add_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_78949 (h0 : complete_lattice (with_one nat)) : is_compactly_generated (with_one nat) := sorry --non-trivial
lemma new_lemma_78950 (h0 : topological_space (complete_distrib_lattice (has_bot (has_bot (has_bot (has_Inf real)))))) : path_connected_space (complete_distrib_lattice (has_bot (has_bot (has_bot (has_Inf real))))) := sorry --non-trivial
lemma new_lemma_78951 (h0 : functor.add_const (topological_space (has_Inf pos)) name) : @totally_separated_space.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_78952 (h0 : group (has_neg (ring linarith.comp))) : is_simple_group (has_neg (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_78953 (h0 : group (measurable_space (has_top (random_gen fun_info)))) : group.fg (measurable_space (has_top (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_78954 (h0 : ring (boolean_algebra (comm_group unsigned))) : rank_condition (boolean_algebra (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_78955 (h0 : topological_space (semigroup (ring linarith.comp))) : totally_separated_space (semigroup (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_78956 (h0 : group (has_emptyc (with_bot to_additive.value_type))) : group.fg (has_emptyc (with_bot to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_78957 (h0 : add_group (semigroup pos)) : is_add_cyclic (semigroup pos) := sorry --non-trivial
lemma new_lemma_78958 (h0 : functor.add_const (ring (monoid pos)) pos) : @is_domain.{0} (monoid.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (monoid.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_78959 (h0 : topological_space (encodable (with_bot to_additive.value_type))) : totally_separated_space (encodable (with_bot to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_78960 (h0 : ordered_add_comm_monoid (has_to_string (option (option (option (option (option pos))))))) : archimedean (has_to_string (option (option (option (option (option pos)))))) := sorry --non-trivial
lemma new_lemma_78961 (h0 : functor.add_const (topological_space (cancel_monoid pos)) environment.implicit_infer_kind) : @discrete_topology.{0} (cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_78962 (h0 : complete_lattice (ordered_comm_ring (has_Inf (has_Inf real)))) : is_atomistic (ordered_comm_ring (has_Inf (has_Inf real))) := sorry --non-trivial
lemma new_lemma_78963 (h0 : nat) (h1 h2 : fin h0) : fin.lt h1 (id h2) := sorry --non-trivial
lemma new_lemma_78964 (h0 : functor.add_const (monoid (boolean_algebra linarith.comp)) (ring environment.implicit_infer_kind)) : @monoid.fg.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (monoid.{0} (boolean_algebra.{0} linarith.comp)) (ring.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_78965 (h0 : topological_space (monoid_with_zero pos)) : topological_space.separable_space (monoid_with_zero pos) := sorry --non-trivial
lemma new_lemma_78966 (h0 : ordered_add_comm_monoid (complete_distrib_lattice (has_nndist (finset (has_add (has_neg Type)))))) : archimedean (complete_distrib_lattice (has_nndist (finset (has_add (has_neg Type))))) := sorry --non-trivial
lemma new_lemma_78967 (h0 : uniform_space (has_norm (has_top linarith.comp))) : complete_space (has_norm (has_top linarith.comp)) := sorry --non-trivial
lemma new_lemma_78968 (h1 : filter (encodable (has_nnnorm (has_nnnorm char)))) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_78969 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (canonically_linear_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_linear_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_78970 (h0 : topological_space (boolean_algebra.core (boolean_algebra name))) : totally_disconnected_space (boolean_algebra.core (boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_78971 (h1 : function.extfun Type ring) : @rank_condition.{0} (has_norm.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} h1 (has_norm.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_78972 (h0 : uniform_space (has_norm (random_gen (has_top (random_gen (random_gen num)))))) : complete_space (has_norm (random_gen (has_top (random_gen (random_gen num))))) := sorry --non-trivial
lemma new_lemma_78973 (h0 : functor.comp ring cancel_monoid name) : @rank_condition.{0} (cancel_monoid.{0} name) (@functor.comp.run.{0 0 0} ring.{0} cancel_monoid.{0} name h0)  := sorry --non-trivial
lemma new_lemma_78974 (h0 : fin has_zero.zero) : @rank_condition.{1} (comm_semigroup.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (comm_semigroup.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_78975 (h0 : function.extfun Type (functor.comp topological_space ring)) : @locally_compact_space.{0} (ring.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} ring.{0} ennreal (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} ring.{0}) h0 ennreal))  := sorry --non-trivial
lemma new_lemma_78976 (h0 : ring (left_cancel_semigroup congr_arg_kind)) : strong_rank_condition (left_cancel_semigroup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_78977 (h0 : functor.add_const (complete_lattice (add_comm_monoid pos)) Type) : @is_atomistic.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 1} (complete_lattice.{0} (add_comm_monoid.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_78978 (h0 : functor.add_const (topological_space auto.case_option) unsigned) : @preconnected_space.{0} auto.case_option (@functor.add_const.run.{0 0} (topological_space.{0} auto.case_option) unsigned h0)  := sorry --non-trivial
lemma new_lemma_78979 (h1 : has_mem.mem (measurable_space linarith.comp) has_emptyc.emptyc) : @locally_compact_space.{0} (measurable_space.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (measurable_space.{0} linarith.comp) h1)  := sorry --non-trivial
lemma new_lemma_78980 (h0 : topological_space (ring (has_add linarith.comp))) : path_connected_space (ring (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_78981 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @normal_space.{0} (has_Inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (has_Inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_78982 (h0 : topological_space (has_neg (comm_group (comm_group (comm_group (comm_group Type)))))) : sequential_space (has_neg (comm_group (comm_group (comm_group (comm_group Type))))) := sorry --non-trivial
lemma new_lemma_78983 (h0 : monoid (normed_comm_ring (has_top (semiring num)))) : monoid.fg (normed_comm_ring (has_top (semiring num))) := sorry --non-trivial
lemma new_lemma_78984 (h0 : functor.add_const (semiring (has_pos_part linarith.comp)) pos) : @is_noetherian_ring.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (semiring.{0} (has_pos_part.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_78985 (h0 : add_monoid (has_to_string Type)) : add_monoid.fg (has_to_string Type) := sorry --non-trivial
lemma new_lemma_78986 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (has_neg.{0} ennreal) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_neg.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_78987 (h0 : group (comm_group (option (option name)))) : normalizer_condition (comm_group (option (option name))) := sorry --non-trivial
lemma new_lemma_78988 (h1 : ring (normed_field string_imp)) : is_domain (normed_field string_imp) := sorry --non-trivial
lemma new_lemma_78989 (h0 : topological_space (has_dist (comm_monoid (comm_monoid (comm_monoid unsigned))))) : totally_separated_space (has_dist (comm_monoid (comm_monoid (comm_monoid unsigned)))) := sorry --non-trivial
lemma new_lemma_78990 (h1 : ring linarith.comp_source) : is_domain linarith.comp_source := sorry --non-trivial
lemma new_lemma_78991 (h0 : topological_space (ring unsigned)) : t1_space (ring unsigned) := sorry --non-trivial
lemma new_lemma_78992 (h0 : functor.add_const (ring (ordered_comm_ring linarith.comp)) linarith.comp) : @is_domain.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (ordered_comm_ring.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_78993 (h0 : functor.add_const (function.extfun Type add_group) Type) : @is_add_cyclic.{0} (finset.{0} name) (@function.extfun_app.{2 1} Type add_group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type add_group.{0}) Type h0) (finset.{0} name))  := sorry --non-trivial
lemma new_lemma_78994 (h0 : functor.add_const (function.extfun (Type 1) topological_space) Type) : @t0_space.{1} (ordered_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) Type h0) (ordered_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_78995 (h0 : functor.add_const (topological_space (boolean_algebra.core unsigned)) (option (option empty))) : @discrete_topology.{0} (boolean_algebra.core.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} unsigned)) (option.{0} (option.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_78996 (h2 : group (with_bot linarith.comp_source)) : normalizer_condition (with_bot linarith.comp_source) := sorry --non-trivial
lemma new_lemma_78997 (h0 : complete_lattice (with_one char)) : complete_lattice.is_Sup_finite_compact (with_one char) := sorry --non-trivial
lemma new_lemma_78998 (h1 : add_comm_semigroup ereal -> Prop) : is_total (add_comm_semigroup ereal) (fun (h0 : add_comm_semigroup ereal), h1) := sorry --non-trivial
lemma new_lemma_78999 (h0 : topological_space (finset (has_Inf (has_Inf pos)))) : loc_path_connected_space (finset (has_Inf (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_79000 (h0 : ereal -> ereal -> Prop) (h1 : ereal) : acc h0 h1 := sorry --non-trivial
lemma new_lemma_79001 (h0 : functor.add_const (ring (boolean_algebra.core environment.implicit_infer_kind)) pos) : @rank_condition.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_79002 (h0 : has_mem.mem (id linarith.ineq) has_emptyc.emptyc) : @t0_space.{0} (@id.{2} Type linarith.ineq) (@finset.pi.empty.{1 0} Type topological_space.{0} (@id.{2} Type linarith.ineq) h0)  := sorry --non-trivial
lemma new_lemma_79003 (h0 : functor.add_const (topological_space (add_cancel_monoid pos)) pos) : @t0_space.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_79004 (h0 : not (add_group (has_nnnorm reducibility_hints) -> false)) : @is_add_cyclic.{0} (has_nnnorm.{0} reducibility_hints) (@classical.by_contradiction'.{1} (add_group.{0} (has_nnnorm.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_79005 (h0 : ring (generalized_boolean_algebra (has_pos_part (ring pos)))) : strong_rank_condition (generalized_boolean_algebra (has_pos_part (ring pos))) := sorry --non-trivial
lemma new_lemma_79006 (h0 : function.extfun Type topological_space) : @normal_space.{0} (has_to_string.{0} (has_add.{0} ennreal)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} (has_add.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_79007 (h0 : topological_space (complete_distrib_lattice (option (option pos)))) : preconnected_space (complete_distrib_lattice (option (option pos))) := sorry --non-trivial
lemma new_lemma_79008 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (linear_ordered_comm_monoid_with_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_79009 (h1 : complete_lattice (random_gen linarith.comp_source)) : is_atomistic (random_gen linarith.comp_source) := sorry --non-trivial
lemma new_lemma_79010 (h0 : prod (ordered_ring (semiring empty)) (ordered_ring (semiring empty))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_79011 (h1 : measurable_space (mul_one_class (normed_field fun_info))) (h2 : filter (mul_one_class (normed_field fun_info))) : filter.is_measurably_generated h2 := sorry --non-trivial
lemma new_lemma_79012 (h0 : topological_space (simple_graph (ordered_comm_monoid (finset (has_add pos))))) : totally_separated_space (simple_graph (ordered_comm_monoid (finset (has_add pos)))) := sorry --non-trivial
lemma new_lemma_79013 (h0 : cancel_comm_monoid_with_zero (has_add (boolean_algebra.core (normed_comm_ring pos)))) : unique_factorization_monoid (has_add (boolean_algebra.core (normed_comm_ring pos))) := sorry --non-trivial
lemma new_lemma_79014 (h0 : functor.add_const (topological_space (has_to_string unsigned)) name) : @totally_separated_space.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_79015 (h0 : list (ordered_comm_monoid (has_Inf (has_Inf linarith.comp)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_79016 (h0 : complete_lattice (semiring unsigned)) : complete_lattice.is_Sup_finite_compact (semiring unsigned) := sorry --non-trivial
lemma new_lemma_79017 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (@id.{2} Type unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (@id.{2} Type unsigned))  := sorry --non-trivial
lemma new_lemma_79018 (h0 : function.extfun Type (functor.add_const (prod (ordered_ring empty) (ordered_ring empty)))) : id_rel (functor.add_const.run (function.extfun_app h0 unsigned)) := sorry --non-trivial
lemma new_lemma_79019 (h0 : function.extfun Type ring) : @rank_condition.{0} (semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_79020 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_bot.{0} real) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_bot.{0} real))  := sorry --non-trivial
lemma new_lemma_79021 (h0 : functor.add_const (ordered_add_comm_monoid (ordered_cancel_add_comm_monoid pos)) pos) : @archimedean.{0} (ordered_cancel_add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (ordered_cancel_add_comm_monoid.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_79022 (h0 : functor.add_const (ring (cancel_monoid ennreal)) congr_arg_kind) : @rank_condition.{0} (cancel_monoid.{0} ennreal) (@functor.add_const.run.{0 0} (ring.{0} (cancel_monoid.{0} ennreal)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_79023 (h0 : functor.add_const (add_group (has_zero linarith.comp)) linarith.comp) : @is_add_cyclic.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_group.{0} (has_zero.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_79024 (h0 : topological_space (ordered_comm_group unsigned)) : normal_space (ordered_comm_group unsigned) := sorry --non-trivial
lemma new_lemma_79025 (h0 : group (random_gen (has_inv (random_gen linarith.ineq)))) : is_cyclic (random_gen (has_inv (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_79026 (h0 : list (topological_space fun_info)) : @locally_compact_space.{0} fun_info (@list.head.{0} (topological_space.{0} fun_info) (@inhabited_topological_space.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_79027 (h0 : topological_space (has_norm (random_gen congr_arg_kind))) : t0_space (has_norm (random_gen congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_79028 (h0 : group (comm_ring (random_gen string_imp))) : is_cyclic (comm_ring (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_79029 (h0 : group (has_zero (has_add name))) : group.fg (has_zero (has_add name)) := sorry --non-trivial
lemma new_lemma_79030 (h0 : functor.add_const (topological_space (mul_zero_class name)) pos) : @totally_separated_space.{0} (mul_zero_class.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_79031 (h1 : ring (has_append (has_nnnorm (random_gen to_additive.value_type)))) : strong_rank_condition (has_append (has_nnnorm (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_79032 (h0 : not (group (has_nnnorm reducibility_hints) -> false)) : @is_cyclic.{0} (has_nnnorm.{0} reducibility_hints) (@classical.by_contradiction'.{1} (group.{0} (has_nnnorm.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_79033 (h0 : ring (mul_one_class (mul_one_class (mul_one_class enat)))) : strong_rank_condition (mul_one_class (mul_one_class (mul_one_class enat))) := sorry --non-trivial
lemma new_lemma_79034 (h0 : group linarith.ineq) : is_cyclic linarith.ineq := sorry --non-trivial
lemma new_lemma_79035 (h0 : ring (semigroup num)) : is_domain (semigroup num) := sorry --non-trivial
lemma new_lemma_79036 (h1 : topological_space (normed_field linarith.ineq)) (h2 : preorder (normed_field linarith.ineq)) : order_closed_topology (normed_field linarith.ineq) := sorry --non-trivial
lemma new_lemma_79037 (h0 : cancel_comm_monoid_with_zero (add_right_cancel_monoid (semiring (semiring unsigned)))) : unique_factorization_monoid (add_right_cancel_monoid (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_79038 (h0 : ring (has_Sup (semiring unsigned))) : rank_condition (has_Sup (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_79039 (h0 : functor.add_const (topological_space (has_add Type)) (has_neg pos)) : @sequential_space.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_add.{1} Type)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_79040 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_to_string.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_to_string.{0} num))  := sorry --non-trivial
lemma new_lemma_79041 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_79042 (h0 h1 : multiset (simple_graph (mul_one_class string.iterator_imp))) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_79043 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (semiring.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semiring.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_79044 (h0 : functor.add_const (function.extfun (Type 1) topological_space) name) : @normal_space.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) name h0) (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_79045 (h0 : functor.add_const (topological_space (semigroup name)) environment.implicit_infer_kind) : @preconnected_space.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_79046 (h0 : nat) (h1 : option nat) (h2 : group (plift (nat.min_sq_fac_prop h0 h1))) : normalizer_condition (plift (nat.min_sq_fac_prop h0 h1)) := sorry --non-trivial
lemma new_lemma_79047 (h0 : functor.add_const (add_group (finset linarith.comp)) pos) : @is_add_cyclic.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_group.{0} (finset.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_79048 (h0 : add_group (comm_monoid char)) : is_add_cyclic (comm_monoid char) := sorry --non-trivial
lemma new_lemma_79049 (h0 : not (uniform_space string_imp -> false)) : @complete_space.{0} string_imp (@classical.by_contradiction'.{1} (uniform_space.{0} string_imp) h0)  := sorry --non-trivial
lemma new_lemma_79050 (h0 : functor.add_const (filter (has_pos_part linarith.comp)) (has_pos_part (has_neg Type))) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_79051 (h0 : fin has_zero.zero) : @complete_space.{0} (boolean_algebra.{0} real) (@matrix.vec_empty.{0} (uniform_space.{0} (boolean_algebra.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_79052 (h0 : complete_lattice (encodable (has_inv to_additive.value_type))) : complete_lattice.is_Sup_finite_compact (encodable (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_79053 (h0 : group (has_neg_part (add_cancel_monoid (add_cancel_monoid (finset pos))))) : normalizer_condition (has_neg_part (add_cancel_monoid (add_cancel_monoid (finset pos)))) := sorry --non-trivial
lemma new_lemma_79054 (h0 : topological_space (add_comm_monoid (option congr_arg_kind))) : normal_space (add_comm_monoid (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_79055 (h0 : ordered_add_comm_monoid (ring name)) : archimedean (ring name) := sorry --non-trivial
lemma new_lemma_79056 (h0 : not (ring (has_emptyc linarith.comp_source) -> false)) : @rank_condition.{0} (has_emptyc.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (has_emptyc.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_79057 (h0 : linear_ordered_comm_monoid_with_zero empty -> linear_ordered_comm_monoid_with_zero empty -> Prop) : is_symm (linear_ordered_comm_monoid_with_zero empty) h0 := sorry --non-trivial
lemma new_lemma_79058 (h0 : list (linear_ordered_comm_ring unsigned)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_79059 (h0 : function.extfun (Type 1) topological_space) : @t0_space.{1} (has_zero.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_zero.{1} Type))  := sorry --non-trivial
lemma new_lemma_79060 (h0 : has_le ereal) (h1 : ereal) : is_min h1 := sorry --non-trivial
lemma new_lemma_79061 (h1 : topological_space (fintype to_additive.value_type)) : path_connected_space (fintype to_additive.value_type) := sorry --non-trivial
lemma new_lemma_79062 (h0 : functor.add_const (group (semigroup pos)) linarith.comp) : @normalizer_condition.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (semigroup.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_79063 (h0 : functor.add_const (semiring (add_comm_monoid name)) Type) : @is_noetherian_ring.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 1} (semiring.{0} (add_comm_monoid.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_79064 (h0 : functor.add_const (topological_space (ring (has_neg environment.implicit_infer_kind))) name) : @totally_separated_space.{0} (ring.{0} (has_neg.{0} environment.implicit_infer_kind)) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} (has_neg.{0} environment.implicit_infer_kind))) name h0)  := sorry --non-trivial
lemma new_lemma_79065 (h0 : topological_space (mul_zero_class unsigned)) : preirreducible_space (mul_zero_class unsigned) := sorry --non-trivial
lemma new_lemma_79066 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_79067 (h0 : topological_space (normed_comm_ring (ring (has_neg (has_nndist Type))))) : locally_compact_space (normed_comm_ring (ring (has_neg (has_nndist Type)))) := sorry --non-trivial
lemma new_lemma_79068 (h1 : topological_space (dlist (random_gen (with_one (with_one string_imp))))) : totally_disconnected_space (dlist (random_gen (with_one (with_one string_imp)))) := sorry --non-trivial
lemma new_lemma_79069 (h0 : uniform_space (measurable_space (semiring empty))) : complete_space (measurable_space (semiring empty)) := sorry --non-trivial
lemma new_lemma_79070 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (complete_distrib_lattice ennreal)) := sorry --non-trivial
lemma new_lemma_79071 (h0 : topological_space (boolean_algebra (comm_group unsigned))) : loc_path_connected_space (boolean_algebra (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_79072 (h0 : not (function.extfun Type monoid -> false)) : @monoid.fg.{0} (@id.{2} Type empty) (@function.extfun_app.{2 1} Type monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type monoid.{0}) h0) (@id.{2} Type empty))  := sorry --non-trivial
lemma new_lemma_79073 (h0 : not (has_mem.mem (with_bot (has_top linarith.ineq)) has_emptyc.emptyc -> false)) : @path_connected_space.{0} (with_bot.{0} (has_top.{0} linarith.ineq)) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_bot.{0} (has_top.{0} linarith.ineq)) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_bot.{0} (has_top.{0} linarith.ineq)) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_79074 (h0 : function.extfun Type group) : @is_cyclic.{0} (finset.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (finset.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_79075 (h0 : monoid (has_zero (add_cancel_monoid (has_neg name)))) : monoid.fg (has_zero (add_cancel_monoid (has_neg name))) := sorry --non-trivial
lemma new_lemma_79076 (h0 : topological_space (finset unsigned)) : topological_space.separable_space (finset unsigned) := sorry --non-trivial
lemma new_lemma_79077 (h0 : topological_space (ordered_comm_ring (has_neg linarith.comp))) : sequential_space (ordered_comm_ring (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_79078 (h0 : monoid (bin_tree (semiring unsigned))) : monoid.fg (bin_tree (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_79079 (h0 : complete_lattice (plift (semiring congr_arg_kind))) : complete_lattice.is_Sup_finite_compact (plift (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_79080 (h1 : char) (h3 : Prop) (h4 : char) : set.insert h1 (id (fun (h2 : char), h3)) h4 := sorry --non-trivial
lemma new_lemma_79081 (h0 : not (complete_lattice (comm_ring reducibility_hints) -> false)) : @is_compactly_generated.{0} (comm_ring.{0} reducibility_hints) (@classical.by_contradiction'.{1} (complete_lattice.{0} (comm_ring.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_79082 (h0 : fin has_zero.zero) : @normal_space.{1} (boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (boolean_algebra.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_79083 (h0 : uniform_space (distrib to_additive.value_type)) : complete_space (distrib to_additive.value_type) := sorry --non-trivial
lemma new_lemma_79084 (h0 : functor.add_const (cancel_comm_monoid_with_zero (free_add_monoid num)) empty) : @unique_factorization_monoid.{0} (free_add_monoid.{0} num) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (free_add_monoid.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_79085 (h0 : semiring (has_to_string (finset ennreal))) : is_noetherian_ring (has_to_string (finset ennreal)) := sorry --non-trivial
lemma new_lemma_79086 (h0 : functor.add_const (topological_space (comm_group name)) Type) : @locally_compact_space.{0} (comm_group.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (comm_group.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_79087 (h0 : monoid (id (has_top (has_top (semiring (semiring empty)))))) : monoid.fg (id (has_top (has_top (semiring (semiring empty))))) := sorry --non-trivial
lemma new_lemma_79088 (h0 : functor.add_const (filter pos) pos) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_79089 (h0 : uniform_space (fintype string_imp)) : complete_space (fintype string_imp) := sorry --non-trivial
lemma new_lemma_79090 (h0 : topological_space (has_bot (option (option (option (option (option (option empty)))))))) : totally_disconnected_space (has_bot (option (option (option (option (option (option empty))))))) := sorry --non-trivial
lemma new_lemma_79091 (h1 : not (ring (random_gen reducibility_hints) -> false)) : @rank_condition.{0} (random_gen.{0} reducibility_hints) (@classical.by_contradiction'.{1} (ring.{0} (random_gen.{0} reducibility_hints)) h1)  := sorry --non-trivial
lemma new_lemma_79092 (h0 : complete_lattice (left_cancel_monoid empty)) : is_atomistic (left_cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_79093 (h0 : functor.add_const (topological_space (non_assoc_semiring unsigned)) congr_arg_kind) : @t1_space.{0} (non_assoc_semiring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (non_assoc_semiring.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_79094 (h1 : complete_lattice linarith.ineq) : is_compactly_generated linarith.ineq := sorry --non-trivial
lemma new_lemma_79095 (h0 : topological_space (has_lt (has_neg fun_info))) : path_connected_space (has_lt (has_neg fun_info)) := sorry --non-trivial
lemma new_lemma_79096 (h0 : add_comm_semigroup char -> add_comm_semigroup char -> Prop) (h2 : add_comm_semigroup char) : set.finite (eqv_gen h0 h2) := sorry --non-trivial
lemma new_lemma_79097 (h0 : topological_space (canonically_ordered_comm_semiring unsigned)) : loc_path_connected_space (canonically_ordered_comm_semiring unsigned) := sorry --non-trivial
lemma new_lemma_79098 (h0 : cancel_comm_monoid_with_zero (comm_semigroup (has_pos_part (has_add (sub_neg_monoid real))))) : unique_factorization_monoid (comm_semigroup (has_pos_part (has_add (sub_neg_monoid real)))) := sorry --non-trivial
lemma new_lemma_79099 (h0 : finset (is_R_or_C (option empty))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_79100 (h0 : uniform_space (cancel_monoid num)) : separated_space (cancel_monoid num) := sorry --non-trivial
lemma new_lemma_79101 (h0 : topological_space (semigroup (cancel_monoid unsigned))) : preirreducible_space (semigroup (cancel_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_79102 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (has_to_string.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_to_string.{0} name))  := sorry --non-trivial
lemma new_lemma_79103 (h0 : functor.add_const (finset (comm_monoid empty)) empty) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_79104 (h0 : functor.add_const (finset (add_comm_monoid unsigned)) unsigned) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_79105 (h0 : functor.add_const (semiring (add_comm_monoid environment.implicit_infer_kind)) name) : @is_noetherian_ring.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (semiring.{0} (add_comm_monoid.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_79106 (h0 : topological_space (has_compl (has_nnnorm fun_info))) : path_connected_space (has_compl (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_79107 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (canonically_ordered_add_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_add_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_79108 (h0 : has_lt real) : no_max_order real := sorry --non-trivial
lemma new_lemma_79109 (h0 : topological_space (measurable_space.dynkin_system (semiring (semiring (semiring linarith.comp))))) : path_connected_space (measurable_space.dynkin_system (semiring (semiring (semiring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_79110 (h5 : has_lt (dlist to_additive.value_type)) : no_max_order (dlist to_additive.value_type) := sorry --non-trivial
lemma new_lemma_79111 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (add_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (add_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_79112 (h0 : ring (has_lt (mul_one_class (has_lt linarith.comp_source)))) : is_domain (has_lt (mul_one_class (has_lt linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_79113 (h0 : preorder enat) (h2 : Prop) : set.is_pwo (id (fun (h1 : enat), h2)) := sorry --non-trivial
lemma new_lemma_79114 (h0 : fin has_zero.zero) : @totally_disconnected_space.{1} (simple_graph.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (simple_graph.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_79115 (h0 : add_monoid (semiring (semiring congr_arg_kind))) : add_monoid.fg (semiring (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_79116 (h1 : semiring fun_info) (h2 : fun_info) : even h2 := sorry --non-trivial
lemma new_lemma_79117 (h0 : topological_space (comm_monoid (semiring (semiring (semiring empty))))) : loc_path_connected_space (comm_monoid (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_79118 (h0 : functor.add_const (ring (boolean_algebra.core environment.implicit_infer_kind)) Type) : @rank_condition.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (ring.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_79119 (h0 : fin has_zero.zero) : @separated_space.{0} (canonically_linear_ordered_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (uniform_space.{0} (canonically_linear_ordered_monoid.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_79120 (h0 : add_group (has_neg_part (option (ring (option (option (option unsigned))))))) : is_add_cyclic (has_neg_part (option (ring (option (option (option unsigned)))))) := sorry --non-trivial
lemma new_lemma_79121 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (has_union.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_union.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_79122 (h0 : topological_space (ring (option congr_arg_kind))) : normal_space (ring (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_79123 (h0 : functor.add_const (topological_space (add_comm_monoid name)) pos) : @t0_space.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_79124 (h0 : topological_space (ordered_comm_ring (boolean_algebra.core linarith.comp))) : normal_space (ordered_comm_ring (boolean_algebra.core linarith.comp)) := sorry --non-trivial
lemma new_lemma_79125 (h0 : functor.add_const (group (has_to_string name)) unsigned) : @is_simple_group.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (group.{0} (has_to_string.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_79126 (h0 : list (generalized_boolean_algebra (has_pos_part pos))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_79127 (h0 : uniform_space (has_top linarith.ineq)) : complete_space (has_top linarith.ineq) := sorry --non-trivial
lemma new_lemma_79128 (h0 : functor.add_const (add_group (has_neg_part linarith.comp)) environment.implicit_infer_kind) : @is_add_cyclic.{0} (has_neg_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_group.{0} (has_neg_part.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_79129 (h0 : functor.add_const (topological_space (has_Inf Type)) name) : @discrete_topology.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_Inf.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_79130 (h0 : topological_space (measure_theory.measure_space num)) : normal_space (measure_theory.measure_space num) := sorry --non-trivial
lemma new_lemma_79131 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @regular_space.{0} (finset.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (finset.{0} real))  := sorry --non-trivial
lemma new_lemma_79132 (h0 : list Prop -> Prop) : list.tfae (classical.epsilon h0) := sorry --non-trivial
lemma new_lemma_79133 (h0 : topological_space (ring unsigned)) : irreducible_space (ring unsigned) := sorry --non-trivial
lemma new_lemma_79134 (h0 : topological_space (add_cancel_monoid (normed_comm_ring Type))) : topological_space.separable_space (add_cancel_monoid (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_79135 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_simple_group.{0} (add_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (add_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_79136 (h0 : topological_space (ordered_comm_ring (has_neg (has_neg (ring Type))))) : sequential_space (ordered_comm_ring (has_neg (has_neg (ring Type)))) := sorry --non-trivial
lemma new_lemma_79137 (h1 : topological_space (mul_one_class (normed_field char))) : t0_space (mul_one_class (normed_field char)) := sorry --non-trivial
lemma new_lemma_79138 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} (has_norm.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (has_norm.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_79139 (h0 : function.extfun Type ring) : @is_domain.{0} (simple_graph.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (simple_graph.{0} name))  := sorry --non-trivial
lemma new_lemma_79140 (h0 : group (canonically_ordered_comm_semiring (comm_group unsigned))) : is_simple_group (canonically_ordered_comm_semiring (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_79141 (h0 : list (encodable linarith.ineq)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_79142 (h0 : ring (has_div (mul_one_class char))) : is_domain (has_div (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_79143 (h0 : topological_space (encodable (has_nnnorm (has_nnnorm linarith.comp_source)))) : totally_disconnected_space (encodable (has_nnnorm (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_79144 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @preconnected_space.{0} (ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_79145 (h0 : list (has_neg (has_neg linarith.comp))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_79146 (h0 : filter (random_gen unsigned)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_79147 (h0 : function.extfun Type topological_space) : @t1_space.{0} (pseudo_metric_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (pseudo_metric_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_79148 (h0 : topological_space (has_neg (comm_group Type))) : irreducible_space (has_neg (comm_group Type)) := sorry --non-trivial
lemma new_lemma_79149 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_union.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_union.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_79150 (h0 : ring (cancel_monoid linarith.comp)) : rank_condition (cancel_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_79151 (h0 : ring (has_le char)) : strong_rank_condition (has_le char) := sorry --non-trivial
lemma new_lemma_79152 (h1 h2 : multiset (nondiscrete_normed_field reducibility_hints)) : multiset.subset h1 h2 := sorry --non-trivial
lemma new_lemma_79153 (h0 : not (uniform_space (has_inv linarith.ineq) -> false)) : @complete_space.{0} (has_inv.{0} linarith.ineq) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_inv.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_79154 (h0 : topological_space (bin_tree (semiring congr_arg_kind))) : t0_space (bin_tree (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_79155 (h0 : topological_space (ring (ring (has_add (has_pos_part linarith.comp))))) : loc_path_connected_space (ring (ring (has_add (has_pos_part linarith.comp)))) := sorry --non-trivial
lemma new_lemma_79156 (h0 : topological_space (canonically_linear_ordered_monoid linarith.comp)) : t1_space (canonically_linear_ordered_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_79157 (h1 : ring (fintype (fintype linarith.comp_source))) : strong_rank_condition (fintype (fintype linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_79158 (h0 : ring (has_add (has_neg name))) : is_domain (has_add (has_neg name)) := sorry --non-trivial
lemma new_lemma_79159 (h0 : ring (ordered_comm_monoid (has_add (has_pos_part pos)))) : strong_rank_condition (ordered_comm_monoid (has_add (has_pos_part pos))) := sorry --non-trivial
lemma new_lemma_79160 (h0 : function.extfun nat fin) : @rank_condition.{1} (generalized_boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (generalized_boolean_algebra.{1} Type)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))))  := sorry --non-trivial
lemma new_lemma_79161 (h0 : functor.comp semiring has_zero Type) : @is_noetherian_ring.{1} (has_zero.{1} Type) (@functor.comp.run.{1 1 1} semiring.{1} has_zero.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_79162 (h0 : has_lift ereal Prop) (h1 : ereal) : @lift.{1 1} ereal Prop h0 h1  := sorry --non-trivial
lemma new_lemma_79163 (h0 : functor.add_const (topological_space pos) name) : @path_connected_space.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) name h0)  := sorry --non-trivial
lemma new_lemma_79164 (h0 : functor.add_const (topological_space (has_bot name)) name) : @regular_space.{0} (has_bot.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_bot.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_79165 (h0 : topological_space (has_emptyc (random_gen congr_arg_kind))) : t0_space (has_emptyc (random_gen congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_79166 (h0 : function.extfun nat fin) : @archimedean.{0} (generalized_boolean_algebra.{0} real) (@matrix.vec_empty.{0} (ordered_add_comm_monoid.{0} (generalized_boolean_algebra.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_79167 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @topological_space.separable_space.{0} (has_Inf.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (has_Inf.{0} pos)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_79168 (h0 : topological_space (distrib_lattice (has_inv (random_gen linarith.ineq)))) : locally_compact_space (distrib_lattice (has_inv (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_79169 (h0 : topological_space (measurable_space to_additive.value_type)) : irreducible_space (measurable_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_79170 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (has_bot.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_bot.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_79171 (h1 : measurable_space (nondiscrete_normed_field linarith.ineq)) (h2 : filter (nondiscrete_normed_field linarith.ineq)) : filter.is_measurably_generated h2 := sorry --non-trivial
lemma new_lemma_79172 (h0 : measurable_space (add_group num)) (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @has_measurable_div₂.{0} (add_group.{0} num) h0 (@function.extfun_app.{2 1} Type has_div.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 has_div.{0}) (add_group.{0} num))  := sorry --non-trivial
lemma new_lemma_79173 (h0 : uniform_space (has_nnnorm (has_lt (normed_field (denumerable (has_nnnorm linarith.comp_source)))))) : complete_space (has_nnnorm (has_lt (normed_field (denumerable (has_nnnorm linarith.comp_source))))) := sorry --non-trivial
lemma new_lemma_79174 (h0 : ring (measurable_space empty)) : strong_rank_condition (measurable_space empty) := sorry --non-trivial
lemma new_lemma_79175 (h0 : ring (has_to_string (has_to_string (has_to_string pos)))) : is_principal_ideal_ring (has_to_string (has_to_string (has_to_string pos))) := sorry --non-trivial
lemma new_lemma_79176 (h0 : functor.add_const (complete_lattice (has_to_string environment.implicit_infer_kind)) pos) : @is_compactly_generated.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_to_string.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_79177 (h0 : functor.add_const (topological_space (boolean_algebra.core name)) environment.implicit_infer_kind) : @preconnected_space.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_79178 (h0 : complete_lattice (add_comm_semigroup (add_comm_semigroup string.iterator_imp))) : complete_lattice.is_Sup_finite_compact (add_comm_semigroup (add_comm_semigroup string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_79179 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (partial_order.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (partial_order.{0} num))  := sorry --non-trivial
lemma new_lemma_79180 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (has_to_string ennreal)) := sorry --non-trivial
lemma new_lemma_79181 (h0 : functor.add_const (complete_lattice (has_zero pos)) Type) : @complete_lattice.is_Sup_finite_compact.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 1} (complete_lattice.{0} (has_zero.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_79182 (h0 : functor.add_const (ordered_comm_monoid (has_to_string name)) linarith.comp) : @has_exists_mul_of_le.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_to_string.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_79183 (h0 : ring (distrib (mul_one_class (mul_one_class string.iterator_imp)))) : strong_rank_condition (distrib (mul_one_class (mul_one_class string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_79184 (h1 : set (enat -> mul_one_class char)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_79185 (h2 : ring linarith.ineq) : is_field linarith.ineq := sorry --non-trivial
lemma new_lemma_79186 (h0 : functor.add_const (ordered_add_comm_monoid (normed_comm_ring Type)) (ring pos)) : @archimedean.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (ordered_add_comm_monoid.{1} (normed_comm_ring.{1} Type)) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_79187 (h0 : monoid (has_star (option (option unsigned)))) : monoid.fg (has_star (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_79188 (h0 : topological_space (has_Sup congr_arg_kind)) : preirreducible_space (has_Sup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_79189 (h0 : uniform_space (preorder (option (option (option (option empty)))))) : separated_space (preorder (option (option (option (option empty))))) := sorry --non-trivial
lemma new_lemma_79190 (h0 : functor.add_const (group (add_cancel_monoid name)) (cancel_monoid name)) : @is_simple_group.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (group.{0} (add_cancel_monoid.{0} name)) (cancel_monoid.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_79191 (h0 : ordered_add_comm_monoid (has_bot (has_add pos))) : archimedean (has_bot (has_add pos)) := sorry --non-trivial
lemma new_lemma_79192 (h0 : semiring (has_nndist (has_to_string name))) : is_noetherian_ring (has_nndist (has_to_string name)) := sorry --non-trivial
lemma new_lemma_79193 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (add_cancel_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (add_cancel_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_79194 (h0 : list (has_ssubset fun_info)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_79195 (h0 : topological_space (cancel_monoid linarith.comp)) : t1_space (cancel_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_79196 (h0 : cancel_comm_monoid_with_zero (canonically_ordered_comm_semiring (has_neg pos))) : unique_factorization_monoid (canonically_ordered_comm_semiring (has_neg pos)) := sorry --non-trivial
lemma new_lemma_79197 (h0 : complete_lattice (comm_group (option (option ennreal)))) : complete_lattice.is_Sup_finite_compact (comm_group (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_79198 (h0 : group (semigroup (option pos))) : normalizer_condition (semigroup (option pos)) := sorry --non-trivial
lemma new_lemma_79199 (h0 : ring (linear_ordered_comm_group_with_zero (mul_one_class environment.projection_info))) : rank_condition (linear_ordered_comm_group_with_zero (mul_one_class environment.projection_info)) := sorry --non-trivial
lemma new_lemma_79200 (h0 : ring (ordered_cancel_add_comm_monoid (option (option unsigned)))) : rank_condition (ordered_cancel_add_comm_monoid (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_79201 (h0 : fin has_zero.zero) : @is_noetherian_ring.{0} (comm_semigroup.{0} real) (@matrix.vec_empty.{0} (semiring.{0} (comm_semigroup.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_79202 (h0 : topological_space (mul_zero_class (finset (finset environment.implicit_infer_kind)))) : topological_space.separable_space (mul_zero_class (finset (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_79203 (h0 : ring (has_inter (option (option (option empty))))) : is_principal_ideal_ring (has_inter (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_79204 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (normed_lattice_add_comm_group.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_lattice_add_comm_group.{0} name))  := sorry --non-trivial
lemma new_lemma_79205 (h0 : ordered_add_comm_monoid (normed_lattice_add_comm_group (sub_neg_monoid real))) : archimedean (normed_lattice_add_comm_group (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_79206 (h0 : cancel_comm_monoid_with_zero (normed_comm_ring (has_add environment.implicit_infer_kind))) : unique_factorization_monoid (normed_comm_ring (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_79207 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (add_group.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (add_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_79208 (h0 : list (measurable_space congr_arg_kind)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_79209 (h0 : finset (canonically_ordered_monoid (has_add (has_Inf Type)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_79210 (h1 h2 : multiset fun_info) : multiset.disjoint h1 h2 := sorry --non-trivial
lemma new_lemma_79211 (h0 : cancel_comm_monoid_with_zero (finset (finset (finset Type)))) : unique_factorization_monoid (finset (finset (finset Type))) := sorry --non-trivial
lemma new_lemma_79212 (h0 : functor.add_const (topological_space (has_zero environment.implicit_infer_kind)) Type) : @totally_disconnected_space.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (has_zero.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_79213 (h0 : not (add_group (ordered_comm_monoid to_additive.value_type) -> false)) : @is_add_cyclic.{0} (ordered_comm_monoid.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (add_group.{0} (ordered_comm_monoid.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_79214 (h0 : set (add_comm_semigroup (add_comm_semigroup linarith.ineq) -> fun_info)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_79215 (h1 : topological_space (has_add fun_info)) : totally_disconnected_space (has_add fun_info) := sorry --non-trivial
lemma new_lemma_79216 (h0 : topological_space (has_bot (has_Inf pos))) : t1_space (has_bot (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_79217 (h0 : functor.add_const (functor.add_const (ring nnreal) congr_arg_kind) congr_arg_kind) : @is_domain.{0} nnreal (@functor.add_const.run.{0 0} (ring.{0} nnreal) congr_arg_kind (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (ring.{0} nnreal) congr_arg_kind) congr_arg_kind h0))  := sorry --non-trivial
lemma new_lemma_79218 (h0 : topological_space (normed_group empty)) : preirreducible_space (normed_group empty) := sorry --non-trivial
lemma new_lemma_79219 (h1 : has_mem.mem (id linarith.comp) has_emptyc.emptyc) : @separated_space.{0} (@id.{2} Type linarith.comp) (@finset.pi.empty.{1 0} Type uniform_space.{0} (@id.{2} Type linarith.comp) h1)  := sorry --non-trivial
lemma new_lemma_79220 (h0 : group (has_nndist (option ennreal))) : normalizer_condition (has_nndist (option ennreal)) := sorry --non-trivial
lemma new_lemma_79221 (h0 : topological_space (bin_tree (semiring (semiring num)))) : normal_space (bin_tree (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_79222 (h0 : add_monoid (plift (option unsigned))) : add_monoid.fg (plift (option unsigned)) := sorry --non-trivial
lemma new_lemma_79223 (h0 : complete_lattice (has_emptyc (has_norm (has_norm linarith.ineq)))) : is_compactly_generated (has_emptyc (has_norm (has_norm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_79224 (h0 : has_neg (add_comm_semigroup (normed_field std_gen))) (h1 : measurable_space (add_comm_semigroup (normed_field std_gen))) : has_measurable_neg (add_comm_semigroup (normed_field std_gen)) := sorry --non-trivial
lemma new_lemma_79225 (h0 : complete_lattice (semigroup (has_add (has_add Type)))) : is_compactly_generated (semigroup (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_79226 (h0 : functor.add_const (topological_space (simple_graph linarith.comp)) Type) : @totally_disconnected_space.{0} (simple_graph.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (simple_graph.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_79227 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (canonically_linear_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_linear_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_79228 (h0 : topological_space (comm_semigroup (has_Inf (has_pos_part (has_add (has_pos_part pos)))))) : discrete_topology (comm_semigroup (has_Inf (has_pos_part (has_add (has_pos_part pos))))) := sorry --non-trivial
lemma new_lemma_79229 (h0 : ring (normed_lattice_add_comm_group congr_arg_kind)) : rank_condition (normed_lattice_add_comm_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_79230 (h0 : topological_space (complete_distrib_lattice (finset name))) : path_connected_space (complete_distrib_lattice (finset name)) := sorry --non-trivial
lemma new_lemma_79231 (h0 : topological_space (normed_comm_ring (comm_group (comm_group name)))) : preirreducible_space (normed_comm_ring (comm_group (comm_group name))) := sorry --non-trivial
lemma new_lemma_79232 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (cancel_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_79233 (h0 : functor.add_const (ordered_add_comm_monoid (add_cancel_monoid Type)) pos) : @archimedean.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (ordered_add_comm_monoid.{1} (add_cancel_monoid.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_79234 (h0 : topological_space (canonically_linear_ordered_monoid (option unsigned))) : preirreducible_space (canonically_linear_ordered_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_79235 (h0 : filter (complete_distrib_lattice environment.implicit_infer_kind)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_79236 (h0 : ordered_add_comm_monoid Type) : archimedean Type := sorry --non-trivial
lemma new_lemma_79237 (h0 : functor.add_const (ring (semiring congr_arg_kind)) num) : @strong_rank_condition.{0} (semiring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ring.{0} (semiring.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_79238 (h0 : topological_space (semiring (random_gen linarith.comp_source))) : totally_separated_space (semiring (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_79239 (h0 : ring (cancel_monoid environment.implicit_infer_kind)) : strong_rank_condition (cancel_monoid environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_79240 (h0 : complete_lattice (ordered_comm_monoid (has_add real))) : is_compactly_generated (ordered_comm_monoid (has_add real)) := sorry --non-trivial
lemma new_lemma_79241 (h0 : functor.add_const (list (add_comm_monoid Type)) Type) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_79242 (h0 : functor.add_const Prop (ring (option ennreal))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_79243 (h0 : ring (has_to_string (has_to_string linarith.comp))) : strong_rank_condition (has_to_string (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_79244 (h0 : functor.add_const (function.extfun (Type 1) topological_space) (has_add Type)) : @preconnected_space.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) (has_add.{1} Type) h0) (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_79245 (h0 : function.extfun Type (functor.add_const (filter (ordered_comm_group unsigned)))) : filter.ne_bot (functor.add_const.run (function.extfun_app h0 empty)) := sorry --non-trivial
lemma new_lemma_79246 (h0 : ring (semigroup (comm_group (has_add (comm_group (comm_group Type)))))) : rank_condition (semigroup (comm_group (has_add (comm_group (comm_group Type))))) := sorry --non-trivial
lemma new_lemma_79247 (h0 : ring (has_top (has_norm (has_norm string_imp)))) : is_domain (has_top (has_norm (has_norm string_imp))) := sorry --non-trivial
lemma new_lemma_79248 (h1 : comm_semiring (denumerable linarith.comp_source)) (h2 : polynomial (denumerable linarith.comp_source)) : polynomial.is_primitive h2 := sorry --non-trivial
lemma new_lemma_79249 (h0 : functor.add_const (topological_space (has_add linarith.comp)) (has_neg (has_neg (has_add name)))) : @preconnected_space.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} linarith.comp)) (has_neg.{0} (has_neg.{0} (has_add.{0} name))) h0)  := sorry --non-trivial
lemma new_lemma_79250 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (measurable_space.dynkin_system.{0} (semiring.{0} congr_arg_kind)) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (measurable_space.dynkin_system.{0} (semiring.{0} congr_arg_kind)))  := sorry --non-trivial
lemma new_lemma_79251 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (complete_distrib_lattice.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (complete_distrib_lattice.{0} pos))  := sorry --non-trivial
lemma new_lemma_79252 (h0 : functor.add_const (topological_space (semigroup num)) empty) : @discrete_topology.{0} (semigroup.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_79253 (h0 : topological_space (canonically_ordered_comm_semiring environment.implicit_infer_kind)) : discrete_topology (canonically_ordered_comm_semiring environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_79254 (h0 : complete_lattice (linear_order (option (option unsigned)))) : is_atomistic (linear_order (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_79255 (h0 : functor.add_const (ring (generalized_boolean_algebra pos)) pos) : @is_domain.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (generalized_boolean_algebra.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_79256 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (random_gen.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (random_gen.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_79257 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (cancel_monoid environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_79258 (h0 : has_lt (nondiscrete_normed_field string.iterator_imp)) : no_max_order (nondiscrete_normed_field string.iterator_imp) := sorry --non-trivial
lemma new_lemma_79259 (h0 : functor.add_const (topological_space (has_edist congr_arg_kind)) unsigned) : @preirreducible_space.{0} (has_edist.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_edist.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_79260 (h0 : not (topological_space (has_one linarith.comp) -> false)) : @t0_space.{0} (has_one.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (has_one.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_79261 (h0 : complete_lattice (has_Sup (option unsigned))) : is_atomistic (has_Sup (option unsigned)) := sorry --non-trivial
lemma new_lemma_79262 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (add_group.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_79263 (h0 : group (ordered_comm_ring (ring (has_nndist (ring (boolean_algebra.core linarith.comp)))))) : is_cyclic (ordered_comm_ring (ring (has_nndist (ring (boolean_algebra.core linarith.comp))))) := sorry --non-trivial
lemma new_lemma_79264 (h0 : functor.add_const (cancel_comm_monoid_with_zero (mul_zero_class num)) empty) : @unique_factorization_monoid.{0} (mul_zero_class.{0} num) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (mul_zero_class.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_79265 (h0 : functor.add_const (ring (comm_monoid empty)) empty) : @is_domain.{0} (comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (comm_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_79266 (h0 : uniform_space (has_norm (has_norm empty))) : complete_space (has_norm (has_norm empty)) := sorry --non-trivial
lemma new_lemma_79267 (h0 : topological_space (has_neg (has_add pos))) : irreducible_space (has_neg (has_add pos)) := sorry --non-trivial
lemma new_lemma_79268 (h0 : function.extfun Type topological_space) : @regular_space.{0} (linear_ordered_field.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_field.{0} pos))  := sorry --non-trivial
lemma new_lemma_79269 (h0 : monoid (semiring (random_gen (random_gen (random_gen linarith.comp_source))))) : monoid.fg (semiring (random_gen (random_gen (random_gen linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_79270 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} auto.case_option (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 auto.case_option)  := sorry --non-trivial
lemma new_lemma_79271 (h0 : functor.add_const (complete_lattice (boolean_algebra.core name)) name) : @complete_lattice.is_Sup_finite_compact.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (boolean_algebra.core.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_79272 (h1 : group (complete_semilattice_Sup linarith.comp)) : normalizer_condition (complete_semilattice_Sup linarith.comp) := sorry --non-trivial
lemma new_lemma_79273 (h0 : function.extfun Type ring) : @rank_condition.{0} (pseudo_metric_space.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} h0 (pseudo_metric_space.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_79274 (h0 : functor.add_const (topological_space (boolean_algebra Type)) (boolean_algebra pos)) : @irreducible_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.{1} Type)) (boolean_algebra.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_79275 (h0 : functor.add_const (topological_space (normed_comm_ring pos)) Type) : @totally_separated_space.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (normed_comm_ring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_79276 (h0 : group (random_gen fun_info)) : group.fg (random_gen fun_info) := sorry --non-trivial
lemma new_lemma_79277 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (boolean_algebra.core.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (boolean_algebra.core.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_79278 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (has_add.{0} real) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_add.{0} real))  := sorry --non-trivial
lemma new_lemma_79279 (h0 : uniform_space (add_comm_monoid (has_add (add_comm_monoid Type)))) : complete_space (add_comm_monoid (has_add (add_comm_monoid Type))) := sorry --non-trivial
lemma new_lemma_79280 (h0 : topological_space (id fun_info)) : irreducible_space (id fun_info) := sorry --non-trivial
lemma new_lemma_79281 (h0 : add_group (finset Type)) : is_add_cyclic (finset Type) := sorry --non-trivial
lemma new_lemma_79282 (h2 : ring (topological_space char)) : rank_condition (topological_space char) := sorry --non-trivial
lemma new_lemma_79283 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (has_neg.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_neg.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_79284 (h0 : set (enat -> linarith.ineq)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_79285 (h1 : topological_space (metric_space to_additive.value_type)) : totally_disconnected_space (metric_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_79286 (h0 : not (has_mem.mem (semiring fun_info) has_emptyc.emptyc -> false)) : @is_add_cyclic.{0} (semiring.{0} fun_info) (@finset.pi.empty.{1 0} Type add_group.{0} (semiring.{0} fun_info) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} fun_info) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_79287 (h0 : function.extfun Type ring) : @rank_condition.{0} (is_R_or_C.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (is_R_or_C.{0} num))  := sorry --non-trivial
lemma new_lemma_79288 (h0 : uniform_space (has_Inf (finset (has_nndist linarith.comp)))) : complete_space (has_Inf (finset (has_nndist linarith.comp))) := sorry --non-trivial
lemma new_lemma_79289 (h0 : topological_space (filter num)) : totally_separated_space (filter num) := sorry --non-trivial
lemma new_lemma_79290 (h0 : uniform_space (has_nndist (mul_zero_class (mul_zero_class pos)))) : complete_space (has_nndist (mul_zero_class (mul_zero_class pos))) := sorry --non-trivial
lemma new_lemma_79291 (h1 : ring (comm_ring (has_ssubset char))) : rank_condition (comm_ring (has_ssubset char)) := sorry --non-trivial
lemma new_lemma_79292 (h0 : functor.add_const (topological_space (free_add_monoid num)) (semiring (semiring num))) : @totally_disconnected_space.{0} (free_add_monoid.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} num)) (semiring.{0} (semiring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_79293 (h0 : uniform_space (add_comm_monoid (has_add name))) : complete_space (add_comm_monoid (has_add name)) := sorry --non-trivial
lemma new_lemma_79294 (h0 : not (topological_space (has_ssubset linarith.comp_source) -> false)) : @totally_disconnected_space.{0} (has_ssubset.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (has_ssubset.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_79295 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_79296 (h0 : topological_space (comm_semigroup (has_Inf linarith.comp))) : locally_compact_space (comm_semigroup (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_79297 (h0 : functor.add_const (ring (ordered_comm_ring linarith.comp)) linarith.comp) : @is_principal_ideal_ring.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (ordered_comm_ring.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_79298 (h0 : ring (mul_zero_class pos)) : is_principal_ideal_ring (mul_zero_class pos) := sorry --non-trivial
lemma new_lemma_79299 (h0 : topological_space (has_sub (semiring num))) : irreducible_space (has_sub (semiring num)) := sorry --non-trivial
lemma new_lemma_79300 (h0 : functor.add_const (semiring (complete_distrib_lattice pos)) pos) : @is_noetherian_ring.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (semiring.{0} (complete_distrib_lattice.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_79301 (h0 : group (boolean_algebra (boolean_algebra.core Type))) : is_cyclic (boolean_algebra (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_79302 (h0 : topological_space (pseudo_metric_space (option (cancel_monoid name)))) : discrete_topology (pseudo_metric_space (option (cancel_monoid name))) := sorry --non-trivial
lemma new_lemma_79303 (h0 : fin has_zero.zero) : @complete_space.{0} (add_comm_monoid.{0} pos) (@matrix.vec_empty.{0} (uniform_space.{0} (add_comm_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_79304 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @has_exists_mul_of_le.{0} (cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) ordered_comm_monoid.{0}) (cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_79305 (h0 : functor.add_const (topological_space (mul_zero_class ennreal)) pos) : @topological_space.separable_space.{0} (mul_zero_class.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} ennreal)) pos h0)  := sorry --non-trivial
lemma new_lemma_79306 (h0 : functor.add_const (function.extfun (Type 1) finset) linarith.comp) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (ordered_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_79307 (h0 : complete_lattice (dlist (random_gen (random_gen (random_gen (random_gen string_imp)))))) : is_atomistic (dlist (random_gen (random_gen (random_gen (random_gen string_imp))))) := sorry --non-trivial
lemma new_lemma_79308 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (has_dist num)) := sorry --non-trivial
lemma new_lemma_79309 (h0 : complete_lattice (has_zero (has_neg environment.implicit_infer_kind))) : complete_lattice.is_Sup_finite_compact (has_zero (has_neg environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_79310 (h0 : topological_space (add_comm_semigroup (mul_one_class enat))) : path_connected_space (add_comm_semigroup (mul_one_class enat)) := sorry --non-trivial
lemma new_lemma_79311 (h0 : ordered_comm_monoid (canonically_ordered_comm_semiring (ring linarith.comp))) : has_exists_mul_of_le (canonically_ordered_comm_semiring (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_79312 (h0 : group (normed_group (has_inv to_additive.value_type))) : normalizer_condition (normed_group (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_79313 (h0 : topological_space (canonically_ordered_comm_semiring (has_add environment.implicit_infer_kind))) : irreducible_space (canonically_ordered_comm_semiring (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_79314 (h0 : uniform_space (has_lt fun_info)) : complete_space (has_lt fun_info) := sorry --non-trivial
lemma new_lemma_79315 (h0 : topological_space (has_zero ennreal)) : totally_separated_space (has_zero ennreal) := sorry --non-trivial
lemma new_lemma_79316 (h0 : add_group (has_norm (random_gen fun_info))) : is_add_cyclic (has_norm (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_79317 (h0 : topological_space (has_top (has_norm (random_gen num)))) : totally_separated_space (has_top (has_norm (random_gen num))) := sorry --non-trivial
lemma new_lemma_79318 (h0 : functor.add_const (ring (omega_complete_partial_order unsigned)) unsigned) : @is_domain.{0} (omega_complete_partial_order.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (omega_complete_partial_order.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_79319 (h0 : group (topological_space (random_gen (has_nnnorm char)))) : is_cyclic (topological_space (random_gen (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_79320 (h0 : not (complete_lattice (bin_tree unsigned) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (bin_tree.{0} unsigned) (@classical.by_contradiction'.{1} (complete_lattice.{0} (bin_tree.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_79321 (h0 : cancel_monoid (has_add ennreal) -> cancel_monoid (has_add ennreal) -> Prop) : reflexive h0 := sorry --non-trivial
lemma new_lemma_79322 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_neg.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_79323 (h0 : not (function.extfun Type topological_space -> false)) : @irreducible_space.{0} (@id.{2} Type unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (@id.{2} Type unsigned))  := sorry --non-trivial
lemma new_lemma_79324 (h0 : complete_lattice (ordered_ring (option empty))) : is_atomistic (ordered_ring (option empty)) := sorry --non-trivial
lemma new_lemma_79325 (h0 : topological_space (mul_zero_class (semiring num))) : normal_space (mul_zero_class (semiring num)) := sorry --non-trivial
lemma new_lemma_79326 (h3 : ring ereal) : is_domain ereal := sorry --non-trivial
lemma new_lemma_79327 (h0 : function.extfun Type topological_space) : @normal_space.{0} (has_star.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_star.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_79328 (h0 : group (has_nnnorm (has_top (has_nnnorm linarith.comp_source)))) : group.fg (has_nnnorm (has_top (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_79329 (h0 : functor.add_const (topological_space (boolean_algebra.core name)) linarith.comp) : @path_connected_space.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_79330 (h0 : ring (with_bot (random_gen linarith.comp))) : rank_condition (with_bot (random_gen linarith.comp)) := sorry --non-trivial
lemma new_lemma_79331 (h0 : functor.add_const (function.extfun (Type 1) topological_space) pos) : @t1_space.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) pos h0) (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_79332 (h0 : complete_lattice (canonically_ordered_monoid (has_Inf real))) : is_compactly_generated (canonically_ordered_monoid (has_Inf real)) := sorry --non-trivial
lemma new_lemma_79333 (h0 : ring (has_zero num)) : is_principal_ideal_ring (has_zero num) := sorry --non-trivial
lemma new_lemma_79334 (h0 : group (has_zero (finset (finset linarith.comp)))) : group.fg (has_zero (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_79335 (h0 : function.extfun Type topological_space) : @regular_space.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg_part.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_79336 (h0 : function.extfun Type (functor.add_const (topological_space (with_bot empty)))) : @totally_disconnected_space.{0} (with_bot.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (with_bot.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (with_bot.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_79337 (h0 : topological_space (cancel_monoid ennreal)) : totally_separated_space (cancel_monoid ennreal) := sorry --non-trivial
lemma new_lemma_79338 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (non_assoc_semiring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (non_assoc_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_79339 (h0 : functor.add_const (functor.add_const (monoid (has_Inf pos)) pos) Type) : @monoid.fg.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (monoid.{0} (has_Inf.{0} pos)) pos (@functor.add_const.run.{0 1} (functor.add_const.{0 0} (monoid.{0} (has_Inf.{0} pos)) pos) Type h0))  := sorry --non-trivial
lemma new_lemma_79340 (h0 : semiring (has_zero (boolean_algebra linarith.comp))) : is_noetherian_ring (has_zero (boolean_algebra linarith.comp)) := sorry --non-trivial
lemma new_lemma_79341 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (measurable_space.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (measurable_space.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_79342 (h0 : monoid (cancel_monoid pos)) : monoid.fg (cancel_monoid pos) := sorry --non-trivial
lemma new_lemma_79343 (h0 : functor.add_const (topological_space (has_nndist unsigned)) pos) : @preirreducible_space.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_79344 (h0 : topological_space (boolean_algebra (has_Inf (has_Inf (has_Inf pos))))) : discrete_topology (boolean_algebra (has_Inf (has_Inf (has_Inf pos)))) := sorry --non-trivial
lemma new_lemma_79345 (h0 : topological_space (canonically_linear_ordered_monoid (ordered_comm_monoid (has_Inf real)))) : totally_disconnected_space (canonically_linear_ordered_monoid (ordered_comm_monoid (has_Inf real))) := sorry --non-trivial
lemma new_lemma_79346 (h0 : ring (dlist (measurable_space linarith.ineq))) : is_domain (dlist (measurable_space linarith.ineq)) := sorry --non-trivial
lemma new_lemma_79347 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_79348 (h0 : fin has_zero.zero) : @is_noetherian_ring.{0} (ordered_comm_monoid.{0} real) (@matrix.vec_empty.{0} (semiring.{0} (ordered_comm_monoid.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_79349 (h0 : topological_space (finset (finset (add_comm_monoid Type)))) : totally_disconnected_space (finset (finset (add_comm_monoid Type))) := sorry --non-trivial
lemma new_lemma_79350 (h0 : functor.add_const (ring (has_neg pos)) (has_Inf (has_Inf Type))) : @is_principal_ideal_ring.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (has_neg.{0} pos)) (has_Inf.{1} (has_Inf.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_79351 (h0 : not (complete_lattice (has_emptyc linarith.ineq) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_emptyc.{0} linarith.ineq) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_emptyc.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_79352 (h0 : topological_space (has_top (semiring (semiring unsigned)))) : irreducible_space (has_top (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_79353 (h0 : group (cancel_monoid unsigned)) : group.fg (cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_79354 (h0 : not (function.extfun Type topological_space -> false)) : @totally_disconnected_space.{0} (normed_group.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (normed_group.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_79355 (h1 : set (distrib std_gen)) : set.subsingleton h1 := sorry --non-trivial
lemma new_lemma_79356 (h0 : boolean_algebra.core (has_zero pos) -> boolean_algebra.core (has_zero pos) -> Prop) : is_antisymm (boolean_algebra.core (has_zero pos)) h0 := sorry --non-trivial
lemma new_lemma_79357 (h0 : ring (has_compl to_additive.value_type)) : is_domain (has_compl to_additive.value_type) := sorry --non-trivial
lemma new_lemma_79358 (h0 : topological_space (ordered_comm_group (option unsigned))) : locally_compact_space (ordered_comm_group (option unsigned)) := sorry --non-trivial
lemma new_lemma_79359 (h0 : functor.add_const (ordered_add_comm_monoid (has_nndist name)) unsigned) : @archimedean.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_nndist.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_79360 (h0 : ring (linear_ordered_add_comm_group (add_zero_class fun_info))) : rank_condition (linear_ordered_add_comm_group (add_zero_class fun_info)) := sorry --non-trivial
lemma new_lemma_79361 (h0 : topological_space (has_add (finset Type))) : t0_space (has_add (finset Type)) := sorry --non-trivial
lemma new_lemma_79362 (h0 : functor.add_const (ring (has_to_string unsigned)) name) : @rank_condition.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (has_to_string.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_79363 (h0 : filter (measurable_space (semiring congr_arg_kind))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_79364 (h0 : functor.add_const (topological_space (complete_distrib_lattice environment.implicit_infer_kind)) linarith.comp) : @normal_space.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_79365 (h3 : has_neg (mul_one_class enat)) (h4 : measurable_space (mul_one_class enat)) : has_measurable_neg (mul_one_class enat) := sorry --non-trivial
lemma new_lemma_79366 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (ordered_ring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_79367 (h0 : topological_space (has_norm (has_inv string_imp))) : totally_disconnected_space (has_norm (has_inv string_imp)) := sorry --non-trivial
lemma new_lemma_79368 (h2 : complete_lattice (semi_normed_comm_ring linarith.ineq)) : complete_lattice.is_Sup_finite_compact (semi_normed_comm_ring linarith.ineq) := sorry --non-trivial
lemma new_lemma_79369 (h0 : ring (has_add (normed_comm_ring pos))) : rank_condition (has_add (normed_comm_ring pos)) := sorry --non-trivial
lemma new_lemma_79370 (h0 : functor.add_const (topological_space (has_neg name)) linarith.comp) : @preconnected_space.{0} (has_neg.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_79371 (h0 : prod (option congr_arg_kind) (option congr_arg_kind)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_79372 (h0 : complete_lattice (ring (has_neg_part (has_zero (boolean_algebra Type))))) : is_compactly_generated (ring (has_neg_part (has_zero (boolean_algebra Type)))) := sorry --non-trivial
lemma new_lemma_79373 (h0 : ring (add_cancel_monoid (option (option (option ennreal))))) : is_principal_ideal_ring (add_cancel_monoid (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_79374 (h0 : has_mem.mem uniform_space has_emptyc.emptyc) : @separated_space.{0} (has_union.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) uniform_space.{0} h0) (has_union.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_79375 (h2 : complete_lattice (denumerable linarith.ineq)) : is_compactly_generated (denumerable linarith.ineq) := sorry --non-trivial
lemma new_lemma_79376 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_79377 (h0 : group (distrib (has_nnnorm (has_nnnorm (has_nnnorm linarith.ineq))))) : is_cyclic (distrib (has_nnnorm (has_nnnorm (has_nnnorm linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_79378 (h0 h1 : list (has_ssubset reducibility_hints)) : list.subset h0 h1 := sorry --non-trivial
lemma new_lemma_79379 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (ordered_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (ordered_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_79380 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (has_neg.{0} name) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (has_neg.{0} name))  := sorry --non-trivial
lemma new_lemma_79381 (h0 : add_monoid (boolean_algebra (add_cancel_monoid (emetric_space name)))) : add_monoid.fg (boolean_algebra (add_cancel_monoid (emetric_space name))) := sorry --non-trivial
lemma new_lemma_79382 (h0 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} (measurable_space.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (measurable_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_79383 (h0 : boolean_algebra (semigroup name) -> boolean_algebra (semigroup name) -> Prop) : is_total_preorder (boolean_algebra (semigroup name)) h0 := sorry --non-trivial
lemma new_lemma_79384 (h0 : ring (metric_space linarith.comp_source)) (h1 : ring (ring.total_positive_cone (metric_space linarith.comp_source))) : rank_condition (ring.total_positive_cone (metric_space linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_79385 (h1 : not (has_mem.mem (has_top linarith.comp_source) has_emptyc.emptyc -> false)) : @locally_compact_space.{0} (has_top.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_top.{0} linarith.comp_source) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_top.{0} linarith.comp_source) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h1))  := sorry --non-trivial
lemma new_lemma_79386 (h0 : topological_space (monoid (option (option empty)))) : topological_space.separable_space (monoid (option (option empty))) := sorry --non-trivial
lemma new_lemma_79387 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @path_connected_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (semigroup.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_79388 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (has_edist.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (has_edist.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_79389 (h0 : function.extfun Type ring) : @rank_condition.{0} (canonically_ordered_comm_semiring.{0} (normed_comm_ring.{0} name)) (@function.extfun_app.{2 1} Type ring.{0} h0 (canonically_ordered_comm_semiring.{0} (normed_comm_ring.{0} name)))  := sorry --non-trivial
lemma new_lemma_79390 (h0 : topological_space (has_to_string (has_add environment.implicit_infer_kind))) : preconnected_space (has_to_string (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_79391 (h0 : topological_space (free_add_monoid num)) : totally_disconnected_space (free_add_monoid num) := sorry --non-trivial
lemma new_lemma_79392 (h0 : uniform_space (normed_comm_ring name)) : complete_space (normed_comm_ring name) := sorry --non-trivial
lemma new_lemma_79393 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (has_bot.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_bot.{0} pos))  := sorry --non-trivial
lemma new_lemma_79394 (h0 : monoid (semiring (random_gen (has_top (random_gen linarith.ineq))))) : monoid.fg (semiring (random_gen (has_top (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_79395 (h0 : not (setoid to_additive.value_type -> false)) (h1 h2 : to_additive.value_type) : setoid.rel (classical.by_contradiction' h0) h1 h2 := sorry --non-trivial
lemma new_lemma_79396 (h1 : not (topological_space (random_gen fun_info) -> false)) : @t0_space.{0} (random_gen.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (random_gen.{0} fun_info)) h1)  := sorry --non-trivial
lemma new_lemma_79397 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (mul_zero_class.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (mul_zero_class.{0} name))  := sorry --non-trivial
lemma new_lemma_79398 (h0 : topological_space (ring (option pos))) : topological_space.separable_space (ring (option pos)) := sorry --non-trivial
lemma new_lemma_79399 (h0 : functor.add_const Prop (normed_comm_ring Type)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_79400 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (with_bot.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (with_bot.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_79401 (h0 : ring (has_inter empty)) : is_domain (has_inter empty) := sorry --non-trivial
lemma new_lemma_79402 (h0 : has_le (measurable_space.dynkin_system congr_arg_kind)) : no_bot_order (measurable_space.dynkin_system congr_arg_kind) := sorry --non-trivial
lemma new_lemma_79403 (h0 : function.extfun (Type 1) complete_lattice) : @complete_lattice.is_Sup_finite_compact.{1} (has_pos_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} h0 (has_pos_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_79404 (h0 : ring (boolean_algebra (comm_group unsigned))) : is_principal_ideal_ring (boolean_algebra (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_79405 (h0 : ring (metric_space (semiring unsigned))) : is_principal_ideal_ring (metric_space (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_79406 (h0 : functor.add_const (topological_space (has_Inf name)) pos) : @t0_space.{0} (has_Inf.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_79407 (h0 : not (function.extfun (Type 1) ring -> false)) : @is_domain.{1} (plift.{1} unsigned) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@classical.by_contradiction'.{3} (function.extfun.{3 2} (Type 1) ring.{1}) h0) (plift.{1} unsigned))  := sorry --non-trivial
lemma new_lemma_79408 (h0 : not (ring (distrib_lattice to_additive.value_type) -> false)) : @rank_condition.{0} (distrib_lattice.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (distrib_lattice.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_79409 (h0 : group (has_neg_part Type)) : normalizer_condition (has_neg_part Type) := sorry --non-trivial
lemma new_lemma_79410 (h0 : fin has_zero.zero) : @loc_path_connected_space.{1} (ordered_comm_ring.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (ordered_comm_ring.{1} Type)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))))  := sorry --non-trivial
lemma new_lemma_79411 (h0 : complete_lattice (omega_complete_partial_order empty)) : is_atomistic (omega_complete_partial_order empty) := sorry --non-trivial
lemma new_lemma_79412 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (add_comm_monoid.{0} (option.{0} num)) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (add_comm_monoid.{0} (option.{0} num)))  := sorry --non-trivial
lemma new_lemma_79413 (h0 h1 : multiset (has_nnnorm (mul_one_class environment.projection_info))) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_79414 (h0 : functor.comp group boolean_algebra name) : @normalizer_condition.{0} (boolean_algebra.{0} name) (@functor.comp.run.{0 0 0} group.{0} boolean_algebra.{0} name h0)  := sorry --non-trivial
lemma new_lemma_79415 (h0 : functor.add_const (functor.add_const (ring unsigned) empty) (option (option (option (option unsigned))))) : @rank_condition.{0} unsigned (@functor.add_const.run.{0 0} (ring.{0} unsigned) empty (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (ring.{0} unsigned) empty) (option.{0} (option.{0} (option.{0} (option.{0} unsigned)))) h0))  := sorry --non-trivial
lemma new_lemma_79416 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} ennreal (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) ennreal)  := sorry --non-trivial
lemma new_lemma_79417 (h0 : complete_lattice (has_div (has_append linarith.comp_source))) : is_compactly_generated (has_div (has_append linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_79418 (h0 : has_to_string (option ennreal) -> has_to_string (option ennreal) -> Prop) : is_per (has_to_string (option ennreal)) h0 := sorry --non-trivial
lemma new_lemma_79419 (h0 : add_monoid (with_bot num)) : add_monoid.fg (with_bot num) := sorry --non-trivial
lemma new_lemma_79420 (h0 : functor.add_const (topological_space (has_nndist Type)) environment.implicit_infer_kind) : @locally_compact_space.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_nndist.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_79421 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (ordered_cancel_add_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (ordered_cancel_add_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_79422 (h0 : semiring (ordered_comm_ring (has_pos_part pos))) : is_noetherian_ring (ordered_comm_ring (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_79423 (h0 : not (ring (linear_ordered_comm_group_with_zero char) -> false)) : @is_domain.{0} (linear_ordered_comm_group_with_zero.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (linear_ordered_comm_group_with_zero.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_79424 (h1 : not (ring (comm_ring linarith.comp_source) -> false)) : @strong_rank_condition.{0} (comm_ring.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (comm_ring.{0} linarith.comp_source)) h1)  := sorry --non-trivial
lemma new_lemma_79425 (h0 : not (function.extfun Type ring -> false)) : @rank_condition.{0} (semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_79426 (h0 : group (has_neg (finset (has_nndist (finset (finset (finset ennreal))))))) : is_simple_group (has_neg (finset (has_nndist (finset (finset (finset ennreal)))))) := sorry --non-trivial
lemma new_lemma_79427 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (ordered_comm_monoid congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_79428 (h0 : functor.add_const (functor.add_const (complete_lattice (has_nndist linarith.comp)) Type) linarith.comp) : @is_compactly_generated.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 1} (complete_lattice.{0} (has_nndist.{0} linarith.comp)) Type (@functor.add_const.run.{0 0} (functor.add_const.{0 1} (complete_lattice.{0} (has_nndist.{0} linarith.comp)) Type) linarith.comp h0))  := sorry --non-trivial
lemma new_lemma_79429 (h0 : functor.add_const (topological_space (cancel_monoid unsigned)) pos) : @topological_space.separable_space.{0} (cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_79430 (h0 : topological_space (add_comm_semigroup (mul_one_class linarith.ineq))) : path_connected_space (add_comm_semigroup (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_79431 (h0 : ordered_comm_monoid (ring (option (option unsigned)))) : has_exists_mul_of_le (ring (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_79432 (h2 : complete_lattice (normed_group (boolean_algebra.core string_imp))) : is_compactly_generated (normed_group (boolean_algebra.core string_imp)) := sorry --non-trivial
lemma new_lemma_79433 (h3 : topological_space (topological_space (has_nnnorm fun_info))) : totally_disconnected_space (topological_space (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_79434 (h0 : filter (has_neg_part (comm_group (comm_group name)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_79435 (h0 : has_dist empty -> has_dist empty -> Prop) (h1 : function.extfun (has_dist empty) (fun (x : has_dist empty), Prop)) : set.unbounded h0 (function.extfun_app h1) := sorry --non-trivial
lemma new_lemma_79436 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (add_semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (add_semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_79437 (h0 : ring (denumerable (topological_space string_imp))) : rank_condition (denumerable (topological_space string_imp)) := sorry --non-trivial
lemma new_lemma_79438 (h0 : topological_space (add_cancel_monoid (boolean_algebra.core unsigned))) : regular_space (add_cancel_monoid (boolean_algebra.core unsigned)) := sorry --non-trivial
lemma new_lemma_79439 (h0 : function.extfun Type (functor.add_const (ordered_comm_monoid (ordered_comm_ring linarith.comp)))) : @has_exists_mul_of_le.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (ordered_comm_ring.{0} linarith.comp)) linarith.comp (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ordered_comm_monoid.{0} (ordered_comm_ring.{0} linarith.comp))) h0 linarith.comp))  := sorry --non-trivial
lemma new_lemma_79440 (h0 : ordered_add_comm_monoid (semigroup unsigned)) : archimedean (semigroup unsigned) := sorry --non-trivial
lemma new_lemma_79441 (h0 : functor.add_const (topological_space (boolean_algebra Type)) name) : @discrete_topology.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_79442 (h0 : ring (normed_lattice_add_comm_group (has_Inf (has_add (sub_neg_monoid real))))) : strong_rank_condition (normed_lattice_add_comm_group (has_Inf (has_add (sub_neg_monoid real)))) := sorry --non-trivial
lemma new_lemma_79443 (h0 : topological_space (complete_distrib_lattice (ring linarith.comp))) : path_connected_space (complete_distrib_lattice (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_79444 (h0 : group (has_union (semiring (semiring (semiring (semiring num)))))) : group.fg (has_union (semiring (semiring (semiring (semiring num))))) := sorry --non-trivial
lemma new_lemma_79445 (h0 : topological_space (canonically_ordered_monoid (sub_neg_monoid (sub_neg_monoid name)))) : locally_compact_space (canonically_ordered_monoid (sub_neg_monoid (sub_neg_monoid name))) := sorry --non-trivial
lemma new_lemma_79446 (h0 : uniform_space (has_nndist congr_arg_kind)) : separated_space (has_nndist congr_arg_kind) := sorry --non-trivial
lemma new_lemma_79447 (h0 : topological_space (has_Inf (has_Inf Type))) : normal_space (has_Inf (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_79448 (h0 : topological_space (has_Sup congr_arg_kind)) : totally_separated_space (has_Sup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_79449 (h0 : function.extfun Type topological_space) : @normal_space.{0} (semigroup.{0} (has_nndist.{0} ennreal)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} (has_nndist.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_79450 (h0 : topological_space (add_comm_monoid (sub_neg_monoid linarith.comp))) : preconnected_space (add_comm_monoid (sub_neg_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_79451 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (add_group.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (add_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_79452 (h0 : ring (has_add (finset (normed_comm_ring name)))) : is_principal_ideal_ring (has_add (finset (normed_comm_ring name))) := sorry --non-trivial
lemma new_lemma_79453 (h0 : ring (with_one (semiring (has_norm (has_top (has_top congr_arg_kind)))))) : strong_rank_condition (with_one (semiring (has_norm (has_top (has_top congr_arg_kind))))) := sorry --non-trivial
lemma new_lemma_79454 (h0 : functor.add_const (ordered_comm_monoid (has_to_string pos)) environment.implicit_infer_kind) : @has_exists_mul_of_le.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_to_string.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_79455 (h0 : add_group (left_cancel_semigroup empty)) : is_add_cyclic (left_cancel_semigroup empty) := sorry --non-trivial
lemma new_lemma_79456 (h0 : ring (non_unital_non_assoc_semiring (mul_one_class (mul_one_class reducibility_hints)))) : is_domain (non_unital_non_assoc_semiring (mul_one_class (mul_one_class reducibility_hints))) := sorry --non-trivial
lemma new_lemma_79457 (h0 : function.extfun (finset ((Type -> Type) -> Type 1)) (has_mem.mem (function.extfun Type))) : @irreducible_space.{0} (normed_group.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@finset.pi.empty.{2 1} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) (function.extfun.{2 1} Type) (@function.extfun_app.{3 0} (finset.{2} ((Type → Type) → Type 1)) (@has_mem.mem.{2 2} ((Type → Type) → Type 1) (finset.{2} ((Type → Type) → Type 1)) (@finset.has_mem.{2} ((Type → Type) → Type 1)) (function.extfun.{2 1} Type)) h0 (@has_emptyc.emptyc.{2} (finset.{2} ((Type → Type) → Type 1)) (@finset.has_emptyc.{2} ((Type → Type) → Type 1))))) topological_space.{0}) (normed_group.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_79458 (h0 : uniform_space (mul_zero_class (has_nndist (has_nndist unsigned)))) : complete_space (mul_zero_class (has_nndist (has_nndist unsigned))) := sorry --non-trivial
lemma new_lemma_79459 (h0 : functor.add_const (topological_space (add_comm_monoid pos)) (comm_group Type)) : @regular_space.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (add_comm_monoid.{0} pos)) (comm_group.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_79460 (h0 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} (has_union.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_union.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_79461 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_norm.{0} (random_gen.{0} linarith.comp_source)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_norm.{0} (random_gen.{0} linarith.comp_source)))  := sorry --non-trivial
lemma new_lemma_79462 (h1 : topological_space (mul_one_class (mul_one_class (mul_one_class std_gen)))) : path_connected_space (mul_one_class (mul_one_class (mul_one_class std_gen))) := sorry --non-trivial
lemma new_lemma_79463 (h0 : has_mem.mem complete_lattice has_emptyc.emptyc) : @is_atomistic.{0} num (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} h0) num)  := sorry --non-trivial
lemma new_lemma_79464 (h0 : ring (ordered_comm_monoid (has_add Type))) : is_domain (ordered_comm_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_79465 (h0 : functor.add_const (topological_space (left_cancel_semigroup empty)) num) : @totally_separated_space.{0} (left_cancel_semigroup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_semigroup.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_79466 (h0 : uniform_space (semiring (has_top unsigned))) : complete_space (semiring (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_79467 (h0 : filter (measure_theory.measure_space num)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_79468 (h0 : not (group (complete_semilattice_Sup linarith.comp) -> false)) : @is_cyclic.{0} (complete_semilattice_Sup.{0} linarith.comp) (@classical.by_contradiction'.{1} (group.{0} (complete_semilattice_Sup.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_79469 (h0 : complete_lattice (add_cancel_monoid (option num))) : is_compactly_generated (add_cancel_monoid (option num)) := sorry --non-trivial
lemma new_lemma_79470 (h0 : ring (complete_linear_order (has_top (has_top num)))) : is_domain (complete_linear_order (has_top (has_top num))) := sorry --non-trivial
lemma new_lemma_79471 (h0 : functor.add_const Prop (add_comm_monoid (finset name))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_79472 (h0 : group (option (option (option (option unsigned))))) : is_simple_group (option (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_79473 (h0 : functor.add_const (topological_space (finset linarith.comp)) pos) : @path_connected_space.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_79474 (h0 : topological_space (complete_distrib_lattice (has_neg Type))) : irreducible_space (complete_distrib_lattice (has_neg Type)) := sorry --non-trivial
lemma new_lemma_79475 (h0 : ring (ordered_comm_ring (has_add pos))) : is_domain (ordered_comm_ring (has_add pos)) := sorry --non-trivial
lemma new_lemma_79476 (h0 : functor.add_const (function.extfun Type topological_space) (ordered_ring linarith.comp)) : @totally_separated_space.{0} (finset.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (ordered_ring.{0} linarith.comp) h0) (finset.{0} name))  := sorry --non-trivial
lemma new_lemma_79477 (h0 : functor.add_const (function.extfun (Type 1) topological_space) pos) : @totally_separated_space.{1} (normed_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) pos h0) (normed_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_79478 (h0 : add_group (random_gen (comm_ring to_additive.value_type))) : is_add_cyclic (random_gen (comm_ring to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_79479 (h0 : finset (has_neg (option name))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_79480 (h0 : function.extfun Type (functor.comp topological_space canonically_ordered_comm_semiring)) : @path_connected_space.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@functor.comp.run.{0 0 0} topological_space.{0} canonically_ordered_comm_semiring.{0} unsigned (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} canonically_ordered_comm_semiring.{0}) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_79481 (h0 : add_group (has_neg (has_nndist (semigroup unsigned)))) : is_add_cyclic (has_neg (has_nndist (semigroup unsigned))) := sorry --non-trivial
lemma new_lemma_79482 (h0 : filter (random_gen (has_norm (has_norm linarith.comp)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_79483 (h0 : group (measurable_space (has_inv (random_gen (random_gen fun_info))))) : normalizer_condition (measurable_space (has_inv (random_gen (random_gen fun_info)))) := sorry --non-trivial
lemma new_lemma_79484 (h0 : measurable_space (random_gen char)) (h1 : filter (random_gen char)) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_79485 (h0 : functor.add_const (complete_lattice (canonically_ordered_comm_semiring name)) pos) : @complete_lattice.is_Sup_finite_compact.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (canonically_ordered_comm_semiring.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_79486 (h0 : topological_space (has_bot (has_Inf (has_Inf (has_add linarith.comp))))) : preirreducible_space (has_bot (has_Inf (has_Inf (has_add linarith.comp)))) := sorry --non-trivial
lemma new_lemma_79487 (h0 : ring (with_zero string_imp)) : rank_condition (with_zero string_imp) := sorry --non-trivial
lemma new_lemma_79488 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (group_with_zero.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (group_with_zero.{0} num))  := sorry --non-trivial
lemma new_lemma_79489 (h0 : filter (plift unsigned)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_79490 (h0 : fin has_zero.zero) : @group.fg.{0} (add_comm_monoid.{0} pos) (@matrix.vec_empty.{0} (group.{0} (add_comm_monoid.{0} pos)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)))  := sorry --non-trivial
lemma new_lemma_79491 (h0 : ring (filter empty)) : strong_rank_condition (filter empty) := sorry --non-trivial
lemma new_lemma_79492 (h0 : functor.add_const (topological_space (normed_comm_ring name)) Type) : @topological_space.separable_space.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (normed_comm_ring.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_79493 (h0 : not (group (fintype linarith.ineq) -> false)) : @is_cyclic.{0} (fintype.{0} linarith.ineq) (@classical.by_contradiction'.{1} (group.{0} (fintype.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_79494 (h0 : complete_lattice (mul_zero_class num)) : complete_lattice.is_Sup_finite_compact (mul_zero_class num) := sorry --non-trivial
lemma new_lemma_79495 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (has_neg congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_79496 (h0 : topological_space (generalized_boolean_algebra (finset (has_pos_part (ring linarith.comp))))) : sequential_space (generalized_boolean_algebra (finset (has_pos_part (ring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_79497 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : complete_lattice.is_Sup_finite_compact (measurable_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_79498 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (preorder.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (preorder.{0} num))  := sorry --non-trivial
lemma new_lemma_79499 (h0 : functor.add_const (topological_space (has_star unsigned)) empty) : @path_connected_space.{0} (has_star.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_79500 (h0 : group (semigroup (has_zero (finset (finset pos))))) : is_cyclic (semigroup (has_zero (finset (finset pos)))) := sorry --non-trivial
lemma new_lemma_79501 (h0 : function.extfun Type group) : @is_cyclic.{0} (encodable.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} h0 (encodable.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_79502 (h0 : fin has_zero.zero) : @unique_factorization_monoid.{0} (has_bot.{0} name) (@matrix.vec_empty.{0} (cancel_comm_monoid_with_zero.{0} (has_bot.{0} name)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)))  := sorry --non-trivial
lemma new_lemma_79503 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (generalized_boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (generalized_boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_79504 (h0 : function.extfun Type ring) : @rank_condition.{0} (cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_79505 (h0 : topological_space (random_gen linarith.comp)) : t0_space (random_gen linarith.comp) := sorry --non-trivial
lemma new_lemma_79506 (h0 : functor.add_const (uniform_space (has_Inf pos)) (has_Inf (has_Inf pos))) : @complete_space.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_Inf.{0} pos)) (has_Inf.{0} (has_Inf.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_79507 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (has_nndist.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_nndist.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_79508 (h0 : ordered_comm_monoid (complete_distrib_lattice (finset Type))) : has_exists_mul_of_le (complete_distrib_lattice (finset Type)) := sorry --non-trivial
lemma new_lemma_79509 (h0 : functor.add_const (uniform_space (semigroup Type)) Type) : @separated_space.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 1} (uniform_space.{1} (semigroup.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_79510 (h0 : topological_space (add_comm_monoid (option (option unsigned)))) : t0_space (add_comm_monoid (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_79511 (h0 : topological_space (group_with_zero num)) : discrete_topology (group_with_zero num) := sorry --non-trivial
lemma new_lemma_79512 (h0 : uniform_space (ring (has_Inf (has_pos_part (has_pos_part pos))))) : complete_space (ring (has_Inf (has_pos_part (has_pos_part pos)))) := sorry --non-trivial
lemma new_lemma_79513 (h0 : complete_lattice (has_zero (has_to_string (has_to_string ennreal)))) : is_atomistic (has_zero (has_to_string (has_to_string ennreal))) := sorry --non-trivial
lemma new_lemma_79514 (h0 : topological_space (cancel_monoid (boolean_algebra Type))) : t0_space (cancel_monoid (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_79515 (h0 : topological_space (comm_group (has_to_string Type))) : t1_space (comm_group (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_79516 (h0 : functor.add_const (ordered_comm_monoid (has_to_string environment.implicit_infer_kind)) (finset linarith.comp)) : @has_exists_mul_of_le.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_to_string.{0} environment.implicit_infer_kind)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_79517 (h0 : topological_space (normed_comm_ring name)) : normal_space (normed_comm_ring name) := sorry --non-trivial
lemma new_lemma_79518 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (has_top.{0} unsigned) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (has_top.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_79519 (h0 : fin has_zero.zero) : @t1_space.{0} (sub_neg_monoid.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (sub_neg_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_79520 (h0 : functor.add_const (group (has_neg name)) ennreal) : @is_simple_group.{0} (has_neg.{0} name) (@functor.add_const.run.{0 0} (group.{0} (has_neg.{0} name)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_79521 (h0 : topological_space (add_cancel_comm_monoid (option empty))) : irreducible_space (add_cancel_comm_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_79522 (h1 : function.extfun Type group) : @group.fg.{0} (has_norm.{0} string_imp) (@function.extfun_app.{2 1} Type group.{0} h1 (has_norm.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_79523 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (denumerable.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (denumerable.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_79524 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_79525 (h0 : ring (has_neg_part (option (option pos)))) : is_principal_ideal_ring (has_neg_part (option (option pos))) := sorry --non-trivial
lemma new_lemma_79526 (h0 : functor.add_const (topological_space (add_comm_monoid name)) linarith.comp) : @topological_space.separable_space.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_79527 (h0 : functor.add_const (ordered_comm_monoid (ordered_comm_ring pos)) pos) : @has_exists_mul_of_le.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (ordered_comm_ring.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_79528 (h0 : add_group (with_bot (has_top (has_inv (has_inv linarith.ineq))))) : is_add_cyclic (with_bot (has_top (has_inv (has_inv linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_79529 (h0 : uniform_space (normed_field string.iterator_imp)) : complete_space (normed_field string.iterator_imp) := sorry --non-trivial
lemma new_lemma_79530 (h1 : topological_space (semi_normed_comm_ring (random_gen char))) : totally_disconnected_space (semi_normed_comm_ring (random_gen char)) := sorry --non-trivial
lemma new_lemma_79531 (h0 : functor.add_const (group (non_assoc_semiring unsigned)) congr_arg_kind) : @group.fg.{0} (non_assoc_semiring.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (non_assoc_semiring.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_79532 (h1 : group (has_nnnorm (comm_ring reducibility_hints))) : is_cyclic (has_nnnorm (comm_ring reducibility_hints)) := sorry --non-trivial
lemma new_lemma_79533 (h0 : topological_space (has_norm (has_top (has_top (has_top num))))) : totally_disconnected_space (has_norm (has_top (has_top (has_top num)))) := sorry --non-trivial
lemma new_lemma_79534 (h0 : complete_lattice (comm_group (comm_group unsigned))) : is_compactly_generated (comm_group (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_79535 (h0 : ring (has_nndist (option (comm_monoid unsigned)))) : strong_rank_condition (has_nndist (option (comm_monoid unsigned))) := sorry --non-trivial
lemma new_lemma_79536 (h0 : topological_space (cancel_monoid Type)) : regular_space (cancel_monoid Type) := sorry --non-trivial
lemma new_lemma_79537 (h0 : has_lt (add_comm_semigroup (has_mul (semigroup reducibility_hints)))) : no_max_order (add_comm_semigroup (has_mul (semigroup reducibility_hints))) := sorry --non-trivial
lemma new_lemma_79538 (h0 : ring (ring (has_add linarith.comp))) : is_domain (ring (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_79539 (h0 : list (boolean_algebra.core (has_add (normed_comm_ring Type)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_79540 (h0 : function.extfun Type (functor.add_const (topological_space linarith.comp))) : @normal_space.{0} linarith.comp (@functor.add_const.run.{0 0} (topological_space.{0} linarith.comp) pos (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} linarith.comp)) h0 pos))  := sorry --non-trivial
lemma new_lemma_79541 (h0 : ring (has_to_string (has_add Type))) : rank_condition (has_to_string (has_add Type)) := sorry --non-trivial
lemma new_lemma_79542 (h0 : ring (random_gen (has_nnnorm reducibility_hints))) : rank_condition (random_gen (has_nnnorm reducibility_hints)) := sorry --non-trivial
lemma new_lemma_79543 (h0 : topological_space (simple_graph num)) : discrete_topology (simple_graph num) := sorry --non-trivial
lemma new_lemma_79544 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (ring.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_79545 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring pos)) pos) : @preconnected_space.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_79546 (h0 : topological_space (comm_ring (comm_ring linarith.ineq))) : irreducible_space (comm_ring (comm_ring linarith.ineq)) := sorry --non-trivial
lemma new_lemma_79547 (h0 : topological_space (metric_space (comm_ring linarith.comp_source))) : t0_space (metric_space (comm_ring linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_79548 (h0 : functor.add_const (ordered_add_comm_monoid (has_Sup empty)) empty) : @archimedean.{0} (has_Sup.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_Sup.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_79549 (h0 : filter (normed_comm_ring (has_to_string linarith.comp))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_79550 (h0 : function.extfun nat fin) : @locally_compact_space.{1} (has_bot.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (has_bot.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_79551 (h0 : option (finset (has_inter congr_arg_kind))) (h1 : finset (has_inter congr_arg_kind)) : finset.nonempty (option.get_or_else h0 h1) := sorry --non-trivial
lemma new_lemma_79552 (h0 : topological_space (sub_neg_monoid (finset (has_Inf (has_add pos))))) : regular_space (sub_neg_monoid (finset (has_Inf (has_add pos)))) := sorry --non-trivial
lemma new_lemma_79553 (h0 : group (has_add (has_pos_part (has_pos_part linarith.comp)))) : group.fg (has_add (has_pos_part (has_pos_part linarith.comp))) := sorry --non-trivial
lemma new_lemma_79554 (h0 : add_monoid (has_add (option (mul_zero_class Type)))) : add_monoid.fg (has_add (option (mul_zero_class Type))) := sorry --non-trivial
lemma new_lemma_79555 (h0 : add_group (linear_ordered_comm_monoid_with_zero unsigned)) : is_add_cyclic (linear_ordered_comm_monoid_with_zero unsigned) := sorry --non-trivial
lemma new_lemma_79556 (h0 : ring (free_add_monoid (option unsigned))) : is_principal_ideal_ring (free_add_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_79557 (h0 : topological_space (add_cancel_monoid (ring (has_add (has_neg (has_Inf (has_neg pos))))))) : preconnected_space (add_cancel_monoid (ring (has_add (has_neg (has_Inf (has_neg pos)))))) := sorry --non-trivial
lemma new_lemma_79558 (h1 : topological_space (linear_ordered_semiring (has_top fun_info))) : path_connected_space (linear_ordered_semiring (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_79559 (h0 : group (finset Type)) : normalizer_condition (finset Type) := sorry --non-trivial
lemma new_lemma_79560 (h0 : ring (add_cancel_comm_monoid (has_lt char))) : strong_rank_condition (add_cancel_comm_monoid (has_lt char)) := sorry --non-trivial
lemma new_lemma_79561 (h0 : topological_space (add_comm_semigroup string.iterator_imp)) (h1 : set (set (add_comm_semigroup string.iterator_imp))) : topological_space.is_topological_basis h1 := sorry --non-trivial
lemma new_lemma_79562 (h0 h1 : pnat) (h2 : ulower (list pnat)) : pnat.coprime h0 (list.ilast' h1 (ulower.up h2)) := sorry --non-trivial
lemma new_lemma_79563 (h0 : uniform_space (has_to_string linarith.comp)) : separated_space (has_to_string linarith.comp) := sorry --non-trivial
lemma new_lemma_79564 (h0 : semiring (canonically_linear_ordered_monoid real)) : is_noetherian_ring (canonically_linear_ordered_monoid real) := sorry --non-trivial
lemma new_lemma_79565 (h0 : topological_space (has_add (has_neg Type))) : normal_space (has_add (has_neg Type)) := sorry --non-trivial
lemma new_lemma_79566 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (add_comm_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (add_comm_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_79567 (h0 : functor.add_const (topological_space (pseudo_metric_space unsigned)) name) : @irreducible_space.{0} (pseudo_metric_space.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (pseudo_metric_space.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_79568 (h0 : topological_space (has_nndist name)) : preconnected_space (has_nndist name) := sorry --non-trivial
lemma new_lemma_79569 (h0 : functor.add_const (topological_space (partial_order empty)) empty) : @totally_disconnected_space.{0} (partial_order.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (partial_order.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_79570 (h0 : topological_space (id (semiring congr_arg_kind))) : totally_separated_space (id (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_79571 (h0 : functor.add_const (ring (linear_order empty)) empty) : @is_domain.{0} (linear_order.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (linear_order.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_79572 (h0 : functor.add_const (function.extfun Type finset) name) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_79573 (h0 : topological_space (generalized_boolean_algebra pos)) : preirreducible_space (generalized_boolean_algebra pos) := sorry --non-trivial
lemma new_lemma_79574 (h0 : functor.add_const (ring (boolean_algebra.core name)) linarith.comp) : @is_domain.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.core.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_79575 (h0 : topological_space (comm_semigroup (sub_neg_monoid (sub_neg_monoid real)))) : t1_space (comm_semigroup (sub_neg_monoid (sub_neg_monoid real))) := sorry --non-trivial
lemma new_lemma_79576 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (generalized_boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (generalized_boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_79577 (h0 : ring (with_zero string_imp)) : is_domain (with_zero string_imp) := sorry --non-trivial
lemma new_lemma_79578 (h0 : ring (has_div std_gen)) : rank_condition (has_div std_gen) := sorry --non-trivial
lemma new_lemma_79579 (h0 : topological_space (has_to_string (semigroup linarith.comp))) : preirreducible_space (has_to_string (semigroup linarith.comp)) := sorry --non-trivial
lemma new_lemma_79580 (h0 : functor.add_const (function.extfun Type topological_space) name) : @discrete_topology.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_79581 (h0 : topological_space (has_Inf (has_add (has_Inf pos)))) : loc_path_connected_space (has_Inf (has_add (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_79582 (h0 : semiring (mul_zero_class empty)) (h1 : not (ideal (mul_zero_class empty) -> false)) : ideal.fg (classical.by_contradiction' h1) := sorry --non-trivial
lemma new_lemma_79583 (h0 : functor.add_const (list (has_nndist linarith.comp)) pos) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_79584 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_atomistic.{0} (normed_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (normed_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_79585 (h1 : ring (dlist (has_nnnorm linarith.ineq))) : strong_rank_condition (dlist (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_79586 (h0 : add_group (semiring (has_norm (has_top (has_top (has_top to_additive.value_type)))))) : is_add_cyclic (semiring (has_norm (has_top (has_top (has_top to_additive.value_type))))) := sorry --non-trivial
lemma new_lemma_79587 (h2 : char -> char -> char) (h3 : char) : right_identity h2 h3 := sorry --non-trivial
lemma new_lemma_79588 (h0 : topological_space (id congr_arg_kind)) : totally_separated_space (id congr_arg_kind) := sorry --non-trivial
lemma new_lemma_79589 (h0 : set (linarith.ineq -> string.iterator_imp)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_79590 (h0 : measurable_space (comm_ring char)) (h1 : set (comm_ring char)) : measurable_set h1 := sorry --non-trivial
lemma new_lemma_79591 (h0 : set (has_compl (mul_one_class to_additive.value_type))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_79592 (h0 : fin has_zero.zero) : @regular_space.{0} (comm_semigroup.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (comm_semigroup.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_79593 (h0 : Type -> mul_one_class Type -> Prop) : relator.bi_total h0 := sorry --non-trivial
lemma new_lemma_79594 (h0 : topological_space (generalized_boolean_algebra (sub_neg_monoid Type))) : locally_compact_space (generalized_boolean_algebra (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_79595 (h0 : functor.add_const (function.extfun (Type 1) group) pos) : @is_simple_group.{1} (boolean_algebra.core.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) group.{1}) pos h0) (boolean_algebra.core.{1} Type))  := sorry --non-trivial
lemma new_lemma_79596 (h0 : add_group (has_bot (finset (has_add pos)))) : is_add_cyclic (has_bot (finset (has_add pos))) := sorry --non-trivial
lemma new_lemma_79597 (h0 : functor.comp topological_space has_neg pos) : @sequential_space.{0} (has_neg.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_79598 (h0 : group (complete_distrib_lattice (comm_group Type))) : normalizer_condition (complete_distrib_lattice (comm_group Type)) := sorry --non-trivial
lemma new_lemma_79599 (h0 : functor.comp topological_space comm_group (semigroup unsigned)) : @preconnected_space.{0} (comm_group.{0} (semigroup.{0} unsigned)) (@functor.comp.run.{0 0 0} topological_space.{0} comm_group.{0} (semigroup.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_79600 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (has_one.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (has_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_79601 (h0 : functor.add_const (group (comm_group linarith.comp)) linarith.comp) : @is_simple_group.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (comm_group.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_79602 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_dist.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_dist.{0} num))  := sorry --non-trivial
lemma new_lemma_79603 (h0 : functor.add_const (topological_space (partial_order congr_arg_kind)) empty) : @topological_space.separable_space.{0} (partial_order.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (partial_order.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_79604 (h0 : functor.add_const (topological_space (has_nndist linarith.comp)) environment.implicit_infer_kind) : @t0_space.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_79605 (h0 : ring (normed_group (has_top linarith.comp_source))) : rank_condition (normed_group (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_79606 (h0 : topological_space (has_nndist (has_add environment.implicit_infer_kind))) : topological_space.separable_space (has_nndist (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_79607 (h0 : list (add_left_cancel_semigroup (option empty))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_79608 (h0 : functor.add_const Prop (group_with_zero congr_arg_kind)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_79609 (h0 : function.extfun Type topological_space) : @regular_space.{0} (finset.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_79610 (h0 : fin has_zero.zero) : @is_simple_group.{0} (has_bot.{0} pos) (@matrix.vec_empty.{0} (group.{0} (has_bot.{0} pos)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)))))))  := sorry --non-trivial
lemma new_lemma_79611 (h0 : topological_space (comm_group (option (ring pos)))) : discrete_topology (comm_group (option (ring pos))) := sorry --non-trivial
lemma new_lemma_79612 (h0 : functor.add_const (ring (canonically_ordered_comm_semiring Type)) linarith.comp) : @is_principal_ideal_ring.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (canonically_ordered_comm_semiring.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_79613 (h0 : functor.add_const (topological_space (comm_group (ring name))) pos) : @normal_space.{0} (comm_group.{0} (ring.{0} name)) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} (ring.{0} name))) pos h0)  := sorry --non-trivial
lemma new_lemma_79614 (h0 : functor.add_const (topological_space (generalized_boolean_algebra linarith.comp)) Type) : @topological_space.separable_space.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (generalized_boolean_algebra.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_79615 (h0 : topological_space (has_div fun_info)) (h1 : preorder (has_div fun_info)) : order_closed_topology (has_div fun_info) := sorry --non-trivial
lemma new_lemma_79616 (h0 : topological_space (ring (option (option (option empty))))) : loc_path_connected_space (ring (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_79617 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_inv.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} h0 (has_inv.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_79618 (h0 : topological_space (measure_theory.measure_space num)) : totally_separated_space (measure_theory.measure_space num) := sorry --non-trivial
lemma new_lemma_79619 (h0 : functor.comp ring has_to_string name) : @rank_condition.{0} (has_to_string.{0} name) (@functor.comp.run.{0 0 0} ring.{0} has_to_string.{0} name h0)  := sorry --non-trivial
lemma new_lemma_79620 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_79621 (h0 : ulower (fin has_zero.zero)) : id (matrix.vec_empty (id (ulower.up h0))) := sorry --non-trivial
lemma new_lemma_79622 (h0 : monoid (has_zero (ring name))) : monoid.fg (has_zero (ring name)) := sorry --non-trivial
lemma new_lemma_79623 (h0 : complete_lattice (finset to_additive.value_type)) : complete_lattice.is_Sup_finite_compact (finset to_additive.value_type) := sorry --non-trivial
lemma new_lemma_79624 (h1 : add_group (encodable fun_info)) : is_add_cyclic (encodable fun_info) := sorry --non-trivial
lemma new_lemma_79625 (h0 : complete_lattice (random_gen (has_nnnorm (has_nnnorm fun_info)))) : complete_lattice.is_Sup_finite_compact (random_gen (has_nnnorm (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_79626 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_79627 (h0 : ring (with_zero (has_nnnorm fun_info))) : rank_condition (with_zero (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_79628 (h0 : complete_lattice (has_pos_part (has_bot Type))) : is_compactly_generated (has_pos_part (has_bot Type)) := sorry --non-trivial
lemma new_lemma_79629 (h0 : topological_space (has_append (random_gen (has_nnnorm char)))) : path_connected_space (has_append (random_gen (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_79630 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (has_nndist congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_79631 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (denumerable.{0} linarith.ineq) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (denumerable.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_79632 (h0 : topological_space (linear_ordered_add_comm_group (has_top to_additive.value_type))) : t0_space (linear_ordered_add_comm_group (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_79633 (h0 : not (complete_lattice (uniform_space char) -> false)) : is_compactly_generated (uniform_space char) := sorry --non-trivial
lemma new_lemma_79634 (h0 : topological_space (has_norm (has_norm (has_norm (has_norm linarith.ineq))))) : totally_disconnected_space (has_norm (has_norm (has_norm (has_norm linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_79635 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (normed_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (normed_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_79636 (h0 : functor.add_const (function.extfun (Type 1) ordered_add_comm_monoid) (has_Inf Type)) : @archimedean.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_add_comm_monoid.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) ordered_add_comm_monoid.{1}) (has_Inf.{1} Type) h0) (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_79637 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (linear_ordered_cancel_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (linear_ordered_cancel_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_79638 (h0 : topological_space (metric_space (has_norm unsigned))) : t0_space (metric_space (has_norm unsigned)) := sorry --non-trivial
lemma new_lemma_79639 (h0 : group (with_one num)) : group.fg (with_one num) := sorry --non-trivial
lemma new_lemma_79640 (h0 : ring (measurable_space (has_norm (has_norm (has_norm unsigned))))) : strong_rank_condition (measurable_space (has_norm (has_norm (has_norm unsigned)))) := sorry --non-trivial
lemma new_lemma_79641 (h0 : functor.add_const (topological_space (comm_group pos)) linarith.comp) : @discrete_topology.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_79642 (h0 : functor.add_const (function.extfun (Type 1) topological_space) (has_Inf pos)) : @irreducible_space.{1} Type (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) (has_Inf.{0} pos) h0) Type)  := sorry --non-trivial
lemma new_lemma_79643 (h0 : uniform_space (has_emptyc Type)) : complete_space (has_emptyc Type) := sorry --non-trivial
lemma new_lemma_79644 (h0 : topological_space (semigroup (semiring unsigned))) : locally_compact_space (semigroup (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_79645 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (normed_linear_ordered_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_linear_ordered_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_79646 (h0 : ring (sub_neg_monoid name)) : is_domain (sub_neg_monoid name) := sorry --non-trivial
lemma new_lemma_79647 (h0 : topological_space (has_bot (has_pos_part (has_add pos)))) : t0_space (has_bot (has_pos_part (has_add pos))) := sorry --non-trivial
lemma new_lemma_79648 (h0 : functor.add_const (filter (add_cancel_monoid Type)) Type) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_79649 (h0 : functor.add_const (add_group (has_neg pos)) linarith.comp) : @is_add_cyclic.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (has_neg.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_79650 (h0 : group (linear_ordered_semiring (has_norm (has_norm (has_norm linarith.comp_source))))) : is_cyclic (linear_ordered_semiring (has_norm (has_norm (has_norm linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_79651 (h0 : topological_space (partial_order unsigned)) : t0_space (partial_order unsigned) := sorry --non-trivial
lemma new_lemma_79652 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (mul_zero_class.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (mul_zero_class.{0} pos))  := sorry --non-trivial
lemma new_lemma_79653 (h0 : add_zero_class (boolean_algebra linarith.ineq)) (h1 : group (add_submonoid (boolean_algebra linarith.ineq))) : group.fg (add_submonoid (boolean_algebra linarith.ineq)) := sorry --non-trivial
lemma new_lemma_79654 (h0 : topological_space (finset (finset (finset (finset (has_neg_part Type)))))) : locally_compact_space (finset (finset (finset (finset (has_neg_part Type))))) := sorry --non-trivial
lemma new_lemma_79655 (h0 : function.extfun Type ring) : @rank_condition.{0} (ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_79656 (h0 : topological_space (normed_group linarith.ineq)) : locally_compact_space (normed_group linarith.ineq) := sorry --non-trivial
lemma new_lemma_79657 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_top.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_top.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_79658 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (canonically_ordered_add_monoid empty)) := sorry --non-trivial
lemma new_lemma_79659 (h0 : complete_lattice (semi_normed_comm_ring (random_gen linarith.ineq))) : complete_lattice.is_Sup_finite_compact (semi_normed_comm_ring (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_79660 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (@id.{2} Type unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (@id.{2} Type unsigned))  := sorry --non-trivial
lemma new_lemma_79661 (h0 : topological_space (complete_semilattice_Sup (comm_ring linarith.comp_source))) : irreducible_space (complete_semilattice_Sup (comm_ring linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_79662 (h0 : function.extfun Type ring) : @rank_condition.{0} (semigroup.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_79663 (h0 : topological_space (has_one empty)) : normal_space (has_one empty) := sorry --non-trivial
lemma new_lemma_79664 (h0 : function.extfun (finset ((Type -> Type) -> Type 1)) (has_mem.mem (function.extfun Type))) : @complete_lattice.is_Sup_finite_compact.{0} num (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@finset.pi.empty.{2 1} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) (function.extfun.{2 1} Type) (@function.extfun_app.{3 0} (finset.{2} ((Type → Type) → Type 1)) (@has_mem.mem.{2 2} ((Type → Type) → Type 1) (finset.{2} ((Type → Type) → Type 1)) (@finset.has_mem.{2} ((Type → Type) → Type 1)) (function.extfun.{2 1} Type)) h0 (@has_emptyc.emptyc.{2} (finset.{2} ((Type → Type) → Type 1)) (@finset.has_emptyc.{2} ((Type → Type) → Type 1))))) complete_lattice.{0}) num)  := sorry --non-trivial
lemma new_lemma_79665 (h0 : group (free_add_monoid unsigned)) : group.fg (free_add_monoid unsigned) := sorry --non-trivial
lemma new_lemma_79666 (h0 : uniform_space (has_one unsigned)) : complete_space (has_one unsigned) := sorry --non-trivial
lemma new_lemma_79667 (h0 : complete_lattice (boolean_algebra (has_Inf (has_Inf pos)))) : is_compactly_generated (boolean_algebra (has_Inf (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_79668 (h0 : function.extfun Type topological_space) : @regular_space.{0} (add_right_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_right_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_79669 (h1 : topological_space (random_gen char)) : t0_space (random_gen char) := sorry --non-trivial
lemma new_lemma_79670 (h0 : functor.add_const (uniform_space (boolean_algebra.core Type)) linarith.comp) : @separated_space.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (boolean_algebra.core.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_79671 (h0 : function.extfun (Type 1) (functor.add_const (topological_space (complete_distrib_lattice linarith.comp)))) : @preconnected_space.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (complete_distrib_lattice.{0} linarith.comp)) (generalized_boolean_algebra.{1} Type) (@function.extfun_app.{3 1} (Type 1) (functor.add_const.{0 1} (topological_space.{0} (complete_distrib_lattice.{0} linarith.comp))) h0 (generalized_boolean_algebra.{1} Type)))  := sorry --non-trivial
lemma new_lemma_79672 (h0 : list (ordered_cancel_add_comm_monoid congr_arg_kind)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_79673 (h0 : ring (has_add (boolean_algebra (has_add (has_add pos))))) : strong_rank_condition (has_add (boolean_algebra (has_add (has_add pos)))) := sorry --non-trivial
lemma new_lemma_79674 (h0 : function.extfun (finset Type) (has_mem.mem (has_emptyc to_additive.value_type))) : @is_domain.{0} (has_emptyc.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type ring.{0} (has_emptyc.{0} to_additive.value_type) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_emptyc.{0} to_additive.value_type)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_79675 (h0 : ring (has_add (boolean_algebra Type))) : rank_condition (has_add (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_79676 (h0 : add_group (option (complete_linear_order num))) : is_add_cyclic (option (complete_linear_order num)) := sorry --non-trivial
lemma new_lemma_79677 (h0 : functor.add_const (function.extfun Type complete_lattice) Type) : @is_compactly_generated.{0} (has_zero.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type complete_lattice.{0}) Type h0) (has_zero.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_79678 (h0 : functor.add_const (group (has_bot linarith.comp)) real) : @normalizer_condition.{0} (has_bot.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (has_bot.{0} linarith.comp)) real h0)  := sorry --non-trivial
lemma new_lemma_79679 (h0 : ring (has_compl (random_gen (semi_normed_ring linarith.comp_source)))) : strong_rank_condition (has_compl (random_gen (semi_normed_ring linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_79680 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_79681 (h0 : topological_space (sub_neg_monoid (ring pos))) : irreducible_space (sub_neg_monoid (ring pos)) := sorry --non-trivial
lemma new_lemma_79682 (h0 : group (add_comm_monoid unsigned)) : is_cyclic (add_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_79683 (h0 : topological_space (has_add (comm_group (comm_group (has_to_string Type))))) : regular_space (has_add (comm_group (comm_group (has_to_string Type)))) := sorry --non-trivial
lemma new_lemma_79684 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} ennreal (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) ennreal)  := sorry --non-trivial
lemma new_lemma_79685 (h1 : topological_space (with_one num)) : irreducible_space (with_one num) := sorry --non-trivial
lemma new_lemma_79686 (h0 : finset (has_nndist (has_add (boolean_algebra Type)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_79687 (h0 : filter (semigroup (has_to_string pos))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_79688 (h0 : semiring (finset (ring (has_to_string linarith.comp)))) : is_noetherian_ring (finset (ring (has_to_string linarith.comp))) := sorry --non-trivial
lemma new_lemma_79689 (h1 : topological_space (linear_ordered_comm_group_with_zero string_imp)) : t0_space (linear_ordered_comm_group_with_zero string_imp) := sorry --non-trivial
lemma new_lemma_79690 (h0 : topological_space Type -> Prop) : @irreducible_space.{1} Type (@classical.epsilon.{2} (topological_space.{1} Type) (@nonempty_of_inhabited.{2} (topological_space.{1} Type) (@inhabited_topological_space.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_79691 (h0 : uniform_space (has_norm unsigned)) : complete_space (has_norm unsigned) := sorry --non-trivial
lemma new_lemma_79692 (h0 : topological_space (has_to_string (option num))) : t1_space (has_to_string (option num)) := sorry --non-trivial
lemma new_lemma_79693 (h0 : group (with_one (random_gen string_imp))) : group.fg (with_one (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_79694 (h0 : char -> char -> Prop) : is_incomp_trans char h0 := sorry --non-trivial
lemma new_lemma_79695 (h0 : fin has_zero.zero) : @is_domain.{0} (canonically_ordered_monoid.{0} (has_bot.{0} real)) (@matrix.vec_empty.{0} (ring.{0} (canonically_ordered_monoid.{0} (has_bot.{0} real))) h0)  := sorry --non-trivial
lemma new_lemma_79696 (h0 : group (with_one (semiring (semiring num)))) : group.fg (with_one (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_79697 (h0 : functor.comp topological_space has_neg_part name) : @preirreducible_space.{0} (has_neg_part.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg_part.{0} name h0)  := sorry --non-trivial
lemma new_lemma_79698 (h1 : filter (with_one fun_info)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_79699 (h0 : function.extfun (finset Type) (has_mem.mem real.angle)) : @is_compactly_generated.{0} real.angle (@finset.pi.empty.{1 0} Type complete_lattice.{0} real.angle (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) real.angle) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_79700 (h1 : topological_space (fintype (has_ssubset string_imp))) : totally_disconnected_space (fintype (has_ssubset string_imp)) := sorry --non-trivial
lemma new_lemma_79701 (h0 : add_group (denumerable char)) : is_add_cyclic (denumerable char) := sorry --non-trivial
lemma new_lemma_79702 (h1 : topological_space (mul_one_class std_gen)) : t0_space (mul_one_class std_gen) := sorry --non-trivial
lemma new_lemma_79703 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_79704 (h0 : fun_info -> fun_info -> Prop) (h1 : set fun_info) : is_strong_antichain h0 h1 := sorry --non-trivial
lemma new_lemma_79705 (h0 : topological_space (measurable_space empty)) : totally_disconnected_space (measurable_space empty) := sorry --non-trivial
lemma new_lemma_79706 (h0 : set (add_comm_semigroup ereal -> uniform_space.core ereal)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_79707 (h0 : functor.add_const (topological_space (add_cancel_monoid pos)) ennreal) : @topological_space.separable_space.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} pos)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_79708 (h0 : functor.add_const (add_monoid (normed_comm_ring pos)) (has_add pos)) : @add_monoid.fg.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (add_monoid.{0} (normed_comm_ring.{0} pos)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_79709 (h0 : complete_lattice (has_add (normed_comm_ring (finset pos)))) : complete_lattice.is_Sup_finite_compact (has_add (normed_comm_ring (finset pos))) := sorry --non-trivial
lemma new_lemma_79710 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (preorder.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (preorder.{0} num))  := sorry --non-trivial
lemma new_lemma_79711 (h0 : topological_space (ring (has_neg (has_neg Type)))) : t0_space (ring (has_neg (has_neg Type))) := sorry --non-trivial
lemma new_lemma_79712 (h0 : topological_space (metric_space (semiring (semiring empty)))) : path_connected_space (metric_space (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_79713 (h0 : functor.add_const (topological_space (mul_zero_class environment.implicit_infer_kind)) name) : @irreducible_space.{0} (mul_zero_class.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_79714 (h0 : functor.add_const (topological_space (semigroup pos)) name) : @preconnected_space.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_79715 (h0 : finset (has_neg num)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_79716 (h0 : topological_space (uniform_space (metric_space to_additive.value_type))) : path_connected_space (uniform_space (metric_space to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_79717 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (complete_semilattice_Sup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_79718 (h0 : ring (simple_graph (has_neg (ring name)))) : strong_rank_condition (simple_graph (has_neg (ring name))) := sorry --non-trivial
lemma new_lemma_79719 (h0 : topological_space (measurable_space (has_norm fun_info))) : totally_disconnected_space (measurable_space (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_79720 (h1 : monoid linarith.comp_source) : monoid.fg linarith.comp_source := sorry --non-trivial
lemma new_lemma_79721 (h0 : ring (has_norm (has_inv to_additive.value_type))) : is_domain (has_norm (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_79722 (h0 : not (ring (comm_ring linarith.ineq) -> false)) : @is_domain.{0} (comm_ring.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (comm_ring.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_79723 (h0 : topological_space (sub_neg_monoid (has_Inf linarith.comp))) : locally_compact_space (sub_neg_monoid (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_79724 (h0 : not (uniform_space (normed_field (has_ssubset (has_ssubset (has_ssubset char)))) -> false)) : @complete_space.{0} (normed_field.{0} (has_ssubset.{0} (has_ssubset.{0} (has_ssubset.{0} char)))) (@classical.by_contradiction'.{1} (uniform_space.{0} (normed_field.{0} (has_ssubset.{0} (has_ssubset.{0} (has_ssubset.{0} char))))) h0)  := sorry --non-trivial
lemma new_lemma_79725 (h0 : functor.add_const (topological_space (boolean_algebra.core ennreal)) pos) : @totally_separated_space.{0} (boolean_algebra.core.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} ennreal)) pos h0)  := sorry --non-trivial
lemma new_lemma_79726 (h0 : topological_space (ordered_comm_monoid (has_pos_part Type))) : discrete_topology (ordered_comm_monoid (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_79727 (h0 : functor.add_const (topological_space (option unsigned)) num) : @t1_space.{0} (option.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_79728 (h0 : topological_space (has_repr (has_neg linarith.comp))) : loc_path_connected_space (has_repr (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_79729 (h2 : topological_space (random_gen to_additive.value_type)) : t0_space (random_gen to_additive.value_type) := sorry --non-trivial
lemma new_lemma_79730 (h0 : order_hom nat (topological_space (normed_field string_imp))) : @t0_space.{0} (normed_field.{0} string_imp) (@monotonic_sequence_limit.{0} (topological_space.{0} (normed_field.{0} string_imp)) (@topological_space.partial_order.{0} (normed_field.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_79731 (h0 : ring (semi_normed_ring (mul_one_class linarith.comp_source))) : strong_rank_condition (semi_normed_ring (mul_one_class linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_79732 (h0 : ring (dlist (has_nnnorm (has_nnnorm (random_gen linarith.ineq))))) : rank_condition (dlist (has_nnnorm (has_nnnorm (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_79733 (h0 : list (has_pos_part (finset linarith.comp))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_79734 (h0 : not (topological_space (with_one to_additive.value_type) -> false)) : @path_connected_space.{0} (with_one.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (with_one.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_79735 (h0 : topological_space (has_pos_part (has_Inf (canonically_linear_ordered_monoid pos)))) : preirreducible_space (has_pos_part (has_Inf (canonically_linear_ordered_monoid pos))) := sorry --non-trivial
lemma new_lemma_79736 (h0 : add_group (simple_graph reducibility_hints)) : is_add_cyclic (simple_graph reducibility_hints) := sorry --non-trivial
lemma new_lemma_79737 (h0 : topological_space (boolean_algebra.core (normed_comm_ring Type))) : loc_path_connected_space (boolean_algebra.core (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_79738 (h0 : functor.add_const (list (add_comm_monoid pos)) Type) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_79739 (h0 : not (complete_lattice (comm_ring linarith.comp_source) -> false)) : @is_compactly_generated.{0} (comm_ring.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (complete_lattice.{0} (comm_ring.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_79740 (h0 : function.extfun Type group) : @is_cyclic.{0} (distrib_lattice.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} h0 (distrib_lattice.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_79741 (h0 : uniform_space (uniform_space (add_comm_monoid string_imp))) : complete_space (uniform_space (add_comm_monoid string_imp)) := sorry --non-trivial
lemma new_lemma_79742 (h0 : list (canonically_ordered_comm_semiring num)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_79743 (h0 : fin has_zero.zero) : @group.fg.{0} (complete_distrib_lattice.{0} pos) (@matrix.vec_empty.{0} (group.{0} (complete_distrib_lattice.{0} pos)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_79744 (h0 : ring (normed_group linarith.comp)) : strong_rank_condition (normed_group linarith.comp) := sorry --non-trivial
lemma new_lemma_79745 (h0 : functor.add_const (ordered_comm_monoid (has_zero linarith.comp)) unsigned) : @has_exists_mul_of_le.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_zero.{0} linarith.comp)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_79746 (h0 : topological_space (has_neg (normed_comm_ring name))) : path_connected_space (has_neg (normed_comm_ring name)) := sorry --non-trivial
lemma new_lemma_79747 (h0 : function.extfun Type measurable_space) (h1 : function.extfun Type has_mul) : @has_measurable_mul.{0} (@id.{2} Type linarith.comp_source) (@function.extfun_app.{2 1} Type measurable_space.{0} h0 (@id.{2} Type linarith.comp_source)) (@function.extfun_app.{2 1} Type has_mul.{0} h1 (@id.{2} Type linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_79748 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @normalizer_condition.{1} (ordered_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 group.{1}) (ordered_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_79749 (h0 : not (ring (with_zero to_additive.value_type) -> false)) : @is_domain.{0} (with_zero.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (with_zero.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_79750 (h0 : functor.add_const (group (add_comm_monoid environment.implicit_infer_kind)) name) : @normalizer_condition.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (add_comm_monoid.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_79751 (h0 : has_mem.mem fun_info has_emptyc.emptyc) : @locally_compact_space.{0} fun_info (@finset.pi.empty.{1 0} Type topological_space.{0} fun_info h0)  := sorry --non-trivial
lemma new_lemma_79752 (h0 : topological_space (complete_semilattice_Sup (semiring empty))) : t1_space (complete_semilattice_Sup (semiring empty)) := sorry --non-trivial
lemma new_lemma_79753 (h0 : group (complete_semilattice_Sup (random_gen linarith.comp_source))) : normalizer_condition (complete_semilattice_Sup (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_79754 (h0 : functor.add_const (filter (has_to_string pos)) (finset environment.implicit_infer_kind)) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_79755 (h0 : uniform_space (ordered_comm_ring name)) : separated_space (ordered_comm_ring name) := sorry --non-trivial
lemma new_lemma_79756 (h0 : fin has_zero.zero) : @preirreducible_space.{0} (sub_neg_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (sub_neg_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_79757 (h0 : add_group (has_norm linarith.ineq)) : is_add_cyclic (has_norm linarith.ineq) := sorry --non-trivial
lemma new_lemma_79758 (h0 : fin has_zero.zero) : @has_exists_mul_of_le.{1} (boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (ordered_comm_monoid.{1} (boolean_algebra.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_79759 (h0 : functor.add_const (add_group (has_nndist Type)) name) : @is_add_cyclic.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (add_group.{1} (has_nndist.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_79760 (h0 : functor.comp topological_space has_zero Type) : @preirreducible_space.{1} (has_zero.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} has_zero.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_79761 (h0 : functor.add_const (ordered_comm_monoid (complete_distrib_lattice Type)) unsigned) : @has_exists_mul_of_le.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 0} (ordered_comm_monoid.{1} (complete_distrib_lattice.{1} Type)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_79762 (h0 : functor.add_const (complete_lattice (left_cancel_monoid unsigned)) congr_arg_kind) : @is_compactly_generated.{0} (left_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (left_cancel_monoid.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_79763 (h0 : functor.add_const (topological_space (ring pos)) linarith.comp) : @discrete_topology.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_79764 (h0 : functor.add_const (ordered_add_comm_monoid (ordered_comm_monoid real)) real) : @archimedean.{0} (ordered_comm_monoid.{0} real) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (ordered_comm_monoid.{0} real)) real h0)  := sorry --non-trivial
lemma new_lemma_79765 (h0 : topological_space (ordered_comm_ring (has_add (has_Inf (has_add name))))) : preirreducible_space (ordered_comm_ring (has_add (has_Inf (has_add name)))) := sorry --non-trivial
lemma new_lemma_79766 (h0 : filter (add_left_cancel_monoid (has_nnnorm linarith.ineq))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_79767 (h0 : not (function.extfun Type add_monoid -> false)) : @add_monoid.fg.{0} (has_union.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_monoid.{0}) h0) (has_union.{0} empty))  := sorry --non-trivial
lemma new_lemma_79768 (h0 : ring (canonically_ordered_comm_semiring (option (option (option empty))))) : strong_rank_condition (canonically_ordered_comm_semiring (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_79769 (h0 : ring (linear_ordered_comm_group ennreal)) : is_domain (linear_ordered_comm_group ennreal) := sorry --non-trivial
lemma new_lemma_79770 (h0 : not (ring (has_norm linarith.comp_source) -> false)) : @strong_rank_condition.{0} (has_norm.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (has_norm.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_79771 (h0 : functor.add_const (topological_space (boolean_algebra pos)) (ring Type)) : @preirreducible_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.{0} pos)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_79772 (h0 : functor.add_const (topological_space (left_cancel_monoid unsigned)) unsigned) : @loc_path_connected_space.{0} (left_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_79773 (h0 : topological_space (has_pos_part (has_add (has_add linarith.comp)))) : discrete_topology (has_pos_part (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_79774 (h0 : finset (add_comm_monoid (has_add (has_add (has_add (has_add (has_add pos))))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_79775 (h0 : not (prod (complete_semilattice_Sup unsigned) (complete_semilattice_Sup unsigned) -> false)) : id_rel (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_79776 (h0 : group (id (has_norm unsigned))) : normalizer_condition (id (has_norm unsigned)) := sorry --non-trivial
lemma new_lemma_79777 (h0 : ring (generalized_boolean_algebra (has_add linarith.comp))) : is_principal_ideal_ring (generalized_boolean_algebra (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_79778 (h0 : uniform_space (as_linear_order (complete_distrib_lattice unsigned))) : complete_space (as_linear_order (complete_distrib_lattice unsigned)) := sorry --non-trivial
lemma new_lemma_79779 (h1 : filter (fintype (topological_space (comm_ring (distrib_lattice char))))) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_79780 (h0 : functor.comp ordered_comm_monoid has_to_string Type) : @has_exists_mul_of_le.{1} (has_to_string.{1} Type) (@functor.comp.run.{1 1 1} ordered_comm_monoid.{1} has_to_string.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_79781 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : monoid.fg nnreal := sorry --non-trivial
lemma new_lemma_79782 (h0 : group (id (has_top (random_gen linarith.ineq)))) : group.fg (id (has_top (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_79783 (h0 : uniform_space (complete_distrib_lattice empty)) : separated_space (complete_distrib_lattice empty) := sorry --non-trivial
lemma new_lemma_79784 (h0 : function.extfun Type topological_space) : @t0_space.{0} (div_inv_monoid.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (div_inv_monoid.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_79785 (h0 : functor.add_const (topological_space (semigroup unsigned)) (has_add name)) : @sequential_space.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} unsigned)) (has_add.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_79786 (h0 : has_lt (has_le string.iterator_imp)) : no_max_order (has_le string.iterator_imp) := sorry --non-trivial
lemma new_lemma_79787 (h0 : function.extfun Type topological_space) : @normal_space.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_79788 (h1 : topological_space (nondiscrete_normed_field (mul_one_class enat))) (h2 : set (nondiscrete_normed_field (mul_one_class enat))) : is_path_connected h2 := sorry --non-trivial
lemma new_lemma_79789 (h0 : function.extfun (Type 1) ring) : @rank_condition.{1} (canonically_ordered_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (canonically_ordered_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_79790 (h0 : functor.add_const (topological_space (ring name)) name) : @t1_space.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_79791 (h0 : finset (ring (option (option (option unsigned))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_79792 (h1 : add_group (add_monoid fun_info)) : is_add_cyclic (add_monoid fun_info) := sorry --non-trivial
lemma new_lemma_79793 (h0 : function.extfun (finset ((Type -> Type) -> Type 1)) (has_mem.mem (function.extfun Type))) : @irreducible_space.{0} (random_gen.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@finset.pi.empty.{2 1} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) (function.extfun.{2 1} Type) (@function.extfun_app.{3 0} (finset.{2} ((Type → Type) → Type 1)) (@has_mem.mem.{2 2} ((Type → Type) → Type 1) (finset.{2} ((Type → Type) → Type 1)) (@finset.has_mem.{2} ((Type → Type) → Type 1)) (function.extfun.{2 1} Type)) h0 (@has_emptyc.emptyc.{2} (finset.{2} ((Type → Type) → Type 1)) (@finset.has_emptyc.{2} ((Type → Type) → Type 1))))) topological_space.{0}) (random_gen.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_79794 (h0 : not (function.extfun Type group -> false)) : @group.fg.{0} linarith.comp (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) linarith.comp)  := sorry --non-trivial
lemma new_lemma_79795 (h0 : functor.add_const (finset (has_neg pos)) linarith.comp) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_79796 (h0 : not (list string_imp -> false)) : list.nodup (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_79797 (h0 : topological_space (option (option ennreal))) : preconnected_space (option (option ennreal)) := sorry --non-trivial
lemma new_lemma_79798 (h0 : functor.add_const (topological_space (add_comm_monoid name)) (has_to_string Type)) : @totally_disconnected_space.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (add_comm_monoid.{0} name)) (has_to_string.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_79799 (h0 : not (topological_space (has_top num) -> false)) : @totally_disconnected_space.{0} (has_top.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (has_top.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_79800 (h0 : functor.add_const (ring (has_neg pos)) environment.implicit_infer_kind) : @is_domain.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_neg.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_79801 (h0 : topological_space (semiring fun_info)) : totally_disconnected_space (semiring fun_info) := sorry --non-trivial
lemma new_lemma_79802 (h0 : functor.add_const Prop (complete_distrib_lattice (ring (ring linarith.comp)))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_79803 (h0 : ordered_add_comm_monoid (linear_ordered_comm_group (option (option (option ennreal))))) : archimedean (linear_ordered_comm_group (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_79804 (h0 : topological_space (add_right_cancel_monoid empty)) : normal_space (add_right_cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_79805 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} (with_bot.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (with_bot.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_79806 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (monoid_with_zero.{0} ennreal) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (monoid_with_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_79807 (h0 : list (linear_ordered_field (option (option (has_add name))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_79808 (h1 : ring (topological_space (metric_space (metric_space char)))) : is_domain (topological_space (metric_space (metric_space char))) := sorry --non-trivial
lemma new_lemma_79809 (h0 : ordered_comm_monoid (semigroup (finset Type))) : has_exists_mul_of_le (semigroup (finset Type)) := sorry --non-trivial
lemma new_lemma_79810 (h0 : topological_space (normed_comm_ring (finset (finset (ring (ring (ring linarith.comp))))))) : totally_disconnected_space (normed_comm_ring (finset (finset (ring (ring (ring linarith.comp)))))) := sorry --non-trivial
lemma new_lemma_79811 (h0 : topological_space (finset (monoid ennreal))) : regular_space (finset (monoid ennreal)) := sorry --non-trivial
lemma new_lemma_79812 (h0 : group linarith.ineq) (h1 : subgroup linarith.ineq) : subgroup.normal h1 := sorry --non-trivial
lemma new_lemma_79813 (h0 : functor.add_const (function.extfun Type group) (ring Type)) : @is_cyclic.{0} (has_Inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type group.{0}) (ring.{1} Type) h0) (has_Inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_79814 (h0 : fin has_zero.zero) : @group.fg.{0} (ordered_comm_monoid.{0} real) (@matrix.vec_empty.{0} (group.{0} (ordered_comm_monoid.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_79815 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (linear_ordered_field.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (linear_ordered_field.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_79816 (h2 : topological_space (denumerable char)) : path_connected_space (denumerable char) := sorry --non-trivial
lemma new_lemma_79817 (h0 : ordered_add_comm_monoid (boolean_algebra (has_add (has_neg_part (has_add name))))) : archimedean (boolean_algebra (has_add (has_neg_part (has_add name)))) := sorry --non-trivial
lemma new_lemma_79818 (h0 : topological_space (has_add (has_Inf (ordered_ring linarith.comp)))) : normal_space (has_add (has_Inf (ordered_ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_79819 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (has_dist ennreal)) := sorry --non-trivial
lemma new_lemma_79820 (h0 : topological_space (semigroup (has_neg_part name))) : locally_compact_space (semigroup (has_neg_part name)) := sorry --non-trivial
lemma new_lemma_79821 (h0 : topological_space (add_comm_monoid (has_to_string Type))) : totally_disconnected_space (add_comm_monoid (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_79822 (h0 : group (canonically_ordered_comm_semiring ennreal)) : is_simple_group (canonically_ordered_comm_semiring ennreal) := sorry --non-trivial
lemma new_lemma_79823 (h0 : functor.add_const (topological_space (has_zero unsigned)) linarith.comp) : @path_connected_space.{0} (has_zero.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_79824 (h0 : not (function.extfun Type group -> false)) : @group.fg.{0} (with_one.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (with_one.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_79825 (h0 : functor.add_const (ordered_comm_monoid (ring pos)) (ring (finset linarith.comp))) : @has_exists_mul_of_le.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (ring.{0} pos)) (ring.{0} (finset.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_79826 (h0 : measurable_space (with_zero char)) (h1 : has_sup (with_zero char)) : has_measurable_sup (with_zero char) := sorry --non-trivial
lemma new_lemma_79827 (h0 : topological_space (add_group (semiring num))) : locally_compact_space (add_group (semiring num)) := sorry --non-trivial
lemma new_lemma_79828 (h0 : set (enat -> mul_one_class (mul_one_class (mul_one_class (mul_one_class std_gen))))) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_79829 (h0 : topological_space (boolean_algebra (has_neg (has_neg pos)))) : preconnected_space (boolean_algebra (has_neg (has_neg pos))) := sorry --non-trivial
lemma new_lemma_79830 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (normed_comm_ring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_79831 (h0 : filter (has_zero linarith.comp)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_79832 (h1 : topological_space environment.projection_info) (h2 : preorder environment.projection_info) : order_closed_topology environment.projection_info := sorry --non-trivial
lemma new_lemma_79833 (h0 h1 : list Prop) : list.head (list.append h0 h1) := sorry --non-trivial
lemma new_lemma_79834 (h0 : function.extfun Type group) : @is_cyclic.{0} (metric_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (metric_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_79835 (h0 : topological_space (normed_comm_ring (option (option pos)))) : topological_space.separable_space (normed_comm_ring (option (option pos))) := sorry --non-trivial
lemma new_lemma_79836 (h0 : functor.add_const (topological_space (has_zero name)) Type) : @t1_space.{0} (has_zero.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (has_zero.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_79837 (h0 : functor.add_const (complete_lattice (has_zero linarith.comp)) pos) : @complete_lattice.is_Sup_finite_compact.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_zero.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_79838 (h0 : monoid (distrib_lattice (random_gen fun_info))) : monoid.fg (distrib_lattice (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_79839 (h0 : not (topological_space (add_right_cancel_monoid congr_arg_kind) -> false)) : @totally_disconnected_space.{0} (add_right_cancel_monoid.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (add_right_cancel_monoid.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_79840 (h0 : group (cancel_monoid (boolean_algebra Type))) : normalizer_condition (cancel_monoid (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_79841 (h0 : ring (has_emptyc (random_gen to_additive.value_type))) : strong_rank_condition (has_emptyc (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_79842 (h0 : complete_lattice (comm_ring fun_info)) : is_compactly_generated (comm_ring fun_info) := sorry --non-trivial
lemma new_lemma_79843 (h0 : not (topological_space (linear_ordered_add_comm_group linarith.comp_source) -> false)) : @t0_space.{0} (linear_ordered_add_comm_group.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_add_comm_group.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_79844 (h0 : group (has_Inf pos)) : is_simple_group (has_Inf pos) := sorry --non-trivial
lemma new_lemma_79845 (h0 : functor.add_const (topological_space (ordered_comm_ring Type)) name) : @locally_compact_space.{1} (ordered_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ordered_comm_ring.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_79846 (h0 : uniform_space (nondiscrete_normed_field (add_comm_semigroup (add_comm_semigroup linarith.ineq)))) : complete_space (nondiscrete_normed_field (add_comm_semigroup (add_comm_semigroup linarith.ineq))) := sorry --non-trivial
lemma new_lemma_79847 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (normed_comm_ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_79848 (h0 : ring (canonically_ordered_comm_semiring (has_Inf linarith.comp))) : is_domain (canonically_ordered_comm_semiring (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_79849 (h0 : group (normed_lattice_add_comm_group (has_Inf real))) : is_cyclic (normed_lattice_add_comm_group (has_Inf real)) := sorry --non-trivial
lemma new_lemma_79850 (h0 : semiring (id (has_norm congr_arg_kind))) : is_noetherian_ring (id (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_79851 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @preconnected_space.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_79852 (h0 : group (has_add (add_comm_monoid pos))) : normalizer_condition (has_add (add_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_79853 (h0 : function.extfun Type topological_space) : @t0_space.{0} (normed_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_79854 (h0 : topological_space (simple_graph num)) : locally_compact_space (simple_graph num) := sorry --non-trivial
lemma new_lemma_79855 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (bin_tree.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (bin_tree.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_79856 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} (normed_group.{0} num) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (normed_group.{0} num))  := sorry --non-trivial
lemma new_lemma_79857 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (has_pos_part.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_pos_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_79858 (h0 : topological_space (simple_graph (has_neg (has_neg name)))) : discrete_topology (simple_graph (has_neg (has_neg name))) := sorry --non-trivial
lemma new_lemma_79859 (h0 : complete_lattice (has_lt (has_div (normed_field to_additive.value_type)))) : complete_lattice.is_Sup_finite_compact (has_lt (has_div (normed_field to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_79860 (h0 : not (function.extfun Type semiring -> false)) : @is_noetherian_ring.{0} (has_one.{0} num) (@function.extfun_app.{2 1} Type semiring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type semiring.{0}) h0) (has_one.{0} num))  := sorry --non-trivial
lemma new_lemma_79861 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (normed_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (normed_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_79862 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @normal_space.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_79863 (h0 : topological_space (has_zero (normed_comm_ring Type))) : discrete_topology (has_zero (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_79864 (h0 : topological_space (canonically_ordered_monoid (has_bot real))) : preconnected_space (canonically_ordered_monoid (has_bot real)) := sorry --non-trivial
lemma new_lemma_79865 (h0 : filter (partial_order (option (option (option (option (option ennreal))))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_79866 (h0 : functor.add_const (add_group (linear_order empty)) unsigned) : @is_add_cyclic.{0} (linear_order.{0} empty) (@functor.add_const.run.{0 0} (add_group.{0} (linear_order.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_79867 (h0 : topological_space (ordered_comm_ring (has_neg (ring (ring (ring Type)))))) : preconnected_space (ordered_comm_ring (has_neg (ring (ring (ring Type))))) := sorry --non-trivial
lemma new_lemma_79868 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (boolean_algebra.core.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (boolean_algebra.core.{0} num))  := sorry --non-trivial
lemma new_lemma_79869 (h0 : fin has_zero.zero) : @unique_factorization_monoid.{1} (has_bot.{1} Type) (@matrix.vec_empty.{1} (cancel_comm_monoid_with_zero.{1} (has_bot.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_79870 (h0 : functor.add_const (topological_space (linear_ordered_cancel_comm_monoid num)) empty) : @t1_space.{0} (linear_ordered_cancel_comm_monoid.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_cancel_comm_monoid.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_79871 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (complete_distrib_lattice.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_distrib_lattice.{0} pos))  := sorry --non-trivial
lemma new_lemma_79872 (h0 : topological_space (generalized_boolean_algebra real)) : t0_space (generalized_boolean_algebra real) := sorry --non-trivial
lemma new_lemma_79873 (h0 : complete_lattice (add_comm_monoid congr_arg_kind)) : complete_lattice.is_Sup_finite_compact (add_comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_79874 (h0 : group (complete_distrib_lattice unsigned)) : normalizer_condition (complete_distrib_lattice unsigned) := sorry --non-trivial
lemma new_lemma_79875 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_79876 (h0 : complete_lattice (with_bot (semiring unsigned))) : is_compactly_generated (with_bot (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_79877 (h0 : add_monoid (has_one (semiring (random_gen unsigned)))) : add_monoid.fg (has_one (semiring (random_gen unsigned))) := sorry --non-trivial
lemma new_lemma_79878 (h0 : topological_space (has_add (finset linarith.comp))) : t1_space (has_add (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_79879 (h0 : ring (has_add (has_neg_part (has_neg_part (comm_group pos))))) : is_domain (has_add (has_neg_part (has_neg_part (comm_group pos)))) := sorry --non-trivial
lemma new_lemma_79880 (h0 : functor.add_const (complete_lattice (boolean_algebra.core name)) unsigned) : @is_compactly_generated.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (boolean_algebra.core.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_79881 (h0 : functor.add_const (ordered_add_comm_monoid (complete_distrib_lattice unsigned)) empty) : @archimedean.{0} (complete_distrib_lattice.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (complete_distrib_lattice.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_79882 (h0 : topological_space (has_neg environment.implicit_infer_kind)) : irreducible_space (has_neg environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_79883 (h0 : topological_space (has_Inf (ring Type))) : sequential_space (has_Inf (ring Type)) := sorry --non-trivial
lemma new_lemma_79884 (h0 : topological_space (canonically_ordered_comm_semiring empty)) : irreducible_space (canonically_ordered_comm_semiring empty) := sorry --non-trivial
lemma new_lemma_79885 (h0 : topological_space (generalized_boolean_algebra (ring name))) : normal_space (generalized_boolean_algebra (ring name)) := sorry --non-trivial
lemma new_lemma_79886 (h0 : functor.add_const (ordered_add_comm_monoid (generalized_boolean_algebra pos)) real) : @archimedean.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (generalized_boolean_algebra.{0} pos)) real h0)  := sorry --non-trivial
lemma new_lemma_79887 (h0 : uniform_space (add_group (has_top (semiring empty)))) : separated_space (add_group (has_top (semiring empty))) := sorry --non-trivial
lemma new_lemma_79888 (h0 : functor.add_const (group pos) (pseudo_metric_space (option name))) : @is_cyclic.{0} pos (@functor.add_const.run.{0 0} (group.{0} pos) (pseudo_metric_space.{0} (option.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_79889 (h0 : complete_lattice (has_neg_part (has_add pos))) : is_compactly_generated (has_neg_part (has_add pos)) := sorry --non-trivial
lemma new_lemma_79890 (h0 : cancel_comm_monoid_with_zero (has_Inf (has_to_string Type))) : unique_factorization_monoid (has_Inf (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_79891 (h0 : topological_space (nondiscrete_normed_field enat)) (h1 : set (nondiscrete_normed_field enat)) : is_path_connected h1 := sorry --non-trivial
lemma new_lemma_79892 (h0 : bin_tree (filter Prop)) : @Lim.{0} Prop sierpinski_space (@nonempty_of_inhabited.{1} Prop sort.inhabited.{0}) (@list.head.{0} (filter.{0} Prop) (@filter.inhabited.{0} Prop) (@bin_tree.to_list.{0} (filter.{0} Prop) h0))  := sorry --non-trivial
lemma new_lemma_79893 (h0 : functor.add_const (finset (non_assoc_semiring empty)) (complete_distrib_lattice (option empty))) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_79894 (h0 : topological_space (comm_monoid (add_left_cancel_semigroup congr_arg_kind))) : preirreducible_space (comm_monoid (add_left_cancel_semigroup congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_79895 (h0 : topological_space (has_add (finset pos))) : irreducible_space (has_add (finset pos)) := sorry --non-trivial
lemma new_lemma_79896 (h0 : ring (semiring (random_gen fun_info))) : rank_condition (semiring (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_79897 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_79898 (h0 : topological_space (has_bot (has_add pos))) : t1_space (has_bot (has_add pos)) := sorry --non-trivial
lemma new_lemma_79899 (h0 : ordered_comm_monoid (has_zero ennreal)) : has_exists_mul_of_le (has_zero ennreal) := sorry --non-trivial
lemma new_lemma_79900 (h0 : function.extfun nat fin) : @is_domain.{0} (measurable_space.{0} (semiring.{0} linarith.comp)) (@matrix.vec_empty.{0} (ring.{0} (measurable_space.{0} (semiring.{0} linarith.comp))) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_79901 (h0 : functor.add_const (ring (partial_order congr_arg_kind)) num) : @rank_condition.{0} (partial_order.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ring.{0} (partial_order.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_79902 (h0 : function.extfun nat fin) : @is_noetherian_ring.{1} (sub_neg_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) semiring.{1} (@matrix.vec_empty.{2} (function.extfun.{3 2} (Type 1) semiring.{1}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (sub_neg_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_79903 (h0 : group (has_add (with_zero linarith.ineq))) : is_cyclic (has_add (with_zero linarith.ineq)) := sorry --non-trivial
lemma new_lemma_79904 (h0 : cancel_comm_monoid_with_zero (add_cancel_monoid (option empty))) : unique_factorization_monoid (add_cancel_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_79905 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_to_string.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_to_string.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_79906 (h0 : functor.add_const (uniform_space (has_nndist unsigned)) unsigned) : @complete_space.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_nndist.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_79907 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_neg.{0} (finset.{0} pos)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} (finset.{0} pos)))  := sorry --non-trivial
lemma new_lemma_79908 (h0 : list (boolean_algebra.core (option (option ennreal)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_79909 (h0 : semiring (has_to_string (has_add unsigned))) : is_noetherian_ring (has_to_string (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_79910 (h0 : topological_space (option num)) : preconnected_space (option num) := sorry --non-trivial
lemma new_lemma_79911 (h0 : group (non_assoc_semiring congr_arg_kind)) : normalizer_condition (non_assoc_semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_79912 (h0 : topological_space (boolean_algebra (boolean_algebra.core (has_add (has_add Type))))) : sequential_space (boolean_algebra (boolean_algebra.core (has_add (has_add Type)))) := sorry --non-trivial
lemma new_lemma_79913 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (mul_zero_class.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (mul_zero_class.{0} name))  := sorry --non-trivial
lemma new_lemma_79914 (h0 : uniform_space (uniform_space empty)) : separated_space (uniform_space empty) := sorry --non-trivial
lemma new_lemma_79915 (h0 : nnreal -> Prop) (h1 : filter nnreal) : filter.frequently h0 h1 := sorry --non-trivial
lemma new_lemma_79916 (h0 : functor.add_const (semiring (ordered_comm_monoid linarith.comp)) pos) : @is_noetherian_ring.{0} (ordered_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (semiring.{0} (ordered_comm_monoid.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_79917 (h1 : function.extfun Type topological_space) : @locally_compact_space.{0} (semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_79918 (h0 : topological_space (monoid unsigned)) : topological_space.separable_space (monoid unsigned) := sorry --non-trivial
lemma new_lemma_79919 (h0 : complete_lattice (sub_neg_monoid (has_add real))) : complete_lattice.is_Sup_finite_compact (sub_neg_monoid (has_add real)) := sorry --non-trivial
lemma new_lemma_79920 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (measurable_space.dynkin_system unsigned)) := sorry --non-trivial
lemma new_lemma_79921 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (has_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (has_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_79922 (h0 : ring (has_inter linarith.comp_source)) : is_domain (has_inter linarith.comp_source) := sorry --non-trivial
lemma new_lemma_79923 (h0 : function.extfun Type group) : @group.fg.{0} (has_to_string.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (has_to_string.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_79924 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (linear_ordered_semiring.{0} fun_info) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (linear_ordered_semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_79925 (h0 : functor.add_const (function.extfun Type list) num) : list.nodup (function.extfun_app (functor.add_const.run h0) (add_cancel_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_79926 (h0 : functor.add_const (ordered_add_comm_monoid (boolean_algebra linarith.comp)) environment.implicit_infer_kind) : @archimedean.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (boolean_algebra.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_79927 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (left_cancel_semigroup.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (left_cancel_semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_79928 (h0 : topological_space (has_add to_additive.value_type)) : locally_compact_space (has_add to_additive.value_type) := sorry --non-trivial
lemma new_lemma_79929 (h0 : topological_space (has_neg (has_Inf pos))) : topological_space.separable_space (has_neg (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_79930 (h1 : has_coe (add_comm_semigroup ereal) Prop) (h2 : add_comm_semigroup ereal) : @coe_b.{1 1} (add_comm_semigroup.{0} ereal) Prop h1 h2  := sorry --non-trivial
lemma new_lemma_79931 (h0 : topological_space (canonically_ordered_comm_semiring (has_add pos))) : irreducible_space (canonically_ordered_comm_semiring (has_add pos)) := sorry --non-trivial
lemma new_lemma_79932 (h0 : pnat) (h1 : fin has_zero.zero) : pnat.coprime h0 (id (ulower.up (id (matrix.vec_empty h1)))) := sorry --non-trivial
lemma new_lemma_79933 (h0 : ring (mul_zero_class (semiring congr_arg_kind))) : is_domain (mul_zero_class (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_79934 (h0 : has_mem.mem (normed_group linarith.comp_source) has_emptyc.emptyc) : @totally_disconnected_space.{0} (normed_group.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (normed_group.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_79935 (h0 : ring (has_bot (option empty))) : is_principal_ideal_ring (has_bot (option empty)) := sorry --non-trivial
lemma new_lemma_79936 (h0 : group (plift (semiring congr_arg_kind))) : group.fg (plift (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_79937 (h0 : functor.add_const (ring (has_nndist Type)) Type) : @strong_rank_condition.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 1} (ring.{1} (has_nndist.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_79938 (h0 : semiring (add_comm_monoid real)) : is_noetherian_ring (add_comm_monoid real) := sorry --non-trivial
lemma new_lemma_79939 (h0 : has_mem.mem list has_emptyc.emptyc) : list.head (function.extfun_app (finset.pi.empty (function.extfun Type) list h0) Prop) := sorry --non-trivial
lemma new_lemma_79940 (h0 : function.extfun (finset Type) (has_mem.mem (has_one empty))) : @path_connected_space.{0} (has_one.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_one.{0} empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_one.{0} empty)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_79941 (h0 : functor.comp topological_space mul_zero_class Type) : @totally_disconnected_space.{1} (mul_zero_class.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} mul_zero_class.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_79942 (h0 : function.extfun Type (functor.add_const Prop)) : functor.add_const.run (function.extfun_app h0 (has_neg_part name)) := sorry --non-trivial
lemma new_lemma_79943 (h0 : topological_space (linear_ordered_field congr_arg_kind)) : preirreducible_space (linear_ordered_field congr_arg_kind) := sorry --non-trivial
lemma new_lemma_79944 (h0 : functor.add_const (monoid (canonically_linear_ordered_monoid num)) num) : @monoid.fg.{0} (canonically_linear_ordered_monoid.{0} num) (@functor.add_const.run.{0 0} (monoid.{0} (canonically_linear_ordered_monoid.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_79945 (h0 : topological_space (semigroup (finset (has_add pos)))) : totally_separated_space (semigroup (finset (has_add pos))) := sorry --non-trivial
lemma new_lemma_79946 (h0 : complete_lattice (monoid congr_arg_kind)) : complete_lattice.is_Sup_finite_compact (monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_79947 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_nndist.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_79948 (h0 : add_group (normed_lattice_add_comm_group (has_Inf linarith.comp))) : is_add_cyclic (normed_lattice_add_comm_group (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_79949 (h0 : cancel_comm_monoid_with_zero (has_Inf (has_add Type))) : unique_factorization_monoid (has_Inf (has_add Type)) := sorry --non-trivial
lemma new_lemma_79950 (h0 : uniform_space (has_lt linarith.ineq)) : complete_space (has_lt linarith.ineq) := sorry --non-trivial
lemma new_lemma_79951 (h0 : filter (has_add (finset (has_Inf pos)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_79952 (h0 : functor.add_const (ring (boolean_algebra unsigned)) linarith.comp) : @rank_condition.{0} (boolean_algebra.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_79953 (h0 : functor.add_const (ring (complete_distrib_lattice name)) name) : @is_principal_ideal_ring.{0} (complete_distrib_lattice.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (complete_distrib_lattice.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_79954 (h0 : not (function.extfun Type topological_space -> false)) : @discrete_topology.{0} (normed_group.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (normed_group.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_79955 (h0 : not (complete_lattice (measurable_space.dynkin_system unsigned) -> false)) : @is_atomistic.{0} (measurable_space.dynkin_system.{0} unsigned) (@classical.by_contradiction'.{1} (complete_lattice.{0} (measurable_space.dynkin_system.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_79956 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_norm.{0} linarith.ineq) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_norm.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_79957 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_79958 (h0 : add_monoid (has_one unsigned)) : add_monoid.fg (has_one unsigned) := sorry --non-trivial
lemma new_lemma_79959 (h0 : group (canonically_ordered_monoid (normed_lattice_add_comm_group (has_Inf linarith.comp)))) : is_cyclic (canonically_ordered_monoid (normed_lattice_add_comm_group (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_79960 (h0 : topological_space (add_comm_semigroup (add_comm_semigroup char))) : topological_space.first_countable_topology (add_comm_semigroup (add_comm_semigroup char)) := sorry --non-trivial
lemma new_lemma_79961 (h0 : functor.add_const (add_monoid (left_cancel_semigroup empty)) empty) : @add_monoid.fg.{0} (left_cancel_semigroup.{0} empty) (@functor.add_const.run.{0 0} (add_monoid.{0} (left_cancel_semigroup.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_79962 (h0 : function.extfun Type (functor.comp topological_space add_cancel_monoid)) : @discrete_topology.{0} (add_cancel_monoid.{0} unsigned) (@functor.comp.run.{0 0 0} topological_space.{0} add_cancel_monoid.{0} unsigned (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} add_cancel_monoid.{0}) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_79963 (h0 : ordered_add_comm_monoid (non_assoc_semiring num)) : archimedean (non_assoc_semiring num) := sorry --non-trivial
lemma new_lemma_79964 (h0 : topological_space (has_pos_part (has_nndist linarith.comp))) : normal_space (has_pos_part (has_nndist linarith.comp)) := sorry --non-trivial
lemma new_lemma_79965 (h0 : topological_space (mul_zero_class Type)) : totally_separated_space (mul_zero_class Type) := sorry --non-trivial
lemma new_lemma_79966 (h0 : add_group (with_one unsigned)) : is_add_cyclic (with_one unsigned) := sorry --non-trivial
lemma new_lemma_79967 (h0 : functor.add_const (ring (add_comm_monoid pos)) Type) : @strong_rank_condition.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (add_comm_monoid.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_79968 (h0 : ring (canonically_linear_ordered_monoid (sub_neg_monoid linarith.comp))) : rank_condition (canonically_linear_ordered_monoid (sub_neg_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_79969 (h0 : ring linarith.comp_source) : strong_rank_condition linarith.comp_source := sorry --non-trivial
lemma new_lemma_79970 (h0 : functor.add_const (semiring (normed_comm_ring Type)) (boolean_algebra pos)) : @is_noetherian_ring.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (semiring.{1} (normed_comm_ring.{1} Type)) (boolean_algebra.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_79971 (h0 : functor.add_const (ring (ordered_ring empty)) empty) : @is_domain.{0} (ordered_ring.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (ordered_ring.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_79972 (h0 : topological_space (add_semigroup (option unsigned))) : locally_compact_space (add_semigroup (option unsigned)) := sorry --non-trivial
lemma new_lemma_79973 (h0 : topological_space (sub_neg_monoid (has_add pos))) : path_connected_space (sub_neg_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_79974 (h1 : not (function.extfun Type topological_space -> false)) : @irreducible_space.{0} (complete_semilattice_Sup.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h1) (complete_semilattice_Sup.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_79975 (h0 : function.extfun Type topological_space) : @t0_space.{0} (mul_zero_class.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (mul_zero_class.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_79976 (h0 : ring (has_nnnorm (has_inv string_imp))) : rank_condition (has_nnnorm (has_inv string_imp)) := sorry --non-trivial
lemma new_lemma_79977 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (group_with_zero.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (group_with_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_79978 (h0 : add_monoid (comm_group (finset Type))) : add_monoid.fg (comm_group (finset Type)) := sorry --non-trivial
lemma new_lemma_79979 (h0 : group (ordered_comm_ring (has_Inf Type))) : is_simple_group (ordered_comm_ring (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_79980 (h1 : has_mem.mem (with_one linarith.comp) has_emptyc.emptyc) : @is_domain.{0} (with_one.{0} linarith.comp) (@finset.pi.empty.{1 0} Type ring.{0} (with_one.{0} linarith.comp) h1)  := sorry --non-trivial
lemma new_lemma_79981 (h0 : function.extfun Type topological_space) : @normal_space.{0} (has_Inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_Inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_79982 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_atomistic.{0} (has_union.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (has_union.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_79983 (h0 : functor.add_const (add_group (semigroup unsigned)) (semiring num)) : @is_add_cyclic.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (add_group.{0} (semigroup.{0} unsigned)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_79984 (h0 : ring (complete_distrib_lattice (ordered_comm_ring (has_Inf (ring (finset pos)))))) : strong_rank_condition (complete_distrib_lattice (ordered_comm_ring (has_Inf (ring (finset pos))))) := sorry --non-trivial
lemma new_lemma_79985 (h1 : group (with_one (has_top congr_arg_kind))) : normalizer_condition (with_one (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_79986 (h0 : ring (has_norm (random_gen linarith.comp_source))) : strong_rank_condition (has_norm (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_79987 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @irreducible_space.{0} (measurable_space.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (measurable_space.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_79988 (h0 : functor.add_const (cancel_comm_monoid_with_zero (add_group num)) num) : @unique_factorization_monoid.{0} (add_group.{0} num) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (add_group.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_79989 (h0 : functor.add_const (ordered_add_comm_monoid (comm_group Type)) pos) : @archimedean.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (ordered_add_comm_monoid.{1} (comm_group.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_79990 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} (with_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (with_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_79991 (h0 : function.extfun Type ring) : @is_domain.{0} (canonically_ordered_add_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (canonically_ordered_add_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_79992 (h0 : functor.add_const (monoid (non_assoc_semiring unsigned)) unsigned) : @monoid.fg.{0} (non_assoc_semiring.{0} unsigned) (@functor.add_const.run.{0 0} (monoid.{0} (non_assoc_semiring.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_79993 (h0 : functor.add_const (ring (as_linear_order empty)) (option empty)) : @is_principal_ideal_ring.{0} (as_linear_order.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (as_linear_order.{0} empty)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_79994 (h0 : topological_space (canonically_linear_ordered_monoid num)) : irreducible_space (canonically_linear_ordered_monoid num) := sorry --non-trivial
lemma new_lemma_79995 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_zero.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_79996 (h0 : functor.add_const (add_monoid (bin_tree unsigned)) empty) : @add_monoid.fg.{0} (bin_tree.{0} unsigned) (@functor.add_const.run.{0 0} (add_monoid.{0} (bin_tree.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_79997 (h0 : has_mem.mem (linear_ordered_add_comm_group linarith.ineq) has_emptyc.emptyc) : @locally_compact_space.{0} (linear_ordered_add_comm_group.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type topological_space.{0} (linear_ordered_add_comm_group.{0} linarith.ineq) h0)  := sorry --non-trivial
lemma new_lemma_79998 (h0 : topological_space (distrib enat)) (h2 : add_group (distrib enat)) : topological_add_group (distrib enat) := sorry --non-trivial
lemma new_lemma_79999 (h0 : functor.add_const (ordered_comm_monoid (canonically_ordered_comm_semiring ennreal)) pos) : @has_exists_mul_of_le.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (canonically_ordered_comm_semiring.{0} ennreal)) pos h0)  := sorry --non-trivial
