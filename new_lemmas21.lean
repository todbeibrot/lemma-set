import imports
lemma new_lemma_168000 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (complete_semilattice_Sup.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (complete_semilattice_Sup.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_168001 (h0 : topological_space (boolean_algebra.core (normed_comm_ring environment.implicit_infer_kind))) : preconnected_space (boolean_algebra.core (normed_comm_ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_168002 (h0 : group (comm_ring (random_gen (random_gen to_additive.value_type)))) : is_cyclic (comm_ring (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_168003 (h1 : list (with_one (random_gen to_additive.value_type))) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_168004 (h1 : topological_space (mul_one_class enat)) (h2 : add_group (mul_one_class enat)) : topological_add_group (mul_one_class enat) := sorry --non-trivial
lemma new_lemma_168005 (h0 h1 : multiset (uniform_space reducibility_hints)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_168006 (h0 : topological_space (complete_distrib_lattice (ring pos))) : t1_space (complete_distrib_lattice (ring pos)) := sorry --non-trivial
lemma new_lemma_168007 (h0 : monoid (with_bot (random_gen (random_gen (random_gen linarith.ineq))))) : monoid.fg (with_bot (random_gen (random_gen (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_168008 (h0 : functor.add_const (uniform_space (has_Inf name)) Type) : @complete_space.{0} (has_Inf.{0} name) (@functor.add_const.run.{0 1} (uniform_space.{0} (has_Inf.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_168009 (h0 : topological_space (has_neg (boolean_algebra name))) : t1_space (has_neg (boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_168010 (h0 : function.extfun Type topological_space) : @t0_space.{0} (@id.{2} Type fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (@id.{2} Type fun_info))  := sorry --non-trivial
lemma new_lemma_168011 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (comm_ring.{0} (has_nnnorm.{0} to_additive.value_type)) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (comm_ring.{0} (has_nnnorm.{0} to_additive.value_type)))  := sorry --non-trivial
lemma new_lemma_168012 (h0 : functor.add_const (topological_space (boolean_algebra Type)) environment.implicit_infer_kind) : @preconnected_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_168013 (h0 : ring congr_arg_kind) : is_principal_ideal_ring congr_arg_kind := sorry --non-trivial
lemma new_lemma_168014 (h0 : functor.add_const (function.extfun (Type 1) topological_space) Type) : @t0_space.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) Type h0) (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_168015 (h0 : functor.add_const (topological_space (non_assoc_semiring num)) empty) : @t0_space.{0} (non_assoc_semiring.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (non_assoc_semiring.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_168016 (h0 : ring (measurable_space (has_norm linarith.comp))) : is_domain (measurable_space (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_168017 (h0 : prod (metric_space (has_top (semiring (has_top unsigned)))) (metric_space (has_top (semiring (has_top unsigned))))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_168018 (h0 : has_mem.mem (linear_ordered_add_comm_group num) has_emptyc.emptyc) : @totally_separated_space.{0} (linear_ordered_add_comm_group.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (linear_ordered_add_comm_group.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_168019 (h0 : not (list (has_nnnorm linarith.ineq) -> false)) : list.nodup (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_168020 (h0 : complete_lattice (has_zero (finset ennreal))) : is_compactly_generated (has_zero (finset ennreal)) := sorry --non-trivial
lemma new_lemma_168021 (h0 : topological_space (add_comm_monoid unsigned)) : discrete_topology (add_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_168022 (h0 : functor.add_const (topological_space (mul_zero_class pos)) name) : @normal_space.{0} (mul_zero_class.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_168023 (h0 : ring (normed_field (has_nnnorm linarith.comp_source))) : is_domain (normed_field (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_168024 (h0 : functor.add_const (function.extfun Type list) linarith.comp) : list.nodup (function.extfun_app (functor.add_const.run h0) (semigroup linarith.comp)) := sorry --non-trivial
lemma new_lemma_168025 (h2 : set (ereal -> char)) : set.separates_points h2 := sorry --non-trivial
lemma new_lemma_168026 (h0 : not (has_lt (measurable_space.dynkin_system empty) -> false)) : no_min_order (measurable_space.dynkin_system empty) := sorry --non-trivial
lemma new_lemma_168027 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_nndist.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_nndist.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_168028 (h0 : list (boolean_algebra (has_neg_part Type))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_168029 (h0 : functor.add_const (filter (add_cancel_monoid unsigned)) (has_to_string (has_to_string Type))) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_168030 (h0 : complete_lattice fun_info) : complete_lattice.is_Sup_finite_compact fun_info := sorry --non-trivial
lemma new_lemma_168031 (h0 : group (boolean_algebra (has_to_string (has_neg_part Type)))) : group.fg (boolean_algebra (has_to_string (has_neg_part Type))) := sorry --non-trivial
lemma new_lemma_168032 (h1 : not (group (canonically_ordered_add_monoid char) -> false)) : @is_cyclic.{0} (canonically_ordered_add_monoid.{0} char) (@classical.by_contradiction'.{1} (group.{0} (canonically_ordered_add_monoid.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_168033 (h0 : not (add_group (denumerable fun_info) -> false)) : @is_add_cyclic.{0} (denumerable.{0} fun_info) (@classical.by_contradiction'.{1} (add_group.{0} (denumerable.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_168034 (h0 : functor.add_const (topological_space (normed_comm_ring Type)) pos) : @irreducible_space.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (normed_comm_ring.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_168035 (h0 : functor.add_const (add_monoid (has_nndist Type)) Type) : @add_monoid.fg.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 1} (add_monoid.{1} (has_nndist.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_168036 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (linear_ordered_add_comm_group.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (linear_ordered_add_comm_group.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_168037 (h0 : topological_space (pseudo_metric_space (add_comm_monoid (has_add (has_to_string pos))))) : normal_space (pseudo_metric_space (add_comm_monoid (has_add (has_to_string pos)))) := sorry --non-trivial
lemma new_lemma_168038 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} unsigned (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) unsigned)  := sorry --non-trivial
lemma new_lemma_168039 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (comm_ring.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (comm_ring.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_168040 (h0 : topological_space (complete_distrib_lattice unsigned)) : topological_space.separable_space (complete_distrib_lattice unsigned) := sorry --non-trivial
lemma new_lemma_168041 (h0 : topological_space (has_Inf (ring Type))) : irreducible_space (has_Inf (ring Type)) := sorry --non-trivial
lemma new_lemma_168042 (h0 : topological_space (has_top (random_gen num))) : totally_disconnected_space (has_top (random_gen num)) := sorry --non-trivial
lemma new_lemma_168043 (h0 : functor.add_const (filter (has_to_string pos)) (ring Type)) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_168044 (h0 : topological_space (add_comm_monoid num)) : preirreducible_space (add_comm_monoid num) := sorry --non-trivial
lemma new_lemma_168045 (h0 : group (complete_distrib_lattice (has_bot Type))) : is_simple_group (complete_distrib_lattice (has_bot Type)) := sorry --non-trivial
lemma new_lemma_168046 (h0 : topological_space (with_bot (random_gen to_additive.value_type))) : t0_space (with_bot (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_168047 (h0 : function.extfun Type ring) : @rank_condition.{0} (partial_order.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (partial_order.{0} num))  := sorry --non-trivial
lemma new_lemma_168048 (h0 : filter (has_zero (has_to_string (has_to_string pos)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_168049 (h0 : add_group (has_ssubset enat)) : is_add_cyclic (has_ssubset enat) := sorry --non-trivial
lemma new_lemma_168050 (h0 : list (complete_semilattice_Sup (has_norm (has_norm fun_info)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_168051 (h0 : functor.comp topological_space has_zero Type) : @irreducible_space.{1} (has_zero.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} has_zero.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_168052 (h0 : group (has_to_string pos)) : normalizer_condition (has_to_string pos) := sorry --non-trivial
lemma new_lemma_168053 (h0 : functor.add_const (topological_space ennreal) name) : topological_space.separable_space ennreal := sorry --non-trivial
lemma new_lemma_168054 (h0 : functor.add_const (complete_lattice (has_neg environment.implicit_infer_kind)) linarith.comp) : @complete_lattice.is_Sup_finite_compact.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_neg.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_168055 (h0 : functor.add_const (topological_space (has_add Type)) linarith.comp) : @path_connected_space.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_add.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_168056 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @has_exists_mul_of_le.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_comm_monoid.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ordered_comm_monoid.{1}) (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_168057 (h0 : ring (with_bot empty)) : is_domain (with_bot empty) := sorry --non-trivial
lemma new_lemma_168058 (h0 : semiring std_gen) (h1 : ideal std_gen) : ideal.is_prime h1 := sorry --non-trivial
lemma new_lemma_168059 (h0 : topological_space (has_norm empty)) : discrete_topology (has_norm empty) := sorry --non-trivial
lemma new_lemma_168060 (h0 : functor.add_const (topological_space (ordered_ring empty)) (semiring num)) : @irreducible_space.{0} (ordered_ring.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} empty)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_168061 (h0 h1 : list linarith.ineq) : list.is_infix h0 h1 := sorry --non-trivial
lemma new_lemma_168062 (h0 : function.extfun (finset Type) (has_mem.mem (semiring unsigned))) : @monoid.fg.{0} (semiring.{0} unsigned) (@finset.pi.empty.{1 0} Type monoid.{0} (semiring.{0} unsigned) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} unsigned)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_168063 (h0 : ring (has_neg pos)) : is_principal_ideal_ring (has_neg pos) := sorry --non-trivial
lemma new_lemma_168064 (h0 : semiring (canonically_ordered_comm_semiring (has_Inf linarith.comp))) : is_noetherian_ring (canonically_ordered_comm_semiring (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_168065 (h0 : add_monoid (has_emptyc linarith.comp)) : add_monoid.fg (has_emptyc linarith.comp) := sorry --non-trivial
lemma new_lemma_168066 (h0 : functor.add_const (uniform_space (partial_order unsigned)) empty) : @separated_space.{0} (partial_order.{0} unsigned) (@functor.add_const.run.{0 0} (uniform_space.{0} (partial_order.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_168067 (h0 : functor.add_const (functor.add_const (group Type) Type) Type) : @is_simple_group.{1} Type (@functor.add_const.run.{1 1} (group.{1} Type) Type (@functor.add_const.run.{1 1} (functor.add_const.{1 1} (group.{1} Type) Type) Type h0))  := sorry --non-trivial
lemma new_lemma_168068 (h0 : topological_space (comm_semigroup (sub_neg_monoid (sub_neg_monoid real)))) : preconnected_space (comm_semigroup (sub_neg_monoid (sub_neg_monoid real))) := sorry --non-trivial
lemma new_lemma_168069 (h1 : ring (add_monoid (fintype fun_info))) : strong_rank_condition (add_monoid (fintype fun_info)) := sorry --non-trivial
lemma new_lemma_168070 (h0 : topological_space (has_nndist (has_add name))) : totally_separated_space (has_nndist (has_add name)) := sorry --non-trivial
lemma new_lemma_168071 (h0 : complete_lattice (ordered_comm_monoid (ring (ring (ring pos))))) : is_compactly_generated (ordered_comm_monoid (ring (ring (ring pos)))) := sorry --non-trivial
lemma new_lemma_168072 (h0 : functor.add_const (ordered_comm_monoid (boolean_algebra Type)) (has_add name)) : @has_exists_mul_of_le.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (ordered_comm_monoid.{1} (boolean_algebra.{1} Type)) (has_add.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_168073 (h1 : uniform_space (has_nnnorm char)) : complete_space (has_nnnorm char) := sorry --non-trivial
lemma new_lemma_168074 (h1 : complete_lattice (random_gen char)) : is_compactly_generated (random_gen char) := sorry --non-trivial
lemma new_lemma_168075 (h0 : filter (linear_ordered_field (option (option (option ennreal))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_168076 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (ordered_cancel_add_comm_monoid.{0} num) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (ordered_cancel_add_comm_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_168077 (h0 : function.extfun Type topological_space) : @t0_space.{0} (semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_168078 (h0 : semiring (semigroup (has_add linarith.comp))) : is_noetherian_ring (semigroup (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_168079 (h0 : group (has_pos_part (has_nnnorm linarith.comp_source))) : is_cyclic (has_pos_part (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_168080 (h0 : functor.add_const (topological_space (has_zero Type)) pos) : @discrete_topology.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_zero.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_168081 (h0 : topological_space (has_Sup empty)) : topological_space.separable_space (has_Sup empty) := sorry --non-trivial
lemma new_lemma_168082 (h0 : functor.add_const (topological_space (has_neg linarith.comp)) name) : @t1_space.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_168083 (h0 : functor.comp topological_space semigroup Type) : @totally_separated_space.{1} (semigroup.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} semigroup.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_168084 (h0 : add_monoid (has_add (mul_one_class Type))) : add_monoid.fg (has_add (mul_one_class Type)) := sorry --non-trivial
lemma new_lemma_168085 (h0 : topological_space (id (has_inv char))) : totally_disconnected_space (id (has_inv char)) := sorry --non-trivial
lemma new_lemma_168086 (h0 : function.extfun (Type 1) ring) : @strong_rank_condition.{1} (plift.{1} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} congr_arg_kind))))) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (plift.{1} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} congr_arg_kind))))))  := sorry --non-trivial
lemma new_lemma_168087 (h0 : ring (with_bot (semiring empty))) : strong_rank_condition (with_bot (semiring empty)) := sorry --non-trivial
lemma new_lemma_168088 (h0 : add_monoid (has_top unsigned)) : add_monoid.fg (has_top unsigned) := sorry --non-trivial
lemma new_lemma_168089 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_cyclic.{1} Type (@function.extfun_app.{3 2} (Type 1) group.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 group.{1}) Type)  := sorry --non-trivial
lemma new_lemma_168090 (h0 : complete_lattice (id linarith.comp_source)) : is_compactly_generated (id linarith.comp_source) := sorry --non-trivial
lemma new_lemma_168091 (h0 : functor.add_const (topological_space (left_cancel_monoid num)) (semiring (option num))) : @discrete_topology.{0} (left_cancel_monoid.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} num)) (semiring.{0} (option.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_168092 (h0 : topological_space (has_edist (option (option empty)))) : t1_space (has_edist (option (option empty))) := sorry --non-trivial
lemma new_lemma_168093 : nonempty nnreal := sorry --simp
lemma new_lemma_168094 (h0 : add_group (has_edist (option unsigned))) : is_add_cyclic (has_edist (option unsigned)) := sorry --non-trivial
lemma new_lemma_168095 (h0 : functor.add_const (ring (has_pos_part pos)) (ring Type)) : @strong_rank_condition.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (has_pos_part.{0} pos)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_168096 (h0 : topological_space (has_top (id empty))) : preirreducible_space (has_top (id empty)) := sorry --non-trivial
lemma new_lemma_168097 (h0 : topological_space (has_nndist congr_arg_kind)) : discrete_topology (has_nndist congr_arg_kind) := sorry --non-trivial
lemma new_lemma_168098 (h0 : ring (semiring (has_top (has_top (random_gen congr_arg_kind))))) : strong_rank_condition (semiring (has_top (has_top (random_gen congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_168099 (h0 : complete_lattice (complete_distrib_lattice (option (option empty)))) : complete_lattice.is_Sup_finite_compact (complete_distrib_lattice (option (option empty))) := sorry --non-trivial
lemma new_lemma_168100 (h0 : function.extfun Type (functor.add_const (finset auto.case_option))) : finset.nonempty (functor.add_const.run (function.extfun_app h0 empty)) := sorry --non-trivial
lemma new_lemma_168101 (h0 : ordered_add_comm_monoid (complete_distrib_lattice pos)) : archimedean (complete_distrib_lattice pos) := sorry --non-trivial
lemma new_lemma_168102 (h0 : group (left_cancel_monoid (option empty))) : group.fg (left_cancel_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_168103 (h0 : topological_space (normed_group (random_gen num))) : irreducible_space (normed_group (random_gen num)) := sorry --non-trivial
lemma new_lemma_168104 (h0 : functor.add_const (finset (complete_distrib_lattice num)) ennreal) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_168105 (h0 : ordered_add_comm_monoid (add_cancel_monoid (has_add linarith.comp))) : archimedean (add_cancel_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_168106 (h0 : group (has_norm (random_gen (with_one char)))) : group.fg (has_norm (random_gen (with_one char))) := sorry --non-trivial
lemma new_lemma_168107 (h0 : uniform_space (has_add (has_zero (ring (finset linarith.comp))))) : separated_space (has_add (has_zero (ring (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_168108 (h0 : not (uniform_space (non_unital_non_assoc_semiring char) -> false)) : @complete_space.{0} (non_unital_non_assoc_semiring.{0} char) (@classical.by_contradiction'.{1} (uniform_space.{0} (non_unital_non_assoc_semiring.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_168109 (h0 : complete_lattice (add_cancel_comm_monoid unsigned)) : is_compactly_generated (add_cancel_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_168110 (h0 : topological_space (has_norm (semiring (semiring (semiring linarith.comp))))) : path_connected_space (has_norm (semiring (semiring (semiring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_168111 (h0 : decidable_eq (complete_distrib_lattice (has_neg_part pos))) (h1 : equiv.perm (complete_distrib_lattice (has_neg_part pos))) : equiv.perm.is_swap h1 := sorry --non-trivial
lemma new_lemma_168112 (h0 : functor.add_const (semiring (normed_comm_ring Type)) (comm_group name)) : @is_noetherian_ring.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (semiring.{1} (normed_comm_ring.{1} Type)) (comm_group.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_168113 (h0 : functor.add_const (complete_lattice (has_Sup unsigned)) unsigned) : @is_compactly_generated.{0} (has_Sup.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_Sup.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_168114 (h0 : topological_space (cancel_monoid (option (option congr_arg_kind)))) : preirreducible_space (cancel_monoid (option (option congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_168115 (h0 : complete_lattice (has_add (finset pos))) : complete_lattice.is_Sup_finite_compact (has_add (finset pos)) := sorry --non-trivial
lemma new_lemma_168116 (h0 : functor.add_const (uniform_space (generalized_boolean_algebra pos)) pos) : @complete_space.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (generalized_boolean_algebra.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_168117 (h0 : ring to_additive.value_type) : is_domain to_additive.value_type := sorry --non-trivial
lemma new_lemma_168118 (h0 : group (cancel_monoid (option (option (option (option ennreal)))))) : is_simple_group (cancel_monoid (option (option (option (option ennreal))))) := sorry --non-trivial
lemma new_lemma_168119 (h0 : prod (has_top (semiring (semiring empty))) (has_top (semiring (semiring empty)))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_168120 (h0 : functor.add_const (topological_space (add_cancel_monoid pos)) Type) : @path_connected_space.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (add_cancel_monoid.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_168121 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (normed_comm_ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_168122 (h0 : topological_space (has_to_string (has_add (has_add (add_comm_monoid name))))) : preirreducible_space (has_to_string (has_add (has_add (add_comm_monoid name)))) := sorry --non-trivial
lemma new_lemma_168123 (h0 : complete_lattice (normed_lattice_add_comm_group (ordered_comm_monoid Type))) : is_compactly_generated (normed_lattice_add_comm_group (ordered_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_168124 (h0 : not (topological_space (with_one empty) -> false)) : @totally_disconnected_space.{0} (with_one.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (with_one.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_168125 (h0 : topological_space (canonically_ordered_comm_semiring (has_add (finset pos)))) : loc_path_connected_space (canonically_ordered_comm_semiring (has_add (finset pos))) := sorry --non-trivial
lemma new_lemma_168126 (h0 : cancel_comm_monoid_with_zero (complete_distrib_lattice Type)) : unique_factorization_monoid (complete_distrib_lattice Type) := sorry --non-trivial
lemma new_lemma_168127 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (filter.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (filter.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_168128 (h0 : topological_space (add_comm_monoid (comm_group name))) : locally_compact_space (add_comm_monoid (comm_group name)) := sorry --non-trivial
lemma new_lemma_168129 (h0 : finset (boolean_algebra (has_Inf (has_neg pos)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_168130 (h0 : functor.add_const (uniform_space (add_cancel_monoid name)) (has_nndist (has_nndist Type))) : @complete_space.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 1} (uniform_space.{0} (add_cancel_monoid.{0} name)) (has_nndist.{1} (has_nndist.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_168131 (h0 : char -> ereal -> ereal) (h1 : ereal -> ereal -> Prop) : covariant char ereal h0 h1 := sorry --non-trivial
lemma new_lemma_168132 (h0 : functor.add_const (group (add_semigroup empty)) (option (option unsigned))) : @normalizer_condition.{0} (add_semigroup.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (add_semigroup.{0} empty)) (option.{0} (option.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_168133 (h0 : topological_space (has_neg (ring name))) : discrete_topology (has_neg (ring name)) := sorry --non-trivial
lemma new_lemma_168134 (h0 : function.extfun (Type 1) topological_space) : @discrete_topology.{1} (has_bot.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_bot.{1} Type))  := sorry --non-trivial
lemma new_lemma_168135 (h0 : topological_space (sub_neg_monoid (has_neg (has_neg (has_neg name))))) : sequential_space (sub_neg_monoid (has_neg (has_neg (has_neg name)))) := sorry --non-trivial
lemma new_lemma_168136 (h0 : ring (add_monoid (has_nnnorm linarith.ineq))) : is_domain (add_monoid (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_168137 (h0 : group (has_compl (random_gen linarith.ineq))) : is_cyclic (has_compl (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_168138 (h0 : semiring (with_bot (has_top empty))) : is_noetherian_ring (with_bot (has_top empty)) := sorry --non-trivial
lemma new_lemma_168139 (h0 : topological_space (boolean_algebra (has_to_string environment.implicit_infer_kind))) : totally_separated_space (boolean_algebra (has_to_string environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_168140 (h0 : not (function.extfun Type filter -> false)) : filter.ne_bot (function.extfun_app (classical.by_contradiction' h0) (complete_linear_order empty)) := sorry --non-trivial
lemma new_lemma_168141 (h0 : not (topological_space (semi_normed_comm_ring char) -> false)) : @t0_space.{0} (semi_normed_comm_ring.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (semi_normed_comm_ring.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_168142 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (simple_graph.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (simple_graph.{0} num))  := sorry --non-trivial
lemma new_lemma_168143 (h0 : list (omega_complete_partial_order unsigned)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_168144 (h0 : functor.comp topological_space has_nndist ennreal) : @loc_path_connected_space.{0} (has_nndist.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_168145 (h0 : topological_space (cancel_monoid (has_add (has_add (has_add environment.implicit_infer_kind))))) : normal_space (cancel_monoid (has_add (has_add (has_add environment.implicit_infer_kind)))) := sorry --non-trivial
lemma new_lemma_168146 (h0 : functor.add_const (topological_space (add_comm_monoid Type)) Type) : @preirreducible_space.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (add_comm_monoid.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_168147 (h0 : functor.add_const (function.extfun (Type 1) filter) Type) : filter.ne_bot (function.extfun_app (functor.add_const.run h0) (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_168148 (h0 : topological_space (as_linear_order congr_arg_kind)) : preirreducible_space (as_linear_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_168149 (h0 : add_group (encodable (has_nnnorm linarith.ineq))) : is_add_cyclic (encodable (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_168150 (h1 : uniform_space (measurable_space (random_gen to_additive.value_type))) : complete_space (measurable_space (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_168151 (h0 : add_monoid (order_dual congr_arg_kind)) : add_monoid.fg (order_dual congr_arg_kind) := sorry --non-trivial
lemma new_lemma_168152 (h0 : functor.add_const (uniform_space (complete_distrib_lattice name)) linarith.comp) : @complete_space.{0} (complete_distrib_lattice.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (complete_distrib_lattice.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_168153 (h0 : has_mem.mem (semiring empty) has_emptyc.emptyc) : @strong_rank_condition.{0} (semiring.{0} empty) (@finset.pi.empty.{1 0} Type ring.{0} (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_168154 (h0 : functor.add_const (ring (add_cancel_monoid pos)) (has_neg name)) : @rank_condition.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (add_cancel_monoid.{0} pos)) (has_neg.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_168155 (h0 : semiring (add_comm_semigroup enat)) (h1 : ideal (add_comm_semigroup enat)) : ideal.is_prime h1 := sorry --non-trivial
lemma new_lemma_168156 (h0 : filter (finset (finset Type))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_168157 (h0 : topological_space (topological_space (has_nnnorm (has_nnnorm linarith.ineq)))) : t0_space (topological_space (has_nnnorm (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_168158 (h0 : functor.add_const (topological_space (has_neg linarith.comp)) pos) : @normal_space.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_168159 (h0 : preorder (denumerable linarith.comp_source)) (h1 : denumerable linarith.comp_source -> set to_additive.value_type) : filter.is_antitone_basis h1 := sorry --non-trivial
lemma new_lemma_168160 (h0 : not (uniform_space (preorder congr_arg_kind) -> false)) : @separated_space.{0} (preorder.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (uniform_space.{0} (preorder.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_168161 (h0 : prod (cancel_monoid (finset (add_comm_monoid Type))) (cancel_monoid (finset (add_comm_monoid Type)))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_168162 (h0 : semiring (add_group unsigned)) : is_noetherian_ring (add_group unsigned) := sorry --non-trivial
lemma new_lemma_168163 (h0 : functor.add_const (finset (boolean_algebra linarith.comp)) (finset pos)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_168164 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (linear_ordered_field.{0} ennreal) (@function.extfun_app.{2 1} Type monoid.{0} h0 (linear_ordered_field.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_168165 (h0 : topological_space (random_gen (random_gen (random_gen (random_gen string_imp))))) : locally_compact_space (random_gen (random_gen (random_gen (random_gen string_imp)))) := sorry --non-trivial
lemma new_lemma_168166 (h0 : topological_space (boolean_algebra (has_Inf Type))) : t1_space (boolean_algebra (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_168167 (h0 : monoid (normed_comm_ring (has_add (has_add Type)))) : monoid.fg (normed_comm_ring (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_168168 (h0 : functor.add_const (cancel_comm_monoid_with_zero (complete_distrib_lattice ennreal)) linarith.comp) : @unique_factorization_monoid.{0} (complete_distrib_lattice.{0} ennreal) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (complete_distrib_lattice.{0} ennreal)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_168169 (h0 : functor.add_const (function.extfun Type topological_space) name) : @normal_space.{0} (has_pos_part.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (has_pos_part.{0} name))  := sorry --non-trivial
lemma new_lemma_168170 (h0 : topological_space (add_comm_monoid (has_add (sub_neg_monoid pos)))) : preconnected_space (add_comm_monoid (has_add (sub_neg_monoid pos))) := sorry --non-trivial
lemma new_lemma_168171 (h0 : char -> char -> char) (h1 : char -> char) (h2 : char) : right_inverse h0 h1 h2 := sorry --non-trivial
lemma new_lemma_168172 (h0 : functor.add_const (topological_space (left_cancel_monoid num)) num) : @path_connected_space.{0} (left_cancel_monoid.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_168173 (h0 : function.extfun nat fin) : @locally_compact_space.{1} (comm_semigroup.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (comm_semigroup.{1} Type)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))))  := sorry --non-trivial
lemma new_lemma_168174 (h0 : ring (generalized_boolean_algebra pos)) : is_domain (generalized_boolean_algebra pos) := sorry --non-trivial
lemma new_lemma_168175 (h0 : group (linear_ordered_semiring (random_gen (random_gen (random_gen num))))) : normalizer_condition (linear_ordered_semiring (random_gen (random_gen (random_gen num)))) := sorry --non-trivial
lemma new_lemma_168176 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (left_cancel_monoid empty)) := sorry --non-trivial
lemma new_lemma_168177 (h0 : functor.add_const (prod (has_neg_part name) (has_neg_part name)) (option pos)) : id_rel (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_168178 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_monoid_with_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_168179 (h0 : topological_space (has_nnnorm (random_gen linarith.ineq))) : t0_space (has_nnnorm (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_168180 (h0 : functor.add_const (topological_space (finset unsigned)) Type) : @topological_space.separable_space.{0} (finset.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (finset.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_168181 (h0 : has_mem.mem (function.extfun Type) has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} congr_arg_kind (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@finset.pi.empty.{2 1} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) (function.extfun.{2 1} Type) h0) complete_lattice.{0}) congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_168182 (h0 : uniform_space (boolean_algebra empty)) : separated_space (boolean_algebra empty) := sorry --non-trivial
lemma new_lemma_168183 (h0 h1 : multiset (non_unital_non_assoc_semiring enat)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_168184 (h0 : not (function.extfun Type monoid -> false)) : @monoid.fg.{0} linarith.comp (@function.extfun_app.{2 1} Type monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type monoid.{0}) h0) linarith.comp)  := sorry --non-trivial
lemma new_lemma_168185 (h0 : topological_space (has_zero ennreal)) : loc_path_connected_space (has_zero ennreal) := sorry --non-trivial
lemma new_lemma_168186 (h0 : functor.add_const (topological_space (has_neg_part pos)) (finset (has_add (comm_group Type)))) : @sequential_space.{0} (has_neg_part.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg_part.{0} pos)) (finset.{1} (has_add.{1} (comm_group.{1} Type))) h0)  := sorry --non-trivial
lemma new_lemma_168187 (h0 : functor.add_const (topological_space (finset Type)) Type) : @irreducible_space.{1} (finset.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (finset.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_168188 (h0 : topological_space (has_add (has_pos_part (has_pos_part (has_pos_part (has_pos_part pos)))))) : t0_space (has_add (has_pos_part (has_pos_part (has_pos_part (has_pos_part pos))))) := sorry --non-trivial
lemma new_lemma_168189 (h0 : function.extfun Type (functor.add_const (function.extfun Type add_group))) : @is_add_cyclic.{0} (has_neg.{0} (has_neg_part.{0} (cancel_monoid.{0} (has_neg_part.{0} (has_neg_part.{0} (ring.{0} name)))))) (@function.extfun_app.{2 1} Type add_group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_group.{0}) linarith.comp (@function.extfun_app.{2 2} Type (functor.add_const.{1 0} (function.extfun.{2 1} Type add_group.{0})) h0 linarith.comp)) (has_neg.{0} (has_neg_part.{0} (cancel_monoid.{0} (has_neg_part.{0} (has_neg_part.{0} (ring.{0} name)))))))  := sorry --non-trivial
lemma new_lemma_168190 (h0 : ring (has_neg (has_to_string Type))) : is_principal_ideal_ring (has_neg (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_168191 (h0 : not (monoid (left_cancel_semigroup num) -> false)) : @monoid.fg.{0} (left_cancel_semigroup.{0} num) (@classical.by_contradiction'.{1} (monoid.{0} (left_cancel_semigroup.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_168192 (h0 : topological_space (sub_neg_monoid (option (option empty)))) : totally_separated_space (sub_neg_monoid (option (option empty))) := sorry --non-trivial
lemma new_lemma_168193 (h0 : functor.add_const (complete_lattice (non_assoc_semiring empty)) empty) : @is_atomistic.{0} (non_assoc_semiring.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (non_assoc_semiring.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_168194 (h0 : functor.add_const (topological_space (cancel_monoid linarith.comp)) Type) : @locally_compact_space.{0} (cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (cancel_monoid.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_168195 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @sequential_space.{0} (has_to_string.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (has_to_string.{0} name))  := sorry --non-trivial
lemma new_lemma_168196 (h1 : ring (denumerable (random_gen (random_gen char)))) : rank_condition (denumerable (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_168197 (h0 : topological_space (finset (has_add real))) : normal_space (finset (has_add real)) := sorry --non-trivial
lemma new_lemma_168198 (h0 : complete_lattice (complete_distrib_lattice (has_pos_part linarith.comp))) : complete_lattice.is_Sup_finite_compact (complete_distrib_lattice (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_168199 (h0 : monoid (add_left_cancel_semigroup unsigned)) : monoid.fg (add_left_cancel_semigroup unsigned) := sorry --non-trivial
lemma new_lemma_168200 (h0 : topological_space (has_nndist (has_neg (ring (has_nndist environment.implicit_infer_kind))))) : preconnected_space (has_nndist (has_neg (ring (has_nndist environment.implicit_infer_kind)))) := sorry --non-trivial
lemma new_lemma_168201 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (distrib_lattice.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (distrib_lattice.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_168202 (h1 : not (uniform_space (has_append char) -> false)) : @complete_space.{0} (has_append.{0} char) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_append.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_168203 (h0 : set (has_nndist linarith.ineq)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_168204 (h0 : functor.add_const (ordered_add_comm_monoid (has_neg linarith.comp)) linarith.comp) : @archimedean.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_neg.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_168205 (h0 : uniform_space (has_norm (has_top (has_top fun_info)))) : complete_space (has_norm (has_top (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_168206 (h0 : fin has_zero.zero) : @group.fg.{0} (has_pos_part.{0} real) (@matrix.vec_empty.{0} (group.{0} (has_pos_part.{0} real)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_168207 (h0 : functor.add_const (topological_space (has_nndist pos)) (has_neg linarith.comp)) : @preirreducible_space.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} pos)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_168208 (h0 : group (has_Sup congr_arg_kind)) : normalizer_condition (has_Sup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_168209 (h0 : topological_space (random_gen (semiring (semiring (semiring (semiring num)))))) : totally_separated_space (random_gen (semiring (semiring (semiring (semiring num))))) := sorry --non-trivial
lemma new_lemma_168210 (h0 : functor.add_const (finset (complete_linear_order num)) empty) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_168211 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (add_group.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (add_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_168212 (h0 : ring (has_emptyc (random_gen (has_norm (random_gen (has_top to_additive.value_type)))))) : rank_condition (has_emptyc (random_gen (has_norm (random_gen (has_top to_additive.value_type))))) := sorry --non-trivial
lemma new_lemma_168213 (h0 : not (function.extfun Type topological_space -> false)) : @normal_space.{0} (with_bot.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (with_bot.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_168214 (h0 : functor.add_const (topological_space (has_add Type)) pos) : @topological_space.separable_space.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_add.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_168215 (h0 : not (topological_space (has_union empty) -> false)) : @totally_disconnected_space.{0} (has_union.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (has_union.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_168216 (h0 : not (group (has_union congr_arg_kind) -> false)) : @normalizer_condition.{0} (has_union.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (group.{0} (has_union.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_168217 (h0 : list (normed_comm_ring (ring Type))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_168218 (h0 : topological_space (generalized_boolean_algebra (ordered_comm_ring Type))) : discrete_topology (generalized_boolean_algebra (ordered_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_168219 (h1 : complete_lattice (with_one linarith.comp)) : is_compactly_generated (with_one linarith.comp) := sorry --non-trivial
lemma new_lemma_168220 (h0 : functor.add_const (topological_space (comm_group environment.implicit_infer_kind)) linarith.comp) : @irreducible_space.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_168221 (h0 : ring (has_nndist congr_arg_kind)) : is_principal_ideal_ring (has_nndist congr_arg_kind) := sorry --non-trivial
lemma new_lemma_168222 (h0 : ring (partial_order (semiring num))) : strong_rank_condition (partial_order (semiring num)) := sorry --non-trivial
lemma new_lemma_168223 (h0 : has_mem.mem (complete_semilattice_Sup congr_arg_kind) has_emptyc.emptyc) : @totally_disconnected_space.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (complete_semilattice_Sup.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_168224 (h0 : not (complete_lattice (complete_linear_order congr_arg_kind) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (complete_linear_order.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (complete_lattice.{0} (complete_linear_order.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_168225 (h0 : functor.add_const (topological_space (ring environment.implicit_infer_kind)) name) : @totally_separated_space.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_168226 (h0 : functor.add_const (filter (complete_distrib_lattice linarith.comp)) pos) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_168227 (h0 : functor.add_const (group (semigroup Type)) unsigned) : @normalizer_condition.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (semigroup.{1} Type)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_168228 (h0 : function.extfun Type topological_space) : @t0_space.{0} (linear_ordered_add_comm_monoid_with_top.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_add_comm_monoid_with_top.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_168229 (h0 : add_group (has_top (random_gen to_additive.value_type))) : is_add_cyclic (has_top (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_168230 (h0 : topological_space (add_comm_monoid congr_arg_kind)) : locally_compact_space (add_comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_168231 (h0 : topological_space (normed_comm_ring (comm_group (has_add name)))) : preconnected_space (normed_comm_ring (comm_group (has_add name))) := sorry --non-trivial
lemma new_lemma_168232 (h0 : functor.comp topological_space has_neg environment.implicit_infer_kind) : @discrete_topology.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_168233 (h0 : functor.add_const (topological_space (has_star empty)) unsigned) : @t0_space.{0} (has_star.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_168234 (h0 : not (add_group (add_cancel_comm_monoid string.iterator_imp) -> false)) : @is_add_cyclic.{0} (add_cancel_comm_monoid.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (add_group.{0} (add_cancel_comm_monoid.{0} string.iterator_imp)) h0)  := sorry --non-trivial
lemma new_lemma_168235 (h0 : group (canonically_linear_ordered_monoid (has_pos_part Type))) : normalizer_condition (canonically_linear_ordered_monoid (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_168236 (h0 : group (has_edist unsigned)) : is_cyclic (has_edist unsigned) := sorry --non-trivial
lemma new_lemma_168237 (h1 : not (topological_space (non_unital_non_assoc_semiring reducibility_hints) -> false)) : @t0_space.{0} (non_unital_non_assoc_semiring.{0} reducibility_hints) (@classical.by_contradiction'.{1} (topological_space.{0} (non_unital_non_assoc_semiring.{0} reducibility_hints)) h1)  := sorry --non-trivial
lemma new_lemma_168238 (h0 : functor.add_const (topological_space (has_neg environment.implicit_infer_kind)) linarith.comp) : @normal_space.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_168239 (h0 : functor.add_const (function.extfun Type monoid) (finset Type)) : @monoid.fg.{0} (has_zero.{0} name) (@function.extfun_app.{2 1} Type monoid.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type monoid.{0}) (finset.{1} Type) h0) (has_zero.{0} name))  := sorry --non-trivial
lemma new_lemma_168240 (h0 : group (sub_neg_monoid name)) : group.fg (sub_neg_monoid name) := sorry --non-trivial
lemma new_lemma_168241 (h0 : filter (normed_comm_ring unsigned)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_168242 (h0 : uniform_space (has_compl (has_ssubset fun_info))) : complete_space (has_compl (has_ssubset fun_info)) := sorry --non-trivial
lemma new_lemma_168243 (h0 : functor.add_const (group (complete_distrib_lattice Type)) name) : @group.fg.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (complete_distrib_lattice.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_168244 (h2 : topological_space num) : irreducible_space num := sorry --non-trivial
lemma new_lemma_168245 (h0 : ring (has_neg environment.implicit_infer_kind)) : rank_condition (has_neg environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_168246 (h0 : not (topological_space (add_group congr_arg_kind) -> false)) : @path_connected_space.{0} (add_group.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (add_group.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_168247 (h2 : set (mul_one_class reducibility_hints)) : set.finite h2 := sorry --non-trivial
lemma new_lemma_168248 (h0 : functor.add_const (group (has_dist congr_arg_kind)) num) : @group.fg.{0} (has_dist.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (group.{0} (has_dist.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_168249 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_add.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} h0 (has_add.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_168250 (h0 : topological_space (ring empty)) : irreducible_space (ring empty) := sorry --non-trivial
lemma new_lemma_168251 (h0 : topological_space (finset linarith.comp)) : normal_space (finset linarith.comp) := sorry --non-trivial
lemma new_lemma_168252 (h0 : has_mem.mem (id empty) has_emptyc.emptyc) : @rank_condition.{0} (@id.{2} Type empty) (@finset.pi.empty.{1 0} Type ring.{0} (@id.{2} Type empty) h0)  := sorry --non-trivial
lemma new_lemma_168253 (h0 : topological_space (topological_space (has_ssubset (dlist (has_ssubset fun_info))))) : locally_compact_space (topological_space (has_ssubset (dlist (has_ssubset fun_info)))) := sorry --non-trivial
lemma new_lemma_168254 (h0 : add_group (boolean_algebra.core (has_add (has_add (has_neg_part Type))))) : is_add_cyclic (boolean_algebra.core (has_add (has_add (has_neg_part Type)))) := sorry --non-trivial
lemma new_lemma_168255 (h0 : function.extfun Type ring) : @is_domain.{0} (has_top.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_top.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_168256 (h0 : add_group (has_norm (semiring (semiring unsigned)))) : is_add_cyclic (has_norm (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_168257 (h0 : topological_space (ring (finset linarith.comp))) : t1_space (ring (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_168258 (h0 : topological_space (semiring (semiring unsigned))) : t0_space (semiring (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_168259 (h0 : topological_space (simple_graph (has_add linarith.comp))) : topological_space.separable_space (simple_graph (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_168260 (h0 : topological_space (add_cancel_monoid name)) : irreducible_space (add_cancel_monoid name) := sorry --non-trivial
lemma new_lemma_168261 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_168262 (h0 : functor.add_const (group (boolean_algebra.core linarith.comp)) name) : @is_cyclic.{0} (boolean_algebra.core.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.core.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_168263 (h1 : ring (dlist linarith.ineq)) : is_domain (dlist linarith.ineq) := sorry --non-trivial
lemma new_lemma_168264 (h0 : uniform_space (boolean_algebra.core ennreal)) : separated_space (boolean_algebra.core ennreal) := sorry --non-trivial
lemma new_lemma_168265 (h0 : add_group (random_gen (random_gen (random_gen string_imp)))) : is_add_cyclic (random_gen (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_168266 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @discrete_topology.{1} (has_bot.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (has_bot.{1} Type))  := sorry --non-trivial
lemma new_lemma_168267 (h0 : uniform_space (mul_one_class linarith.ineq)) : complete_space (mul_one_class linarith.ineq) := sorry --non-trivial
lemma new_lemma_168268 (h0 : semiring (preorder congr_arg_kind)) : is_noetherian_ring (preorder congr_arg_kind) := sorry --non-trivial
lemma new_lemma_168269 (h0 : uniform_space (has_inv (random_gen (random_gen (random_gen linarith.ineq))))) : complete_space (has_inv (random_gen (random_gen (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_168270 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (with_bot.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (with_bot.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_168271 (h0 : function.extfun Type group) : @is_cyclic.{0} (sub_neg_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} h0 (sub_neg_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_168272 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (finset.{0} num) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (finset.{0} num))  := sorry --non-trivial
lemma new_lemma_168273 (h0 : topological_space (preorder empty)) : t1_space (preorder empty) := sorry --non-trivial
lemma new_lemma_168274 (h0 : topological_space (comm_ring (linear_ordered_add_comm_group (has_nnnorm to_additive.value_type)))) : t0_space (comm_ring (linear_ordered_add_comm_group (has_nnnorm to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_168275 (h0 : not (ring Type -> false)) : @rank_condition.{1} Type (@classical.by_contradiction'.{2} (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_168276 (h1 : filter (measurable_space to_additive.value_type)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_168277 (h0 : topological_space (complete_distrib_lattice (option unsigned))) : totally_separated_space (complete_distrib_lattice (option unsigned)) := sorry --non-trivial
lemma new_lemma_168278 (h0 : monoid (complete_semilattice_Sup (has_inv (has_inv linarith.comp_source)))) : monoid.fg (complete_semilattice_Sup (has_inv (has_inv linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_168279 (h0 : ordered_add_comm_monoid (normed_comm_ring (has_add linarith.comp))) : archimedean (normed_comm_ring (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_168280 (h0 : complete_lattice (comm_group (comm_monoid (has_add Type)))) : is_atomistic (comm_group (comm_monoid (has_add Type))) := sorry --non-trivial
lemma new_lemma_168281 (h0 : has_mem.mem (measurable_space linarith.ineq) has_emptyc.emptyc) : @path_connected_space.{0} (measurable_space.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type topological_space.{0} (measurable_space.{0} linarith.ineq) h0)  := sorry --non-trivial
lemma new_lemma_168282 (h0 : functor.add_const (topological_space (has_Inf pos)) name) : @loc_path_connected_space.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_168283 (h0 : ring (has_bot name)) : is_principal_ideal_ring (has_bot name) := sorry --non-trivial
lemma new_lemma_168284 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem monoid)) : @monoid.fg.{0} (semiring.{0} fun_info) (@function.extfun_app.{2 1} Type monoid.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) monoid.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) monoid.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_168285 (h0 : function.extfun Type ring) : @rank_condition.{0} (linear_ordered_field.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_ordered_field.{0} empty))  := sorry --non-trivial
lemma new_lemma_168286 (h0 : functor.add_const (complete_lattice (add_cancel_monoid environment.implicit_infer_kind)) pos) : @is_compactly_generated.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_168287 (h0 : functor.add_const (monoid (has_neg unsigned)) (boolean_algebra Type)) : @monoid.fg.{0} (has_neg.{0} unsigned) (@functor.add_const.run.{0 1} (monoid.{0} (has_neg.{0} unsigned)) (boolean_algebra.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_168288 (h0 : monoid (random_gen (has_inv (has_inv linarith.ineq)))) : monoid.fg (random_gen (has_inv (has_inv linarith.ineq))) := sorry --non-trivial
lemma new_lemma_168289 (h0 : group (measurable_space.dynkin_system unsigned)) : normalizer_condition (measurable_space.dynkin_system unsigned) := sorry --non-trivial
lemma new_lemma_168290 (h0 : topological_space (normed_group (semiring unsigned))) : path_connected_space (normed_group (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_168291 (h0 h1 : list char) : list.subperm h0 h1 := sorry --non-trivial
lemma new_lemma_168292 (h0 : monoid (finset (finset (has_pos_part pos)))) : monoid.fg (finset (finset (has_pos_part pos))) := sorry --non-trivial
lemma new_lemma_168293 (h0 : group (has_inv fun_info)) : group.fg (has_inv fun_info) := sorry --non-trivial
lemma new_lemma_168294 (h0 : functor.add_const (function.extfun Type group) pos) : @is_cyclic.{0} (boolean_algebra.{0} (has_pos_part.{0} linarith.comp)) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) pos h0) (boolean_algebra.{0} (has_pos_part.{0} linarith.comp)))  := sorry --non-trivial
lemma new_lemma_168295 (h0 : filter (metric_space (semiring empty))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_168296 (h0 : functor.add_const (complete_lattice (canonically_ordered_comm_semiring unsigned)) Type) : @is_atomistic.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@functor.add_const.run.{0 1} (complete_lattice.{0} (canonically_ordered_comm_semiring.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_168297 (h0 : preorder (nondiscrete_normed_field (add_comm_semigroup (add_comm_semigroup string.iterator_imp)))) (h1 : set (nondiscrete_normed_field (add_comm_semigroup (add_comm_semigroup string.iterator_imp)))) : set.is_pwo h1 := sorry --non-trivial
lemma new_lemma_168298 (h0 : has_mem.mem (measurable_space num) has_emptyc.emptyc) : @is_add_cyclic.{0} (measurable_space.{0} num) (@finset.pi.empty.{1 0} Type add_group.{0} (measurable_space.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_168299 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (has_emptyc.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (has_emptyc.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_168300 (h0 : ring (semi_normed_ring (mul_one_class ereal))) : strong_rank_condition (semi_normed_ring (mul_one_class ereal)) := sorry --non-trivial
lemma new_lemma_168301 (h6 : uniform_space (topological_space fun_info)) : complete_space (topological_space fun_info) := sorry --non-trivial
lemma new_lemma_168302 (h0 : functor.add_const (ring (has_to_string pos)) environment.implicit_infer_kind) : @is_principal_ideal_ring.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_to_string.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_168303 (h0 : topological_space (complete_semilattice_Sup num)) : discrete_topology (complete_semilattice_Sup num) := sorry --non-trivial
lemma new_lemma_168304 (h0 : complete_lattice (comm_group unsigned)) : is_compactly_generated (comm_group unsigned) := sorry --non-trivial
lemma new_lemma_168305 (h0 : not (has_mem.mem (semiring linarith.comp_source) has_emptyc.emptyc -> false)) : @irreducible_space.{0} (semiring.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (semiring.{0} linarith.comp_source) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} linarith.comp_source) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_168306 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_star.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (has_star.{0} empty))  := sorry --non-trivial
lemma new_lemma_168307 (h1 : topological_space (encodable char)) : totally_disconnected_space (encodable char) := sorry --non-trivial
lemma new_lemma_168308 (h0 : topological_space (add_right_cancel_monoid empty)) : irreducible_space (add_right_cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_168309 (h0 : not (ring (partial_order empty) -> false)) : @strong_rank_condition.{0} (partial_order.{0} empty) (@classical.by_contradiction'.{1} (ring.{0} (partial_order.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_168310 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_sub.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_sub.{0} empty))  := sorry --non-trivial
lemma new_lemma_168311 (h1 : set (normed_field linarith.comp_source)) : set.subsingleton h1 := sorry --non-trivial
lemma new_lemma_168312 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (mul_zero_class.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type semiring.{0} h0 (mul_zero_class.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_168313 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} (has_star.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (has_star.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_168314 (h0 : not (has_mem.mem (with_bot linarith.comp_source) has_emptyc.emptyc -> false)) : @totally_disconnected_space.{0} (with_bot.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_bot.{0} linarith.comp_source) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_bot.{0} linarith.comp_source) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_168315 (h0 : ring (random_gen unsigned)) : strong_rank_condition (random_gen unsigned) := sorry --non-trivial
lemma new_lemma_168316 (h0 : has_sub unsigned -> has_sub unsigned -> Prop) : is_equiv (has_sub unsigned) h0 := sorry --non-trivial
lemma new_lemma_168317 (h0 : functor.add_const (ordered_comm_monoid (finset pos)) (normed_comm_ring (normed_comm_ring name))) : @has_exists_mul_of_le.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (finset.{0} pos)) (normed_comm_ring.{0} (normed_comm_ring.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_168318 (h0 : functor.comp topological_space has_to_string linarith.comp) : @t0_space.{0} (has_to_string.{0} linarith.comp) (@functor.comp.run.{0 0 0} topological_space.{0} has_to_string.{0} linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_168319 (h0 : add_group (complete_distrib_lattice (has_add environment.implicit_infer_kind))) : is_add_cyclic (complete_distrib_lattice (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_168320 (h0 : filter (has_inv (random_gen linarith.comp_source))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_168321 (h0 : functor.add_const (ring (boolean_algebra linarith.comp)) Type) : @strong_rank_condition.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 1} (ring.{0} (boolean_algebra.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_168322 (h0 : functor.add_const (complete_lattice (has_nndist num)) num) : @is_atomistic.{0} (has_nndist.{0} num) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_nndist.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_168323 (h0 : group (has_to_string unsigned)) : group.fg (has_to_string unsigned) := sorry --non-trivial
lemma new_lemma_168324 (h0 : functor.add_const (topological_space (simple_graph Type)) Type) : @t1_space.{1} (simple_graph.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (simple_graph.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_168325 (h0 : functor.add_const (functor.add_const (ring nnreal) empty) congr_arg_kind) : @is_principal_ideal_ring.{0} nnreal (@functor.add_const.run.{0 0} (ring.{0} nnreal) empty (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (ring.{0} nnreal) empty) congr_arg_kind h0))  := sorry --non-trivial
lemma new_lemma_168326 (h0 : topological_space (boolean_algebra (ring linarith.comp))) : preirreducible_space (boolean_algebra (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_168327 (h0 : functor.add_const (function.extfun Type complete_lattice) (has_neg Type)) : @is_compactly_generated.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type complete_lattice.{0}) (has_neg.{1} Type) h0) (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_168328 (h0 : ring (add_cancel_monoid (boolean_algebra.core linarith.comp))) : strong_rank_condition (add_cancel_monoid (boolean_algebra.core linarith.comp)) := sorry --non-trivial
lemma new_lemma_168329 (h0 : has_mem.mem (has_emptyc congr_arg_kind) has_emptyc.emptyc) : @path_connected_space.{0} (has_emptyc.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_emptyc.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_168330 (h0 : functor.add_const (function.extfun (Type 1) list) Type) : palindrome (function.extfun_app (functor.add_const.run h0) (ring Type)) := sorry --non-trivial
lemma new_lemma_168331 (h0 : functor.add_const (topological_space (cancel_monoid environment.implicit_infer_kind)) linarith.comp) : @preconnected_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_168332 (h0 : filter (has_to_string unsigned)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_168333 (h0 : complete_lattice (has_top (random_gen (has_inv to_additive.value_type)))) : is_atomistic (has_top (random_gen (has_inv to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_168334 (h0 : topological_space (add_left_cancel_semigroup (option empty))) : totally_disconnected_space (add_left_cancel_semigroup (option empty)) := sorry --non-trivial
lemma new_lemma_168335 (h0 : fin has_zero.zero) : @normal_space.{0} (canonically_ordered_monoid.{0} (has_neg.{0} name)) (@matrix.vec_empty.{0} (topological_space.{0} (canonically_ordered_monoid.{0} (has_neg.{0} name))) h0)  := sorry --non-trivial
lemma new_lemma_168336 (h0 : not (group (has_one unsigned) -> false)) : @is_cyclic.{0} (has_one.{0} unsigned) (@classical.by_contradiction'.{1} (group.{0} (has_one.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_168337 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (linear_ordered_semiring.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (linear_ordered_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_168338 (h0 : ring (semiring (random_gen num))) : is_domain (semiring (random_gen num)) := sorry --non-trivial
lemma new_lemma_168339 (h0 : function.extfun (Type 1) topological_space) : @topological_space.separable_space.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_168340 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (has_edist.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_edist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_168341 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (linear_ordered_comm_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_168342 (h0 : function.extfun Type (functor.add_const (ordered_add_comm_monoid (is_R_or_C empty)))) : @archimedean.{0} (is_R_or_C.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (is_R_or_C.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ordered_add_comm_monoid.{0} (is_R_or_C.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_168343 (h0 : topological_space (canonically_ordered_monoid (has_add (has_add (has_pos_part linarith.comp))))) : normal_space (canonically_ordered_monoid (has_add (has_add (has_pos_part linarith.comp)))) := sorry --non-trivial
lemma new_lemma_168344 (h0 : group (normed_group (denumerable linarith.ineq))) : is_cyclic (normed_group (denumerable linarith.ineq)) := sorry --non-trivial
lemma new_lemma_168345 (h0 : group (linear_ordered_add_comm_group char)) : is_cyclic (linear_ordered_add_comm_group char) := sorry --non-trivial
lemma new_lemma_168346 (h0 : complete_lattice (measurable_space (has_top linarith.comp))) : is_compactly_generated (measurable_space (has_top linarith.comp)) := sorry --non-trivial
lemma new_lemma_168347 (h0 : functor.add_const (topological_space (normed_linear_ordered_group empty)) congr_arg_kind) : @locally_compact_space.{0} (normed_linear_ordered_group.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_linear_ordered_group.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_168348 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (has_pos_part.{0} name) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (has_pos_part.{0} name))  := sorry --non-trivial
lemma new_lemma_168349 (h0 : functor.add_const (add_monoid (semigroup linarith.comp)) pos) : @add_monoid.fg.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_monoid.{0} (semigroup.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_168350 (h0 : function.extfun Type (functor.add_const (ring (ordered_ring congr_arg_kind)))) : @strong_rank_condition.{0} (ordered_ring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ring.{0} (ordered_ring.{0} congr_arg_kind)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} (ordered_ring.{0} congr_arg_kind))) h0 empty))  := sorry --non-trivial
lemma new_lemma_168351 (h0 : functor.add_const (functor.add_const (complete_lattice (linear_order empty)) empty) num) : @complete_lattice.is_Sup_finite_compact.{0} (linear_order.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (linear_order.{0} empty)) empty (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (complete_lattice.{0} (linear_order.{0} empty)) empty) num h0))  := sorry --non-trivial
lemma new_lemma_168352 (h0 : functor.add_const (function.extfun Type finset) (has_add name)) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_168353 (h3 : complete_lattice (comm_ring to_additive.value_type)) : is_compactly_generated (comm_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_168354 (h0 : functor.add_const (monoid (has_zero name)) name) : @monoid.fg.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (monoid.{0} (has_zero.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_168355 (h0 : functor.add_const empty (pseudo_metric_space (option congr_arg_kind))) : empty.elim (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_168356 (h0 : add_monoid (has_add (finset name))) : add_monoid.fg (has_add (finset name)) := sorry --non-trivial
lemma new_lemma_168357 (h0 : complete_lattice (distrib_lattice linarith.ineq)) : complete_lattice.is_Sup_finite_compact (distrib_lattice linarith.ineq) := sorry --non-trivial
lemma new_lemma_168358 (h2 : topological_space (has_ssubset (random_gen ereal))) : totally_disconnected_space (has_ssubset (random_gen ereal)) := sorry --non-trivial
lemma new_lemma_168359 (h0 : topological_space (canonically_ordered_comm_semiring pos)) : topological_space.separable_space (canonically_ordered_comm_semiring pos) := sorry --non-trivial
lemma new_lemma_168360 (h2 : topological_space nat) (h3 : preorder nat) : order_closed_topology nat := sorry --non-trivial
lemma new_lemma_168361 (h0 : complete_lattice (normed_group num)) : is_compactly_generated (normed_group num) := sorry --non-trivial
lemma new_lemma_168362 (h0 : group (dlist (has_ssubset (has_nnnorm linarith.ineq)))) : group.fg (dlist (has_ssubset (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_168363 (h0 : not (complete_lattice (has_top linarith.comp_source) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_top.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_top.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_168364 (h0 : group (linear_ordered_comm_group num)) : is_cyclic (linear_ordered_comm_group num) := sorry --non-trivial
lemma new_lemma_168365 (h0 : function.extfun Type topological_space) : @t0_space.{0} (linear_order.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_168366 (h0 : prod (option num) (option num)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_168367 (h0 : topological_space (complete_semilattice_Sup (semiring unsigned))) : topological_space.separable_space (complete_semilattice_Sup (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_168368 (h0 : add_monoid (measure_theory.measure_space unsigned)) : add_monoid.fg (measure_theory.measure_space unsigned) := sorry --non-trivial
lemma new_lemma_168369 (h0 : functor.comp semiring semigroup name) : @is_noetherian_ring.{0} (semigroup.{0} name) (@functor.comp.run.{0 0 0} semiring.{0} semigroup.{0} name h0)  := sorry --non-trivial
lemma new_lemma_168370 (h0 : ordered_add_comm_monoid (add_cancel_monoid (option name))) : archimedean (add_cancel_monoid (option name)) := sorry --non-trivial
lemma new_lemma_168371 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (linear_ordered_field.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (linear_ordered_field.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_168372 (h0 : topological_space (ordered_cancel_add_comm_monoid (option pos))) : normal_space (ordered_cancel_add_comm_monoid (option pos)) := sorry --non-trivial
lemma new_lemma_168373 (h0 : function.extfun (Type 1) (functor.comp topological_space canonically_ordered_comm_semiring)) : @totally_separated_space.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} canonically_ordered_comm_semiring.{1} Type (@function.extfun_app.{3 2} (Type 1) (functor.comp.{1 1 1} topological_space.{1} canonically_ordered_comm_semiring.{1}) h0 Type))  := sorry --non-trivial
lemma new_lemma_168374 (h0 : topological_space (has_neg_part environment.implicit_infer_kind)) : regular_space (has_neg_part environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_168375 (h0 : ring (has_star (option unsigned))) : is_domain (has_star (option unsigned)) := sorry --non-trivial
lemma new_lemma_168376 (h0 : complete_lattice (complete_distrib_lattice linarith.comp)) : complete_lattice.is_Sup_finite_compact (complete_distrib_lattice linarith.comp) := sorry --non-trivial
lemma new_lemma_168377 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (add_comm_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (add_comm_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_168378 (h1 : topological_space (normed_group to_additive.value_type)) : totally_disconnected_space (normed_group to_additive.value_type) := sorry --non-trivial
lemma new_lemma_168379 (h0 : semiring (canonically_ordered_monoid (has_Inf real))) : is_noetherian_ring (canonically_ordered_monoid (has_Inf real)) := sorry --non-trivial
lemma new_lemma_168380 (h0 : has_mem.mem (functor.comp ring measurable_space) has_emptyc.emptyc) : @is_domain.{0} (measurable_space.{0} fun_info) (@functor.comp.run.{0 0 0} ring.{0} measurable_space.{0} fun_info (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} ring.{0} measurable_space.{0}) (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) (functor.comp.{0 0 0} ring.{0} measurable_space.{0}) h0) fun_info))  := sorry --non-trivial
lemma new_lemma_168381 (h0 : functor.add_const (topological_space (complete_distrib_lattice unsigned)) empty) : @normal_space.{0} (complete_distrib_lattice.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_168382 (h0 : functor.add_const (ring (ordered_comm_ring pos)) (ordered_ring linarith.comp)) : @is_principal_ideal_ring.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (ordered_comm_ring.{0} pos)) (ordered_ring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_168383 (h0 : function.extfun Type (functor.comp group has_nndist)) : @is_cyclic.{0} (has_nndist.{0} pos) (@functor.comp.run.{0 0 0} group.{0} has_nndist.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} group.{0} has_nndist.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_168384 (h0 : topological_space (has_top (semiring (semiring num)))) : irreducible_space (has_top (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_168385 (h0 : ring (add_cancel_monoid (option (option empty)))) : rank_condition (add_cancel_monoid (option (option empty))) := sorry --non-trivial
lemma new_lemma_168386 (h0 : topological_space (has_nndist (comm_group Type))) : normal_space (has_nndist (comm_group Type)) := sorry --non-trivial
lemma new_lemma_168387 (h0 : group (id fun_info)) : normalizer_condition (id fun_info) := sorry --non-trivial
lemma new_lemma_168388 (h0 : uniform_space (has_bot real)) : separated_space (has_bot real) := sorry --non-trivial
lemma new_lemma_168389 (h1 : topological_space char) (h2 : has_sub char) : has_continuous_sub char := sorry --non-trivial
lemma new_lemma_168390 (h0 : ring (has_emptyc linarith.comp)) : rank_condition (has_emptyc linarith.comp) := sorry --non-trivial
lemma new_lemma_168391 (h0 : group (has_emptyc (random_gen (random_gen (random_gen string_imp)))) -> linarith.comp_source) (h1 : function.extfun (set linarith.comp_source) coe_sort) : @normalizer_condition.{0} (has_emptyc.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} string_imp)))) (@set.range_splitting.{0 0} (group.{0} (has_emptyc.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} string_imp))))) linarith.comp_source h0 (@function.extfun_app.{1 1} (set.{0} linarith.comp_source) (@coe_sort.{1 2} (set.{0} linarith.comp_source) Type (@set.has_coe_to_sort.{0} linarith.comp_source)) h1 (@set.range.{0 1} linarith.comp_source (group.{0} (has_emptyc.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} string_imp))))) h0)))  := sorry --non-trivial
lemma new_lemma_168392 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (complete_linear_order.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_linear_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_168393 (h0 : complete_lattice (normed_group linarith.comp)) : is_compactly_generated (normed_group linarith.comp) := sorry --non-trivial
lemma new_lemma_168394 (h0 : function.extfun Type group) : @normalizer_condition.{0} (measurable_space.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (measurable_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_168395 (h0 : topological_space (metric_space (has_norm (has_norm unsigned)))) : irreducible_space (metric_space (has_norm (has_norm unsigned))) := sorry --non-trivial
lemma new_lemma_168396 (h0 : group (boolean_algebra (has_add linarith.comp))) : group.fg (boolean_algebra (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_168397 (h0 : group (has_Inf (has_Inf linarith.comp))) : is_cyclic (has_Inf (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_168398 (h0 : cancel_comm_monoid_with_zero (has_bot (has_neg (has_neg (has_neg pos))))) : unique_factorization_monoid (has_bot (has_neg (has_neg (has_neg pos)))) := sorry --non-trivial
lemma new_lemma_168399 (h0 : monoid (ordered_comm_monoid (has_add (has_pos_part real)))) : monoid.fg (ordered_comm_monoid (has_add (has_pos_part real))) := sorry --non-trivial
lemma new_lemma_168400 (h0 : topological_space (has_add (has_neg_part Type))) : discrete_topology (has_add (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_168401 (h0 : topological_space (boolean_algebra.core (option pos))) : locally_compact_space (boolean_algebra.core (option pos)) := sorry --non-trivial
lemma new_lemma_168402 (h1 : set (mul_one_class enat -> std_gen)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_168403 (h0 : ordered_add_comm_monoid (has_neg unsigned)) : archimedean (has_neg unsigned) := sorry --non-trivial
lemma new_lemma_168404 (h0 : topological_space (has_sub (semiring unsigned))) : topological_space.separable_space (has_sub (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_168405 (h0 : functor.add_const (topological_space (has_star num)) (semiring num)) : @t1_space.{0} (has_star.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} num)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_168406 (h0 : functor.add_const (topological_space (semigroup environment.implicit_infer_kind)) linarith.comp) : @loc_path_connected_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_168407 (h0 : functor.add_const (complete_lattice (add_cancel_monoid name)) name) : @is_compactly_generated.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_cancel_monoid.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_168408 (h0 : functor.add_const (topological_space (has_add ennreal)) Type) : @totally_separated_space.{0} (has_add.{0} ennreal) (@functor.add_const.run.{0 1} (topological_space.{0} (has_add.{0} ennreal)) Type h0)  := sorry --non-trivial
lemma new_lemma_168409 (h0 : ring (add_cancel_monoid (has_neg linarith.comp))) : is_domain (add_cancel_monoid (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_168410 (h0 : ring (has_emptyc num)) : is_domain (has_emptyc num) := sorry --non-trivial
lemma new_lemma_168411 (h0 : functor.add_const (uniform_space (finset environment.implicit_infer_kind)) linarith.comp) : @complete_space.{0} (finset.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (uniform_space.{0} (finset.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_168412 (h0 : function.extfun (Type 1 -> Type 2) (function.extfun (Type 1))) : @totally_disconnected_space.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (has_to_string.{0} environment.implicit_infer_kind)) (has_pos_part.{1} (has_pos_part.{1} Type)) (@functor.add_const.run.{0 1} (functor.add_const.{0 1} (topological_space.{0} (has_to_string.{0} environment.implicit_infer_kind)) (has_pos_part.{1} (has_pos_part.{1} Type))) (has_to_string.{1} Type) (@functor.add_const.run.{0 1} (functor.add_const.{0 1} (functor.add_const.{0 1} (topological_space.{0} (has_to_string.{0} environment.implicit_infer_kind)) (has_pos_part.{1} (has_pos_part.{1} Type))) (has_to_string.{1} Type)) (has_to_string.{1} Type) (@functor.add_const.run.{0 1} (functor.add_const.{0 1} (functor.add_const.{0 1} (functor.add_const.{0 1} (topological_space.{0} (has_to_string.{0} environment.implicit_infer_kind)) (has_pos_part.{1} (has_pos_part.{1} Type))) (has_to_string.{1} Type)) (has_to_string.{1} Type)) Type (@functor.add_const.run.{0 0} (functor.add_const.{0 1} (functor.add_const.{0 1} (functor.add_const.{0 1} (functor.add_const.{0 1} (topological_space.{0} (has_to_string.{0} environment.implicit_infer_kind)) (has_pos_part.{1} (has_pos_part.{1} Type))) (has_to_string.{1} Type)) (has_to_string.{1} Type)) Type) pos (@functor.add_const.run.{0 1} (functor.add_const.{0 0} (functor.add_const.{0 1} (functor.add_const.{0 1} (functor.add_const.{0 1} (functor.add_const.{0 1} (topological_space.{0} (has_to_string.{0} environment.implicit_infer_kind)) (has_pos_part.{1} (has_pos_part.{1} Type))) (has_to_string.{1} Type)) (has_to_string.{1} Type)) Type) pos) (has_to_string.{1} Type) (@function.extfun_app.{3 1} (Type 1) (functor.add_const.{0 1} (functor.add_const.{0 0} (functor.add_const.{0 1} (functor.add_const.{0 1} (functor.add_const.{0 1} (functor.add_const.{0 1} (topological_space.{0} (has_to_string.{0} environment.implicit_infer_kind)) (has_pos_part.{1} (has_pos_part.{1} Type))) (has_to_string.{1} Type)) (has_to_string.{1} Type)) Type) pos)) (@functor.add_const.run.{2 1} (function.extfun.{3 1} (Type 1) (functor.add_const.{0 1} (functor.add_const.{0 0} (functor.add_const.{0 1} (functor.add_const.{0 1} (functor.add_const.{0 1} (functor.add_const.{0 1} (topological_space.{0} (has_to_string.{0} environment.implicit_infer_kind)) (has_pos_part.{1} (has_pos_part.{1} Type))) (has_to_string.{1} Type)) (has_to_string.{1} Type)) Type) pos))) (mul_one_class.{1} Type) (@function.extfun_app.{3 3} (Type 1) (functor.add_const.{2 1} (function.extfun.{3 1} (Type 1) (functor.add_const.{0 1} (functor.add_const.{0 0} (functor.add_const.{0 1} (functor.add_const.{0 1} (functor.add_const.{0 1} (functor.add_const.{0 1} (topological_space.{0} (has_to_string.{0} environment.implicit_infer_kind)) (has_pos_part.{1} (has_pos_part.{1} Type))) (has_to_string.{1} Type)) (has_to_string.{1} Type)) Type) pos)))) (@function.extfun_app.{4 3} (Type 1 → Type 2) (function.extfun.{3 3} (Type 1)) h0 (functor.add_const.{2 1} (function.extfun.{3 1} (Type 1) (functor.add_const.{0 1} (functor.add_const.{0 0} (functor.add_const.{0 1} (functor.add_const.{0 1} (functor.add_const.{0 1} (functor.add_const.{0 1} (topological_space.{0} (has_to_string.{0} environment.implicit_infer_kind)) (has_pos_part.{1} (has_pos_part.{1} Type))) (has_to_string.{1} Type)) (has_to_string.{1} Type)) Type) pos))))) (mul_one_class.{1} Type))) (has_to_string.{1} Type))))))))  := sorry --non-trivial
lemma new_lemma_168413 (h0 : topological_space (has_bot (has_add real))) : t1_space (has_bot (has_add real)) := sorry --non-trivial
lemma new_lemma_168414 (h0 : ring (ordered_cancel_add_comm_monoid ennreal)) : rank_condition (ordered_cancel_add_comm_monoid ennreal) := sorry --non-trivial
lemma new_lemma_168415 (h0 : group (has_zero (semigroup environment.implicit_infer_kind))) : normalizer_condition (has_zero (semigroup environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_168416 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (semiring.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_168417 (h0 : filter (ordered_comm_ring fun_info)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_168418 (h0 : topological_space (linear_ordered_add_comm_group (has_norm string_imp))) : t0_space (linear_ordered_add_comm_group (has_norm string_imp)) := sorry --non-trivial
lemma new_lemma_168419 (h0 : topological_space (boolean_algebra (boolean_algebra.core pos))) : totally_separated_space (boolean_algebra (boolean_algebra.core pos)) := sorry --non-trivial
lemma new_lemma_168420 (h1 : set (has_compl linarith.comp_source)) : set.subsingleton h1 := sorry --non-trivial
lemma new_lemma_168421 (h0 : function.extfun Type topological_space) : @normal_space.{0} (has_union.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_union.{0} num))  := sorry --non-trivial
lemma new_lemma_168422 (h0 : ring (distrib (topological_space linarith.ineq))) : rank_condition (distrib (topological_space linarith.ineq)) := sorry --non-trivial
lemma new_lemma_168423 (h0 : uniform_space (semigroup (finset linarith.comp))) : complete_space (semigroup (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_168424 (h0 : function.extfun nat fin) : @is_simple_group.{0} (sub_neg_monoid.{0} real) (@function.extfun_app.{2 1} Type group.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type group.{0}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (sub_neg_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_168425 (h0 : topological_space (has_zero (finset (has_pos_part Type)))) : loc_path_connected_space (has_zero (finset (has_pos_part Type))) := sorry --non-trivial
lemma new_lemma_168426 (h0 : complete_lattice (normed_field char)) : complete_lattice.is_Sup_finite_compact (normed_field char) := sorry --non-trivial
lemma new_lemma_168427 (h0 : functor.add_const (complete_lattice (semigroup empty)) empty) : @complete_lattice.is_Sup_finite_compact.{0} (semigroup.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (semigroup.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_168428 (h0 : function.extfun Type complete_lattice) : complete_lattice.is_Sup_finite_compact (measurable_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_168429 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (group_with_zero.{0} ennreal) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (group_with_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_168430 (h0 : ring (semi_normed_comm_ring (mul_one_class linarith.comp_source))) : rank_condition (semi_normed_comm_ring (mul_one_class linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_168431 (h0 : complete_lattice (generalized_boolean_algebra (has_add name))) : complete_lattice.is_Sup_finite_compact (generalized_boolean_algebra (has_add name)) := sorry --non-trivial
lemma new_lemma_168432 (h0 : topological_space (add_group (has_norm (random_gen (has_norm linarith.comp))))) : irreducible_space (add_group (has_norm (random_gen (has_norm linarith.comp)))) := sorry --non-trivial
lemma new_lemma_168433 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_168434 (h0 : uniform_space (has_edist (option unsigned))) : complete_space (has_edist (option unsigned)) := sorry --non-trivial
lemma new_lemma_168435 (h0 : topological_space (add_comm_semigroup enat)) : compact_space (add_comm_semigroup enat) := sorry --non-trivial
lemma new_lemma_168436 (h0 : function.extfun (Type 1) complete_lattice) : @is_atomistic.{1} (has_neg.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} h0 (has_neg.{1} Type))  := sorry --non-trivial
lemma new_lemma_168437 (h0 : function.extfun Type group) : @is_cyclic.{0} (non_assoc_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (non_assoc_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_168438 (h0 : function.extfun Type group) : @is_cyclic.{0} (partial_order.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (partial_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_168439 (h0 : topological_space (normed_group (random_gen (random_gen linarith.ineq)))) : path_connected_space (normed_group (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_168440 (h0 : has_mem.mem (with_bot num) has_emptyc.emptyc) : filter.ne_bot (finset.pi.empty filter (with_bot num) h0) := sorry --non-trivial
lemma new_lemma_168441 (h0 : ring (add_group_with_zero_nhd empty)) : rank_condition (add_group_with_zero_nhd empty) := sorry --non-trivial
lemma new_lemma_168442 (h0 : functor.add_const (filter (cancel_monoid environment.implicit_infer_kind)) (has_add Type)) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_168443 (h0 : topological_space (comm_ring to_additive.value_type)) : locally_compact_space (comm_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_168444 (h0 : uniform_space (is_R_or_C (option empty))) : complete_space (is_R_or_C (option empty)) := sorry --non-trivial
lemma new_lemma_168445 (h0 : functor.add_const (semiring (has_nndist Type)) unsigned) : @is_noetherian_ring.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (semiring.{1} (has_nndist.{1} Type)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_168446 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (add_comm_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_comm_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_168447 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (canonically_linear_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (canonically_linear_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_168448 (h0 : uniform_space (with_bot (has_inv (comm_ring linarith.ineq)))) : complete_space (with_bot (has_inv (comm_ring linarith.ineq))) := sorry --non-trivial
lemma new_lemma_168449 (h0 : not (ring (has_norm congr_arg_kind) -> false)) : @strong_rank_condition.{0} (has_norm.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (ring.{0} (has_norm.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_168450 (h0 : add_group (comm_semigroup pos)) : is_add_cyclic (comm_semigroup pos) := sorry --non-trivial
lemma new_lemma_168451 (h0 : measurable_space char) (h2 : filter char) (h3 : list (filter char)) : filter.is_measurably_generated (list.ilast' h2 h3) := sorry --non-trivial
lemma new_lemma_168452 (h0 : functor.add_const (ring (sub_neg_monoid pos)) linarith.comp) : @is_principal_ideal_ring.{0} (sub_neg_monoid.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (sub_neg_monoid.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_168453 (h0 : functor.add_const (list (has_Inf linarith.comp)) (has_add (ring name))) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_168454 (h0 : functor.add_const (function.extfun Type list) linarith.comp) : list.nodup (function.extfun_app (functor.add_const.run h0) (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_168455 (h0 : not (topological_space name -> false)) : @irreducible_space.{0} name (@classical.by_contradiction'.{1} (topological_space.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_168456 (h0 : functor.add_const (topological_space (ring pos)) (ring (has_neg Type))) : @t0_space.{0} (ring.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (ring.{0} pos)) (ring.{1} (has_neg.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_168457 (h0 : function.extfun Type group) : @normalizer_condition.{0} (as_linear_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (as_linear_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_168458 (h2 : set (has_lt string_imp)) : set.finite h2 := sorry --non-trivial
lemma new_lemma_168459 (h0 : cancel_comm_monoid_with_zero (normed_comm_ring (comm_group (comm_group name)))) : unique_factorization_monoid (normed_comm_ring (comm_group (comm_group name))) := sorry --non-trivial
lemma new_lemma_168460 (h1 : complete_lattice (has_div to_additive.value_type)) : is_compactly_generated (has_div to_additive.value_type) := sorry --non-trivial
lemma new_lemma_168461 (h0 : ring (add_comm_monoid (option empty))) : is_principal_ideal_ring (add_comm_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_168462 (h0 : function.extfun Type (functor.comp topological_space canonically_ordered_comm_semiring)) : @irreducible_space.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} canonically_ordered_comm_semiring.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} canonically_ordered_comm_semiring.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_168463 (h1 : multiset (has_le linarith.ineq)) : multiset.nodup h1 := sorry --non-trivial
lemma new_lemma_168464 (h0 : functor.add_const (topological_space (semigroup environment.implicit_infer_kind)) pos) : @normal_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_168465 (h2 : ring (has_Sup (has_nnnorm (random_gen (has_nnnorm char))))) : strong_rank_condition (has_Sup (has_nnnorm (random_gen (has_nnnorm char)))) := sorry --non-trivial
lemma new_lemma_168466 (h0 : topological_space (add_group (semiring (semiring unsigned)))) : t0_space (add_group (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_168467 (h0 : complete_lattice (id unsigned)) : is_atomistic (id unsigned) := sorry --non-trivial
lemma new_lemma_168468 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (simple_graph.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (simple_graph.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_168469 (h0 : functor.comp semiring canonically_ordered_comm_semiring Type) : @is_noetherian_ring.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.comp.run.{1 1 1} semiring.{1} canonically_ordered_comm_semiring.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_168470 (h0 : topological_space (has_top (has_norm linarith.comp))) : normal_space (has_top (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_168471 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (with_bot.{0} string_imp) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (with_bot.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_168472 (h0 : function.extfun (finset Type) (has_mem.mem (has_norm fun_info))) : @irreducible_space.{0} (has_norm.{0} fun_info) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_norm.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_norm.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_168473 (h0 : ring (with_bot (random_gen (random_gen num)))) : rank_condition (with_bot (random_gen (random_gen num))) := sorry --non-trivial
lemma new_lemma_168474 (h0 : functor.comp topological_space canonically_ordered_comm_semiring pos) : @topological_space.separable_space.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} canonically_ordered_comm_semiring.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_168475 (h0 : functor.add_const (topological_space (has_dist empty)) ennreal) : @preirreducible_space.{0} (has_dist.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_dist.{0} empty)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_168476 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} unsigned (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) unsigned)  := sorry --non-trivial
lemma new_lemma_168477 (h0 : complete_lattice (measurable_space to_additive.value_type)) : complete_lattice.is_Sup_finite_compact (measurable_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_168478 (h0 : Prop) : id (id (id (id (id h0)))) := sorry --non-trivial
lemma new_lemma_168479 (h0 : not (topological_space (has_norm congr_arg_kind) -> false)) : @path_connected_space.{0} (has_norm.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (has_norm.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_168480 (h0 : fin has_zero.zero) : @unique_factorization_monoid.{1} (has_add.{1} Type) (@matrix.vec_empty.{1} (cancel_comm_monoid_with_zero.{1} (has_add.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_168481 (h0 : filter (linear_ordered_comm_monoid_with_zero (option (option (option empty))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_168482 (h0 : function.extfun Type group) : @normalizer_condition.{0} (canonically_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (canonically_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_168483 (h0 : functor.add_const (topological_space (has_Inf linarith.comp)) linarith.comp) : @preirreducible_space.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_168484 (h0 : ring (ring (option (option (option (option unsigned)))))) : strong_rank_condition (ring (option (option (option (option unsigned))))) := sorry --non-trivial
lemma new_lemma_168485 (h0 : complete_lattice (complete_distrib_lattice (sub_neg_monoid (finset real)))) : is_compactly_generated (complete_distrib_lattice (sub_neg_monoid (finset real))) := sorry --non-trivial
lemma new_lemma_168486 (h0 : functor.comp filter add_cancel_monoid environment.implicit_infer_kind) : countable_Inter_filter (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_168487 (h0 : topological_space (metric_space (semiring congr_arg_kind))) : irreducible_space (metric_space (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_168488 (h0 : function.extfun Type group) : @group.fg.{0} (with_bot.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} h0 (with_bot.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_168489 (h0 : fin has_zero.zero) : @regular_space.{1} (normed_lattice_add_comm_group.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (normed_lattice_add_comm_group.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_168490 (h1 : topological_space (mul_one_class linarith.ineq)) (h2 : set (mul_one_class linarith.ineq)) : is_path_connected h2 := sorry --non-trivial
lemma new_lemma_168491 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (with_one string_imp)) := sorry --non-trivial
lemma new_lemma_168492 (h0 : monoid (denumerable (random_gen (random_gen linarith.ineq)))) : monoid.fg (denumerable (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_168493 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (semigroup.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_168494 (h0 : topological_space (has_pos_part (has_pos_part Type))) : irreducible_space (has_pos_part (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_168495 (h0 : topological_space (comm_semigroup pos)) : loc_path_connected_space (comm_semigroup pos) := sorry --non-trivial
lemma new_lemma_168496 (h0 : ring (has_add (sub_neg_monoid Type))) : is_principal_ideal_ring (has_add (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_168497 (h0 : add_group (has_compl reducibility_hints)) : is_add_cyclic (has_compl reducibility_hints) := sorry --non-trivial
lemma new_lemma_168498 (h0 : monoid (has_Inf Type)) : monoid.fg (has_Inf Type) := sorry --non-trivial
lemma new_lemma_168499 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (has_edist.{0} empty) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_edist.{0} empty))  := sorry --non-trivial
lemma new_lemma_168500 (h1 : ring (simple_graph std_gen)) : is_domain (simple_graph std_gen) := sorry --non-trivial
lemma new_lemma_168501 (h0 : finset (add_cancel_monoid ennreal)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_168502 (h0 : topological_space (has_neg_part (has_to_string (finset (finset (finset name)))))) : normal_space (has_neg_part (has_to_string (finset (finset (finset name))))) := sorry --non-trivial
lemma new_lemma_168503 (h1 : not (uniform_space (has_add char) -> false)) : @complete_space.{0} (has_add.{0} char) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_add.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_168504 (h0 : ring (has_ssubset linarith.comp_source)) : rank_condition (has_ssubset linarith.comp_source) := sorry --non-trivial
lemma new_lemma_168505 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_sub.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_sub.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_168506 (h0 : functor.add_const (add_group (cancel_monoid pos)) Type) : @is_add_cyclic.{0} (cancel_monoid.{0} pos) (@functor.add_const.run.{0 1} (add_group.{0} (cancel_monoid.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_168507 (h0 : functor.add_const (list (add_cancel_monoid unsigned)) num) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_168508 (h0 : topological_space (normed_lattice_add_comm_group name)) : totally_separated_space (normed_lattice_add_comm_group name) := sorry --non-trivial
lemma new_lemma_168509 (h0 : topological_space (semiring (add_left_cancel_semigroup unsigned))) : irreducible_space (semiring (add_left_cancel_semigroup unsigned)) := sorry --non-trivial
lemma new_lemma_168510 (h0 : functor.add_const (monoid (boolean_algebra Type)) (ring Type)) : @monoid.fg.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 1} (monoid.{1} (boolean_algebra.{1} Type)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_168511 (h0 : add_monoid (has_nndist real)) : add_monoid.fg (has_nndist real) := sorry --non-trivial
lemma new_lemma_168512 (h0 : functor.add_const (ordered_comm_monoid (ring environment.implicit_infer_kind)) (boolean_algebra Type)) : @has_exists_mul_of_le.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (ring.{0} environment.implicit_infer_kind)) (boolean_algebra.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_168513 (h0 : functor.comp cancel_comm_monoid_with_zero has_to_string Type) : @unique_factorization_monoid.{1} (has_to_string.{1} Type) (@functor.comp.run.{1 1 1} cancel_comm_monoid_with_zero.{1} has_to_string.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_168514 (h0 : functor.add_const (topological_space (has_zero Type)) linarith.comp) : @preconnected_space.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_zero.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_168515 (h0 : uniform_space (plift (semiring num))) : separated_space (plift (semiring num)) := sorry --non-trivial
lemma new_lemma_168516 (h1 : group (uniform_space (has_top (has_nnnorm to_additive.value_type)))) : group.fg (uniform_space (has_top (has_nnnorm to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_168517 (h0 : topological_space (semi_normed_ring (mul_one_class char))) : totally_disconnected_space (semi_normed_ring (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_168518 (h0 : group (finset to_additive.value_type)) : is_cyclic (finset to_additive.value_type) := sorry --non-trivial
lemma new_lemma_168519 (h0 : topological_space (has_Inf (has_add linarith.comp))) : topological_space.separable_space (has_Inf (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_168520 (h0 : topological_space (linear_order (option unsigned))) : totally_separated_space (linear_order (option unsigned)) := sorry --non-trivial
lemma new_lemma_168521 (h1 : topological_space (semi_normed_ring string_imp)) (h2 : not (preorder (semi_normed_ring string_imp) -> false)) : @order_topology.{0} (semi_normed_ring.{0} string_imp) h1 (@classical.by_contradiction'.{1} (preorder.{0} (semi_normed_ring.{0} string_imp)) h2)  := sorry --non-trivial
lemma new_lemma_168522 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (comm_group.{0} (cancel_monoid.{0} ennreal)) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (comm_group.{0} (cancel_monoid.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_168523 (h0 : list (add_cancel_monoid environment.implicit_infer_kind)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_168524 (h2 : topological_space linarith.ineq) (h3 : preorder linarith.ineq) : order_closed_topology linarith.ineq := sorry --non-trivial
lemma new_lemma_168525 (h0 : not (filter (has_append linarith.comp_source) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_168526 (h0 : add_group (ring (normed_comm_ring linarith.comp))) : is_add_cyclic (ring (normed_comm_ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_168527 (h0 : list (semigroup (add_cancel_monoid (has_neg_part name)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_168528 (h0 : functor.add_const (uniform_space (has_add pos)) Type) : @complete_space.{0} (has_add.{0} pos) (@functor.add_const.run.{0 1} (uniform_space.{0} (has_add.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_168529 (h0 : not (function.extfun Type ring -> false)) : @strong_rank_condition.{0} (add_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (add_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_168530 (h0 : topological_space (fintype (has_nnnorm char))) : path_connected_space (fintype (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_168531 (h0 : functor.add_const (group (has_pos_part linarith.comp)) Type) : @is_simple_group.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 1} (group.{0} (has_pos_part.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_168532 (h0 : functor.add_const (topological_space (has_add Type)) (finset Type)) : @regular_space.{1} (has_add.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_add.{1} Type)) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_168533 (h0 : topological_space (add_cancel_monoid num)) : loc_path_connected_space (add_cancel_monoid num) := sorry --non-trivial
lemma new_lemma_168534 (h0 : topological_space (generalized_boolean_algebra (has_add (has_bot Type)))) : t1_space (generalized_boolean_algebra (has_add (has_bot Type))) := sorry --non-trivial
lemma new_lemma_168535 (h0 : topological_space (normed_comm_ring (cancel_monoid (comm_group pos)))) : preconnected_space (normed_comm_ring (cancel_monoid (comm_group pos))) := sorry --non-trivial
lemma new_lemma_168536 (h0 : filter (has_zero (has_add (has_add (has_add pos))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_168537 (h0 : not (function.extfun Type monoid -> false)) : @monoid.fg.{0} (has_norm.{0} linarith.comp) (@function.extfun_app.{2 1} Type monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type monoid.{0}) h0) (has_norm.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_168538 (h0 : add_group (has_compl (has_nnnorm (has_nnnorm linarith.ineq)))) : is_add_cyclic (has_compl (has_nnnorm (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_168539 (h0 : add_monoid (normed_group linarith.comp)) : add_monoid.fg (normed_group linarith.comp) := sorry --non-trivial
lemma new_lemma_168540 (h0 : uniform_space (finset (has_neg (ring environment.implicit_infer_kind)))) : complete_space (finset (has_neg (ring environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_168541 (h0 : ring (with_bot (semiring (semiring (semiring (semiring (semiring (semiring unsigned)))))))) : is_domain (with_bot (semiring (semiring (semiring (semiring (semiring (semiring unsigned))))))) := sorry --non-trivial
lemma new_lemma_168542 (h0 : monoid (finset (has_neg (finset (has_neg Type))))) : monoid.fg (finset (has_neg (finset (has_neg Type)))) := sorry --non-trivial
lemma new_lemma_168543 (h0 : functor.add_const (topological_space (has_to_string unsigned)) pos) : @normal_space.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_168544 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (has_emptyc.{0} linarith.ineq) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (has_emptyc.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_168545 (h0 : topological_space (has_pos_part (has_Inf (has_Inf (has_Inf real))))) : totally_disconnected_space (has_pos_part (has_Inf (has_Inf (has_Inf real)))) := sorry --non-trivial
lemma new_lemma_168546 (h0 : functor.add_const (monoid (has_inter ennreal)) ennreal) : @monoid.fg.{0} (has_inter.{0} ennreal) (@functor.add_const.run.{0 0} (monoid.{0} (has_inter.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_168547 (h0 : topological_space (finset (has_to_string pos))) : t1_space (finset (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_168548 (h0 : not (semiring (plift congr_arg_kind) -> false)) : @is_noetherian_ring.{1} (plift.{1} congr_arg_kind) (@classical.by_contradiction'.{2} (semiring.{1} (plift.{1} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_168549 (h0 : complete_lattice string) : is_compactly_generated string := sorry --non-trivial
lemma new_lemma_168550 (h0 : ulower (fin has_zero.zero)) : matrix.vec_empty (matrix.vec_empty (matrix.vec_empty (ulower.up h0))) := sorry --non-trivial
lemma new_lemma_168551 (h0 : topological_space (finset (finset (add_comm_monoid Type)))) : regular_space (finset (finset (add_comm_monoid Type))) := sorry --non-trivial
lemma new_lemma_168552 (h0 : functor.add_const (topological_space (has_neg linarith.comp)) Type) : @preconnected_space.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_168553 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @locally_compact_space.{0} (has_norm.{0} (random_gen.{0} linarith.comp_source)) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) topological_space.{0}) (has_norm.{0} (random_gen.{0} linarith.comp_source)))  := sorry --non-trivial
lemma new_lemma_168554 (h0 : group (has_scalar pos (comm_group (comm_group Type)))) : is_simple_group (has_scalar pos (comm_group (comm_group Type))) := sorry --non-trivial
lemma new_lemma_168555 (h0 : function.extfun Type (functor.add_const (function.extfun Type complete_lattice))) : @complete_lattice.is_Sup_finite_compact.{0} (mul_zero_class.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) name (@function.extfun_app.{2 2} Type (functor.add_const.{1 0} (function.extfun.{2 1} Type complete_lattice.{0})) h0 name)) (mul_zero_class.{0} name))  := sorry --non-trivial
lemma new_lemma_168556 (h0 : not (topological_space (has_append string.iterator_imp) -> false)) : @t0_space.{0} (has_append.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (topological_space.{0} (has_append.{0} string.iterator_imp)) h0)  := sorry --non-trivial
lemma new_lemma_168557 (h0 : has_mem.mem (normed_group num) has_emptyc.emptyc) : @path_connected_space.{0} (normed_group.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (normed_group.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_168558 (h0 : not (ring nnreal -> false)) : @is_domain.{0} nnreal (@classical.by_contradiction'.{1} (ring.{0} nnreal) h0)  := sorry --non-trivial
lemma new_lemma_168559 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_neg_part.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_neg_part.{0} name))  := sorry --non-trivial
lemma new_lemma_168560 (h0 : ring (boolean_algebra environment.implicit_infer_kind)) : is_principal_ideal_ring (boolean_algebra environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_168561 (h0 : topological_space (ordered_comm_ring (has_neg (has_neg name)))) : t1_space (ordered_comm_ring (has_neg (has_neg name))) := sorry --non-trivial
lemma new_lemma_168562 (h0 : group (add_comm_monoid (option (option ennreal)))) : is_cyclic (add_comm_monoid (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_168563 (h0 : not (complete_lattice (has_inv to_additive.value_type) -> false)) : @is_compactly_generated.{0} (has_inv.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_inv.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_168564 (h7 : topological_space (has_compl fun_info)) : path_connected_space (has_compl fun_info) := sorry --non-trivial
lemma new_lemma_168565 (h0 : cancel_comm_monoid_with_zero (semiring num)) : unique_factorization_monoid (semiring num) := sorry --non-trivial
lemma new_lemma_168566 (h0 : list (left_cancel_semigroup (semiring congr_arg_kind))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_168567 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (semiring.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_168568 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (ordered_cancel_add_comm_monoid.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (ordered_cancel_add_comm_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_168569 (h0 : functor.add_const (complete_lattice (semigroup name)) pos) : @is_compactly_generated.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (semigroup.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_168570 (h0 : group (with_one (random_gen (random_gen (random_gen (random_gen string_imp)))))) : group.fg (with_one (random_gen (random_gen (random_gen (random_gen string_imp))))) := sorry --non-trivial
lemma new_lemma_168571 (h0 : functor.add_const (group (has_dist congr_arg_kind)) empty) : @group.fg.{0} (has_dist.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (group.{0} (has_dist.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_168572 (h1 : function.extfun Type topological_space) : @locally_compact_space.{0} linarith.ineq (@function.extfun_app.{2 1} Type topological_space.{0} h1 linarith.ineq)  := sorry --non-trivial
lemma new_lemma_168573 (h0 : topological_space (add_left_cancel_semigroup (option (option (option empty))))) : loc_path_connected_space (add_left_cancel_semigroup (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_168574 (h0 : functor.add_const (function.extfun (Type 1) group) Type) : @is_cyclic.{1} (simple_graph.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) group.{1}) Type h0) (simple_graph.{1} Type))  := sorry --non-trivial
lemma new_lemma_168575 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (monoid_with_zero.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (monoid_with_zero.{0} num))  := sorry --non-trivial
lemma new_lemma_168576 (h0 : functor.add_const (topological_space (has_star congr_arg_kind)) num) : @normal_space.{0} (has_star.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_168577 (h0 : functor.add_const (uniform_space (comm_group Type)) name) : @separated_space.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (comm_group.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_168578 (h0 : functor.add_const (functor.comp group semigroup pos) Type) : @is_cyclic.{0} (semigroup.{0} pos) (@functor.comp.run.{0 0 0} group.{0} semigroup.{0} pos (@functor.add_const.run.{0 1} (functor.comp.{0 0 0} group.{0} semigroup.{0} pos) Type h0))  := sorry --non-trivial
lemma new_lemma_168579 (h0 : has_mem.mem (semiring linarith.comp) has_emptyc.emptyc) : @locally_compact_space.{0} (semiring.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (semiring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_168580 (h0 : cancel_comm_monoid_with_zero enat) (h1 : has_lt (gcd_monoid enat)) : no_max_order (gcd_monoid enat) := sorry --non-trivial
lemma new_lemma_168581 (h0 : topological_space (sub_neg_monoid (has_neg name))) : discrete_topology (sub_neg_monoid (has_neg name)) := sorry --non-trivial
lemma new_lemma_168582 (h0 : semiring (metric_space (semiring num))) : is_noetherian_ring (metric_space (semiring num)) := sorry --non-trivial
lemma new_lemma_168583 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @loc_path_connected_space.{1} (ordered_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (ordered_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_168584 (h0 : function.extfun Type (functor.comp topological_space has_to_string)) : @locally_compact_space.{0} (has_to_string.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} has_to_string.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} has_to_string.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_168585 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (free_add_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (free_add_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_168586 (h0 : add_group (has_top (random_gen (random_gen linarith.ineq)))) : is_add_cyclic (has_top (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_168587 (h0 : list (add_left_cancel_semigroup empty)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_168588 (h1 : topological_space (has_nnnorm (random_gen to_additive.value_type))) : locally_compact_space (has_nnnorm (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_168589 (h0 : ring (has_Sup (option empty))) : strong_rank_condition (has_Sup (option empty)) := sorry --non-trivial
lemma new_lemma_168590 (h0 : group (add_cancel_monoid (finset Type))) : is_cyclic (add_cancel_monoid (finset Type)) := sorry --non-trivial
lemma new_lemma_168591 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (comm_semigroup.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (comm_semigroup.{0} real))  := sorry --non-trivial
lemma new_lemma_168592 (h0 : uniform_space (has_neg (add_comm_monoid pos))) : complete_space (has_neg (add_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_168593 (h0 : functor.add_const (add_monoid (comm_group environment.implicit_infer_kind)) Type) : @add_monoid.fg.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (add_monoid.{0} (comm_group.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_168594 (h0 : set (fun_info -> std_gen)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_168595 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_compactly_generated.{1} (generalized_boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 complete_lattice.{1}) (generalized_boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_168596 (h0 : complete_lattice (has_dist (option (option congr_arg_kind)))) : complete_lattice.is_Sup_finite_compact (has_dist (option (option congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_168597 (h0 : functor.add_const (functor.add_const (uniform_space name) Type) environment.implicit_infer_kind) : @complete_space.{0} name (@functor.add_const.run.{0 1} (uniform_space.{0} name) Type (@functor.add_const.run.{0 0} (functor.add_const.{0 1} (uniform_space.{0} name) Type) environment.implicit_infer_kind h0))  := sorry --non-trivial
lemma new_lemma_168598 (h0 : functor.add_const (function.extfun (Type 1) topological_space) pos) : @discrete_topology.{1} (ordered_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) pos h0) (ordered_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_168599 (h0 : topological_space (has_norm (semiring unsigned))) : totally_disconnected_space (has_norm (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_168600 (h0 : topological_space (ring (has_neg (has_neg name)))) : discrete_topology (ring (has_neg (has_neg name))) := sorry --non-trivial
lemma new_lemma_168601 (h0 : topological_space (with_bot (has_top (has_top (has_top num))))) : discrete_topology (with_bot (has_top (has_top (has_top num)))) := sorry --non-trivial
lemma new_lemma_168602 (h0 : function.extfun (Type 1) topological_space) : @topological_space.separable_space.{1} (ordered_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (ordered_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_168603 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @locally_compact_space.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_168604 (h0 : topological_space (add_group (has_norm linarith.comp))) : totally_disconnected_space (add_group (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_168605 (h0 : not (cancel_comm_monoid_with_zero (complete_semilattice_Sup num) -> false)) : @unique_factorization_monoid.{0} (complete_semilattice_Sup.{0} num) (@classical.by_contradiction'.{1} (cancel_comm_monoid_with_zero.{0} (complete_semilattice_Sup.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_168606 (h0 : add_group (denumerable (has_ssubset fun_info))) : is_add_cyclic (denumerable (has_ssubset fun_info)) := sorry --non-trivial
lemma new_lemma_168607 (h1 : ring (encodable (has_ssubset (has_ssubset (has_ssubset fun_info))))) : strong_rank_condition (encodable (has_ssubset (has_ssubset (has_ssubset fun_info)))) := sorry --non-trivial
lemma new_lemma_168608 (h0 : add_group (boolean_algebra (has_bot Type))) : is_add_cyclic (boolean_algebra (has_bot Type)) := sorry --non-trivial
lemma new_lemma_168609 (h0 : topological_space (comm_semigroup (sub_neg_monoid pos))) : locally_compact_space (comm_semigroup (sub_neg_monoid pos)) := sorry --non-trivial
lemma new_lemma_168610 (h0 : semiring (ring (finset linarith.comp))) : is_noetherian_ring (ring (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_168611 (h0 : ring (div_inv_monoid (random_gen linarith.ineq))) : strong_rank_condition (div_inv_monoid (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_168612 (h0 : topological_space (cancel_monoid (comm_group linarith.comp))) : sequential_space (cancel_monoid (comm_group linarith.comp)) := sorry --non-trivial
lemma new_lemma_168613 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_to_string.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_168614 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @path_connected_space.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_168615 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_compactly_generated.{0} (with_one.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (with_one.{0} num))  := sorry --non-trivial
lemma new_lemma_168616 (h0 : functor.add_const (function.extfun Type group) name) : @group.fg.{0} (cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) name h0) (cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_168617 (h0 : fin has_zero.zero) : @normalizer_condition.{0} (boolean_algebra.core.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type group.{0}) (@function.extfun_app.{1 1} nat fin (@matrix.vec_empty.{0} (function.extfun.{1 1} nat fin) h0) (@has_zero.zero.{0} nat nat.has_zero))) (boolean_algebra.core.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_168618 (h1 : ring (has_compl (has_ssubset (has_ssubset (random_gen (random_gen string_imp)))))) : rank_condition (has_compl (has_ssubset (has_ssubset (random_gen (random_gen string_imp))))) := sorry --non-trivial
lemma new_lemma_168619 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (preorder.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (preorder.{0} empty))  := sorry --non-trivial
lemma new_lemma_168620 (h3 : ring enat) : strong_rank_condition enat := sorry --non-trivial
lemma new_lemma_168621 (h0 : complete_lattice (add_right_cancel_monoid (semiring empty))) : complete_lattice.is_Sup_finite_compact (add_right_cancel_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_168622 (h0 : topological_space (has_ssubset (random_gen (random_gen char)))) : locally_compact_space (has_ssubset (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_168623 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (has_add.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_add.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_168624 (h0 : cancel_comm_monoid_with_zero (canonically_ordered_add_monoid (option unsigned))) : unique_factorization_monoid (canonically_ordered_add_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_168625 (h0 : uniform_space enat -> linarith.ineq) (h1 : coe_sort (set.range h0)) : @complete_space.{0} enat (@set.range_splitting.{0 0} (uniform_space.{0} enat) linarith.ineq h0 h1)  := sorry --non-trivial
lemma new_lemma_168626 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_inter.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inter.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_168627 (h0 : complete_lattice (ring num)) : is_atomistic (ring num) := sorry --non-trivial
lemma new_lemma_168628 (h0 : topological_space (normed_group (has_top (random_gen fun_info)))) : totally_separated_space (normed_group (has_top (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_168629 (h0 : cancel_comm_monoid_with_zero (canonically_ordered_monoid (sub_neg_monoid real))) : unique_factorization_monoid (canonically_ordered_monoid (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_168630 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (simple_graph.{0} empty) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (simple_graph.{0} empty))  := sorry --non-trivial
lemma new_lemma_168631 (h0 : function.extfun Type ring) : @is_domain.{0} (pseudo_metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (pseudo_metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_168632 (h1 : add_group (comm_ring (linear_ordered_add_comm_group (has_inv to_additive.value_type)))) : is_add_cyclic (comm_ring (linear_ordered_add_comm_group (has_inv to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_168633 (h0 : topological_space (cancel_monoid (comm_group (comm_group pos)))) : locally_compact_space (cancel_monoid (comm_group (comm_group pos))) := sorry --non-trivial
lemma new_lemma_168634 (h0 : functor.add_const (topological_space (add_cancel_monoid Type)) pos) : @topological_space.separable_space.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_cancel_monoid.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_168635 (h0 : enat -> enat -> enat) (h1 : enat) : right_identity h0 h1 := sorry --non-trivial
lemma new_lemma_168636 (h0 : not (complete_lattice (dlist linarith.ineq) -> false)) : @is_compactly_generated.{0} (dlist.{0} linarith.ineq) (@classical.by_contradiction'.{1} (complete_lattice.{0} (dlist.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_168637 (h0 : ring (linear_ordered_comm_ring congr_arg_kind)) : rank_condition (linear_ordered_comm_ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_168638 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @path_connected_space.{1} (normed_lattice_add_comm_group.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (normed_lattice_add_comm_group.{1} Type)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_168639 (h0 : topological_space (normed_field enat)) : totally_disconnected_space (normed_field enat) := sorry --non-trivial
lemma new_lemma_168640 (h0 : topological_space (has_nndist (has_Inf pos))) : regular_space (has_nndist (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_168641 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_168642 (h0 : complete_lattice (normed_field linarith.ineq)) : is_compactly_generated (normed_field linarith.ineq) := sorry --non-trivial
lemma new_lemma_168643 (h1 : ring (complete_semilattice_Sup (has_inv string_imp))) : is_domain (complete_semilattice_Sup (has_inv string_imp)) := sorry --non-trivial
lemma new_lemma_168644 (h0 : group (has_Inf (has_Inf (has_bot real)))) : group.fg (has_Inf (has_Inf (has_bot real))) := sorry --non-trivial
lemma new_lemma_168645 (h0 : functor.add_const (function.extfun Type finset) linarith.comp) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (add_comm_monoid name)) := sorry --non-trivial
lemma new_lemma_168646 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (add_group.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (add_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_168647 (h0 : finset (has_neg_part (has_add ennreal))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_168648 (h0 : ring (with_zero (random_gen (has_inv fun_info)))) : strong_rank_condition (with_zero (random_gen (has_inv fun_info))) := sorry --non-trivial
lemma new_lemma_168649 (h0 : functor.add_const Prop (group_with_zero num)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_168650 (h0 : list (denumerable (random_gen (random_gen (random_gen (random_gen string_imp)))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_168651 (h0 : topological_space (ordered_comm_monoid (has_neg (has_neg (has_Inf (ordered_comm_monoid name)))))) : irreducible_space (ordered_comm_monoid (has_neg (has_neg (has_Inf (ordered_comm_monoid name))))) := sorry --non-trivial
lemma new_lemma_168652 (h0 : not (uniform_space (has_norm fun_info) -> false)) : @separated_space.{0} (has_norm.{0} fun_info) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_norm.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_168653 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (denumerable.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (denumerable.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_168654 (h0 : function.extfun Type group) : @normalizer_condition.{0} (complete_semilattice_Sup.{0} string_imp) (@function.extfun_app.{2 1} Type group.{0} h0 (complete_semilattice_Sup.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_168655 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_dist.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_dist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_168656 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (ordered_ring.{0} (has_Sup.{0} (add_semigroup.{0} unsigned))) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_ring.{0} (has_Sup.{0} (add_semigroup.{0} unsigned))))  := sorry --non-trivial
lemma new_lemma_168657 (h0 : uniform_space (linear_ordered_semiring unsigned)) : complete_space (linear_ordered_semiring unsigned) := sorry --non-trivial
lemma new_lemma_168658 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_atomistic.{0} (normed_group.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (normed_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_168659 (h0 : topological_space (non_assoc_semiring (option unsigned))) : irreducible_space (non_assoc_semiring (option unsigned)) := sorry --non-trivial
lemma new_lemma_168660 (h0 : group (has_bot (has_Inf (has_add pos)))) : normalizer_condition (has_bot (has_Inf (has_add pos))) := sorry --non-trivial
lemma new_lemma_168661 (h0 : function.extfun Type ring) : @is_domain.{0} (finset.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} h0 (finset.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_168662 (h0 : topological_space (has_norm (has_norm (has_norm num)))) : t0_space (has_norm (has_norm (has_norm num))) := sorry --non-trivial
lemma new_lemma_168663 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_168664 (h0 : functor.add_const (function.extfun (Type 1) topological_space) (has_neg_part Type)) : @loc_path_connected_space.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) (has_neg_part.{1} Type) h0) (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_168665 (h0 : list (has_nnnorm to_additive.value_type)) (h1 : not (list (has_nnnorm to_additive.value_type) -> false)) : list.subperm h0 (classical.by_contradiction' h1) := sorry --non-trivial
lemma new_lemma_168666 (h0 : group (has_nndist (option (has_add ennreal)))) : is_simple_group (has_nndist (option (has_add ennreal))) := sorry --non-trivial
lemma new_lemma_168667 (h0 : ring (sub_neg_monoid real)) : strong_rank_condition (sub_neg_monoid real) := sorry --non-trivial
lemma new_lemma_168668 (h0 : function.extfun Type ordered_add_comm_monoid) : archimedean real := sorry --non-trivial
lemma new_lemma_168669 (h0 : ring (comm_semigroup pos)) : is_principal_ideal_ring (comm_semigroup pos) := sorry --non-trivial
lemma new_lemma_168670 (h0 : ring (random_gen (has_pos_part (has_ssubset char)))) : is_domain (random_gen (has_pos_part (has_ssubset char))) := sorry --non-trivial
lemma new_lemma_168671 (h0 : list (has_neg_part (option name))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_168672 (h0 : topological_space (boolean_algebra (boolean_algebra environment.implicit_infer_kind))) : sequential_space (boolean_algebra (boolean_algebra environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_168673 (h0 : complete_lattice (has_neg_part (finset (option environment.implicit_infer_kind)))) : is_compactly_generated (has_neg_part (finset (option environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_168674 (h0 : topological_space (with_bot (has_norm empty))) : locally_compact_space (with_bot (has_norm empty)) := sorry --non-trivial
lemma new_lemma_168675 (h0 : cancel_comm_monoid_with_zero environment.implicit_infer_kind) : unique_factorization_monoid environment.implicit_infer_kind := sorry --non-trivial
lemma new_lemma_168676 (h0 : option Type) (h1 : semiring (option.get_or_else h0 (add_comm_semigroup ereal))) (h2 : ideal (option.get_or_else h0 (add_comm_semigroup ereal))) : ideal.is_prime h2 := sorry --non-trivial
lemma new_lemma_168677 (h0 : topological_space (generalized_boolean_algebra name)) : locally_compact_space (generalized_boolean_algebra name) := sorry --non-trivial
lemma new_lemma_168678 (h0 : topological_space (mul_one_class string_imp)) : t0_space (mul_one_class string_imp) := sorry --non-trivial
lemma new_lemma_168679 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (add_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_168680 (h0 : topological_space (has_nndist (finset name))) : preconnected_space (has_nndist (finset name)) := sorry --non-trivial
lemma new_lemma_168681 (h0 : monoid (boolean_algebra (finset linarith.comp))) : monoid.fg (boolean_algebra (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_168682 (h0 : functor.add_const (topological_space (boolean_algebra Type)) linarith.comp) : @topological_space.separable_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_168683 (h0 : finset (linear_ordered_comm_ring (semiring (semiring num)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_168684 (h0 : ring (has_emptyc (has_norm linarith.comp_source))) : is_domain (has_emptyc (has_norm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_168685 (h0 : functor.add_const (topological_space (mul_zero_class empty)) unsigned) : @t0_space.{0} (mul_zero_class.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_168686 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (omega_complete_partial_order.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (omega_complete_partial_order.{0} num))  := sorry --non-trivial
lemma new_lemma_168687 (h0 : functor.add_const (uniform_space (lattice empty)) empty) : @separated_space.{0} (lattice.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (lattice.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_168688 (h0 : list (monoid (has_neg (option pos)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_168689 (h0 : filter (mul_zero_class name)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_168690 (h0 : uniform_space (canonically_linear_ordered_monoid (option pos))) : separated_space (canonically_linear_ordered_monoid (option pos)) := sorry --non-trivial
lemma new_lemma_168691 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem add_monoid)) : @add_monoid.fg.{0} (normed_group.{0} num) (@function.extfun_app.{2 1} Type add_monoid.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) add_monoid.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) add_monoid.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (normed_group.{0} num))  := sorry --non-trivial
lemma new_lemma_168692 (h0 : linarith.ineq -> linarith.ineq -> Prop) : is_antisymm linarith.ineq h0 := sorry --non-trivial
lemma new_lemma_168693 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @regular_space.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_168694 (h0 : ring (with_bot (semiring (semiring congr_arg_kind)))) : rank_condition (with_bot (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_168695 (h0 : uniform_space (distrib (has_ssubset char))) : complete_space (distrib (has_ssubset char)) := sorry --non-trivial
lemma new_lemma_168696 (h0 : not (ring (has_ssubset char) -> false)) : @rank_condition.{0} (has_ssubset.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (has_ssubset.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_168697 (h0 : ring (non_assoc_semiring (semiring congr_arg_kind))) : strong_rank_condition (non_assoc_semiring (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_168698 (h0 : ordered_comm_monoid (semigroup (has_nndist ennreal))) : has_exists_mul_of_le (semigroup (has_nndist ennreal)) := sorry --non-trivial
lemma new_lemma_168699 (h0 : topological_space (canonically_ordered_monoid real)) : regular_space (canonically_ordered_monoid real) := sorry --non-trivial
lemma new_lemma_168700 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @regular_space.{0} (complete_distrib_lattice.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_distrib_lattice.{0} pos))  := sorry --non-trivial
lemma new_lemma_168701 (h0 : add_monoid (measurable_space.dynkin_system (has_norm congr_arg_kind))) : add_monoid.fg (measurable_space.dynkin_system (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_168702 (h0 : ring (has_sdiff (has_nnnorm char))) : rank_condition (has_sdiff (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_168703 (h0 : semiring (add_cancel_monoid (option (option (option unsigned))))) : is_noetherian_ring (add_cancel_monoid (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_168704 (h0 : not (topological_space (has_one linarith.comp) -> false)) : @locally_compact_space.{0} (has_one.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (has_one.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_168705 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_norm.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_norm.{0} empty))  := sorry --non-trivial
lemma new_lemma_168706 (h0 : group (ordered_comm_monoid (ring pos))) : is_cyclic (ordered_comm_monoid (ring pos)) := sorry --non-trivial
lemma new_lemma_168707 (h0 : functor.add_const (ring (non_unital_semiring pos)) name) : @rank_condition.{0} (non_unital_semiring.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (non_unital_semiring.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_168708 (h0 : ordered_comm_monoid (sub_neg_monoid pos)) : has_exists_mul_of_le (sub_neg_monoid pos) := sorry --non-trivial
lemma new_lemma_168709 (h0 : group (has_top (random_gen (random_gen (random_gen char))))) : group.fg (has_top (random_gen (random_gen (random_gen char)))) := sorry --non-trivial
lemma new_lemma_168710 (h0 : function.extfun (Type 1) finset) : finset.nonempty (function.extfun_app h0 (plift congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_168711 (h0 : functor.add_const (functor.add_const (topological_space Type) pos) linarith.comp) : @regular_space.{1} Type (@functor.add_const.run.{1 0} (topological_space.{1} Type) pos (@functor.add_const.run.{1 0} (functor.add_const.{1 0} (topological_space.{1} Type) pos) linarith.comp h0))  := sorry --non-trivial
lemma new_lemma_168712 (h0 : topological_space (has_Inf (has_Inf (has_Inf linarith.comp)))) : irreducible_space (has_Inf (has_Inf (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_168713 (h0 : ring (left_cancel_semigroup (ordered_cancel_comm_monoid unsigned))) : strong_rank_condition (left_cancel_semigroup (ordered_cancel_comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_168714 (h0 : topological_space (ordered_comm_ring (has_neg (has_neg name)))) : preconnected_space (ordered_comm_ring (has_neg (has_neg name))) := sorry --non-trivial
lemma new_lemma_168715 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} (has_norm.{0} empty) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (has_norm.{0} empty))  := sorry --non-trivial
lemma new_lemma_168716 (h0 : functor.add_const (functor.add_const (topological_space Type) linarith.comp) linarith.comp) : @loc_path_connected_space.{1} Type (@functor.add_const.run.{1 0} (topological_space.{1} Type) linarith.comp (@functor.add_const.run.{1 0} (functor.add_const.{1 0} (topological_space.{1} Type) linarith.comp) linarith.comp h0))  := sorry --non-trivial
lemma new_lemma_168717 (h0 : fin has_zero.zero) : @topological_space.separable_space.{0} (canonically_ordered_monoid.{0} name) (@matrix.vec_empty.{0} (topological_space.{0} (canonically_ordered_monoid.{0} name)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_168718 (h0 : group (has_ssubset char)) : group.fg (has_ssubset char) := sorry --non-trivial
lemma new_lemma_168719 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (left_cancel_monoid.{0} (semiring.{0} empty)) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (left_cancel_monoid.{0} (semiring.{0} empty)))  := sorry --non-trivial
lemma new_lemma_168720 (h0 : topological_space (cancel_monoid (option (has_neg_part pos)))) : irreducible_space (cancel_monoid (option (has_neg_part pos))) := sorry --non-trivial
lemma new_lemma_168721 (h0 : functor.add_const (add_group (boolean_algebra pos)) linarith.comp) : @is_add_cyclic.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (boolean_algebra.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_168722 (h0 : ring (restrict_scalars string char char)) : rank_condition (restrict_scalars string char char) := sorry --non-trivial
lemma new_lemma_168723 (h0 : functor.add_const (ring (has_bot unsigned)) empty) : @is_domain.{0} (has_bot.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (has_bot.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_168724 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_emptyc.{0} (has_top.{0} (has_top.{0} fun_info))) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_emptyc.{0} (has_top.{0} (has_top.{0} fun_info))))  := sorry --non-trivial
lemma new_lemma_168725 (h0 : topological_space (has_nndist (option (option ennreal)))) : totally_separated_space (has_nndist (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_168726 (h0 h1 : multiset (add_comm_semigroup linarith.ineq)) : multiset.le h0 h1 := sorry --non-trivial
lemma new_lemma_168727 (h1 : not (topological_space (uniform_space string_imp) -> false)) : @t0_space.{0} (uniform_space.{0} string_imp) (@classical.by_contradiction'.{1} (topological_space.{0} (uniform_space.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_168728 (h0 : functor.add_const (topological_space (has_add ennreal)) Type) : @discrete_topology.{0} (has_add.{0} ennreal) (@functor.add_const.run.{0 1} (topological_space.{0} (has_add.{0} ennreal)) Type h0)  := sorry --non-trivial
lemma new_lemma_168729 (h0 : measurable_space (free_add_monoid enat)) (h1 : measure_theory.measure (free_add_monoid enat)) : measure_theory.is_finite_measure h1 := sorry --non-trivial
lemma new_lemma_168730 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (complete_distrib_lattice.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (complete_distrib_lattice.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_168731 (h0 : topological_space (linear_ordered_comm_ring congr_arg_kind)) : preirreducible_space (linear_ordered_comm_ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_168732 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (@id.{2} Type to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (@id.{2} Type to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_168733 (h0 : functor.add_const (monoid (has_neg Type)) linarith.comp) : @monoid.fg.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (monoid.{1} (has_neg.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_168734 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (mul_zero_class.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (mul_zero_class.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_168735 (h0 : functor.add_const (group (complete_distrib_lattice unsigned)) empty) : @is_cyclic.{0} (complete_distrib_lattice.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (complete_distrib_lattice.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_168736 (h0 : ring (has_nndist (option ennreal))) : rank_condition (has_nndist (option ennreal)) := sorry --non-trivial
lemma new_lemma_168737 (h0 : uniform_space to_additive.value_type) : separated_space to_additive.value_type := sorry --non-trivial
lemma new_lemma_168738 (h0 : ring (semi_normed_comm_ring (random_gen to_additive.value_type))) : is_domain (semi_normed_comm_ring (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_168739 (h0 : topological_space (complete_linear_order num)) : totally_separated_space (complete_linear_order num) := sorry --non-trivial
lemma new_lemma_168740 (h0 : topological_space (ring (has_neg_part (has_neg (has_add environment.implicit_infer_kind))))) : preconnected_space (ring (has_neg_part (has_neg (has_add environment.implicit_infer_kind)))) := sorry --non-trivial
lemma new_lemma_168741 (h0 : functor.add_const (filter (complete_distrib_lattice Type)) environment.implicit_infer_kind) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_168742 (h0 : group (canonically_ordered_add_monoid (option (option empty)))) : is_cyclic (canonically_ordered_add_monoid (option (option empty))) := sorry --non-trivial
lemma new_lemma_168743 (h0 : functor.add_const (functor.add_const (uniform_space auto.case_option) num) empty) : @separated_space.{0} auto.case_option (@functor.add_const.run.{0 0} (uniform_space.{0} auto.case_option) num (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (uniform_space.{0} auto.case_option) num) empty h0))  := sorry --non-trivial
lemma new_lemma_168744 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : irreducible_space empty := sorry --non-trivial
lemma new_lemma_168745 (h0 : functor.add_const (ordered_add_comm_monoid (ring environment.implicit_infer_kind)) (mul_one_class (has_neg Type))) : @archimedean.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (ordered_add_comm_monoid.{0} (ring.{0} environment.implicit_infer_kind)) (mul_one_class.{1} (has_neg.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_168746 (h0 : group (has_top (random_gen (random_gen string_imp)))) : group.fg (has_top (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_168747 (h0 : not (topological_space (with_bot linarith.ineq) -> false)) : @sequential_space.{0} (with_bot.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (with_bot.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_168748 (h0 : set (add_comm_semigroup (add_comm_semigroup enat) -> enat)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_168749 (h0 : group (comm_ring linarith.comp_source)) : group.fg (comm_ring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_168750 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (random_gen.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (random_gen.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_168751 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (add_cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_168752 (h0 : list (normed_comm_ring (ring Type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_168753 (h0 : functor.add_const (uniform_space (canonically_ordered_comm_semiring pos)) pos) : @separated_space.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (canonically_ordered_comm_semiring.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_168754 (h4 : topological_space (mul_one_class (mul_one_class (mul_one_class enat)))) : t0_space (mul_one_class (mul_one_class (mul_one_class enat))) := sorry --non-trivial
lemma new_lemma_168755 (h0 : functor.add_const (group (has_neg_part pos)) name) : @is_cyclic.{0} (has_neg_part.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_neg_part.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_168756 (h0 : functor.add_const (add_group (ordered_comm_ring pos)) (has_neg (finset pos))) : @is_add_cyclic.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (ordered_comm_ring.{0} pos)) (has_neg.{0} (finset.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_168757 (h0 : function.extfun nat fin) : @topological_space.separable_space.{0} (ordered_comm_ring.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_ring.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_168758 (h0 : set (add_comm_semigroup enat -> add_comm_semigroup linarith.ineq)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_168759 (h0 : functor.add_const (group (comm_group pos)) Type) : @normalizer_condition.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (comm_group.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_168760 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (boolean_algebra.core.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_168761 (h0 : complete_lattice (with_one fun_info)) : is_atomistic (with_one fun_info) := sorry --non-trivial
lemma new_lemma_168762 (h0 : topological_space (mul_zero_class (has_add Type))) : totally_disconnected_space (mul_zero_class (has_add Type)) := sorry --non-trivial
lemma new_lemma_168763 (h0 : monoid (has_edist (option empty))) : monoid.fg (has_edist (option empty)) := sorry --non-trivial
lemma new_lemma_168764 (h0 : group (canonically_ordered_comm_semiring linarith.comp)) : normalizer_condition (canonically_ordered_comm_semiring linarith.comp) := sorry --non-trivial
lemma new_lemma_168765 (h0 : topological_space (cancel_monoid (option pos))) : sequential_space (cancel_monoid (option pos)) := sorry --non-trivial
lemma new_lemma_168766 (h0 : has_mem.mem (normed_group (has_norm congr_arg_kind)) has_emptyc.emptyc) : @complete_space.{0} (normed_group.{0} (has_norm.{0} congr_arg_kind)) (@finset.pi.empty.{1 0} Type uniform_space.{0} (normed_group.{0} (has_norm.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_168767 (h0 : function.extfun Type topological_space) : @t1_space.{0} (complete_distrib_lattice.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} real))  := sorry --non-trivial
lemma new_lemma_168768 (h0 : has_Inf (has_Inf pos) -> has_Inf (has_Inf pos) -> Prop) : is_antisymm (has_Inf (has_Inf pos)) h0 := sorry --non-trivial
lemma new_lemma_168769 (h0 : complete_lattice (has_nndist (option ennreal))) : is_atomistic (has_nndist (option ennreal)) := sorry --non-trivial
lemma new_lemma_168770 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : palindrome (function.extfun_app (function.extfun_app h0 list) (simple_graph Type)) := sorry --non-trivial
lemma new_lemma_168771 (h0 : topological_space (ring (has_pos_part environment.implicit_infer_kind))) : discrete_topology (ring (has_pos_part environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_168772 (h0 : group (comm_group (add_cancel_monoid ennreal))) : is_cyclic (comm_group (add_cancel_monoid ennreal)) := sorry --non-trivial
lemma new_lemma_168773 (h0 : function.extfun (Type 1) (functor.comp group has_neg_part)) : @is_cyclic.{1} (has_neg_part.{1} Type) (@functor.comp.run.{1 1 1} group.{1} has_neg_part.{1} Type (@function.extfun_app.{3 2} (Type 1) (functor.comp.{1 1 1} group.{1} has_neg_part.{1}) h0 Type))  := sorry --non-trivial
lemma new_lemma_168774 (h0 : ring (add_comm_semigroup fun_info)) : is_domain (add_comm_semigroup fun_info) := sorry --non-trivial
lemma new_lemma_168775 (h0 : filter (has_one (semiring (has_top linarith.comp)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_168776 (h0 : functor.add_const (topological_space (boolean_algebra environment.implicit_infer_kind)) name) : @normal_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_168777 (h0 : topological_space (preorder empty)) : totally_disconnected_space (preorder empty) := sorry --non-trivial
lemma new_lemma_168778 (h0 : group (has_star num)) : normalizer_condition (has_star num) := sorry --non-trivial
lemma new_lemma_168779 (h0 : complete_lattice (finset (has_add (has_add Type)))) : is_atomistic (finset (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_168780 (h0 : topological_space (normed_comm_ring (comm_group Type))) : path_connected_space (normed_comm_ring (comm_group Type)) := sorry --non-trivial
lemma new_lemma_168781 (h0 : topological_space (has_le (normed_field (mul_one_class std_gen)))) : path_connected_space (has_le (normed_field (mul_one_class std_gen))) := sorry --non-trivial
lemma new_lemma_168782 (h0 : list (linear_ordered_comm_monoid_with_zero (has_bot unsigned))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_168783 (h0 : group (has_norm (random_gen (has_nnnorm char)))) : group.fg (has_norm (random_gen (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_168784 (h0 : cancel_comm_monoid_with_zero (add_group (has_top fun_info))) : unique_factorization_monoid (add_group (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_168785 (h1 : group (with_one num)) : normalizer_condition (with_one num) := sorry --non-trivial
lemma new_lemma_168786 (h0 : add_group (with_zero fun_info)) : is_add_cyclic (with_zero fun_info) := sorry --non-trivial
lemma new_lemma_168787 (h0 : topological_space (has_zero (finset (finset (finset (finset pos)))))) : preirreducible_space (has_zero (finset (finset (finset (finset pos))))) := sorry --non-trivial
lemma new_lemma_168788 (h0 : function.extfun Type topological_space) : @t0_space.{0} (normed_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_168789 (h0 : function.extfun (Type 1) list) : list.nodup (function.extfun_app h0 (complete_distrib_lattice Type)) := sorry --non-trivial
lemma new_lemma_168790 (h2 : ring (add_cancel_comm_monoid char)) : rank_condition (add_cancel_comm_monoid char) := sorry --non-trivial
lemma new_lemma_168791 (h0 : semiring (ring (has_pos_part (has_pos_part (ring linarith.comp))))) : is_noetherian_ring (ring (has_pos_part (has_pos_part (ring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_168792 (h0 : complete_lattice (left_cancel_semigroup (semiring (semiring unsigned)))) : complete_lattice.is_Sup_finite_compact (left_cancel_semigroup (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_168793 (h0 : filter (finset (has_neg_part pos))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_168794 (h0 : ring (has_Inf (has_Inf (generalized_boolean_algebra (has_Inf pos))))) : rank_condition (has_Inf (has_Inf (generalized_boolean_algebra (has_Inf pos)))) := sorry --non-trivial
lemma new_lemma_168795 (h1 : topological_space (topological_space (semi_normed_ring char))) : path_connected_space (topological_space (semi_normed_ring char)) := sorry --non-trivial
lemma new_lemma_168796 (h0 : function.extfun nat fin) : @normalizer_condition.{1} (boolean_algebra.core.{1} Type) (@matrix.vec_empty.{1} (group.{1} (boolean_algebra.core.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_168797 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (simple_graph.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (simple_graph.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_168798 (h0 : topological_space (has_pos_part (has_add (finset pos)))) : t0_space (has_pos_part (has_add (finset pos))) := sorry --non-trivial
lemma new_lemma_168799 (h0 : topological_space (normed_group (random_gen to_additive.value_type))) : totally_separated_space (normed_group (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_168800 (h0 : semiring (linear_ordered_comm_group num)) : is_noetherian_ring (linear_ordered_comm_group num) := sorry --non-trivial
lemma new_lemma_168801 (h0 : function.extfun Type ring) : @rank_condition.{0} (with_one.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (with_one.{0} num))  := sorry --non-trivial
lemma new_lemma_168802 (h0 : functor.add_const (topological_space (has_to_string unsigned)) Type) : @path_connected_space.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (has_to_string.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_168803 (h4 : topological_space (add_comm_semigroup enat)) : totally_disconnected_space (add_comm_semigroup enat) := sorry --non-trivial
lemma new_lemma_168804 (h0 : uniform_space (semigroup (semigroup (normed_comm_ring linarith.comp)))) : separated_space (semigroup (semigroup (normed_comm_ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_168805 (h0 : topological_space (boolean_algebra.core (finset (has_add (has_add ennreal))))) : locally_compact_space (boolean_algebra.core (finset (has_add (has_add ennreal)))) := sorry --non-trivial
lemma new_lemma_168806 (h0 : topological_space (linear_ordered_semiring (semiring (semiring congr_arg_kind)))) : t0_space (linear_ordered_semiring (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_168807 (h2 : ring (add_comm_semigroup (add_comm_semigroup (add_comm_semigroup ereal)))) : strong_rank_condition (add_comm_semigroup (add_comm_semigroup (add_comm_semigroup ereal))) := sorry --non-trivial
lemma new_lemma_168808 (h0 : group (comm_group (finset pos))) : is_simple_group (comm_group (finset pos)) := sorry --non-trivial
lemma new_lemma_168809 (h0 : topological_space (ring (ring (finset pos)))) : t0_space (ring (ring (finset pos))) := sorry --non-trivial
lemma new_lemma_168810 (h0 : cancel_comm_monoid_with_zero (ring (ring unsigned))) : unique_factorization_monoid (ring (ring unsigned)) := sorry --non-trivial
lemma new_lemma_168811 (h0 : group (has_le to_additive.value_type)) : group.fg (has_le to_additive.value_type) := sorry --non-trivial
lemma new_lemma_168812 (h0 : functor.add_const (topological_space (has_to_string Type)) (has_zero Type)) : @normal_space.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_to_string.{1} Type)) (has_zero.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_168813 (h0 : topological_space (semigroup (finset linarith.comp))) : preirreducible_space (semigroup (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_168814 (h0 : functor.add_const (list (ordered_comm_ring linarith.comp)) linarith.comp) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_168815 (h0 : ring (semi_normed_ring (mul_one_class (mul_one_class reducibility_hints)))) : is_domain (semi_normed_ring (mul_one_class (mul_one_class reducibility_hints))) := sorry --non-trivial
lemma new_lemma_168816 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (finset.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (finset.{0} empty))  := sorry --non-trivial
lemma new_lemma_168817 (h0 : functor.add_const (topological_space (normed_comm_ring unsigned)) linarith.comp) : @preirreducible_space.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_168818 (h0 : filter (distrib_lattice (has_ssubset (has_ssubset (random_gen (has_norm to_additive.value_type)))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_168819 (h0 : topological_space (has_nndist (has_add (has_add Type)))) : totally_separated_space (has_nndist (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_168820 (h0 : uniform_space (random_gen (has_norm fun_info))) : complete_space (random_gen (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_168821 (h0 : complete_lattice (has_neg (finset (finset (finset (finset (finset linarith.comp))))))) : is_compactly_generated (has_neg (finset (finset (finset (finset (finset linarith.comp)))))) := sorry --non-trivial
lemma new_lemma_168822 (h0 : complete_lattice (has_ssubset (has_nnnorm linarith.ineq))) : is_compactly_generated (has_ssubset (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_168823 (h0 : set (mul_one_class std_gen)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_168824 (h0 : functor.add_const (topological_space (finset name)) (boolean_algebra (has_neg (has_neg linarith.comp)))) : @preconnected_space.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} name)) (boolean_algebra.{0} (has_neg.{0} (has_neg.{0} linarith.comp))) h0)  := sorry --non-trivial
lemma new_lemma_168825 (h0 : ring (random_gen (mul_one_class linarith.ineq))) : strong_rank_condition (random_gen (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_168826 (h0 : functor.add_const Prop (has_union (has_norm empty))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_168827 (h0 : uniform_space (measurable_space string_imp)) : complete_space (measurable_space string_imp) := sorry --non-trivial
lemma new_lemma_168828 (h0 : functor.add_const (semiring (has_nndist ennreal)) (canonically_ordered_comm_semiring pos)) : @is_noetherian_ring.{0} (has_nndist.{0} ennreal) (@functor.add_const.run.{0 0} (semiring.{0} (has_nndist.{0} ennreal)) (canonically_ordered_comm_semiring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_168829 (h1 : ring environment.projection_info) : strong_rank_condition environment.projection_info := sorry --non-trivial
lemma new_lemma_168830 (h0 : topological_space (plift nnreal)) : totally_separated_space (plift nnreal) := sorry --non-trivial
lemma new_lemma_168831 (h0 : topological_space (has_inter ennreal)) : loc_path_connected_space (has_inter ennreal) := sorry --non-trivial
lemma new_lemma_168832 (h0 : topological_space (canonically_ordered_monoid (has_add (has_add pos)))) : totally_separated_space (canonically_ordered_monoid (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_168833 (h0 : not (ring (dlist (mul_one_class linarith.comp_source)) -> false)) : @rank_condition.{0} (dlist.{0} (mul_one_class.{0} linarith.comp_source)) (@classical.by_contradiction'.{1} (ring.{0} (dlist.{0} (mul_one_class.{0} linarith.comp_source))) h0)  := sorry --non-trivial
lemma new_lemma_168834 (h0 : functor.add_const (topological_space (finset pos)) unsigned) : @irreducible_space.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_168835 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_168836 (h0 : list (boolean_algebra (has_add Type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_168837 (h0 : functor.add_const (topological_space (has_nndist pos)) name) : @topological_space.separable_space.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_168838 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_norm.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_norm.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_168839 (h0 : functor.add_const (monoid (comm_monoid empty)) empty) : @monoid.fg.{0} (comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (monoid.{0} (comm_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_168840 (h0 : topological_space (dlist (has_nnnorm string_imp))) : t0_space (dlist (has_nnnorm string_imp)) := sorry --non-trivial
lemma new_lemma_168841 (h2 : complete_lattice (add_left_cancel_monoid to_additive.value_type)) : complete_lattice.is_Sup_finite_compact (add_left_cancel_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_168842 (h1 : set (linarith.ineq -> fun_info)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_168843 (h0 : uniform_space (has_nndist (add_cancel_monoid (add_cancel_monoid linarith.comp)))) : complete_space (has_nndist (add_cancel_monoid (add_cancel_monoid linarith.comp))) := sorry --non-trivial
lemma new_lemma_168844 (h0 : topological_space (pseudo_metric_space (option empty))) : t1_space (pseudo_metric_space (option empty)) := sorry --non-trivial
lemma new_lemma_168845 (h2 : not (group (with_one congr_arg_kind) -> false)) : @normalizer_condition.{0} (with_one.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (group.{0} (with_one.{0} congr_arg_kind)) h2)  := sorry --non-trivial
lemma new_lemma_168846 (h2 h3 : multiset (uniform_space reducibility_hints)) : multiset.disjoint h2 h3 := sorry --non-trivial
lemma new_lemma_168847 (h0 : topological_space (normed_field fun_info)) (h1 : preorder (normed_field fun_info)) : order_closed_topology (normed_field fun_info) := sorry --non-trivial
lemma new_lemma_168848 (h1 : topological_space (semi_normed_comm_ring (has_nnnorm char))) : totally_disconnected_space (semi_normed_comm_ring (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_168849 (h0 : functor.add_const (topological_space (finset Type)) pos) : @preconnected_space.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (finset.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_168850 (h0 : fin has_zero.zero) : @is_principal_ideal_ring.{1} (add_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (add_comm_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_168851 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} (complete_linear_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (complete_linear_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_168852 (h0 : fin has_zero.zero) : @totally_disconnected_space.{0} (boolean_algebra.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (boolean_algebra.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_168853 (h0 : topological_space (normed_field (mul_one_class string.iterator_imp))) : path_connected_space (normed_field (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_168854 (h0 : ring (ordered_ring (semiring num))) : is_principal_ideal_ring (ordered_ring (semiring num)) := sorry --non-trivial
lemma new_lemma_168855 (h0 : functor.add_const (topological_space (add_cancel_monoid environment.implicit_infer_kind)) real) : @regular_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind)) real h0)  := sorry --non-trivial
lemma new_lemma_168856 (h0 : not (topological_space (linear_ordered_semiring unsigned) -> false)) : @t0_space.{0} (linear_ordered_semiring.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_semiring.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_168857 (h0 : group (left_cancel_semigroup congr_arg_kind)) : is_cyclic (left_cancel_semigroup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_168858 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (has_inter.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (has_inter.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_168859 (h0 : prod (id (has_top (has_top (has_top unsigned)))) (id (has_top (has_top (has_top unsigned))))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_168860 (h0 : list (mul_zero_class (finset pos))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_168861 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (has_inv congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_168862 (h0 : functor.add_const (cancel_comm_monoid_with_zero (normed_comm_ring pos)) (ring (comm_group linarith.comp))) : @unique_factorization_monoid.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (normed_comm_ring.{0} pos)) (ring.{0} (comm_group.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_168863 (h0 : topological_space (has_Sup num)) : t0_space (has_Sup num) := sorry --non-trivial
lemma new_lemma_168864 (h0 : topological_space (mul_zero_class (mul_zero_class ennreal))) : totally_separated_space (mul_zero_class (mul_zero_class ennreal)) := sorry --non-trivial
lemma new_lemma_168865 (h0 : topological_space (ordered_comm_monoid (has_Inf real))) : loc_path_connected_space (ordered_comm_monoid (has_Inf real)) := sorry --non-trivial
lemma new_lemma_168866 (h0 : not (topological_space (semi_normed_comm_ring (mul_one_class (mul_one_class linarith.ineq))) -> false)) : @totally_disconnected_space.{0} (semi_normed_comm_ring.{0} (mul_one_class.{0} (mul_one_class.{0} linarith.ineq))) (@classical.by_contradiction'.{1} (topological_space.{0} (semi_normed_comm_ring.{0} (mul_one_class.{0} (mul_one_class.{0} linarith.ineq)))) h0)  := sorry --non-trivial
lemma new_lemma_168867 (h1 : uniform_space (simple_graph string_imp)) : complete_space (simple_graph string_imp) := sorry --non-trivial
lemma new_lemma_168868 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (boolean_algebra.core.{0} (has_add.{0} pos)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} (has_add.{0} pos)))  := sorry --non-trivial
lemma new_lemma_168869 (h0 : functor.add_const (fin has_zero.zero) (has_Inf (has_add (has_Inf name)))) : @add_monoid.fg.{0} (has_pos_part.{0} real) (@function.extfun_app.{2 1} Type add_monoid.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type add_monoid.{0}) (@functor.add_const.run.{0 0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (has_Inf.{0} (has_add.{0} (has_Inf.{0} name))) h0)) (has_pos_part.{0} real))  := sorry --non-trivial
lemma new_lemma_168870 (h0 : functor.add_const (add_group (boolean_algebra Type)) (ring (has_to_string linarith.comp))) : @is_add_cyclic.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (add_group.{1} (boolean_algebra.{1} Type)) (ring.{0} (has_to_string.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_168871 (h0 : group (canonically_linear_ordered_monoid (has_Inf Type))) : group.fg (canonically_linear_ordered_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_168872 (h0 : ring (pseudo_metric_space (has_add name))) : is_principal_ideal_ring (pseudo_metric_space (has_add name)) := sorry --non-trivial
lemma new_lemma_168873 (h0 : monoid (normed_lattice_add_comm_group (has_Inf real))) : monoid.fg (normed_lattice_add_comm_group (has_Inf real)) := sorry --non-trivial
lemma new_lemma_168874 (h0 : has_lt (has_nndist (finset (finset name)))) : no_min_order (has_nndist (finset (finset name))) := sorry --non-trivial
lemma new_lemma_168875 (h0 : set environment.projection_info) : set.finite h0 := sorry --non-trivial
lemma new_lemma_168876 (h0 : functor.add_const (topological_space (has_neg empty)) ennreal) : @normal_space.{0} (has_neg.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} empty)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_168877 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (has_nndist.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_nndist.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_168878 (h0 : ring (complete_distrib_lattice (option (option (option (option empty)))))) : strong_rank_condition (complete_distrib_lattice (option (option (option (option empty))))) := sorry --non-trivial
lemma new_lemma_168879 (h1 : topological_space (id congr_arg_kind)) : discrete_topology (id congr_arg_kind) := sorry --non-trivial
lemma new_lemma_168880 (h0 : functor.add_const (topological_space (mul_zero_class num)) congr_arg_kind) : @discrete_topology.{0} (mul_zero_class.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_168881 (h0 : finset (finset (has_nndist (finset (finset linarith.comp))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_168882 (h0 : group (has_one (has_norm (has_norm (has_norm (has_norm (has_norm empty))))))) : is_cyclic (has_one (has_norm (has_norm (has_norm (has_norm (has_norm empty)))))) := sorry --non-trivial
lemma new_lemma_168883 (h0 : cancel_comm_monoid_with_zero (comm_group (boolean_algebra Type))) : unique_factorization_monoid (comm_group (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_168884 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_nnnorm.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_nnnorm.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_168885 (h0 : functor.add_const (topological_space (sub_neg_monoid name)) name) : @irreducible_space.{0} (sub_neg_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (sub_neg_monoid.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_168886 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (complete_distrib_lattice.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_distrib_lattice.{0} empty))  := sorry --non-trivial
lemma new_lemma_168887 (h0 : functor.add_const (function.extfun (Type 1) add_group) Type) : @is_add_cyclic.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_group.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) add_group.{1}) Type h0) (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_168888 (h0 : topological_space (boolean_algebra (has_Inf (has_Inf pos)))) : t0_space (boolean_algebra (has_Inf (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_168889 (h0 : topological_space (has_to_string (semigroup environment.implicit_infer_kind))) : t0_space (has_to_string (semigroup environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_168890 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (ring.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_168891 (h0 : ordered_add_comm_monoid (has_bot (option (option empty)))) : archimedean (has_bot (option (option empty))) := sorry --non-trivial
lemma new_lemma_168892 (h1 : complete_lattice (random_gen (normed_group (random_gen linarith.ineq)))) : is_compactly_generated (random_gen (normed_group (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_168893 (h0 : function.extfun (Type 1) group) : @is_simple_group.{1} (comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} h0 (comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_168894 (h0 : ring (omega_complete_partial_order (option unsigned))) : is_domain (omega_complete_partial_order (option unsigned)) := sorry --non-trivial
lemma new_lemma_168895 (h0 : ordered_comm_monoid (ring (has_to_string pos))) : has_exists_mul_of_le (ring (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_168896 (h0 : topological_space (comm_group (option ennreal))) : normal_space (comm_group (option ennreal)) := sorry --non-trivial
lemma new_lemma_168897 (h0 : fin has_zero.zero) : @complete_space.{0} (canonically_ordered_monoid.{0} pos) (@matrix.vec_empty.{0} (uniform_space.{0} (canonically_ordered_monoid.{0} pos)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_168898 (h0 : ordered_add_comm_monoid (canonically_ordered_comm_semiring (has_neg_part Type))) : archimedean (canonically_ordered_comm_semiring (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_168899 (h0 : topological_space (linear_ordered_semiring (has_norm unsigned))) : totally_disconnected_space (linear_ordered_semiring (has_norm unsigned)) := sorry --non-trivial
lemma new_lemma_168900 (h0 : fin has_zero.zero) : @t0_space.{0} (complete_distrib_lattice.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (complete_distrib_lattice.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_168901 (h0 : topological_space (has_zero (comm_group name))) : t1_space (has_zero (comm_group name)) := sorry --non-trivial
lemma new_lemma_168902 (h0 : functor.add_const (group (canonically_ordered_add_monoid empty)) (option (option empty))) : @is_cyclic.{0} (canonically_ordered_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (canonically_ordered_add_monoid.{0} empty)) (option.{0} (option.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_168903 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (with_bot.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_bot.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_168904 (h0 : complete_lattice (has_compl (mul_one_class string.iterator_imp))) : complete_lattice.is_Sup_finite_compact (has_compl (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_168905 (h0 : topological_space (has_add (has_Inf (has_add linarith.comp)))) : sequential_space (has_add (has_Inf (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_168906 (h0 : not (topological_space (complete_linear_order congr_arg_kind) -> false)) : @normal_space.{0} (complete_linear_order.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (complete_linear_order.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_168907 (h0 : monoid (random_gen (random_gen (random_gen (random_gen linarith.ineq))))) : monoid.fg (random_gen (random_gen (random_gen (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_168908 (h0 : functor.add_const (function.extfun Type group) pos) : @normalizer_condition.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) pos h0) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_168909 (h0 : ring (has_neg_part (has_add ennreal))) : is_principal_ideal_ring (has_neg_part (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_168910 (h0 : complete_lattice (boolean_algebra name)) : is_atomistic (boolean_algebra name) := sorry --non-trivial
lemma new_lemma_168911 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (with_bot.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_bot.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_168912 (h0 : ring (with_one (has_norm (has_norm linarith.ineq)))) : rank_condition (with_one (has_norm (has_norm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_168913 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (omega_complete_partial_order.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (omega_complete_partial_order.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_168914 (h0 : functor.add_const (complete_lattice (has_to_string pos)) pos) : @is_atomistic.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_to_string.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_168915 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem uniform_space)) : @separated_space.{0} (measurable_space.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) uniform_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) uniform_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (measurable_space.{0} num))  := sorry --non-trivial
lemma new_lemma_168916 (h0 : set (mul_one_class (add_comm_semigroup ereal) -> mul_one_class enat)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_168917 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @t1_space.{0} (finset.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (finset.{0} name))  := sorry --non-trivial
lemma new_lemma_168918 (h0 : topological_space (boolean_algebra (ring Type))) : totally_disconnected_space (boolean_algebra (ring Type)) := sorry --non-trivial
lemma new_lemma_168919 (h0 : not (function.extfun Type topological_space -> false)) : @totally_separated_space.{0} (dlist.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (dlist.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_168920 (h0 : list (has_Inf (has_neg (has_Inf (has_add linarith.comp))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_168921 (h2 : topological_space (topological_space to_additive.value_type)) : totally_disconnected_space (topological_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_168922 (h0 : complete_lattice (canonically_ordered_monoid (has_Inf (has_add real)))) : is_atomistic (canonically_ordered_monoid (has_Inf (has_add real))) := sorry --non-trivial
lemma new_lemma_168923 (h0 : topological_space (has_neg_part (finset (finset ennreal)))) : normal_space (has_neg_part (finset (finset ennreal))) := sorry --non-trivial
lemma new_lemma_168924 (h0 : topological_space (has_norm (metric_space linarith.comp))) : totally_separated_space (has_norm (metric_space linarith.comp)) := sorry --non-trivial
lemma new_lemma_168925 (h0 : functor.add_const (function.extfun Type add_group) linarith.comp) : @is_add_cyclic.{0} (has_pos_part.{0} name) (@function.extfun_app.{2 1} Type add_group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_group.{0}) linarith.comp h0) (has_pos_part.{0} name))  := sorry --non-trivial
lemma new_lemma_168926 (h0 : monoid (has_add (has_Inf (boolean_algebra.core (has_nndist (has_Inf (has_add (finset Type)))))))) : monoid.fg (has_add (has_Inf (boolean_algebra.core (has_nndist (has_Inf (has_add (finset Type))))))) := sorry --non-trivial
lemma new_lemma_168927 (h0 : function.extfun Type group) : @normalizer_condition.{0} (canonically_linear_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type group.{0} h0 (canonically_linear_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_168928 (h0 : topological_space (comm_semigroup (sub_neg_monoid linarith.comp))) : preconnected_space (comm_semigroup (sub_neg_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_168929 (h0 : ring (id (has_top linarith.ineq))) : is_domain (id (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_168930 (h0 : topological_space (topological_space (has_lt (comm_ring linarith.ineq)))) : path_connected_space (topological_space (has_lt (comm_ring linarith.ineq))) := sorry --non-trivial
lemma new_lemma_168931 (h0 : topological_space (normed_comm_ring (has_add (has_to_string pos)))) : totally_separated_space (normed_comm_ring (has_add (has_to_string pos))) := sorry --non-trivial
lemma new_lemma_168932 (h0 : topological_space (boolean_algebra (has_add unsigned))) : discrete_topology (boolean_algebra (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_168933 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_add.{0} (option.{0} pos)) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_add.{0} (option.{0} pos)))  := sorry --non-trivial
lemma new_lemma_168934 (h0 : group (normed_comm_ring (option empty))) : is_cyclic (normed_comm_ring (option empty)) := sorry --non-trivial
lemma new_lemma_168935 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @preirreducible_space.{1} (has_neg_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (has_neg_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_168936 (h0 : not (topological_space (has_inv char) -> false)) : @t0_space.{0} (has_inv.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (has_inv.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_168937 (h0 : topological_space (has_nndist (finset (finset Type)))) : t1_space (has_nndist (finset (finset Type))) := sorry --non-trivial
lemma new_lemma_168938 (h0 : ordered_comm_monoid (normed_lattice_add_comm_group (has_Inf linarith.comp))) : has_exists_mul_of_le (normed_lattice_add_comm_group (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_168939 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_top.{0} string_imp) (@function.extfun_app.{2 1} Type group.{0} h0 (has_top.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_168940 (h0 : fin has_zero.zero) : @is_principal_ideal_ring.{0} (has_add.{0} pos) (@matrix.vec_empty.{0} (ring.{0} (has_add.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_168941 (h0 : ring (normed_lattice_add_comm_group (normed_lattice_add_comm_group real))) : rank_condition (normed_lattice_add_comm_group (normed_lattice_add_comm_group real)) := sorry --non-trivial
lemma new_lemma_168942 (h0 : monoid (plift (has_top (semiring num)))) : monoid.fg (plift (has_top (semiring num))) := sorry --non-trivial
lemma new_lemma_168943 (h0 : complete_lattice (has_emptyc (has_norm congr_arg_kind))) : is_atomistic (has_emptyc (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_168944 (h0 : functor.add_const (ring (semigroup empty)) empty) : @rank_condition.{0} (semigroup.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (semigroup.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_168945 (h0 : complete_lattice (plift empty)) : is_atomistic (plift empty) := sorry --non-trivial
lemma new_lemma_168946 (h0 h1 : multiset (nondiscrete_normed_field (mul_one_class (mul_one_class enat)))) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_168947 (h0 : functor.add_const (uniform_space (boolean_algebra.core environment.implicit_infer_kind)) linarith.comp) : @separated_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (uniform_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_168948 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (bin_tree.{0} (add_left_cancel_semigroup.{0} unsigned)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (bin_tree.{0} (add_left_cancel_semigroup.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_168949 (h0 : topological_space (pseudo_metric_space (has_nndist (option name)))) : preirreducible_space (pseudo_metric_space (has_nndist (option name))) := sorry --non-trivial
lemma new_lemma_168950 (h0 : topological_space (has_top (semiring empty))) : totally_disconnected_space (has_top (semiring empty)) := sorry --non-trivial
lemma new_lemma_168951 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_emptyc.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} h0 (has_emptyc.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_168952 (h0 : add_monoid (has_neg_part (option (option (option (option (option (option (option unsigned))))))))) : add_monoid.fg (has_neg_part (option (option (option (option (option (option (option unsigned)))))))) := sorry --non-trivial
lemma new_lemma_168953 (h0 : functor.comp topological_space has_add Type) : @preconnected_space.{1} (has_add.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} has_add.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_168954 (h0 : functor.add_const (monoid (has_Sup empty)) (option (option empty))) : @monoid.fg.{0} (has_Sup.{0} empty) (@functor.add_const.run.{0 0} (monoid.{0} (has_Sup.{0} empty)) (option.{0} (option.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_168955 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (normed_comm_ring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_168956 (h0 : topological_space (has_neg_part unsigned)) : irreducible_space (has_neg_part unsigned) := sorry --non-trivial
lemma new_lemma_168957 (h0 : functor.add_const (topological_space (sub_neg_monoid pos)) (finset pos)) : @regular_space.{0} (sub_neg_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (sub_neg_monoid.{0} pos)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_168958 (h0 : preorder num) (h1 : not (ring (closure_operator num) -> false)) : @rank_condition.{0} (@closure_operator.{0} num h0) (@classical.by_contradiction'.{1} (ring.{0} (@closure_operator.{0} num h0)) h1)  := sorry --non-trivial
lemma new_lemma_168959 (h0 : uniform_space (has_div char)) : complete_space (has_div char) := sorry --non-trivial
lemma new_lemma_168960 (h0 : list (is_R_or_C (semiring (semiring empty)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_168961 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @sequential_space.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_168962 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_168963 (h0 h1 : multiset (comm_ring linarith.comp_source)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_168964 (h0 : filter (has_neg (has_add pos))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_168965 (h0 : finset (free_add_monoid (semiring (semiring unsigned)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_168966 (h0 : functor.add_const (functor.add_const (group pos) pos) pos) : @normalizer_condition.{0} pos (@functor.add_const.run.{0 0} (group.{0} pos) pos (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (group.{0} pos) pos) pos h0))  := sorry --non-trivial
lemma new_lemma_168967 (h1 : function.extfun Type topological_space) : @totally_separated_space.{0} linarith.comp_source (@function.extfun_app.{2 1} Type topological_space.{0} h1 linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_168968 (h0 : add_monoid (has_sub unsigned)) : add_monoid.fg (has_sub unsigned) := sorry --non-trivial
lemma new_lemma_168969 (h1 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} (has_top.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h1) (has_top.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_168970 (h0 : function.extfun Type (functor.add_const (ordered_add_comm_monoid (ordered_ring empty)))) : @archimedean.{0} (ordered_ring.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (ordered_ring.{0} empty)) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ordered_add_comm_monoid.{0} (ordered_ring.{0} empty))) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_168971 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (add_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_168972 (h0 : monoid (linear_ordered_semiring (has_norm (has_norm (has_top (has_norm fun_info)))))) : monoid.fg (linear_ordered_semiring (has_norm (has_norm (has_top (has_norm fun_info))))) := sorry --non-trivial
lemma new_lemma_168973 (h0 : not (function.extfun Type topological_space -> false)) : @discrete_topology.{0} (has_edist.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_edist.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_168974 (h0 : topological_space (has_to_string (has_add unsigned))) : preconnected_space (has_to_string (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_168975 (h0 : ring (add_cancel_monoid (has_pos_part pos))) : is_principal_ideal_ring (add_cancel_monoid (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_168976 (h0 : complete_lattice (add_cancel_monoid (has_zero linarith.comp))) : is_compactly_generated (add_cancel_monoid (has_zero linarith.comp)) := sorry --non-trivial
lemma new_lemma_168977 (h0 : topological_space (canonically_ordered_comm_semiring (has_nndist (has_add ennreal)))) : normal_space (canonically_ordered_comm_semiring (has_nndist (has_add ennreal))) := sorry --non-trivial
lemma new_lemma_168978 (h0 : ring (linear_ordered_cancel_comm_monoid unsigned)) : strong_rank_condition (linear_ordered_cancel_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_168979 (h0 : group (measurable_space.dynkin_system (semiring num))) : is_cyclic (measurable_space.dynkin_system (semiring num)) := sorry --non-trivial
lemma new_lemma_168980 (h0 : functor.add_const (group (is_R_or_C unsigned)) empty) : @normalizer_condition.{0} (is_R_or_C.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (is_R_or_C.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_168981 (h0 : uniform_space (ring (has_Inf (mul_one_class (ring linarith.comp))))) : complete_space (ring (has_Inf (mul_one_class (ring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_168982 (h0 : topological_space (measurable_space.dynkin_system (semiring empty))) : discrete_topology (measurable_space.dynkin_system (semiring empty)) := sorry --non-trivial
lemma new_lemma_168983 (h2 : not (has_mem.mem topological_space has_emptyc.emptyc -> false)) : @totally_disconnected_space.{0} linarith.comp_source (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0} (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type)))) h2)) linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_168984 (h0 : ring (with_one unsigned)) : is_domain (with_one unsigned) := sorry --non-trivial
lemma new_lemma_168985 (h0 : ring (has_neg linarith.comp)) : is_principal_ideal_ring (has_neg linarith.comp) := sorry --non-trivial
lemma new_lemma_168986 (h0 : fin has_zero.zero) : @strong_rank_condition.{0} (canonically_ordered_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ring.{0}) h0) (canonically_ordered_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_168987 (h0 : functor.add_const Prop linarith.comp) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_168988 (h0 : uniform_space (has_nnnorm (mul_one_class (mul_one_class string.iterator_imp)))) : complete_space (has_nnnorm (mul_one_class (mul_one_class string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_168989 (h0 : not (uniform_space (with_one congr_arg_kind) -> false)) : @separated_space.{0} (with_one.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (uniform_space.{0} (with_one.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_168990 (h0 : topological_space (has_neg_part num)) : path_connected_space (has_neg_part num) := sorry --non-trivial
lemma new_lemma_168991 (h0 : functor.add_const (topological_space (option empty)) unsigned) : @locally_compact_space.{0} (option.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_168992 (h0 : topological_space (bin_tree num)) : totally_disconnected_space (bin_tree num) := sorry --non-trivial
lemma new_lemma_168993 (h0 : add_group (denumerable fun_info)) : is_add_cyclic (denumerable fun_info) := sorry --non-trivial
lemma new_lemma_168994 (h0 : functor.add_const (function.extfun Type topological_space) real) : @preirreducible_space.{0} (ordered_comm_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) real h0) (ordered_comm_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_168995 (h0 : topological_space (comm_group (option (option unsigned)))) : path_connected_space (comm_group (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_168996 (h0 : topological_space (comm_group (comm_group pos))) : irreducible_space (comm_group (comm_group pos)) := sorry --non-trivial
lemma new_lemma_168997 (h0 : group (topological_space (topological_space (has_nnnorm linarith.ineq)))) : is_cyclic (topological_space (topological_space (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_168998 (h0 : topological_space (mul_zero_class Type)) : t0_space (mul_zero_class Type) := sorry --non-trivial
lemma new_lemma_168999 (h0 : functor.add_const (complete_lattice (add_comm_monoid Type)) environment.implicit_infer_kind) : @is_atomistic.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (add_comm_monoid.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_169000 (h1 : topological_space (has_one num)) : t0_space (has_one num) := sorry --non-trivial
lemma new_lemma_169001 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : is_compactly_generated (measurable_space num) := sorry --non-trivial
lemma new_lemma_169002 (h0 : complete_lattice (has_one (has_top linarith.comp))) : complete_lattice.is_Sup_finite_compact (has_one (has_top linarith.comp)) := sorry --non-trivial
lemma new_lemma_169003 (h0 : ring (random_gen (has_ssubset linarith.comp_source))) : is_domain (random_gen (has_ssubset linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_169004 (h0 : list (ordered_ring congr_arg_kind)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_169005 (h0 : ring (with_bot empty)) : strong_rank_condition (with_bot empty) := sorry --non-trivial
lemma new_lemma_169006 (h0 : topological_space (has_pos_part (boolean_algebra.core Type))) : sequential_space (has_pos_part (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_169007 (h0 : topological_space (linear_ordered_comm_ring empty)) : preirreducible_space (linear_ordered_comm_ring empty) := sorry --non-trivial
lemma new_lemma_169008 (h0 : functor.add_const (function.extfun Type ring) pos) : @strong_rank_condition.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) pos h0) (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_169009 (h0 : functor.add_const (group (has_zero name)) name) : @is_cyclic.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (group.{0} (has_zero.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_169010 (h0 : group (normed_group (random_gen (has_nnnorm to_additive.value_type)))) : group.fg (normed_group (random_gen (has_nnnorm to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_169011 (h0 : functor.add_const (complete_lattice (has_star unsigned)) empty) : @complete_lattice.is_Sup_finite_compact.{0} (has_star.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_star.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_169012 (h1 : function.extfun Type ring) : @strong_rank_condition.{0} (@id.{2} Type to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} h1 (@id.{2} Type to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_169013 (h0 : uniform_space (mul_zero_class (semiring (semiring (semiring (semiring empty)))))) : complete_space (mul_zero_class (semiring (semiring (semiring (semiring empty))))) := sorry --non-trivial
lemma new_lemma_169014 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (pseudo_metric_space.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (pseudo_metric_space.{0} name))  := sorry --non-trivial
lemma new_lemma_169015 (h1 : ring (has_add string_imp)) : rank_condition (has_add string_imp) := sorry --non-trivial
lemma new_lemma_169016 (h0 : ring (generalized_boolean_algebra Type)) : strong_rank_condition (generalized_boolean_algebra Type) := sorry --non-trivial
lemma new_lemma_169017 (h0 : topological_space (linear_ordered_field ennreal)) : preirreducible_space (linear_ordered_field ennreal) := sorry --non-trivial
lemma new_lemma_169018 (h0 : add_monoid (semi_normed_ring real.angle)) (h1 : topological_space (uniform_space (add_action (semi_normed_ring real.angle) linarith.ineq))) : t0_space (uniform_space (add_action (semi_normed_ring real.angle) linarith.ineq)) := sorry --non-trivial
lemma new_lemma_169019 (h0 : ring (has_to_string (finset (finset environment.implicit_infer_kind)))) : is_principal_ideal_ring (has_to_string (finset (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_169020 (h0 : functor.add_const (uniform_space (has_pos_part real)) real) : @complete_space.{0} (has_pos_part.{0} real) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_pos_part.{0} real)) real h0)  := sorry --non-trivial
lemma new_lemma_169021 (h0 : functor.add_const (function.extfun (Type 1) add_group) linarith.comp) : @is_add_cyclic.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) add_group.{1}) linarith.comp h0) (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_169022 (h1 : uniform_space (non_unital_non_assoc_semiring string.iterator_imp)) : complete_space (non_unital_non_assoc_semiring string.iterator_imp) := sorry --non-trivial
lemma new_lemma_169023 (h0 : topological_space (normed_group (random_gen fun_info))) : totally_separated_space (normed_group (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_169024 (h1 : topological_space (mul_one_class (mul_one_class ereal))) (h2 : set (mul_one_class (mul_one_class ereal))) : is_path_connected h2 := sorry --non-trivial
lemma new_lemma_169025 (h0 : function.extfun Type uniform_space) : @complete_space.{0} linarith.ineq (@function.extfun_app.{2 1} Type uniform_space.{0} h0 linarith.ineq)  := sorry --non-trivial
lemma new_lemma_169026 (h0 : filter (semigroup (normed_comm_ring pos))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_169027 (h0 : uniform_space (semi_normed_ring string.iterator_imp)) : complete_space (semi_normed_ring string.iterator_imp) := sorry --non-trivial
lemma new_lemma_169028 (h0 : topological_space (with_bot (random_gen linarith.comp_source))) : irreducible_space (with_bot (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_169029 (h0 : functor.add_const (topological_space (boolean_algebra.core Type)) name) : @locally_compact_space.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.core.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_169030 (h0 : topological_space (has_emptyc (has_inv linarith.ineq))) : t0_space (has_emptyc (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_169031 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_inter.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inter.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_169032 (h0 : group (add_cancel_monoid (has_nndist environment.implicit_infer_kind))) : group.fg (add_cancel_monoid (has_nndist environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_169033 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} real.angle (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) real.angle)  := sorry --non-trivial
lemma new_lemma_169034 (h0 : ring (random_gen (random_gen empty))) : rank_condition (random_gen (random_gen empty)) := sorry --non-trivial
lemma new_lemma_169035 (h0 : topological_space (canonically_linear_ordered_monoid Type)) : regular_space (canonically_linear_ordered_monoid Type) := sorry --non-trivial
lemma new_lemma_169036 (h0 : functor.add_const (topological_space (ordered_comm_group empty)) congr_arg_kind) : @preirreducible_space.{0} (ordered_comm_group.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_group.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_169037 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (boolean_algebra linarith.comp)) := sorry --non-trivial
lemma new_lemma_169038 (h0 : topological_space (id linarith.comp_source)) : locally_compact_space (id linarith.comp_source) := sorry --non-trivial
lemma new_lemma_169039 (h0 : topological_space (encodable (random_gen (random_gen (random_gen linarith.ineq))))) : t0_space (encodable (random_gen (random_gen (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_169040 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (has_Inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_Inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_169041 (h0 : function.extfun Type ring) : @is_domain.{0} (dlist.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} h0 (dlist.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_169042 (h0 : functor.add_const (function.extfun Type uniform_space) Type) : @complete_space.{0} (has_nndist.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type uniform_space.{0}) Type h0) (has_nndist.{0} name))  := sorry --non-trivial
lemma new_lemma_169043 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_169044 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (has_zero (option pos))) := sorry --non-trivial
lemma new_lemma_169045 (h0 : group (finset (mul_one_class pos))) : is_simple_group (finset (mul_one_class pos)) := sorry --non-trivial
lemma new_lemma_169046 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring name)) Type) : @t1_space.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (canonically_ordered_comm_semiring.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_169047 (h0 : function.extfun (Type 1) ordered_comm_monoid) : @has_exists_mul_of_le.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_comm_monoid.{1} h0 (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_169048 (h0 : functor.add_const (topological_space (semiring num)) empty) : @preirreducible_space.{0} (semiring.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (semiring.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_169049 (h0 : topological_space (generalized_boolean_algebra (sub_neg_monoid (has_bot name)))) : preirreducible_space (generalized_boolean_algebra (sub_neg_monoid (has_bot name))) := sorry --non-trivial
lemma new_lemma_169050 (h0 : topological_space (sub_neg_monoid (finset (boolean_algebra.core linarith.comp)))) : path_connected_space (sub_neg_monoid (finset (boolean_algebra.core linarith.comp))) := sorry --non-trivial
lemma new_lemma_169051 (h0 : has_mem.mem (has_top linarith.comp_source) has_emptyc.emptyc) : @path_connected_space.{0} (has_top.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_top.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_169052 (h0 : monoid (metric_space (has_top congr_arg_kind))) : monoid.fg (metric_space (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_169053 (h0 : add_group (pseudo_metric_space (option pos))) : is_add_cyclic (pseudo_metric_space (option pos)) := sorry --non-trivial
lemma new_lemma_169054 (h0 : filter (normed_comm_ring (has_to_string linarith.comp))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_169055 (h0 : add_group (linear_ordered_comm_group_with_zero (mul_one_class environment.projection_info))) : is_add_cyclic (linear_ordered_comm_group_with_zero (mul_one_class environment.projection_info)) := sorry --non-trivial
lemma new_lemma_169056 (h0 : functor.add_const (function.extfun Type topological_space) name) : @t1_space.{0} (ring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (ring.{0} name))  := sorry --non-trivial
lemma new_lemma_169057 (h0 : functor.add_const (topological_space (has_inter empty)) unsigned) : @locally_compact_space.{0} (has_inter.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_inter.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_169058 (h0 : functor.add_const (topological_space (monoid empty)) empty) : @preirreducible_space.{0} (monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_169059 (h0 : functor.add_const (ring (comm_group pos)) linarith.comp) : @is_domain.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (comm_group.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_169060 (h0 : functor.add_const (function.extfun Type ring) linarith.comp) : @rank_condition.{0} (boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) linarith.comp h0) (boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_169061 (h0 : functor.add_const (uniform_space (finset linarith.comp)) (mul_one_class linarith.comp)) : @separated_space.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (finset.{0} linarith.comp)) (mul_one_class.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_169062 (h0 : topological_space (ordered_comm_monoid (ring (ring (ring Type))))) : sequential_space (ordered_comm_monoid (ring (ring (ring Type)))) := sorry --non-trivial
lemma new_lemma_169063 (h0 : topological_space (canonically_ordered_comm_semiring congr_arg_kind)) : irreducible_space (canonically_ordered_comm_semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_169064 (h0 : uniform_space (ordered_comm_ring (ring Type))) : separated_space (ordered_comm_ring (ring Type)) := sorry --non-trivial
lemma new_lemma_169065 (h0 : topological_space (finset (finset name))) : path_connected_space (finset (finset name)) := sorry --non-trivial
lemma new_lemma_169066 (h0 : preorder (has_Inf Type)) (h1 : has_Inf Type -> set (has_Inf pos)) : filter.is_antitone_basis h1 := sorry --non-trivial
lemma new_lemma_169067 (h1 : add_group (has_compl fun_info)) : is_add_cyclic (has_compl fun_info) := sorry --non-trivial
lemma new_lemma_169068 (h0 : fin has_zero.zero) : matrix.vec_empty (matrix.vec_empty (id (id h0))) := sorry --non-trivial
lemma new_lemma_169069 (h0 : functor.add_const (topological_space (add_left_cancel_semigroup unsigned)) num) : @normal_space.{0} (add_left_cancel_semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_left_cancel_semigroup.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_169070 (h0 : ring (has_top (random_gen linarith.ineq))) : is_domain (has_top (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_169071 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_169072 (h0 : topological_space (complete_semilattice_Sup (random_gen (random_gen to_additive.value_type)))) : t0_space (complete_semilattice_Sup (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_169073 (h0 : uniform_space (boolean_algebra (cancel_monoid name))) : complete_space (boolean_algebra (cancel_monoid name)) := sorry --non-trivial
lemma new_lemma_169074 (h0 : functor.add_const (group (add_cancel_monoid environment.implicit_infer_kind)) environment.implicit_infer_kind) : @is_simple_group.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_169075 (h0 : semiring (boolean_algebra.core congr_arg_kind)) : is_noetherian_ring (boolean_algebra.core congr_arg_kind) := sorry --non-trivial
lemma new_lemma_169076 (h0 : topological_space (has_nnnorm (has_nnnorm linarith.ineq))) : totally_disconnected_space (has_nnnorm (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_169077 (h0 : fin has_zero.zero) : nat.perfect (id (id (matrix.vec_empty (id (id (id h0)))))) := sorry --non-trivial
lemma new_lemma_169078 (h0 : topological_space (canonically_ordered_comm_semiring (has_add (option ennreal)))) : sequential_space (canonically_ordered_comm_semiring (has_add (option ennreal))) := sorry --non-trivial
lemma new_lemma_169079 (h0 : functor.add_const (filter (comm_group pos)) name) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_169080 (h0 : add_group (linear_ordered_cancel_comm_monoid unsigned)) : is_add_cyclic (linear_ordered_cancel_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_169081 (h0 : topological_space (has_Inf (has_pos_part (has_add linarith.comp)))) : preirreducible_space (has_Inf (has_pos_part (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_169082 (h0 : function.extfun Type (functor.add_const (ordered_comm_monoid (has_bot linarith.comp)))) : @has_exists_mul_of_le.{0} (has_bot.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_bot.{0} linarith.comp)) name (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ordered_comm_monoid.{0} (has_bot.{0} linarith.comp))) h0 name))  := sorry --non-trivial
lemma new_lemma_169083 (h0 : add_group (non_assoc_semiring empty)) : is_add_cyclic (non_assoc_semiring empty) := sorry --non-trivial
lemma new_lemma_169084 (h1 : function.extfun (finset (Type -> Type)) (has_mem.mem ring)) : @is_domain.{0} (with_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) ring.{0}) h1 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (with_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_169085 (h0 : simple_graph fun_info) (h1 h2 h3 : fun_info) : simple_graph.common_neighbors h0 h1 h2 h3 := sorry --non-trivial
lemma new_lemma_169086 (h0 : function.extfun Type topological_space) : @regular_space.{0} (linear_ordered_field.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_field.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_169087 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_169088 (h0 : function.extfun Type group) : @is_cyclic.{0} (ordered_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (ordered_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_169089 (h0 : functor.add_const (group (has_zero pos)) pos) : @normalizer_condition.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_zero.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_169090 (h0 : functor.add_const (topological_space (complete_distrib_lattice name)) linarith.comp) : @topological_space.separable_space.{0} (complete_distrib_lattice.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_169091 (h0 : topological_space (non_unital_non_assoc_semiring string.iterator_imp)) : t0_space (non_unital_non_assoc_semiring string.iterator_imp) := sorry --non-trivial
lemma new_lemma_169092 (h0 : topological_space (normed_group (semiring (semiring unsigned)))) : totally_disconnected_space (normed_group (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_169093 (h0 : filter (has_compl to_additive.value_type)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_169094 (h0 : uniform_space (add_group (semiring num))) : complete_space (add_group (semiring num)) := sorry --non-trivial
lemma new_lemma_169095 (h0 : topological_space (add_comm_semigroup (mul_one_class (mul_one_class ereal)))) : totally_disconnected_space (add_comm_semigroup (mul_one_class (mul_one_class ereal))) := sorry --non-trivial
lemma new_lemma_169096 (h0 : function.extfun Type group) : @normalizer_condition.{0} (with_bot.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (with_bot.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_169097 (h0 : add_group (add_comm_semigroup (mul_one_class (normed_field environment.projection_info)))) : is_add_cyclic (add_comm_semigroup (mul_one_class (normed_field environment.projection_info))) := sorry --non-trivial
lemma new_lemma_169098 (h0 : has_mem.mem (has_emptyc linarith.comp_source) has_emptyc.emptyc) : @totally_separated_space.{0} (has_emptyc.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_emptyc.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_169099 (h0 : function.extfun Type measurable_space) (h1 : has_div (add_right_cancel_monoid congr_arg_kind)) : @has_measurable_div₂.{0} (add_right_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type measurable_space.{0} h0 (add_right_cancel_monoid.{0} congr_arg_kind)) h1  := sorry --non-trivial
lemma new_lemma_169100 (h1 : set (has_lt string_imp)) : set.finite h1 := sorry --non-trivial
lemma new_lemma_169101 (h0 : topological_space (ring (has_to_string (ring Type)))) : t1_space (ring (has_to_string (ring Type))) := sorry --non-trivial
lemma new_lemma_169102 (h0 : std_gen -> ring (nondiscrete_normed_field enat)) (h1 : set std_gen) (h2 : coe_sort h1) : @strong_rank_condition.{0} (nondiscrete_normed_field.{0} enat) (@set.restrict.{0 0} std_gen (ring.{0} (nondiscrete_normed_field.{0} enat)) h0 h1 h2)  := sorry --non-trivial
lemma new_lemma_169103 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @preirreducible_space.{1} (boolean_algebra.core.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (boolean_algebra.core.{1} Type))  := sorry --non-trivial
lemma new_lemma_169104 (h0 : topological_space (has_zero (has_add (has_add name)))) : discrete_topology (has_zero (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_169105 (h0 : group (has_Inf (finset pos))) : group.fg (has_Inf (finset pos)) := sorry --non-trivial
lemma new_lemma_169106 (h0 : topological_space (measurable_space (has_norm num))) : totally_separated_space (measurable_space (has_norm num)) := sorry --non-trivial
lemma new_lemma_169107 (h1 : group (comm_ring (random_gen string_imp))) : is_cyclic (comm_ring (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_169108 (h0 : complete_lattice (with_one (semiring congr_arg_kind))) : complete_lattice.is_Sup_finite_compact (with_one (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_169109 (h0 : topological_space (filter.countable_filter_basis enat)) : path_connected_space (filter.countable_filter_basis enat) := sorry --non-trivial
lemma new_lemma_169110 (h0 : topological_space (linear_ordered_comm_group pos)) : preirreducible_space (linear_ordered_comm_group pos) := sorry --non-trivial
lemma new_lemma_169111 (h0 : fin has_zero.zero) : @preconnected_space.{0} (normed_lattice_add_comm_group.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (normed_lattice_add_comm_group.{0} real))  := sorry --non-trivial
lemma new_lemma_169112 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @discrete_topology.{0} (has_union.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) topological_space.{0}) (has_union.{0} empty))  := sorry --non-trivial
lemma new_lemma_169113 (h0 : set (normed_field (has_le linarith.comp_source))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_169114 (h0 : normed_comm_ring (monoid (option (option ennreal))) -> normed_comm_ring (monoid (option (option ennreal))) -> Prop) : is_symm (normed_comm_ring (monoid (option (option ennreal)))) h0 := sorry --non-trivial
lemma new_lemma_169115 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (left_cancel_semigroup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_group.{0} h0 (left_cancel_semigroup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_169116 (h0 : ring (linear_ordered_cancel_comm_monoid empty)) : strong_rank_condition (linear_ordered_cancel_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_169117 (h0 : ring (add_cancel_monoid (has_to_string (finset pos)))) : rank_condition (add_cancel_monoid (has_to_string (finset pos))) := sorry --non-trivial
lemma new_lemma_169118 (h0 : ordered_add_comm_monoid (has_add (ring (ring Type)))) : archimedean (has_add (ring (ring Type))) := sorry --non-trivial
lemma new_lemma_169119 (h0 : has_mem.mem (measurable_space to_additive.value_type) has_emptyc.emptyc) : @rank_condition.{0} (measurable_space.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type ring.{0} (measurable_space.{0} to_additive.value_type) h0)  := sorry --non-trivial
lemma new_lemma_169120 (h0 : group (has_norm (random_gen (random_gen (has_inv linarith.comp_source))))) : is_cyclic (has_norm (random_gen (random_gen (has_inv linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_169121 (h1 : topological_space (normed_group congr_arg_kind)) : irreducible_space (normed_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_169122 (h0 : topological_space (has_inter unsigned)) : locally_compact_space (has_inter unsigned) := sorry --non-trivial
lemma new_lemma_169123 (h0 : topological_space (canonically_ordered_comm_semiring (option (option empty)))) : path_connected_space (canonically_ordered_comm_semiring (option (option empty))) := sorry --non-trivial
lemma new_lemma_169124 (h0 : function.extfun Type group) : @is_cyclic.{0} (with_bot.{0} (random_gen.{0} string_imp)) (@function.extfun_app.{2 1} Type group.{0} h0 (with_bot.{0} (random_gen.{0} string_imp)))  := sorry --non-trivial
lemma new_lemma_169125 (h0 : function.extfun (Type 1) ordered_comm_monoid) : @has_exists_mul_of_le.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_comm_monoid.{1} h0 (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_169126 (h0 : functor.add_const (ring (semigroup linarith.comp)) pos) : @rank_condition.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (semigroup.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_169127 (h0 : ring (semigroup (has_neg_part name))) : strong_rank_condition (semigroup (has_neg_part name)) := sorry --non-trivial
lemma new_lemma_169128 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_Inf.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_Inf.{0} name))  := sorry --non-trivial
lemma new_lemma_169129 (h0 : monoid (semigroup (normed_comm_ring (has_add linarith.comp)))) : monoid.fg (semigroup (normed_comm_ring (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_169130 (h0 : has_neg (linear_ordered_comm_group_with_zero string.iterator_imp)) (h1 : measurable_space (linear_ordered_comm_group_with_zero string.iterator_imp)) : has_measurable_neg (linear_ordered_comm_group_with_zero string.iterator_imp) := sorry --non-trivial
lemma new_lemma_169131 (h0 : topological_space (semiring (has_top linarith.comp))) : preirreducible_space (semiring (has_top linarith.comp)) := sorry --non-trivial
lemma new_lemma_169132 (h0 : not (complete_lattice (measurable_space (has_top fun_info)) -> false)) : complete_lattice.is_Sup_finite_compact (measurable_space (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_169133 (h0 : topological_space (has_union (has_norm (has_norm empty)))) : t0_space (has_union (has_norm (has_norm empty))) := sorry --non-trivial
lemma new_lemma_169134 (h0 : topological_space (with_one (random_gen (comm_ring (random_gen fun_info))))) : totally_disconnected_space (with_one (random_gen (comm_ring (random_gen fun_info)))) := sorry --non-trivial
lemma new_lemma_169135 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (add_left_cancel_semigroup.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_left_cancel_semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_169136 (h0 : not (complete_lattice (lex linarith.ineq) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (lex.{0} linarith.ineq) (@classical.by_contradiction'.{1} (complete_lattice.{0} (lex.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_169137 (h0 : ring (has_nndist (finset (finset ennreal)))) : is_domain (has_nndist (finset (finset ennreal))) := sorry --non-trivial
lemma new_lemma_169138 (h0 : functor.add_const (semiring (preorder num)) congr_arg_kind) : @is_noetherian_ring.{0} (preorder.{0} num) (@functor.add_const.run.{0 0} (semiring.{0} (preorder.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_169139 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} (has_add.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_add.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_169140 (h0 : ring (uniform_space (mul_one_class linarith.comp_source))) : strong_rank_condition (uniform_space (mul_one_class linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_169141 (h0 : list (ordered_ring (normed_linear_ordered_group (free_add_monoid (option (semiring unsigned)))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_169142 (h0 : semiring (with_bot (semiring (semiring linarith.comp)))) : is_noetherian_ring (with_bot (semiring (semiring linarith.comp))) := sorry --non-trivial
lemma new_lemma_169143 (h0 : not (ring (distrib_lattice linarith.ineq) -> false)) : @strong_rank_condition.{0} (distrib_lattice.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (distrib_lattice.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_169144 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_bot.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_bot.{0} empty))  := sorry --non-trivial
lemma new_lemma_169145 (h0 : ring (bin_tree empty)) : strong_rank_condition (bin_tree empty) := sorry --non-trivial
lemma new_lemma_169146 (h0 : finset (cancel_monoid (option (option (option ennreal))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_169147 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} fun_info (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) fun_info)  := sorry --non-trivial
lemma new_lemma_169148 (h0 : ring (has_bot (option (option (option (option (option unsigned))))))) : rank_condition (has_bot (option (option (option (option (option unsigned)))))) := sorry --non-trivial
lemma new_lemma_169149 (h0 : group (canonically_linear_ordered_monoid (has_Inf Type))) : is_cyclic (canonically_linear_ordered_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_169150 (h0 : not (ring (has_sub congr_arg_kind) -> false)) : @is_domain.{0} (has_sub.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (ring.{0} (has_sub.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_169151 (h0 : add_group (has_top (random_gen (comm_ring to_additive.value_type)))) : is_add_cyclic (has_top (random_gen (comm_ring to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_169152 (h0 : not (ring (add_monoid linarith.ineq) -> false)) : @rank_condition.{0} (add_monoid.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (add_monoid.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_169153 (h0 : ring (add_cancel_monoid (has_neg linarith.comp))) : is_principal_ideal_ring (add_cancel_monoid (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_169154 (h0 : group (finset (has_neg (has_neg (normed_comm_ring linarith.comp))))) : normalizer_condition (finset (has_neg (has_neg (normed_comm_ring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_169155 (h0 : topological_space (has_nndist (has_to_string (has_add name)))) : totally_separated_space (has_nndist (has_to_string (has_add name))) := sorry --non-trivial
lemma new_lemma_169156 (h0 : ring (ordered_comm_ring (has_add (has_add real)))) : is_domain (ordered_comm_ring (has_add (has_add real))) := sorry --non-trivial
lemma new_lemma_169157 (h0 : ring (measurable_space (has_top to_additive.value_type))) : rank_condition (measurable_space (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_169158 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (measurable_space.dynkin_system.{0} num) (@function.extfun_app.{2 1} Type add_group.{0} h0 (measurable_space.dynkin_system.{0} num))  := sorry --non-trivial
lemma new_lemma_169159 (h0 : functor.add_const (group (add_comm_monoid linarith.comp)) pos) : @is_simple_group.{0} (add_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (add_comm_monoid.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_169160 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (ordered_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (ordered_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_169161 (h0 : group (ring (has_add Type))) : is_simple_group (ring (has_add Type)) := sorry --non-trivial
lemma new_lemma_169162 (h0 : add_group (topological_space (has_nnnorm (random_gen fun_info)))) : is_add_cyclic (topological_space (has_nnnorm (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_169163 (h0 : topological_space (has_ssubset (has_inv char))) : path_connected_space (has_ssubset (has_inv char)) := sorry --non-trivial
lemma new_lemma_169164 (h0 : not (function.extfun Type semiring -> false)) : @is_noetherian_ring.{0} (has_norm.{0} empty) (@function.extfun_app.{2 1} Type semiring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type semiring.{0}) h0) (has_norm.{0} empty))  := sorry --non-trivial
lemma new_lemma_169165 (h0 : functor.comp topological_space normed_comm_ring Type) : @loc_path_connected_space.{1} (normed_comm_ring.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} normed_comm_ring.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_169166 (h0 : fin has_zero.zero) : @is_compactly_generated.{0} (canonically_linear_ordered_monoid.{0} name) (@matrix.vec_empty.{0} (complete_lattice.{0} (canonically_linear_ordered_monoid.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_169167 (h0 : functor.add_const (group (has_edist unsigned)) empty) : @group.fg.{0} (has_edist.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (has_edist.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_169168 (h0 : topological_space (add_left_cancel_semigroup congr_arg_kind)) : discrete_topology (add_left_cancel_semigroup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_169169 (h0 : functor.add_const (topological_space (has_to_string Type)) Type) : @discrete_topology.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_to_string.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_169170 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (normed_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_169171 (h0 : function.extfun Type topological_space) : @t1_space.{0} (simple_graph.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (simple_graph.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_169172 (h0 : ring (has_to_string num)) : rank_condition (has_to_string num) := sorry --non-trivial
lemma new_lemma_169173 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (option.{0} empty) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (option.{0} empty))  := sorry --non-trivial
lemma new_lemma_169174 (h0 : has_neg (simple_graph (mul_one_class fun_info))) (h1 : measurable_space (simple_graph (mul_one_class fun_info))) : has_measurable_neg (simple_graph (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_169175 (h0 : not (add_group (with_one congr_arg_kind) -> false)) : @is_add_cyclic.{0} (with_one.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (add_group.{0} (with_one.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_169176 (h1 : add_group (add_comm_semigroup (add_comm_semigroup fun_info))) : is_add_cyclic (add_comm_semigroup (add_comm_semigroup fun_info)) := sorry --non-trivial
lemma new_lemma_169177 (h0 : complete_lattice (finset (has_zero Type))) : is_compactly_generated (finset (has_zero Type)) := sorry --non-trivial
lemma new_lemma_169178 (h0 : group (measurable_space (with_bot string_imp))) : group.fg (measurable_space (with_bot string_imp)) := sorry --non-trivial
lemma new_lemma_169179 (h0 : list (comm_monoid (add_left_cancel_semigroup (option unsigned)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_169180 (h0 : functor.add_const (ring (add_comm_monoid pos)) (finset Type)) : @strong_rank_condition.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (add_comm_monoid.{0} pos)) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_169181 (h1 : complete_lattice (non_unital_non_assoc_semiring string.iterator_imp)) : is_compactly_generated (non_unital_non_assoc_semiring string.iterator_imp) := sorry --non-trivial
lemma new_lemma_169182 (h0 : add_group (has_inter (option (option (option (option empty)))))) : is_add_cyclic (has_inter (option (option (option (option empty))))) := sorry --non-trivial
lemma new_lemma_169183 (h0 : not (ring (mul_one_class char) -> false)) : @rank_condition.{0} (mul_one_class.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (mul_one_class.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_169184 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (canonically_linear_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (canonically_linear_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_169185 (h0 : functor.add_const (topological_space (has_to_string name)) linarith.comp) : @locally_compact_space.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_169186 (h0 : ordered_add_comm_monoid (generalized_boolean_algebra (finset linarith.comp))) : archimedean (generalized_boolean_algebra (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_169187 (h0 : functor.add_const (ring (semiring empty)) congr_arg_kind) : @rank_condition.{0} (semiring.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (semiring.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_169188 (h0 : functor.add_const (group (add_cancel_monoid pos)) name) : @is_simple_group.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (add_cancel_monoid.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_169189 (h0 : monoid Type) : monoid.fg Type := sorry --non-trivial
lemma new_lemma_169190 (h0 : topological_space (semigroup (mul_zero_class unsigned))) : sequential_space (semigroup (mul_zero_class unsigned)) := sorry --non-trivial
lemma new_lemma_169191 (h0 : semiring (simple_graph (has_add pos))) : is_noetherian_ring (simple_graph (has_add pos)) := sorry --non-trivial
lemma new_lemma_169192 (h0 : functor.add_const (list (boolean_algebra.core pos)) linarith.comp) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_169193 (h0 : ring (with_zero linarith.ineq)) : is_domain (with_zero linarith.ineq) := sorry --non-trivial
lemma new_lemma_169194 (h0 : functor.add_const (topological_space (has_nndist name)) pos) : @loc_path_connected_space.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_169195 (h0 : functor.comp topological_space mul_one_class Type) : @preirreducible_space.{1} (mul_one_class.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} mul_one_class.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_169196 (h0 : topological_space enat) : topological_space.first_countable_topology enat := sorry --non-trivial
lemma new_lemma_169197 (h0 : topological_space (has_ssubset (has_nnnorm (has_nnnorm (has_nnnorm reducibility_hints))))) : t0_space (has_ssubset (has_nnnorm (has_nnnorm (has_nnnorm reducibility_hints)))) := sorry --non-trivial
lemma new_lemma_169198 (h0 : topological_space (generalized_boolean_algebra pos)) : totally_disconnected_space (generalized_boolean_algebra pos) := sorry --non-trivial
lemma new_lemma_169199 (h0 : function.extfun Type topological_space) : @t0_space.{0} (measure_theory.measure_space.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measure_theory.measure_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_169200 (h0 : topological_space (canonically_ordered_comm_semiring (option ennreal))) : locally_compact_space (canonically_ordered_comm_semiring (option ennreal)) := sorry --non-trivial
lemma new_lemma_169201 (h0 : complete_lattice (linear_ordered_semiring (semiring (semiring congr_arg_kind)))) : is_atomistic (linear_ordered_semiring (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_169202 (h0 : ring (add_cancel_comm_monoid (random_gen (has_nnnorm (has_nnnorm linarith.ineq))))) : strong_rank_condition (add_cancel_comm_monoid (random_gen (has_nnnorm (has_nnnorm linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_169203 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_emptyc.{0} (has_top.{0} fun_info)) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_emptyc.{0} (has_top.{0} fun_info)))  := sorry --non-trivial
lemma new_lemma_169204 (h0 : functor.add_const (topological_space (add_cancel_comm_monoid empty)) congr_arg_kind) : @preirreducible_space.{0} (add_cancel_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_comm_monoid.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_169205 (h0 : functor.comp uniform_space has_to_string linarith.comp) : @complete_space.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_to_string.{0} linarith.comp)) linarith.comp (@functor.comp.run.{0 0 0} uniform_space.{0} has_to_string.{0} linarith.comp h0))  := sorry --non-trivial
lemma new_lemma_169206 (h0 : functor.comp topological_space semigroup pos) : @preconnected_space.{0} (semigroup.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_169207 (h0 : group (with_one (random_gen (random_gen to_additive.value_type)))) : group.fg (with_one (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_169208 (h0 : topological_space (has_neg (finset Type))) : discrete_topology (has_neg (finset Type)) := sorry --non-trivial
lemma new_lemma_169209 (h0 : functor.add_const (topological_space (has_add (finset linarith.comp))) pos) : @normal_space.{0} (has_add.{0} (finset.{0} linarith.comp)) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} (finset.{0} linarith.comp))) pos h0)  := sorry --non-trivial
lemma new_lemma_169210 (h0 : topological_space (canonically_ordered_monoid name)) : totally_disconnected_space (canonically_ordered_monoid name) := sorry --non-trivial
lemma new_lemma_169211 (h0 : function.extfun Type ring) : @rank_condition.{0} (mul_zero_class.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (mul_zero_class.{0} name))  := sorry --non-trivial
lemma new_lemma_169212 (h0 : complete_lattice (has_emptyc (random_gen (random_gen fun_info)))) : complete_lattice.is_Sup_finite_compact (has_emptyc (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_169213 (h0 : topological_space (cancel_monoid (has_nndist name))) : t1_space (cancel_monoid (has_nndist name)) := sorry --non-trivial
lemma new_lemma_169214 (h0 : finset (ordered_comm_ring (has_add (has_add pos)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_169215 (h0 : semiring (linear_ordered_field (finset (finset pos)))) : is_noetherian_ring (linear_ordered_field (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_169216 (h0 : topological_space (mul_zero_class (has_add pos))) : path_connected_space (mul_zero_class (has_add pos)) := sorry --non-trivial
lemma new_lemma_169217 (h0 : uniform_space (has_Inf pos)) : complete_space (has_Inf pos) := sorry --non-trivial
lemma new_lemma_169218 (h0 : uniform_space (add_cancel_monoid (option (option unsigned)))) : separated_space (add_cancel_monoid (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_169219 (h0 : functor.add_const (topological_space (has_zero linarith.comp)) Type) : @path_connected_space.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_zero.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_169220 (h0 : functor.add_const (group (has_add linarith.comp)) (ring pos)) : @group.fg.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (has_add.{0} linarith.comp)) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_169221 (h0 : topological_space (linear_ordered_comm_group unsigned)) : loc_path_connected_space (linear_ordered_comm_group unsigned) := sorry --non-trivial
lemma new_lemma_169222 (h0 : prod (has_union congr_arg_kind) (has_union congr_arg_kind)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_169223 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @totally_separated_space.{0} (ordered_comm_monoid.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_monoid.{0} pos)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_169224 (h0 : list (has_inv to_additive.value_type)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_169225 (h0 : topological_space (boolean_algebra (finset Type))) : irreducible_space (boolean_algebra (finset Type)) := sorry --non-trivial
lemma new_lemma_169226 (h0 : topological_space (has_top (semiring (semiring (has_top congr_arg_kind))))) : irreducible_space (has_top (semiring (semiring (has_top congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_169227 (h0 : functor.add_const (group (finset Type)) name) : @normalizer_condition.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (finset.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_169228 (h0 : group (with_one unsigned)) : is_cyclic (with_one unsigned) := sorry --non-trivial
lemma new_lemma_169229 (h0 : filter (has_add (has_inv (has_zero string_imp)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_169230 (h0 : ordered_add_comm_monoid (generalized_boolean_algebra (has_add (has_add linarith.comp)))) : archimedean (generalized_boolean_algebra (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_169231 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @normal_space.{1} (ordered_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (ordered_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_169232 (h0 : function.extfun Type (functor.comp semiring finset)) : @is_noetherian_ring.{0} (finset.{0} pos) (@functor.comp.run.{0 0 0} semiring.{0} finset.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} semiring.{0} finset.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_169233 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring ennreal)) pos) : @preconnected_space.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} ennreal)) pos h0)  := sorry --non-trivial
lemma new_lemma_169234 (h0 : monoid (boolean_algebra (finset (finset environment.implicit_infer_kind)))) : monoid.fg (boolean_algebra (finset (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_169235 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (random_gen.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (random_gen.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_169236 (h0 : function.extfun Type topological_space) : @normal_space.{0} (ordered_cancel_add_comm_monoid.{0} (option.{0} pos)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_cancel_add_comm_monoid.{0} (option.{0} pos)))  := sorry --non-trivial
lemma new_lemma_169237 (h0 : complete_lattice (has_append congr_arg_kind)) : complete_lattice.is_Sup_finite_compact (has_append congr_arg_kind) := sorry --non-trivial
lemma new_lemma_169238 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (mul_zero_class.{0} pos) (@function.extfun_app.{2 1} Type add_group.{0} h0 (mul_zero_class.{0} pos))  := sorry --non-trivial
lemma new_lemma_169239 (h0 : functor.add_const (functor.comp complete_lattice mul_zero_class ennreal) environment.implicit_infer_kind) : @is_compactly_generated.{0} (mul_zero_class.{0} ennreal) (@functor.comp.run.{0 0 0} complete_lattice.{0} mul_zero_class.{0} ennreal (@functor.add_const.run.{0 0} (functor.comp.{0 0 0} complete_lattice.{0} mul_zero_class.{0} ennreal) environment.implicit_infer_kind h0))  := sorry --non-trivial
lemma new_lemma_169240 (h0 : functor.add_const (complete_lattice (has_neg_part Type)) Type) : @is_atomistic.{1} (has_neg_part.{1} Type) (@functor.add_const.run.{1 1} (complete_lattice.{1} (has_neg_part.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_169241 (h2 : topological_space (mul_one_class enat)) : t0_space (mul_one_class enat) := sorry --non-trivial
lemma new_lemma_169242 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_169243 (h0 : not (group (normed_group congr_arg_kind) -> false)) : @normalizer_condition.{0} (normed_group.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (group.{0} (normed_group.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_169244 (h0 : semiring (has_star (semiring congr_arg_kind))) : is_noetherian_ring (has_star (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_169245 (h0 : topological_space (fintype (random_gen (random_gen char)))) : totally_disconnected_space (fintype (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_169246 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (linear_ordered_comm_ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (linear_ordered_comm_ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_169247 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (normed_linear_ordered_group (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_169248 (h0 : function.extfun Type group) : @is_cyclic.{0} (denumerable.{0} char) (@function.extfun_app.{2 1} Type group.{0} h0 (denumerable.{0} char))  := sorry --non-trivial
lemma new_lemma_169249 (h0 : topological_space (linear_ordered_field ennreal)) : totally_disconnected_space (linear_ordered_field ennreal) := sorry --non-trivial
lemma new_lemma_169250 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (linear_ordered_semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (linear_ordered_semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_169251 (h0 : function.extfun Type topological_space) : @normal_space.{0} (canonically_ordered_monoid.{0} (has_add.{0} pos)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_monoid.{0} (has_add.{0} pos)))  := sorry --non-trivial
lemma new_lemma_169252 (h0 : list (has_nndist (has_add (has_nndist (has_add (has_nndist Type)))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_169253 (h0 : not (topological_space (semi_normed_comm_ring fun_info) -> false)) : @path_connected_space.{0} (semi_normed_comm_ring.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (semi_normed_comm_ring.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_169254 (h0 : functor.add_const (complete_lattice (has_nndist name)) name) : @complete_lattice.is_Sup_finite_compact.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_nndist.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_169255 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (has_dist num)) := sorry --non-trivial
lemma new_lemma_169256 (h0 : not (has_mem.mem (normed_group num) has_emptyc.emptyc -> false)) : @separated_space.{0} (normed_group.{0} num) (@finset.pi.empty.{1 0} Type uniform_space.{0} (normed_group.{0} num) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (normed_group.{0} num) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_169257 (h0 : functor.add_const (topological_space (has_to_string linarith.comp)) pos) : @discrete_topology.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_169258 (h0 : add_monoid (has_neg (add_comm_monoid name))) : add_monoid.fg (has_neg (add_comm_monoid name)) := sorry --non-trivial
lemma new_lemma_169259 (h0 : topological_space (semigroup (has_pos_part Type))) : t0_space (semigroup (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_169260 (h0 : ring (has_add (has_to_string congr_arg_kind))) : is_domain (has_add (has_to_string congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_169261 (h0 : topological_space (has_union (semiring (semiring num)))) : locally_compact_space (has_union (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_169262 (h0 : ring (finset (has_neg Type))) : is_domain (finset (has_neg Type)) := sorry --non-trivial
lemma new_lemma_169263 (h0 : group (non_assoc_semiring (semiring empty))) : is_cyclic (non_assoc_semiring (semiring empty)) := sorry --non-trivial
lemma new_lemma_169264 (h0 : ring (normed_lattice_add_comm_group pos)) : is_domain (normed_lattice_add_comm_group pos) := sorry --non-trivial
lemma new_lemma_169265 (h0 : not (semiring (has_union linarith.comp) -> false)) : @is_noetherian_ring.{0} (has_union.{0} linarith.comp) (@classical.by_contradiction'.{1} (semiring.{0} (has_union.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_169266 (h0 : measurable_space (denumerable char)) (h1 : measure_theory.measure (denumerable char)) : measure_theory.has_no_atoms h1 := sorry --non-trivial
lemma new_lemma_169267 (h0 : functor.add_const (ring (semiring congr_arg_kind)) empty) : @rank_condition.{0} (semiring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ring.{0} (semiring.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_169268 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @regular_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.core.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_169269 (h0 : complete_lattice (random_gen (denumerable string.iterator_imp))) : complete_lattice.is_Sup_finite_compact (random_gen (denumerable string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_169270 (h0 : ring (has_Inf (sub_neg_monoid real))) : strong_rank_condition (has_Inf (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_169271 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_169272 (h0 : Prop) (h1 : list Prop) : list.ilast' h0 (id h1) := sorry --non-trivial
lemma new_lemma_169273 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (canonically_ordered_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (canonically_ordered_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_169274 (h0 : topological_space (has_add (has_nnnorm fun_info))) : path_connected_space (has_add (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_169275 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (ring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_169276 (h0 : group (id (semiring (semiring (semiring unsigned))))) : group.fg (id (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_169277 (h0 : topological_space (has_Inf (has_add (has_add pos)))) : preirreducible_space (has_Inf (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_169278 (h0 : topological_space (normed_comm_ring unsigned)) : path_connected_space (normed_comm_ring unsigned) := sorry --non-trivial
lemma new_lemma_169279 (h0 : functor.add_const (functor.add_const Prop (complete_distrib_lattice linarith.comp)) name) : functor.add_const.run (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_169280 (h0 : not (ring (normed_field (random_gen reducibility_hints)) -> false)) : @is_domain.{0} (normed_field.{0} (random_gen.{0} reducibility_hints)) (@classical.by_contradiction'.{1} (ring.{0} (normed_field.{0} (random_gen.{0} reducibility_hints))) h0)  := sorry --non-trivial
lemma new_lemma_169281 (h0 : semiring (finset (has_zero (has_zero pos)))) : is_noetherian_ring (finset (has_zero (has_zero pos))) := sorry --non-trivial
lemma new_lemma_169282 (h0 : functor.add_const (complete_lattice (has_neg_part name)) Type) : @complete_lattice.is_Sup_finite_compact.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 1} (complete_lattice.{0} (has_neg_part.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_169283 (h0 : group (add_comm_monoid (has_add linarith.comp))) : is_simple_group (add_comm_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_169284 (h0 : functor.add_const (monoid (finset name)) unsigned) : @monoid.fg.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (monoid.{0} (finset.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_169285 (h0 : uniform_space (non_unital_non_assoc_semiring (add_cancel_comm_monoid linarith.comp_source))) : complete_space (non_unital_non_assoc_semiring (add_cancel_comm_monoid linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_169286 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (normed_group fun_info)) := sorry --non-trivial
lemma new_lemma_169287 (h0 : function.extfun Type (functor.comp topological_space comm_group)) : @locally_compact_space.{0} (comm_group.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} comm_group.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} comm_group.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_169288 (h0 : topological_space (has_top (random_gen linarith.ineq))) : totally_disconnected_space (has_top (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_169289 (h0 : add_monoid (ordered_comm_monoid (has_Inf (has_Inf real)))) : add_monoid.fg (ordered_comm_monoid (has_Inf (has_Inf real))) := sorry --non-trivial
lemma new_lemma_169290 (h0 : topological_space (ordered_semiring congr_arg_kind)) : irreducible_space (ordered_semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_169291 (h0 : group (simple_graph (has_Inf linarith.comp))) : is_cyclic (simple_graph (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_169292 (h1 : ring (has_compl (random_gen (random_gen (random_gen char))))) : is_domain (has_compl (random_gen (random_gen (random_gen char)))) := sorry --non-trivial
lemma new_lemma_169293 (h0 : topological_space (has_norm num)) : totally_disconnected_space (has_norm num) := sorry --non-trivial
lemma new_lemma_169294 (h0 : generalized_boolean_algebra Type -> generalized_boolean_algebra Type -> Prop) : transitive h0 := sorry --non-trivial
lemma new_lemma_169295 (h0 : topological_space (comm_group (option (has_neg_part (cancel_monoid name))))) : discrete_topology (comm_group (option (has_neg_part (cancel_monoid name)))) := sorry --non-trivial
lemma new_lemma_169296 : nonempty (omega_complete_partial_order ereal) := sorry --non-trivial
lemma new_lemma_169297 (h0 : functor.add_const (topological_space environment.implicit_infer_kind) name) : @normal_space.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 0} (topological_space.{0} environment.implicit_infer_kind) name h0)  := sorry --non-trivial
lemma new_lemma_169298 (h0 : functor.add_const (topological_space (ring Type)) pos) : @normal_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ring.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_169299 (h0 : functor.add_const (topological_space real) name) : sequential_space real := sorry --non-trivial
lemma new_lemma_169300 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @sequential_space.{0} (has_inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (has_inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_169301 (h0 : ring (has_emptyc fun_info)) : is_domain (has_emptyc fun_info) := sorry --non-trivial
lemma new_lemma_169302 (h0 : functor.add_const (topological_space environment.implicit_infer_kind) Type) : @normal_space.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 1} (topological_space.{0} environment.implicit_infer_kind) Type h0)  := sorry --non-trivial
lemma new_lemma_169303 (h0 : topological_space (ring (option name))) : preirreducible_space (ring (option name)) := sorry --non-trivial
lemma new_lemma_169304 (h0 : not (topological_space (semiring linarith.comp_source) -> false)) : @t0_space.{0} (semiring.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (semiring.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_169305 (h0 : topological_space (semigroup Type)) : t1_space (semigroup Type) := sorry --non-trivial
lemma new_lemma_169306 (h0 : add_group (has_zero (has_add (has_neg_part Type)))) : is_add_cyclic (has_zero (has_add (has_neg_part Type))) := sorry --non-trivial
lemma new_lemma_169307 (h0 : prod (with_bot num) (with_bot num)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_169308 (h0 : topological_space (normed_group (has_union (with_bot (has_union empty))))) : t0_space (normed_group (has_union (with_bot (has_union empty)))) := sorry --non-trivial
lemma new_lemma_169309 (h0 : topological_space (canonically_ordered_comm_semiring (has_to_string Type))) : totally_separated_space (canonically_ordered_comm_semiring (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_169310 (h0 : topological_space (has_Inf (finset pos))) : t0_space (has_Inf (finset pos)) := sorry --non-trivial
lemma new_lemma_169311 (h0 : topological_space (uniform_space char)) (h1 : not (preorder (uniform_space char) -> false)) : order_topology (uniform_space char) := sorry --non-trivial
lemma new_lemma_169312 (h0 : ring (has_le (mul_one_class (mul_one_class (mul_one_class char))))) : is_domain (has_le (mul_one_class (mul_one_class (mul_one_class char)))) := sorry --non-trivial
lemma new_lemma_169313 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @complete_space.{0} (has_pos_part.{0} pos) (@matrix.vec_empty.{0} (uniform_space.{0} (has_pos_part.{0} pos)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_169314 (h1 : uniform_space (linear_ordered_add_comm_group linarith.ineq)) : complete_space (linear_ordered_add_comm_group linarith.ineq) := sorry --non-trivial
lemma new_lemma_169315 (h0 : topological_space (dlist (has_ssubset (has_ssubset (has_norm string_imp))))) : path_connected_space (dlist (has_ssubset (has_ssubset (has_norm string_imp)))) := sorry --non-trivial
lemma new_lemma_169316 (h1 : filter (has_append (comm_ring char))) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_169317 (h0 : group (topological_space (has_nnnorm (has_nnnorm char)))) : group.fg (topological_space (has_nnnorm (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_169318 (h0 : functor.add_const (uniform_space (has_add pos)) environment.implicit_infer_kind) : @complete_space.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_add.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_169319 (h0 : functor.add_const (ring (has_neg linarith.comp)) linarith.comp) : @is_principal_ideal_ring.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_neg.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_169320 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (is_R_or_C.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (is_R_or_C.{0} empty))  := sorry --non-trivial
lemma new_lemma_169321 (h0 : functor.add_const (ordered_add_comm_monoid (has_nndist unsigned)) Type) : @archimedean.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 1} (ordered_add_comm_monoid.{0} (has_nndist.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_169322 (h0 : function.extfun Type group) : @is_simple_group.{0} (has_neg.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (has_neg.{0} num))  := sorry --non-trivial
lemma new_lemma_169323 (h1 : function.extfun Type topological_space) : @path_connected_space.{0} (with_one.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (with_one.{0} num))  := sorry --non-trivial
lemma new_lemma_169324 (h0 : not (topological_space (metric_space linarith.comp) -> false)) : @normal_space.{0} (metric_space.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (metric_space.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_169325 (h0 : filter (normed_comm_ring ennreal)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_169326 (h0 : functor.add_const (topological_space (has_pos_part pos)) name) : @normal_space.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_169327 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (random_gen.{0} linarith.ineq) (@function.extfun_app.{2 1} Type monoid.{0} h0 (random_gen.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_169328 (h0 : topological_space (has_compl (random_gen (random_gen string_imp)))) : locally_compact_space (has_compl (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_169329 (h0 : fin has_zero.zero) : @unique_factorization_monoid.{0} (ordered_comm_ring.{0} pos) (@matrix.vec_empty.{0} (cancel_comm_monoid_with_zero.{0} (ordered_comm_ring.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_169330 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_add.{0} real) (@function.extfun_app.{2 1} Type group.{0} h0 (has_add.{0} real))  := sorry --non-trivial
lemma new_lemma_169331 (h0 : add_monoid (add_comm_monoid ennreal)) : add_monoid.fg (add_comm_monoid ennreal) := sorry --non-trivial
lemma new_lemma_169332 (h0 : uniform_space (normed_linear_ordered_group (semiring empty))) : complete_space (normed_linear_ordered_group (semiring empty)) := sorry --non-trivial
lemma new_lemma_169333 (h0 : topological_space (uniform_space (mul_one_class (mul_one_class enat)))) : totally_disconnected_space (uniform_space (mul_one_class (mul_one_class enat))) := sorry --non-trivial
lemma new_lemma_169334 (h0 : topological_space (add_comm_monoid unsigned)) : path_connected_space (add_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_169335 (h0 : filter (topological_space (semiring unsigned))) : @totally_disconnected_space.{0} (semiring.{0} unsigned) (@filter.Limsup.{0} (topological_space.{0} (semiring.{0} unsigned)) (@complete_lattice.to_conditionally_complete_lattice.{0} (topological_space.{0} (semiring.{0} unsigned)) (@topological_space.complete_lattice.{0} (semiring.{0} unsigned))) h0)  := sorry --non-trivial
lemma new_lemma_169336 (h0 : num -> num -> Prop) (h1 : set num) : set.unbounded h0 h1 := sorry --non-trivial
lemma new_lemma_169337 (h0 : topological_space (complete_distrib_lattice (has_pos_part linarith.comp))) : preconnected_space (complete_distrib_lattice (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_169338 (h0 : topological_space (distrib_lattice (has_top (random_gen linarith.comp_source)))) : path_connected_space (distrib_lattice (has_top (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_169339 (h0 : topological_space (normed_comm_ring (has_add (boolean_algebra.core (has_add Type))))) : preirreducible_space (normed_comm_ring (has_add (boolean_algebra.core (has_add Type)))) := sorry --non-trivial
lemma new_lemma_169340 (h0 : not (topological_space (measurable_space congr_arg_kind) -> false)) : @discrete_topology.{0} (measurable_space.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (measurable_space.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_169341 (h0 : topological_space (boolean_algebra.core unsigned)) : locally_compact_space (boolean_algebra.core unsigned) := sorry --non-trivial
lemma new_lemma_169342 (h0 : function.extfun (Type 1) (functor.comp topological_space ring)) : @normal_space.{1} (ring.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} ring.{1} Type (@function.extfun_app.{3 2} (Type 1) (functor.comp.{1 1 1} topological_space.{1} ring.{1}) h0 Type))  := sorry --non-trivial
lemma new_lemma_169343 (h0 : complete_lattice (ring (finset pos))) : is_compactly_generated (ring (finset pos)) := sorry --non-trivial
lemma new_lemma_169344 (h0 : ring (semi_normed_comm_ring (mul_one_class string.iterator_imp))) : is_domain (semi_normed_comm_ring (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_169345 (h0 : functor.add_const (semiring (add_cancel_monoid linarith.comp)) Type) : @is_noetherian_ring.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (semiring.{0} (add_cancel_monoid.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_169346 (h0 : functor.add_const (function.extfun (Type 1) group) linarith.comp) : @normalizer_condition.{1} (has_pos_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) group.{1}) linarith.comp h0) (has_pos_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_169347 (h0 : topological_space (has_zero (has_to_string environment.implicit_infer_kind))) : preirreducible_space (has_zero (has_to_string environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_169348 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @archimedean.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_add_comm_monoid.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ordered_add_comm_monoid.{1}) (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_169349 (h0 : topological_space (has_pos_part (ring (ring linarith.comp)))) : loc_path_connected_space (has_pos_part (ring (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_169350 (h0 : topological_space (has_compl (has_ssubset linarith.comp_source))) : totally_disconnected_space (has_compl (has_ssubset linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_169351 (h0 : ordered_comm_monoid (ordered_comm_monoid (has_neg (has_neg (has_neg (has_neg name)))))) : has_exists_mul_of_le (ordered_comm_monoid (has_neg (has_neg (has_neg (has_neg name))))) := sorry --non-trivial
lemma new_lemma_169352 (h0 : topological_space (measurable_space (random_gen num))) : t0_space (measurable_space (random_gen num)) := sorry --non-trivial
lemma new_lemma_169353 (h0 : ring (with_bot to_additive.value_type)) : rank_condition (with_bot to_additive.value_type) := sorry --non-trivial
lemma new_lemma_169354 (h0 : Prop -> std_gen -> Prop) (h1 : Prop) (h2 : list std_gen) : list.foldl h0 h1 h2 := sorry --non-trivial
lemma new_lemma_169355 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (with_one linarith.ineq)) := sorry --non-trivial
lemma new_lemma_169356 (h0 : group (topological_space (has_nnnorm (has_nnnorm fun_info)))) : is_cyclic (topological_space (has_nnnorm (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_169357 (h0 : not (group (topological_space reducibility_hints) -> false)) : @is_cyclic.{0} (topological_space.{0} reducibility_hints) (@classical.by_contradiction'.{1} (group.{0} (topological_space.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_169358 (h0 : list (cancel_monoid num)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_169359 (h0 : not (monoid (random_gen num) -> false)) : @monoid.fg.{0} (random_gen.{0} num) (@classical.by_contradiction'.{1} (monoid.{0} (random_gen.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_169360 (h0 : group (has_norm (has_nnnorm (random_gen (random_gen (has_top to_additive.value_type)))))) : group.fg (has_norm (has_nnnorm (random_gen (random_gen (has_top to_additive.value_type))))) := sorry --non-trivial
lemma new_lemma_169361 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (has_inter.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_inter.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_169362 (h0 : add_monoid (add_group congr_arg_kind)) : add_monoid.fg (add_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_169363 (h0 : functor.add_const (functor.add_const (topological_space name) num) congr_arg_kind) : @normal_space.{0} name (@functor.add_const.run.{0 0} (topological_space.{0} name) num (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (topological_space.{0} name) num) congr_arg_kind h0))  := sorry --non-trivial
lemma new_lemma_169364 (h0 : monoid (non_assoc_semiring (semiring congr_arg_kind))) : monoid.fg (non_assoc_semiring (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_169365 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring Type)) pos) : @preirreducible_space.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (canonically_ordered_comm_semiring.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_169366 (h0 : add_comm_semigroup (add_comm_semigroup ereal) -> add_comm_semigroup (add_comm_semigroup ereal)) (h1 : add_comm_semigroup (add_comm_semigroup ereal)) : function.is_fixed_pt h0 h1 := sorry --non-trivial
lemma new_lemma_169367 (h0 : list (has_zero name)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_169368 (h0 : topological_space (linear_ordered_semiring linarith.comp)) (h1 : has_inf (linear_ordered_semiring linarith.comp)) : has_continuous_inf (linear_ordered_semiring linarith.comp) := sorry --non-trivial
lemma new_lemma_169369 (h1 : monoid (measurable_space string_imp)) : monoid.fg (measurable_space string_imp) := sorry --non-trivial
lemma new_lemma_169370 (h0 : group (semigroup (has_Inf pos))) : is_simple_group (semigroup (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_169371 (h0 : functor.add_const (group (has_add pos)) real) : @is_simple_group.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_add.{0} pos)) real h0)  := sorry --non-trivial
lemma new_lemma_169372 (h5 : Prop) : set.finite (id (fun (h0 : ereal), h5)) := sorry --non-trivial
lemma new_lemma_169373 (h0 : functor.add_const (topological_space (has_neg_part pos)) pos) : @t1_space.{0} (has_neg_part.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_169374 (h0 : cancel_comm_monoid_with_zero (has_neg (has_add pos))) : unique_factorization_monoid (has_neg (has_add pos)) := sorry --non-trivial
lemma new_lemma_169375 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type add_group.{0} h0 (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_169376 (h0 : uniform_space (has_neg (option (option name)))) : complete_space (has_neg (option (option name))) := sorry --non-trivial
lemma new_lemma_169377 (h0 : topological_space (boolean_algebra (has_pos_part (has_neg (has_pos_part linarith.comp))))) : path_connected_space (boolean_algebra (has_pos_part (has_neg (has_pos_part linarith.comp)))) := sorry --non-trivial
lemma new_lemma_169378 (h0 : group (mul_zero_class (has_neg_part ennreal))) : is_simple_group (mul_zero_class (has_neg_part ennreal)) := sorry --non-trivial
lemma new_lemma_169379 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (monoid_with_zero.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (monoid_with_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_169380 (h0 : functor.add_const (complete_lattice (finset Type)) environment.implicit_infer_kind) : @is_atomistic.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (finset.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_169381 (h0 : topological_space (has_edist (semiring empty))) : normal_space (has_edist (semiring empty)) := sorry --non-trivial
lemma new_lemma_169382 (h0 : functor.comp topological_space finset pos) : @discrete_topology.{0} (finset.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} finset.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_169383 (h0 : semiring (linear_ordered_comm_ring (semiring congr_arg_kind))) : is_noetherian_ring (linear_ordered_comm_ring (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_169384 (h0 : ordered_comm_monoid (generalized_boolean_algebra (has_nndist Type))) : has_exists_mul_of_le (generalized_boolean_algebra (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_169385 (h0 : ring (has_top (boolean_algebra.core linarith.comp_source))) : strong_rank_condition (has_top (boolean_algebra.core linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_169386 (h0 : not (add_group (add_right_cancel_monoid congr_arg_kind) -> false)) : @is_add_cyclic.{0} (add_right_cancel_monoid.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (add_group.{0} (add_right_cancel_monoid.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_169387 (h0 : topological_space (mul_zero_class (finset Type))) : preconnected_space (mul_zero_class (finset Type)) := sorry --non-trivial
lemma new_lemma_169388 (h0 : group (ordered_comm_monoid (ring linarith.comp))) : is_cyclic (ordered_comm_monoid (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_169389 (h0 : group (normed_group (has_top (has_inv fun_info)))) : normalizer_condition (normed_group (has_top (has_inv fun_info))) := sorry --non-trivial
lemma new_lemma_169390 (h0 : ring (canonically_ordered_monoid ennreal)) : strong_rank_condition (canonically_ordered_monoid ennreal) := sorry --non-trivial
lemma new_lemma_169391 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (with_bot.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (with_bot.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_169392 (h0 : complete_lattice (metric_space (semiring unsigned))) : is_atomistic (metric_space (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_169393 (h0 : monoid (is_R_or_C empty)) : monoid.fg (is_R_or_C empty) := sorry --non-trivial
lemma new_lemma_169394 (h0 : not (semiring (add_group unsigned) -> false)) : @is_noetherian_ring.{0} (add_group.{0} unsigned) (@classical.by_contradiction'.{1} (semiring.{0} (add_group.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_169395 (h0 : topological_space (normed_linear_ordered_group (option unsigned))) : totally_separated_space (normed_linear_ordered_group (option unsigned)) := sorry --non-trivial
lemma new_lemma_169396 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @is_noetherian_ring.{1} (has_add.{1} Type) (@matrix.vec_empty.{1} (semiring.{1} (has_add.{1} Type)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_169397 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_norm.{0} (comm_ring.{0} to_additive.value_type)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_norm.{0} (comm_ring.{0} to_additive.value_type)))  := sorry --non-trivial
lemma new_lemma_169398 (h0 : function.extfun Type topological_space) : @normal_space.{0} auto.case_option (@function.extfun_app.{2 1} Type topological_space.{0} h0 auto.case_option)  := sorry --non-trivial
lemma new_lemma_169399 (h0 : group (has_neg (finset (has_add (has_add name))))) : group.fg (has_neg (finset (has_add (has_add name)))) := sorry --non-trivial
lemma new_lemma_169400 (h0 : list (encodable (with_one to_additive.value_type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_169401 (h0 : function.extfun Type ring) : @is_domain.{0} (metric_space.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (metric_space.{0} num))  := sorry --non-trivial
lemma new_lemma_169402 (h0 : not (has_mem.mem (with_bot linarith.ineq) has_emptyc.emptyc -> false)) : @t0_space.{0} (with_bot.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_bot.{0} linarith.ineq) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_bot.{0} linarith.ineq) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_169403 (h0 : functor.add_const (group (has_neg_part environment.implicit_infer_kind)) linarith.comp) : @group.fg.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (has_neg_part.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_169404 (h0 : topological_space (random_gen (has_ssubset reducibility_hints))) : t0_space (random_gen (has_ssubset reducibility_hints)) := sorry --non-trivial
lemma new_lemma_169405 (h0 : topological_space (has_div string_imp)) : path_connected_space (has_div string_imp) := sorry --non-trivial
lemma new_lemma_169406 (h0 h1 : multiset (semi_normed_comm_ring to_additive.value_type)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_169407 (h0 : group (semigroup (has_neg linarith.comp))) : group.fg (semigroup (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_169408 (h0 : topological_space (normed_group (semiring (has_top (semiring unsigned))))) : locally_compact_space (normed_group (semiring (has_top (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_169409 (h2 : topological_space (has_compl (has_ssubset char))) : t0_space (has_compl (has_ssubset char)) := sorry --non-trivial
lemma new_lemma_169410 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} (has_emptyc.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (has_emptyc.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_169411 (h0 : ring (has_to_string (option empty))) : is_principal_ideal_ring (has_to_string (option empty)) := sorry --non-trivial
lemma new_lemma_169412 (h0 : functor.add_const (complete_lattice (add_cancel_monoid name)) pos) : @complete_lattice.is_Sup_finite_compact.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_cancel_monoid.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_169413 (h0 : function.extfun Type group) : @group.fg.{0} (has_neg.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} h0 (has_neg.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_169414 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @regular_space.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_169415 (h0 : ring (metric_space congr_arg_kind)) : rank_condition (metric_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_169416 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (simple_graph linarith.comp)) := sorry --non-trivial
lemma new_lemma_169417 (h0 : topological_space (cancel_monoid (canonically_linear_ordered_monoid name))) : path_connected_space (cancel_monoid (canonically_linear_ordered_monoid name)) := sorry --non-trivial
lemma new_lemma_169418 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (distrib_lattice.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (distrib_lattice.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_169419 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (add_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_169420 (h0 : add_group (normed_lattice_add_comm_group (has_Inf real))) : is_add_cyclic (normed_lattice_add_comm_group (has_Inf real)) := sorry --non-trivial
lemma new_lemma_169421 (h0 : filter (has_Inf (boolean_algebra.core (has_add Type)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_169422 (h0 : group (ordered_comm_monoid (has_nndist Type))) : group.fg (ordered_comm_monoid (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_169423 (h0 : topological_space (has_to_string (has_neg (has_neg name)))) : sequential_space (has_to_string (has_neg (has_neg name))) := sorry --non-trivial
lemma new_lemma_169424 (h0 : ring (ordered_comm_monoid (has_Inf (has_add Type)))) : is_domain (ordered_comm_monoid (has_Inf (has_add Type))) := sorry --non-trivial
lemma new_lemma_169425 (h0 : topological_space (has_pos_part (has_add (has_neg name)))) : irreducible_space (has_pos_part (has_add (has_neg name))) := sorry --non-trivial
lemma new_lemma_169426 (h0 : functor.add_const (function.extfun Type topological_space) environment.implicit_infer_kind) : @t0_space.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) environment.implicit_infer_kind h0) (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_169427 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (linear_ordered_cancel_comm_monoid empty)) := sorry --non-trivial
lemma new_lemma_169428 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_add.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_add.{0} name))  := sorry --non-trivial
lemma new_lemma_169429 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} auto.case_option (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) auto.case_option)  := sorry --non-trivial
lemma new_lemma_169430 (h0 : function.extfun Type topological_space) : @t1_space.{0} (monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_169431 (h0 : topological_space (boolean_algebra unsigned)) : t1_space (boolean_algebra unsigned) := sorry --non-trivial
lemma new_lemma_169432 (h0 : topological_space (left_cancel_semigroup num)) : locally_compact_space (left_cancel_semigroup num) := sorry --non-trivial
lemma new_lemma_169433 (h0 : monoid (has_zero Type)) : monoid.fg (has_zero Type) := sorry --non-trivial
lemma new_lemma_169434 (h0 : functor.add_const (topological_space (has_zero Type)) name) : @locally_compact_space.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_zero.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_169435 (h0 : add_group (normed_group linarith.comp_source)) : is_add_cyclic (normed_group linarith.comp_source) := sorry --non-trivial
lemma new_lemma_169436 (h0 : functor.add_const (ring pos) unsigned) : @is_domain.{0} pos (@functor.add_const.run.{0 0} (ring.{0} pos) unsigned h0)  := sorry --non-trivial
lemma new_lemma_169437 (h0 : functor.add_const (uniform_space (has_Inf pos)) pos) : @complete_space.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_Inf.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_169438 (h0 : functor.add_const (finset (has_to_string Type)) pos) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_169439 (h0 : list (linear_ordered_add_comm_group to_additive.value_type)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_169440 (h0 : topological_space (has_sub (semiring empty))) : locally_compact_space (has_sub (semiring empty)) := sorry --non-trivial
lemma new_lemma_169441 (h0 : add_group (ordered_comm_ring Type)) : is_add_cyclic (ordered_comm_ring Type) := sorry --non-trivial
lemma new_lemma_169442 (h0 : add_group (distrib (random_gen fun_info))) : is_add_cyclic (distrib (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_169443 (h0 : group (with_one (random_gen to_additive.value_type))) : group.fg (with_one (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_169444 (h0 : topological_space (mul_zero_class (has_add (has_neg unsigned)))) : sequential_space (mul_zero_class (has_add (has_neg unsigned))) := sorry --non-trivial
lemma new_lemma_169445 (h0 : not (ring (add_semigroup string_imp) -> false)) : @is_domain.{0} (add_semigroup.{0} string_imp) (@classical.by_contradiction'.{1} (ring.{0} (add_semigroup.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_169446 (h0 : functor.add_const (group (boolean_algebra linarith.comp)) name) : @is_simple_group.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_169447 (h0 : function.extfun (Type 1) filter) : countable_Inter_filter (function.extfun_app h0 (finset Type)) := sorry --non-trivial
lemma new_lemma_169448 (h0 : has_mem.mem (semiring num) has_emptyc.emptyc) : @is_atomistic.{0} (semiring.{0} num) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_169449 (h0 : topological_space (has_neg_part (has_to_string unsigned))) : regular_space (has_neg_part (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_169450 (h0 : topological_space (ordered_comm_ring real)) : preirreducible_space (ordered_comm_ring real) := sorry --non-trivial
lemma new_lemma_169451 (h0 : add_monoid (monoid unsigned)) : add_monoid.fg (monoid unsigned) := sorry --non-trivial
lemma new_lemma_169452 (h0 : list (has_zero (finset (finset pos)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_169453 (h0 : random_gen linarith.comp -> linarith.comp -> Prop) : relator.right_unique h0 := sorry --non-trivial
lemma new_lemma_169454 (h1 : not (add_group (non_unital_non_assoc_semiring string_imp) -> false)) : @is_add_cyclic.{0} (non_unital_non_assoc_semiring.{0} string_imp) (@classical.by_contradiction'.{1} (add_group.{0} (non_unital_non_assoc_semiring.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_169455 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (with_bot.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} empty)))))) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_bot.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} empty)))))))  := sorry --non-trivial
lemma new_lemma_169456 (h0 : filter (comm_group (has_add (has_to_string (comm_group unsigned))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_169457 (h0 : functor.comp ring normed_field linarith.comp_source) : @rank_condition.{0} (normed_field.{0} linarith.comp_source) (@functor.comp.run.{0 0 0} ring.{0} normed_field.{0} linarith.comp_source h0)  := sorry --non-trivial
lemma new_lemma_169458 (h0 : finset (linear_ordered_field congr_arg_kind)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_169459 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (ordered_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (ordered_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_169460 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (omega_complete_partial_order.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (omega_complete_partial_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_169461 (h1 : set (fun_info -> fun_info)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_169462 (h0 : topological_space (has_Inf (ring (has_Inf (has_add linarith.comp))))) : preconnected_space (has_Inf (ring (has_Inf (has_add linarith.comp)))) := sorry --non-trivial
lemma new_lemma_169463 (h0 : ordered_add_comm_monoid (has_to_string (ring linarith.comp))) : archimedean (has_to_string (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_169464 (h0 : functor.comp ring cancel_monoid Type) : @is_principal_ideal_ring.{1} (cancel_monoid.{1} Type) (@functor.comp.run.{1 1 1} ring.{1} cancel_monoid.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_169465 (h0 : semiring (comm_semigroup (sub_neg_monoid (sub_neg_monoid Type)))) : is_noetherian_ring (comm_semigroup (sub_neg_monoid (sub_neg_monoid Type))) := sorry --non-trivial
lemma new_lemma_169466 (h0 : topological_space (add_cancel_monoid (has_add Type))) : preirreducible_space (add_cancel_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_169467 (h0 : uniform_space (boolean_algebra.core (ring (ring (ring pos))))) : separated_space (boolean_algebra.core (ring (ring (ring pos)))) := sorry --non-trivial
lemma new_lemma_169468 (h0 : topological_space (measurable_space empty)) : preirreducible_space (measurable_space empty) := sorry --non-trivial
lemma new_lemma_169469 (h0 : has_mem.mem (random_gen congr_arg_kind) has_emptyc.emptyc) : @discrete_topology.{0} (random_gen.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (random_gen.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_169470 (h0 : ring (semiring (semiring num))) : rank_condition (semiring (semiring num)) := sorry --non-trivial
lemma new_lemma_169471 (h0 : topological_space (has_nndist (boolean_algebra (boolean_algebra environment.implicit_infer_kind)))) : discrete_topology (has_nndist (boolean_algebra (boolean_algebra environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_169472 (h0 : uniform_space (has_div (mul_one_class (has_nnnorm enat)))) : complete_space (has_div (mul_one_class (has_nnnorm enat))) := sorry --non-trivial
lemma new_lemma_169473 (h0 : add_group (pseudo_emetric_space (random_gen char))) : is_add_cyclic (pseudo_emetric_space (random_gen char)) := sorry --non-trivial
lemma new_lemma_169474 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (complete_distrib_lattice.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} pos))  := sorry --non-trivial
lemma new_lemma_169475 (h0 : functor.add_const (topological_space (has_neg linarith.comp)) pos) : @preconnected_space.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_169476 (h1 : function.extfun (finset (Type -> Type)) (has_mem.mem ring)) : @rank_condition.{0} (measurable_space.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) ring.{0}) h1 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (measurable_space.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_169477 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (has_to_string.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_to_string.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_169478 (h1 : function.extfun Type complete_lattice) : @is_atomistic.{0} (@id.{2} Type linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} h1 (@id.{2} Type linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_169479 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_bot.{0} (ordered_comm_group.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_bot.{0} (ordered_comm_group.{0} empty)))  := sorry --non-trivial
lemma new_lemma_169480 (h0 : topological_space (has_Inf (has_neg name))) : irreducible_space (has_Inf (has_neg name)) := sorry --non-trivial
lemma new_lemma_169481 (h0 : functor.add_const (ring (has_nndist linarith.comp)) linarith.comp) : @rank_condition.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_nndist.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_169482 (h0 : uniform_space (linear_ordered_comm_group_with_zero (mul_one_class reducibility_hints))) : complete_space (linear_ordered_comm_group_with_zero (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_169483 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (mul_zero_class.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (mul_zero_class.{0} num))  := sorry --non-trivial
lemma new_lemma_169484 (h0 : functor.add_const (add_group (complete_distrib_lattice name)) Type) : @is_add_cyclic.{0} (complete_distrib_lattice.{0} name) (@functor.add_const.run.{0 1} (add_group.{0} (complete_distrib_lattice.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_169485 (h0 : complete_lattice (dlist fun_info)) : is_compactly_generated (dlist fun_info) := sorry --non-trivial
lemma new_lemma_169486 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (linear_ordered_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (linear_ordered_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_169487 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_169488 (h0 : functor.add_const (topological_space (sub_neg_monoid pos)) linarith.comp) : @normal_space.{0} (sub_neg_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (sub_neg_monoid.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_169489 (h0 : ring (has_compl std_gen)) : is_domain (has_compl std_gen) := sorry --non-trivial
lemma new_lemma_169490 (h0 : fin has_zero.zero) : @preconnected_space.{0} (complete_distrib_lattice.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (complete_distrib_lattice.{0} pos))  := sorry --non-trivial
lemma new_lemma_169491 (h0 : add_group (with_bot (random_gen (random_gen (random_gen linarith.ineq))))) : is_add_cyclic (with_bot (random_gen (random_gen (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_169492 (h0 : not (topological_space (uniform_space (mul_one_class string.iterator_imp)) -> false)) : @totally_disconnected_space.{0} (uniform_space.{0} (mul_one_class.{0} string.iterator_imp)) (@classical.by_contradiction'.{1} (topological_space.{0} (uniform_space.{0} (mul_one_class.{0} string.iterator_imp))) h0)  := sorry --non-trivial
lemma new_lemma_169493 (h0 : complete_lattice (has_add (has_add (has_add pos)))) : is_compactly_generated (has_add (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_169494 (h1 : topological_space (has_compl std_gen)) (h2 : add_group (has_compl std_gen)) : topological_add_group (has_compl std_gen) := sorry --non-trivial
lemma new_lemma_169495 (h0 : functor.add_const (ring (finset environment.implicit_infer_kind)) environment.implicit_infer_kind) : @is_principal_ideal_ring.{0} (finset.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (finset.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_169496 (h0 : fin has_zero.zero) : @sequential_space.{0} (has_bot.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (has_bot.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_169497 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_169498 (h0 : not (ring (normed_field to_additive.value_type) -> false)) : @rank_condition.{0} (normed_field.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (normed_field.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_169499 (h0 : ring (linear_ordered_semiring (semiring congr_arg_kind))) : is_domain (linear_ordered_semiring (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_169500 (h0 : group (has_pos_part (ordered_ring pos))) : is_cyclic (has_pos_part (ordered_ring pos)) := sorry --non-trivial
lemma new_lemma_169501 (h0 : list (ordered_comm_monoid (has_add (has_add pos)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_169502 (h0 : finset (comm_group pos)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_169503 (h0 : group (boolean_algebra.core (has_add pos))) : group.fg (boolean_algebra.core (has_add pos)) := sorry --non-trivial
lemma new_lemma_169504 (h0 : function.extfun Type topological_space) : @t1_space.{0} (add_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_169505 (h0 : add_group (add_left_cancel_semigroup empty)) : is_add_cyclic (add_left_cancel_semigroup empty) := sorry --non-trivial
lemma new_lemma_169506 (h0 : functor.add_const (function.extfun (Type 1) group) environment.implicit_infer_kind) : @is_simple_group.{1} (comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) group.{1}) environment.implicit_infer_kind h0) (comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_169507 (h0 : functor.add_const (uniform_space (has_to_string Type)) Type) : @separated_space.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 1} (uniform_space.{1} (has_to_string.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_169508 (h0 : list (generalized_boolean_algebra (has_add name))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_169509 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @totally_disconnected_space.{0} (with_one.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (with_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_169510 (h0 : functor.add_const (group (boolean_algebra name)) Type) : @is_cyclic.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 1} (group.{0} (boolean_algebra.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_169511 (h0 : monoid (semigroup empty)) : monoid.fg (semigroup empty) := sorry --non-trivial
lemma new_lemma_169512 (h0 : function.extfun Type (functor.add_const (monoid (simple_graph linarith.comp)))) : @monoid.fg.{0} (simple_graph.{0} linarith.comp) (@functor.add_const.run.{0 0} (monoid.{0} (simple_graph.{0} linarith.comp)) linarith.comp (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (monoid.{0} (simple_graph.{0} linarith.comp))) h0 linarith.comp))  := sorry --non-trivial
lemma new_lemma_169513 (h0 : functor.add_const (complete_lattice (has_neg unsigned)) (boolean_algebra name)) : @is_compactly_generated.{0} (has_neg.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_neg.{0} unsigned)) (boolean_algebra.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_169514 (h0 : group (add_cancel_monoid (ring environment.implicit_infer_kind))) : group.fg (add_cancel_monoid (ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_169515 (h0 : ordered_comm_monoid (boolean_algebra linarith.comp)) : has_exists_mul_of_le (boolean_algebra linarith.comp) := sorry --non-trivial
lemma new_lemma_169516 (h0 : topological_space (add_right_cancel_monoid (semiring (semiring unsigned)))) : discrete_topology (add_right_cancel_monoid (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_169517 (h0 : group (encodable (has_nnnorm linarith.ineq))) : group.fg (encodable (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_169518 (h0 : topological_space (normed_field string.iterator_imp)) (h1 : preorder (normed_field string.iterator_imp)) : order_closed_topology (normed_field string.iterator_imp) := sorry --non-trivial
lemma new_lemma_169519 (h1 : complete_lattice (with_zero linarith.comp_source)) : complete_lattice.is_Sup_finite_compact (with_zero linarith.comp_source) := sorry --non-trivial
lemma new_lemma_169520 (h0 : set (set (random_gen (random_gen string_imp)))) : is_countably_spanning h0 := sorry --non-trivial
lemma new_lemma_169521 (h0 : functor.add_const (topological_space (complete_linear_order unsigned)) empty) : @t0_space.{0} (complete_linear_order.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_linear_order.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_169522 (h0 : ring (semiring num)) : rank_condition (semiring num) := sorry --non-trivial
lemma new_lemma_169523 (h0 : list (complete_linear_order (semiring empty))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_169524 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (semi_normed_comm_ring.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (semi_normed_comm_ring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_169525 (h0 : cancel_comm_monoid_with_zero (has_Inf (finset linarith.comp))) : unique_factorization_monoid (has_Inf (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_169526 (h0 : functor.add_const (topological_space (mul_zero_class num)) (semiring (semiring congr_arg_kind))) : @t0_space.{0} (mul_zero_class.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} num)) (semiring.{0} (semiring.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_169527 (h0 : topological_space (sub_neg_monoid (has_Inf (finset pos)))) : sequential_space (sub_neg_monoid (has_Inf (finset pos))) := sorry --non-trivial
lemma new_lemma_169528 (h0 : topological_space (complete_distrib_lattice (finset ennreal))) : preirreducible_space (complete_distrib_lattice (finset ennreal)) := sorry --non-trivial
lemma new_lemma_169529 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (comm_semigroup.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_semigroup.{0} real))  := sorry --non-trivial
lemma new_lemma_169530 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @separated_space.{1} (canonically_ordered_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 uniform_space.{1}) (canonically_ordered_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_169531 (h0 : topological_space (add_cancel_monoid unsigned)) : sequential_space (add_cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_169532 (h0 : cancel_comm_monoid_with_zero (preorder num)) : unique_factorization_monoid (preorder num) := sorry --non-trivial
lemma new_lemma_169533 (h0 : topological_space (filter congr_arg_kind)) : totally_disconnected_space (filter congr_arg_kind) := sorry --non-trivial
lemma new_lemma_169534 (h1 : has_mem.mem (denumerable (random_gen (has_nnnorm fun_info))) has_zero.zero) : @path_connected_space.{0} (denumerable.{0} (random_gen.{0} (has_nnnorm.{0} fun_info))) (@multiset.pi.empty.{1 0} Type topological_space.{0} (denumerable.{0} (random_gen.{0} (has_nnnorm.{0} fun_info))) h1)  := sorry --non-trivial
lemma new_lemma_169535 (h0 : function.extfun Type group) : @is_cyclic.{0} (ordered_comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (ordered_comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_169536 (h0 : functor.comp (functor.comp topological_space boolean_algebra.core) with_top nnreal) : @preirreducible_space.{0} (boolean_algebra.core.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} boolean_algebra.core.{0} ennreal (@functor.comp.run.{0 0 0} (functor.comp.{0 0 0} topological_space.{0} boolean_algebra.core.{0}) with_top.{0} nnreal h0))  := sorry --non-trivial
lemma new_lemma_169537 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (finset.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (finset.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_169538 (h0 : uniform_space (canonically_ordered_comm_semiring ennreal)) : separated_space (canonically_ordered_comm_semiring ennreal) := sorry --non-trivial
lemma new_lemma_169539 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} (partial_order.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (partial_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_169540 (h0 : add_comm_monoid (has_zero ennreal) -> add_comm_monoid (has_zero ennreal) -> Prop) : is_symm (add_comm_monoid (has_zero ennreal)) h0 := sorry --non-trivial
lemma new_lemma_169541 (h0 : topological_space (add_cancel_monoid (has_neg Type))) : locally_compact_space (add_cancel_monoid (has_neg Type)) := sorry --non-trivial
lemma new_lemma_169542 (h0 : ring (normed_comm_ring (has_add linarith.comp))) : is_principal_ideal_ring (normed_comm_ring (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_169543 (h0 : fin has_zero.zero) : @is_cyclic.{1} (has_Inf.{1} Type) (@matrix.vec_empty.{1} (group.{1} (has_Inf.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_169544 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (normed_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_169545 (h1 : function.extfun Type multiset) (h2 : multiset (has_norm linarith.comp_source)) : multiset.subset (function.extfun_app h1 (has_norm linarith.comp_source)) h2 := sorry --non-trivial
lemma new_lemma_169546 (h0 : function.extfun Type group) : @group.fg.{0} (random_gen.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} h0 (random_gen.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_169547 (h0 : complete_lattice (add_group (semiring linarith.comp))) : is_atomistic (add_group (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_169548 (h0 : filter (has_ssubset (has_ssubset linarith.comp_source))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_169549 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (bin_tree.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (bin_tree.{0} num))  := sorry --non-trivial
lemma new_lemma_169550 (h0 : ordered_add_comm_monoid (add_comm_monoid (has_neg pos))) : archimedean (add_comm_monoid (has_neg pos)) := sorry --non-trivial
lemma new_lemma_169551 (h0 : group (has_add unsigned)) : group.fg (has_add unsigned) := sorry --non-trivial
lemma new_lemma_169552 (h0 : topological_space (semigroup (semigroup (has_add linarith.comp)))) : regular_space (semigroup (semigroup (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_169553 (h0 : group (preorder (semiring (semiring (semiring (semiring empty)))))) : group.fg (preorder (semiring (semiring (semiring (semiring empty))))) := sorry --non-trivial
lemma new_lemma_169554 (h0 : not (function.extfun Type add_monoid -> false)) : @add_monoid.fg.{0} (has_norm.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_monoid.{0}) h0) (has_norm.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_169555 (h0 : not (complete_lattice (denumerable to_additive.value_type) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (denumerable.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (complete_lattice.{0} (denumerable.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_169556 (h0 : ordered_add_comm_monoid (boolean_algebra (ring Type))) : archimedean (boolean_algebra (ring Type)) := sorry --non-trivial
lemma new_lemma_169557 (h0 : has_mem.mem (normed_group num) has_emptyc.emptyc) : @discrete_topology.{0} (normed_group.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (normed_group.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_169558 (h1 : topological_space (has_emptyc congr_arg_kind)) : path_connected_space (has_emptyc congr_arg_kind) := sorry --non-trivial
lemma new_lemma_169559 (h0 : ordered_add_comm_monoid (normed_lattice_add_comm_group (has_Inf name))) : archimedean (normed_lattice_add_comm_group (has_Inf name)) := sorry --non-trivial
lemma new_lemma_169560 (h0 : functor.add_const (ordered_comm_monoid (add_comm_monoid environment.implicit_infer_kind)) (comm_group name)) : @has_exists_mul_of_le.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (add_comm_monoid.{0} environment.implicit_infer_kind)) (comm_group.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_169561 (h0 : measurable_space enat) (h1 : has_sub enat) : has_measurable_sub₂ enat := sorry --non-trivial
lemma new_lemma_169562 (h0 : function.extfun Type ring) : @rank_condition.{0} (complete_semilattice_Sup.{0} linarith.ineq) (@function.extfun_app.{2 1} Type ring.{0} h0 (complete_semilattice_Sup.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_169563 (h0 : complete_lattice (has_edist unsigned)) : is_atomistic (has_edist unsigned) := sorry --non-trivial
lemma new_lemma_169564 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (comm_ring.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (comm_ring.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_169565 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (canonically_linear_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (canonically_linear_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_169566 (h0 : not (has_mem.mem linarith.comp_source has_emptyc.emptyc -> false)) : @complete_lattice.is_Sup_finite_compact.{0} linarith.comp_source (@finset.pi.empty.{1 0} Type complete_lattice.{0} linarith.comp_source (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) linarith.comp_source (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_169567 (h0 : topological_space (has_nndist (has_neg_part Type))) : irreducible_space (has_nndist (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_169568 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @group.fg.{0} (has_top.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) group.{0}) (has_top.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_169569 (h0 : topological_space (has_zero (finset (cancel_monoid ennreal)))) : irreducible_space (has_zero (finset (cancel_monoid ennreal))) := sorry --non-trivial
lemma new_lemma_169570 (h0 : ring (uniform_space (list (has_inter (random_gen linarith.comp_source))))) : is_domain (uniform_space (list (has_inter (random_gen linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_169571 (h0 : filter (canonically_linear_ordered_monoid name)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_169572 (h0 : functor.add_const (list (boolean_algebra.core Type)) pos) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_169573 (h0 : finset (complete_linear_order unsigned)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_169574 (h0 : function.extfun (Type 1) add_monoid) : @add_monoid.fg.{1} (@id.{3} (Type 1) Type) (@function.extfun_app.{3 2} (Type 1) add_monoid.{1} h0 (@id.{3} (Type 1) Type))  := sorry --non-trivial
lemma new_lemma_169575 (h0 : functor.add_const (topological_space Type) pos) : @totally_separated_space.{1} Type (@functor.add_const.run.{1 0} (topological_space.{1} Type) pos h0)  := sorry --non-trivial
lemma new_lemma_169576 (h0 : function.extfun Type (functor.add_const (ordered_add_comm_monoid (preorder num)))) : @archimedean.{0} (preorder.{0} num) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (preorder.{0} num)) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ordered_add_comm_monoid.{0} (preorder.{0} num))) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_169577 (h0 : topological_space reducibility_hints) (h1 : set reducibility_hints) : is_path_connected h1 := sorry --non-trivial
lemma new_lemma_169578 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (normed_comm_ring.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (normed_comm_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_169579 (h0 : complete_lattice (add_left_cancel_semigroup congr_arg_kind)) : complete_lattice.is_Sup_finite_compact (add_left_cancel_semigroup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_169580 (h0 : group (complete_distrib_lattice (has_add pos))) : is_simple_group (complete_distrib_lattice (has_add pos)) := sorry --non-trivial
lemma new_lemma_169581 (h0 : group (distrib_lattice (random_gen (random_gen char)))) : group.fg (distrib_lattice (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_169582 (h0 : functor.add_const (function.extfun Type group) name) : @normalizer_condition.{0} (finset.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) name h0) (finset.{0} name))  := sorry --non-trivial
lemma new_lemma_169583 (h0 : add_monoid (has_zero (has_to_string Type))) : add_monoid.fg (has_zero (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_169584 (h1 : not (ring (comm_ring char) -> false)) : @strong_rank_condition.{0} (comm_ring.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (comm_ring.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_169585 (h0 : topological_space (semiring unsigned)) : preirreducible_space (semiring unsigned) := sorry --non-trivial
lemma new_lemma_169586 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (has_bot.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_bot.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_169587 (h0 : finset (finset (option (option (option (option (option unsigned))))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_169588 (h0 : functor.add_const (topological_space (normed_linear_ordered_group unsigned)) empty) : @loc_path_connected_space.{0} (normed_linear_ordered_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_linear_ordered_group.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_169589 (h0 : complete_lattice (has_append (has_nnnorm char))) : is_compactly_generated (has_append (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_169590 (h1 : complete_lattice linarith.comp_source) : complete_lattice.is_Sup_finite_compact linarith.comp_source := sorry --non-trivial
lemma new_lemma_169591 (h0 : functor.add_const (group (has_nndist Type)) (finset pos)) : @group.fg.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (has_nndist.{1} Type)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_169592 (h1 : ring (complete_semilattice_Sup (random_gen string_imp))) : rank_condition (complete_semilattice_Sup (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_169593 (h0 : add_group (div_inv_monoid to_additive.value_type)) : is_add_cyclic (div_inv_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_169594 (h0 : functor.add_const (group (boolean_algebra pos)) pos) : @normalizer_condition.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_169595 (h0 : functor.add_const (topological_space (has_neg pos)) (has_neg Type)) : @preirreducible_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg.{0} pos)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_169596 (h1 : topological_space (has_neg_part (add_comm_semigroup environment.projection_info))) : t0_space (has_neg_part (add_comm_semigroup environment.projection_info)) := sorry --non-trivial
lemma new_lemma_169597 (h0 : function.extfun Type topological_space) : @regular_space.{0} (has_add.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_169598 (h0 : not (function.extfun Type group -> false)) : @normalizer_condition.{0} (complete_semilattice_Sup.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (complete_semilattice_Sup.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_169599 (h0 : function.extfun Type (functor.add_const (topological_space (ring Type)))) : @locally_compact_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ring.{1} Type)) pos (@function.extfun_app.{2 2} Type (functor.add_const.{1 0} (topological_space.{1} (ring.{1} Type))) h0 pos))  := sorry --non-trivial
lemma new_lemma_169600 (h0 : functor.add_const (function.extfun Type ring) pos) : @is_domain.{0} (add_cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) pos h0) (add_cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_169601 (h0 : uniform_space (ordered_comm_monoid (has_add (ordered_comm_monoid (ordered_comm_monoid pos))))) : separated_space (ordered_comm_monoid (has_add (ordered_comm_monoid (ordered_comm_monoid pos)))) := sorry --non-trivial
lemma new_lemma_169602 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (has_emptyc.{0} (random_gen.{0} linarith.ineq)) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_emptyc.{0} (random_gen.{0} linarith.ineq)))  := sorry --non-trivial
lemma new_lemma_169603 (h0 : topological_space (ordered_comm_group (option (option (option (option unsigned)))))) : irreducible_space (ordered_comm_group (option (option (option (option unsigned))))) := sorry --non-trivial
lemma new_lemma_169604 (h0 : filter (ring (has_pos_part pos))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_169605 (h0 : ordered_comm_monoid (ordered_comm_monoid (has_add (has_add pos)))) : has_exists_mul_of_le (ordered_comm_monoid (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_169606 (h0 : functor.add_const (list (has_zero name)) (semigroup name)) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_169607 (h0 : not (topological_space (uniform_space linarith.ineq) -> false)) : @totally_disconnected_space.{0} (uniform_space.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (uniform_space.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_169608 (h0 : group (normed_field to_additive.value_type)) : is_cyclic (normed_field to_additive.value_type) := sorry --non-trivial
lemma new_lemma_169609 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (has_inter.{0} ennreal) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (has_inter.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_169610 (h0 : monoid (has_nndist (comm_monoid unsigned))) : monoid.fg (has_nndist (comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_169611 (h0 : list (complete_linear_order (semiring unsigned))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_169612 (h0 : topological_space (ordered_ring (partial_order unsigned))) : discrete_topology (ordered_ring (partial_order unsigned)) := sorry --non-trivial
lemma new_lemma_169613 (h0 : has_mem.mem complete_lattice has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} (random_gen.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} h0) (random_gen.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_169614 (h0 : functor.add_const (topological_space (cancel_monoid pos)) pos) : @totally_separated_space.{0} (cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_169615 (h0 : functor.add_const (topological_space (left_cancel_monoid unsigned)) (semiring (semiring num))) : @t1_space.{0} (left_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} unsigned)) (semiring.{0} (semiring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_169616 (h0 : ordered_comm_monoid (semigroup (boolean_algebra Type))) : has_exists_mul_of_le (semigroup (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_169617 (h0 : has_mul (add_comm_monoid name)) (h1 : add_comm_monoid name) : is_right_regular h1 := sorry --non-trivial
lemma new_lemma_169618 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_169619 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_169620 (h0 : functor.add_const (topological_space (add_comm_monoid linarith.comp)) (finset (finset pos))) : @locally_compact_space.{0} (add_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} linarith.comp)) (finset.{0} (finset.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_169621 (h0 : not (uniform_space (has_top fun_info) -> false)) : @complete_space.{0} (has_top.{0} fun_info) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_top.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_169622 (h0 : functor.add_const (topological_space (pseudo_metric_space ennreal)) pos) : @preconnected_space.{0} (pseudo_metric_space.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (pseudo_metric_space.{0} ennreal)) pos h0)  := sorry --non-trivial
lemma new_lemma_169623 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (linear_ordered_comm_group.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_group.{0} num))  := sorry --non-trivial
lemma new_lemma_169624 (h0 : function.extfun Type topological_space) : @t1_space.{0} (option.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (option.{0} num))  := sorry --non-trivial
lemma new_lemma_169625 (h0 : topological_space (simple_graph (add_comm_semigroup environment.projection_info))) : totally_disconnected_space (simple_graph (add_comm_semigroup environment.projection_info)) := sorry --non-trivial
lemma new_lemma_169626 (h0 : add_group (ordered_comm_group empty)) : is_add_cyclic (ordered_comm_group empty) := sorry --non-trivial
lemma new_lemma_169627 (h0 : functor.add_const (ring (add_cancel_monoid linarith.comp)) pos) : @is_domain.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (add_cancel_monoid.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_169628 (h0 : topological_space (semigroup (has_add environment.implicit_infer_kind))) : regular_space (semigroup (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_169629 (h0 : topological_space (boolean_algebra.core Type)) : sequential_space (boolean_algebra.core Type) := sorry --non-trivial
lemma new_lemma_169630 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (measurable_space.dynkin_system.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (measurable_space.dynkin_system.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_169631 (h0 : functor.add_const (function.extfun (Type 1) group) (has_neg linarith.comp)) : @is_cyclic.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) group.{1}) (has_neg.{0} linarith.comp) h0) (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_169632 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (linear_ordered_add_comm_group.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_add_comm_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_169633 (h0 : ring (lattice empty)) : is_principal_ideal_ring (lattice empty) := sorry --non-trivial
lemma new_lemma_169634 (h0 : functor.add_const (topological_space (has_pos_part Type)) name) : @irreducible_space.{1} (has_pos_part.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_pos_part.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_169635 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (pseudo_metric_space.{0} name) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (pseudo_metric_space.{0} name))  := sorry --non-trivial
lemma new_lemma_169636 (h0 : list Prop) : list.head (id (id (id h0))) := sorry --non-trivial
lemma new_lemma_169637 (h0 : topological_space (has_one linarith.comp)) : normal_space (has_one linarith.comp) := sorry --non-trivial
lemma new_lemma_169638 (h0 : not (complete_lattice (semi_normed_comm_ring linarith.ineq) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (semi_normed_comm_ring.{0} linarith.ineq) (@classical.by_contradiction'.{1} (complete_lattice.{0} (semi_normed_comm_ring.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_169639 (h0 : functor.add_const (group (ring pos)) linarith.comp) : @normalizer_condition.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (ring.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_169640 (h0 : uniform_space (complete_semilattice_Sup (random_gen (with_bot string_imp)))) : complete_space (complete_semilattice_Sup (random_gen (with_bot string_imp))) := sorry --non-trivial
lemma new_lemma_169641 (h0 : topological_space (has_add (has_add real))) : t1_space (has_add (has_add real)) := sorry --non-trivial
lemma new_lemma_169642 (h0 : add_group (has_top (ring linarith.comp))) : is_add_cyclic (has_top (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_169643 (h0 : topological_space (ring (has_add (has_add name)))) : t0_space (ring (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_169644 (h0 : uniform_space (has_norm (has_top (has_top empty)))) : separated_space (has_norm (has_top (has_top empty))) := sorry --non-trivial
lemma new_lemma_169645 (h0 : add_group (is_R_or_C congr_arg_kind)) : is_add_cyclic (is_R_or_C congr_arg_kind) := sorry --non-trivial
lemma new_lemma_169646 (h0 : uniform_space (finset (option num))) : separated_space (finset (option num)) := sorry --non-trivial
lemma new_lemma_169647 (h0 : functor.add_const (uniform_space (linear_order unsigned)) empty) : @separated_space.{0} (linear_order.{0} unsigned) (@functor.add_const.run.{0 0} (uniform_space.{0} (linear_order.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_169648 (h0 : not (add_group (partial_order unsigned) -> false)) : @is_add_cyclic.{0} (partial_order.{0} unsigned) (@classical.by_contradiction'.{1} (add_group.{0} (partial_order.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_169649 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (add_cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_169650 (h0 : function.extfun Type (functor.add_const (group (ordered_comm_group empty)))) : @is_cyclic.{0} (ordered_comm_group.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (ordered_comm_group.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (group.{0} (ordered_comm_group.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_169651 (h0 : functor.add_const (function.extfun Type ring) environment.implicit_infer_kind) : @is_principal_ideal_ring.{0} (has_nndist.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) environment.implicit_infer_kind h0) (has_nndist.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_169652 (h0 : monoid (semigroup (has_add linarith.comp))) : monoid.fg (semigroup (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_169653 (h0 : topological_space (ordered_comm_ring (has_Inf linarith.comp))) : preconnected_space (ordered_comm_ring (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_169654 (h0 : not (list (encodable linarith.ineq) -> false)) : list.nodup (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_169655 (h0 : function.extfun Type topological_space) : @t1_space.{0} (free_add_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (free_add_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_169656 (h0 : semiring (ordered_cancel_add_comm_monoid pos)) : is_noetherian_ring (ordered_cancel_add_comm_monoid pos) := sorry --non-trivial
lemma new_lemma_169657 (h0 : functor.add_const (group (generalized_boolean_algebra linarith.comp)) pos) : @normalizer_condition.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (generalized_boolean_algebra.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_169658 (h0 : not (complete_lattice (linear_ordered_add_comm_group fun_info) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (linear_ordered_add_comm_group.{0} fun_info) (@classical.by_contradiction'.{1} (complete_lattice.{0} (linear_ordered_add_comm_group.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_169659 (h0 : functor.add_const Prop (has_norm num)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_169660 (h2 : set (add_comm_semigroup enat -> linarith.ineq)) : set.separates_points h2 := sorry --non-trivial
lemma new_lemma_169661 (h2 : complete_lattice (with_zero linarith.ineq)) : complete_lattice.is_Sup_finite_compact (with_zero linarith.ineq) := sorry --non-trivial
lemma new_lemma_169662 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (semiring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (semiring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_169663 (h0 : group (boolean_algebra.core ennreal)) : normalizer_condition (boolean_algebra.core ennreal) := sorry --non-trivial
lemma new_lemma_169664 (h0 : cancel_comm_monoid_with_zero (normed_comm_ring (comm_group pos))) : unique_factorization_monoid (normed_comm_ring (comm_group pos)) := sorry --non-trivial
lemma new_lemma_169665 (h0 : has_mem.mem group has_emptyc.emptyc) : @normalizer_condition.{0} (has_norm.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} h0) (has_norm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_169666 (h0 : topological_space (semigroup (add_comm_monoid pos))) : t1_space (semigroup (add_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_169667 (h0 : not (topological_space (mul_zero_class empty) -> false)) : @t1_space.{0} (mul_zero_class.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (mul_zero_class.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_169668 (h0 : ring (add_cancel_monoid (has_add (has_zero Type)))) : rank_condition (add_cancel_monoid (has_add (has_zero Type))) := sorry --non-trivial
lemma new_lemma_169669 (h0 : functor.add_const (complete_lattice (canonically_linear_ordered_monoid num)) num) : @complete_lattice.is_Sup_finite_compact.{0} (canonically_linear_ordered_monoid.{0} num) (@functor.add_const.run.{0 0} (complete_lattice.{0} (canonically_linear_ordered_monoid.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_169670 (h0 : not (group (has_top empty) -> false)) : @normalizer_condition.{0} (has_top.{0} empty) (@classical.by_contradiction'.{1} (group.{0} (has_top.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_169671 (h0 : functor.add_const (semiring (sub_neg_monoid pos)) linarith.comp) : @is_noetherian_ring.{0} (sub_neg_monoid.{0} pos) (@functor.add_const.run.{0 0} (semiring.{0} (sub_neg_monoid.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_169672 (h0 : functor.add_const (topological_space (partial_order num)) empty) : @t0_space.{0} (partial_order.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (partial_order.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_169673 (h0 : group (has_neg (boolean_algebra pos))) : normalizer_condition (has_neg (boolean_algebra pos)) := sorry --non-trivial
lemma new_lemma_169674 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (with_one.{0} fun_info) (@function.extfun_app.{2 1} Type monoid.{0} h0 (with_one.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_169675 (h0 : function.extfun Type group) : @group.fg.{0} (has_add.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} h0 (has_add.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_169676 (h0 : topological_space (left_cancel_semigroup (semiring congr_arg_kind))) : discrete_topology (left_cancel_semigroup (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_169677 (h0 : functor.add_const (topological_space (boolean_algebra pos)) Type) : @irreducible_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_169678 (h0 : add_monoid (semigroup (option name))) : add_monoid.fg (semigroup (option name)) := sorry --non-trivial
lemma new_lemma_169679 (h3 : topological_space enat) (h4 : set (set enat)) : topological_space.is_topological_basis h4 := sorry --non-trivial
lemma new_lemma_169680 (h0 : function.extfun Type group) : @is_cyclic.{0} (with_one.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} h0 (with_one.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_169681 (h0 : topological_space (has_union congr_arg_kind)) : discrete_topology (has_union congr_arg_kind) := sorry --non-trivial
lemma new_lemma_169682 (h0 : function.extfun (finset Type) (has_mem.mem (random_gen to_additive.value_type))) : @rank_condition.{0} (random_gen.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type ring.{0} (random_gen.{0} to_additive.value_type) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} to_additive.value_type)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_169683 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (canonically_linear_ordered_add_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_linear_ordered_add_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_169684 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_norm.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_norm.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_169685 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_169686 (h0 : topological_space (add_comm_semigroup environment.projection_info)) : totally_disconnected_space (add_comm_semigroup environment.projection_info) := sorry --non-trivial
lemma new_lemma_169687 (h0 : topological_space (random_gen (semiring num))) : normal_space (random_gen (semiring num)) := sorry --non-trivial
lemma new_lemma_169688 (h2 : add_group (complete_semilattice_Sup linarith.comp)) : is_add_cyclic (complete_semilattice_Sup linarith.comp) := sorry --non-trivial
lemma new_lemma_169689 (h0 : topological_space (comm_semigroup (has_bot (has_add real)))) : t0_space (comm_semigroup (has_bot (has_add real))) := sorry --non-trivial
lemma new_lemma_169690 (h0 : topological_space (ordered_comm_monoid (ring (has_nndist (ring (ring (ring (ring pos)))))))) : irreducible_space (ordered_comm_monoid (ring (has_nndist (ring (ring (ring (ring pos))))))) := sorry --non-trivial
lemma new_lemma_169691 (h0 : topological_space (plift (semiring unsigned))) : normal_space (plift (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_169692 (h0 : uniform_space (option (semiring (semiring num)))) : complete_space (option (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_169693 (h0 : topological_space (ordered_comm_monoid (ring pos))) : locally_compact_space (ordered_comm_monoid (ring pos)) := sorry --non-trivial
lemma new_lemma_169694 (h1 : topological_space (with_one (has_norm to_additive.value_type))) : t0_space (with_one (has_norm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_169695 (h0 : topological_space (has_pos_part (has_pos_part pos))) : irreducible_space (has_pos_part (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_169696 (h0 : uniform_space (has_neg (cancel_monoid (has_neg environment.implicit_infer_kind)))) : separated_space (has_neg (cancel_monoid (has_neg environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_169697 (h0 : add_monoid (finset ennreal)) (h1 : functor.comp monoid semigroup (add_units (finset ennreal))) : @monoid.fg.{0} (semigroup.{0} (@add_units.{0} (finset.{0} ennreal) h0)) (@functor.comp.run.{0 0 0} monoid.{0} semigroup.{0} (@add_units.{0} (finset.{0} ennreal) h0) h1)  := sorry --non-trivial
lemma new_lemma_169698 (h0 : ring (complete_distrib_lattice (generalized_boolean_algebra linarith.comp))) : is_domain (complete_distrib_lattice (generalized_boolean_algebra linarith.comp)) := sorry --non-trivial
lemma new_lemma_169699 (h0 : group (has_neg_part (add_comm_monoid name))) : group.fg (has_neg_part (add_comm_monoid name)) := sorry --non-trivial
lemma new_lemma_169700 (h0 : uniform_space (metric_space (semiring (semiring empty)))) : complete_space (metric_space (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_169701 (h0 : list (has_norm to_additive.value_type)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_169702 (h0 : topological_space (with_one (has_norm (distrib_lattice fun_info)))) : path_connected_space (with_one (has_norm (distrib_lattice fun_info))) := sorry --non-trivial
lemma new_lemma_169703 (h0 : uniform_space (has_to_string (boolean_algebra (has_neg (has_neg linarith.comp))))) : complete_space (has_to_string (boolean_algebra (has_neg (has_neg linarith.comp)))) := sorry --non-trivial
lemma new_lemma_169704 (h0 : monoid (has_to_string unsigned)) : monoid.fg (has_to_string unsigned) := sorry --non-trivial
lemma new_lemma_169705 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} znum (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) znum)  := sorry --non-trivial
lemma new_lemma_169706 (h0 : functor.add_const (list (linear_ordered_comm_monoid_with_zero unsigned)) empty) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_169707 (h0 : semiring (has_add (has_add Type))) : is_noetherian_ring (has_add (has_add Type)) := sorry --non-trivial
lemma new_lemma_169708 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (has_inter.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_inter.{0} empty))  := sorry --non-trivial
lemma new_lemma_169709 (h0 : topological_space (complete_semilattice_Sup (has_union linarith.comp))) : discrete_topology (complete_semilattice_Sup (has_union linarith.comp)) := sorry --non-trivial
lemma new_lemma_169710 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (boolean_algebra.core name)) := sorry --non-trivial
lemma new_lemma_169711 (h0 : topological_space (has_to_string ennreal)) : regular_space (has_to_string ennreal) := sorry --non-trivial
lemma new_lemma_169712 (h0 : functor.add_const (group (has_zero Type)) environment.implicit_infer_kind) : @normalizer_condition.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (has_zero.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_169713 (h0 : group (denumerable linarith.ineq)) : group.fg (denumerable linarith.ineq) := sorry --non-trivial
lemma new_lemma_169714 (h2 : ring (with_one fun_info)) : rank_condition (with_one fun_info) := sorry --non-trivial
lemma new_lemma_169715 (h0 : functor.add_const (function.extfun Type ring) pos) : @is_principal_ideal_ring.{0} (has_nndist.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) pos h0) (has_nndist.{0} name))  := sorry --non-trivial
lemma new_lemma_169716 (h0 : filter (ring (has_neg_part (has_neg_part Type)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_169717 (h0 : has_le (add_comm_semigroup linarith.ineq)) (h1 : add_comm_semigroup linarith.ineq) : is_bot h1 := sorry --non-trivial
lemma new_lemma_169718 (h0 : functor.add_const (ring (normed_comm_ring environment.implicit_infer_kind)) environment.implicit_infer_kind) : @rank_condition.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (normed_comm_ring.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_169719 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @t0_space.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_169720 (h3 : ring (normed_field to_additive.value_type)) : rank_condition (normed_field to_additive.value_type) := sorry --non-trivial
lemma new_lemma_169721 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type monoid.{0} h0 (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_169722 (h0 : functor.add_const (function.extfun Type complete_lattice) pos) : @is_compactly_generated.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) pos h0) (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_169723 (h0 : group (as_linear_order (option empty))) : group.fg (as_linear_order (option empty)) := sorry --non-trivial
lemma new_lemma_169724 (h0 : has_lt (simple_graph char)) : no_max_order (simple_graph char) := sorry --non-trivial
lemma new_lemma_169725 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (add_comm_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_comm_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_169726 (h0 : not (filter (has_norm num) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_169727 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (has_add.{0} name) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (has_add.{0} name))  := sorry --non-trivial
lemma new_lemma_169728 (h0 : topological_space (has_Inf (has_neg name))) : discrete_topology (has_Inf (has_neg name)) := sorry --non-trivial
lemma new_lemma_169729 (h0 : topological_space (normed_comm_ring (option empty))) : path_connected_space (normed_comm_ring (option empty)) := sorry --non-trivial
lemma new_lemma_169730 (h0 : list (semigroup (has_add pos))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_169731 (h0 : functor.add_const (topological_space (mul_zero_class environment.implicit_infer_kind)) name) : @preconnected_space.{0} (mul_zero_class.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_169732 (h0 : complete_lattice (ring (ordered_comm_ring (has_Inf Type)))) : complete_lattice.is_Sup_finite_compact (ring (ordered_comm_ring (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_169733 (h1 : complete_lattice (fintype string_imp)) : complete_lattice.is_Sup_finite_compact (fintype string_imp) := sorry --non-trivial
lemma new_lemma_169734 (h0 : functor.add_const (topological_space (finset num)) pos) : @loc_path_connected_space.{0} (finset.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} num)) pos h0)  := sorry --non-trivial
lemma new_lemma_169735 (h0 : functor.add_const (topological_space (left_cancel_semigroup empty)) (semiring empty)) : @t1_space.{0} (left_cancel_semigroup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_semigroup.{0} empty)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_169736 (h0 : topological_space (generalized_boolean_algebra (has_add (ring (has_add linarith.comp))))) : normal_space (generalized_boolean_algebra (has_add (ring (has_add linarith.comp)))) := sorry --non-trivial
lemma new_lemma_169737 (h0 : monoid (add_cancel_monoid (has_neg (has_neg_part Type)))) : monoid.fg (add_cancel_monoid (has_neg (has_neg_part Type))) := sorry --non-trivial
lemma new_lemma_169738 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (normed_comm_ring empty)) := sorry --non-trivial
lemma new_lemma_169739 (h0 : topological_space (linear_ordered_comm_monoid_with_zero (option unsigned))) : t1_space (linear_ordered_comm_monoid_with_zero (option unsigned)) := sorry --non-trivial
lemma new_lemma_169740 (h0 : not (complete_lattice (normed_field fun_info) -> false)) : @is_compactly_generated.{0} (normed_field.{0} fun_info) (@classical.by_contradiction'.{1} (complete_lattice.{0} (normed_field.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_169741 (h0 : topological_space (semigroup (has_neg linarith.comp))) : preirreducible_space (semigroup (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_169742 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (finset.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (finset.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_169743 (h0 : set (has_div (mul_one_class (add_right_cancel_monoid linarith.ineq)))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_169744 (h0 : topological_space (add_comm_monoid (has_Inf Type))) : path_connected_space (add_comm_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_169745 (h0 : cancel_comm_monoid_with_zero (free_add_monoid (semiring empty))) : unique_factorization_monoid (free_add_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_169746 (h0 : topological_space (simple_graph (has_add (boolean_algebra.core Type)))) : preirreducible_space (simple_graph (has_add (boolean_algebra.core Type))) := sorry --non-trivial
lemma new_lemma_169747 (h0 : topological_space (pseudo_metric_space pos)) : totally_separated_space (pseudo_metric_space pos) := sorry --non-trivial
lemma new_lemma_169748 (h0 : functor.add_const (topological_space (comm_group name)) pos) : @irreducible_space.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_169749 (h0 : filter (complete_linear_order (has_top (semiring (semiring (has_top empty)))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_169750 (h0 : topological_space (has_le enat)) (h1 : preorder (has_le enat)) : order_closed_topology (has_le enat) := sorry --non-trivial
lemma new_lemma_169751 (h0 : functor.add_const (ordered_add_comm_monoid (add_comm_monoid pos)) (cancel_monoid (has_add pos))) : @archimedean.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (add_comm_monoid.{0} pos)) (cancel_monoid.{0} (has_add.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_169752 (h0 : not (topological_space (plift num) -> false)) : @t0_space.{1} (plift.{1} num) (@classical.by_contradiction'.{2} (topological_space.{1} (plift.{1} num)) h0)  := sorry --non-trivial
lemma new_lemma_169753 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (boolean_algebra.core.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.core.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_169754 (h0 : functor.add_const (add_group (has_pos_part pos)) (ring (has_nndist (has_nndist Type)))) : @is_add_cyclic.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 1} (add_group.{0} (has_pos_part.{0} pos)) (ring.{1} (has_nndist.{1} (has_nndist.{1} Type))) h0)  := sorry --non-trivial
lemma new_lemma_169755 (h0 : group (comm_ring (with_one fun_info))) : is_cyclic (comm_ring (with_one fun_info)) := sorry --non-trivial
lemma new_lemma_169756 (h0 : topological_space (with_one (has_norm (has_top linarith.ineq)))) : totally_disconnected_space (with_one (has_norm (has_top linarith.ineq))) := sorry --non-trivial
lemma new_lemma_169757 (h0 : uniform_space (normed_comm_ring (finset ennreal))) : complete_space (normed_comm_ring (finset ennreal)) := sorry --non-trivial
lemma new_lemma_169758 (h0 : function.extfun Type ring) : @is_domain.{0} (has_zero.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_169759 (h0 : ring (canonically_ordered_comm_semiring linarith.comp)) : is_principal_ideal_ring (canonically_ordered_comm_semiring linarith.comp) := sorry --non-trivial
lemma new_lemma_169760 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} subsingleton_info (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 subsingleton_info)  := sorry --non-trivial
lemma new_lemma_169761 (h0 : ring (has_norm (semiring (semiring unsigned)))) : rank_condition (has_norm (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_169762 (h0 : functor.add_const (uniform_space (has_nndist name)) linarith.comp) : @separated_space.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_nndist.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_169763 (h0 : functor.add_const (ordered_add_comm_monoid (add_comm_monoid linarith.comp)) linarith.comp) : @archimedean.{0} (add_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (add_comm_monoid.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_169764 (h0 : topological_space (complete_semilattice_Sup (has_top (has_top to_additive.value_type)))) : path_connected_space (complete_semilattice_Sup (has_top (has_top to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_169765 (h0 : has_mem.mem (has_norm fun_info) has_emptyc.emptyc) : @is_compactly_generated.{0} (has_norm.{0} fun_info) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (has_norm.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_169766 (h0 : functor.add_const (uniform_space (add_cancel_monoid Type)) name) : @complete_space.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (add_cancel_monoid.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_169767 (h0 : group (add_cancel_monoid (has_add linarith.comp))) : normalizer_condition (add_cancel_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_169768 (h0 : monoid (denumerable linarith.ineq)) : monoid.fg (denumerable linarith.ineq) := sorry --non-trivial
lemma new_lemma_169769 (h0 : functor.add_const (function.extfun Type topological_space) real) : @path_connected_space.{0} (comm_semigroup.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) real h0) (comm_semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_169770 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (semigroup.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_169771 (h0 : functor.add_const (topological_space (boolean_algebra linarith.comp)) environment.implicit_infer_kind) : @regular_space.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_169772 (h0 : ring (comm_ring (random_gen (has_nnnorm linarith.ineq)))) : strong_rank_condition (comm_ring (random_gen (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_169773 (h0 : topological_space (ordered_comm_ring (has_pos_part (ring (ring Type))))) : discrete_topology (ordered_comm_ring (has_pos_part (ring (ring Type)))) := sorry --non-trivial
lemma new_lemma_169774 (h0 : complete_lattice (boolean_algebra.core ennreal)) : is_atomistic (boolean_algebra.core ennreal) := sorry --non-trivial
lemma new_lemma_169775 (h0 : functor.add_const (finset (has_to_string linarith.comp)) linarith.comp) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_169776 (h0 : not (ring (complete_semilattice_Sup unsigned) -> false)) : @is_principal_ideal_ring.{0} (complete_semilattice_Sup.{0} unsigned) (@classical.by_contradiction'.{1} (ring.{0} (complete_semilattice_Sup.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_169777 (h0 : topological_space (simple_graph (has_add (finset Type)))) : t1_space (simple_graph (has_add (finset Type))) := sorry --non-trivial
lemma new_lemma_169778 (h0 : functor.add_const (function.extfun Type topological_space) environment.implicit_infer_kind) : @t0_space.{0} (has_to_string.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) environment.implicit_infer_kind h0) (has_to_string.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_169779 (h0 : ring (has_compl (mul_one_class (mul_one_class (group_with_zero reducibility_hints))))) : rank_condition (has_compl (mul_one_class (mul_one_class (group_with_zero reducibility_hints)))) := sorry --non-trivial
lemma new_lemma_169780 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (with_bot.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (with_bot.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_169781 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (has_neg.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (has_neg.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_169782 (h0 : function.extfun Type group) : @group.fg.{0} (denumerable.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} h0 (denumerable.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_169783 (h0 : topological_space (omega_complete_partial_order congr_arg_kind)) : sequential_space (omega_complete_partial_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_169784 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_169785 (h0 : function.extfun (finset Type) (has_mem.mem (normed_comm_ring linarith.comp_source))) : @path_connected_space.{0} (normed_comm_ring.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (normed_comm_ring.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (normed_comm_ring.{0} linarith.comp_source)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_169786 (h0 : function.extfun nat fin) : @t1_space.{0} (has_add.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (has_add.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_169787 (h0 : functor.add_const (add_monoid (left_cancel_monoid num)) congr_arg_kind) : @add_monoid.fg.{0} (left_cancel_monoid.{0} num) (@functor.add_const.run.{0 0} (add_monoid.{0} (left_cancel_monoid.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_169788 (h0 : semiring (has_nndist unsigned)) : is_noetherian_ring (has_nndist unsigned) := sorry --non-trivial
lemma new_lemma_169789 (h0 : functor.add_const (topological_space (has_nndist ennreal)) num) : @loc_path_connected_space.{0} (has_nndist.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} ennreal)) num h0)  := sorry --non-trivial
lemma new_lemma_169790 (h0 : topological_space (has_to_string (option unsigned))) : loc_path_connected_space (has_to_string (option unsigned)) := sorry --non-trivial
lemma new_lemma_169791 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_neg_part.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_169792 (h0 : complete_lattice (with_one (random_gen (random_gen linarith.ineq)))) : complete_lattice.is_Sup_finite_compact (with_one (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_169793 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (mul_zero_class.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (mul_zero_class.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_169794 (h1 : topological_space (measurable_space (random_gen string_imp))) : t0_space (measurable_space (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_169795 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_169796 (h0 : fin has_zero.zero) : @unique_factorization_monoid.{0} (normed_lattice_add_comm_group.{0} real) (@matrix.vec_empty.{0} (cancel_comm_monoid_with_zero.{0} (normed_lattice_add_comm_group.{0} real)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_169797 (h0 : monoid (has_add (option ennreal))) (h1 : submonoid (has_add (option ennreal))) : submonoid.fg h1 := sorry --non-trivial
lemma new_lemma_169798 (h0 : functor.add_const (topological_space (complete_linear_order num)) num) : @discrete_topology.{0} (complete_linear_order.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_linear_order.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_169799 (h0 : functor.add_const (topological_space (has_zero Type)) environment.implicit_infer_kind) : @irreducible_space.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_zero.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_169800 (h0 : functor.add_const (ring (has_zero pos)) pos) : @is_domain.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_zero.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_169801 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (has_zero.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (has_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_169802 (h0 : ring (ordered_comm_ring (finset (has_pos_part Type)))) : is_domain (ordered_comm_ring (finset (has_pos_part Type))) := sorry --non-trivial
lemma new_lemma_169803 (h0 : functor.add_const (topological_space (ring linarith.comp)) Type) : @preconnected_space.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (ring.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_169804 (h0 : topological_space (denumerable (random_gen (random_gen (has_nnnorm char))))) : totally_disconnected_space (denumerable (random_gen (random_gen (has_nnnorm char)))) := sorry --non-trivial
lemma new_lemma_169805 (h0 : functor.add_const (group (complete_distrib_lattice name)) Type) : @group.fg.{0} (complete_distrib_lattice.{0} name) (@functor.add_const.run.{0 1} (group.{0} (complete_distrib_lattice.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_169806 (h0 : functor.add_const (topological_space (normed_comm_ring pos)) (has_to_string Type)) : @t0_space.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (normed_comm_ring.{0} pos)) (has_to_string.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_169807 (h0 : complete_lattice (finset (has_add (finset (finset (finset (has_Inf pos))))))) : complete_lattice.is_Sup_finite_compact (finset (has_add (finset (finset (finset (has_Inf pos)))))) := sorry --non-trivial
lemma new_lemma_169808 (h0 : topological_space (complete_distrib_lattice (has_Inf Type))) : loc_path_connected_space (complete_distrib_lattice (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_169809 (h0 : topological_space (left_cancel_semigroup congr_arg_kind)) : totally_disconnected_space (left_cancel_semigroup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_169810 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (has_bot.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_bot.{0} real))  := sorry --non-trivial
lemma new_lemma_169811 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (canonically_ordered_comm_semiring.{0} (has_to_string.{0} pos)) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (canonically_ordered_comm_semiring.{0} (has_to_string.{0} pos)))  := sorry --non-trivial
lemma new_lemma_169812 (h0 : fin has_zero.zero) : @is_domain.{1} (has_bot.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (has_bot.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_169813 (h0 : not (group (linear_ordered_comm_ring unsigned) -> false)) : @normalizer_condition.{0} (linear_ordered_comm_ring.{0} unsigned) (@classical.by_contradiction'.{1} (group.{0} (linear_ordered_comm_ring.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_169814 (h0 : topological_space (has_dist (option (option num)))) : t0_space (has_dist (option (option num))) := sorry --non-trivial
lemma new_lemma_169815 (h0 : semiring (complete_linear_order (semiring congr_arg_kind))) : is_noetherian_ring (complete_linear_order (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_169816 (h0 : topological_space (cancel_monoid (boolean_algebra linarith.comp))) : preirreducible_space (cancel_monoid (boolean_algebra linarith.comp)) := sorry --non-trivial
lemma new_lemma_169817 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (has_bot.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_bot.{0} real))  := sorry --non-trivial
lemma new_lemma_169818 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (pseudo_metric_space.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (pseudo_metric_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_169819 (h2 h3 : multiset (nondiscrete_normed_field enat)) : multiset.disjoint h2 h3 := sorry --non-trivial
lemma new_lemma_169820 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (ordered_cancel_add_comm_monoid congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_169821 (h0 : functor.add_const (group ennreal) (option (option (option unsigned)))) : @is_cyclic.{0} ennreal (@functor.add_const.run.{0 0} (group.{0} ennreal) (option.{0} (option.{0} (option.{0} unsigned))) h0)  := sorry --non-trivial
lemma new_lemma_169822 (h1 : add_group (topological_space (has_lt linarith.ineq))) : is_add_cyclic (topological_space (has_lt linarith.ineq)) := sorry --non-trivial
lemma new_lemma_169823 (h0 : list (has_add (option (option ennreal)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_169824 (h0 : thunk pnat) (h1 : nat) (h2 : array h1 pnat) (h3 : fin h1) : pnat.coprime (@trace_call_stack.{0} pnat h0) (@array.read.{0} h1 pnat h2 h3)  := sorry --non-trivial
lemma new_lemma_169825 (h0 : not (function.extfun Type complete_lattice -> false)) : is_atomistic (measurable_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_169826 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_169827 (h1 : multiset (simple_graph string_imp)) (h2 : not (multiset (simple_graph string_imp) -> false)) : multiset.disjoint h1 (classical.by_contradiction' h2) := sorry --non-trivial
lemma new_lemma_169828 (h0 : topological_space (canonically_ordered_add_monoid (option (option (option empty))))) : t0_space (canonically_ordered_add_monoid (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_169829 (h0 : uniform_space (has_Sup congr_arg_kind)) : complete_space (has_Sup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_169830 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_169831 (h0 : topological_space (semigroup (has_to_string congr_arg_kind))) : preconnected_space (semigroup (has_to_string congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_169832 (h0 : functor.add_const (group (comm_group Type)) pos) : @is_simple_group.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (comm_group.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_169833 (h0 : topological_space (has_top (random_gen (random_gen (dlist linarith.ineq))))) : t0_space (has_top (random_gen (random_gen (dlist linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_169834 (h0 : semiring (semigroup (semiring (semiring empty)))) : is_noetherian_ring (semigroup (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_169835 (h0 : topological_space (has_nndist (finset (finset pos)))) : irreducible_space (has_nndist (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_169836 (h0 : topological_space (ordered_comm_monoid (has_add (boolean_algebra.core linarith.comp)))) : preirreducible_space (ordered_comm_monoid (has_add (boolean_algebra.core linarith.comp))) := sorry --non-trivial
lemma new_lemma_169837 (h2 : uniform_space (has_norm (random_gen (with_bot (random_gen to_additive.value_type))))) : complete_space (has_norm (random_gen (with_bot (random_gen to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_169838 (h0 : topological_space (mul_zero_class congr_arg_kind)) : t0_space (mul_zero_class congr_arg_kind) := sorry --non-trivial
lemma new_lemma_169839 (h0 : ring (plift unsigned)) : is_principal_ideal_ring (plift unsigned) := sorry --non-trivial
lemma new_lemma_169840 (h0 : generalized_boolean_algebra (comm_semigroup Type) -> generalized_boolean_algebra (comm_semigroup Type) -> Prop) : transitive h0 := sorry --non-trivial
lemma new_lemma_169841 (h2 : uniform_space fun_info) : complete_space fun_info := sorry --non-trivial
lemma new_lemma_169842 (h0 : not (ring (uniform_space fun_info) -> false)) : @is_domain.{0} (uniform_space.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (uniform_space.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_169843 (h0 : topological_space (has_pos_part (has_pos_part (has_add linarith.comp)))) : preirreducible_space (has_pos_part (has_pos_part (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_169844 (h0 : group (canonically_ordered_comm_semiring (has_Inf linarith.comp))) : is_cyclic (canonically_ordered_comm_semiring (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_169845 (h0 : topological_space pos) : locally_compact_space pos := sorry --non-trivial
lemma new_lemma_169846 (h0 : functor.add_const (finset (left_cancel_monoid congr_arg_kind)) unsigned) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_169847 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (mul_zero_class.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (mul_zero_class.{0} pos))  := sorry --non-trivial
lemma new_lemma_169848 (h0 : not (topological_space (has_lt string.iterator_imp) -> false)) : @path_connected_space.{0} (has_lt.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (topological_space.{0} (has_lt.{0} string.iterator_imp)) h0)  := sorry --non-trivial
lemma new_lemma_169849 (h0 : functor.add_const (ring (semigroup pos)) unsigned) : @rank_condition.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (semigroup.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_169850 (h0 : not (complete_lattice (random_gen string.iterator_imp) -> false)) : @is_compactly_generated.{0} (random_gen.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (complete_lattice.{0} (random_gen.{0} string.iterator_imp)) h0)  := sorry --non-trivial
lemma new_lemma_169851 (h0 h1 : std_gen -> std_gen) : function.commute h0 h1 := sorry --non-trivial
lemma new_lemma_169852 (h0 : fin has_zero.zero) : @has_exists_mul_of_le.{0} (add_comm_monoid.{0} pos) (@matrix.vec_empty.{0} (ordered_comm_monoid.{0} (add_comm_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_169853 (h0 : cancel_comm_monoid_with_zero (monoid_with_zero (option pos))) : unique_factorization_monoid (monoid_with_zero (option pos)) := sorry --non-trivial
lemma new_lemma_169854 (h0 : functor.add_const (function.extfun (Type 1) topological_space) pos) : @t0_space.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) pos h0) (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_169855 (h0 : ring (has_dist (option unsigned))) : rank_condition (has_dist (option unsigned)) := sorry --non-trivial
lemma new_lemma_169856 (h0 : functor.add_const (semiring (has_nndist environment.implicit_infer_kind)) pos) : @is_noetherian_ring.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (semiring.{0} (has_nndist.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_169857 (h0 : functor.add_const (complete_lattice (normed_comm_ring name)) Type) : @complete_lattice.is_Sup_finite_compact.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 1} (complete_lattice.{0} (normed_comm_ring.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_169858 (h0 : topological_space (mul_zero_class (semiring (semiring (semiring congr_arg_kind))))) : locally_compact_space (mul_zero_class (semiring (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_169859 (h0 : functor.add_const (topological_space (has_add environment.implicit_infer_kind)) pos) : @path_connected_space.{0} (has_add.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_169860 (h0 : topological_space (mul_one_class congr_arg_kind)) : normal_space (mul_one_class congr_arg_kind) := sorry --non-trivial
lemma new_lemma_169861 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_169862 (h0 : add_monoid (add_cancel_monoid (option (option (option num))))) : add_monoid.fg (add_cancel_monoid (option (option (option num)))) := sorry --non-trivial
lemma new_lemma_169863 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (generalized_boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (generalized_boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_169864 (h0 : filter (comm_ring (has_norm fun_info))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_169865 (h0 : not (topological_space (add_right_cancel_monoid unsigned) -> false)) : @discrete_topology.{0} (add_right_cancel_monoid.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (add_right_cancel_monoid.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_169866 (h0 : topological_space (add_comm_semigroup linarith.ineq)) : topological_space.first_countable_topology (add_comm_semigroup linarith.ineq) := sorry --non-trivial
lemma new_lemma_169867 (h0 : topological_space (bin_tree (semiring (semiring unsigned)))) : totally_separated_space (bin_tree (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_169868 (h0 : functor.add_const (topological_space (finset pos)) (has_neg Type)) : @totally_separated_space.{0} (finset.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (finset.{0} pos)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_169869 (h0 : not (has_mem.mem (has_norm linarith.ineq) has_emptyc.emptyc -> false)) : @totally_disconnected_space.{0} (has_norm.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_norm.{0} linarith.ineq) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_norm.{0} linarith.ineq) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_169870 (h3 : add_group (add_comm_semigroup (mul_one_class environment.projection_info))) : is_add_cyclic (add_comm_semigroup (mul_one_class environment.projection_info)) := sorry --non-trivial
lemma new_lemma_169871 (h0 : group (finset (normed_comm_ring linarith.comp))) : is_simple_group (finset (normed_comm_ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_169872 (h0 : topological_space (has_inf ennreal)) : discrete_topology (has_inf ennreal) := sorry --non-trivial
lemma new_lemma_169873 (h0 : semiring (has_inv linarith.comp_source)) (h1 : has_inv linarith.comp_source) : odd h1 := sorry --non-trivial
lemma new_lemma_169874 (h0 : topological_space (comm_semigroup (has_neg real))) : totally_separated_space (comm_semigroup (has_neg real)) := sorry --non-trivial
lemma new_lemma_169875 (h0 : functor.add_const (function.extfun (Type 1) add_group) environment.implicit_infer_kind) : @is_add_cyclic.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) add_group.{1}) environment.implicit_infer_kind h0) (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_169876 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (canonically_linear_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_linear_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_169877 (h0 : topological_space (id to_additive.value_type)) : locally_compact_space (id to_additive.value_type) := sorry --non-trivial
lemma new_lemma_169878 (h0 : group (has_neg (option ennreal))) : normalizer_condition (has_neg (option ennreal)) := sorry --non-trivial
lemma new_lemma_169879 (h0 : finset (finset (mul_zero_class name))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_169880 (h0 : not (topological_space (non_unital_non_assoc_semiring linarith.ineq) -> false)) : @path_connected_space.{0} (non_unital_non_assoc_semiring.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (non_unital_non_assoc_semiring.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_169881 (h0 : nat) (h1 : function.extfun Type topological_space) : @preirreducible_space.{0} (nat.partition h0) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (nat.partition h0))  := sorry --non-trivial
lemma new_lemma_169882 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (has_to_string.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (has_to_string.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_169883 (h0 : group (complete_distrib_lattice (option pos))) : normalizer_condition (complete_distrib_lattice (option pos)) := sorry --non-trivial
lemma new_lemma_169884 (h0 : functor.add_const (ring (mul_zero_class congr_arg_kind)) congr_arg_kind) : @strong_rank_condition.{0} (mul_zero_class.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ring.{0} (mul_zero_class.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_169885 (h0 : topological_space (fintype (linear_ordered_add_comm_group linarith.comp_source))) : totally_disconnected_space (fintype (linear_ordered_add_comm_group linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_169886 (h0 : function.extfun Type topological_space) : @normal_space.{0} (has_add.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_169887 (h0 : functor.add_const (function.extfun Type uniform_space) (boolean_algebra linarith.comp)) : @separated_space.{0} (boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) (boolean_algebra.{0} linarith.comp) h0) (boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_169888 (h0 : num -> num -> Prop) : relator.bi_unique h0 := sorry --non-trivial
lemma new_lemma_169889 (h0 : functor.add_const (list (canonically_linear_ordered_monoid name)) name) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_169890 (h0 : topological_space (simple_graph linarith.comp)) : preirreducible_space (simple_graph linarith.comp) := sorry --non-trivial
lemma new_lemma_169891 (h0 : uniform_space (with_bot (has_top fun_info))) : separated_space (with_bot (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_169892 (h0 : finset (canonically_ordered_comm_semiring congr_arg_kind)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_169893 (h0 : cancel_comm_monoid_with_zero (canonically_ordered_monoid (has_pos_part pos))) : unique_factorization_monoid (canonically_ordered_monoid (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_169894 (h0 : functor.add_const (topological_space (has_Sup unsigned)) congr_arg_kind) : @totally_disconnected_space.{0} (has_Sup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Sup.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_169895 (h0 : topological_space (semiring linarith.ineq)) : t0_space (semiring linarith.ineq) := sorry --non-trivial
lemma new_lemma_169896 (h0 : topological_space (comm_ring char)) : path_connected_space (comm_ring char) := sorry --non-trivial
lemma new_lemma_169897 (h0 : ring (normed_group (has_norm (semiring (has_norm linarith.comp))))) : strong_rank_condition (normed_group (has_norm (semiring (has_norm linarith.comp)))) := sorry --non-trivial
lemma new_lemma_169898 (h0 : topological_space (with_bot (has_top (has_top (has_top (has_top (has_top unsigned))))))) : discrete_topology (with_bot (has_top (has_top (has_top (has_top (has_top unsigned)))))) := sorry --non-trivial
lemma new_lemma_169899 (h1 : complete_lattice empty) : is_compactly_generated empty := sorry --non-trivial
lemma new_lemma_169900 (h0 : ring (dlist (random_gen (random_gen (random_gen (random_gen to_additive.value_type)))))) : is_domain (dlist (random_gen (random_gen (random_gen (random_gen to_additive.value_type))))) := sorry --non-trivial
lemma new_lemma_169901 (h0 : functor.add_const (uniform_space (has_neg environment.implicit_infer_kind)) (mul_one_class linarith.comp)) : @complete_space.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_neg.{0} environment.implicit_infer_kind)) (mul_one_class.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_169902 (h0 : function.extfun Type group) : @normalizer_condition.{0} (canonically_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type group.{0} h0 (canonically_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_169903 (h0 : not (topological_space (semi_normed_ring char) -> false)) : @t0_space.{0} (semi_normed_ring.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (semi_normed_ring.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_169904 (h0 : topological_space (canonically_linear_ordered_monoid (sub_neg_monoid (has_neg pos)))) : regular_space (canonically_linear_ordered_monoid (sub_neg_monoid (has_neg pos))) := sorry --non-trivial
lemma new_lemma_169905 (h1 : complete_lattice (uniform_space (has_lt reducibility_hints))) : is_compactly_generated (uniform_space (has_lt reducibility_hints)) := sorry --non-trivial
lemma new_lemma_169906 (h0 : functor.add_const (ring (has_nndist name)) pos) : @strong_rank_condition.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (has_nndist.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_169907 (h0 : functor.add_const (function.extfun (Type 1) topological_space) (finset linarith.comp)) : @discrete_topology.{1} (add_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) (finset.{0} linarith.comp) h0) (add_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_169908 (h0 : fin has_zero.zero) : @complete_space.{0} (has_add.{0} real) (@matrix.vec_empty.{0} (uniform_space.{0} (has_add.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_169909 (h0 : functor.add_const (functor.add_const Prop (boolean_algebra name)) name) : functor.add_const.run (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_169910 (h0 : topological_space (has_add (has_to_string ennreal))) : locally_compact_space (has_add (has_to_string ennreal)) := sorry --non-trivial
lemma new_lemma_169911 (h0 : ring (semigroup Type)) : rank_condition (semigroup Type) := sorry --non-trivial
lemma new_lemma_169912 (h0 : functor.add_const (ring (add_semigroup unsigned)) empty) : @is_domain.{0} (add_semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (add_semigroup.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_169913 (h0 : functor.add_const (topological_space (ring Type)) linarith.comp) : @topological_space.separable_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ring.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_169914 (h0 : function.extfun (finset Type) (has_mem.mem (semiring empty))) : @is_compactly_generated.{0} (semiring.{0} empty) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (semiring.{0} empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} empty)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_169915 (h0 : group (plift (semiring (semiring unsigned)))) : group.fg (plift (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_169916 (h0 : topological_space (has_one (random_gen empty))) : irreducible_space (has_one (random_gen empty)) := sorry --non-trivial
lemma new_lemma_169917 (h0 : prod (option unsigned) (option unsigned)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_169918 (h0 : complete_lattice (simple_graph (has_lt char))) : complete_lattice.is_Sup_finite_compact (simple_graph (has_lt char)) := sorry --non-trivial
lemma new_lemma_169919 (h0 : has_mem.mem (semiring linarith.comp) has_emptyc.emptyc) : @normal_space.{0} (semiring.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (semiring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_169920 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_top.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_top.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_169921 (h0 : topological_space (ordered_cancel_add_comm_monoid pos)) : sequential_space (ordered_cancel_add_comm_monoid pos) := sorry --non-trivial
lemma new_lemma_169922 (h0 : functor.add_const (ordered_add_comm_monoid (complete_distrib_lattice linarith.comp)) pos) : @archimedean.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (complete_distrib_lattice.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_169923 (h0 : topological_space (with_bot (has_norm congr_arg_kind))) : path_connected_space (with_bot (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_169924 (h0 : ordered_add_comm_monoid (ordered_comm_ring (generalized_boolean_algebra (has_add real)))) : archimedean (ordered_comm_ring (generalized_boolean_algebra (has_add real))) := sorry --non-trivial
lemma new_lemma_169925 (h0 : function.extfun Type group) : @is_cyclic.{0} (semiring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} h0 (semiring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_169926 (h0 : group (semiring (has_top to_additive.value_type))) : is_cyclic (semiring (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_169927 (h0 : functor.add_const (topological_space (plift num)) unsigned) : @normal_space.{1} (plift.{1} num) (@functor.add_const.run.{1 0} (topological_space.{1} (plift.{1} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_169928 (h0 : pnat) (h1 : thunk (ulower (fin has_zero.zero))) : pnat.coprime h0 (@matrix.vec_empty.{0} pnat (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@ulower.up.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (encodable.fin (@has_zero.zero.{0} nat nat.has_zero)) (@trace_call_stack.{0} (@ulower.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (encodable.fin (@has_zero.zero.{0} nat nat.has_zero))) h1))))  := sorry --non-trivial
lemma new_lemma_169929 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @complete_space.{1} (simple_graph.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 uniform_space.{1}) (simple_graph.{1} Type))  := sorry --non-trivial
lemma new_lemma_169930 (h0 : list (dlist (random_gen (random_gen (random_gen (random_gen (random_gen (random_gen char)))))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_169931 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} (has_nnnorm.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_nnnorm.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_169932 (h0 : functor.comp finset has_neg pos) : finset.nonempty (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_169933 (h0 : functor.add_const (group (semigroup name)) pos) : @is_simple_group.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (group.{0} (semigroup.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_169934 (h0 : group (normed_comm_ring (semigroup Type))) : is_cyclic (normed_comm_ring (semigroup Type)) := sorry --non-trivial
lemma new_lemma_169935 (h0 : ring (ring (has_add (mul_one_class pos)))) : is_principal_ideal_ring (ring (has_add (mul_one_class pos))) := sorry --non-trivial
lemma new_lemma_169936 (h0 : topological_space (with_one (has_top to_additive.value_type))) : path_connected_space (with_one (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_169937 (h0 : topological_space (is_R_or_C (semiring (semiring (semiring (semiring empty)))))) : t1_space (is_R_or_C (semiring (semiring (semiring (semiring empty))))) := sorry --non-trivial
lemma new_lemma_169938 (h0 : function.extfun (Type 1) group) : @is_cyclic.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} h0 (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_169939 (h0 : not (function.extfun Type semiring -> false)) : @is_noetherian_ring.{0} (with_one.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type semiring.{0}) h0) (with_one.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_169940 (h1 : uniform_space (semi_normed_comm_ring (has_ssubset (has_nnnorm reducibility_hints)))) : complete_space (semi_normed_comm_ring (has_ssubset (has_nnnorm reducibility_hints))) := sorry --non-trivial
lemma new_lemma_169941 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (linear_ordered_semiring.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} h0 (linear_ordered_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_169942 (h0 : functor.add_const (topological_space (has_Sup unsigned)) num) : @preirreducible_space.{0} (has_Sup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Sup.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_169943 (h0 : complete_lattice (canonically_linear_ordered_monoid (has_neg (has_neg real)))) : complete_lattice.is_Sup_finite_compact (canonically_linear_ordered_monoid (has_neg (has_neg real))) := sorry --non-trivial
lemma new_lemma_169944 (h0 : functor.comp topological_space has_to_string name) : @totally_disconnected_space.{0} (has_to_string.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} has_to_string.{0} name h0)  := sorry --non-trivial
lemma new_lemma_169945 (h0 : functor.comp topological_space mul_zero_class ennreal) : @preirreducible_space.{0} (mul_zero_class.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} mul_zero_class.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_169946 (h0 : topological_space (semigroup (ring (has_Inf (ring Type))))) : preirreducible_space (semigroup (ring (has_Inf (ring Type)))) := sorry --non-trivial
lemma new_lemma_169947 (h0 : topological_space (has_inv (random_gen linarith.ineq))) : t0_space (has_inv (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_169948 (h1 : add_group (comm_ring reducibility_hints)) : is_add_cyclic (comm_ring reducibility_hints) := sorry --non-trivial
lemma new_lemma_169949 (h0 : topological_space (linear_ordered_field pos)) : loc_path_connected_space (linear_ordered_field pos) := sorry --non-trivial
lemma new_lemma_169950 (h1 : topological_space linarith.comp) : locally_compact_space linarith.comp := sorry --non-trivial
lemma new_lemma_169951 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (bin_tree.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (bin_tree.{0} empty))  := sorry --non-trivial
lemma new_lemma_169952 (h0 : group (normed_comm_ring (has_to_string pos))) : group.fg (normed_comm_ring (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_169953 (h0 : linarith.comp_source -> add_group (distrib (mul_one_class (mul_one_class (mul_one_class char))))) (h1 : ordinal) (h2 : has_lt.lt h1 (ordinal.type well_ordering_rel)) : @is_add_cyclic.{0} (distrib.{0} (mul_one_class.{0} (mul_one_class.{0} (mul_one_class.{0} char)))) (@ordinal.bfamily_of_family.{0 0} (add_group.{0} (distrib.{0} (mul_one_class.{0} (mul_one_class.{0} (mul_one_class.{0} char))))) linarith.comp_source h0 h1 h2)  := sorry --non-trivial
lemma new_lemma_169954 (h1 : add_group (normed_field string.iterator_imp)) : is_add_cyclic (normed_field string.iterator_imp) := sorry --non-trivial
lemma new_lemma_169955 (h0 : functor.comp topological_space comm_group environment.implicit_infer_kind) : @t1_space.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} comm_group.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_169956 (h0 : topological_space (has_add (random_gen (has_nnnorm (random_gen fun_info))))) : totally_disconnected_space (has_add (random_gen (has_nnnorm (random_gen fun_info)))) := sorry --non-trivial
lemma new_lemma_169957 (h0 : topological_space (simple_graph char) -> linarith.ineq) (h1 : coe_sort (set.range h0)) : @t0_space.{0} (simple_graph.{0} char) (@set.range_splitting.{0 0} (topological_space.{0} (simple_graph.{0} char)) linarith.ineq h0 h1)  := sorry --non-trivial
lemma new_lemma_169958 (h0 : topological_space (canonically_ordered_monoid (has_neg name))) : t0_space (canonically_ordered_monoid (has_neg name)) := sorry --non-trivial
lemma new_lemma_169959 (h0 : functor.add_const (complete_lattice (has_nndist Type)) ennreal) : @is_compactly_generated.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (has_nndist.{1} Type)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_169960 (h0 : functor.comp ring has_nndist name) : @is_domain.{0} (has_nndist.{0} name) (@functor.comp.run.{0 0 0} ring.{0} has_nndist.{0} name h0)  := sorry --non-trivial
lemma new_lemma_169961 (h0 : function.extfun Type (functor.add_const (ring linarith.comp))) : @rank_condition.{0} linarith.comp (@functor.add_const.run.{0 0} (ring.{0} linarith.comp) linarith.comp (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} linarith.comp)) h0 linarith.comp))  := sorry --non-trivial
lemma new_lemma_169962 (h0 : ordered_comm_monoid (has_add (has_neg Type))) : has_exists_mul_of_le (has_add (has_neg Type)) := sorry --non-trivial
lemma new_lemma_169963 (h0 : monoid (semiring linarith.comp)) : monoid.fg (semiring linarith.comp) := sorry --non-trivial
lemma new_lemma_169964 (h0 : not (ring (normed_group fun_info) -> false)) : @is_domain.{0} (normed_group.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (normed_group.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_169965 (h0 : topological_space (comm_ring (has_ssubset (has_norm (random_gen (random_gen string_imp)))))) : locally_compact_space (comm_ring (has_ssubset (has_norm (random_gen (random_gen string_imp))))) := sorry --non-trivial
lemma new_lemma_169966 (h0 : ring (boolean_algebra.core num)) : is_domain (boolean_algebra.core num) := sorry --non-trivial
lemma new_lemma_169967 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (monoid unsigned)) := sorry --non-trivial
lemma new_lemma_169968 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (complete_distrib_lattice.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} num))  := sorry --non-trivial
lemma new_lemma_169969 (h0 : not (ring num -> false)) : @strong_rank_condition.{0} num (@classical.by_contradiction'.{1} (ring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_169970 (h0 : monoid (id (random_gen (random_gen (has_inv linarith.ineq))))) : monoid.fg (id (random_gen (random_gen (has_inv linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_169971 (h0 : ring (has_neg (boolean_algebra.core (finset Type)))) : rank_condition (has_neg (boolean_algebra.core (finset Type))) := sorry --non-trivial
lemma new_lemma_169972 (h0 : semiring (has_to_string (finset (has_add pos)))) : is_noetherian_ring (has_to_string (finset (has_add pos))) := sorry --non-trivial
lemma new_lemma_169973 (h0 : group (ring (option (option pos)))) : is_cyclic (ring (option (option pos))) := sorry --non-trivial
lemma new_lemma_169974 (h0 : functor.add_const (ring (ordered_ring congr_arg_kind)) empty) : @rank_condition.{0} (ordered_ring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ring.{0} (ordered_ring.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_169975 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (has_star.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_star.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_169976 (h0 : ring (add_comm_semigroup (mul_one_class char))) : strong_rank_condition (add_comm_semigroup (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_169977 (h0 : functor.add_const (monoid ennreal) ennreal) : monoid.fg ennreal := sorry --non-trivial
lemma new_lemma_169978 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (ordered_cancel_add_comm_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_cancel_add_comm_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_169979 (h0 : not (topological_space (linear_ordered_comm_group_with_zero reducibility_hints) -> false)) : @path_connected_space.{0} (linear_ordered_comm_group_with_zero.{0} reducibility_hints) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_comm_group_with_zero.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_169980 (h0 : has_mem.mem (semiring to_additive.value_type) has_emptyc.emptyc) : @monoid.fg.{0} (semiring.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type monoid.{0} (semiring.{0} to_additive.value_type) h0)  := sorry --non-trivial
lemma new_lemma_169981 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_neg_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_169982 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_pos_part Type)) linarith.comp) : @unique_factorization_monoid.{1} (has_pos_part.{1} Type) (@functor.add_const.run.{1 0} (cancel_comm_monoid_with_zero.{1} (has_pos_part.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_169983 (h0 : set (set (random_gen (random_gen (random_gen string_imp))))) : is_countably_spanning h0 := sorry --non-trivial
lemma new_lemma_169984 (h0 : function.extfun Type (functor.add_const (finset pos))) : finset.nonempty (functor.add_const.run (function.extfun_app h0 name)) := sorry --non-trivial
lemma new_lemma_169985 (h0 : functor.add_const (functor.comp topological_space has_neg name) linarith.comp) : @t0_space.{0} (has_neg.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} name (@functor.add_const.run.{0 0} (functor.comp.{0 0 0} topological_space.{0} has_neg.{0} name) linarith.comp h0))  := sorry --non-trivial
lemma new_lemma_169986 (h0 : not (ring (has_norm congr_arg_kind) -> false)) : @is_domain.{0} (has_norm.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (ring.{0} (has_norm.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_169987 (h0 : functor.add_const (finset (finset environment.implicit_infer_kind)) environment.implicit_infer_kind) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_169988 (h1 : ring (fintype fun_info)) : is_domain (fintype fun_info) := sorry --non-trivial
lemma new_lemma_169989 (h0 : ring (normed_lattice_add_comm_group (has_pos_part name))) : is_domain (normed_lattice_add_comm_group (has_pos_part name)) := sorry --non-trivial
lemma new_lemma_169990 (h0 : filter (add_cancel_monoid (has_pos_part (has_add pos)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_169991 (h0 : list (bin_tree (semiring (semiring (semiring num))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_169992 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (linear_ordered_comm_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_169993 (h1 : Prop) : set.separates_points (id (fun (h0 : ereal -> enat), h1)) := sorry --non-trivial
lemma new_lemma_169994 (h0 : functor.add_const (topological_space (free_add_monoid congr_arg_kind)) congr_arg_kind) : @totally_disconnected_space.{0} (free_add_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_169995 (h0 : function.extfun Type group) : @group.fg.{0} (has_compl.{0} char) (@function.extfun_app.{2 1} Type group.{0} h0 (has_compl.{0} char))  := sorry --non-trivial
lemma new_lemma_169996 (h0 : ordered_comm_monoid (has_nndist (finset Type))) : has_exists_mul_of_le (has_nndist (finset Type)) := sorry --non-trivial
lemma new_lemma_169997 (h0 : functor.add_const (monoid (left_cancel_monoid empty)) num) : @monoid.fg.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (monoid.{0} (left_cancel_monoid.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_169998 (h0 : function.extfun Type (functor.comp topological_space has_neg_part)) : @regular_space.{0} (has_neg_part.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg_part.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} has_neg_part.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_169999 (h0 : topological_space (boolean_algebra (has_bot Type))) : normal_space (boolean_algebra (has_bot Type)) := sorry --non-trivial
lemma new_lemma_170000 (h0 : topological_space (has_top (has_top (has_norm (has_norm fun_info))))) : irreducible_space (has_top (has_top (has_norm (has_norm fun_info)))) := sorry --non-trivial
lemma new_lemma_170001 (h0 : topological_space (cancel_monoid (comm_group (cancel_monoid name)))) : sequential_space (cancel_monoid (comm_group (cancel_monoid name))) := sorry --non-trivial
lemma new_lemma_170002 (h1 : filter (has_top (random_gen to_additive.value_type))) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_170003 (h0 : function.extfun Type group) : @group.fg.{0} (has_zero.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} h0 (has_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_170004 (h0 : functor.add_const (list (has_neg_part environment.implicit_infer_kind)) environment.implicit_infer_kind) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_170005 (h0 : functor.add_const (topological_space (has_add environment.implicit_infer_kind)) name) : @preirreducible_space.{0} (has_add.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_170006 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem add_monoid)) : @add_monoid.fg.{0} (with_bot.{0} num) (@function.extfun_app.{2 1} Type add_monoid.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) add_monoid.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) add_monoid.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (with_bot.{0} num))  := sorry --non-trivial
lemma new_lemma_170007 (h0 : group (add_comm_monoid (has_to_string (has_add (has_to_string name))))) : is_cyclic (add_comm_monoid (has_to_string (has_add (has_to_string name)))) := sorry --non-trivial
lemma new_lemma_170008 (h0 : has_scalar (has_nndist linarith.comp_source) (has_nnnorm fun_info)) : mul_action.is_pretransitive (has_nndist linarith.comp_source) (has_nnnorm fun_info) := sorry --non-trivial
lemma new_lemma_170009 (h0 : has_neg char) (h1 : measurable_space char) : has_measurable_neg char := sorry --non-trivial
lemma new_lemma_170010 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (normed_comm_ring.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (normed_comm_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_170011 (h0 : functor.add_const (topological_space (add_cancel_monoid empty)) ennreal) : @locally_compact_space.{0} (add_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} empty)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_170012 (h0 : topological_space (add_comm_monoid (has_neg_part Type))) : normal_space (add_comm_monoid (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_170013 (h0 : topological_space (add_comm_monoid (has_to_string linarith.comp))) : topological_space.separable_space (add_comm_monoid (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_170014 (h3 : uniform_space (has_ssubset string_imp)) : complete_space (has_ssubset string_imp) := sorry --non-trivial
lemma new_lemma_170015 (h0 : add_monoid (add_group (semiring (semiring (semiring (semiring num)))))) : add_monoid.fg (add_group (semiring (semiring (semiring (semiring num))))) := sorry --non-trivial
lemma new_lemma_170016 (h0 : topological_space (distrib (has_nnnorm char))) : t0_space (distrib (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_170017 (h0 : topological_space (plift (semiring empty))) : t1_space (plift (semiring empty)) := sorry --non-trivial
lemma new_lemma_170018 (h0 : filter (normed_comm_ring (has_to_string (has_to_string name)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_170019 (h0 : ring (sub_neg_monoid (sub_neg_monoid real))) : strong_rank_condition (sub_neg_monoid (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_170020 (h0 : cancel_comm_monoid_with_zero (semigroup (ring linarith.comp))) : unique_factorization_monoid (semigroup (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_170021 (h0 : ereal -> ereal) (h1 : ereal) : function.periodic_pts h0 h1 := sorry --non-trivial
lemma new_lemma_170022 (h1 : topological_space (mul_one_class to_additive.value_type)) : t0_space (mul_one_class to_additive.value_type) := sorry --non-trivial
lemma new_lemma_170023 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (has_neg.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (has_neg.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_170024 (h0 : functor.comp topological_space canonically_ordered_comm_semiring environment.implicit_infer_kind) : @preirreducible_space.{0} (canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_170025 (h0 : topological_space (mul_one_class (add_comm_semigroup fun_info))) : t0_space (mul_one_class (add_comm_semigroup fun_info)) := sorry --non-trivial
lemma new_lemma_170026 (h0 : not (ring (has_nnnorm linarith.ineq) -> false)) : @rank_condition.{0} (has_nnnorm.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (has_nnnorm.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_170027 (h0 : semiring (simple_graph (has_nndist linarith.comp))) : is_noetherian_ring (simple_graph (has_nndist linarith.comp)) := sorry --non-trivial
lemma new_lemma_170028 (h0 : to_additive.value_type -> to_additive.value_type -> Prop) : is_irrefl to_additive.value_type h0 := sorry --non-trivial
lemma new_lemma_170029 (h0 : ring (option (option pos))) : is_principal_ideal_ring (option (option pos)) := sorry --non-trivial
lemma new_lemma_170030 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (with_one.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (with_one.{0} num))  := sorry --non-trivial
lemma new_lemma_170031 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (ordered_comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_170032 (h0 : ring (semi_normed_comm_ring (random_gen fun_info))) : is_domain (semi_normed_comm_ring (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_170033 (h0 : group (complete_distrib_lattice (has_Inf linarith.comp))) : group.fg (complete_distrib_lattice (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_170034 (h0 : topological_space (semigroup (finset environment.implicit_infer_kind))) : t1_space (semigroup (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_170035 (h0 : uniform_space (add_cancel_monoid (normed_comm_ring name))) : separated_space (add_cancel_monoid (normed_comm_ring name)) := sorry --non-trivial
lemma new_lemma_170036 (h0 : topological_space (add_cancel_monoid environment.implicit_infer_kind)) : totally_disconnected_space (add_cancel_monoid environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_170037 (h0 : functor.add_const (filter (cancel_monoid name)) linarith.comp) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_170038 (h0 : not (group (partial_order congr_arg_kind) -> false)) : @group.fg.{0} (partial_order.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (group.{0} (partial_order.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_170039 (h0 : topological_space (linear_ordered_field ennreal)) : irreducible_space (linear_ordered_field ennreal) := sorry --non-trivial
lemma new_lemma_170040 (h0 : not (function.extfun Type ring -> false)) : @strong_rank_condition.{0} congr_arg_kind (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_170041 (h0 : function.extfun Type topological_space) : @normal_space.{0} (add_group.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_group.{0} num))  := sorry --non-trivial
lemma new_lemma_170042 (h0 : topological_space (has_append (has_nnnorm (has_nnnorm (has_nnnorm fun_info))))) : path_connected_space (has_append (has_nnnorm (has_nnnorm (has_nnnorm fun_info)))) := sorry --non-trivial
lemma new_lemma_170043 (h0 : topological_space (normed_group (has_inv (has_inv to_additive.value_type)))) : irreducible_space (normed_group (has_inv (has_inv to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_170044 (h0 : functor.add_const (group (has_nndist linarith.comp)) linarith.comp) : @group.fg.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (has_nndist.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_170045 (h0 : group (pseudo_metric_space (option (option name)))) : normalizer_condition (pseudo_metric_space (option (option name))) := sorry --non-trivial
lemma new_lemma_170046 (h0 : function.extfun (multiset Type) (has_mem.mem num)) : @separated_space.{0} num (@multiset.pi.empty.{1 0} Type uniform_space.{0} num (@function.extfun_app.{2 0} (multiset.{1} Type) (@has_mem.mem.{1 1} Type (multiset.{1} Type) (@multiset.has_mem.{1} Type) num) h0 (@has_zero.zero.{1} (multiset.{1} Type) (@multiset.has_zero.{1} Type))))  := sorry --non-trivial
lemma new_lemma_170047 (h0 : complete_lattice (has_add (has_Inf (sub_neg_monoid real)))) : is_compactly_generated (has_add (has_Inf (sub_neg_monoid real))) := sorry --non-trivial
lemma new_lemma_170048 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} znum (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) znum)  := sorry --non-trivial
lemma new_lemma_170049 (h0 : topological_space (bin_tree (semiring (semiring (semiring num))))) : t1_space (bin_tree (semiring (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_170050 (h0 : ring (set.set_semiring string_imp)) : strong_rank_condition (set.set_semiring string_imp) := sorry --non-trivial
lemma new_lemma_170051 (h0 : functor.add_const (list (ring name)) name) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_170052 (h0 : functor.add_const (filter (normed_comm_ring pos)) (has_neg linarith.comp)) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_170053 (h0 : functor.add_const (function.extfun (Type 1) topological_space) linarith.comp) : @t0_space.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) linarith.comp h0) (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_170054 (h0 : functor.add_const (topological_space (has_nndist pos)) Type) : @locally_compact_space.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_nndist.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_170055 (h1 : group (metric_space (comm_ring to_additive.value_type))) : is_cyclic (metric_space (comm_ring to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_170056 (h0 : functor.add_const (cancel_comm_monoid_with_zero (finset name)) Type) : @unique_factorization_monoid.{0} (finset.{0} name) (@functor.add_const.run.{0 1} (cancel_comm_monoid_with_zero.{0} (finset.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_170057 (h1 : filter string_imp) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_170058 (h0 : topological_space (finset (has_neg (finset (finset linarith.comp))))) : preconnected_space (finset (has_neg (finset (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_170059 (h1 : topological_space (has_div linarith.comp_source)) (h2 : add_group (has_div linarith.comp_source)) : topological_add_group (has_div linarith.comp_source) := sorry --non-trivial
lemma new_lemma_170060 (h3 : monoid fun_info) : monoid.fg fun_info := sorry --non-trivial
lemma new_lemma_170061 (h0 : functor.add_const (topological_space (has_neg pos)) (has_neg pos)) : @regular_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} pos)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_170062 (h0 : topological_space (add_comm_monoid real)) : locally_compact_space (add_comm_monoid real) := sorry --non-trivial
lemma new_lemma_170063 (h1 : group (random_gen char)) : group.fg (random_gen char) := sorry --non-trivial
lemma new_lemma_170064 (h0 : topological_space (has_zero (finset (finset pos)))) : discrete_topology (has_zero (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_170065 (h0 : group (linear_order unsigned)) : normalizer_condition (linear_order unsigned) := sorry --non-trivial
lemma new_lemma_170066 (h0 : add_group (linear_ordered_comm_group_with_zero to_additive.value_type)) : is_add_cyclic (linear_ordered_comm_group_with_zero to_additive.value_type) := sorry --non-trivial
lemma new_lemma_170067 (h1 : set (has_lt std_gen)) : set.finite h1 := sorry --non-trivial
lemma new_lemma_170068 (h0 : topological_space (ordered_comm_ring (has_pos_part linarith.comp))) : normal_space (ordered_comm_ring (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_170069 (h0 : topological_space (measure_theory.measure_space (semiring (has_top empty)))) : irreducible_space (measure_theory.measure_space (semiring (has_top empty))) := sorry --non-trivial
lemma new_lemma_170070 (h0 : topological_space (has_Sup num)) : normal_space (has_Sup num) := sorry --non-trivial
lemma new_lemma_170071 (h0 : ordered_comm_monoid (comm_group (option ennreal))) : has_exists_mul_of_le (comm_group (option ennreal)) := sorry --non-trivial
lemma new_lemma_170072 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (distrib_lattice.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (distrib_lattice.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_170073 (h0 : functor.add_const (list (has_zero unsigned)) unsigned) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_170074 (h0 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} (has_union.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h0) (has_union.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_170075 (h0 : functor.add_const (list (plift unsigned)) unsigned) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_170076 (h0 : topological_space (option (mul_zero_class num))) : t1_space (option (mul_zero_class num)) := sorry --non-trivial
lemma new_lemma_170077 (h0 : functor.add_const (topological_space (complete_linear_order empty)) unsigned) : @totally_disconnected_space.{0} (complete_linear_order.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_linear_order.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_170078 (h0 : complete_lattice (non_assoc_semiring (semiring (semiring unsigned)))) : complete_lattice.is_Sup_finite_compact (non_assoc_semiring (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_170079 (h0 : function.extfun Type group) : @normalizer_condition.{0} (normed_group.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} h0 (normed_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_170080 (h0 : topological_space (has_ssubset reducibility_hints)) (h1 : preorder (has_ssubset reducibility_hints)) : order_closed_topology (has_ssubset reducibility_hints) := sorry --non-trivial
lemma new_lemma_170081 (h1 : ring std_gen) : strong_rank_condition std_gen := sorry --non-trivial
lemma new_lemma_170082 (h0 : add_group (non_unital_non_assoc_semiring char)) : is_add_cyclic (non_unital_non_assoc_semiring char) := sorry --non-trivial
lemma new_lemma_170083 (h0 : list (normed_lattice_add_comm_group (has_neg pos))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_170084 (h0 : function.extfun Type ring) : @rank_condition.{0} (add_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_170085 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (add_cancel_monoid.{0} (option.{0} unsigned)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_170086 (h0 : not (topological_space (add_left_cancel_monoid fun_info) -> false)) : @totally_disconnected_space.{0} (add_left_cancel_monoid.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (add_left_cancel_monoid.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_170087 (h0 : std_gen -> std_gen -> Prop) : is_trans std_gen h0 := sorry --non-trivial
lemma new_lemma_170088 (h0 : group (preorder num)) : is_cyclic (preorder num) := sorry --non-trivial
lemma new_lemma_170089 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (has_add.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_add.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_170090 (h2 : function.extfun (finset Type) (has_mem.mem (complete_semilattice_Sup string_imp))) : @irreducible_space.{0} (complete_semilattice_Sup.{0} string_imp) (@finset.pi.empty.{1 0} Type topological_space.{0} (complete_semilattice_Sup.{0} string_imp) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (complete_semilattice_Sup.{0} string_imp)) h2 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_170091 (h0 : set fun_info) : set.infinite h0 := sorry --non-trivial
lemma new_lemma_170092 (h0 : filter (semigroup (has_add (finset pos)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_170093 (h0 : topological_space (ordered_comm_monoid (has_Inf (has_Inf (has_add Type))))) : topological_space.separable_space (ordered_comm_monoid (has_Inf (has_Inf (has_add Type)))) := sorry --non-trivial
lemma new_lemma_170094 (h0 : functor.add_const (add_monoid (ring pos)) unsigned) : @add_monoid.fg.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (add_monoid.{0} (ring.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_170095 (h0 : add_monoid (has_one num)) : add_monoid.fg (has_one num) := sorry --non-trivial
lemma new_lemma_170096 (h0 : not (topological_space (random_gen num) -> false)) (h1 : function.extfun (random_gen num -> Type) (function.extfun (random_gen num))) : @is_seq_compact.{0} (random_gen.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (random_gen.{0} num)) h0) (@function.extfun_app.{1 1} (random_gen.{0} num) (λ (x : random_gen.{0} num), Prop) (@function.extfun_app.{2 1} (random_gen.{0} num → Type) (function.extfun.{1 1} (random_gen.{0} num)) h1 (λ (x : random_gen.{0} num), Prop)))  := sorry --non-trivial
lemma new_lemma_170097 (h0 : not (ring (comm_ring linarith.comp_source) -> false)) : @strong_rank_condition.{0} (comm_ring.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (comm_ring.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_170098 (h0 : topological_space (has_pos_part linarith.comp)) : t0_space (has_pos_part linarith.comp) := sorry --non-trivial
lemma new_lemma_170099 (h0 : topological_space (add_semigroup (option empty))) : locally_compact_space (add_semigroup (option empty)) := sorry --non-trivial
lemma new_lemma_170100 (h0 : topological_space (add_cancel_monoid (semigroup ennreal))) : topological_space.separable_space (add_cancel_monoid (semigroup ennreal)) := sorry --non-trivial
lemma new_lemma_170101 (h0 : ring (add_cancel_monoid (finset linarith.comp))) : is_domain (add_cancel_monoid (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_170102 (h0 : add_group (linear_ordered_semiring (has_norm fun_info))) : is_add_cyclic (linear_ordered_semiring (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_170103 (h0 : not (complete_lattice (uniform_space (mul_one_class char)) -> false)) : complete_lattice.is_Sup_finite_compact (uniform_space (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_170104 (h0 : topological_space (distrib (has_ssubset (has_ssubset char)))) : t0_space (distrib (has_ssubset (has_ssubset char))) := sorry --non-trivial
lemma new_lemma_170105 (h0 : fin has_zero.zero) : @separated_space.{0} (simple_graph.{0} pos) (@matrix.vec_empty.{0} (uniform_space.{0} (simple_graph.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_170106 (h0 : topological_space (has_add (mul_one_class Type))) : t0_space (has_add (mul_one_class Type)) := sorry --non-trivial
lemma new_lemma_170107 (h0 : has_le (semi_normed_ring linarith.ineq)) (h1 : semi_normed_ring linarith.ineq) : is_bot h1 := sorry --non-trivial
lemma new_lemma_170108 (h0 : function.extfun Type ring) : @is_domain.{0} (monoid.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_170109 (h0 : ring (has_Inf (has_Inf (has_Inf (has_Inf (has_Inf (has_Inf Type))))))) : strong_rank_condition (has_Inf (has_Inf (has_Inf (has_Inf (has_Inf (has_Inf Type)))))) := sorry --non-trivial
lemma new_lemma_170110 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (measurable_space.{0} string_imp) (@function.extfun_app.{2 1} Type add_group.{0} h0 (measurable_space.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_170111 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (semiring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semiring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_170112 (h1 : topological_space (normed_field char)) : totally_disconnected_space (normed_field char) := sorry --non-trivial
lemma new_lemma_170113 (h0 : ulower (fin has_zero.zero)) : matrix.vec_empty (matrix.vec_empty (ulower.up h0)) := sorry --non-trivial
lemma new_lemma_170114 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_170115 (h0 : topological_space (comm_group (normed_comm_ring name))) : discrete_topology (comm_group (normed_comm_ring name)) := sorry --non-trivial
lemma new_lemma_170116 (h0 : complete_lattice (has_nnnorm (denumerable to_additive.value_type))) : complete_lattice.is_Sup_finite_compact (has_nnnorm (denumerable to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_170117 (h0 : topological_space (boolean_algebra.core (has_neg Type))) : totally_separated_space (boolean_algebra.core (has_neg Type)) := sorry --non-trivial
lemma new_lemma_170118 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (canonically_linear_ordered_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (canonically_linear_ordered_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_170119 (h0 : topological_space (canonically_linear_ordered_monoid name)) : topological_space.separable_space (canonically_linear_ordered_monoid name) := sorry --non-trivial
lemma new_lemma_170120 (h0 : complete_lattice (add_comm_monoid num)) : is_atomistic (add_comm_monoid num) := sorry --non-trivial
lemma new_lemma_170121 (h0 : ring (topological_space (has_nnnorm (has_lt (has_nnnorm linarith.ineq))))) : strong_rank_condition (topological_space (has_nnnorm (has_lt (has_nnnorm linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_170122 (h0 : ring (ordered_comm_ring (has_add real))) : strong_rank_condition (ordered_comm_ring (has_add real)) := sorry --non-trivial
lemma new_lemma_170123 (h0 : topological_space (ring ennreal)) : normal_space (ring ennreal) := sorry --non-trivial
lemma new_lemma_170124 (h0 : uniform_space (filter empty)) : separated_space (filter empty) := sorry --non-trivial
lemma new_lemma_170125 (h0 : ring (nondiscrete_normed_field linarith.ineq)) : strong_rank_condition (nondiscrete_normed_field linarith.ineq) := sorry --non-trivial
lemma new_lemma_170126 (h0 : add_monoid (canonically_linear_ordered_monoid ennreal)) : add_monoid.fg (canonically_linear_ordered_monoid ennreal) := sorry --non-trivial
lemma new_lemma_170127 (h0 : topological_space (pseudo_emetric_space (add_comm_monoid (option (option empty))))) : irreducible_space (pseudo_emetric_space (add_comm_monoid (option (option empty)))) := sorry --non-trivial
lemma new_lemma_170128 (h0 : filter (complete_distrib_lattice (option unsigned))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_170129 (h0 : topological_space (semi_normed_ring (uniform_space (has_compl reducibility_hints)))) : totally_disconnected_space (semi_normed_ring (uniform_space (has_compl reducibility_hints))) := sorry --non-trivial
lemma new_lemma_170130 (h0 : topological_space (boolean_algebra (has_add Type))) : path_connected_space (boolean_algebra (has_add Type)) := sorry --non-trivial
lemma new_lemma_170131 (h0 : fin has_zero.zero) : @normalizer_condition.{1} (comm_semigroup.{1} Type) (@matrix.vec_empty.{1} (group.{1} (comm_semigroup.{1} Type)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)))))  := sorry --non-trivial
lemma new_lemma_170132 (h0 : list (has_star empty)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_170133 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem uniform_space)) : @separated_space.{0} (has_top.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) uniform_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) uniform_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_top.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_170134 (h0 : fin has_zero.zero) : @is_principal_ideal_ring.{0} (ordered_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ring.{0}) h0) (ordered_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_170135 (h0 : functor.add_const (monoid (left_cancel_monoid unsigned)) unsigned) : @monoid.fg.{0} (left_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (monoid.{0} (left_cancel_monoid.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_170136 (h0 : filter (has_union (has_top unsigned))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_170137 (h0 : uniform_space (has_to_string (comm_group (comm_group (semigroup Type))))) : complete_space (has_to_string (comm_group (comm_group (semigroup Type)))) := sorry --non-trivial
lemma new_lemma_170138 (h0 : monoid (denumerable string_imp)) : monoid.fg (denumerable string_imp) := sorry --non-trivial
lemma new_lemma_170139 (h0 : ordered_add_comm_monoid (add_comm_monoid (option (option ennreal)))) : archimedean (add_comm_monoid (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_170140 (h0 : functor.add_const (topological_space (has_zero Type)) linarith.comp) : @loc_path_connected_space.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_zero.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_170141 (h0 : group (id linarith.comp_source)) : is_cyclic (id linarith.comp_source) := sorry --non-trivial
lemma new_lemma_170142 (h0 : uniform_space (linear_ordered_semiring (semiring (has_top (semiring fun_info))))) : separated_space (linear_ordered_semiring (semiring (has_top (semiring fun_info)))) := sorry --non-trivial
lemma new_lemma_170143 (h0 : functor.add_const (function.extfun Type ordered_comm_monoid) name) : @has_exists_mul_of_le.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) name h0) (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_170144 (h0 : not (topological_space (option (semiring (semiring (semiring (semiring empty))))) -> false)) : @topological_space.separable_space.{0} (option.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} empty))))) (@classical.by_contradiction'.{1} (topological_space.{0} (option.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} empty)))))) h0)  := sorry --non-trivial
lemma new_lemma_170145 (h0 : prod (id unsigned) (id unsigned)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_170146 (h0 : add_comm_monoid Type -> Prop) : zzz_forall h0 := sorry --non-trivial
lemma new_lemma_170147 (h0 : functor.add_const (semiring (comm_group linarith.comp)) (ring (has_nndist pos))) : @is_noetherian_ring.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (semiring.{0} (comm_group.{0} linarith.comp)) (ring.{0} (has_nndist.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_170148 (h0 : ring (metric_space to_additive.value_type)) : is_domain (metric_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_170149 (h0 : function.extfun Type group) : @is_simple_group.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_170150 (h0 : complete_lattice (has_neg (boolean_algebra.core pos))) : is_atomistic (has_neg (boolean_algebra.core pos)) := sorry --non-trivial
lemma new_lemma_170151 (h0 : fin has_zero.zero) : @sequential_space.{0} (has_bot.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_bot.{0} pos))  := sorry --non-trivial
lemma new_lemma_170152 (h0 : functor.add_const (topological_space (has_nndist Type)) name) : @irreducible_space.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_nndist.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_170153 (h0 : functor.add_const (monoid (semigroup linarith.comp)) environment.implicit_infer_kind) : @monoid.fg.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (monoid.{0} (semigroup.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_170154 (h1 : complete_lattice (mul_one_class linarith.ineq)) : complete_lattice.is_Sup_finite_compact (mul_one_class linarith.ineq) := sorry --non-trivial
lemma new_lemma_170155 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem add_monoid)) : @add_monoid.fg.{0} (with_bot.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_monoid.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) add_monoid.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) add_monoid.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (with_bot.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_170156 (h0 : preorder (linear_ordered_comm_group_with_zero linarith.ineq)) (h1 : set (linear_ordered_comm_group_with_zero linarith.ineq)) : set.is_pwo h1 := sorry --non-trivial
lemma new_lemma_170157 (h1 : list linarith.ineq) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_170158 (h0 : functor.add_const (topological_space (left_cancel_monoid unsigned)) empty) : @path_connected_space.{0} (left_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_170159 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_inter.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inter.{0} num))  := sorry --non-trivial
lemma new_lemma_170160 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (complete_distrib_lattice.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (complete_distrib_lattice.{0} name))  := sorry --non-trivial
lemma new_lemma_170161 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_170162 (h0 : add_group (dlist (with_one string_imp))) : is_add_cyclic (dlist (with_one string_imp)) := sorry --non-trivial
lemma new_lemma_170163 (h0 : not (uniform_space (has_inv int) -> false)) : @complete_space.{0} (has_inv.{0} int) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_inv.{0} int)) h0)  := sorry --non-trivial
lemma new_lemma_170164 (h0 : Prop) (h1 : topological_space Prop) (h2 : topological_space.second_countable_topology Prop) : topological_space.countable_basis Prop (and h0) := sorry --non-trivial
lemma new_lemma_170165 (h0 : functor.add_const (ring (has_add environment.implicit_infer_kind)) linarith.comp) : @rank_condition.{0} (has_add.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (has_add.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_170166 (h0 : cancel_comm_monoid_with_zero (normed_linear_ordered_group unsigned)) : unique_factorization_monoid (normed_linear_ordered_group unsigned) := sorry --non-trivial
lemma new_lemma_170167 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (uniform_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (uniform_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_170168 (h1 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (has_top.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h1) (has_top.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_170169 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_cyclic.{1} (plift.{1} empty) (@function.extfun_app.{3 2} (Type 1) group.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 group.{1}) (plift.{1} empty))  := sorry --non-trivial
lemma new_lemma_170170 (h0 : not (complete_lattice (has_top linarith.ineq) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_top.{0} linarith.ineq) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_top.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_170171 (h0 : topological_space (with_one linarith.ineq)) : discrete_topology (with_one linarith.ineq) := sorry --non-trivial
lemma new_lemma_170172 (h0 : not (complete_lattice (complete_linear_order empty) -> false)) : @is_compactly_generated.{0} (complete_linear_order.{0} empty) (@classical.by_contradiction'.{1} (complete_lattice.{0} (complete_linear_order.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_170173 (h0 : ring (random_gen (has_norm (has_norm num)))) : rank_condition (random_gen (has_norm (has_norm num))) := sorry --non-trivial
lemma new_lemma_170174 (h0 : functor.add_const (group (has_neg name)) Type) : @normalizer_condition.{0} (has_neg.{0} name) (@functor.add_const.run.{0 1} (group.{0} (has_neg.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_170175 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (semigroup pos)) := sorry --non-trivial
lemma new_lemma_170176 (h1 : ring (random_gen fun_info)) : rank_condition (random_gen fun_info) := sorry --non-trivial
lemma new_lemma_170177 (h0 : monoid (random_gen linarith.comp_source)) : monoid.fg (random_gen linarith.comp_source) := sorry --non-trivial
lemma new_lemma_170178 (h0 : semiring (has_to_string (finset (finset (finset environment.implicit_infer_kind))))) : is_noetherian_ring (has_to_string (finset (finset (finset environment.implicit_infer_kind)))) := sorry --non-trivial
lemma new_lemma_170179 (h0 : functor.add_const (complete_lattice (option unsigned)) (option (option (option pos)))) : @is_atomistic.{0} (option.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (option.{0} unsigned)) (option.{0} (option.{0} (option.{0} pos))) h0)  := sorry --non-trivial
lemma new_lemma_170180 (h0 : ring (option (option unsigned))) : is_principal_ideal_ring (option (option unsigned)) := sorry --non-trivial
lemma new_lemma_170181 (h0 : not (uniform_space (add_right_cancel_monoid unsigned) -> false)) : @separated_space.{0} (add_right_cancel_monoid.{0} unsigned) (@classical.by_contradiction'.{1} (uniform_space.{0} (add_right_cancel_monoid.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_170182 (h0 : simple_graph linarith.ineq) (h1 h2 : linarith.ineq) : simple_graph.neighbor_set h0 h1 h2 := sorry --non-trivial
lemma new_lemma_170183 (h0 : add_group (has_lt (mul_one_class to_additive.value_type))) : is_add_cyclic (has_lt (mul_one_class to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_170184 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (sub_neg_monoid.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (sub_neg_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_170185 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @locally_compact_space.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_170186 (h0 : functor.add_const (uniform_space (boolean_algebra linarith.comp)) Type) : @complete_space.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 1} (uniform_space.{0} (boolean_algebra.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_170187 (h0 : function.extfun (finset ((Type -> Type) -> Type 1)) (has_mem.mem (function.extfun Type))) : @rank_condition.{0} (with_one.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@finset.pi.empty.{2 1} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) (function.extfun.{2 1} Type) (@function.extfun_app.{3 0} (finset.{2} ((Type → Type) → Type 1)) (@has_mem.mem.{2 2} ((Type → Type) → Type 1) (finset.{2} ((Type → Type) → Type 1)) (@finset.has_mem.{2} ((Type → Type) → Type 1)) (function.extfun.{2 1} Type)) h0 (@has_emptyc.emptyc.{2} (finset.{2} ((Type → Type) → Type 1)) (@finset.has_emptyc.{2} ((Type → Type) → Type 1))))) ring.{0}) (with_one.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_170188 (h0 : uniform_space (ordered_comm_monoid (has_neg (has_neg name)))) : complete_space (ordered_comm_monoid (has_neg (has_neg name))) := sorry --non-trivial
lemma new_lemma_170189 (h0 : topological_space (boolean_algebra.core (option (option pos)))) : locally_compact_space (boolean_algebra.core (option (option pos))) := sorry --non-trivial
lemma new_lemma_170190 (h0 : functor.add_const (function.extfun (Type 1) add_monoid) environment.implicit_infer_kind) : @add_monoid.fg.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) add_monoid.{1}) environment.implicit_infer_kind h0) (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_170191 (h0 : not (topological_space (has_append fun_info) -> false)) : @totally_disconnected_space.{0} (has_append.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (has_append.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_170192 (h0 : topological_space (has_nndist (finset (finset (finset linarith.comp))))) : t1_space (has_nndist (finset (finset (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_170193 (h0 : function.extfun Type (functor.add_const (topological_space (has_Inf linarith.comp)))) : @normal_space.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} linarith.comp)) pos (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (has_Inf.{0} linarith.comp))) h0 pos))  := sorry --non-trivial
lemma new_lemma_170194 (h1 : not (ring (topological_space char) -> false)) : @is_domain.{0} (topological_space.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (topological_space.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_170195 (h0 : topological_space (has_dist unsigned)) : topological_space.separable_space (has_dist unsigned) := sorry --non-trivial
lemma new_lemma_170196 (h0 : functor.add_const (group (linear_ordered_field ennreal)) (option pos)) : @is_simple_group.{0} (linear_ordered_field.{0} ennreal) (@functor.add_const.run.{0 0} (group.{0} (linear_ordered_field.{0} ennreal)) (option.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_170197 (h0 : functor.add_const (topological_space name) congr_arg_kind) : @path_connected_space.{0} name (@functor.add_const.run.{0 0} (topological_space.{0} name) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_170198 (h1 : pfun environment.projection_info Prop) (h2 : coe_sort (pfun.dom h1)) : pfun.as_subtype h1 h2 := sorry --non-trivial
lemma new_lemma_170199 (h0 : ring (linear_order empty)) : rank_condition (linear_order empty) := sorry --non-trivial
lemma new_lemma_170200 (h0 : group (has_union (has_norm linarith.comp))) : group.fg (has_union (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_170201 (h0 : function.extfun Type topological_space) : @t1_space.{0} (linear_ordered_field.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_field.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_170202 (h0 : monoid (denumerable (with_bot to_additive.value_type))) : monoid.fg (denumerable (with_bot to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_170203 (h0 : topological_space (semigroup (finset num))) : sequential_space (semigroup (finset num)) := sorry --non-trivial
lemma new_lemma_170204 (h0 : function.extfun Type group) : @is_cyclic.{0} (normed_comm_ring.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (normed_comm_ring.{0} num))  := sorry --non-trivial
lemma new_lemma_170205 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (linear_ordered_field.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_field.{0} empty))  := sorry --non-trivial
lemma new_lemma_170206 (h0 : functor.add_const (functor.comp complete_lattice has_neg pos) name) : @complete_lattice.is_Sup_finite_compact.{0} (has_neg.{0} pos) (@functor.comp.run.{0 0 0} complete_lattice.{0} has_neg.{0} pos (@functor.add_const.run.{0 0} (functor.comp.{0 0 0} complete_lattice.{0} has_neg.{0} pos) name h0))  := sorry --non-trivial
lemma new_lemma_170207 (h0 : functor.add_const (topological_space (ring name)) unsigned) : @normal_space.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_170208 (h0 : ring string) : strong_rank_condition string := sorry --non-trivial
lemma new_lemma_170209 (h0 : list (complete_distrib_lattice congr_arg_kind)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_170210 (h0 : not (uniform_space (has_lt to_additive.value_type) -> false)) : @complete_space.{0} (has_lt.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_lt.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_170211 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_170212 (h0 : topological_space (option (semiring (semiring empty)))) : locally_compact_space (option (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_170213 (h0 : functor.add_const (function.extfun Type add_monoid) linarith.comp) : @add_monoid.fg.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_monoid.{0}) linarith.comp h0) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_170214 (h0 : ring (semiring (normed_group unsigned))) : is_domain (semiring (normed_group unsigned)) := sorry --non-trivial
lemma new_lemma_170215 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (complete_distrib_lattice.{0} num) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (complete_distrib_lattice.{0} num))  := sorry --non-trivial
lemma new_lemma_170216 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (monoid_with_zero.{0} ennreal) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (monoid_with_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_170217 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (semigroup.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_170218 (h1 : not (topological_space (complete_semilattice_Sup congr_arg_kind) -> false)) : @discrete_topology.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (complete_semilattice_Sup.{0} congr_arg_kind)) h1)  := sorry --non-trivial
lemma new_lemma_170219 (h0 : functor.add_const (uniform_space (generalized_boolean_algebra name)) (ring name)) : @separated_space.{0} (generalized_boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (generalized_boolean_algebra.{0} name)) (ring.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_170220 (h0 : functor.add_const (topological_space (has_add unsigned)) environment.implicit_infer_kind) : @totally_separated_space.{0} (has_add.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_170221 (h0 : functor.add_const (topological_space (has_to_string unsigned)) linarith.comp) : @loc_path_connected_space.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_170222 (h0 : functor.add_const (group (ordered_ring congr_arg_kind)) unsigned) : @is_cyclic.{0} (ordered_ring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (group.{0} (ordered_ring.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_170223 (h0 : ring (has_bot (has_add Type))) : strong_rank_condition (has_bot (has_add Type)) := sorry --non-trivial
lemma new_lemma_170224 (h0 : filter (with_one (random_gen (has_ssubset (random_gen string_imp))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_170225 (h0 : function.extfun Type ring) : @rank_condition.{0} (ordered_comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (ordered_comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_170226 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (@id.{2} Type unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (@id.{2} Type unsigned))  := sorry --non-trivial
lemma new_lemma_170227 (h0 : filter (has_nndist (has_add pos))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_170228 (h0 : topological_space (complete_distrib_lattice (boolean_algebra.core name))) : discrete_topology (complete_distrib_lattice (boolean_algebra.core name)) := sorry --non-trivial
lemma new_lemma_170229 (h0 : functor.add_const (topological_space (ordered_ring empty)) num) : @t0_space.{0} (ordered_ring.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_170230 (h0 : not (has_mem.mem add_group has_emptyc.emptyc -> false)) : @is_add_cyclic.{0} (with_bot.{0} fun_info) (@function.extfun_app.{2 1} Type add_group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) add_group.{0} (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) add_group.{0} (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type)))) h0)) (with_bot.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_170231 (h0 : topological_space (ordered_comm_ring real)) : path_connected_space (ordered_comm_ring real) := sorry --non-trivial
lemma new_lemma_170232 (h0 : finset (ordered_ring empty)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_170233 (h0 : group (topological_space (random_gen linarith.ineq))) : group.fg (topological_space (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_170234 (h0 : not (add_comm_group (linear_ordered_comm_group_with_zero to_additive.value_type) -> false)) (h1 : not (has_norm (linear_ordered_comm_group_with_zero to_additive.value_type) -> false)) : @semi_normed_group.core.{0} (linear_ordered_comm_group_with_zero.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (add_comm_group.{0} (linear_ordered_comm_group_with_zero.{0} to_additive.value_type)) h0) (@classical.by_contradiction'.{1} (has_norm.{0} (linear_ordered_comm_group_with_zero.{0} to_additive.value_type)) h1)  := sorry --non-trivial
lemma new_lemma_170235 (h0 : not (topological_space (filter char) -> false)) : @totally_disconnected_space.{0} (filter.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (filter.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_170236 (h0 : function.extfun Type (functor.add_const (list (has_to_string pos)))) : palindrome (functor.add_const.run (function.extfun_app h0 linarith.comp)) := sorry --non-trivial
lemma new_lemma_170237 (h0 : ring (add_comm_semigroup (mul_one_class std_gen))) : strong_rank_condition (add_comm_semigroup (mul_one_class std_gen)) := sorry --non-trivial
lemma new_lemma_170238 (h0 : not (uniform_space (simple_graph linarith.comp_source) -> false)) : @complete_space.{0} (simple_graph.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (uniform_space.{0} (simple_graph.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_170239 (h0 : list (add_cancel_monoid (finset linarith.comp))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_170240 (h0 : functor.add_const (function.extfun Type topological_space) (finset pos)) : @totally_separated_space.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (finset.{0} pos) h0) (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_170241 (h0 : uniform_space (has_nndist (complete_semilattice_Sup linarith.comp))) : separated_space (has_nndist (complete_semilattice_Sup linarith.comp)) := sorry --non-trivial
lemma new_lemma_170242 (h0 : finset (has_nndist name)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_170243 (h0 : topological_space (has_add (has_pos_part pos))) : sequential_space (has_add (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_170244 (h0 : monoid (comm_group (has_add Type))) : monoid.fg (comm_group (has_add Type)) := sorry --non-trivial
lemma new_lemma_170245 (h0 : has_mem.mem (normed_group num) has_emptyc.emptyc) : @group.fg.{0} (normed_group.{0} num) (@finset.pi.empty.{1 0} Type group.{0} (normed_group.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_170246 (h1 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_inv.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (has_inv.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_170247 (h0 : function.extfun (distrib_lattice to_additive.value_type) (fun (x : distrib_lattice to_additive.value_type), Prop)) : set.infinite (function.extfun_app h0) := sorry --non-trivial
lemma new_lemma_170248 (h0 : finset (ordered_comm_monoid (semigroup (finset (has_neg (has_neg pos)))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_170249 (h0 : add_group (canonically_linear_ordered_monoid (has_add pos))) : is_add_cyclic (canonically_linear_ordered_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_170250 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (ordered_cancel_add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_cancel_add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_170251 (h0 : topological_space (add_comm_semigroup char)) (h2 : Prop) : is_closed (id (fun (h1 : add_comm_semigroup char), h2)) := sorry --non-trivial
lemma new_lemma_170252 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (linear_ordered_field.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_field.{0} pos))  := sorry --non-trivial
lemma new_lemma_170253 (h0 : functor.add_const (group (ordered_comm_monoid linarith.comp)) (has_pos_part (ring Type))) : @normalizer_condition.{0} (ordered_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (group.{0} (ordered_comm_monoid.{0} linarith.comp)) (has_pos_part.{1} (ring.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_170254 (h0 : functor.add_const (topological_space ennreal) ennreal) : preirreducible_space ennreal := sorry --non-trivial
lemma new_lemma_170255 (h0 : ring (boolean_algebra (has_neg (has_add (has_add pos))))) : rank_condition (boolean_algebra (has_neg (has_add (has_add pos)))) := sorry --non-trivial
lemma new_lemma_170256 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_inter.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inter.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_170257 (h2 : group (semi_normed_ring char)) : is_cyclic (semi_normed_ring char) := sorry --non-trivial
lemma new_lemma_170258 (h0 : topological_space (has_inv char)) : totally_disconnected_space (has_inv char) := sorry --non-trivial
lemma new_lemma_170259 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @preirreducible_space.{1} (generalized_boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (generalized_boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_170260 (h2 : group string_imp) : normalizer_condition string_imp := sorry --non-trivial
lemma new_lemma_170261 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (sub_neg_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (sub_neg_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_170262 (h0 : topological_space (has_add (ring Type))) : normal_space (has_add (ring Type)) := sorry --non-trivial
lemma new_lemma_170263 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (semigroup.{0} name) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_170264 (h0 : functor.add_const (function.extfun Type cancel_comm_monoid_with_zero) name) : @unique_factorization_monoid.{0} (semigroup.{0} name) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type cancel_comm_monoid_with_zero.{0}) name h0) (semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_170265 (h0 : functor.comp topological_space add_cancel_monoid Type) : @t1_space.{1} (add_cancel_monoid.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} add_cancel_monoid.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_170266 (h0 : functor.add_const (uniform_space (has_Inf real)) linarith.comp) : @separated_space.{0} (has_Inf.{0} real) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_Inf.{0} real)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_170267 (h0 : ring (semiring (option empty))) : strong_rank_condition (semiring (option empty)) := sorry --non-trivial
lemma new_lemma_170268 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @is_add_cyclic.{0} (has_inv.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) add_group.{0}) (has_inv.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_170269 (h6 : uniform_space (has_compl linarith.comp_source)) : complete_space (has_compl linarith.comp_source) := sorry --non-trivial
lemma new_lemma_170270 (h0 : complete_lattice (ring empty)) : complete_lattice.is_Sup_finite_compact (ring empty) := sorry --non-trivial
lemma new_lemma_170271 (h0 : topological_space (normed_group linarith.comp)) : discrete_topology (normed_group linarith.comp) := sorry --non-trivial
lemma new_lemma_170272 (h0 : functor.add_const (ring (semigroup (has_to_string pos))) linarith.comp) : @is_domain.{0} (semigroup.{0} (has_to_string.{0} pos)) (@functor.add_const.run.{0 0} (ring.{0} (semigroup.{0} (has_to_string.{0} pos))) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_170273 (h0 : functor.add_const (topological_space (boolean_algebra linarith.comp)) (boolean_algebra linarith.comp)) : @discrete_topology.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} linarith.comp)) (boolean_algebra.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_170274 (h0 : pos -> pos -> Prop) : reflexive h0 := sorry --non-trivial
lemma new_lemma_170275 (h0 : functor.add_const (topological_space (boolean_algebra.core linarith.comp)) linarith.comp) : @preconnected_space.{0} (boolean_algebra.core.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_170276 (h0 : add_monoid (add_cancel_monoid (normed_comm_ring name))) : add_monoid.fg (add_cancel_monoid (normed_comm_ring name)) := sorry --non-trivial
lemma new_lemma_170277 (h0 : functor.add_const (topological_space (add_cancel_monoid empty)) unsigned) : @t1_space.{0} (add_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_170278 (h0 : topological_space (has_Inf (has_neg (has_Inf linarith.comp)))) : topological_space.separable_space (has_Inf (has_neg (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_170279 (h0 : ordered_add_comm_monoid (boolean_algebra (has_nndist name))) : archimedean (boolean_algebra (has_nndist name)) := sorry --non-trivial
lemma new_lemma_170280 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (left_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (left_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_170281 (h0 : filter (comm_group (comm_group (has_to_string Type)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_170282 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_zero.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_zero.{0} name))  := sorry --non-trivial
lemma new_lemma_170283 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (has_norm.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (has_norm.{0} empty))  := sorry --non-trivial
lemma new_lemma_170284 (h0 : functor.add_const (cancel_comm_monoid_with_zero (comm_group Type)) name) : @unique_factorization_monoid.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (cancel_comm_monoid_with_zero.{1} (comm_group.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_170285 (h0 : topological_space (with_bot (measurable_space linarith.comp))) : irreducible_space (with_bot (measurable_space linarith.comp)) := sorry --non-trivial
lemma new_lemma_170286 (h0 : monoid (has_to_string (finset linarith.comp))) : monoid.fg (has_to_string (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_170287 (h0 : group (pseudo_metric_space (option (option ennreal)))) : is_simple_group (pseudo_metric_space (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_170288 (h0 : group (has_union (has_norm empty))) : normalizer_condition (has_union (has_norm empty)) := sorry --non-trivial
lemma new_lemma_170289 (h0 : semiring (has_to_string (mul_zero_class name))) : is_noetherian_ring (has_to_string (mul_zero_class name)) := sorry --non-trivial
lemma new_lemma_170290 (h0 : complete_lattice (has_emptyc (has_norm to_additive.value_type))) : complete_lattice.is_Sup_finite_compact (has_emptyc (has_norm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_170291 (h0 : topological_space (semi_normed_comm_ring (has_nnnorm (random_gen linarith.ineq)))) : totally_disconnected_space (semi_normed_comm_ring (has_nnnorm (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_170292 (h0 : functor.add_const (topological_space (has_zero pos)) linarith.comp) : @t0_space.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_170293 (h0 : functor.add_const (topological_space (semiring unsigned)) congr_arg_kind) : @t1_space.{0} (semiring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (semiring.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_170294 (h0 : topological_space (topological_space linarith.ineq)) : t0_space (topological_space linarith.ineq) := sorry --non-trivial
lemma new_lemma_170295 (h0 : ring (semiring unsigned)) : is_principal_ideal_ring (semiring unsigned) := sorry --non-trivial
lemma new_lemma_170296 (h0 : functor.add_const (topological_space (has_neg_part environment.implicit_infer_kind)) linarith.comp) : @preconnected_space.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_170297 (h0 : functor.add_const (add_monoid (has_neg_part pos)) unsigned) : @add_monoid.fg.{0} (has_neg_part.{0} pos) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_neg_part.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_170298 (h0 : topological_space (semigroup (has_to_string (ring (ring environment.implicit_infer_kind))))) : totally_disconnected_space (semigroup (has_to_string (ring (ring environment.implicit_infer_kind)))) := sorry --non-trivial
lemma new_lemma_170299 (h0 : topological_space (has_append linarith.ineq)) : path_connected_space (has_append linarith.ineq) := sorry --non-trivial
lemma new_lemma_170300 (h0 : uniform_space (linear_ordered_field congr_arg_kind)) : complete_space (linear_ordered_field congr_arg_kind) := sorry --non-trivial
lemma new_lemma_170301 (h0 : semiring (add_comm_monoid (finset (finset (finset Type))))) : is_noetherian_ring (add_comm_monoid (finset (finset (finset Type)))) := sorry --non-trivial
lemma new_lemma_170302 (h0 : topological_space (preorder (mul_one_class enat))) : t0_space (preorder (mul_one_class enat)) := sorry --non-trivial
lemma new_lemma_170303 (h1 : topological_space (has_emptyc linarith.comp_source)) : path_connected_space (has_emptyc linarith.comp_source) := sorry --non-trivial
lemma new_lemma_170304 (h0 : functor.add_const (topological_space (semigroup Type)) linarith.comp) : @regular_space.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (semigroup.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_170305 (h0 : list (boolean_algebra (comm_group (has_add (semigroup Type))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_170306 (h0 : functor.add_const (topological_space (has_to_string pos)) environment.implicit_infer_kind) : @sequential_space.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_170307 (h0 : topological_space (has_nnnorm (random_gen string_imp))) : path_connected_space (has_nnnorm (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_170308 (h0 : finset (has_zero ennreal) -> finset (has_zero ennreal) -> Prop) : is_symm (finset (has_zero ennreal)) h0 := sorry --non-trivial
lemma new_lemma_170309 (h0 : topological_space (linear_ordered_field (option congr_arg_kind))) : locally_compact_space (linear_ordered_field (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_170310 (h0 : group (semi_normed_ring linarith.comp_source)) : is_cyclic (semi_normed_ring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_170311 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (has_star.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_star.{0} num))  := sorry --non-trivial
lemma new_lemma_170312 (h0 : not (group (has_emptyc (has_inv linarith.ineq)) -> false)) : @group.fg.{0} (has_emptyc.{0} (has_inv.{0} linarith.ineq)) (@classical.by_contradiction'.{1} (group.{0} (has_emptyc.{0} (has_inv.{0} linarith.ineq))) h0)  := sorry --non-trivial
lemma new_lemma_170313 (h1 : topological_space (has_ssubset char)) : totally_disconnected_space (has_ssubset char) := sorry --non-trivial
lemma new_lemma_170314 (h0 : add_group (has_inv to_additive.value_type)) : is_add_cyclic (has_inv to_additive.value_type) := sorry --non-trivial
lemma new_lemma_170315 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (semigroup name)) := sorry --non-trivial
lemma new_lemma_170316 (h0 : has_lt (non_unital_non_assoc_semiring to_additive.value_type)) : no_max_order (non_unital_non_assoc_semiring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_170317 (h0 : group (canonically_linear_ordered_monoid (option pos))) : normalizer_condition (canonically_linear_ordered_monoid (option pos)) := sorry --non-trivial
lemma new_lemma_170318 (h0 : topological_space (boolean_algebra (finset (finset linarith.comp)))) : totally_disconnected_space (boolean_algebra (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_170319 (h0 : topological_space (comm_ring (has_ssubset (distrib_lattice string_imp)))) : totally_disconnected_space (comm_ring (has_ssubset (distrib_lattice string_imp))) := sorry --non-trivial
lemma new_lemma_170320 (h0 : ring (add_left_cancel_monoid (has_nnnorm (has_ssubset (random_gen linarith.comp_source))))) : is_domain (add_left_cancel_monoid (has_nnnorm (has_ssubset (random_gen linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_170321 (h0 : add_group (add_semigroup (semiring (semiring empty)))) : is_add_cyclic (add_semigroup (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_170322 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_simple_group.{0} (ring.{0} (option.{0} ennreal)) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (ring.{0} (option.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_170323 (h0 : semiring (has_neg (has_neg pos))) : is_noetherian_ring (has_neg (has_neg pos)) := sorry --non-trivial
lemma new_lemma_170324 (h0 : topological_space (left_cancel_monoid empty)) : loc_path_connected_space (left_cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_170325 (h0 : functor.add_const (monoid (boolean_algebra.core Type)) pos) : @monoid.fg.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (monoid.{1} (boolean_algebra.core.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_170326 (h0 : topological_space (has_compl (mul_one_class fun_info))) (h1 : add_group (has_compl (mul_one_class fun_info))) : topological_add_group (has_compl (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_170327 (h0 : ring (semiring (has_norm congr_arg_kind))) : strong_rank_condition (semiring (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_170328 (h0 : semiring (comm_monoid congr_arg_kind)) : is_noetherian_ring (comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_170329 (h0 : topological_space (normed_comm_ring (comm_group name))) : preconnected_space (normed_comm_ring (comm_group name)) := sorry --non-trivial
lemma new_lemma_170330 (h0 : ordered_add_comm_monoid (cancel_monoid (add_comm_monoid name))) : archimedean (cancel_monoid (add_comm_monoid name)) := sorry --non-trivial
lemma new_lemma_170331 (h0 : uniform_space (has_add (has_nnnorm (has_nnnorm linarith.comp_source)))) : complete_space (has_add (has_nnnorm (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_170332 (h0 : not (ring (has_lt string_imp) -> false)) : @strong_rank_condition.{0} (has_lt.{0} string_imp) (@classical.by_contradiction'.{1} (ring.{0} (has_lt.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_170333 (h0 : functor.add_const (group (left_cancel_semigroup congr_arg_kind)) (semiring (semiring num))) : @group.fg.{0} (left_cancel_semigroup.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (group.{0} (left_cancel_semigroup.{0} congr_arg_kind)) (semiring.{0} (semiring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_170334 (h0 : function.extfun Type (functor.add_const (topological_space (has_Sup congr_arg_kind)))) : @topological_space.separable_space.{0} (has_Sup.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Sup.{0} congr_arg_kind)) (semiring.{0} empty) (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (has_Sup.{0} congr_arg_kind))) h0 (semiring.{0} empty)))  := sorry --non-trivial
lemma new_lemma_170335 (h0 : monoid (has_norm linarith.comp_source)) (h1 : add_group (star_monoid (has_norm linarith.comp_source))) : is_add_cyclic (star_monoid (has_norm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_170336 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) (h1 : has_inf to_additive.value_type) : @has_measurable_inf.{0} to_additive.value_type (@function.extfun_app.{2 1} Type measurable_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) measurable_space.{0}) to_additive.value_type) h1  := sorry --non-trivial
lemma new_lemma_170337 (h0 : topological_space (linear_ordered_semiring (random_gen empty))) : normal_space (linear_ordered_semiring (random_gen empty)) := sorry --non-trivial
lemma new_lemma_170338 (h0 : not (group (metric_space empty) -> false)) : @normalizer_condition.{0} (metric_space.{0} empty) (@classical.by_contradiction'.{1} (group.{0} (metric_space.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_170339 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_170340 (h0 : group (with_one (random_gen linarith.comp_source))) : group.fg (with_one (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_170341 (h0 : group (finset (lex name))) : group.fg (finset (lex name)) := sorry --non-trivial
lemma new_lemma_170342 (h0 : monoid (partial_order (semiring (semiring num)))) : monoid.fg (partial_order (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_170343 (h0 : ring (has_nnnorm (has_lt (mul_one_class std_gen)))) : rank_condition (has_nnnorm (has_lt (mul_one_class std_gen))) := sorry --non-trivial
lemma new_lemma_170344 (h0 : functor.add_const (topological_space (bin_tree congr_arg_kind)) congr_arg_kind) : @irreducible_space.{0} (bin_tree.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (bin_tree.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_170345 (h0 : topological_space (ring unsigned)) : locally_compact_space (ring unsigned) := sorry --non-trivial
lemma new_lemma_170346 (h0 : list (dlist to_additive.value_type)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_170347 (h0 : not (has_mem.mem (has_norm (has_top linarith.comp_source)) has_emptyc.emptyc -> false)) : @totally_separated_space.{0} (has_norm.{0} (has_top.{0} linarith.comp_source)) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_norm.{0} (has_top.{0} linarith.comp_source)) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_norm.{0} (has_top.{0} linarith.comp_source)) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_170348 (h1 : group (complete_semilattice_Sup (has_emptyc string_imp))) : is_cyclic (complete_semilattice_Sup (has_emptyc string_imp)) := sorry --non-trivial
lemma new_lemma_170349 (h0 : topological_space (has_inter congr_arg_kind)) : loc_path_connected_space (has_inter congr_arg_kind) := sorry --non-trivial
lemma new_lemma_170350 (h0 : functor.add_const (topological_space (normed_comm_ring linarith.comp)) (has_nndist pos)) : @loc_path_connected_space.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} linarith.comp)) (has_nndist.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_170351 (h0 : topological_space (has_edist (left_cancel_monoid congr_arg_kind))) : locally_compact_space (has_edist (left_cancel_monoid congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_170352 (h0 : functor.add_const (topological_space (has_to_string environment.implicit_infer_kind)) linarith.comp) : @path_connected_space.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_170353 (h0 : topological_space (id (semiring num))) : locally_compact_space (id (semiring num)) := sorry --non-trivial
lemma new_lemma_170354 (h0 : topological_space (has_bot (has_add Type))) : loc_path_connected_space (has_bot (has_add Type)) := sorry --non-trivial
lemma new_lemma_170355 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (has_neg.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_neg.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_170356 (h0 : functor.add_const (semiring (ring pos)) Type) : @is_noetherian_ring.{0} (ring.{0} pos) (@functor.add_const.run.{0 1} (semiring.{0} (ring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_170357 (h0 : function.extfun (finset Type -> Prop) (function.extfun (finset Type))) : @monoid.fg.{0} (has_one.{0} empty) (@finset.pi.empty.{1 0} Type monoid.{0} (has_one.{0} empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_one.{0} empty)) (@function.extfun_app.{2 0} (finset.{1} Type → Prop) (function.extfun.{2 0} (finset.{1} Type)) h0 (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_one.{0} empty))) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_170358 (h0 : semiring (has_neg_part Type)) : is_noetherian_ring (has_neg_part Type) := sorry --non-trivial
lemma new_lemma_170359 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (id linarith.comp)) := sorry --non-trivial
lemma new_lemma_170360 (h0 : semiring (has_neg pos)) : is_noetherian_ring (has_neg pos) := sorry --non-trivial
lemma new_lemma_170361 (h0 : monoid (random_gen (has_top linarith.ineq))) : monoid.fg (random_gen (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_170362 (h0 : topological_space (has_nndist (has_to_string environment.implicit_infer_kind))) : loc_path_connected_space (has_nndist (has_to_string environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_170363 (h0 : topological_space (has_add (finset linarith.comp))) : t0_space (has_add (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_170364 (h0 : filter (has_top (has_inv linarith.ineq))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_170365 (h0 : ring (add_group (has_top (has_top (has_union congr_arg_kind))))) : strong_rank_condition (add_group (has_top (has_top (has_union congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_170366 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (sub_neg_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (sub_neg_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_170367 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @regular_space.{1} (generalized_boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (generalized_boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_170368 (h0 : functor.add_const (complete_lattice (semiring congr_arg_kind)) congr_arg_kind) : @complete_lattice.is_Sup_finite_compact.{0} (semiring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (semiring.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_170369 (h0 : function.extfun Type (functor.add_const (complete_lattice (has_Sup empty)))) : @complete_lattice.is_Sup_finite_compact.{0} (has_Sup.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_Sup.{0} empty)) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (complete_lattice.{0} (has_Sup.{0} empty))) h0 num))  := sorry --non-trivial
lemma new_lemma_170370 (h0 : complete_lattice (add_comm_semigroup string.iterator_imp)) : complete_lattice.is_Sup_finite_compact (add_comm_semigroup string.iterator_imp) := sorry --non-trivial
lemma new_lemma_170371 (h0 : function.extfun Type group) : @group.fg.{0} (non_assoc_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (non_assoc_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_170372 (h0 : add_monoid (linear_ordered_semiring (semiring (has_norm congr_arg_kind)))) : add_monoid.fg (linear_ordered_semiring (semiring (has_norm congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_170373 (h0 : ring (measurable_space fun_info)) : rank_condition (measurable_space fun_info) := sorry --non-trivial
lemma new_lemma_170374 (h0 : not (complete_lattice (add_group linarith.comp) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (add_group.{0} linarith.comp) (@classical.by_contradiction'.{1} (complete_lattice.{0} (add_group.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_170375 (h0 : ordered_comm_monoid (canonically_ordered_comm_semiring (option ennreal))) : has_exists_mul_of_le (canonically_ordered_comm_semiring (option ennreal)) := sorry --non-trivial
lemma new_lemma_170376 (h0 : functor.add_const (function.extfun Type monoid) linarith.comp) : @monoid.fg.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type monoid.{0}) linarith.comp h0) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_170377 (h0 : functor.add_const (topological_space (ordered_comm_monoid linarith.comp)) Type) : @preirreducible_space.{0} (ordered_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (ordered_comm_monoid.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_170378 (h1 : topological_space congr_arg_kind) : irreducible_space congr_arg_kind := sorry --non-trivial
lemma new_lemma_170379 (h0 : functor.add_const (topological_space (has_to_string environment.implicit_infer_kind)) pos) : @locally_compact_space.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_170380 (h1 : topological_space (has_nnnorm (random_gen char))) : totally_disconnected_space (has_nnnorm (random_gen char)) := sorry --non-trivial
lemma new_lemma_170381 (h0 : semiring (finset (ring pos))) : is_noetherian_ring (finset (ring pos)) := sorry --non-trivial
lemma new_lemma_170382 (h1 : complete_lattice Type) : is_compactly_generated Type := sorry --non-trivial
lemma new_lemma_170383 (h0 : topological_space (has_to_string (add_cancel_monoid (has_add Type)))) : path_connected_space (has_to_string (add_cancel_monoid (has_add Type))) := sorry --non-trivial
lemma new_lemma_170384 (h0 : functor.add_const (topological_space (mul_zero_class unsigned)) empty) : @path_connected_space.{0} (mul_zero_class.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_170385 (h2 : not (ring (has_append char) -> false)) : @strong_rank_condition.{0} (has_append.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (has_append.{0} char)) h2)  := sorry --non-trivial
lemma new_lemma_170386 (h2 : topological_space (with_zero fun_info)) : t0_space (with_zero fun_info) := sorry --non-trivial
lemma new_lemma_170387 (h0 : ordered_add_comm_monoid (comm_monoid congr_arg_kind)) : archimedean (comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_170388 (h0 : function.extfun (finset Type) (has_mem.mem (has_top fun_info))) : @rank_condition.{0} (has_top.{0} fun_info) (@finset.pi.empty.{1 0} Type ring.{0} (has_top.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_top.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_170389 (h0 : topological_space (has_pos_part (has_neg name))) : t0_space (has_pos_part (has_neg name)) := sorry --non-trivial
lemma new_lemma_170390 (h0 : measurable_space std_gen) (h1 : has_add std_gen) (h2 : measure_theory.measure std_gen) : measure_theory.measure.is_add_left_invariant h2 := sorry --non-trivial
lemma new_lemma_170391 (h0 : complete_lattice (has_nndist (cancel_monoid name))) : is_compactly_generated (has_nndist (cancel_monoid name)) := sorry --non-trivial
lemma new_lemma_170392 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (linear_ordered_semiring.{0} fun_info) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (linear_ordered_semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_170393 (h0 : functor.add_const (add_monoid Type) (has_neg (finset (finset (finset environment.implicit_infer_kind))))) : @add_monoid.fg.{1} Type (@functor.add_const.run.{1 0} (add_monoid.{1} Type) (has_neg.{0} (finset.{0} (finset.{0} (finset.{0} environment.implicit_infer_kind)))) h0)  := sorry --non-trivial
lemma new_lemma_170394 (h0 : ring (uniform_space (mul_one_class (metric_space linarith.comp_source)))) : strong_rank_condition (uniform_space (mul_one_class (metric_space linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_170395 (h0 : functor.add_const Prop (has_neg_part environment.implicit_infer_kind)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_170396 (h0 : group (has_neg (has_add ennreal))) : group.fg (has_neg (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_170397 (h0 : list (has_neg (finset (has_add (finset name))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_170398 (h0 : not (group (add_cancel_comm_monoid linarith.comp_source) -> false)) : @is_cyclic.{0} (add_cancel_comm_monoid.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (group.{0} (add_cancel_comm_monoid.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_170399 (h0 : group (complete_distrib_lattice (has_pos_part (has_add Type)))) : normalizer_condition (complete_distrib_lattice (has_pos_part (has_add Type))) := sorry --non-trivial
lemma new_lemma_170400 (h0 : functor.add_const (topological_space (bin_tree empty)) num) : @preirreducible_space.{0} (bin_tree.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (bin_tree.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_170401 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (has_top.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_top.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_170402 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} auto.case_option (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) auto.case_option)  := sorry --non-trivial
lemma new_lemma_170403 (h0 : topological_space (pseudo_metric_space ennreal)) : irreducible_space (pseudo_metric_space ennreal) := sorry --non-trivial
lemma new_lemma_170404 (h0 : functor.add_const (add_group (ordered_comm_ring pos)) Type) : @is_add_cyclic.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 1} (add_group.{0} (ordered_comm_ring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_170405 (h5 : measurable_space (nondiscrete_normed_field linarith.ineq)) (h6 : measure_theory.measure (nondiscrete_normed_field linarith.ineq)) : measure_theory.is_finite_measure h6 := sorry --non-trivial
lemma new_lemma_170406 (h0 : filter (complete_semilattice_Sup (random_gen (random_gen linarith.comp_source)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_170407 (h0 : function.extfun Type group) : @normalizer_condition.{0} (complete_semilattice_Sup.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} h0 (complete_semilattice_Sup.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_170408 (h0 : not (has_mem.mem linarith.ineq has_emptyc.emptyc -> false)) : @is_domain.{0} linarith.ineq (@finset.pi.empty.{1 0} Type ring.{0} linarith.ineq (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) linarith.ineq (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_170409 (h0 : topological_space (has_one (has_norm empty))) : locally_compact_space (has_one (has_norm empty)) := sorry --non-trivial
lemma new_lemma_170410 (h0 : not (function.extfun Type monoid -> false)) : @monoid.fg.{0} (left_cancel_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type monoid.{0}) h0) (left_cancel_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_170411 (h0 : uniform_space (ordered_comm_monoid (ring (ring (finset (ring linarith.comp)))))) : complete_space (ordered_comm_monoid (ring (ring (finset (ring linarith.comp))))) := sorry --non-trivial
lemma new_lemma_170412 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (has_pos_part.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_pos_part.{0} num))  := sorry --non-trivial
lemma new_lemma_170413 (h0 : functor.add_const (topological_space (ring environment.implicit_infer_kind)) name) : @t1_space.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_170414 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (normed_linear_ordered_group.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (normed_linear_ordered_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_170415 (h0 : ring (ordered_comm_monoid real)) : rank_condition (ordered_comm_monoid real) := sorry --non-trivial
lemma new_lemma_170416 (h0 : functor.add_const (topological_space (boolean_algebra Type)) (has_add Type)) : @irreducible_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (boolean_algebra.{1} Type)) (has_add.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_170417 (h0 : functor.add_const (topological_space (has_to_string linarith.comp)) pos) : @normal_space.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_170418 (h0 : group (has_bot (sub_neg_monoid (boolean_algebra Type)))) : group.fg (has_bot (sub_neg_monoid (boolean_algebra Type))) := sorry --non-trivial
lemma new_lemma_170419 (h0 : topological_space (denumerable (has_norm to_additive.value_type))) : t0_space (denumerable (has_norm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_170420 (h0 : functor.add_const (monoid (normed_linear_ordered_group empty)) empty) : @monoid.fg.{0} (normed_linear_ordered_group.{0} empty) (@functor.add_const.run.{0 0} (monoid.{0} (normed_linear_ordered_group.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_170421 (h0 : semiring (semigroup (mul_zero_class name))) : is_noetherian_ring (semigroup (mul_zero_class name)) := sorry --non-trivial
lemma new_lemma_170422 (h0 : topological_space (ring (ordered_ring (has_add (ordered_ring (ring (has_Inf (ring linarith.comp)))))))) : t0_space (ring (ordered_ring (has_add (ordered_ring (ring (has_Inf (ring linarith.comp))))))) := sorry --non-trivial
lemma new_lemma_170423 (h1 : not (topological_space (normed_field ennreal) -> false)) : @t0_space.{0} (normed_field.{0} ennreal) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_field.{0} ennreal)) h1)  := sorry --non-trivial
lemma new_lemma_170424 (h0 : ring (has_Inf (finset (finset linarith.comp)))) : is_domain (has_Inf (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_170425 (h0 : topological_space (has_to_string (has_add name))) : path_connected_space (has_to_string (has_add name)) := sorry --non-trivial
lemma new_lemma_170426 (h0 : functor.add_const (group (has_nndist Type)) unsigned) : @is_cyclic.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (has_nndist.{1} Type)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_170427 (h0 : topological_space (finset (semigroup Type))) : loc_path_connected_space (finset (semigroup Type)) := sorry --non-trivial
lemma new_lemma_170428 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (comm_group.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (comm_group.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_170429 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (has_bot.{0} linarith.comp) (@function.extfun_app.{2 1} Type monoid.{0} h0 (has_bot.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_170430 (h0 : functor.add_const (uniform_space (has_zero name)) linarith.comp) : @complete_space.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_zero.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_170431 (h0 : functor.add_const (ring (ordered_comm_monoid linarith.comp)) (has_neg linarith.comp)) : @rank_condition.{0} (ordered_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (ordered_comm_monoid.{0} linarith.comp)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_170432 (h0 : topological_space (cancel_monoid (option (option ennreal)))) : totally_disconnected_space (cancel_monoid (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_170433 (h0 : functor.add_const (uniform_space (has_neg pos)) pos) : @complete_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_neg.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_170434 (h0 : fin has_zero.zero) : @normal_space.{0} (add_comm_monoid.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (add_comm_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_170435 (h0 : topological_space (boolean_algebra (finset environment.implicit_infer_kind))) : discrete_topology (boolean_algebra (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_170436 (h0 : topological_space (nondiscrete_normed_field (add_comm_semigroup string.iterator_imp))) (h1 : set (nondiscrete_normed_field (add_comm_semigroup string.iterator_imp))) : is_path_connected h1 := sorry --non-trivial
lemma new_lemma_170437 (h0 : functor.add_const (topological_space (finset pos)) (finset linarith.comp)) : @path_connected_space.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} pos)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_170438 (h0 : topological_space (semiring (has_norm num))) : locally_compact_space (semiring (has_norm num)) := sorry --non-trivial
lemma new_lemma_170439 (h0 : topological_space (encodable (denumerable linarith.ineq))) : t0_space (encodable (denumerable linarith.ineq)) := sorry --non-trivial
lemma new_lemma_170440 (h0 : functor.add_const (complete_lattice (normed_linear_ordered_group congr_arg_kind)) congr_arg_kind) : @is_compactly_generated.{0} (normed_linear_ordered_group.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (normed_linear_ordered_group.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_170441 (h0 : functor.add_const (ordered_add_comm_monoid (cancel_monoid unsigned)) pos) : @archimedean.{0} (cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (cancel_monoid.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_170442 (h0 : ring (add_cancel_monoid num)) : is_principal_ideal_ring (add_cancel_monoid num) := sorry --non-trivial
lemma new_lemma_170443 (h0 : functor.add_const (ordered_comm_monoid (has_to_string linarith.comp)) Type) : @has_exists_mul_of_le.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (has_to_string.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_170444 (h0 : add_group (free_add_monoid (option unsigned))) : is_add_cyclic (free_add_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_170445 (h0 : finset (canonically_linear_ordered_monoid unsigned)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_170446 (h0 : ring (has_neg (cancel_monoid unsigned))) : is_principal_ideal_ring (has_neg (cancel_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_170447 (h0 : ordered_add_comm_monoid (finset (has_to_string congr_arg_kind))) : archimedean (finset (has_to_string congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_170448 (h0 : functor.add_const (functor.add_const (ring bool) empty) empty) : @is_domain.{0} bool (@functor.add_const.run.{0 0} (ring.{0} bool) empty (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (ring.{0} bool) empty) empty h0))  := sorry --non-trivial
lemma new_lemma_170449 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (normed_linear_ordered_group.{0} (add_left_cancel_semigroup.{0} empty)) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (normed_linear_ordered_group.{0} (add_left_cancel_semigroup.{0} empty)))  := sorry --non-trivial
lemma new_lemma_170450 (h0 : group (semigroup (finset linarith.comp))) : is_simple_group (semigroup (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_170451 (h0 : topological_space (left_cancel_semigroup (semiring (semiring empty)))) : totally_disconnected_space (left_cancel_semigroup (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_170452 (h0 : ring (has_compl (random_gen (random_gen char)))) : strong_rank_condition (has_compl (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_170453 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) to_additive.value_type) := sorry --non-trivial
lemma new_lemma_170454 (h0 : ring (has_append (has_nnnorm (has_nnnorm linarith.comp_source)))) : rank_condition (has_append (has_nnnorm (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_170455 (h0 : not (function.extfun Type topological_space -> false)) : @irreducible_space.{0} (complete_semilattice_Sup.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (complete_semilattice_Sup.{0} empty))  := sorry --non-trivial
lemma new_lemma_170456 (h0 : topological_space (with_zero (has_nnnorm (random_gen linarith.comp_source)))) : totally_disconnected_space (with_zero (has_nnnorm (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_170457 (h0 : ring (distrib (comm_ring (comm_ring (has_nnnorm linarith.ineq))))) : rank_condition (distrib (comm_ring (comm_ring (has_nnnorm linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_170458 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (pseudo_metric_space.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (pseudo_metric_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_170459 (h0 : functor.add_const (topological_space (finset linarith.comp)) pos) : @regular_space.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_170460 (h0 : measurable_space (ordered_comm_monoid Type)) (h1 : has_div (ordered_comm_monoid Type)) : has_measurable_div₂ (ordered_comm_monoid Type) := sorry --non-trivial
lemma new_lemma_170461 (h0 : has_mem.mem congr_arg_kind has_emptyc.emptyc) : @is_atomistic.{0} congr_arg_kind (@finset.pi.empty.{1 0} Type complete_lattice.{0} congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_170462 (h0 : topological_space (add_comm_monoid (option pos))) : topological_space.separable_space (add_comm_monoid (option pos)) := sorry --non-trivial
lemma new_lemma_170463 (h0 : mul_one_class (mul_one_class fun_info) -> mul_one_class (mul_one_class fun_info) -> Prop) (h1 : list (mul_one_class (mul_one_class fun_info))) : list.sorted h0 h1 := sorry --non-trivial
lemma new_lemma_170464 (h0 : function.extfun (Type 1) ring) : @strong_rank_condition.{1} (canonically_linear_ordered_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (canonically_linear_ordered_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_170465 (h0 : complete_lattice (has_nndist (finset environment.implicit_infer_kind))) : complete_lattice.is_Sup_finite_compact (has_nndist (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_170466 (h0 : uniform_space (has_inv (has_nnnorm string_imp))) : complete_space (has_inv (has_nnnorm string_imp)) := sorry --non-trivial
lemma new_lemma_170467 (h0 : topological_space (finset (option empty))) : preconnected_space (finset (option empty)) := sorry --non-trivial
lemma new_lemma_170468 (h0 : topological_space (pseudo_emetric_space unsigned)) : totally_separated_space (pseudo_emetric_space unsigned) := sorry --non-trivial
lemma new_lemma_170469 (h0 : add_monoid (measurable_space empty)) : add_monoid.fg (measurable_space empty) := sorry --non-trivial
lemma new_lemma_170470 (h0 : group (has_to_string (has_neg Type))) : is_simple_group (has_to_string (has_neg Type)) := sorry --non-trivial
lemma new_lemma_170471 (h0 : fin has_zero.zero) : @totally_disconnected_space.{1} (canonically_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (canonically_ordered_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_170472 (h0 : set (semi_normed_comm_ring enat)) (h1 : semi_normed_comm_ring enat) : set.compl h0 h1 := sorry --non-trivial
lemma new_lemma_170473 (h0 : add_group (bin_tree (semiring (semiring (semiring (semiring congr_arg_kind)))))) : is_add_cyclic (bin_tree (semiring (semiring (semiring (semiring congr_arg_kind))))) := sorry --non-trivial
lemma new_lemma_170474 (h0 : functor.add_const (monoid (canonically_ordered_comm_semiring linarith.comp)) linarith.comp) : @monoid.fg.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@functor.add_const.run.{0 0} (monoid.{0} (canonically_ordered_comm_semiring.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_170475 (h0 : group (add_comm_monoid (comm_group (has_to_string Type)))) : is_simple_group (add_comm_monoid (comm_group (has_to_string Type))) := sorry --non-trivial
lemma new_lemma_170476 (h0 : uniform_space (has_ssubset (normed_field reducibility_hints))) : complete_space (has_ssubset (normed_field reducibility_hints)) := sorry --non-trivial
lemma new_lemma_170477 (h0 : functor.add_const (finset (has_pos_part pos)) linarith.comp) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_170478 (h0 : function.extfun (Type 1) list) : list.nodup (function.extfun_app h0 (canonically_ordered_comm_semiring Type)) := sorry --non-trivial
lemma new_lemma_170479 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (has_nndist.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_170480 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @t0_space.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_170481 (h0 : functor.add_const (list (complete_distrib_lattice name)) unsigned) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_170482 (h0 : has_neg to_additive.value_type) (h1 : measurable_space to_additive.value_type) : has_measurable_neg to_additive.value_type := sorry --non-trivial
lemma new_lemma_170483 (h0 : functor.add_const (cancel_comm_monoid_with_zero (semigroup pos)) name) : @unique_factorization_monoid.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (semigroup.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_170484 (h0 : not (group (measurable_space linarith.ineq) -> false)) : @is_cyclic.{0} (measurable_space.{0} linarith.ineq) (@classical.by_contradiction'.{1} (group.{0} (measurable_space.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_170485 (h0 : topological_space (nondiscrete_normed_field reducibility_hints)) : t0_space (nondiscrete_normed_field reducibility_hints) := sorry --non-trivial
lemma new_lemma_170486 (h0 : group (has_neg num)) : is_simple_group (has_neg num) := sorry --non-trivial
lemma new_lemma_170487 (h0 : function.extfun Type (functor.add_const (complete_lattice (has_to_string linarith.comp)))) : @complete_lattice.is_Sup_finite_compact.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_to_string.{0} linarith.comp)) (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (complete_lattice.{0} (has_to_string.{0} linarith.comp))) h0 (has_add.{0} linarith.comp)))  := sorry --non-trivial
lemma new_lemma_170488 (h0 : topological_space (comm_ring (bin_tree (linear_ordered_add_comm_group fun_info)))) : t0_space (comm_ring (bin_tree (linear_ordered_add_comm_group fun_info))) := sorry --non-trivial
lemma new_lemma_170489 (h0 : nat) (h1 : eq h0 has_zero.zero -> Prop) (h2 : Pi (m : nat), eq h0 (nat.succ m) -> Prop) : nat.discriminate h1 h2 := sorry --non-trivial
lemma new_lemma_170490 (h0 : topological_space (option (semiring (semiring (semiring empty))))) : totally_separated_space (option (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_170491 (h0 : add_monoid (boolean_algebra (has_add Type))) : add_monoid.fg (boolean_algebra (has_add Type)) := sorry --non-trivial
lemma new_lemma_170492 (h0 : functor.add_const (ring (has_Inf Type)) (has_add name)) : @strong_rank_condition.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_Inf.{1} Type)) (has_add.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_170493 (h0 : function.extfun Type group) : @is_cyclic.{0} (ordered_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (ordered_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_170494 (h0 : uniform_space (add_group linarith.comp)) : separated_space (add_group linarith.comp) := sorry --non-trivial
lemma new_lemma_170495 (h0 : functor.add_const (add_group (has_neg Type)) name) : @is_add_cyclic.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (add_group.{1} (has_neg.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_170496 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (add_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_170497 (h0 : group (pseudo_metric_space (finset ennreal))) : group.fg (pseudo_metric_space (finset ennreal)) := sorry --non-trivial
lemma new_lemma_170498 (h0 : functor.add_const (complete_lattice (boolean_algebra Type)) Type) : @is_compactly_generated.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 1} (complete_lattice.{1} (boolean_algebra.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_170499 (h0 : functor.add_const (topological_space (boolean_algebra unsigned)) pos) : @locally_compact_space.{0} (boolean_algebra.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_170500 (h0 : topological_space (with_one (has_norm (semiring (semiring (semiring num)))))) : irreducible_space (with_one (has_norm (semiring (semiring (semiring num))))) := sorry --non-trivial
lemma new_lemma_170501 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (preorder empty)) := sorry --non-trivial
lemma new_lemma_170502 (h0 : functor.add_const (topological_space (has_Inf Type)) linarith.comp) : @totally_separated_space.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_Inf.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_170503 (h0 : ring (has_append (has_ssubset (random_gen fun_info)))) : rank_condition (has_append (has_ssubset (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_170504 (h0 : set (has_nnnorm reducibility_hints)) (h1 : has_nnnorm reducibility_hints) : set.up h0 h1 := sorry --non-trivial
lemma new_lemma_170505 (h0 : add_group (linear_ordered_add_comm_group (has_inv fun_info))) : is_add_cyclic (linear_ordered_add_comm_group (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_170506 (h0 : not (ring (plift empty) -> false)) : @is_domain.{1} (plift.{1} empty) (@classical.by_contradiction'.{2} (ring.{1} (plift.{1} empty)) h0)  := sorry --non-trivial
lemma new_lemma_170507 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (has_sub.{0} num) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (has_sub.{0} num))  := sorry --non-trivial
lemma new_lemma_170508 (h2 : topological_space (has_nnnorm linarith.ineq)) : t0_space (has_nnnorm linarith.ineq) := sorry --non-trivial
lemma new_lemma_170509 (h0 : topological_space (linear_ordered_field name)) : normal_space (linear_ordered_field name) := sorry --non-trivial
lemma new_lemma_170510 (h0 : has_mem.mem complete_lattice has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} (with_bot.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} h0) (with_bot.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_170511 (h0 : group (has_pos_part (has_bot real))) : normalizer_condition (has_pos_part (has_bot real)) := sorry --non-trivial
lemma new_lemma_170512 (h0 : group (topological_space (random_gen to_additive.value_type))) : is_cyclic (topological_space (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_170513 (h0 : functor.add_const (topological_space (has_neg_part unsigned)) (boolean_algebra (boolean_algebra name))) : @t1_space.{0} (has_neg_part.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} unsigned)) (boolean_algebra.{0} (boolean_algebra.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_170514 (h0 : functor.add_const (topological_space (boolean_algebra pos)) (has_Inf (finset Type))) : @discrete_topology.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.{0} pos)) (has_Inf.{1} (finset.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_170515 (h0 : ring (has_bot (has_add pos))) : rank_condition (has_bot (has_add pos)) := sorry --non-trivial
lemma new_lemma_170516 (h0 : add_group (simple_graph (mul_one_class (has_compl (has_compl fun_info))))) : is_add_cyclic (simple_graph (mul_one_class (has_compl (has_compl fun_info)))) := sorry --non-trivial
lemma new_lemma_170517 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (comm_group.{0} name) (@function.extfun_app.{2 1} Type add_group.{0} h0 (comm_group.{0} name))  := sorry --non-trivial
lemma new_lemma_170518 (h1 : add_comm_semigroup ereal -> add_comm_semigroup ereal -> Prop) : is_trans (add_comm_semigroup ereal) h1 := sorry --non-trivial
lemma new_lemma_170519 (h0 : not (filter (has_compl (has_nnnorm linarith.comp_source)) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_170520 (h0 : function.extfun Type (prod (complete_linear_order empty))) : set.diagonal (complete_linear_order empty) (function.extfun_app h0 (complete_linear_order empty)) := sorry --non-trivial
lemma new_lemma_170521 (h0 : has_neg (has_nnnorm string.iterator_imp)) (h1 : measurable_space (has_nnnorm string.iterator_imp)) : has_measurable_neg (has_nnnorm string.iterator_imp) := sorry --non-trivial
lemma new_lemma_170522 (h0 : topological_space (canonically_ordered_comm_semiring Type)) : regular_space (canonically_ordered_comm_semiring Type) := sorry --non-trivial
lemma new_lemma_170523 (h0 : functor.add_const (function.extfun (Type 1) topological_space) (finset Type)) : @t0_space.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) (finset.{1} Type) h0) (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_170524 (h0 : group (semiring linarith.comp_source)) : normalizer_condition (semiring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_170525 (h0 : topological_space (ordered_comm_ring (ring Type))) : loc_path_connected_space (ordered_comm_ring (ring Type)) := sorry --non-trivial
lemma new_lemma_170526 (h0 : function.extfun Type complete_lattice) : is_compactly_generated (topological_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_170527 (h0 : functor.add_const (complete_lattice (normed_linear_ordered_group empty)) empty) : @is_compactly_generated.{0} (normed_linear_ordered_group.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (normed_linear_ordered_group.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_170528 (h0 : functor.add_const (topological_space (has_neg_part ennreal)) unsigned) : @topological_space.separable_space.{0} (has_neg_part.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_170529 (h0 : topological_space (cancel_monoid (has_add name))) : preconnected_space (cancel_monoid (has_add name)) := sorry --non-trivial
lemma new_lemma_170530 (h0 : topological_space (ordered_ring empty)) : locally_compact_space (ordered_ring empty) := sorry --non-trivial
lemma new_lemma_170531 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (complete_distrib_lattice.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} empty))  := sorry --non-trivial
lemma new_lemma_170532 (h0 : ring (generalized_boolean_algebra (has_add (boolean_algebra.core pos)))) : is_principal_ideal_ring (generalized_boolean_algebra (has_add (boolean_algebra.core pos))) := sorry --non-trivial
lemma new_lemma_170533 (h0 : list (comm_group (option (option (option (option (option ennreal))))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_170534 (h0 : functor.add_const (list (option unsigned)) (option unsigned)) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_170535 (h0 : functor.add_const (ring (boolean_algebra unsigned)) pos) : @is_domain.{0} (boolean_algebra.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_170536 (h0 : ring (boolean_algebra.core (boolean_algebra (comm_group name)))) : strong_rank_condition (boolean_algebra.core (boolean_algebra (comm_group name))) := sorry --non-trivial
lemma new_lemma_170537 (h0 : functor.add_const (cancel_comm_monoid_with_zero (ring Type)) environment.implicit_infer_kind) : @unique_factorization_monoid.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (cancel_comm_monoid_with_zero.{1} (ring.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_170538 (h0 : has_mem.mem preorder has_emptyc.emptyc) (h1 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @Sup_convergence_class.{0} (has_inter.{0} empty) (@function.extfun_app.{2 1} Type preorder.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) preorder.{0} h0) (has_inter.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h1) topological_space.{0}) (has_inter.{0} empty))  := sorry --non-trivial
lemma new_lemma_170539 (h0 : complete_lattice (with_one (has_top congr_arg_kind))) : is_atomistic (with_one (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_170540 (h0 : ring (simple_graph (has_ssubset linarith.ineq))) : strong_rank_condition (simple_graph (has_ssubset linarith.ineq)) := sorry --non-trivial
lemma new_lemma_170541 (h0 : uniform_space (has_union linarith.comp)) : complete_space (has_union linarith.comp) := sorry --non-trivial
lemma new_lemma_170542 (h0 : prod (add_left_cancel_semigroup congr_arg_kind) (add_left_cancel_semigroup congr_arg_kind)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_170543 (h0 : functor.add_const (semiring (has_to_string Type)) (finset linarith.comp)) : @is_noetherian_ring.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (semiring.{1} (has_to_string.{1} Type)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_170544 (h0 : function.extfun Type (functor.comp topological_space finset)) : @irreducible_space.{0} (finset.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} finset.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} finset.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_170545 (h0 : add_monoid (with_one (semiring empty))) : add_monoid.fg (with_one (semiring empty)) := sorry --non-trivial
lemma new_lemma_170546 (h0 : uniform_space (semigroup (boolean_algebra Type))) : separated_space (semigroup (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_170547 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (metric_space.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (metric_space.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_170548 (h0 : uniform_space (has_bot (has_neg name))) : complete_space (has_bot (has_neg name)) := sorry --non-trivial
lemma new_lemma_170549 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (normed_lattice_add_comm_group.{0} name) (@function.extfun_app.{2 1} Type monoid.{0} h0 (normed_lattice_add_comm_group.{0} name))  := sorry --non-trivial
lemma new_lemma_170550 (h0 : topological_space (ring (finset linarith.comp))) : totally_disconnected_space (ring (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_170551 (h0 : add_monoid (has_to_string (finset ennreal))) : add_monoid.fg (has_to_string (finset ennreal)) := sorry --non-trivial
lemma new_lemma_170552 (h1 : functor.comp list measurable_space to_additive.value_type) : list.nodup (functor.comp.run h1) := sorry --non-trivial
lemma new_lemma_170553 (h0 : functor.comp ring has_neg environment.implicit_infer_kind) : @strong_rank_condition.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} ring.{0} has_neg.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_170554 (h0 : has_mem.mem add_group has_emptyc.emptyc) : @is_add_cyclic.{0} (linear_ordered_semiring.{0} fun_info) (@function.extfun_app.{2 1} Type add_group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) add_group.{0} h0) (linear_ordered_semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_170555 (h0 : list (has_nnnorm (random_gen (denumerable linarith.comp_source)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_170556 (h0 : functor.add_const (complete_lattice (plift unsigned)) num) : @is_atomistic.{1} (plift.{1} unsigned) (@functor.add_const.run.{1 0} (complete_lattice.{1} (plift.{1} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_170557 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring unsigned)) (option (option empty))) : @locally_compact_space.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} unsigned)) (option.{0} (option.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_170558 (h0 : fin has_zero.zero) : @preirreducible_space.{0} (has_bot.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (has_bot.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_170559 (h0 : group (canonically_ordered_monoid (has_add pos))) : normalizer_condition (canonically_ordered_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_170560 (h0 : functor.comp topological_space canonically_ordered_comm_semiring environment.implicit_infer_kind) : @totally_disconnected_space.{0} (canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_170561 (h0 : semiring (semigroup (ring (semigroup linarith.comp)))) : is_noetherian_ring (semigroup (ring (semigroup linarith.comp))) := sorry --non-trivial
lemma new_lemma_170562 (h0 : functor.add_const (cancel_comm_monoid_with_zero (semiring congr_arg_kind)) empty) : @unique_factorization_monoid.{0} (semiring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (semiring.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_170563 (h0 : topological_space (finset Type)) : topological_space.separable_space (finset Type) := sorry --non-trivial
lemma new_lemma_170564 (h0 : functor.add_const (group (comm_group Type)) pos) : @normalizer_condition.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (comm_group.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_170565 (h0 : topological_space (has_emptyc (random_gen (random_gen (random_gen linarith.ineq))))) : totally_separated_space (has_emptyc (random_gen (random_gen (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_170566 (h0 : finset (ring (finset (finset linarith.comp)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_170567 (h0 : topological_space (has_nndist (add_comm_monoid name))) : sequential_space (has_nndist (add_comm_monoid name)) := sorry --non-trivial
lemma new_lemma_170568 (h0 : functor.add_const (group (finset name)) name) : @group.fg.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (group.{0} (finset.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_170569 (h0 : add_monoid empty) (h1 : complete_lattice (has_top (add_action empty (metric_space empty)))) : is_atomistic (has_top (add_action empty (metric_space empty))) := sorry --non-trivial
lemma new_lemma_170570 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (normed_comm_ring.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (normed_comm_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_170571 (h0 : add_group (has_nndist (option unsigned))) : is_add_cyclic (has_nndist (option unsigned)) := sorry --non-trivial
lemma new_lemma_170572 (h1 : topological_space (comm_ring linarith.comp_source)) : path_connected_space (comm_ring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_170573 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} name (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) name)  := sorry --non-trivial
lemma new_lemma_170574 (h0 : has_neg (has_lt (mul_one_class string.iterator_imp))) (h1 : measurable_space (has_lt (mul_one_class string.iterator_imp))) : has_measurable_neg (has_lt (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_170575 (h0 : monoid (mul_zero_class (option (option unsigned)))) : monoid.fg (mul_zero_class (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_170576 (h0 : ring (has_dist unsigned)) : is_principal_ideal_ring (has_dist unsigned) := sorry --non-trivial
lemma new_lemma_170577 (h0 : not (function.extfun Type topological_space -> false)) : @irreducible_space.{0} (semiring.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_170578 (h0 : topological_space (has_zero (has_neg_part num))) : topological_space.separable_space (has_zero (has_neg_part num)) := sorry --non-trivial
lemma new_lemma_170579 (h0 : uniform_space (sub_neg_monoid (has_add Type))) : separated_space (sub_neg_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_170580 (h0 : add_group (add_comm_monoid (ring (semigroup (has_neg_part unsigned))))) : is_add_cyclic (add_comm_monoid (ring (semigroup (has_neg_part unsigned)))) := sorry --non-trivial
lemma new_lemma_170581 (h0 : monoid (random_gen (has_norm linarith.ineq))) : monoid.fg (random_gen (has_norm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_170582 (h0 : group (has_norm (with_bot string_imp))) : normalizer_condition (has_norm (with_bot string_imp)) := sorry --non-trivial
lemma new_lemma_170583 (h0 : finset (has_bot unsigned)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_170584 (h0 : ring (complete_distrib_lattice (has_add name))) : is_principal_ideal_ring (complete_distrib_lattice (has_add name)) := sorry --non-trivial
lemma new_lemma_170585 (h0 : uniform_space (has_to_string string.iterator_imp)) : complete_space (has_to_string string.iterator_imp) := sorry --non-trivial
lemma new_lemma_170586 (h1 : topological_space (with_one (has_top congr_arg_kind))) : irreducible_space (with_one (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_170587 (h0 : ordered_comm_monoid (normed_lattice_add_comm_group real)) : has_exists_mul_of_le (normed_lattice_add_comm_group real) := sorry --non-trivial
lemma new_lemma_170588 (h0 : add_monoid (measure_theory.measure_space congr_arg_kind)) : add_monoid.fg (measure_theory.measure_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_170589 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (linear_ordered_comm_group.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_comm_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_170590 (h0 : filter (canonically_ordered_add_monoid linarith.comp_source)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_170591 (h1 : ring (comm_ring (random_gen linarith.comp_source))) : strong_rank_condition (comm_ring (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_170592 (h0 : topological_space (normed_lattice_add_comm_group (has_neg (has_add Type)))) : discrete_topology (normed_lattice_add_comm_group (has_neg (has_add Type))) := sorry --non-trivial
lemma new_lemma_170593 (h0 : function.extfun Type (functor.add_const (list (semigroup empty)))) : list.nodup (functor.add_const.run (function.extfun_app h0 empty)) := sorry --non-trivial
lemma new_lemma_170594 (h0 : topological_space (has_top (metric_space (has_one (metric_space empty))))) : irreducible_space (has_top (metric_space (has_one (metric_space empty)))) := sorry --non-trivial
lemma new_lemma_170595 (h0 : complete_lattice (finset (boolean_algebra.core (finset Type)))) : is_atomistic (finset (boolean_algebra.core (finset Type))) := sorry --non-trivial
lemma new_lemma_170596 (h0 : add_group (has_ssubset (mul_one_class environment.projection_info))) : is_add_cyclic (has_ssubset (mul_one_class environment.projection_info)) := sorry --non-trivial
lemma new_lemma_170597 (h0 : functor.add_const (topological_space (complete_distrib_lattice pos)) Type) : @preirreducible_space.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (complete_distrib_lattice.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_170598 (h0 : fin has_zero.zero) : @rank_condition.{0} (distrib.{0} (has_ssubset.{0} (has_ssubset.{0} linarith.comp_source))) (@matrix.vec_empty.{0} (ring.{0} (distrib.{0} (has_ssubset.{0} (has_ssubset.{0} linarith.comp_source)))) h0)  := sorry --non-trivial
lemma new_lemma_170599 (h0 : topological_space (fintype (random_gen fun_info))) : totally_disconnected_space (fintype (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_170600 (h0 : function.extfun (Type 1) topological_space) : @t1_space.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_170601 (h0 : group (has_emptyc congr_arg_kind)) : group.fg (has_emptyc congr_arg_kind) := sorry --non-trivial
lemma new_lemma_170602 (h0 : functor.add_const (filter (semigroup ennreal)) name) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_170603 (h0 : metric_space unsigned -> metric_space unsigned -> Prop) : is_total (metric_space unsigned) h0 := sorry --non-trivial
lemma new_lemma_170604 (h0 : monoid (normed_comm_ring (semigroup Type))) : monoid.fg (normed_comm_ring (semigroup Type)) := sorry --non-trivial
lemma new_lemma_170605 (h0 : topological_space (has_to_string (has_Inf (has_Inf (has_Inf (has_Inf linarith.comp)))))) : preconnected_space (has_to_string (has_Inf (has_Inf (has_Inf (has_Inf linarith.comp))))) := sorry --non-trivial
lemma new_lemma_170606 (h0 : preorder (uniform_space char)) (h1 : not (succ_order (uniform_space char) -> false)) : @is_succ_archimedean.{0} (uniform_space.{0} char) h0 (@classical.by_contradiction'.{1} (@succ_order.{0} (uniform_space.{0} char) h0) h1)  := sorry --non-trivial
lemma new_lemma_170607 (h0 : topological_space (has_norm (semiring (has_norm empty)))) : preirreducible_space (has_norm (semiring (has_norm empty))) := sorry --non-trivial
lemma new_lemma_170608 (h0 : topological_space (boolean_algebra (has_add name))) : totally_separated_space (boolean_algebra (has_add name)) := sorry --non-trivial
lemma new_lemma_170609 (h0 : function.extfun Type topological_space) : @t0_space.{0} (normed_comm_ring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_170610 (h1 : not (topological_space (add_monoid linarith.ineq) -> false)) : @path_connected_space.{0} (add_monoid.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (add_monoid.{0} linarith.ineq)) h1)  := sorry --non-trivial
lemma new_lemma_170611 (h0 : functor.add_const (filter (comm_group unsigned)) linarith.comp) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_170612 (h0 : filter (add_group (has_union (semiring empty)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_170613 (h0 : function.extfun nat fin) : @preirreducible_space.{0} (has_add.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (has_add.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_170614 (h0 : functor.add_const (functor.add_const Prop (as_linear_order Type)) name) : functor.add_const.run (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_170615 (h0 : uniform_space (complete_semilattice_Sup (has_top unsigned))) : complete_space (complete_semilattice_Sup (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_170616 (h1 : function.extfun Type uniform_space) : @complete_space.{0} (measurable_space.{0} linarith.ineq) (@function.extfun_app.{2 1} Type uniform_space.{0} h1 (measurable_space.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_170617 (h0 : group (plift (semiring unsigned))) : normalizer_condition (plift (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_170618 (h0 : complete_lattice (normed_comm_ring (finset (finset ennreal)))) : is_atomistic (normed_comm_ring (finset (finset ennreal))) := sorry --non-trivial
lemma new_lemma_170619 (h0 : monoid (simple_graph (has_pos_part (canonically_linear_ordered_monoid pos)))) : monoid.fg (simple_graph (has_pos_part (canonically_linear_ordered_monoid pos))) := sorry --non-trivial
lemma new_lemma_170620 (h0 : complete_lattice (ordered_comm_ring (ring linarith.comp))) : complete_lattice.is_Sup_finite_compact (ordered_comm_ring (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_170621 (h0 : not (group (distrib linarith.comp_source) -> false)) : @is_cyclic.{0} (distrib.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (group.{0} (distrib.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_170622 (h0 : functor.add_const (ordered_add_comm_monoid (has_pos_part Type)) (boolean_algebra.core pos)) : @archimedean.{1} (has_pos_part.{1} Type) (@functor.add_const.run.{1 0} (ordered_add_comm_monoid.{1} (has_pos_part.{1} Type)) (boolean_algebra.core.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_170623 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (add_group.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (add_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_170624 (h0 : ring (boolean_algebra (boolean_algebra Type))) : is_domain (boolean_algebra (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_170625 (h0 : functor.add_const (group (normed_comm_ring pos)) Type) : @is_simple_group.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (normed_comm_ring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_170626 (h0 : topological_space (has_add (has_to_string num))) : preirreducible_space (has_add (has_to_string num)) := sorry --non-trivial
lemma new_lemma_170627 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_170628 (h0 : complete_lattice (ordered_comm_monoid name)) : complete_lattice.is_Sup_finite_compact (ordered_comm_monoid name) := sorry --non-trivial
lemma new_lemma_170629 (h0 h1 : multiset (uniform_space (mul_one_class linarith.ineq))) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_170630 (h0 : ordered_comm_monoid (ordered_comm_monoid (has_pos_part (has_add (has_Inf pos))))) : has_exists_mul_of_le (ordered_comm_monoid (has_pos_part (has_add (has_Inf pos)))) := sorry --non-trivial
lemma new_lemma_170631 (h0 : complete_lattice (fintype (has_ssubset fun_info))) : complete_lattice.is_Sup_finite_compact (fintype (has_ssubset fun_info)) := sorry --non-trivial
lemma new_lemma_170632 (h0 : topological_space (with_bot (has_norm (has_norm fun_info)))) : totally_separated_space (with_bot (has_norm (has_norm fun_info))) := sorry --non-trivial
lemma new_lemma_170633 (h0 : functor.add_const (ordered_comm_monoid (generalized_boolean_algebra name)) (has_neg Type)) : @has_exists_mul_of_le.{0} (generalized_boolean_algebra.{0} name) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (generalized_boolean_algebra.{0} name)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_170634 (h0 : topological_space (has_dist congr_arg_kind)) : loc_path_connected_space (has_dist congr_arg_kind) := sorry --non-trivial
lemma new_lemma_170635 (h0 : group (has_norm (random_gen (semiring num)))) : is_cyclic (has_norm (random_gen (semiring num))) := sorry --non-trivial
lemma new_lemma_170636 (h0 : add_monoid (has_nndist congr_arg_kind)) : add_monoid.fg (has_nndist congr_arg_kind) := sorry --non-trivial
lemma new_lemma_170637 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (ring.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_170638 (h0 : group (filter (option unsigned))) : normalizer_condition (filter (option unsigned)) := sorry --non-trivial
lemma new_lemma_170639 (h0 : topological_space (left_cancel_semigroup num)) : irreducible_space (left_cancel_semigroup num) := sorry --non-trivial
lemma new_lemma_170640 (h0 : ring (normed_group (linear_ordered_add_comm_group to_additive.value_type))) : is_domain (normed_group (linear_ordered_add_comm_group to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_170641 (h0 : group (has_compl (mul_one_class char))) : is_cyclic (has_compl (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_170642 (h0 : complete_lattice (preorder empty)) : complete_lattice.is_Sup_finite_compact (preorder empty) := sorry --non-trivial
lemma new_lemma_170643 (h0 : functor.add_const (function.extfun Type group) (option unsigned)) : @group.fg.{0} (option.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) (option.{0} unsigned) h0) (option.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_170644 (h0 : functor.add_const (filter (finset pos)) Type) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_170645 (h0 : topological_space (normed_comm_ring environment.implicit_infer_kind)) : normal_space (normed_comm_ring environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_170646 (h0 : dlist (linear_ordered_comm_ring (semiring (semiring (semiring (semiring congr_arg_kind)))))) : list.nodup (dlist.to_list h0) := sorry --non-trivial
lemma new_lemma_170647 (h0 : topological_space (has_add (has_neg (mul_one_class linarith.comp)))) : t1_space (has_add (has_neg (mul_one_class linarith.comp))) := sorry --non-trivial
lemma new_lemma_170648 (h0 : group (measurable_space (has_norm num))) : normalizer_condition (measurable_space (has_norm num)) := sorry --non-trivial
lemma new_lemma_170649 (h0 : functor.add_const (group (ring pos)) (ring Type)) : @is_simple_group.{0} (ring.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (ring.{0} pos)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_170650 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (with_bot.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (with_bot.{0} empty))  := sorry --non-trivial
lemma new_lemma_170651 (h0 : add_group (finset (finset Type))) : is_add_cyclic (finset (finset Type)) := sorry --non-trivial
lemma new_lemma_170652 (h0 : functor.add_const (ring (finset num)) unsigned) : @rank_condition.{0} (finset.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (finset.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_170653 (h0 : group (semigroup (has_to_string unsigned))) : is_simple_group (semigroup (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_170654 (h0 : not (has_mem.mem (random_gen fun_info) has_emptyc.emptyc -> false)) : @rank_condition.{0} (random_gen.{0} fun_info) (@finset.pi.empty.{1 0} Type ring.{0} (random_gen.{0} fun_info) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} fun_info) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_170655 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_170656 (h0 : functor.add_const (topological_space (boolean_algebra name)) pos) : @t1_space.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_170657 (h0 : add_monoid (has_nndist (cancel_monoid Type))) : add_monoid.fg (has_nndist (cancel_monoid Type)) := sorry --non-trivial
lemma new_lemma_170658 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (has_add.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_add.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_170659 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (finset unsigned)) := sorry --non-trivial
lemma new_lemma_170660 (h0 : group (normed_comm_ring (finset pos))) : normalizer_condition (normed_comm_ring (finset pos)) := sorry --non-trivial
lemma new_lemma_170661 (h0 : topological_space (distrib_lattice (comm_ring linarith.ineq))) : path_connected_space (distrib_lattice (comm_ring linarith.ineq)) := sorry --non-trivial
lemma new_lemma_170662 (h0 : functor.add_const (group (has_nndist congr_arg_kind)) empty) : @group.fg.{0} (has_nndist.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (group.{0} (has_nndist.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_170663 (h0 : functor.add_const (functor.add_const Prop num) empty) : functor.add_const.run (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_170664 (h0 : ordered_add_comm_monoid (cancel_monoid (has_neg linarith.comp))) : archimedean (cancel_monoid (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_170665 (h0 : ring (non_assoc_semiring (has_norm num))) : rank_condition (non_assoc_semiring (has_norm num)) := sorry --non-trivial
lemma new_lemma_170666 (h0 : ring (add_cancel_monoid (has_pos_part (has_neg pos)))) : strong_rank_condition (add_cancel_monoid (has_pos_part (has_neg pos))) := sorry --non-trivial
lemma new_lemma_170667 (h0 : has_nnnorm char -> Prop) : set.finite (set_of h0) := sorry --non-trivial
lemma new_lemma_170668 (h0 : function.extfun Type topological_space) : @regular_space.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_170669 (h0 : ordered_comm_monoid (ordered_comm_monoid (has_Inf Type))) : has_exists_mul_of_le (ordered_comm_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_170670 (h0 : group (mul_one_class linarith.ineq)) (h1 : subgroup (mul_one_class linarith.ineq)) : subgroup.fg h1 := sorry --non-trivial
lemma new_lemma_170671 (h0 : list (id (random_gen (random_gen to_additive.value_type)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_170672 (h0 : topological_space (comm_ring (has_inv (random_gen fun_info)))) : path_connected_space (comm_ring (has_inv (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_170673 (h0 : complete_lattice (has_to_string (ring environment.implicit_infer_kind))) : complete_lattice.is_Sup_finite_compact (has_to_string (ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_170674 (h0 : functor.add_const (functor.add_const (complete_lattice pos) unsigned) unsigned) : @is_atomistic.{0} pos (@functor.add_const.run.{0 0} (complete_lattice.{0} pos) unsigned (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (complete_lattice.{0} pos) unsigned) unsigned h0))  := sorry --non-trivial
lemma new_lemma_170675 (h0 : add_group (distrib (comm_ring (semi_normed_comm_ring (has_nnnorm char))))) : is_add_cyclic (distrib (comm_ring (semi_normed_comm_ring (has_nnnorm char)))) := sorry --non-trivial
lemma new_lemma_170676 (h0 : functor.add_const (function.extfun Type uniform_space) unsigned) : @complete_space.{0} (linear_ordered_field.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) unsigned h0) (linear_ordered_field.{0} empty))  := sorry --non-trivial
lemma new_lemma_170677 (h0 : topological_space (denumerable (random_gen num))) : discrete_topology (denumerable (random_gen num)) := sorry --non-trivial
lemma new_lemma_170678 (h0 : topological_space (comm_group pos)) : path_connected_space (comm_group pos) := sorry --non-trivial
lemma new_lemma_170679 (h0 h1 : multiset (add_comm_semigroup ereal)) : multiset.le h0 h1 := sorry --non-trivial
lemma new_lemma_170680 (h0 : function.extfun (Type 1) complete_lattice) : @is_compactly_generated.{1} (comm_semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} h0 (comm_semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_170681 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (as_linear_order.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (as_linear_order.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_170682 (h1 : uniform_space (has_nnnorm reducibility_hints)) : complete_space (has_nnnorm reducibility_hints) := sorry --non-trivial
lemma new_lemma_170683 (h0 h2 : multiset (add_comm_semigroup linarith.ineq)) : multiset.le h0 h2 := sorry --non-trivial
lemma new_lemma_170684 (h0 : functor.add_const (add_group (finset ennreal)) num) : @is_add_cyclic.{0} (finset.{0} ennreal) (@functor.add_const.run.{0 0} (add_group.{0} (finset.{0} ennreal)) num h0)  := sorry --non-trivial
lemma new_lemma_170685 (h0 : topological_space (partial_order congr_arg_kind)) : irreducible_space (partial_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_170686 (h0 : fin has_zero.zero) : @path_connected_space.{0} (ordered_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (ordered_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_170687 (h0 : has_mem.mem (with_bot (has_top linarith.ineq)) has_emptyc.emptyc) : @is_add_cyclic.{0} (with_bot.{0} (has_top.{0} linarith.ineq)) (@finset.pi.empty.{1 0} Type add_group.{0} (with_bot.{0} (has_top.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_170688 (h0 : function.extfun Type topological_space) : @t0_space.{0} (distrib_lattice.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (distrib_lattice.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_170689 (h0 : functor.comp topological_space normed_comm_ring name) : @normal_space.{0} (normed_comm_ring.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} normed_comm_ring.{0} name h0)  := sorry --non-trivial
lemma new_lemma_170690 (h0 : topological_space (semigroup (has_add (comm_group (comm_group Type))))) : path_connected_space (semigroup (has_add (comm_group (comm_group Type)))) := sorry --non-trivial
lemma new_lemma_170691 (h0 : topological_space (has_top to_additive.value_type)) : discrete_topology (has_top to_additive.value_type) := sorry --non-trivial
lemma new_lemma_170692 (h0 : not (topological_space (complete_linear_order num) -> false)) : @preirreducible_space.{0} (complete_linear_order.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (complete_linear_order.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_170693 (h0 : has_mem.mem (has_norm num) has_emptyc.emptyc) : @complete_space.{0} (has_norm.{0} num) (@finset.pi.empty.{1 0} Type uniform_space.{0} (has_norm.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_170694 (h0 : topological_space (id (has_norm empty))) : path_connected_space (id (has_norm empty)) := sorry --non-trivial
lemma new_lemma_170695 (h0 : boolean_algebra (has_bot real) -> boolean_algebra (has_bot real) -> Prop) : transitive h0 := sorry --non-trivial
lemma new_lemma_170696 (h0 : add_group (distrib_lattice (has_inv to_additive.value_type))) : is_add_cyclic (distrib_lattice (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_170697 (h0 : functor.add_const (topological_space (complete_distrib_lattice unsigned)) linarith.comp) : @sequential_space.{0} (complete_distrib_lattice.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_170698 (h0 : group (with_bot (has_norm linarith.comp))) : normalizer_condition (with_bot (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_170699 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (bin_tree.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (bin_tree.{0} empty))  := sorry --non-trivial
lemma new_lemma_170700 (h1 : ring (add_comm_semigroup (add_comm_semigroup std_gen))) : strong_rank_condition (add_comm_semigroup (add_comm_semigroup std_gen)) := sorry --non-trivial
lemma new_lemma_170701 (h0 : topological_space (has_norm (denumerable linarith.ineq))) : locally_compact_space (has_norm (denumerable linarith.ineq)) := sorry --non-trivial
lemma new_lemma_170702 (h0 : functor.add_const (ordered_comm_monoid (comm_group environment.implicit_infer_kind)) (ring Type)) : @has_exists_mul_of_le.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (comm_group.{0} environment.implicit_infer_kind)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_170703 (h1 : add_group ordering) : is_add_cyclic ordering := sorry --non-trivial
lemma new_lemma_170704 (h0 : topological_space (has_neg_part (option (option (option (ring pos)))))) : totally_separated_space (has_neg_part (option (option (option (ring pos))))) := sorry --non-trivial
lemma new_lemma_170705 (h0 : topological_space (comm_group name)) : t1_space (comm_group name) := sorry --non-trivial
lemma new_lemma_170706 (h0 : topological_space (normed_comm_ring (has_to_string unsigned))) : regular_space (normed_comm_ring (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_170707 (h0 : functor.add_const (topological_space (has_bot empty)) congr_arg_kind) : @t1_space.{0} (has_bot.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_bot.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_170708 (h0 : topological_space (semigroup (finset environment.implicit_infer_kind))) : irreducible_space (semigroup (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_170709 (h0 : fin has_zero.zero) : @is_compactly_generated.{0} (ordered_comm_ring.{0} real) (@matrix.vec_empty.{0} (complete_lattice.{0} (ordered_comm_ring.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_170710 (h0 : ring (denumerable (has_ssubset fun_info))) : strong_rank_condition (denumerable (has_ssubset fun_info)) := sorry --non-trivial
lemma new_lemma_170711 (h0 : complete_lattice (is_R_or_C (option unsigned))) : complete_lattice.is_Sup_finite_compact (is_R_or_C (option unsigned)) := sorry --non-trivial
lemma new_lemma_170712 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (non_assoc_semiring.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (non_assoc_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_170713 (h0 : functor.add_const (topological_space (generalized_boolean_algebra pos)) (has_add (has_add (has_add (ring pos))))) : @t0_space.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} pos)) (has_add.{0} (has_add.{0} (has_add.{0} (ring.{0} pos)))) h0)  := sorry --non-trivial
lemma new_lemma_170714 (h0 : filter (add_group empty)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_170715 (h0 : function.extfun (finset Type) (has_mem.mem (with_bot linarith.comp_source))) : @complete_space.{0} (with_bot.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type uniform_space.{0} (with_bot.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_bot.{0} linarith.comp_source)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_170716 (h0 : uniform_space (has_ssubset (normed_field (comm_ring linarith.comp_source)))) : complete_space (has_ssubset (normed_field (comm_ring linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_170717 (h0 : functor.add_const (topological_space (mul_zero_class unsigned)) unsigned) : @normal_space.{0} (mul_zero_class.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_170718 (h0 : ring (plift (semiring empty))) : is_domain (plift (semiring empty)) := sorry --non-trivial
lemma new_lemma_170719 (h0 : topological_space (boolean_algebra.core real)) : loc_path_connected_space (boolean_algebra.core real) := sorry --non-trivial
lemma new_lemma_170720 (h1 h2 : multiset environment.projection_info) : multiset.subset h1 h2 := sorry --non-trivial
lemma new_lemma_170721 (h0 : topological_space (add_comm_monoid (has_neg (has_neg environment.implicit_infer_kind)))) : loc_path_connected_space (add_comm_monoid (has_neg (has_neg environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_170722 (h0 : num -> Prop) : zzz_forall h0 := sorry --non-trivial
lemma new_lemma_170723 (h0 : function.extfun nat fin) : @locally_compact_space.{0} (has_add.{0} name) (@matrix.vec_empty.{0} (topological_space.{0} (has_add.{0} name)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_170724 (h0 : ring (semigroup Type)) : is_domain (semigroup Type) := sorry --non-trivial
lemma new_lemma_170725 (h0 : group (linear_ordered_add_comm_group (random_gen (has_inv linarith.ineq)))) : group.fg (linear_ordered_add_comm_group (random_gen (has_inv linarith.ineq))) := sorry --non-trivial
lemma new_lemma_170726 (h0 : list (ordered_semiring (has_top linarith.comp_source))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_170727 (h0 : ring (encodable (random_gen fun_info))) : strong_rank_condition (encodable (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_170728 (h0 : group (with_one (has_inv fun_info))) : is_cyclic (with_one (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_170729 (h0 : ring (semiring (has_star enat))) : rank_condition (semiring (has_star enat)) := sorry --non-trivial
lemma new_lemma_170730 (h0 : function.extfun (finset Type) (has_mem.mem (with_bot empty))) : @normal_space.{0} (with_bot.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_bot.{0} empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_bot.{0} empty)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_170731 (h0 : ring (has_bot (option num))) : strong_rank_condition (has_bot (option num)) := sorry --non-trivial
lemma new_lemma_170732 (h0 : functor.add_const (topological_space environment.implicit_infer_kind) linarith.comp) : @preconnected_space.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 0} (topological_space.{0} environment.implicit_infer_kind) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_170733 (h0 : topological_space (has_Inf name)) : sequential_space (has_Inf name) := sorry --non-trivial
lemma new_lemma_170734 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (mul_zero_class.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (mul_zero_class.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_170735 (h0 : functor.add_const (group (has_pos_part pos)) pos) : @group.fg.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_pos_part.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_170736 (h0 : not (topological_space (has_top (random_gen linarith.comp_source)) -> false)) : @locally_compact_space.{0} (has_top.{0} (random_gen.{0} linarith.comp_source)) (@classical.by_contradiction'.{1} (topological_space.{0} (has_top.{0} (random_gen.{0} linarith.comp_source))) h0)  := sorry --non-trivial
lemma new_lemma_170737 (h1 : not (semiring (denumerable string_imp) -> false)) (h2 : denumerable string_imp) : @odd.{0} (denumerable.{0} string_imp) (@classical.by_contradiction'.{1} (semiring.{0} (denumerable.{0} string_imp)) h1) h2  := sorry --non-trivial
lemma new_lemma_170738 (h0 : functor.add_const (ordered_add_comm_monoid (preorder num)) empty) : @archimedean.{0} (preorder.{0} num) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (preorder.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_170739 (h0 : monoid (measurable_space (random_gen (has_inv (has_inv linarith.ineq))))) : monoid.fg (measurable_space (random_gen (has_inv (has_inv linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_170740 (h0 : functor.add_const (ordered_add_comm_monoid (canonically_ordered_comm_semiring Type)) name) : @archimedean.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.add_const.run.{1 0} (ordered_add_comm_monoid.{1} (canonically_ordered_comm_semiring.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_170741 (h0 : semiring (has_Sup (option (option (option unsigned))))) : is_noetherian_ring (has_Sup (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_170742 (h0 : topological_space (normed_group (has_inv fun_info))) : locally_compact_space (normed_group (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_170743 (h0 : ordered_comm_monoid (finset (finset (finset environment.implicit_infer_kind)))) : has_exists_mul_of_le (finset (finset (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_170744 (h0 : filter (add_cancel_monoid unsigned)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_170745 (h0 : topological_space znum) : path_connected_space znum := sorry --non-trivial
lemma new_lemma_170746 (h1 : complete_lattice (complete_semilattice_Sup (random_gen string_imp))) : is_compactly_generated (complete_semilattice_Sup (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_170747 (h0 : ring (complete_semilattice_Sup char)) : rank_condition (complete_semilattice_Sup char) := sorry --non-trivial
lemma new_lemma_170748 (h0 : topological_space (has_norm (has_norm congr_arg_kind))) : preirreducible_space (has_norm (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_170749 (h0 : functor.add_const (filter (normed_comm_ring pos)) linarith.comp) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_170750 (h0 : filter (semiring (has_norm empty))) : not (filter.ne_bot h0) := sorry --non-trivial
lemma new_lemma_170751 (h0 : topological_space (canonically_ordered_comm_semiring (finset name))) : irreducible_space (canonically_ordered_comm_semiring (finset name)) := sorry --non-trivial
lemma new_lemma_170752 (h0 : functor.add_const (group (has_nndist Type)) linarith.comp) : @group.fg.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (has_nndist.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_170753 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (add_cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (add_cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_170754 (h0 : measurable_space (has_bot unsigned)) (h1 : group (measure_theory.measure (has_bot unsigned))) : is_cyclic (measure_theory.measure (has_bot unsigned)) := sorry --non-trivial
lemma new_lemma_170755 (h0 : monoid (has_top (random_gen string_imp))) : monoid.fg (has_top (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_170756 (h0 : function.extfun Type (functor.add_const (complete_lattice (add_left_cancel_semigroup unsigned)))) : @complete_lattice.is_Sup_finite_compact.{0} (add_left_cancel_semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_left_cancel_semigroup.{0} unsigned)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (complete_lattice.{0} (add_left_cancel_semigroup.{0} unsigned))) h0 empty))  := sorry --non-trivial
lemma new_lemma_170757 (h1 : add_group (distrib (semi_normed_ring (has_ssubset (distrib (comm_ring char)))))) : is_add_cyclic (distrib (semi_normed_ring (has_ssubset (distrib (comm_ring char))))) := sorry --non-trivial
lemma new_lemma_170758 (h0 : topological_space (has_neg_part (has_add pos))) : locally_compact_space (has_neg_part (has_add pos)) := sorry --non-trivial
lemma new_lemma_170759 (h0 : topological_space (boolean_algebra (has_add pos))) : totally_disconnected_space (boolean_algebra (has_add pos)) := sorry --non-trivial
lemma new_lemma_170760 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (denumerable.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (denumerable.{0} num))  := sorry --non-trivial
lemma new_lemma_170761 (h0 : topological_space (complete_distrib_lattice (has_add (has_add environment.implicit_infer_kind)))) : locally_compact_space (complete_distrib_lattice (has_add (has_add environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_170762 (h0 : functor.add_const (topological_space (has_add linarith.comp)) (has_Inf Type)) : @sequential_space.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_add.{0} linarith.comp)) (has_Inf.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_170763 (h1 : not (ring (normed_field char) -> false)) : @rank_condition.{0} (normed_field.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (normed_field.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_170764 (h0 : functor.add_const (topological_space (ring linarith.comp)) (boolean_algebra linarith.comp)) : @normal_space.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} linarith.comp)) (boolean_algebra.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_170765 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_170766 (h0 : list (has_add (has_neg (option ennreal)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_170767 (h0 : group (measure_theory.measure_space (semiring empty))) : is_cyclic (measure_theory.measure_space (semiring empty)) := sorry --non-trivial
lemma new_lemma_170768 (h0 : ring (random_gen (semiring num))) : is_domain (random_gen (semiring num)) := sorry --non-trivial
lemma new_lemma_170769 (h0 : functor.add_const (topological_space (has_neg Type)) pos) : @loc_path_connected_space.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_neg.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_170770 (h0 : functor.comp filter boolean_algebra name) : filter.ne_bot (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_170771 (h0 : group (boolean_algebra (finset (has_add linarith.comp)))) : group.fg (boolean_algebra (finset (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_170772 (h0 : functor.add_const (list (has_zero name)) Type) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_170773 (h0 : not (function.extfun Type complete_lattice -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_top.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (has_top.{0} num))  := sorry --non-trivial
lemma new_lemma_170774 (h0 : prod (comm_group linarith.ineq) (comm_group linarith.ineq)) : set.diagonal (comm_group linarith.ineq) h0 := sorry --non-trivial
lemma new_lemma_170775 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (finset.{0} (option.{0} pos)) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (finset.{0} (option.{0} pos)))  := sorry --non-trivial
lemma new_lemma_170776 (h0 : add_group (has_nndist (option num))) : is_add_cyclic (has_nndist (option num)) := sorry --non-trivial
lemma new_lemma_170777 (h0 : group (id (semiring empty))) : normalizer_condition (id (semiring empty)) := sorry --non-trivial
lemma new_lemma_170778 (h0 : option (filter Prop)) (h1 : filter Prop) : @Lim.{0} Prop sierpinski_space (@nonempty_of_inhabited.{1} Prop sort.inhabited.{0}) (@id.{1} (filter.{0} Prop) (@option.get_or_else.{0} (filter.{0} Prop) h0 h1))  := sorry --non-trivial
lemma new_lemma_170779 (h0 : topological_space (cancel_monoid (boolean_algebra name))) : preirreducible_space (cancel_monoid (boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_170780 (h0 : functor.add_const (uniform_space nnreal) num) : separated_space nnreal := sorry --non-trivial
lemma new_lemma_170781 (h0 : complete_lattice (add_cancel_monoid (option empty))) : is_compactly_generated (add_cancel_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_170782 (h0 : not (topological_space (has_ssubset string.iterator_imp) -> false)) : @t0_space.{0} (has_ssubset.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (topological_space.{0} (has_ssubset.{0} string.iterator_imp)) h0)  := sorry --non-trivial
lemma new_lemma_170783 (h0 : monoid (add_left_cancel_semigroup (semiring unsigned))) : monoid.fg (add_left_cancel_semigroup (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_170784 (h0 : functor.add_const (complete_lattice (canonically_linear_ordered_monoid unsigned)) pos) : @is_atomistic.{0} (canonically_linear_ordered_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (canonically_linear_ordered_monoid.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_170785 (h0 : group (canonically_ordered_monoid (has_scalar real real))) : group.fg (canonically_ordered_monoid (has_scalar real real)) := sorry --non-trivial
lemma new_lemma_170786 (h0 : topological_space (simple_graph to_additive.value_type)) : path_connected_space (simple_graph to_additive.value_type) := sorry --non-trivial
lemma new_lemma_170787 (h0 : function.extfun (finset Type) (has_mem.mem (has_emptyc fun_info))) : @is_add_cyclic.{0} (has_emptyc.{0} fun_info) (@finset.pi.empty.{1 0} Type add_group.{0} (has_emptyc.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_emptyc.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_170788 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (has_norm.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_norm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_170789 (h1 : add_group (distrib (comm_ring (comm_ring char)))) : is_add_cyclic (distrib (comm_ring (comm_ring char))) := sorry --non-trivial
lemma new_lemma_170790 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (random_gen.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (random_gen.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_170791 (h0 : uniform_space (has_zero (finset Type))) : complete_space (has_zero (finset Type)) := sorry --non-trivial
lemma new_lemma_170792 (h0 : comm_semiring (has_pos_part (has_neg linarith.comp))) (h1 : polynomial (has_pos_part (has_neg linarith.comp))) : polynomial.separable h1 := sorry --non-trivial
lemma new_lemma_170793 (h0 : has_mem.mem (normed_group num) has_emptyc.emptyc) : @is_atomistic.{0} (normed_group.{0} num) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (normed_group.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_170794 (h0 : functor.add_const (ordered_comm_monoid (boolean_algebra.core name)) pos) : @has_exists_mul_of_le.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (boolean_algebra.core.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_170795 (h0 : filter (normed_group (semiring unsigned))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_170796 (h0 : topological_space (normed_comm_ring (mul_one_class (has_Inf (has_pos_part linarith.comp))))) : regular_space (normed_comm_ring (mul_one_class (has_Inf (has_pos_part linarith.comp)))) := sorry --non-trivial
lemma new_lemma_170797 (h0 : topological_space (with_bot (has_top congr_arg_kind))) : totally_separated_space (with_bot (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_170798 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (with_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (with_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_170799 (h0 : list (normed_linear_ordered_group num)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_170800 (h0 : finset (has_star (semiring congr_arg_kind))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_170801 (h0 : ordered_comm_monoid (simple_graph (has_add (has_Inf Type)))) : has_exists_mul_of_le (simple_graph (has_add (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_170802 (h0 : group (measurable_space to_additive.value_type)) : group.fg (measurable_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_170803 (h0 : functor.add_const (function.extfun Type semiring) name) : @is_noetherian_ring.{0} (ordered_comm_ring.{0} name) (@function.extfun_app.{2 1} Type semiring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type semiring.{0}) name h0) (ordered_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_170804 (h0 : functor.add_const (topological_space (plift unsigned)) unsigned) : @topological_space.separable_space.{1} (plift.{1} unsigned) (@functor.add_const.run.{1 0} (topological_space.{1} (plift.{1} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_170805 (h0 : function.extfun Type topological_space) : @normal_space.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_monoid_with_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_170806 (h0 : functor.add_const (list (boolean_algebra ennreal)) name) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_170807 (h0 : complete_lattice (has_top (random_gen (random_gen (random_gen (random_gen string_imp)))))) : is_atomistic (has_top (random_gen (random_gen (random_gen (random_gen string_imp))))) := sorry --non-trivial
lemma new_lemma_170808 (h0 : functor.add_const (topological_space (boolean_algebra linarith.comp)) Type) : @topological_space.separable_space.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_170809 (h0 : topological_space (normed_lattice_add_comm_group (has_add linarith.comp))) : totally_disconnected_space (normed_lattice_add_comm_group (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_170810 (h0 : semiring (ordered_comm_monoid (finset (finset linarith.comp)))) : is_noetherian_ring (ordered_comm_monoid (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_170811 (h0 : ring (random_gen empty)) (h1 : ring (ring.total_positive_cone (random_gen empty))) : is_domain (ring.total_positive_cone (random_gen empty)) := sorry --non-trivial
lemma new_lemma_170812 (h0 : fin has_zero.zero) : @ulower.up.{0} Prop encodable.Prop (@id.{1} (@ulower.{0} Prop encodable.Prop) (@matrix.vec_empty.{0} (@ulower.{0} Prop encodable.Prop) (@id.{1} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)))  := sorry --non-trivial
lemma new_lemma_170813 (h0 : function.extfun (Type 1) topological_space) : @loc_path_connected_space.{1} Type (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 Type)  := sorry --non-trivial
lemma new_lemma_170814 (h0 : functor.add_const (group (ordered_comm_ring pos)) name) : @normalizer_condition.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (ordered_comm_ring.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_170815 (h0 : complete_lattice (has_ssubset (comm_ring (has_nnnorm reducibility_hints)))) : complete_lattice.is_Sup_finite_compact (has_ssubset (comm_ring (has_nnnorm reducibility_hints))) := sorry --non-trivial
lemma new_lemma_170816 (h0 : functor.add_const (functor.add_const (topological_space pos) pos) Type) : @t0_space.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) pos (@functor.add_const.run.{0 1} (functor.add_const.{0 0} (topological_space.{0} pos) pos) Type h0))  := sorry --non-trivial
lemma new_lemma_170817 (h0 : has_mem.mem (linear_ordered_semiring linarith.comp) has_emptyc.emptyc) : @is_add_cyclic.{0} (linear_ordered_semiring.{0} linarith.comp) (@finset.pi.empty.{1 0} Type add_group.{0} (linear_ordered_semiring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_170818 (h0 : add_group (plift empty)) : is_add_cyclic (plift empty) := sorry --non-trivial
lemma new_lemma_170819 (h0 : group (with_bot linarith.comp)) : normalizer_condition (with_bot linarith.comp) := sorry --non-trivial
lemma new_lemma_170820 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_170821 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (with_bot.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (with_bot.{0} empty))  := sorry --non-trivial
lemma new_lemma_170822 (h0 : finset (non_assoc_semiring congr_arg_kind)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_170823 (h0 : functor.add_const (ring (boolean_algebra name)) pos) : @is_principal_ideal_ring.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_170824 (h0 : functor.add_const (ordered_add_comm_monoid (boolean_algebra name)) linarith.comp) : @archimedean.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (boolean_algebra.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_170825 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (has_edist.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (has_edist.{0} empty))  := sorry --non-trivial
lemma new_lemma_170826 (h0 : complete_lattice (has_zero (cancel_monoid (has_neg unsigned)))) : is_atomistic (has_zero (cancel_monoid (has_neg unsigned))) := sorry --non-trivial
lemma new_lemma_170827 (h0 : functor.add_const (topological_space (has_add pos)) linarith.comp) : @locally_compact_space.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_170828 (h0 : topological_space (semiring (semiring unsigned))) : locally_compact_space (semiring (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_170829 (h0 : function.extfun Type ring) : @is_domain.{0} (option.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (option.{0} pos))  := sorry --non-trivial
lemma new_lemma_170830 (h1 : complete_lattice (distrib_lattice string_imp)) : is_compactly_generated (distrib_lattice string_imp) := sorry --non-trivial
lemma new_lemma_170831 (h0 : functor.add_const (function.extfun (Type 1) topological_space) linarith.comp) : @totally_disconnected_space.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) linarith.comp h0) (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_170832 (h0 : not (uniform_space (topological_space char) -> false)) : @complete_space.{0} (topological_space.{0} char) (@classical.by_contradiction'.{1} (uniform_space.{0} (topological_space.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_170833 (h0 : ulower nat) (h1 h2 : fin (ulower.up h0)) : fin.lt h1 h2 := sorry --non-trivial
lemma new_lemma_170834 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (linear_ordered_field.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_field.{0} pos))  := sorry --non-trivial
lemma new_lemma_170835 (h0 : topological_space (add_comm_monoid (has_to_string Type))) : sequential_space (add_comm_monoid (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_170836 (h0 : has_neg (add_comm_semigroup ereal)) (h1 : measurable_space (add_comm_semigroup ereal)) : has_measurable_neg (add_comm_semigroup ereal) := sorry --non-trivial
lemma new_lemma_170837 (h0 : fin has_zero.zero) : @monoid.fg.{0} (ordered_comm_monoid.{0} pos) (@matrix.vec_empty.{0} (monoid.{0} (ordered_comm_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_170838 (h0 : group (simple_graph (boolean_algebra.core pos))) : group.fg (simple_graph (boolean_algebra.core pos)) := sorry --non-trivial
lemma new_lemma_170839 (h0 : function.extfun (finset Type) (has_mem.mem congr_arg_kind)) : @is_cyclic.{0} congr_arg_kind (@finset.pi.empty.{1 0} Type group.{0} congr_arg_kind (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) congr_arg_kind) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_170840 (h0 : topological_space (finset name)) : t0_space (finset name) := sorry --non-trivial
lemma new_lemma_170841 (h0 : ring (with_bot (random_gen (random_gen fun_info)))) : is_domain (with_bot (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_170842 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_ssubset.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_ssubset.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_170843 (h0 : functor.add_const (ring (ring pos)) (finset Type)) : @is_domain.{0} (ring.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (ring.{0} pos)) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_170844 (h0 : functor.add_const (list (left_cancel_monoid empty)) num) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_170845 (h0 : topological_space (with_bot (has_norm (has_emptyc fun_info)))) : locally_compact_space (with_bot (has_norm (has_emptyc fun_info))) := sorry --non-trivial
lemma new_lemma_170846 (h0 : group (measurable_space unsigned)) : is_cyclic (measurable_space unsigned) := sorry --non-trivial
lemma new_lemma_170847 (h0 : function.extfun Type ring) : @is_domain.{0} (normed_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (normed_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_170848 (h0 : not (ring (complete_linear_order congr_arg_kind) -> false)) : @strong_rank_condition.{0} (complete_linear_order.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (ring.{0} (complete_linear_order.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_170849 (h0 : option (has_vadd ennreal ennreal)) (h1 : has_vadd ennreal ennreal) (h2 h3 : measurable_space ennreal) : has_measurable_vadd₂ ennreal ennreal := sorry --non-trivial
lemma new_lemma_170850 (h1 : not (ring (random_gen linarith.ineq) -> false)) : @rank_condition.{0} (random_gen.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (random_gen.{0} linarith.ineq)) h1)  := sorry --non-trivial
lemma new_lemma_170851 (h0 : not (topological_space (linear_ordered_semiring linarith.ineq) -> false)) : @path_connected_space.{0} (linear_ordered_semiring.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_semiring.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_170852 (h0 : functor.add_const (function.extfun (Type 1) add_monoid) Type) : @add_monoid.fg.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_monoid.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) add_monoid.{1}) Type h0) (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_170853 (h0 : topological_space (has_Inf pos)) : locally_compact_space (has_Inf pos) := sorry --non-trivial
lemma new_lemma_170854 (h0 : function.extfun Type group) : @normalizer_condition.{0} (complete_distrib_lattice.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (complete_distrib_lattice.{0} empty))  := sorry --non-trivial
lemma new_lemma_170855 (h0 : function.extfun Type topological_space) : @t1_space.{0} (option.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (option.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_170856 (h0 : topological_space (has_one (has_norm (random_gen fun_info)))) : totally_disconnected_space (has_one (has_norm (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_170857 (h0 : complete_lattice (semiring (has_top fun_info))) : is_compactly_generated (semiring (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_170858 (h0 : functor.add_const (uniform_space (ordered_comm_ring pos)) (has_add pos)) : @complete_space.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (ordered_comm_ring.{0} pos)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_170859 (h0 : ring (ordered_comm_monoid (has_Inf Type))) : rank_condition (ordered_comm_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_170860 (h0 : ring (canonically_ordered_comm_semiring (option name))) : strong_rank_condition (canonically_ordered_comm_semiring (option name)) := sorry --non-trivial
lemma new_lemma_170861 (h0 : add_monoid (with_bot linarith.comp_source)) (h1 : with_bot linarith.comp_source) : is_of_fin_add_order h1 := sorry --non-trivial
lemma new_lemma_170862 (h0 : cancel_comm_monoid_with_zero (boolean_algebra (boolean_algebra Type))) : unique_factorization_monoid (boolean_algebra (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_170863 (h0 : topological_space (non_unital_non_assoc_semiring reducibility_hints)) (h1 : preorder (non_unital_non_assoc_semiring reducibility_hints)) : order_topology (non_unital_non_assoc_semiring reducibility_hints) := sorry --non-trivial
lemma new_lemma_170864 (h0 : function.extfun Type group) : @is_cyclic.{0} (add_cancel_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (add_cancel_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_170865 (h0 : group (has_ssubset (random_gen (random_gen linarith.ineq)))) : is_cyclic (has_ssubset (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_170866 (h0 : cancel_comm_monoid_with_zero (mul_zero_class (cancel_monoid pos))) : unique_factorization_monoid (mul_zero_class (cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_170867 (h0 : ordered_add_comm_monoid (has_zero pos)) : archimedean (has_zero pos) := sorry --non-trivial
lemma new_lemma_170868 (h0 : function.extfun (Type 1) filter) : countable_Inter_filter (function.extfun_app h0 (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_170869 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (linear_ordered_cancel_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_cancel_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_170870 (h0 : ring (has_union (semiring (has_norm (has_norm linarith.comp))))) : rank_condition (has_union (semiring (has_norm (has_norm linarith.comp)))) := sorry --non-trivial
lemma new_lemma_170871 (h0 : has_mem.mem (semiring congr_arg_kind) has_emptyc.emptyc) : @normalizer_condition.{0} (semiring.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type group.{0} (semiring.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_170872 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_170873 (h0 : functor.comp ring has_neg_part Type) : @is_principal_ideal_ring.{1} (has_neg_part.{1} Type) (@functor.comp.run.{1 1 1} ring.{1} has_neg_part.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_170874 (h0 : functor.add_const (ring (has_nndist environment.implicit_infer_kind)) environment.implicit_infer_kind) : @is_principal_ideal_ring.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (has_nndist.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_170875 (h1 : has_mul (id linarith.comp_source)) (h2 : id linarith.comp_source) : is_regular h2 := sorry --non-trivial
lemma new_lemma_170876 (h0 : group (comm_group (ring (finset environment.implicit_infer_kind)))) : is_simple_group (comm_group (ring (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_170877 (h0 : functor.comp group has_nndist pos) : @is_simple_group.{0} (has_nndist.{0} pos) (@functor.comp.run.{0 0 0} group.{0} has_nndist.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_170878 (h0 : topological_space (semi_normed_comm_ring (distrib char))) : t0_space (semi_normed_comm_ring (distrib char)) := sorry --non-trivial
lemma new_lemma_170879 (h0 : has_scalar char char) (h1 : ring (add_comm_semigroup (plift (has_faithful_scalar char char)))) : is_domain (add_comm_semigroup (plift (has_faithful_scalar char char))) := sorry --non-trivial
lemma new_lemma_170880 (h0 : topological_space (omega_complete_partial_order (option (option (option empty))))) : discrete_topology (omega_complete_partial_order (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_170881 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @separated_space.{0} (group_with_zero.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) uniform_space.{0}) (group_with_zero.{0} num))  := sorry --non-trivial
lemma new_lemma_170882 (h0 : function.extfun (Type 1) cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{1} (add_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1} h0 (add_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_170883 (h0 : functor.add_const (topological_space (has_nndist name)) environment.implicit_infer_kind) : @totally_separated_space.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_170884 (h0 : uniform_space (has_inv (random_gen (has_inv linarith.ineq)))) : complete_space (has_inv (random_gen (has_inv linarith.ineq))) := sorry --non-trivial
lemma new_lemma_170885 (h0 : complete_lattice (ordered_comm_group congr_arg_kind)) : is_atomistic (ordered_comm_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_170886 (h0 : uniform_space (monoid_with_zero congr_arg_kind)) : separated_space (monoid_with_zero congr_arg_kind) := sorry --non-trivial
lemma new_lemma_170887 (h0 : complete_lattice (has_pos_part (ring (has_add (ring Type))))) : is_compactly_generated (has_pos_part (ring (has_add (ring Type)))) := sorry --non-trivial
lemma new_lemma_170888 (h0 : ring (add_comm_monoid Type)) : is_domain (add_comm_monoid Type) := sorry --non-trivial
lemma new_lemma_170889 (h0 : functor.add_const (topological_space (add_comm_monoid environment.implicit_infer_kind)) name) : @t0_space.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_170890 (h0 : ring (add_left_cancel_monoid (fintype linarith.comp_source))) : is_domain (add_left_cancel_monoid (fintype linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_170891 (h0 : ordered_comm_monoid (add_comm_monoid (has_add (cancel_monoid name)))) : has_exists_mul_of_le (add_comm_monoid (has_add (cancel_monoid name))) := sorry --non-trivial
lemma new_lemma_170892 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_170893 (h1 : has_mem.mem (measurable_space linarith.comp) has_emptyc.emptyc) : @complete_space.{0} (measurable_space.{0} linarith.comp) (@finset.pi.empty.{1 0} Type uniform_space.{0} (measurable_space.{0} linarith.comp) h1)  := sorry --non-trivial
lemma new_lemma_170894 (h0 : topological_space (metric_space (random_gen empty))) : path_connected_space (metric_space (random_gen empty)) := sorry --non-trivial
lemma new_lemma_170895 (h0 : function.extfun (finset Type) (has_mem.mem (with_bot num))) : @is_compactly_generated.{0} (with_bot.{0} num) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (with_bot.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_bot.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_170896 (h0 : uniform_space (uniform_space (linear_ordered_add_comm_group_with_top linarith.ineq))) : complete_space (uniform_space (linear_ordered_add_comm_group_with_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_170897 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (ring.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_170898 (h0 : not (uniform_space (uniform_space char) -> false)) : @separated_space.{0} (uniform_space.{0} char) (@classical.by_contradiction'.{1} (uniform_space.{0} (uniform_space.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_170899 (h0 : complete_lattice (ring (has_to_string Type))) : is_compactly_generated (ring (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_170900 (h0 : functor.add_const (uniform_space (has_Inf linarith.comp)) linarith.comp) : @complete_space.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_Inf.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_170901 (h0 : has_mem.mem (random_gen linarith.comp) has_emptyc.emptyc) : @rank_condition.{0} (random_gen.{0} linarith.comp) (@finset.pi.empty.{1 0} Type ring.{0} (random_gen.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_170902 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (measurable_space.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (measurable_space.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_170903 (h0 : topological_space (has_add (sub_neg_monoid real))) : path_connected_space (has_add (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_170904 (h0 : multiset (has_div string.iterator_imp)) (h1 : multiset (has_div string.iterator_imp) -> string.iterator_imp) (h2 : coe_sort (set.range h1)) : multiset.disjoint h0 (set.range_splitting h1 h2) := sorry --non-trivial
lemma new_lemma_170905 (h1 : ring (mul_one_class string.iterator_imp)) : strong_rank_condition (mul_one_class string.iterator_imp) := sorry --non-trivial
lemma new_lemma_170906 (h0 : topological_space (has_to_string (has_to_string linarith.comp))) : topological_space.separable_space (has_to_string (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_170907 (h0 : group (has_zero (has_neg (has_add Type)))) : normalizer_condition (has_zero (has_neg (has_add Type))) := sorry --non-trivial
lemma new_lemma_170908 (h0 : topological_space (partial_order (semiring unsigned))) : t0_space (partial_order (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_170909 (h0 : ring (ordered_comm_group unsigned)) : is_principal_ideal_ring (ordered_comm_group unsigned) := sorry --non-trivial
lemma new_lemma_170910 (h0 : functor.add_const (topological_space (has_nndist linarith.comp)) pos) : @totally_disconnected_space.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_170911 (h0 : ring (has_edist (linear_ordered_comm_monoid_with_zero empty))) : is_principal_ideal_ring (has_edist (linear_ordered_comm_monoid_with_zero empty)) := sorry --non-trivial
lemma new_lemma_170912 (h0 : complete_lattice (complete_semilattice_Sup congr_arg_kind)) : is_compactly_generated (complete_semilattice_Sup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_170913 (h0 : pnat) (h1 : nat) (h2 : vector (ulower pnat) (has_add.add h1 has_one.one)) : pnat.coprime h0 (ulower.up (vector.last h2)) := sorry --non-trivial
lemma new_lemma_170914 (h0 : prod (has_one (semiring (semiring empty))) (has_one (semiring (semiring empty)))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_170915 (h0 : topological_space (distrib_lattice (random_gen char))) : totally_disconnected_space (distrib_lattice (random_gen char)) := sorry --non-trivial
lemma new_lemma_170916 (h0 : topological_space (semiring (has_norm fun_info))) : totally_disconnected_space (semiring (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_170917 (h0 : topological_space (random_gen (has_norm (has_top to_additive.value_type)))) : discrete_topology (random_gen (has_norm (has_top to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_170918 (h0 : function.extfun Type (functor.add_const (ring (is_R_or_C empty)))) : @is_principal_ideal_ring.{0} (is_R_or_C.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (is_R_or_C.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} (is_R_or_C.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_170919 (h0 : topological_space (simple_graph (option empty))) : totally_separated_space (simple_graph (option empty)) := sorry --non-trivial
lemma new_lemma_170920 (h0 : ring (semigroup linarith.comp)) : is_domain (semigroup linarith.comp) := sorry --non-trivial
lemma new_lemma_170921 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (comm_semigroup.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_170922 (h0 : monoid (has_top (has_norm linarith.comp_source))) : monoid.fg (has_top (has_norm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_170923 (h0 : topological_space (has_neg (option ennreal))) : preconnected_space (has_neg (option ennreal)) := sorry --non-trivial
lemma new_lemma_170924 (h0 : list (ring (has_neg (has_zero name)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_170925 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (ordered_cancel_add_comm_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (ordered_cancel_add_comm_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_170926 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (canonically_ordered_comm_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (canonically_ordered_comm_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_170927 (h0 : complete_lattice (boolean_algebra (comm_group (comm_group Type)))) : is_atomistic (boolean_algebra (comm_group (comm_group Type))) := sorry --non-trivial
lemma new_lemma_170928 (h0 : not (group (linear_ordered_semiring congr_arg_kind) -> false)) : @group.fg.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (group.{0} (linear_ordered_semiring.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_170929 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (ordered_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_170930 (h1 : topological_space (linear_ordered_add_comm_group linarith.comp_source)) : totally_separated_space (linear_ordered_add_comm_group linarith.comp_source) := sorry --non-trivial
lemma new_lemma_170931 (h0 : ring (has_one num)) : rank_condition (has_one num) := sorry --non-trivial
lemma new_lemma_170932 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (distrib_lattice.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (distrib_lattice.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_170933 (h0 : functor.add_const (cancel_comm_monoid_with_zero (complete_distrib_lattice Type)) pos) : @unique_factorization_monoid.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 0} (cancel_comm_monoid_with_zero.{1} (complete_distrib_lattice.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_170934 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @preirreducible_space.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_170935 (h0 : fin has_zero.zero) : @preirreducible_space.{0} (normed_lattice_add_comm_group.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (normed_lattice_add_comm_group.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_170936 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_170937 (h0 : topological_space (denumerable (has_top string_imp))) : totally_disconnected_space (denumerable (has_top string_imp)) := sorry --non-trivial
lemma new_lemma_170938 (h0 : not (function.extfun Type group -> false)) : @group.fg.{0} (topological_space.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (topological_space.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_170939 (h2 : group (add_cancel_comm_monoid fun_info)) : is_cyclic (add_cancel_comm_monoid fun_info) := sorry --non-trivial
lemma new_lemma_170940 (h0 : group (generalized_boolean_algebra (has_Inf pos))) : is_simple_group (generalized_boolean_algebra (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_170941 (h3 : set (add_comm_semigroup linarith.ineq -> environment.implicit_infer_kind)) : set.separates_points h3 := sorry --non-trivial
lemma new_lemma_170942 (h0 : monoid (mul_zero_class (option empty))) : monoid.fg (mul_zero_class (option empty)) := sorry --non-trivial
lemma new_lemma_170943 (h0 : complete_lattice (option (semiring empty))) : is_compactly_generated (option (semiring empty)) := sorry --non-trivial
lemma new_lemma_170944 (h0 : uniform_space (semiring (has_top (semiring (has_top fun_info))))) : separated_space (semiring (has_top (semiring (has_top fun_info)))) := sorry --non-trivial
lemma new_lemma_170945 (h0 : topological_space (as_linear_order (add_comm_monoid empty))) : preirreducible_space (as_linear_order (add_comm_monoid empty)) := sorry --non-trivial
lemma new_lemma_170946 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @is_add_cyclic.{0} (add_cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) add_group.{0}) (add_cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_170947 (h0 : function.extfun Type topological_space) : @t0_space.{0} (normed_linear_ordered_group.{0} (option.{0} (has_bot.{0} (semiring.{0} unsigned)))) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_linear_ordered_group.{0} (option.{0} (has_bot.{0} (semiring.{0} unsigned)))))  := sorry --non-trivial
lemma new_lemma_170948 (h0 : set (mul_one_class char)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_170949 (h0 : topological_space (has_add (has_neg (finset (has_neg (finset linarith.comp)))))) : totally_separated_space (has_add (has_neg (finset (has_neg (finset linarith.comp))))) := sorry --non-trivial
lemma new_lemma_170950 (h0 : ring (random_gen (has_nnnorm to_additive.value_type))) : is_domain (random_gen (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_170951 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (monoid ennreal)) := sorry --non-trivial
lemma new_lemma_170952 (h0 : set (has_le fun_info)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_170953 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring pos)) Type) : @totally_separated_space.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (canonically_ordered_comm_semiring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_170954 (h0 : uniform_space (left_cancel_semigroup (has_nnnorm to_additive.value_type))) : complete_space (left_cancel_semigroup (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_170955 (h0 : ring (ring (has_add (has_add linarith.comp)))) : rank_condition (ring (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_170956 (h0 h1 : nat) (h2 : ulower nat) : nat.modeq (id h0) h1 (ulower.up h2) := sorry --non-trivial
lemma new_lemma_170957 (h0 : complete_lattice (normed_comm_ring (add_comm_monoid unsigned))) : is_atomistic (normed_comm_ring (add_comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_170958 (h0 : semiring (measurable_space.dynkin_system congr_arg_kind)) : is_noetherian_ring (measurable_space.dynkin_system congr_arg_kind) := sorry --non-trivial
lemma new_lemma_170959 (h0 : topological_space (add_cancel_monoid (add_cancel_monoid environment.implicit_infer_kind))) : totally_separated_space (add_cancel_monoid (add_cancel_monoid environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_170960 (h0 : monoid (canonically_ordered_comm_semiring unsigned)) : monoid.fg (canonically_ordered_comm_semiring unsigned) := sorry --non-trivial
lemma new_lemma_170961 (h1 : add_group (has_emptyc (has_norm fun_info))) : is_add_cyclic (has_emptyc (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_170962 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (has_nndist.{0} empty) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (has_nndist.{0} empty))  := sorry --non-trivial
lemma new_lemma_170963 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : add_monoid.fg ennreal := sorry --non-trivial
lemma new_lemma_170964 (h0 : topological_space (has_top (semiring (random_gen (random_gen fun_info))))) : totally_separated_space (has_top (semiring (random_gen (random_gen fun_info)))) := sorry --non-trivial
lemma new_lemma_170965 (h0 : topological_space (boolean_algebra.core (has_add environment.implicit_infer_kind))) : t1_space (boolean_algebra.core (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_170966 (h0 : add_monoid (normed_lattice_add_comm_group (ordered_comm_monoid (has_Inf real)))) : add_monoid.fg (normed_lattice_add_comm_group (ordered_comm_monoid (has_Inf real))) := sorry --non-trivial
lemma new_lemma_170967 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type monoid.{0} h0 (cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_170968 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (metric_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (metric_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_170969 (h0 : functor.add_const (complete_lattice (has_edist empty)) (semiring empty)) : @complete_lattice.is_Sup_finite_compact.{0} (has_edist.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_edist.{0} empty)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_170970 (h0 : topological_space (linear_ordered_field (option (option (option empty))))) : loc_path_connected_space (linear_ordered_field (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_170971 (h1 : not (uniform_space (denumerable char) -> false)) : @complete_space.{0} (denumerable.{0} char) (@classical.by_contradiction'.{1} (uniform_space.{0} (denumerable.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_170972 (h0 : topological_space (has_to_string (has_Inf linarith.comp))) : path_connected_space (has_to_string (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_170973 (h0 : functor.add_const (topological_space (boolean_algebra environment.implicit_infer_kind)) Type) : @locally_compact_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_170974 (h0 : function.extfun Type topological_space) : @t0_space.{0} (pseudo_metric_space.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (pseudo_metric_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_170975 (h0 : topological_space (has_to_string (mul_zero_class pos))) : locally_compact_space (has_to_string (mul_zero_class pos)) := sorry --non-trivial
lemma new_lemma_170976 (h0 : uniform_space (comm_group (finset linarith.comp))) : separated_space (comm_group (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_170977 (h0 : fin has_zero.zero) : @unique_factorization_monoid.{0} (ring.{0} real) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type cancel_comm_monoid_with_zero.{0}) h0) (ring.{0} real))  := sorry --non-trivial
lemma new_lemma_170978 (h0 : add_group (has_compl (has_nnnorm linarith.ineq))) : is_add_cyclic (has_compl (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_170979 (h0 : complete_lattice (has_neg environment.implicit_infer_kind)) : complete_lattice.is_Sup_finite_compact (has_neg environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_170980 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (ring.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (ring.{0} num))  := sorry --non-trivial
lemma new_lemma_170981 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (random_gen.{0} linarith.ineq) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (random_gen.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_170982 (h0 : uniform_space (normed_comm_ring (has_neg_part (has_neg Type)))) : separated_space (normed_comm_ring (has_neg_part (has_neg Type))) := sorry --non-trivial
lemma new_lemma_170983 (h0 : ring (has_add (has_pos_part real))) : rank_condition (has_add (has_pos_part real)) := sorry --non-trivial
lemma new_lemma_170984 (h0 : ring (uniform_space (has_nnnorm enat))) : rank_condition (uniform_space (has_nnnorm enat)) := sorry --non-trivial
lemma new_lemma_170985 (h0 : topological_space stieltjes_function) : path_connected_space stieltjes_function := sorry --non-trivial
lemma new_lemma_170986 (h2 : topological_space linarith.ineq) : topological_space.first_countable_topology linarith.ineq := sorry --non-trivial
lemma new_lemma_170987 (h0 : filter (has_neg_part Type)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_170988 (h0 : ring (id fun_info)) : rank_condition (id fun_info) := sorry --non-trivial
lemma new_lemma_170989 (h1 : ring (distrib (has_ssubset char))) : strong_rank_condition (distrib (has_ssubset char)) := sorry --non-trivial
lemma new_lemma_170990 (h0 : ring (finset (has_add Type))) : rank_condition (finset (has_add Type)) := sorry --non-trivial
lemma new_lemma_170991 (h0 : functor.add_const (topological_space (comm_group Type)) Type) : @locally_compact_space.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (comm_group.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_170992 (h0 : functor.add_const (filter (right_cancel_semigroup pos)) linarith.comp) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_170993 (h1 : add_group (topological_space (fintype char))) : is_add_cyclic (topological_space (fintype char)) := sorry --non-trivial
lemma new_lemma_170994 (h0 : functor.add_const (list (add_cancel_monoid pos)) (has_Inf linarith.comp)) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_170995 (h0 : topological_space (has_bot (has_Inf Type))) : irreducible_space (has_bot (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_170996 (h0 : function.extfun (finset Type) (has_mem.mem (has_one linarith.comp))) : @t0_space.{0} (has_one.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_one.{0} linarith.comp) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_one.{0} linarith.comp)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_170997 (h0 : functor.add_const (function.extfun Type uniform_space) environment.implicit_infer_kind) : @separated_space.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) environment.implicit_infer_kind h0) (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_170998 (h0 : ring (has_add (option (option ennreal)))) : is_domain (has_add (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_170999 (h0 : topological_space (random_gen (semiring (semiring (semiring empty))))) : preirreducible_space (random_gen (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_171000 (h0 : complete_lattice (boolean_algebra.core (boolean_algebra name))) : is_atomistic (boolean_algebra.core (boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_171001 (h0 : uniform_space (mul_zero_class (boolean_algebra.core pos))) : complete_space (mul_zero_class (boolean_algebra.core pos)) := sorry --non-trivial
lemma new_lemma_171002 (h0 : group (add_group (semiring linarith.comp))) : is_cyclic (add_group (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_171003 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @is_compactly_generated.{0} empty (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) complete_lattice.{0}) empty)  := sorry --non-trivial
lemma new_lemma_171004 (h0 : function.extfun Type (prod (is_R_or_C unsigned))) : id_rel (function.extfun_app h0 (is_R_or_C unsigned)) := sorry --non-trivial
lemma new_lemma_171005 (h0 : functor.add_const (uniform_space (boolean_algebra linarith.comp)) name) : @complete_space.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (boolean_algebra.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_171006 (h0 : topological_space (with_one (has_top (measurable_space empty)))) : irreducible_space (with_one (has_top (measurable_space empty))) := sorry --non-trivial
lemma new_lemma_171007 (h0 : topological_space (has_inter congr_arg_kind)) : topological_space.separable_space (has_inter congr_arg_kind) := sorry --non-trivial
lemma new_lemma_171008 (h0 : group (ring Type)) : is_simple_group (ring Type) := sorry --non-trivial
lemma new_lemma_171009 (h0 : complete_lattice (has_neg_part (has_add (has_add pos)))) : complete_lattice.is_Sup_finite_compact (has_neg_part (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_171010 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (pseudo_metric_space.{0} ennreal) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (pseudo_metric_space.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_171011 (h0 : monoid (canonically_ordered_comm_semiring congr_arg_kind)) : monoid.fg (canonically_ordered_comm_semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_171012 (h0 : topological_space (canonically_linear_ordered_monoid ennreal)) : irreducible_space (canonically_linear_ordered_monoid ennreal) := sorry --non-trivial
lemma new_lemma_171013 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (finset.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (finset.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_171014 (h0 : functor.add_const (topological_space (normed_comm_ring pos)) pos) : @discrete_topology.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_171015 (h0 : topological_space (normed_lattice_add_comm_group real)) : preconnected_space (normed_lattice_add_comm_group real) := sorry --non-trivial
lemma new_lemma_171016 (h0 : not (monoid (has_union linarith.comp) -> false)) : @monoid.fg.{0} (has_union.{0} linarith.comp) (@classical.by_contradiction'.{1} (monoid.{0} (has_union.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_171017 (h0 : functor.add_const (topological_space (has_neg linarith.comp)) environment.implicit_infer_kind) : @irreducible_space.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_171018 (h2 : ring (random_gen linarith.comp_source)) : strong_rank_condition (random_gen linarith.comp_source) := sorry --non-trivial
lemma new_lemma_171019 (h0 : functor.add_const (topological_space (semigroup Type)) pos) : @totally_disconnected_space.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (semigroup.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_171020 (h0 : group (with_zero (linear_ordered_add_comm_group char))) : group.fg (with_zero (linear_ordered_add_comm_group char)) := sorry --non-trivial
lemma new_lemma_171021 (h0 : complete_lattice (finset (has_Inf real))) : is_atomistic (finset (has_Inf real)) := sorry --non-trivial
lemma new_lemma_171022 (h0 : ring (linear_ordered_add_comm_group (has_inv (emetric_space char)))) : is_domain (linear_ordered_add_comm_group (has_inv (emetric_space char))) := sorry --non-trivial
lemma new_lemma_171023 (h0 : not (complete_lattice (complete_semilattice_Sup empty) -> false)) : @is_atomistic.{0} (complete_semilattice_Sup.{0} empty) (@classical.by_contradiction'.{1} (complete_lattice.{0} (complete_semilattice_Sup.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_171024 (h0 : functor.add_const (topological_space (ordered_comm_ring linarith.comp)) (boolean_algebra.core linarith.comp)) : @preirreducible_space.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} linarith.comp)) (boolean_algebra.core.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_171025 (h0 : topological_space (comm_monoid unsigned)) : loc_path_connected_space (comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_171026 (h0 : ring (semi_normed_comm_ring (set string_imp))) : strong_rank_condition (semi_normed_comm_ring (set string_imp)) := sorry --non-trivial
lemma new_lemma_171027 (h0 : add_group (has_emptyc (random_gen (random_gen (random_gen fun_info))))) : is_add_cyclic (has_emptyc (random_gen (random_gen (random_gen fun_info)))) := sorry --non-trivial
lemma new_lemma_171028 (h0 : complete_lattice (ordered_comm_ring (has_pos_part pos))) : is_compactly_generated (ordered_comm_ring (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_171029 (h0 : topological_space (boolean_algebra (has_Inf Type))) : locally_compact_space (boolean_algebra (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_171030 (h0 : functor.add_const (cancel_comm_monoid_with_zero (add_left_cancel_semigroup unsigned)) unsigned) : @unique_factorization_monoid.{0} (add_left_cancel_semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (add_left_cancel_semigroup.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_171031 (h0 : fin has_zero.zero) : @complete_space.{1} (has_pos_part.{1} Type) (@matrix.vec_empty.{1} (uniform_space.{1} (has_pos_part.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_171032 (h0 : prod (option (option empty)) (option (option empty))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_171033 (h0 : not (cancel_comm_monoid_with_zero (measure_theory.measure_space num) -> false)) : @unique_factorization_monoid.{0} (measure_theory.measure_space.{0} num) (@classical.by_contradiction'.{1} (cancel_comm_monoid_with_zero.{0} (measure_theory.measure_space.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_171034 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_171035 (h0 : fin has_zero.zero) : @sequential_space.{1} (has_add.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (has_add.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_171036 (h0 : uniform_space (linear_order num)) : separated_space (linear_order num) := sorry --non-trivial
lemma new_lemma_171037 (h0 : ring (denumerable (has_nnnorm string_imp))) : is_domain (denumerable (has_nnnorm string_imp)) := sorry --non-trivial
lemma new_lemma_171038 (h0 : topological_space (mul_zero_class (finset name))) : t0_space (mul_zero_class (finset name)) := sorry --non-trivial
lemma new_lemma_171039 (h1 : topological_space (normed_group linarith.comp)) : locally_compact_space (normed_group linarith.comp) := sorry --non-trivial
lemma new_lemma_171040 (h0 : topological_space (comm_group (has_neg linarith.comp))) : loc_path_connected_space (comm_group (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_171041 (h0 : topological_space (boolean_algebra (comm_group Type))) : totally_separated_space (boolean_algebra (comm_group Type)) := sorry --non-trivial
lemma new_lemma_171042 (h0 : complete_lattice (normed_comm_ring (has_add (normed_comm_ring name)))) : is_compactly_generated (normed_comm_ring (has_add (normed_comm_ring name))) := sorry --non-trivial
lemma new_lemma_171043 (h0 : function.extfun (Type 1) topological_space) : @regular_space.{1} (has_zero.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_zero.{1} Type))  := sorry --non-trivial
lemma new_lemma_171044 (h1 : uniform_space (random_gen congr_arg_kind)) : separated_space (random_gen congr_arg_kind) := sorry --non-trivial
lemma new_lemma_171045 (h0 : ring (distrib (has_ssubset (has_nnnorm linarith.ineq)))) : is_domain (distrib (has_ssubset (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_171046 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_edist.{0} (semiring.{0} num)) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_edist.{0} (semiring.{0} num)))  := sorry --non-trivial
lemma new_lemma_171047 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_simple_group.{0} (canonically_ordered_comm_semiring.{0} (mul_zero_class.{0} name)) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (canonically_ordered_comm_semiring.{0} (mul_zero_class.{0} name)))  := sorry --non-trivial
lemma new_lemma_171048 (h0 : uniform_space (denumerable (random_gen (comm_ring (random_gen reducibility_hints))))) : complete_space (denumerable (random_gen (comm_ring (random_gen reducibility_hints)))) := sorry --non-trivial
lemma new_lemma_171049 (h0 : add_group (has_add (ring (has_zero (mul_one_class pos))))) : is_add_cyclic (has_add (ring (has_zero (mul_one_class pos)))) := sorry --non-trivial
lemma new_lemma_171050 (h0 : functor.add_const (ordered_comm_monoid (has_Inf linarith.comp)) linarith.comp) : @has_exists_mul_of_le.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_Inf.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_171051 (h0 : topological_space (metric_space (has_top (has_top empty)))) : irreducible_space (metric_space (has_top (has_top empty))) := sorry --non-trivial
lemma new_lemma_171052 (h0 : functor.add_const (ordered_comm_monoid (cancel_monoid name)) (boolean_algebra.core pos)) : @has_exists_mul_of_le.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (cancel_monoid.{0} name)) (boolean_algebra.core.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_171053 (h0 : ring (comm_ring (fintype fun_info))) : strong_rank_condition (comm_ring (fintype fun_info)) := sorry --non-trivial
lemma new_lemma_171054 (h0 : ring (has_sub congr_arg_kind)) : is_domain (has_sub congr_arg_kind) := sorry --non-trivial
lemma new_lemma_171055 (h0 : functor.add_const (topological_space (as_linear_order empty)) (option empty)) : @irreducible_space.{0} (as_linear_order.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (as_linear_order.{0} empty)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_171056 (h0 : add_group (with_one linarith.comp_source)) : is_add_cyclic (with_one linarith.comp_source) := sorry --non-trivial
lemma new_lemma_171057 (h0 : functor.add_const (uniform_space (has_zero environment.implicit_infer_kind)) environment.implicit_infer_kind) : @complete_space.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_zero.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_171058 (h0 : add_group (generalized_boolean_algebra (comm_semigroup pos))) : is_add_cyclic (generalized_boolean_algebra (comm_semigroup pos)) := sorry --non-trivial
lemma new_lemma_171059 (h0 : not (group (add_group linarith.comp) -> false)) : @normalizer_condition.{0} (add_group.{0} linarith.comp) (@classical.by_contradiction'.{1} (group.{0} (add_group.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_171060 (h0 : functor.add_const (topological_space (pseudo_metric_space pos)) pos) : @totally_disconnected_space.{0} (pseudo_metric_space.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (pseudo_metric_space.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_171061 (h0 : functor.add_const (topological_space (boolean_algebra.core Type)) (comm_group name)) : @irreducible_space.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.core.{1} Type)) (comm_group.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_171062 (h0 : add_monoid (add_right_cancel_monoid empty)) : add_monoid.fg (add_right_cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_171063 (h0 : not (functor.add_const Prop (normed_field (comm_ring (normed_field (has_nnnorm linarith.comp_source)))) -> false)) : functor.add_const.run (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_171064 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (linear_ordered_comm_monoid_with_zero.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_comm_monoid_with_zero.{0} empty))  := sorry --non-trivial
lemma new_lemma_171065 (h0 : topological_space (canonically_ordered_comm_semiring (option (option pos)))) : irreducible_space (canonically_ordered_comm_semiring (option (option pos))) := sorry --non-trivial
lemma new_lemma_171066 (h0 : ring (div_inv_monoid fun_info)) : is_domain (div_inv_monoid fun_info) := sorry --non-trivial
lemma new_lemma_171067 (h0 : function.extfun (Type 1) uniform_space) : @separated_space.{1} (has_neg.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} h0 (has_neg.{1} Type))  := sorry --non-trivial
lemma new_lemma_171068 (h0 : topological_space (random_gen (random_gen congr_arg_kind))) : discrete_topology (random_gen (random_gen congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_171069 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (ordered_comm_group.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_171070 (h6 : prod (add_comm_semigroup char) (add_comm_semigroup char)) : set.diagonal (add_comm_semigroup char) h6 := sorry --non-trivial
lemma new_lemma_171071 (h0 : topological_space (semiring string_imp)) : irreducible_space (semiring string_imp) := sorry --non-trivial
lemma new_lemma_171072 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (with_bot.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} h0 (with_bot.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_171073 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (partial_order.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (partial_order.{0} num))  := sorry --non-trivial
lemma new_lemma_171074 (h2 : filter (denumerable to_additive.value_type)) : filter.ne_bot h2 := sorry --non-trivial
lemma new_lemma_171075 (h1 : complete_lattice (has_ssubset environment.projection_info)) : complete_lattice.is_Sup_finite_compact (has_ssubset environment.projection_info) := sorry --non-trivial
lemma new_lemma_171076 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @sequential_space.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_171077 (h1 : ring (denumerable (random_gen (random_gen (random_gen (random_gen (random_gen char))))))) : is_domain (denumerable (random_gen (random_gen (random_gen (random_gen (random_gen char)))))) := sorry --non-trivial
lemma new_lemma_171078 (h0 : topological_space (has_zero name)) : topological_space.separable_space (has_zero name) := sorry --non-trivial
lemma new_lemma_171079 (h0 : list (finset (finset (has_nndist name)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_171080 (h0 : ring (with_one (has_nnnorm linarith.comp_source))) : is_domain (with_one (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_171081 (h0 : functor.add_const (complete_lattice (pseudo_metric_space pos)) pos) : @is_compactly_generated.{0} (pseudo_metric_space.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (pseudo_metric_space.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_171082 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @discrete_topology.{0} (has_norm.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_norm.{0} num))  := sorry --non-trivial
lemma new_lemma_171083 (h0 : functor.add_const (topological_space (has_zero linarith.comp)) (has_pos_part linarith.comp)) : @totally_disconnected_space.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} linarith.comp)) (has_pos_part.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_171084 (h0 : functor.add_const (monoid (omega_complete_partial_order empty)) unsigned) : @monoid.fg.{0} (omega_complete_partial_order.{0} empty) (@functor.add_const.run.{0 0} (monoid.{0} (omega_complete_partial_order.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_171085 (h0 : fin has_zero.zero) : @topological_space.separable_space.{1} (has_pos_part.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (has_pos_part.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_171086 (h0 : topological_space (has_Sup (option empty))) : path_connected_space (has_Sup (option empty)) := sorry --non-trivial
lemma new_lemma_171087 (h0 : complete_lattice (distrib (has_ssubset char))) : is_compactly_generated (distrib (has_ssubset char)) := sorry --non-trivial
lemma new_lemma_171088 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (has_to_string.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_to_string.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_171089 (h0 : functor.add_const (functor.add_const Prop environment.implicit_infer_kind) linarith.comp) : functor.add_const.run (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_171090 (h0 : uniform_space (has_sub (has_top empty))) : separated_space (has_sub (has_top empty)) := sorry --non-trivial
lemma new_lemma_171091 (h0 : function.extfun (Type 1) complete_lattice) : @is_compactly_generated.{1} (has_pos_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} h0 (has_pos_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_171092 (h0 : ordered_add_comm_monoid (add_semigroup (semiring (semiring (semiring empty))))) : archimedean (add_semigroup (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_171093 (h0 : topological_space (metric_space linarith.comp)) : irreducible_space (metric_space linarith.comp) := sorry --non-trivial
lemma new_lemma_171094 (h0 : group (has_edist (option (option (option (option (option (option unsigned)))))))) : is_cyclic (has_edist (option (option (option (option (option (option unsigned))))))) := sorry --non-trivial
lemma new_lemma_171095 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (@id.{2} Type unsigned) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (@id.{2} Type unsigned))  := sorry --non-trivial
lemma new_lemma_171096 (h0 : complete_lattice (canonically_ordered_monoid (has_bot (has_Inf real)))) : complete_lattice.is_Sup_finite_compact (canonically_ordered_monoid (has_bot (has_Inf real))) := sorry --non-trivial
lemma new_lemma_171097 (h0 : monoid (has_nndist (has_add pos))) : monoid.fg (has_nndist (has_add pos)) := sorry --non-trivial
lemma new_lemma_171098 (h0 : add_group (comm_group (comm_group name))) : is_add_cyclic (comm_group (comm_group name)) := sorry --non-trivial
lemma new_lemma_171099 (h0 : function.extfun Type group) : @group.fg.{0} (has_nndist.{0} real) (@function.extfun_app.{2 1} Type group.{0} h0 (has_nndist.{0} real))  := sorry --non-trivial
lemma new_lemma_171100 (h0 : functor.add_const (topological_space (is_R_or_C empty)) empty) : @discrete_topology.{0} (is_R_or_C.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (is_R_or_C.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_171101 (h0 : filter (has_zero (option unsigned))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_171102 (h0 : ring (complete_semilattice_Sup (has_nnnorm (random_gen (random_gen char))))) : rank_condition (complete_semilattice_Sup (has_nnnorm (random_gen (random_gen char)))) := sorry --non-trivial
lemma new_lemma_171103 (h0 : topological_space (generalized_boolean_algebra pos)) : topological_space.separable_space (generalized_boolean_algebra pos) := sorry --non-trivial
lemma new_lemma_171104 (h0 : topological_space (ring (option unsigned))) : path_connected_space (ring (option unsigned)) := sorry --non-trivial
lemma new_lemma_171105 (h0 : complete_lattice (linear_ordered_field empty)) : is_compactly_generated (linear_ordered_field empty) := sorry --non-trivial
lemma new_lemma_171106 (h0 : ring (add_comm_semigroup (mul_one_class (add_comm_semigroup fun_info)))) : strong_rank_condition (add_comm_semigroup (mul_one_class (add_comm_semigroup fun_info))) := sorry --non-trivial
lemma new_lemma_171107 (h0 : functor.add_const (functor.add_const (group Type) Type) pos) : @normalizer_condition.{1} Type (@functor.add_const.run.{1 1} (group.{1} Type) Type (@functor.add_const.run.{1 0} (functor.add_const.{1 1} (group.{1} Type) Type) pos h0))  := sorry --non-trivial
lemma new_lemma_171108 (h0 : add_group (linear_ordered_comm_group_with_zero (semi_normed_comm_ring reducibility_hints))) : is_add_cyclic (linear_ordered_comm_group_with_zero (semi_normed_comm_ring reducibility_hints)) := sorry --non-trivial
lemma new_lemma_171109 (h0 : topological_space (generalized_boolean_algebra (boolean_algebra.core pos))) : t0_space (generalized_boolean_algebra (boolean_algebra.core pos)) := sorry --non-trivial
lemma new_lemma_171110 (h0 : group (has_append (comm_ring linarith.comp_source))) : is_cyclic (has_append (comm_ring linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_171111 (h0 : list (canonically_ordered_comm_semiring (option (option empty)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_171112 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (ordered_cancel_add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (ordered_cancel_add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_171113 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (topological_space.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (topological_space.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_171114 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (canonically_ordered_comm_semiring empty)) := sorry --non-trivial
lemma new_lemma_171115 (h0 : uniform_space (semiring (semiring num))) : complete_space (semiring (semiring num)) := sorry --non-trivial
lemma new_lemma_171116 (h0 : uniform_space (has_nndist (has_add environment.implicit_infer_kind))) : separated_space (has_nndist (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_171117 (h0 : topological_space (normed_comm_ring (finset (finset (finset pos))))) : loc_path_connected_space (normed_comm_ring (finset (finset (finset pos)))) := sorry --non-trivial
lemma new_lemma_171118 (h0 : functor.add_const Prop (add_comm_monoid unsigned)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_171119 (h0 : functor.add_const (topological_space (finset unsigned)) pos) : @discrete_topology.{0} (finset.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_171120 (h0 : topological_space (mul_zero_class num)) : preconnected_space (mul_zero_class num) := sorry --non-trivial
lemma new_lemma_171121 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (non_assoc_semiring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (non_assoc_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_171122 (h0 : uniform_space (has_star unsigned)) : separated_space (has_star unsigned) := sorry --non-trivial
lemma new_lemma_171123 (h0 : topological_space (free_add_monoid (semiring unsigned))) : normal_space (free_add_monoid (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_171124 (h2 : prod enat enat) : set.diagonal enat h2 := sorry --non-trivial
lemma new_lemma_171125 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem ring)) : @rank_condition.{0} (with_one.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) ring.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (with_one.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_171126 (h1 : group (topological_space (comm_ring (has_nnnorm reducibility_hints)))) : is_cyclic (topological_space (comm_ring (has_nnnorm reducibility_hints))) := sorry --non-trivial
lemma new_lemma_171127 (h0 : function.extfun Type ring) : @rank_condition.{0} real.angle (@function.extfun_app.{2 1} Type ring.{0} h0 real.angle)  := sorry --non-trivial
lemma new_lemma_171128 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (normed_group.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (normed_group.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_171129 (h0 : filter (has_pos_part (ring (has_add Type)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_171130 (h1 : ring (distrib (comm_ring char))) : is_domain (distrib (comm_ring char)) := sorry --non-trivial
lemma new_lemma_171131 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (with_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_group.{0} h0 (with_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_171132 (h0 : topological_space (measurable_space (has_emptyc (measurable_space linarith.comp)))) : totally_disconnected_space (measurable_space (has_emptyc (measurable_space linarith.comp))) := sorry --non-trivial
lemma new_lemma_171133 (h0 : monoid (linear_ordered_semiring (has_norm (has_norm empty)))) : monoid.fg (linear_ordered_semiring (has_norm (has_norm empty))) := sorry --non-trivial
lemma new_lemma_171134 (h0 : functor.add_const (topological_space (generalized_boolean_algebra linarith.comp)) linarith.comp) : @preirreducible_space.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_171135 (h0 : add_monoid (with_bot (measurable_space empty))) : add_monoid.fg (with_bot (measurable_space empty)) := sorry --non-trivial
lemma new_lemma_171136 (h0 : functor.add_const (topological_space (ordered_comm_monoid real)) real) : @topological_space.separable_space.{0} (ordered_comm_monoid.{0} real) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_monoid.{0} real)) real h0)  := sorry --non-trivial
lemma new_lemma_171137 (h0 : ring (add_cancel_comm_monoid (random_gen (random_gen linarith.ineq)))) : strong_rank_condition (add_cancel_comm_monoid (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_171138 (h0 : function.extfun Type topological_space) : @t1_space.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_171139 (h0 : topological_space (has_lt (mul_one_class string.iterator_imp))) : totally_disconnected_space (has_lt (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_171140 (h0 : functor.add_const (list (ring unsigned)) linarith.comp) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_171141 (h0 : semiring (canonically_linear_ordered_add_monoid unsigned)) : is_noetherian_ring (canonically_linear_ordered_add_monoid unsigned) := sorry --non-trivial
lemma new_lemma_171142 (h0 : topological_space (has_to_string (cancel_monoid (ring linarith.comp)))) : normal_space (has_to_string (cancel_monoid (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_171143 (h0 : ring (has_one (id (semiring congr_arg_kind)))) : is_domain (has_one (id (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_171144 (h0 : functor.add_const (complete_lattice (pseudo_metric_space pos)) name) : @is_compactly_generated.{0} (pseudo_metric_space.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (pseudo_metric_space.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_171145 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (add_comm_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (add_comm_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_171146 (h0 : add_monoid (measurable_space linarith.comp)) (h1 : add_submonoid (measurable_space linarith.comp)) : add_submonoid.fg h1 := sorry --non-trivial
lemma new_lemma_171147 (h0 : topological_space (sub_neg_monoid (has_Inf (has_Inf pos)))) : totally_separated_space (sub_neg_monoid (has_Inf (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_171148 (h0 : topological_space (option (semiring num))) : discrete_topology (option (semiring num)) := sorry --non-trivial
lemma new_lemma_171149 (h0 : topological_space (has_inter congr_arg_kind)) : path_connected_space (has_inter congr_arg_kind) := sorry --non-trivial
lemma new_lemma_171150 (h0 : functor.add_const (ordered_comm_monoid (has_add linarith.comp)) (ring (normed_linear_ordered_group Type))) : @has_exists_mul_of_le.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (has_add.{0} linarith.comp)) (ring.{1} (normed_linear_ordered_group.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_171151 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (ordered_cancel_add_comm_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (ordered_cancel_add_comm_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_171152 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_top.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (has_top.{0} num))  := sorry --non-trivial
lemma new_lemma_171153 (h1 : list (linear_ordered_add_comm_group string_imp)) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_171154 (h0 : not (filter (semi_normed_comm_ring linarith.comp_source) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_171155 (h0 : cancel_comm_monoid_with_zero (has_neg (option pos))) : unique_factorization_monoid (has_neg (option pos)) := sorry --non-trivial
lemma new_lemma_171156 (h0 : functor.add_const (group (boolean_algebra Type)) pos) : @normalizer_condition.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (boolean_algebra.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_171157 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (with_one.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} (has_top.{0} fun_info)))))) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (with_one.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} (has_top.{0} fun_info)))))))  := sorry --non-trivial
lemma new_lemma_171158 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (as_linear_order.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (as_linear_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_171159 (h0 : filter (complete_semilattice_Sup (semiring congr_arg_kind))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_171160 (h0 : ring (has_to_string num)) : is_domain (has_to_string num) := sorry --non-trivial
lemma new_lemma_171161 (h0 : group (canonically_linear_ordered_monoid (option (option (option ennreal))))) : is_cyclic (canonically_linear_ordered_monoid (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_171162 (h0 : add_group (normed_group (has_top (semiring congr_arg_kind)))) : is_add_cyclic (normed_group (has_top (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_171163 (h1 : set (mul_one_class (mul_one_class linarith.ineq) -> linarith.ineq)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_171164 (h0 : topological_space (with_one (has_top to_additive.value_type))) : totally_separated_space (with_one (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_171165 (h0 : topological_space (comm_group pos)) : discrete_topology (comm_group pos) := sorry --non-trivial
lemma new_lemma_171166 (h0 : add_group (normed_group congr_arg_kind)) : is_add_cyclic (normed_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_171167 (h3 : ring (has_add linarith.comp_source)) : is_domain (has_add linarith.comp_source) := sorry --non-trivial
lemma new_lemma_171168 (h1 h2 : multiset (has_compl string_imp)) : multiset.disjoint h1 h2 := sorry --non-trivial
lemma new_lemma_171169 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (mul_zero_class.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (mul_zero_class.{0} name))  := sorry --non-trivial
lemma new_lemma_171170 (h0 : functor.add_const (function.extfun Type group) Type) : @group.fg.{0} (normed_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type group.{0}) Type h0) (normed_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_171171 (h0 : topological_space (has_pos_part (has_add linarith.comp))) : locally_compact_space (has_pos_part (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_171172 (h0 : topological_space (has_pos_part pos)) : totally_separated_space (has_pos_part pos) := sorry --non-trivial
lemma new_lemma_171173 (h0 : functor.comp topological_space canonically_linear_ordered_monoid (option pos)) : @totally_disconnected_space.{0} (canonically_linear_ordered_monoid.{0} (option.{0} pos)) (@functor.comp.run.{0 0 0} topological_space.{0} canonically_linear_ordered_monoid.{0} (option.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_171174 (h0 : topological_space (has_add (ring Type))) : path_connected_space (has_add (ring Type)) := sorry --non-trivial
lemma new_lemma_171175 (h0 : not (topological_space (complete_linear_order unsigned) -> false)) : @totally_disconnected_space.{0} (complete_linear_order.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (complete_linear_order.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_171176 (h0 : ring (normed_field linarith.ineq)) : is_domain (normed_field linarith.ineq) := sorry --non-trivial
lemma new_lemma_171177 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (semigroup.{0} num) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (semigroup.{0} num)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (cancel_comm_monoid_with_zero.{0} (semigroup.{0} num))) (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 (functor.add_const.{0 0} (cancel_comm_monoid_with_zero.{0} (semigroup.{0} num)))) empty))  := sorry --non-trivial
lemma new_lemma_171178 (h0 : not (topological_space (has_union unsigned) -> false)) : @preirreducible_space.{0} (has_union.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (has_union.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_171179 (h1 : ring (semi_normed_comm_ring environment.projection_info) -> Prop) (h2 : Exists (fun (x : ring (semi_normed_comm_ring environment.projection_info)), h1 x)) : @strong_rank_condition.{0} (semi_normed_comm_ring.{0} environment.projection_info) (@classical.some.{1} (ring.{0} (semi_normed_comm_ring.{0} environment.projection_info)) h1 h2)  := sorry --non-trivial
lemma new_lemma_171180 (h0 : ring (canonically_ordered_comm_semiring (finset Type))) : rank_condition (canonically_ordered_comm_semiring (finset Type)) := sorry --non-trivial
lemma new_lemma_171181 (h0 : functor.add_const (list (has_nndist environment.implicit_infer_kind)) ennreal) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_171182 (h0 : functor.add_const (topological_space (complete_distrib_lattice unsigned)) linarith.comp) : @discrete_topology.{0} (complete_distrib_lattice.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_171183 (h0 : function.extfun Type (functor.add_const (topological_space (comm_monoid empty)))) : @path_connected_space.{0} (comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_monoid.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (comm_monoid.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_171184 (h0 : not (function.extfun Type add_monoid -> false)) : @add_monoid.fg.{0} (has_sub.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_monoid.{0}) h0) (has_sub.{0} empty))  := sorry --non-trivial
lemma new_lemma_171185 (h0 : has_mem.mem (random_gen fun_info) has_emptyc.emptyc) : @rank_condition.{0} (random_gen.{0} fun_info) (@finset.pi.empty.{1 0} Type ring.{0} (random_gen.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_171186 (h0 : uniform_space (has_inter (option empty))) : separated_space (has_inter (option empty)) := sorry --non-trivial
lemma new_lemma_171187 (h0 : ring (boolean_algebra.core (has_add ennreal))) : rank_condition (boolean_algebra.core (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_171188 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (denumerable.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (denumerable.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_171189 (h0 : filter (random_gen (random_gen char))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_171190 (h0 : functor.add_const (ring (finset name)) environment.implicit_infer_kind) : @rank_condition.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (finset.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_171191 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_dist.{0} (option.{0} ennreal)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_dist.{0} (option.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_171192 (h0 : prod (ring environment.implicit_infer_kind) (ring environment.implicit_infer_kind)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_171193 (h0 : has_lt (semi_normed_comm_ring enat)) : no_max_order (semi_normed_comm_ring enat) := sorry --non-trivial
lemma new_lemma_171194 (h0 : functor.add_const (finset (semigroup empty)) empty) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_171195 (h0 : group (with_one (semiring unsigned))) : is_cyclic (with_one (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_171196 (h0 : functor.add_const (uniform_space (has_to_string name)) linarith.comp) : @separated_space.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_to_string.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_171197 (h0 : not (group (normed_group fun_info) -> false)) : @is_cyclic.{0} (normed_group.{0} fun_info) (@classical.by_contradiction'.{1} (group.{0} (normed_group.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_171198 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (linear_ordered_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_171199 (h0 : topological_space (has_Inf name)) : normal_space (has_Inf name) := sorry --non-trivial
lemma new_lemma_171200 (h0 : complete_lattice (has_zero (has_add name))) : complete_lattice.is_Sup_finite_compact (has_zero (has_add name)) := sorry --non-trivial
lemma new_lemma_171201 (h0 : function.extfun (Type 1) topological_space) : @t1_space.{1} (plift.{1} congr_arg_kind) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (plift.{1} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_171202 (h0 : functor.add_const (group (ring Type)) (has_to_string Type)) : @is_cyclic.{1} (ring.{1} Type) (@functor.add_const.run.{1 1} (group.{1} (ring.{1} Type)) (has_to_string.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_171203 (h0 : semiring (linear_ordered_comm_group (option (option empty)))) : is_noetherian_ring (linear_ordered_comm_group (option (option empty))) := sorry --non-trivial
lemma new_lemma_171204 (h5 : topological_space fun_info) : path_connected_space fun_info := sorry --non-trivial
lemma new_lemma_171205 (h0 : group (pseudo_metric_space congr_arg_kind)) : normalizer_condition (pseudo_metric_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_171206 (h1 : topological_space to_additive.value_type) : totally_disconnected_space to_additive.value_type := sorry --non-trivial
lemma new_lemma_171207 (h0 : topological_space (semigroup (semigroup Type))) : path_connected_space (semigroup (semigroup Type)) := sorry --non-trivial
lemma new_lemma_171208 (h0 : functor.add_const (ring (finset pos)) linarith.comp) : @is_principal_ideal_ring.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (finset.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_171209 (h0 : topological_space (has_zero (has_neg_part unsigned))) : discrete_topology (has_zero (has_neg_part unsigned)) := sorry --non-trivial
lemma new_lemma_171210 (h0 : functor.comp topological_space has_neg_part name) : @totally_disconnected_space.{0} (has_neg_part.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg_part.{0} name h0)  := sorry --non-trivial
lemma new_lemma_171211 (h0 : function.extfun Type topological_space) : @t1_space.{0} (ordered_ring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_ring.{0} num))  := sorry --non-trivial
lemma new_lemma_171212 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (has_neg.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_neg.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_171213 (h0 : monoid (ordered_cancel_add_comm_monoid empty)) : monoid.fg (ordered_cancel_add_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_171214 (h0 : functor.add_const (semiring (monoid unsigned)) (option (option unsigned))) : @is_noetherian_ring.{0} (monoid.{0} unsigned) (@functor.add_const.run.{0 0} (semiring.{0} (monoid.{0} unsigned)) (option.{0} (option.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_171215 (h0 : uniform_space (id (random_gen empty))) : complete_space (id (random_gen empty)) := sorry --non-trivial
lemma new_lemma_171216 (h0 : functor.comp topological_space canonically_ordered_comm_semiring pos) : @discrete_topology.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} canonically_ordered_comm_semiring.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_171217 (h0 : topological_space (random_gen (random_gen num))) : path_connected_space (random_gen (random_gen num)) := sorry --non-trivial
lemma new_lemma_171218 (h0 : topological_space (omega_complete_partial_order (option (option empty)))) : t0_space (omega_complete_partial_order (option (option empty))) := sorry --non-trivial
lemma new_lemma_171219 (h0 : topological_space (has_nnnorm (has_nnnorm (group_with_zero (uniform_space linarith.ineq))))) : totally_disconnected_space (has_nnnorm (has_nnnorm (group_with_zero (uniform_space linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_171220 (h0 : not (function.extfun Type monoid -> false)) : @monoid.fg.{0} (has_zero.{0} fun_info) (@function.extfun_app.{2 1} Type monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type monoid.{0}) h0) (has_zero.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_171221 (h0 : functor.add_const (topological_space (sub_neg_monoid linarith.comp)) Type) : @path_connected_space.{0} (sub_neg_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (sub_neg_monoid.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_171222 (h0 : ring (add_monoid (has_nnnorm (normed_field linarith.comp_source)))) : strong_rank_condition (add_monoid (has_nnnorm (normed_field linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_171223 (h0 : uniform_space (linear_ordered_semiring linarith.comp)) : separated_space (linear_ordered_semiring linarith.comp) := sorry --non-trivial
lemma new_lemma_171224 (h1 : ring (linear_ordered_comm_group_with_zero to_additive.value_type)) : rank_condition (linear_ordered_comm_group_with_zero to_additive.value_type) := sorry --non-trivial
lemma new_lemma_171225 (h0 : functor.add_const (topological_space (ordered_comm_monoid linarith.comp)) linarith.comp) : @locally_compact_space.{0} (ordered_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_monoid.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_171226 (h0 : prod (ordered_cancel_add_comm_monoid pos) (ordered_cancel_add_comm_monoid pos)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_171227 (h0 : functor.add_const (group (comm_semigroup name)) real) : @normalizer_condition.{0} (comm_semigroup.{0} name) (@functor.add_const.run.{0 0} (group.{0} (comm_semigroup.{0} name)) real h0)  := sorry --non-trivial
lemma new_lemma_171228 (h0 : not (uniform_space (non_unital_non_assoc_semiring (has_ssubset linarith.ineq)) -> false)) : @complete_space.{0} (non_unital_non_assoc_semiring.{0} (has_ssubset.{0} linarith.ineq)) (@classical.by_contradiction'.{1} (uniform_space.{0} (non_unital_non_assoc_semiring.{0} (has_ssubset.{0} linarith.ineq))) h0)  := sorry --non-trivial
lemma new_lemma_171229 (h0 : function.extfun Type topological_space) : @t0_space.{0} (comm_ring.{0} char) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_ring.{0} char))  := sorry --non-trivial
lemma new_lemma_171230 (h0 : complete_lattice (comm_monoid (option (option empty)))) : is_atomistic (comm_monoid (option (option empty))) := sorry --non-trivial
lemma new_lemma_171231 (h3 : topological_space (random_gen (mul_one_class char))) : totally_disconnected_space (random_gen (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_171232 (h0 : functor.comp topological_space normed_comm_ring Type) : @discrete_topology.{1} (normed_comm_ring.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} normed_comm_ring.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_171233 (h0 : list (comm_monoid unsigned)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_171234 (h0 : group (ordered_comm_ring (has_add (has_bot Type)))) : group.fg (ordered_comm_ring (has_add (has_bot Type))) := sorry --non-trivial
lemma new_lemma_171235 (h0 : group (complete_semilattice_Sup (encodable (random_gen fun_info)))) : group.fg (complete_semilattice_Sup (encodable (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_171236 (h0 : ring (ring (has_Inf linarith.comp))) : is_domain (ring (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_171237 (h2 : uniform_space (has_lt linarith.comp_source)) : complete_space (has_lt linarith.comp_source) := sorry --non-trivial
lemma new_lemma_171238 (h0 : functor.add_const (topological_space (boolean_algebra.core name)) name) : @normal_space.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_171239 (h0 : functor.add_const (group (has_edist empty)) unsigned) : @normalizer_condition.{0} (has_edist.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (has_edist.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_171240 (h0 : filter (has_add (comm_group (has_neg_part pos)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_171241 (h0 : functor.add_const (functor.add_const (group linarith.comp) Type) (ring (finset (has_neg Type)))) : @group.fg.{0} linarith.comp (@functor.add_const.run.{0 1} (group.{0} linarith.comp) Type (@functor.add_const.run.{0 1} (functor.add_const.{0 1} (group.{0} linarith.comp) Type) (ring.{1} (finset.{1} (has_neg.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_171242 (h0 : topological_space (has_inv (random_gen (random_gen string_imp)))) : totally_disconnected_space (has_inv (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_171243 (h0 : add_group (normed_field linarith.ineq)) : is_add_cyclic (normed_field linarith.ineq) := sorry --non-trivial
lemma new_lemma_171244 (h0 : ring (plift (semiring num))) : is_domain (plift (semiring num)) := sorry --non-trivial
lemma new_lemma_171245 (h0 : not (topological_space (add_group empty) -> false)) : @totally_disconnected_space.{0} (add_group.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (add_group.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_171246 (h0 : functor.add_const (function.extfun Type cancel_comm_monoid_with_zero) Type) : @unique_factorization_monoid.{0} (has_zero.{0} linarith.comp) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type cancel_comm_monoid_with_zero.{0}) Type h0) (has_zero.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_171247 (h0 : ring (has_nnnorm ereal)) : rank_condition (has_nnnorm ereal) := sorry --non-trivial
lemma new_lemma_171248 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} auto.case_option (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) auto.case_option)  := sorry --non-trivial
lemma new_lemma_171249 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @sequential_space.{0} (has_zero.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_171250 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (has_top.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (has_top.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_171251 (h0 : not (complete_lattice (has_sub empty) -> false)) : @is_compactly_generated.{0} (has_sub.{0} empty) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_sub.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_171252 (h0 : functor.add_const (topological_space (has_to_string name)) pos) : @regular_space.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_171253 (h0 : functor.add_const (topological_space (has_to_string name)) linarith.comp) : @t1_space.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_171254 (h0 : group (has_Inf (has_Inf (has_Inf real)))) : is_simple_group (has_Inf (has_Inf (has_Inf real))) := sorry --non-trivial
lemma new_lemma_171255 (h0 : functor.add_const (list (ring linarith.comp)) pos) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_171256 (h0 : functor.add_const (uniform_space (boolean_algebra pos)) linarith.comp) : @complete_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (boolean_algebra.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_171257 (h0 : functor.add_const (add_group (comm_group name)) (has_to_string linarith.comp)) : @is_add_cyclic.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (add_group.{0} (comm_group.{0} name)) (has_to_string.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_171258 (h0 : uniform_space (has_div std_gen)) : complete_space (has_div std_gen) := sorry --non-trivial
lemma new_lemma_171259 (h0 : functor.add_const (monoid (ring linarith.comp)) (normed_comm_ring Type)) : @monoid.fg.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (monoid.{0} (ring.{0} linarith.comp)) (normed_comm_ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_171260 (h0 : not (ring (add_group empty) -> false)) : @rank_condition.{0} (add_group.{0} empty) (@classical.by_contradiction'.{1} (ring.{0} (add_group.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_171261 (h0 : topological_space (has_ssubset (with_one fun_info))) : t0_space (has_ssubset (with_one fun_info)) := sorry --non-trivial
lemma new_lemma_171262 (h0 : functor.comp group has_neg pos) : @is_cyclic.{0} (has_neg.{0} pos) (@functor.comp.run.{0 0 0} group.{0} has_neg.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_171263 (h0 : not (ring (option empty) -> false)) : @rank_condition.{0} (option.{0} empty) (@classical.by_contradiction'.{1} (ring.{0} (option.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_171264 (h0 : add_group (has_to_string (ring pos))) : is_add_cyclic (has_to_string (ring pos)) := sorry --non-trivial
lemma new_lemma_171265 (h0 : topological_space (ordered_cancel_add_comm_monoid (option ennreal))) : path_connected_space (ordered_cancel_add_comm_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_171266 (h0 : ring (boolean_algebra (has_add pos))) : is_principal_ideal_ring (boolean_algebra (has_add pos)) := sorry --non-trivial
lemma new_lemma_171267 (h0 : function.extfun (Type 1) (functor.add_const (function.extfun Type group))) : @normalizer_condition.{0} (has_zero.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type group.{0}) Type (@function.extfun_app.{3 2} (Type 1) (functor.add_const.{1 1} (function.extfun.{2 1} Type group.{0})) h0 Type)) (has_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_171268 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : irreducible_space empty := sorry --non-trivial
lemma new_lemma_171269 (h0 : functor.add_const (complete_lattice (add_cancel_monoid linarith.comp)) linarith.comp) : @is_compactly_generated.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_cancel_monoid.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_171270 (h1 : uniform_space (with_bot empty)) : separated_space (with_bot empty) := sorry --non-trivial
lemma new_lemma_171271 (h0 : topological_space (has_nndist linarith.comp)) : totally_separated_space (has_nndist linarith.comp) := sorry --non-trivial
lemma new_lemma_171272 (h0 : not (ring (has_append reducibility_hints) -> false)) : @is_domain.{0} (has_append.{0} reducibility_hints) (@classical.by_contradiction'.{1} (ring.{0} (has_append.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_171273 (h0 : fin has_zero.zero) : @path_connected_space.{0} (canonically_linear_ordered_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (canonically_linear_ordered_monoid.{0} linarith.comp)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)))  := sorry --non-trivial
lemma new_lemma_171274 (h4 : topological_space char) (h5 : set char) : is_path_connected h5 := sorry --non-trivial
lemma new_lemma_171275 (h0 : functor.add_const (ordered_comm_monoid (boolean_algebra environment.implicit_infer_kind)) pos) : @has_exists_mul_of_le.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_171276 (h0 : not (ring (fintype string_imp) -> false)) : @rank_condition.{0} (fintype.{0} string_imp) (@classical.by_contradiction'.{1} (ring.{0} (fintype.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_171277 (h0 : topological_space (semi_normed_comm_ring (random_gen string_imp))) : t0_space (semi_normed_comm_ring (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_171278 (h0 : topological_space (has_neg (boolean_algebra environment.implicit_infer_kind))) : discrete_topology (has_neg (boolean_algebra environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_171279 (h0 : functor.add_const (function.extfun Type complete_lattice) unsigned) : @complete_lattice.is_Sup_finite_compact.{0} (has_zero.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) unsigned h0) (has_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_171280 (h1 : complete_lattice (normed_field to_additive.value_type)) : is_compactly_generated (normed_field to_additive.value_type) := sorry --non-trivial
lemma new_lemma_171281 (h0 : add_group (id (has_union empty))) : is_add_cyclic (id (has_union empty)) := sorry --non-trivial
lemma new_lemma_171282 (h0 : group (has_Inf linarith.comp)) : group.fg (has_Inf linarith.comp) := sorry --non-trivial
lemma new_lemma_171283 (h0 : functor.add_const (group (boolean_algebra.core empty)) (option (option (option empty)))) : @is_cyclic.{0} (boolean_algebra.core.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.core.{0} empty)) (option.{0} (option.{0} (option.{0} empty))) h0)  := sorry --non-trivial
lemma new_lemma_171284 (h0 : ring (with_bot (semiring (semiring congr_arg_kind)))) : is_domain (with_bot (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_171285 (h0 : function.extfun Type group) : @normalizer_condition.{0} empty (@function.extfun_app.{2 1} Type group.{0} h0 empty)  := sorry --non-trivial
lemma new_lemma_171286 (h0 : semiring (boolean_algebra (sub_neg_monoid (sub_neg_monoid Type)))) : is_noetherian_ring (boolean_algebra (sub_neg_monoid (sub_neg_monoid Type))) := sorry --non-trivial
lemma new_lemma_171287 (h0 : topological_space (ordered_cancel_add_comm_monoid (option ennreal))) : preirreducible_space (ordered_cancel_add_comm_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_171288 (h0 : topological_space (has_neg_part linarith.comp)) : path_connected_space (has_neg_part linarith.comp) := sorry --non-trivial
lemma new_lemma_171289 (h0 : list (has_to_string (has_pos_part pos))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_171290 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (add_semigroup.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_171291 (h0 : topological_space (with_bot (has_top (has_top fun_info)))) : path_connected_space (with_bot (has_top (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_171292 (h0 : add_group (has_nndist (comm_monoid (comm_monoid empty)))) : is_add_cyclic (has_nndist (comm_monoid (comm_monoid empty))) := sorry --non-trivial
lemma new_lemma_171293 (h1 : complete_lattice (with_one num)) : is_compactly_generated (with_one num) := sorry --non-trivial
lemma new_lemma_171294 (h0 : function.extfun Type (functor.add_const (topological_space auto.case_option))) : @irreducible_space.{0} auto.case_option (@functor.add_const.run.{0 0} (topological_space.{0} auto.case_option) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} auto.case_option)) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_171295 (h0 : group (semiring congr_arg_kind)) : group.fg (semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_171296 (h0 : functor.add_const (list auto.case_option) num -> Prop) (h1 : Exists (fun (x : functor.add_const (list auto.case_option) num), h0 x)) : palindrome (functor.add_const.run (classical.some h1)) := sorry --non-trivial
lemma new_lemma_171297 (h0 : add_group (ordered_cancel_add_comm_monoid ennreal)) : is_add_cyclic (ordered_cancel_add_comm_monoid ennreal) := sorry --non-trivial
lemma new_lemma_171298 (h0 : group (has_emptyc (random_gen (random_gen to_additive.value_type)))) : group.fg (has_emptyc (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_171299 (h0 : group (id (with_bot to_additive.value_type))) : normalizer_condition (id (with_bot to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_171300 (h0 : topological_space (sub_neg_monoid (has_add (has_add Type)))) : normal_space (sub_neg_monoid (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_171301 (h1 : uniform_space (has_union linarith.comp)) : complete_space (has_union linarith.comp) := sorry --non-trivial
lemma new_lemma_171302 (h0 : ordered_comm_monoid (has_neg_part unsigned)) : has_exists_mul_of_le (has_neg_part unsigned) := sorry --non-trivial
lemma new_lemma_171303 (h0 : functor.add_const (group (has_to_string linarith.comp)) pos) : @is_cyclic.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (has_to_string.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_171304 (h0 : ring (semiring (has_top (has_top fun_info)))) : is_domain (semiring (has_top (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_171305 (h0 : functor.add_const (ring (cancel_monoid Type)) (comm_group (comm_group (comm_group Type)))) : @is_domain.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 1} (ring.{1} (cancel_monoid.{1} Type)) (comm_group.{1} (comm_group.{1} (comm_group.{1} Type))) h0)  := sorry --non-trivial
lemma new_lemma_171306 (h0 : uniform_space (semigroup (finset Type))) : separated_space (semigroup (finset Type)) := sorry --non-trivial
lemma new_lemma_171307 (h0 : topological_space (with_bot to_additive.value_type)) : t0_space (with_bot to_additive.value_type) := sorry --non-trivial
lemma new_lemma_171308 (h0 : ordered_add_comm_monoid (canonically_ordered_comm_semiring unsigned)) : archimedean (canonically_ordered_comm_semiring unsigned) := sorry --non-trivial
lemma new_lemma_171309 (h0 : list (has_pos_part (has_Inf linarith.comp))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_171310 (h0 : empty -> complete_semilattice_Sup (add_right_cancel_monoid (has_sub unsigned)) -> Prop) : relator.right_total h0 := sorry --non-trivial
lemma new_lemma_171311 (h0 : set (has_compl (has_compl ereal))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_171312 (h0 : topological_space (has_dist num)) : preirreducible_space (has_dist num) := sorry --non-trivial
lemma new_lemma_171313 (h0 : topological_space (mul_zero_class name)) : normal_space (mul_zero_class name) := sorry --non-trivial
lemma new_lemma_171314 (h0 : comm_semiring (free_add_monoid congr_arg_kind)) (h1 : uniform_space (linear_recurrence (free_add_monoid congr_arg_kind))) : separated_space (linear_recurrence (free_add_monoid congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_171315 (h0 : functor.add_const Prop (has_zero ennreal)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_171316 (h0 : complete_lattice (finset (mul_zero_class pos))) : is_atomistic (finset (mul_zero_class pos)) := sorry --non-trivial
lemma new_lemma_171317 (h0 : functor.add_const (add_monoid (has_neg environment.implicit_infer_kind)) name) : @add_monoid.fg.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_neg.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_171318 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (partial_order.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (partial_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_171319 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (sub_neg_monoid.{0} real) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (sub_neg_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_171320 (h1 : ring (semi_normed_ring (random_gen char))) : is_domain (semi_normed_ring (random_gen char)) := sorry --non-trivial
lemma new_lemma_171321 (h0 : topological_space (ordered_comm_ring (has_pos_part pos))) : discrete_topology (ordered_comm_ring (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_171322 (h0 : filter (omega_complete_partial_order unsigned)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_171323 (h0 : complete_lattice (random_gen (has_ssubset (has_ssubset linarith.comp_source)))) : is_compactly_generated (random_gen (has_ssubset (has_ssubset linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_171324 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (linear_ordered_field.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (linear_ordered_field.{0} empty))  := sorry --non-trivial
lemma new_lemma_171325 (h0 : functor.add_const (topological_space (add_cancel_monoid Type)) name) : @t1_space.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_cancel_monoid.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_171326 (h0 : topological_space (has_to_string (has_to_string (has_add linarith.comp)))) : regular_space (has_to_string (has_to_string (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_171327 (h0 : topological_space (with_one (has_top fun_info))) : totally_separated_space (with_one (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_171328 (h2 : Prop) : set.separates_points (id (fun (h0 : ereal -> std_gen), h2)) := sorry --non-trivial
lemma new_lemma_171329 (h0 : functor.add_const (topological_space (filter empty)) empty) : @locally_compact_space.{0} (filter.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (filter.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_171330 (h0 : topological_space (with_bot (comm_ring (random_gen (random_gen linarith.ineq))))) : irreducible_space (with_bot (comm_ring (random_gen (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_171331 (h0 : add_monoid (boolean_algebra (has_add unsigned))) : add_monoid.fg (boolean_algebra (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_171332 (h0 : filter (denumerable linarith.comp_source)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_171333 (h0 : function.extfun (finset Type) (has_mem.mem fun_info)) : @is_atomistic.{0} fun_info (@finset.pi.empty.{1 0} Type complete_lattice.{0} fun_info (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) fun_info) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_171334 (h0 : monoid (canonically_ordered_comm_semiring Type)) : monoid.fg (canonically_ordered_comm_semiring Type) := sorry --non-trivial
lemma new_lemma_171335 (h0 : topological_space (finset linarith.comp)) : regular_space (finset linarith.comp) := sorry --non-trivial
lemma new_lemma_171336 (h0 : ring (random_gen (comm_ring (random_gen to_additive.value_type)))) : rank_condition (random_gen (comm_ring (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_171337 (h0 : ring (has_nndist (has_neg (has_add linarith.comp)))) : is_principal_ideal_ring (has_nndist (has_neg (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_171338 (h0 : functor.add_const (semiring (add_cancel_monoid unsigned)) unsigned) : @is_noetherian_ring.{0} (add_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (semiring.{0} (add_cancel_monoid.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_171339 (h0 : function.extfun (multiset Type) (has_mem.mem (normed_group fun_info))) : @complete_space.{0} (normed_group.{0} fun_info) (@multiset.pi.empty.{1 0} Type uniform_space.{0} (normed_group.{0} fun_info) (@function.extfun_app.{2 0} (multiset.{1} Type) (@has_mem.mem.{1 1} Type (multiset.{1} Type) (@multiset.has_mem.{1} Type) (normed_group.{0} fun_info)) h0 (@has_zero.zero.{1} (multiset.{1} Type) (@multiset.has_zero.{1} Type))))  := sorry --non-trivial
lemma new_lemma_171340 (h0 : functor.add_const (cancel_comm_monoid_with_zero (canonically_linear_ordered_monoid num)) num) : @unique_factorization_monoid.{0} (canonically_linear_ordered_monoid.{0} num) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (canonically_linear_ordered_monoid.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_171341 (h0 : function.extfun Type (functor.add_const (topological_space (measurable_space.dynkin_system unsigned)))) : @irreducible_space.{0} (measurable_space.dynkin_system.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (measurable_space.dynkin_system.{0} unsigned)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (measurable_space.dynkin_system.{0} unsigned))) h0 empty))  := sorry --non-trivial
lemma new_lemma_171342 (h0 : functor.add_const (topological_space (comm_group pos)) linarith.comp) : @path_connected_space.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_171343 (h0 : not (monoid (add_right_cancel_monoid num) -> false)) : @monoid.fg.{0} (add_right_cancel_monoid.{0} num) (@classical.by_contradiction'.{1} (monoid.{0} (add_right_cancel_monoid.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_171344 (h0 : topological_space (measurable_space (has_top (has_top (has_top num))))) : t0_space (measurable_space (has_top (has_top (has_top num)))) := sorry --non-trivial
lemma new_lemma_171345 (h0 : topological_space (ring (ring (ring Type)))) : preirreducible_space (ring (ring (ring Type))) := sorry --non-trivial
lemma new_lemma_171346 (h0 : functor.add_const (complete_lattice (has_zero name)) (ring Type)) : @is_compactly_generated.{0} (has_zero.{0} name) (@functor.add_const.run.{0 1} (complete_lattice.{0} (has_zero.{0} name)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_171347 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (@id.{2} Type fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (@id.{2} Type fun_info))  := sorry --non-trivial
lemma new_lemma_171348 (h0 : topological_space (filter (semiring (semiring empty)))) : locally_compact_space (filter (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_171349 (h0 : topological_space (has_pos_part linarith.comp)) : preirreducible_space (has_pos_part linarith.comp) := sorry --non-trivial
lemma new_lemma_171350 (h0 : topological_space (normed_group (has_inv fun_info))) : path_connected_space (normed_group (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_171351 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_norm.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_norm.{0} empty))  := sorry --non-trivial
lemma new_lemma_171352 (h0 : topological_space (mul_one_class (metric_space to_additive.value_type))) : path_connected_space (mul_one_class (metric_space to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_171353 (h0 : list (has_nndist (has_to_string (finset linarith.comp)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_171354 (h0 : function.extfun Type group) : @is_cyclic.{0} (complete_semilattice_Sup.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} h0 (complete_semilattice_Sup.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_171355 (h0 : topological_space (has_add congr_arg_kind)) : topological_space.separable_space (has_add congr_arg_kind) := sorry --non-trivial
lemma new_lemma_171356 (h0 : functor.add_const (finset (has_nndist unsigned)) name) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_171357 (h0 : list (plift (option unsigned))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_171358 (h0 : topological_space (linear_ordered_semiring congr_arg_kind)) : totally_separated_space (linear_ordered_semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_171359 (h0 : fin has_zero.zero) : @is_simple_group.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind) (@matrix.vec_empty.{0} (group.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind)) h0)  := sorry --non-trivial
lemma new_lemma_171360 (h0 : topological_space (complete_distrib_lattice (has_add pos))) : totally_disconnected_space (complete_distrib_lattice (has_add pos)) := sorry --non-trivial
lemma new_lemma_171361 (h0 : topological_space (has_inf (option (option (option ennreal))))) : preirreducible_space (has_inf (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_171362 (h0 : functor.add_const (complete_lattice (has_nndist linarith.comp)) Type) : @complete_lattice.is_Sup_finite_compact.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 1} (complete_lattice.{0} (has_nndist.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_171363 (h0 : topological_space (has_zero unsigned)) : preconnected_space (has_zero unsigned) := sorry --non-trivial
lemma new_lemma_171364 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} (generalized_boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) (generalized_boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_171365 (h0 : functor.add_const (topological_space (complete_distrib_lattice pos)) name) : @normal_space.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_171366 (h0 : not (topological_space (has_ssubset to_additive.value_type) -> false)) : @locally_compact_space.{0} (has_ssubset.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (has_ssubset.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_171367 (h0 : complete_lattice (has_Inf name)) : complete_lattice.is_Sup_finite_compact (has_Inf name) := sorry --non-trivial
lemma new_lemma_171368 (h0 : functor.add_const (function.extfun Type cancel_comm_monoid_with_zero) name) : @unique_factorization_monoid.{0} (has_Inf.{0} name) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type cancel_comm_monoid_with_zero.{0}) name h0) (has_Inf.{0} name))  := sorry --non-trivial
lemma new_lemma_171369 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (complete_distrib_lattice.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_171370 (h1 : group (random_gen (comm_ring linarith.comp_source))) : is_cyclic (random_gen (comm_ring linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_171371 (h0 : functor.add_const (function.extfun Type ordered_comm_monoid) (finset Type)) : @has_exists_mul_of_le.{0} (has_nndist.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) (finset.{1} Type) h0) (has_nndist.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_171372 (h0 : group (semigroup (option pos))) : is_simple_group (semigroup (option pos)) := sorry --non-trivial
lemma new_lemma_171373 (h0 : group (ordered_comm_ring (has_Inf pos))) : is_simple_group (ordered_comm_ring (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_171374 (h0 : functor.comp uniform_space finset name) : @complete_space.{0} (finset.{0} name) (@functor.comp.run.{0 0 0} uniform_space.{0} finset.{0} name h0)  := sorry --non-trivial
lemma new_lemma_171375 (h0 : fun_info -> fun_info -> fun_info) : is_right_cancel fun_info h0 := sorry --non-trivial
lemma new_lemma_171376 (h0 : cancel_comm_monoid_with_zero (complete_semilattice_Sup (has_sub unsigned))) : unique_factorization_monoid (complete_semilattice_Sup (has_sub unsigned)) := sorry --non-trivial
lemma new_lemma_171377 (h0 : group (pseudo_metric_space (option unsigned))) : group.fg (pseudo_metric_space (option unsigned)) := sorry --non-trivial
lemma new_lemma_171378 (h0 : function.extfun Type group) : @is_simple_group.{0} (finset.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (finset.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_171379 (h0 : ring (has_add congr_arg_kind)) : is_domain (has_add congr_arg_kind) := sorry --non-trivial
lemma new_lemma_171380 (h0 : ordered_comm_monoid (pseudo_metric_space (option (option name)))) : has_exists_mul_of_le (pseudo_metric_space (option (option name))) := sorry --non-trivial
lemma new_lemma_171381 (h0 : complete_lattice (has_add (has_append string_imp))) : complete_lattice.is_Sup_finite_compact (has_add (has_append string_imp)) := sorry --non-trivial
lemma new_lemma_171382 (h0 : function.extfun Type (functor.add_const (group (has_neg linarith.comp)))) : @group.fg.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (has_neg.{0} linarith.comp)) linarith.comp (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (group.{0} (has_neg.{0} linarith.comp))) h0 linarith.comp))  := sorry --non-trivial
lemma new_lemma_171383 (h0 : ring (normed_field fun_info)) : rank_condition (normed_field fun_info) := sorry --non-trivial
lemma new_lemma_171384 (h0 : functor.add_const (group (add_cancel_monoid real)) unsigned) : @normalizer_condition.{0} (add_cancel_monoid.{0} real) (@functor.add_const.run.{0 0} (group.{0} (add_cancel_monoid.{0} real)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_171385 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @t0_space.{0} (normed_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (normed_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_171386 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (has_dist.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_dist.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_171387 (h0 : functor.add_const (topological_space (has_nndist name)) environment.implicit_infer_kind) : @path_connected_space.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_171388 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (has_nndist.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_nndist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_171389 (h0 : functor.add_const (group znum) (option unsigned)) : @normalizer_condition.{0} znum (@functor.add_const.run.{0 0} (group.{0} znum) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_171390 (h0 : group (has_emptyc congr_arg_kind)) : is_cyclic (has_emptyc congr_arg_kind) := sorry --non-trivial
lemma new_lemma_171391 (h0 : ring (has_ssubset (mul_one_class char))) : strong_rank_condition (has_ssubset (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_171392 (h0 : not (complete_lattice (has_norm fun_info) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_norm.{0} fun_info) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_norm.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_171393 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (free_add_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type semiring.{0} h0 (free_add_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_171394 (h1 : add_group (has_div reducibility_hints)) : is_add_cyclic (has_div reducibility_hints) := sorry --non-trivial
lemma new_lemma_171395 (h0 : functor.add_const (ordered_add_comm_monoid (has_neg linarith.comp)) (ring (has_pos_part pos))) : @archimedean.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_neg.{0} linarith.comp)) (ring.{0} (has_pos_part.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_171396 (h0 : ring (has_neg (finset linarith.comp))) : rank_condition (has_neg (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_171397 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (boolean_algebra.core.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_171398 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (has_nndist linarith.comp)) := sorry --non-trivial
lemma new_lemma_171399 (h0 : topological_space (has_nndist (left_cancel_monoid unsigned))) : totally_disconnected_space (has_nndist (left_cancel_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_171400 (h0 : topological_space (add_comm_semigroup linarith.ineq)) (h1 : set (set (add_comm_semigroup linarith.ineq))) : topological_space.is_topological_basis h1 := sorry --non-trivial
lemma new_lemma_171401 (h1 : not (topological_space (with_zero linarith.ineq) -> false)) : @totally_disconnected_space.{0} (with_zero.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (with_zero.{0} linarith.ineq)) h1)  := sorry --non-trivial
lemma new_lemma_171402 (h0 : not (finset (linear_ordered_comm_ring num) -> false)) : finset.nonempty (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_171403 (h0 : not (ring (with_zero to_additive.value_type) -> false)) : @rank_condition.{0} (with_zero.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (with_zero.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_171404 (h0 : functor.add_const (topological_space (cancel_monoid environment.implicit_infer_kind)) Type) : @t0_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_171405 (h0 : list (comm_group (complete_distrib_lattice (complete_distrib_lattice pos)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_171406 (h0 : topological_space (normed_group (has_union (random_gen (has_union empty))))) : preirreducible_space (normed_group (has_union (random_gen (has_union empty)))) := sorry --non-trivial
lemma new_lemma_171407 (h0 : function.extfun Type (functor.comp topological_space has_add)) : @totally_separated_space.{0} (has_add.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} has_add.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} has_add.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_171408 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_171409 (h1 : topological_space (non_unital_non_assoc_semiring char)) : totally_disconnected_space (non_unital_non_assoc_semiring char) := sorry --non-trivial
lemma new_lemma_171410 (h0 : add_group (preorder congr_arg_kind)) : is_add_cyclic (preorder congr_arg_kind) := sorry --non-trivial
lemma new_lemma_171411 (h0 : uniform_space (has_norm string_imp)) (h1 : group (has_norm string_imp)) : uniform_group (has_norm string_imp) := sorry --non-trivial
lemma new_lemma_171412 (h0 : ring (with_one (semiring num))) : rank_condition (with_one (semiring num)) := sorry --non-trivial
lemma new_lemma_171413 (h1 : complete_lattice (has_nnnorm std_gen)) : complete_lattice.is_Sup_finite_compact (has_nnnorm std_gen) := sorry --non-trivial
lemma new_lemma_171414 (h0 : complete_lattice (linear_ordered_comm_ring congr_arg_kind)) : is_compactly_generated (linear_ordered_comm_ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_171415 (h0 : topological_space (as_linear_order num)) : irreducible_space (as_linear_order num) := sorry --non-trivial
lemma new_lemma_171416 (h0 : group (has_zero (finset (finset (finset (finset name)))))) : group.fg (has_zero (finset (finset (finset (finset name))))) := sorry --non-trivial
lemma new_lemma_171417 (h0 : topological_space (boolean_algebra.core (has_to_string (has_add name)))) : locally_compact_space (boolean_algebra.core (has_to_string (has_add name))) := sorry --non-trivial
lemma new_lemma_171418 (h0 : semiring (mul_zero_class (option environment.implicit_infer_kind))) : is_noetherian_ring (mul_zero_class (option environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_171419 (h0 : ring (has_le linarith.ineq)) : strong_rank_condition (has_le linarith.ineq) := sorry --non-trivial
lemma new_lemma_171420 (h0 : semiring (ordered_comm_monoid (ring (ring (ring (has_add (ring Type))))))) : is_noetherian_ring (ordered_comm_monoid (ring (ring (ring (has_add (ring Type)))))) := sorry --non-trivial
lemma new_lemma_171421 (h0 : has_mem.mem (complete_semilattice_Sup (has_norm linarith.comp_source)) has_emptyc.emptyc) : @t0_space.{0} (complete_semilattice_Sup.{0} (has_norm.{0} linarith.comp_source)) (@finset.pi.empty.{1 0} Type topological_space.{0} (complete_semilattice_Sup.{0} (has_norm.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_171422 (h0 : not (complete_lattice (denumerable char) -> false)) : @is_compactly_generated.{0} (denumerable.{0} char) (@classical.by_contradiction'.{1} (complete_lattice.{0} (denumerable.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_171423 (h0 : functor.add_const (uniform_space (ordered_comm_ring linarith.comp)) Type) : @separated_space.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (uniform_space.{0} (ordered_comm_ring.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_171424 (h0 : ring (has_bot (has_Inf (has_Inf (has_add linarith.comp))))) : is_principal_ideal_ring (has_bot (has_Inf (has_Inf (has_add linarith.comp)))) := sorry --non-trivial
lemma new_lemma_171425 (h0 : ring (has_pos_part (has_add linarith.comp))) : rank_condition (has_pos_part (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_171426 (h0 : functor.add_const (uniform_space (normed_linear_ordered_group empty)) unsigned) : @complete_space.{0} (normed_linear_ordered_group.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (normed_linear_ordered_group.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_171427 (h0 : has_lt (has_nnnorm (mul_one_class (mul_one_class (mul_one_class string.iterator_imp))))) : no_max_order (has_nnnorm (mul_one_class (mul_one_class (mul_one_class string.iterator_imp)))) := sorry --non-trivial
lemma new_lemma_171428 (h0 : topological_space (simple_graph (finset linarith.comp))) : preirreducible_space (simple_graph (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_171429 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (canonically_linear_ordered_monoid congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_171430 (h0 : topological_space (cancel_monoid (has_add name))) : t1_space (cancel_monoid (has_add name)) := sorry --non-trivial
lemma new_lemma_171431 (h0 : not (ring (normed_group num) -> false)) : @strong_rank_condition.{0} (normed_group.{0} num) (@classical.by_contradiction'.{1} (ring.{0} (normed_group.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_171432 (h0 : functor.add_const (uniform_space (semigroup name)) Type) : @complete_space.{0} (semigroup.{0} name) (@functor.add_const.run.{0 1} (uniform_space.{0} (semigroup.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_171433 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (linear_order.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} h0 (linear_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_171434 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_simple_group.{0} (option.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (option.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_171435 (h0 : uniform_space (add_comm_monoid (has_neg_part (has_to_string name)))) : complete_space (add_comm_monoid (has_neg_part (has_to_string name))) := sorry --non-trivial
lemma new_lemma_171436 (h0 : ordered_add_comm_monoid (has_well_founded unsigned)) : archimedean (has_well_founded unsigned) := sorry --non-trivial
lemma new_lemma_171437 (h0 : functor.add_const (topological_space (has_add name)) name) : @totally_separated_space.{0} (has_add.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_171438 (h0 : not (function.extfun Type topological_space -> false)) : @discrete_topology.{0} (has_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_171439 (h0 : topological_space (complete_distrib_lattice (has_Inf linarith.comp))) : irreducible_space (complete_distrib_lattice (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_171440 (h1 : topological_space (simple_graph fun_info)) : path_connected_space (simple_graph fun_info) := sorry --non-trivial
lemma new_lemma_171441 (h0 : ring (ordered_cancel_add_comm_monoid congr_arg_kind)) : rank_condition (ordered_cancel_add_comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_171442 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_171443 (h0 : topological_space (mul_zero_class (semiring (semiring unsigned)))) : totally_separated_space (mul_zero_class (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_171444 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : is_compactly_generated (measurable_space string_imp) := sorry --non-trivial
lemma new_lemma_171445 (h0 : semiring (add_cancel_monoid (ring pos))) : is_noetherian_ring (add_cancel_monoid (ring pos)) := sorry --non-trivial
lemma new_lemma_171446 (h0 : group (pseudo_metric_space (option (option (option (option (option (option unsigned)))))))) : is_cyclic (pseudo_metric_space (option (option (option (option (option (option unsigned))))))) := sorry --non-trivial
lemma new_lemma_171447 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_one.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (has_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_171448 (h0 : functor.add_const (add_group (add_comm_monoid unsigned)) Type) : @is_add_cyclic.{0} (add_comm_monoid.{0} unsigned) (@functor.add_const.run.{0 1} (add_group.{0} (add_comm_monoid.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_171449 (h0 : ring (comm_group (has_add (has_add pos)))) : rank_condition (comm_group (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_171450 (h0 : topological_space (ordered_cancel_add_comm_monoid pos)) : totally_separated_space (ordered_cancel_add_comm_monoid pos) := sorry --non-trivial
lemma new_lemma_171451 (h0 : topological_space (semigroup (cancel_monoid environment.implicit_infer_kind))) : normal_space (semigroup (cancel_monoid environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_171452 (h0 : topological_space (has_neg (has_add Type))) : path_connected_space (has_neg (has_add Type)) := sorry --non-trivial
lemma new_lemma_171453 (h0 : function.extfun nat fin) : @rank_condition.{0} (has_bot.{0} linarith.comp) (@matrix.vec_empty.{0} (ring.{0} (has_bot.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_171454 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (monoid_with_zero.{0} pos) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (monoid_with_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_171455 (h0 : not (function.extfun Type group -> false)) : @group.fg.{0} (random_gen.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (random_gen.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_171456 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (semiring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semiring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_171457 (h0 : functor.add_const (add_monoid (left_cancel_monoid empty)) num) : @add_monoid.fg.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (add_monoid.{0} (left_cancel_monoid.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_171458 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_171459 (h0 : complete_lattice (canonically_linear_ordered_monoid (has_add pos))) : is_compactly_generated (canonically_linear_ordered_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_171460 (h0 : topological_space (normed_group (semiring congr_arg_kind))) : normal_space (normed_group (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_171461 (h0 : ring (add_cancel_comm_monoid (random_gen char))) : rank_condition (add_cancel_comm_monoid (random_gen char)) := sorry --non-trivial
lemma new_lemma_171462 (h0 : functor.add_const (semiring (normed_linear_ordered_group congr_arg_kind)) congr_arg_kind) : @is_noetherian_ring.{0} (normed_linear_ordered_group.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (semiring.{0} (normed_linear_ordered_group.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_171463 (h0 : group (random_gen (random_gen linarith.comp_source))) : group.fg (random_gen (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_171464 (h1 : ring (dlist (has_nnnorm (has_nnnorm char)))) : strong_rank_condition (dlist (has_nnnorm (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_171465 (h0 : ring (complete_distrib_lattice unsigned)) : is_domain (complete_distrib_lattice unsigned) := sorry --non-trivial
lemma new_lemma_171466 (h0 : functor.add_const (topological_space (generalized_boolean_algebra linarith.comp)) (ring pos)) : @irreducible_space.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} linarith.comp)) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_171467 (h0 : functor.add_const (ring (finset Type)) environment.implicit_infer_kind) : @is_principal_ideal_ring.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (finset.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_171468 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (mul_zero_class.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (mul_zero_class.{0} empty))  := sorry --non-trivial
lemma new_lemma_171469 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (has_norm.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (has_norm.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_171470 (h0 : topological_space (filter (option empty))) : preirreducible_space (filter (option empty)) := sorry --non-trivial
lemma new_lemma_171471 (h0 : functor.add_const (uniform_space (finset pos)) name) : @separated_space.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (finset.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_171472 (h0 : uniform_space (has_neg (option unsigned))) : complete_space (has_neg (option unsigned)) := sorry --non-trivial
lemma new_lemma_171473 (h0 : topological_space (canonically_ordered_monoid (has_neg name))) : path_connected_space (canonically_ordered_monoid (has_neg name)) := sorry --non-trivial
lemma new_lemma_171474 (h0 : ring (has_nndist (finset Type))) : rank_condition (has_nndist (finset Type)) := sorry --non-trivial
lemma new_lemma_171475 (h0 : functor.add_const (group (finset environment.implicit_infer_kind)) name) : @is_simple_group.{0} (finset.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (finset.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_171476 (h0 : not (list (non_assoc_semiring unsigned) -> false)) : list.nodup (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_171477 (h0 : topological_space (has_compl (has_ssubset reducibility_hints))) : totally_disconnected_space (has_compl (has_ssubset reducibility_hints)) := sorry --non-trivial
lemma new_lemma_171478 (h0 : add_group (complete_distrib_lattice environment.implicit_infer_kind)) : is_add_cyclic (complete_distrib_lattice environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_171479 (h0 : ring (ring (option empty))) : strong_rank_condition (ring (option empty)) := sorry --non-trivial
lemma new_lemma_171480 (h0 : functor.add_const (complete_lattice (add_cancel_monoid Type)) pos) : @is_compactly_generated.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (add_cancel_monoid.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_171481 (h0 : ordered_add_comm_monoid (has_Inf (sub_neg_monoid pos))) : archimedean (has_Inf (sub_neg_monoid pos)) := sorry --non-trivial
lemma new_lemma_171482 (h0 : complete_lattice (measurable_space (has_top linarith.comp_source))) : is_atomistic (measurable_space (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_171483 (h0 : topological_space (complete_semilattice_Sup (with_bot (semiring (add_group unsigned))))) : path_connected_space (complete_semilattice_Sup (with_bot (semiring (add_group unsigned)))) := sorry --non-trivial
lemma new_lemma_171484 (h0 : topological_space (finset (has_to_string num))) : preconnected_space (finset (has_to_string num)) := sorry --non-trivial
lemma new_lemma_171485 (h0 : functor.add_const (monoid (ordered_comm_ring Type)) Type) : @monoid.fg.{1} (ordered_comm_ring.{1} Type) (@functor.add_const.run.{1 1} (monoid.{1} (ordered_comm_ring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_171486 (h0 : set (has_ssubset ereal)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_171487 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (@id.{2} Type fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (@id.{2} Type fun_info))  := sorry --non-trivial
lemma new_lemma_171488 (h0 : topological_space (random_gen unsigned)) : path_connected_space (random_gen unsigned) := sorry --non-trivial
lemma new_lemma_171489 (h0 : functor.add_const (topological_space (measurable_space.dynkin_system empty)) empty) : @irreducible_space.{0} (measurable_space.dynkin_system.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (measurable_space.dynkin_system.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_171490 (h0 : group (with_bot unsigned)) : group.fg (with_bot unsigned) := sorry --non-trivial
lemma new_lemma_171491 (h0 : topological_space (add_comm_monoid (normed_comm_ring name))) : totally_disconnected_space (add_comm_monoid (normed_comm_ring name)) := sorry --non-trivial
lemma new_lemma_171492 (h0 : not (complete_lattice (parser empty) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (parser empty) (@classical.by_contradiction'.{1} (complete_lattice.{0} (parser empty)) h0)  := sorry --non-trivial
lemma new_lemma_171493 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @t0_space.{0} unsigned (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) unsigned)  := sorry --non-trivial
lemma new_lemma_171494 (h1 : not (topological_space (has_ssubset linarith.comp_source) -> false)) : @path_connected_space.{0} (has_ssubset.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (has_ssubset.{0} linarith.comp_source)) h1)  := sorry --non-trivial
lemma new_lemma_171495 (h0 : functor.add_const (function.extfun Type topological_space) (ring name)) : @irreducible_space.{0} (boolean_algebra.core.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (ring.{0} name) h0) (boolean_algebra.core.{0} name))  := sorry --non-trivial
lemma new_lemma_171496 (h0 : functor.add_const (group (has_add pos)) Type) : @is_cyclic.{0} (has_add.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (has_add.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_171497 (h0 : functor.add_const (finset (has_star empty)) num) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_171498 (h1 : topological_space (semi_normed_comm_ring string_imp)) : totally_disconnected_space (semi_normed_comm_ring string_imp) := sorry --non-trivial
lemma new_lemma_171499 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (has_neg.{0} name) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (has_neg.{0} name))  := sorry --non-trivial
lemma new_lemma_171500 (h0 : functor.add_const (add_monoid (add_cancel_monoid linarith.comp)) (has_neg Type)) : @add_monoid.fg.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (add_monoid.{0} (add_cancel_monoid.{0} linarith.comp)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_171501 (h0 : group (normed_lattice_add_comm_group (has_nndist Type))) : is_simple_group (normed_lattice_add_comm_group (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_171502 (h0 : ring (has_add (has_Inf linarith.comp))) : strong_rank_condition (has_add (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_171503 (h0 : group (linear_order congr_arg_kind)) : normalizer_condition (linear_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_171504 (h0 : add_group (non_unital_non_assoc_semiring (metric_space reducibility_hints))) : is_add_cyclic (non_unital_non_assoc_semiring (metric_space reducibility_hints)) := sorry --non-trivial
lemma new_lemma_171505 (h0 : group (add_cancel_monoid (boolean_algebra linarith.comp))) : group.fg (add_cancel_monoid (boolean_algebra linarith.comp)) := sorry --non-trivial
lemma new_lemma_171506 (h0 : ring (has_append (comm_ring (has_nnnorm (comm_ring reducibility_hints))))) : is_domain (has_append (comm_ring (has_nnnorm (comm_ring reducibility_hints)))) := sorry --non-trivial
lemma new_lemma_171507 (h0 : has_le (left_cancel_monoid (semiring unsigned))) (h1 : functor.add_const (left_cancel_monoid (semiring unsigned)) congr_arg_kind) : is_max (functor.add_const.run h1) := sorry --non-trivial
lemma new_lemma_171508 (h0 : ring (boolean_algebra (mul_one_class linarith.comp))) : is_principal_ideal_ring (boolean_algebra (mul_one_class linarith.comp)) := sorry --non-trivial
lemma new_lemma_171509 (h0 : group (with_bot empty)) : group.fg (with_bot empty) := sorry --non-trivial
lemma new_lemma_171510 (h0 : topological_space (linear_ordered_field name)) : locally_compact_space (linear_ordered_field name) := sorry --non-trivial
lemma new_lemma_171511 (h0 : function.extfun Type topological_space) : @normal_space.{0} (mul_zero_class.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (mul_zero_class.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_171512 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @separated_space.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 uniform_space.{1}) (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_171513 (h0 : functor.add_const (ordered_comm_monoid (semigroup Type)) (finset Type)) : @has_exists_mul_of_le.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 1} (ordered_comm_monoid.{1} (semigroup.{1} Type)) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_171514 (h0 : fin has_zero.zero) : @loc_path_connected_space.{0} (sub_neg_monoid.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (sub_neg_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_171515 (h0 : fin has_zero.zero) : @is_principal_ideal_ring.{1} (canonically_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (canonically_ordered_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_171516 (h0 : ring (add_cancel_comm_monoid (random_gen (random_gen char)))) : rank_condition (add_cancel_comm_monoid (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_171517 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (complete_distrib_lattice.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} name))  := sorry --non-trivial
lemma new_lemma_171518 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (@id.{2} Type num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (@id.{2} Type num))  := sorry --non-trivial
lemma new_lemma_171519 (h0 : cancel_comm_monoid_with_zero (has_Inf (has_zero Type))) : unique_factorization_monoid (has_Inf (has_zero Type)) := sorry --non-trivial
lemma new_lemma_171520 (h0 : group (comm_ring to_additive.value_type)) : is_cyclic (comm_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_171521 (h0 : uniform_space (ordered_cancel_add_comm_monoid (option empty))) : separated_space (ordered_cancel_add_comm_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_171522 (h0 : not (ring (linear_ordered_add_comm_group (has_nnnorm linarith.comp_source)) -> false)) : @rank_condition.{0} (linear_ordered_add_comm_group.{0} (has_nnnorm.{0} linarith.comp_source)) (@classical.by_contradiction'.{1} (ring.{0} (linear_ordered_add_comm_group.{0} (has_nnnorm.{0} linarith.comp_source))) h0)  := sorry --non-trivial
lemma new_lemma_171523 (h0 : functor.add_const (functor.add_const (function.extfun Type monoid) environment.implicit_infer_kind) linarith.comp) : @monoid.fg.{0} (has_to_string.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type monoid.{0}) environment.implicit_infer_kind (@functor.add_const.run.{1 0} (functor.add_const.{1 0} (function.extfun.{2 1} Type monoid.{0}) environment.implicit_infer_kind) linarith.comp h0)) (has_to_string.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_171524 (h0 : uniform_space (ring name)) : complete_space (ring name) := sorry --non-trivial
lemma new_lemma_171525 (h0 : functor.add_const (topological_space (ordered_ring congr_arg_kind)) (semiring (semiring congr_arg_kind))) : @topological_space.separable_space.{0} (ordered_ring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} congr_arg_kind)) (semiring.{0} (semiring.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_171526 (h0 : ring (has_add environment.implicit_infer_kind)) : is_principal_ideal_ring (has_add environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_171527 (h0 : uniform_space (with_bot (random_gen (random_gen fun_info)))) : complete_space (with_bot (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_171528 (h0 : functor.add_const (uniform_space (has_zero linarith.comp)) (has_to_string (has_to_string Type))) : @complete_space.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 1} (uniform_space.{0} (has_zero.{0} linarith.comp)) (has_to_string.{1} (has_to_string.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_171529 (h0 : topological_space (canonically_ordered_monoid (has_add (has_add linarith.comp)))) : locally_compact_space (canonically_ordered_monoid (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_171530 (h0 : functor.add_const (topological_space (non_assoc_semiring unsigned)) unsigned) : @preirreducible_space.{0} (non_assoc_semiring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (non_assoc_semiring.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_171531 (h0 : filter (add_comm_monoid (ring Type))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_171532 (h0 : functor.add_const Prop (add_group (has_norm (with_bot empty)))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_171533 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (has_nndist.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} num))  := sorry --non-trivial
lemma new_lemma_171534 (h0 : topological_space (add_cancel_monoid name)) : regular_space (add_cancel_monoid name) := sorry --non-trivial
lemma new_lemma_171535 (h1 : add_group (has_inter string_imp)) : is_add_cyclic (has_inter string_imp) := sorry --non-trivial
lemma new_lemma_171536 (h0 : functor.comp group canonically_ordered_comm_semiring name) : @is_simple_group.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.comp.run.{0 0 0} group.{0} canonically_ordered_comm_semiring.{0} name h0)  := sorry --non-trivial
lemma new_lemma_171537 (h0 : prod (add_cancel_monoid (option ennreal)) (add_cancel_monoid (option ennreal))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_171538 (h0 : uniform_space (has_zero (comm_group (boolean_algebra.core (semigroup Type))))) : complete_space (has_zero (comm_group (boolean_algebra.core (semigroup Type)))) := sorry --non-trivial
lemma new_lemma_171539 (h0 : filter (ordered_comm_group (option empty))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_171540 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (has_top.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_top.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_171541 (h1 : complete_lattice (random_gen linarith.comp_source)) : complete_lattice.is_Sup_finite_compact (random_gen linarith.comp_source) := sorry --non-trivial
lemma new_lemma_171542 (h0 : uniform_space (has_one (semiring num))) : complete_space (has_one (semiring num)) := sorry --non-trivial
lemma new_lemma_171543 (h0 : monoid (normed_group (has_inv (random_gen (random_gen linarith.ineq))))) : monoid.fg (normed_group (has_inv (random_gen (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_171544 (h1 : topological_space (has_compl (mul_one_class (mul_one_class (mul_one_class linarith.ineq))))) : t0_space (has_compl (mul_one_class (mul_one_class (mul_one_class linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_171545 (h0 : not (function.extfun Type ring -> false)) : @invariant_basis_number.{0} (semiring.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_171546 (h0 : topological_space (comm_semigroup (has_pos_part Type))) : t0_space (comm_semigroup (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_171547 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_domain.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ring.{1}) (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_171548 (h0 : functor.add_const (topological_space (partial_order empty)) num) : @topological_space.separable_space.{0} (partial_order.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (partial_order.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_171549 (h0 : not (topological_space (has_emptyc (random_gen linarith.comp_source)) -> false)) : @irreducible_space.{0} (has_emptyc.{0} (random_gen.{0} linarith.comp_source)) (@classical.by_contradiction'.{1} (topological_space.{0} (has_emptyc.{0} (random_gen.{0} linarith.comp_source))) h0)  := sorry --non-trivial
lemma new_lemma_171550 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (fintype.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (fintype.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_171551 (h0 : ring (has_union (has_nnnorm linarith.comp_source))) : rank_condition (has_union (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_171552 (h0 : topological_space (ordered_comm_monoid (has_pos_part linarith.comp))) : sequential_space (ordered_comm_monoid (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_171553 (h0 : functor.add_const (filter (has_neg_part Type)) (add_cancel_monoid Type)) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_171554 (h0 : uniform_space (cancel_monoid (add_semigroup (semigroup (cancel_monoid Type))))) : separated_space (cancel_monoid (add_semigroup (semigroup (cancel_monoid Type)))) := sorry --non-trivial
lemma new_lemma_171555 (h0 h1 : Prop) : yyy_to h0 (id h1) := sorry --non-trivial
lemma new_lemma_171556 (h0 : monoid (generalized_boolean_algebra (ring (ring (ring Type))))) : monoid.fg (generalized_boolean_algebra (ring (ring (ring Type)))) := sorry --non-trivial
lemma new_lemma_171557 (h0 : functor.add_const (monoid (cancel_monoid name)) pos) : @monoid.fg.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (monoid.{0} (cancel_monoid.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_171558 (h0 : function.extfun Type group) : @is_cyclic.{0} (linear_ordered_field.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (linear_ordered_field.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_171559 (h0 : ordered_comm_monoid (normed_lattice_add_comm_group pos)) : has_exists_mul_of_le (normed_lattice_add_comm_group pos) := sorry --non-trivial
lemma new_lemma_171560 (h0 : not (add_monoid (id congr_arg_kind) -> false)) : @add_monoid.fg.{0} (@id.{2} Type congr_arg_kind) (@classical.by_contradiction'.{1} (add_monoid.{0} (@id.{2} Type congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_171561 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (option.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (option.{0} num))  := sorry --non-trivial
lemma new_lemma_171562 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_171563 (h0 : fin has_zero.zero) : @is_principal_ideal_ring.{0} (has_pos_part.{0} pos) (@matrix.vec_empty.{0} (ring.{0} (has_pos_part.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_171564 (h0 : ring (linear_order num)) : is_principal_ideal_ring (linear_order num) := sorry --non-trivial
lemma new_lemma_171565 (h0 : complete_lattice (with_bot linarith.comp_source)) : is_compactly_generated (with_bot linarith.comp_source) := sorry --non-trivial
lemma new_lemma_171566 (h0 : functor.add_const (complete_lattice (has_nndist name)) Type) : @is_compactly_generated.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 1} (complete_lattice.{0} (has_nndist.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_171567 (h0 : ring (has_to_string (finset (finset (finset name))))) : strong_rank_condition (has_to_string (finset (finset (finset name)))) := sorry --non-trivial
lemma new_lemma_171568 (h0 : topological_space (has_add name)) : totally_disconnected_space (has_add name) := sorry --non-trivial
lemma new_lemma_171569 (h0 : fin has_zero.zero) : @irreducible_space.{0} (ordered_comm_ring.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (ordered_comm_ring.{0} real))  := sorry --non-trivial
lemma new_lemma_171570 (h0 : semiring (ordered_cancel_add_comm_monoid unsigned)) : is_noetherian_ring (ordered_cancel_add_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_171571 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} (topological_space.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (topological_space.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_171572 (h0 : topological_space (partial_order (semiring (semiring (semiring congr_arg_kind))))) : discrete_topology (partial_order (semiring (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_171573 (h0 : topological_space (random_gen (semiring (semiring empty)))) : normal_space (random_gen (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_171574 (h0 : topological_space (non_assoc_semiring empty)) : discrete_topology (non_assoc_semiring empty) := sorry --non-trivial
lemma new_lemma_171575 (h0 : function.extfun Type (functor.comp ordered_comm_monoid has_nndist)) : @has_exists_mul_of_le.{0} (has_nndist.{0} ennreal) (@functor.comp.run.{0 0 0} ordered_comm_monoid.{0} has_nndist.{0} ennreal (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} ordered_comm_monoid.{0} has_nndist.{0}) h0 ennreal))  := sorry --non-trivial
lemma new_lemma_171576 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (semigroup.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semigroup.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_171577 (h1 : measurable_space (mul_one_class std_gen)) (h2 : measure_theory.measure (mul_one_class std_gen)) : measure_theory.is_finite_measure h2 := sorry --non-trivial
lemma new_lemma_171578 (h0 : semiring (with_bot (semiring (semiring empty)))) : is_noetherian_ring (with_bot (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_171579 (h1 : topological_space (distrib_lattice to_additive.value_type)) : path_connected_space (distrib_lattice to_additive.value_type) := sorry --non-trivial
lemma new_lemma_171580 (h0 : ring (random_gen (has_norm (has_norm linarith.ineq)))) : is_domain (random_gen (has_norm (has_norm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_171581 (h0 : functor.add_const (topological_space (comm_group name)) name) : @normal_space.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_171582 (h0 : not (topological_space (partial_order congr_arg_kind) -> false)) : @irreducible_space.{0} (partial_order.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (partial_order.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_171583 (h0 : filter (comm_ring (has_ssubset linarith.ineq))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_171584 (h0 : complete_lattice (finset (finset name))) : is_compactly_generated (finset (finset name)) := sorry --non-trivial
lemma new_lemma_171585 (h0 : ordered_add_comm_monoid (finset (has_add (has_add Type)))) : archimedean (finset (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_171586 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (@id.{2} Type unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (@id.{2} Type unsigned))  := sorry --non-trivial
lemma new_lemma_171587 (h0 : topological_space (has_neg_part (has_add (has_add environment.implicit_infer_kind)))) : locally_compact_space (has_neg_part (has_add (has_add environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_171588 (h2 : ring (denumerable fun_info)) : strong_rank_condition (denumerable fun_info) := sorry --non-trivial
lemma new_lemma_171589 (h0 : complete_lattice (has_ssubset (mul_one_class linarith.comp_source))) : complete_lattice.is_Sup_finite_compact (has_ssubset (mul_one_class linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_171590 (h0 : cancel_comm_monoid_with_zero (ordered_comm_ring (has_neg (has_neg Type)))) : unique_factorization_monoid (ordered_comm_ring (has_neg (has_neg Type))) := sorry --non-trivial
lemma new_lemma_171591 (h0 : add_monoid (plift (semiring (semiring unsigned)))) : add_monoid.fg (plift (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_171592 (h0 : topological_space (cancel_monoid (has_neg (boolean_algebra (boolean_algebra linarith.comp))))) : regular_space (cancel_monoid (has_neg (boolean_algebra (boolean_algebra linarith.comp)))) := sorry --non-trivial
lemma new_lemma_171593 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (semigroup.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semigroup.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_171594 (h0 : topological_space (add_cancel_monoid (has_add (has_add Type)))) : totally_disconnected_space (add_cancel_monoid (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_171595 (h0 : functor.add_const (list (has_to_string name)) unsigned) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_171596 (h0 : has_mem.mem (semiring (random_gen fun_info)) has_emptyc.emptyc) : @is_atomistic.{0} (semiring.{0} (random_gen.{0} fun_info)) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (semiring.{0} (random_gen.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_171597 (h0 : function.extfun Type topological_space) : @normal_space.{0} (partial_order.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (partial_order.{0} num))  := sorry --non-trivial
lemma new_lemma_171598 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @rank_condition.{1} (complete_distrib_lattice.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ring.{1}) (complete_distrib_lattice.{1} Type))  := sorry --non-trivial
lemma new_lemma_171599 (h0 : with_bot (has_one fun_info) -> with_bot (has_one fun_info) -> Prop) : is_symm (with_bot (has_one fun_info)) h0 := sorry --non-trivial
lemma new_lemma_171600 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (option.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (option.{0} empty))  := sorry --non-trivial
lemma new_lemma_171601 (h0 : topological_space (add_comm_monoid (finset (has_to_string linarith.comp)))) : t0_space (add_comm_monoid (finset (has_to_string linarith.comp))) := sorry --non-trivial
lemma new_lemma_171602 (h0 : uniform_space (add_cancel_monoid (ring linarith.comp))) : complete_space (add_cancel_monoid (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_171603 (h0 : filter (add_comm_monoid (comm_group (comm_group (comm_group (comm_group pos)))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_171604 (h0 : list (canonically_ordered_comm_semiring congr_arg_kind)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_171605 (h0 : functor.comp topological_space cancel_monoid Type) : @totally_separated_space.{1} (cancel_monoid.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} cancel_monoid.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_171606 (h0 : topological_space (mul_zero_class (finset name))) : irreducible_space (mul_zero_class (finset name)) := sorry --non-trivial
lemma new_lemma_171607 (h0 : functor.add_const (topological_space (preorder unsigned)) congr_arg_kind) : @locally_compact_space.{0} (preorder.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (preorder.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_171608 (h1 : ring (semi_normed_comm_ring linarith.comp_source)) : strong_rank_condition (semi_normed_comm_ring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_171609 (h0 : ring (normed_lattice_add_comm_group (option (option empty)))) : rank_condition (normed_lattice_add_comm_group (option (option empty))) := sorry --non-trivial
lemma new_lemma_171610 (h0 : ring (linear_order (option (option unsigned)))) : rank_condition (linear_order (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_171611 (h0 : functor.add_const (function.extfun (Type 1) ordered_comm_monoid) name) : @has_exists_mul_of_le.{1} (has_pos_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_comm_monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ordered_comm_monoid.{1}) name h0) (has_pos_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_171612 (h1 : uniform_space num) : complete_space num := sorry --non-trivial
lemma new_lemma_171613 (h0 : functor.add_const (filter (has_neg linarith.comp)) (finset environment.implicit_infer_kind)) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_171614 (h0 : topological_space (semiring (has_norm (has_norm linarith.comp)))) : locally_compact_space (semiring (has_norm (has_norm linarith.comp))) := sorry --non-trivial
lemma new_lemma_171615 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_171616 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (monoid_with_zero.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (monoid_with_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_171617 (h0 : functor.comp list comm_group environment.implicit_infer_kind) : palindrome (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_171618 (h1 : complete_lattice (has_norm (random_gen (random_gen string_imp)))) : is_atomistic (has_norm (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_171619 (h0 : topological_space (semigroup (has_add name))) : regular_space (semigroup (has_add name)) := sorry --non-trivial
lemma new_lemma_171620 (h0 : functor.add_const (function.extfun Type group) (finset (has_neg_part Type))) : @normalizer_condition.{0} (comm_group.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type group.{0}) (finset.{1} (has_neg_part.{1} Type)) h0) (comm_group.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_171621 (h0 : topological_space (has_inter empty)) : totally_disconnected_space (has_inter empty) := sorry --non-trivial
lemma new_lemma_171622 (h0 : topological_space (add_comm_monoid (finset linarith.comp))) : regular_space (add_comm_monoid (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_171623 (h0 : not (complete_lattice (has_top linarith.ineq) -> false)) : @is_atomistic.{0} (has_top.{0} linarith.ineq) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_top.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_171624 (h0 : functor.add_const (ring (ring Type)) environment.implicit_infer_kind) : @is_domain.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (ring.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_171625 (h0 : functor.comp add_monoid has_nndist name) : @add_monoid.fg.{0} (has_nndist.{0} name) (@functor.comp.run.{0 0 0} add_monoid.{0} has_nndist.{0} name (@functor.comp.run.{0 0 0} add_monoid.{0} has_nndist.{0} name (@functor.comp.run.{0 0 0} add_monoid.{0} has_nndist.{0} name (@functor.comp.run.{0 0 0} add_monoid.{0} has_nndist.{0} name (@functor.comp.run.{0 0 0} add_monoid.{0} has_nndist.{0} name (@functor.comp.run.{0 0 0} add_monoid.{0} has_nndist.{0} name (@functor.comp.run.{0 0 0} add_monoid.{0} has_nndist.{0} name (@functor.comp.run.{0 0 0} add_monoid.{0} has_nndist.{0} name (@functor.comp.run.{0 0 0} add_monoid.{0} has_nndist.{0} name (@functor.comp.run.{0 0 0} add_monoid.{0} has_nndist.{0} name (@functor.comp.run.{0 0 0} add_monoid.{0} has_nndist.{0} name h0)))))))))))  := sorry --non-trivial
lemma new_lemma_171626 (h0 : complete_lattice (normed_lattice_add_comm_group (has_neg name))) : complete_lattice.is_Sup_finite_compact (normed_lattice_add_comm_group (has_neg name)) := sorry --non-trivial
lemma new_lemma_171627 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_171628 (h1 : topological_space (simple_graph linarith.comp_source)) : path_connected_space (simple_graph linarith.comp_source) := sorry --non-trivial
lemma new_lemma_171629 (h0 : functor.add_const (topological_space (has_Sup congr_arg_kind)) empty) : @topological_space.separable_space.{0} (has_Sup.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Sup.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_171630 (h0 : ring (has_union (has_union linarith.comp))) : is_domain (has_union (has_union linarith.comp)) := sorry --non-trivial
lemma new_lemma_171631 (h0 : functor.add_const (prod (option empty) (option empty)) empty) : id_rel (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_171632 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_171633 (h0 : group (finset (ring (has_neg (boolean_algebra (has_neg linarith.comp)))))) : is_cyclic (finset (ring (has_neg (boolean_algebra (has_neg linarith.comp))))) := sorry --non-trivial
lemma new_lemma_171634 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (@id.{2} Type num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (@id.{2} Type num))  := sorry --non-trivial
lemma new_lemma_171635 (h1 : ring (non_unital_non_assoc_semiring (random_gen linarith.comp_source))) : is_domain (non_unital_non_assoc_semiring (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_171636 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (semigroup.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type semiring.{0} h0 (semigroup.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_171637 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_171638 (h0 : topological_space (comm_ring (has_nnnorm (with_zero fun_info)))) : path_connected_space (comm_ring (has_nnnorm (with_zero fun_info))) := sorry --non-trivial
lemma new_lemma_171639 (h0 : topological_space (has_top (random_gen num))) : irreducible_space (has_top (random_gen num)) := sorry --non-trivial
lemma new_lemma_171640 (h0 : ring (normed_comm_ring linarith.comp)) : rank_condition (normed_comm_ring linarith.comp) := sorry --non-trivial
lemma new_lemma_171641 (h0 : topological_space (comm_group (semiring empty))) : loc_path_connected_space (comm_group (semiring empty)) := sorry --non-trivial
lemma new_lemma_171642 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (linear_ordered_semiring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_171643 (h0 : functor.add_const (group (canonically_ordered_comm_semiring unsigned)) pos) : @is_cyclic.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (canonically_ordered_comm_semiring.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_171644 (h0 : functor.add_const (group (generalized_boolean_algebra linarith.comp)) pos) : @is_simple_group.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (generalized_boolean_algebra.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_171645 (h0 : cancel_comm_monoid_with_zero (has_to_string environment.implicit_infer_kind)) : unique_factorization_monoid (has_to_string environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_171646 (h0 : has_add (complete_distrib_lattice ennreal) -> has_add (complete_distrib_lattice ennreal) -> Prop) : is_symm (has_add (complete_distrib_lattice ennreal)) h0 := sorry --non-trivial
lemma new_lemma_171647 (h0 : topological_space (add_comm_semigroup ereal)) (h1 : preorder (add_comm_semigroup ereal)) : order_topology (add_comm_semigroup ereal) := sorry --non-trivial
lemma new_lemma_171648 (h0 : uniform_space (canonically_ordered_monoid (has_neg (has_Inf Type)))) : separated_space (canonically_ordered_monoid (has_neg (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_171649 (h0 : function.extfun Type topological_space) : @t0_space.{0} (as_linear_order.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (as_linear_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_171650 (h0 : set (has_compl std_gen)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_171651 (h0 : topological_space (has_norm (has_top (has_top linarith.ineq)))) : totally_disconnected_space (has_norm (has_top (has_top linarith.ineq))) := sorry --non-trivial
lemma new_lemma_171652 (h0 : filter (has_inv (comm_ring fun_info))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_171653 (h0 : functor.add_const (function.extfun Type topological_space) (has_neg pos)) : @normal_space.{0} (has_Inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (has_neg.{0} pos) h0) (has_Inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_171654 (h0 : monoid (preorder (semiring (semiring (semiring empty))))) : monoid.fg (preorder (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_171655 (h0 : topological_space (distrib linarith.comp_source)) : totally_disconnected_space (distrib linarith.comp_source) := sorry --non-trivial
lemma new_lemma_171656 (h0 : function.extfun Type topological_space) : @t0_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_171657 (h0 : complete_lattice (linear_ordered_comm_group ennreal)) : is_atomistic (linear_ordered_comm_group ennreal) := sorry --non-trivial
lemma new_lemma_171658 (h0 : group (ordered_comm_monoid (has_bot (has_bot real)))) : is_cyclic (ordered_comm_monoid (has_bot (has_bot real))) := sorry --non-trivial
lemma new_lemma_171659 (h0 : set (semi_normed_comm_ring reducibility_hints)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_171660 (h0 : ring (has_norm (has_norm (has_norm (has_norm to_additive.value_type))))) : is_domain (has_norm (has_norm (has_norm (has_norm to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_171661 (h0 : functor.add_const (monoid (canonically_linear_ordered_monoid real)) name) : @monoid.fg.{0} (canonically_linear_ordered_monoid.{0} real) (@functor.add_const.run.{0 0} (monoid.{0} (canonically_linear_ordered_monoid.{0} real)) name h0)  := sorry --non-trivial
lemma new_lemma_171662 (h0 : has_mem.mem ring has_emptyc.emptyc) : @rank_condition.{0} (has_emptyc.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} h0) (has_emptyc.{0} num))  := sorry --non-trivial
lemma new_lemma_171663 (h0 : topological_space (with_bot (semiring num))) : normal_space (with_bot (semiring num)) := sorry --non-trivial
lemma new_lemma_171664 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (dlist.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (dlist.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_171665 (h0 : functor.add_const (functor.add_const (cancel_comm_monoid_with_zero Type) linarith.comp) pos) : @unique_factorization_monoid.{1} Type (@functor.add_const.run.{1 0} (cancel_comm_monoid_with_zero.{1} Type) linarith.comp (@functor.add_const.run.{1 0} (functor.add_const.{1 0} (cancel_comm_monoid_with_zero.{1} Type) linarith.comp) pos h0))  := sorry --non-trivial
lemma new_lemma_171666 (h1 h2 : multiset (mul_one_class ereal)) : multiset.disjoint h1 h2 := sorry --non-trivial
lemma new_lemma_171667 (h0 : group (has_append (random_gen char))) : is_cyclic (has_append (random_gen char)) := sorry --non-trivial
lemma new_lemma_171668 (h0 : functor.add_const (group (has_to_string linarith.comp)) environment.implicit_infer_kind) : @group.fg.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (has_to_string.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_171669 (h0 : functor.add_const (uniform_space (has_to_string Type)) (finset Type)) : @complete_space.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 1} (uniform_space.{1} (has_to_string.{1} Type)) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_171670 (h0 : function.extfun Type topological_space) : @normal_space.{0} (linear_ordered_semiring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_171671 (h1 : list (with_one congr_arg_kind)) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_171672 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (with_bot.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (with_bot.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_171673 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (has_sub.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} unsigned)))))) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_sub.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} unsigned)))))))  := sorry --non-trivial
lemma new_lemma_171674 (h0 : ring (boolean_algebra.core (has_to_string pos))) : is_domain (boolean_algebra.core (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_171675 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_to_string.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_to_string.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_171676 (h0 : functor.add_const (complete_lattice (boolean_algebra.core pos)) Type) : @is_compactly_generated.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 1} (complete_lattice.{0} (boolean_algebra.core.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_171677 (h0 : set (add_comm_semigroup (add_comm_semigroup (normed_field environment.projection_info)) -> std_gen)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_171678 (h2 : topological_space (semi_normed_comm_ring string_imp)) : t0_space (semi_normed_comm_ring string_imp) := sorry --non-trivial
lemma new_lemma_171679 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (linear_ordered_semiring.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (linear_ordered_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_171680 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (@id.{2} Type linarith.ineq) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (@id.{2} Type linarith.ineq))  := sorry --non-trivial
lemma new_lemma_171681 (h0 : monoid (has_pos_part name)) : monoid.fg (has_pos_part name) := sorry --non-trivial
lemma new_lemma_171682 (h0 : functor.add_const (add_group (comm_group pos)) (has_add environment.implicit_infer_kind)) : @is_add_cyclic.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (comm_group.{0} pos)) (has_add.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_171683 (h0 : functor.comp ring has_neg environment.implicit_infer_kind) : @is_domain.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} ring.{0} has_neg.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_171684 (h0 : topological_space (has_nndist (has_neg (has_neg (normed_comm_ring linarith.comp))))) : t0_space (has_nndist (has_neg (has_neg (normed_comm_ring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_171685 (h0 : group (random_gen (semiring (semiring linarith.comp)))) : group.fg (random_gen (semiring (semiring linarith.comp))) := sorry --non-trivial
lemma new_lemma_171686 (h0 : function.extfun Type group) : @normalizer_condition.{0} (complete_semilattice_Sup.{0} (has_top.{0} linarith.ineq)) (@function.extfun_app.{2 1} Type group.{0} h0 (complete_semilattice_Sup.{0} (has_top.{0} linarith.ineq)))  := sorry --non-trivial
lemma new_lemma_171687 (h0 : functor.add_const (topological_space (add_comm_monoid environment.implicit_infer_kind)) name) : @path_connected_space.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_171688 (h0 : ring (metric_space (semiring congr_arg_kind))) : strong_rank_condition (metric_space (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_171689 (h0 : function.extfun (Type -> Type) (function.extfun Type)) (h1 : function.extfun Type add_group) : @uniform_add_group.{0} (mul_zero_class.{0} ennreal) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (mul_zero_class.{0} ennreal)) (@function.extfun_app.{2 1} Type add_group.{0} h1 (mul_zero_class.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_171690 (h0 : ring (has_pos_part (has_add (has_bot (has_add real))))) : strong_rank_condition (has_pos_part (has_add (has_bot (has_add real)))) := sorry --non-trivial
lemma new_lemma_171691 (h0 : functor.add_const (list (canonically_ordered_comm_semiring pos)) pos) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_171692 (h0 : uniform_space (add_group (semiring (has_top empty)))) : separated_space (add_group (semiring (has_top empty))) := sorry --non-trivial
lemma new_lemma_171693 (h0 : topological_space (add_cancel_monoid (has_add (finset (finset pos))))) : t0_space (add_cancel_monoid (has_add (finset (finset pos)))) := sorry --non-trivial
lemma new_lemma_171694 (h0 : ring (normed_comm_ring (has_add environment.implicit_infer_kind))) : rank_condition (normed_comm_ring (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_171695 (h0 : num -> num -> Prop) : is_refl num h0 := sorry --non-trivial
lemma new_lemma_171696 (h0 : not (topological_space (semi_normed_comm_ring char) -> false)) : @locally_compact_space.{0} (semi_normed_comm_ring.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (semi_normed_comm_ring.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_171697 (h0 : topological_space (normed_lattice_add_comm_group (sub_neg_monoid (has_bot Type)))) : discrete_topology (normed_lattice_add_comm_group (sub_neg_monoid (has_bot Type))) := sorry --non-trivial
lemma new_lemma_171698 (h0 : ring (finset (has_add (boolean_algebra pos)))) : rank_condition (finset (has_add (boolean_algebra pos))) := sorry --non-trivial
lemma new_lemma_171699 (h1 : topological_space (complete_semilattice_Sup to_additive.value_type)) : locally_compact_space (complete_semilattice_Sup to_additive.value_type) := sorry --non-trivial
lemma new_lemma_171700 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (measurable_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (measurable_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_171701 (h0 : ring (has_one (has_top unsigned))) : rank_condition (has_one (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_171702 (h0 : functor.add_const (semiring (ordered_comm_ring Type)) linarith.comp) : @is_noetherian_ring.{1} (ordered_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (semiring.{1} (ordered_comm_ring.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_171703 (h0 : ring (complete_distrib_lattice (has_neg_part unsigned))) : rank_condition (complete_distrib_lattice (has_neg_part unsigned)) := sorry --non-trivial
lemma new_lemma_171704 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_171705 (h0 : add_group (dlist (random_gen (add_cancel_comm_monoid char)))) : is_add_cyclic (dlist (random_gen (add_cancel_comm_monoid char))) := sorry --non-trivial
lemma new_lemma_171706 (h0 : not (topological_space (linear_ordered_comm_group_with_zero (mul_one_class char)) -> false)) : @t0_space.{0} (linear_ordered_comm_group_with_zero.{0} (mul_one_class.{0} char)) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_comm_group_with_zero.{0} (mul_one_class.{0} char))) h0)  := sorry --non-trivial
lemma new_lemma_171707 (h0 : functor.add_const (group (linear_ordered_comm_monoid_with_zero empty)) empty) : @is_cyclic.{0} (linear_ordered_comm_monoid_with_zero.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (linear_ordered_comm_monoid_with_zero.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_171708 (h0 : has_mem.mem complete_lattice has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} fun_info (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} h0) fun_info)  := sorry --non-trivial
lemma new_lemma_171709 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} (metric_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (metric_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_171710 (h1 : ring (random_gen (has_lt char))) : is_domain (random_gen (has_lt char)) := sorry --non-trivial
lemma new_lemma_171711 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_ssubset.{0} string_imp) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_ssubset.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_171712 (h0 : functor.comp topological_space comm_group ennreal) : @irreducible_space.{0} (comm_group.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} comm_group.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_171713 (h0 : topological_space (has_union (has_union (semiring unsigned)))) : t0_space (has_union (has_union (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_171714 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_171715 (h0 : topological_space (ordered_comm_monoid (finset (has_add linarith.comp)))) : locally_compact_space (ordered_comm_monoid (finset (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_171716 (h0 : group (has_one (semiring (semiring (semiring (semiring (semiring (semiring (semiring num))))))))) : is_cyclic (has_one (semiring (semiring (semiring (semiring (semiring (semiring (semiring num)))))))) := sorry --non-trivial
lemma new_lemma_171717 (h0 : filter (add_left_cancel_monoid (has_nnnorm (has_nnnorm fun_info)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_171718 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (complete_semilattice_Sup unsigned)) := sorry --non-trivial
lemma new_lemma_171719 (h0 : topological_space (semiring (semiring (semiring (semiring congr_arg_kind))))) : path_connected_space (semiring (semiring (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_171720 (h0 : ring (normed_group (has_norm (has_top linarith.comp_source)))) : is_domain (normed_group (has_norm (has_top linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_171721 (h0 : ring (with_one linarith.comp_source)) : strong_rank_condition (with_one linarith.comp_source) := sorry --non-trivial
lemma new_lemma_171722 (h0 : topological_space (has_top (semiring unsigned))) : locally_compact_space (has_top (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_171723 (h0 : list (left_cancel_semigroup (semiring (semiring (semiring congr_arg_kind))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_171724 (h0 : topological_space (has_Sup (free_add_monoid unsigned))) : irreducible_space (has_Sup (free_add_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_171725 (h0 : group (partial_order (semiring (semiring (semiring (semiring (semiring empty))))))) : normalizer_condition (partial_order (semiring (semiring (semiring (semiring (semiring empty)))))) := sorry --non-trivial
lemma new_lemma_171726 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (group_with_zero.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (group_with_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_171727 (h0 : not (topological_space (uniform_space string.iterator_imp) -> false)) : @t0_space.{0} (uniform_space.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (topological_space.{0} (uniform_space.{0} string.iterator_imp)) h0)  := sorry --non-trivial
lemma new_lemma_171728 (h0 : functor.add_const (uniform_space (comm_group name)) Type) : @separated_space.{0} (comm_group.{0} name) (@functor.add_const.run.{0 1} (uniform_space.{0} (comm_group.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_171729 (h0 : function.extfun Type preorder) (h1 : function.extfun (with_bot num) (fun (x : with_bot num), Prop)) : @bdd_below.{0} (with_bot.{0} num) (@function.extfun_app.{2 1} Type preorder.{0} h0 (with_bot.{0} num)) (@function.extfun_app.{1 1} (with_bot.{0} num) (λ (x : with_bot.{0} num), Prop) h1)  := sorry --non-trivial
lemma new_lemma_171730 (h0 : functor.add_const (group (add_comm_monoid pos)) linarith.comp) : @is_simple_group.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (add_comm_monoid.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_171731 (h0 : topological_space (simple_graph linarith.comp)) : normal_space (simple_graph linarith.comp) := sorry --non-trivial
lemma new_lemma_171732 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (semigroup.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (semigroup.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_171733 (h0 : complete_lattice (normed_group (random_gen num))) : is_compactly_generated (normed_group (random_gen num)) := sorry --non-trivial
lemma new_lemma_171734 (h0 : monoid (has_to_string empty)) : monoid.fg (has_to_string empty) := sorry --non-trivial
lemma new_lemma_171735 (h0 : not (function.extfun Type topological_space -> false)) : @preirreducible_space.{0} (normed_group.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (normed_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_171736 (h0 : ordered_comm_monoid (has_neg (finset linarith.comp))) : has_exists_mul_of_le (has_neg (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_171737 (h0 : group (add_right_cancel_monoid (semiring congr_arg_kind))) : is_cyclic (add_right_cancel_monoid (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_171738 (h1 : topological_space (normed_group string_imp)) : locally_compact_space (normed_group string_imp) := sorry --non-trivial
lemma new_lemma_171739 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} environment.implicit_infer_kind (@function.extfun_app.{2 1} Type topological_space.{0} h0 environment.implicit_infer_kind)  := sorry --non-trivial
lemma new_lemma_171740 (h0 : function.extfun Type topological_space) : @t0_space.{0} (semigroup.{0} (semiring.{0} (semiring.{0} (semiring.{0} empty)))) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} (semiring.{0} (semiring.{0} (semiring.{0} empty)))))  := sorry --non-trivial
lemma new_lemma_171741 (h0 : topological_space (has_nnnorm (has_inv linarith.ineq))) : locally_compact_space (has_nnnorm (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_171742 (h0 : topological_space (normed_group (linear_ordered_semiring (semiring num)))) : normal_space (normed_group (linear_ordered_semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_171743 (h0 : ring (with_one (random_gen linarith.ineq))) : strong_rank_condition (with_one (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_171744 (h0 : topological_space (linear_ordered_field (has_add environment.implicit_infer_kind))) : path_connected_space (linear_ordered_field (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_171745 (h0 : functor.add_const (topological_space (left_cancel_monoid num)) num) : @discrete_topology.{0} (left_cancel_monoid.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_171746 (h0 : topological_space (generalized_boolean_algebra (has_bot name))) : t1_space (generalized_boolean_algebra (has_bot name)) := sorry --non-trivial
lemma new_lemma_171747 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @path_connected_space.{1} (has_bot.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (has_bot.{1} Type)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_171748 (h0 : functor.comp filter normed_comm_ring ennreal) : filter.ne_bot (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_171749 (h0 : functor.add_const (uniform_space (pseudo_metric_space empty)) num) : @complete_space.{0} (pseudo_metric_space.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (pseudo_metric_space.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_171750 (h0 : topological_space (has_neg (semigroup pos))) : normal_space (has_neg (semigroup pos)) := sorry --non-trivial
lemma new_lemma_171751 (h1 : group (add_monoid char)) : is_cyclic (add_monoid char) := sorry --non-trivial
lemma new_lemma_171752 (h0 : topological_space (canonically_ordered_comm_semiring (has_add name))) : regular_space (canonically_ordered_comm_semiring (has_add name)) := sorry --non-trivial
lemma new_lemma_171753 (h0 : add_group (simple_graph (finset Type))) : is_add_cyclic (simple_graph (finset Type)) := sorry --non-trivial
lemma new_lemma_171754 (h0 : topological_space (rel empty fun_info)) : locally_compact_space (rel empty fun_info) := sorry --non-trivial
lemma new_lemma_171755 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (add_group.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_171756 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (comm_group.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type semiring.{0} h0 (comm_group.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_171757 (h0 : monoid (left_cancel_monoid (is_R_or_C empty))) : monoid.fg (left_cancel_monoid (is_R_or_C empty)) := sorry --non-trivial
lemma new_lemma_171758 (h0 : add_group (uniform_space (random_gen (comm_ring linarith.comp_source)))) : is_add_cyclic (uniform_space (random_gen (comm_ring linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_171759 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (monoid_with_zero unsigned)) := sorry --non-trivial
lemma new_lemma_171760 (h0 : functor.add_const (list (has_Inf Type)) name) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_171761 (h0 : topological_space (has_nndist (finset (has_add linarith.comp)))) : t1_space (has_nndist (finset (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_171762 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (with_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_171763 (h0 : functor.add_const (semiring (ordered_comm_ring linarith.comp)) name) : @is_noetherian_ring.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (semiring.{0} (ordered_comm_ring.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_171764 (h0 : functor.add_const Prop (semigroup (has_to_string (has_to_string (has_neg (has_to_string (has_neg pos))))))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_171765 (h0 : not (has_mem.mem (has_top linarith.comp_source) has_emptyc.emptyc -> false)) : @path_connected_space.{0} (has_top.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_top.{0} linarith.comp_source) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_top.{0} linarith.comp_source) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_171766 (h0 : functor.add_const (topological_space (left_cancel_monoid unsigned)) num) : @totally_disconnected_space.{0} (left_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_171767 (h0 : topological_space (semi_normed_comm_ring (random_gen to_additive.value_type))) : totally_disconnected_space (semi_normed_comm_ring (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_171768 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (random_gen.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type monoid.{0} h0 (random_gen.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_171769 (h0 : add_group (monoid_with_zero congr_arg_kind)) : is_add_cyclic (monoid_with_zero congr_arg_kind) := sorry --non-trivial
lemma new_lemma_171770 (h1 : set (add_comm_semigroup string.iterator_imp -> add_comm_semigroup fun_info)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_171771 (h0 : complete_lattice (comm_group Type)) : complete_lattice.is_Sup_finite_compact (comm_group Type) := sorry --non-trivial
lemma new_lemma_171772 (h0 : ring (left_cancel_monoid (option (option empty)))) : is_domain (left_cancel_monoid (option (option empty))) := sorry --non-trivial
lemma new_lemma_171773 (h0 : topological_space (has_add (has_to_string name))) : preirreducible_space (has_add (has_to_string name)) := sorry --non-trivial
lemma new_lemma_171774 (h0 : ring (partial_order unsigned)) : is_domain (partial_order unsigned) := sorry --non-trivial
lemma new_lemma_171775 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (has_to_string.{0} (option.{0} pos)) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_to_string.{0} (option.{0} pos)))  := sorry --non-trivial
lemma new_lemma_171776 (h0 : topological_space (with_one char)) : path_connected_space (with_one char) := sorry --non-trivial
lemma new_lemma_171777 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (mul_zero_class.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (mul_zero_class.{0} empty))  := sorry --non-trivial
lemma new_lemma_171778 (h0 : topological_space (pseudo_emetric_space linarith.comp_source)) : t0_space (pseudo_emetric_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_171779 (h0 : topological_space (cancel_monoid (finset environment.implicit_infer_kind))) : normal_space (cancel_monoid (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_171780 (h0 : has_mem.mem congr_arg_kind has_emptyc.emptyc) : @irreducible_space.{0} congr_arg_kind (@finset.pi.empty.{1 0} Type topological_space.{0} congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_171781 (h0 : ring (has_neg_part (add_comm_monoid Type))) : is_domain (has_neg_part (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_171782 (h0 : group (div_inv_monoid char)) : is_cyclic (div_inv_monoid char) := sorry --non-trivial
lemma new_lemma_171783 (h0 : function.extfun Type (prod (has_to_string (option (option unsigned))))) : id_rel (function.extfun_app h0 (has_to_string (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_171784 (h0 : add_group (has_nndist (has_neg name))) : is_add_cyclic (has_nndist (has_neg name)) := sorry --non-trivial
lemma new_lemma_171785 (h0 : functor.add_const (list (has_to_string environment.implicit_infer_kind)) (finset linarith.comp)) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_171786 (h0 : ordered_add_comm_monoid (has_neg_part environment.implicit_infer_kind)) : archimedean (has_neg_part environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_171787 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem uniform_space)) : @complete_space.{0} num (@function.extfun_app.{2 1} Type uniform_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) uniform_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) uniform_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) num)  := sorry --non-trivial
lemma new_lemma_171788 (h0 : ring (distrib_lattice (has_ssubset (random_gen char)))) : rank_condition (distrib_lattice (has_ssubset (random_gen char))) := sorry --non-trivial
lemma new_lemma_171789 (h0 : topological_space (boolean_algebra.core (boolean_algebra linarith.comp))) : irreducible_space (boolean_algebra.core (boolean_algebra linarith.comp)) := sorry --non-trivial
lemma new_lemma_171790 (h0 : fin has_zero.zero) : @is_add_cyclic.{0} (has_bot.{0} linarith.comp) (@matrix.vec_empty.{0} (add_group.{0} (has_bot.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_171791 (h0 : group (cancel_monoid (comm_group (comm_group name)))) : group.fg (cancel_monoid (comm_group (comm_group name))) := sorry --non-trivial
lemma new_lemma_171792 (h0 : functor.add_const (topological_space (has_Inf linarith.comp)) Type) : @regular_space.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_Inf.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_171793 (h0 : topological_space (non_assoc_semiring (semiring (semiring (semiring unsigned))))) : discrete_topology (non_assoc_semiring (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_171794 (h0 : ring (has_inv (random_gen (has_add (has_ssubset string_imp))))) : rank_condition (has_inv (random_gen (has_add (has_ssubset string_imp)))) := sorry --non-trivial
lemma new_lemma_171795 (h0 : functor.add_const (topological_space (add_group empty)) num) : @t1_space.{0} (add_group.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_group.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_171796 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (comm_ring.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (comm_ring.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_171797 (h0 : function.extfun Type group) : @is_simple_group.{0} (has_bot.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (has_bot.{0} pos))  := sorry --non-trivial
lemma new_lemma_171798 (h2 : topological_space (with_zero fun_info)) : totally_disconnected_space (with_zero fun_info) := sorry --non-trivial
lemma new_lemma_171799 (h0 : functor.add_const (semiring (bin_tree unsigned)) congr_arg_kind) : @is_noetherian_ring.{0} (bin_tree.{0} unsigned) (@functor.add_const.run.{0 0} (semiring.{0} (bin_tree.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_171800 (h0 : group (has_zero (finset (has_neg linarith.comp)))) : is_cyclic (has_zero (finset (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_171801 (h0 : topological_space (has_to_string (has_pos_part linarith.comp))) : regular_space (has_to_string (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_171802 (h0 : topological_space (normed_field (has_nnnorm string.iterator_imp))) : totally_disconnected_space (normed_field (has_nnnorm string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_171803 (h0 : topological_space (has_nndist (semigroup ennreal))) : totally_disconnected_space (has_nndist (semigroup ennreal)) := sorry --non-trivial
lemma new_lemma_171804 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (with_bot.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (with_bot.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_171805 (h0 : functor.add_const (complete_lattice (boolean_algebra linarith.comp)) linarith.comp) : @is_compactly_generated.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (boolean_algebra.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_171806 (h0 : not (uniform_space (has_inv linarith.comp_source) -> false)) : @complete_space.{0} (has_inv.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_inv.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_171807 (h0 : functor.add_const (functor.add_const (complete_lattice (ring unsigned)) pos) Type) : @is_atomistic.{0} (ring.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ring.{0} unsigned)) pos (@functor.add_const.run.{0 1} (functor.add_const.{0 0} (complete_lattice.{0} (ring.{0} unsigned)) pos) Type h0))  := sorry --non-trivial
lemma new_lemma_171808 (h0 : functor.add_const (topological_space (add_comm_monoid Type)) pos) : @path_connected_space.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_comm_monoid.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_171809 (h0 : functor.add_const (function.extfun (Type 1) semiring) Type) : @is_noetherian_ring.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) semiring.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) semiring.{1}) Type h0) (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_171810 (h0 : function.extfun Type group) : @normalizer_condition.{0} (normed_group.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} h0 (normed_group.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_171811 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (normed_linear_ordered_group.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_linear_ordered_group.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_171812 (h0 : functor.add_const (topological_space (complete_distrib_lattice Type)) name) : @normal_space.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (complete_distrib_lattice.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_171813 (h0 : ring (complete_semilattice_Sup (semiring (semiring (semiring (semiring unsigned)))))) : is_domain (complete_semilattice_Sup (semiring (semiring (semiring (semiring unsigned))))) := sorry --non-trivial
lemma new_lemma_171814 (h1 : function.extfun (finset Type) (has_mem.mem num)) : @totally_separated_space.{0} num (@finset.pi.empty.{1 0} Type topological_space.{0} num (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) num) h1 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_171815 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (canonically_linear_ordered_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_linear_ordered_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_171816 (h0 : function.extfun (Type 1) list) : list.nodup (function.extfun_app h0 (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_171817 (h0 : topological_space (linear_ordered_comm_group_with_zero (has_nnnorm (has_nnnorm fun_info)))) : path_connected_space (linear_ordered_comm_group_with_zero (has_nnnorm (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_171818 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (ring.{0} (option.{0} pos)) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ring.{0} (option.{0} pos)))  := sorry --non-trivial
lemma new_lemma_171819 (h0 : group (preorder empty)) : is_cyclic (preorder empty) := sorry --non-trivial
lemma new_lemma_171820 (h0 : functor.add_const (semiring (has_neg Type)) (has_pos_part pos)) : @is_noetherian_ring.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (semiring.{1} (has_neg.{1} Type)) (has_pos_part.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_171821 (h0 : complete_lattice (with_bot (random_gen (random_gen string_imp)))) : complete_lattice.is_Sup_finite_compact (with_bot (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_171822 (h0 : functor.add_const (topological_space (has_inter num)) unsigned) : @normal_space.{0} (has_inter.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (has_inter.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_171823 (h0 : functor.add_const (topological_space (simple_graph linarith.comp)) pos) : @totally_disconnected_space.{0} (simple_graph.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (simple_graph.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_171824 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (simple_graph congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_171825 (h0 : fin has_zero.zero) : @unique_factorization_monoid.{0} (comm_semigroup.{0} real) (@matrix.vec_empty.{0} (cancel_comm_monoid_with_zero.{0} (comm_semigroup.{0} real)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_171826 (h0 : functor.add_const (ring (cancel_monoid Type)) Type) : @is_domain.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 1} (ring.{1} (cancel_monoid.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_171827 (h0 : functor.add_const (function.extfun (Type 1) group) Type) : @normalizer_condition.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) group.{1}) Type h0) (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_171828 (h0 : ring (has_to_string (has_neg (has_neg (has_add pos))))) : is_domain (has_to_string (has_neg (has_neg (has_add pos)))) := sorry --non-trivial
lemma new_lemma_171829 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (ring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ring.{0} name))  := sorry --non-trivial
lemma new_lemma_171830 (h0 : monoid (linear_ordered_semiring (random_gen (semiring empty)))) : monoid.fg (linear_ordered_semiring (random_gen (semiring empty))) := sorry --non-trivial
lemma new_lemma_171831 (h0 : fin has_zero.zero) : @normal_space.{0} (ordered_comm_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_monoid.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_171832 (h0 : function.extfun Type group) : @normalizer_condition.{0} (monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_171833 (h0 : topological_space (id (semiring unsigned))) : irreducible_space (id (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_171834 (h0 : topological_space (has_neg_part (has_neg_part pos))) : preconnected_space (has_neg_part (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_171835 (h0 : ring (metric_space (semiring num))) : rank_condition (metric_space (semiring num)) := sorry --non-trivial
lemma new_lemma_171836 (h0 : not (complete_lattice (has_union congr_arg_kind) -> false)) : @is_atomistic.{0} (has_union.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_union.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_171837 (h0 : topological_space (has_pos_part real)) : totally_separated_space (has_pos_part real) := sorry --non-trivial
lemma new_lemma_171838 (h0 : topological_space (normed_comm_ring (has_neg (has_neg linarith.comp)))) : sequential_space (normed_comm_ring (has_neg (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_171839 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} name (@function.extfun_app.{2 1} Type topological_space.{0} h0 name)  := sorry --non-trivial
lemma new_lemma_171840 (h3 : complete_lattice (distrib char)) : is_compactly_generated (distrib char) := sorry --non-trivial
lemma new_lemma_171841 (h0 h1 : multiset (semi_normed_ring (random_gen reducibility_hints))) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_171842 (h0 : function.extfun Type group) : @group.fg.{0} (linear_ordered_field.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} h0 (linear_ordered_field.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_171843 (h0 : functor.add_const (topological_space (simple_graph linarith.comp)) name) : @locally_compact_space.{0} (simple_graph.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (simple_graph.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_171844 (h0 : add_monoid (has_Sup (option unsigned))) : add_monoid.fg (has_Sup (option unsigned)) := sorry --non-trivial
lemma new_lemma_171845 (h0 : functor.add_const (complete_lattice (semiring unsigned)) num) : @is_compactly_generated.{0} (semiring.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (semiring.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_171846 (h3 : set (enat -> char)) : set.separates_points h3 := sorry --non-trivial
lemma new_lemma_171847 (h0 : group (has_nndist (option name))) : group.fg (has_nndist (option name)) := sorry --non-trivial
lemma new_lemma_171848 (h0 : cancel_comm_monoid_with_zero (ordered_comm_ring (has_Inf linarith.comp))) : unique_factorization_monoid (ordered_comm_ring (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_171849 (h0 : functor.add_const (function.extfun Type topological_space) (has_neg linarith.comp)) : @normal_space.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (has_neg.{0} linarith.comp) h0) (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_171850 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (has_star.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_star.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_171851 (h0 : function.extfun (Type 1) topological_space) : @totally_separated_space.{1} (ordered_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (ordered_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_171852 (h0 : has_mem.mem (measurable_space num) has_emptyc.emptyc) : @rank_condition.{0} (measurable_space.{0} num) (@finset.pi.empty.{1 0} Type ring.{0} (measurable_space.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_171853 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_dist.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_dist.{0} empty))  := sorry --non-trivial
lemma new_lemma_171854 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (ordered_comm_monoid.{0} (has_add.{0} linarith.comp)) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (ordered_comm_monoid.{0} (has_add.{0} linarith.comp)))  := sorry --non-trivial
lemma new_lemma_171855 (h0 : topological_space (semigroup (comm_group linarith.comp))) : locally_compact_space (semigroup (comm_group linarith.comp)) := sorry --non-trivial
lemma new_lemma_171856 (h0 : set (semi_normed_comm_ring fun_info)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_171857 (h1 : topological_space (has_emptyc (random_gen (random_gen (random_gen linarith.ineq))))) : totally_separated_space (has_emptyc (random_gen (random_gen (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_171858 (h0 : topological_space (linear_order (option unsigned))) : discrete_topology (linear_order (option unsigned)) := sorry --non-trivial
lemma new_lemma_171859 (h0 : complete_lattice (nondiscrete_normed_field (normed_field linarith.ineq))) : complete_lattice.is_Sup_finite_compact (nondiscrete_normed_field (normed_field linarith.ineq)) := sorry --non-trivial
lemma new_lemma_171860 (h0 : ring (add_cancel_monoid (add_comm_monoid unsigned))) : strong_rank_condition (add_cancel_monoid (add_comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_171861 (h0 : functor.add_const (function.extfun (Type 1) topological_space) Type) : @discrete_topology.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) Type h0) (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_171862 (h0 : topological_space (normed_comm_ring (comm_group (add_comm_monoid Type)))) : t1_space (normed_comm_ring (comm_group (add_comm_monoid Type))) := sorry --non-trivial
lemma new_lemma_171863 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (encodable string_imp)) := sorry --non-trivial
lemma new_lemma_171864 (h0 : canonically_linear_ordered_monoid unsigned -> semiring congr_arg_kind -> Prop) : relator.bi_total h0 := sorry --non-trivial
lemma new_lemma_171865 (h0 : topological_space (has_nndist num)) : loc_path_connected_space (has_nndist num) := sorry --non-trivial
lemma new_lemma_171866 (h2 : group (with_one string_imp)) : normalizer_condition (with_one string_imp) := sorry --non-trivial
lemma new_lemma_171867 (h0 : functor.add_const (uniform_space (is_R_or_C empty)) empty) : @separated_space.{0} (is_R_or_C.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (is_R_or_C.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_171868 (h0 : monoid (semigroup (has_neg (has_add (omega_complete_partial_order linarith.comp))))) : monoid.fg (semigroup (has_neg (has_add (omega_complete_partial_order linarith.comp)))) := sorry --non-trivial
lemma new_lemma_171869 (h0 : functor.add_const (group (has_neg linarith.comp)) pos) : @normalizer_condition.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (has_neg.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_171870 (h0 : functor.add_const (group (has_pos_part pos)) Type) : @group.fg.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (has_pos_part.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_171871 (h0 : topological_space (ring congr_arg_kind)) : irreducible_space (ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_171872 (h0 : group (canonically_ordered_monoid (has_neg (has_pos_part Type)))) : normalizer_condition (canonically_ordered_monoid (has_neg (has_pos_part Type))) := sorry --non-trivial
lemma new_lemma_171873 (h0 : functor.add_const (ring (has_Inf linarith.comp)) linarith.comp) : @strong_rank_condition.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_Inf.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_171874 (h0 : not (topological_space (linear_ordered_comm_ring unsigned) -> false)) : @irreducible_space.{0} (linear_ordered_comm_ring.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_comm_ring.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_171875 (h0 : ring (has_neg unsigned) -> ring (has_neg unsigned) -> Prop) : is_symm (ring (has_neg unsigned)) h0 := sorry --non-trivial
lemma new_lemma_171876 (h0 : not (topological_space (has_top linarith.comp_source) -> false)) : @path_connected_space.{0} (has_top.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (has_top.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_171877 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (has_star.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_star.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_171878 (h0 : functor.add_const (topological_space (has_add environment.implicit_infer_kind)) Type) : @preconnected_space.{0} (has_add.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (has_add.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_171879 (h0 : group (canonically_ordered_comm_semiring (has_add Type))) : normalizer_condition (canonically_ordered_comm_semiring (has_add Type)) := sorry --non-trivial
lemma new_lemma_171880 (h0 : group (pseudo_metric_space (finset ennreal))) : is_simple_group (pseudo_metric_space (finset ennreal)) := sorry --non-trivial
lemma new_lemma_171881 (h0 : group (has_append linarith.comp_source)) : is_cyclic (has_append linarith.comp_source) := sorry --non-trivial
lemma new_lemma_171882 (h0 : list (boolean_algebra.core (option (option (option unsigned))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_171883 (h0 : add_group (with_one (div_inv_monoid fun_info))) : is_add_cyclic (with_one (div_inv_monoid fun_info)) := sorry --non-trivial
lemma new_lemma_171884 (h0 : set (add_comm_semigroup (add_cancel_monoid ereal) -> char)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_171885 (h0 : ring (normed_field (mul_one_class string.iterator_imp))) : strong_rank_condition (normed_field (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_171886 (h0 : list (semigroup (semiring empty))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_171887 (h1 : add_group (has_append fun_info)) : is_add_cyclic (has_append fun_info) := sorry --non-trivial
lemma new_lemma_171888 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (pseudo_metric_space.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (pseudo_metric_space.{0} num))  := sorry --non-trivial
lemma new_lemma_171889 (h0 : add_monoid (ordered_comm_monoid name)) : add_monoid.fg (ordered_comm_monoid name) := sorry --non-trivial
lemma new_lemma_171890 (h0 : ring (id (random_gen (random_gen fun_info)))) : is_domain (id (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_171891 (h0 : add_group (has_add (ring linarith.comp))) : is_add_cyclic (has_add (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_171892 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (finset.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (finset.{0} empty))  := sorry --non-trivial
lemma new_lemma_171893 (h0 : list (encodable (random_gen linarith.comp_source))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_171894 (h0 : complete_lattice (id (semiring num))) : is_atomistic (id (semiring num)) := sorry --non-trivial
lemma new_lemma_171895 (h0 : functor.add_const (topological_space (mul_zero_class name)) name) : @t0_space.{0} (mul_zero_class.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_171896 (h0 : prod znum znum) : id_rel h0 := sorry --non-trivial
lemma new_lemma_171897 (h0 : uniform_space (add_cancel_monoid (mul_one_class environment.implicit_infer_kind))) : separated_space (add_cancel_monoid (mul_one_class environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_171898 (h0 : functor.add_const (topological_space (ring Type)) (has_pos_part linarith.comp)) : @sequential_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ring.{1} Type)) (has_pos_part.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_171899 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (add_comm_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_171900 (h0 : ring (has_bot (option (option (option unsigned))))) : strong_rank_condition (has_bot (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_171901 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (distrib_lattice.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (distrib_lattice.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_171902 (h0 : function.extfun Type (functor.add_const (ring (monoid empty)))) : @is_domain.{0} (monoid.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (monoid.{0} empty)) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} (monoid.{0} empty))) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_171903 (h0 : fin has_zero.zero) : @monoid.fg.{0} (sub_neg_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (monoid.{0} (sub_neg_monoid.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_171904 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (linear_ordered_field.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_field.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_171905 (h0 : function.extfun Type ring) : @is_domain.{0} (boolean_algebra.core.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (boolean_algebra.core.{0} pos))  := sorry --non-trivial
lemma new_lemma_171906 (h0 : topological_space (ring (normed_comm_ring name))) : normal_space (ring (normed_comm_ring name)) := sorry --non-trivial
lemma new_lemma_171907 (h0 : semiring (ordered_ring congr_arg_kind)) : is_noetherian_ring (ordered_ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_171908 (h0 : topological_space (normed_comm_ring (finset environment.implicit_infer_kind))) : t0_space (normed_comm_ring (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_171909 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (option.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (option.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_171910 (h0 : uniform_space (has_add Type)) : separated_space (has_add Type) := sorry --non-trivial
lemma new_lemma_171911 (h0 : topological_space (has_div (has_ssubset string_imp))) : totally_disconnected_space (has_div (has_ssubset string_imp)) := sorry --non-trivial
lemma new_lemma_171912 (h0 : functor.add_const (function.extfun (Type 1) ordered_add_comm_monoid) (ring pos)) : @archimedean.{1} (comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_add_comm_monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ordered_add_comm_monoid.{1}) (ring.{0} pos) h0) (comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_171913 (h0 : list (finset (finset Type))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_171914 (h0 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} (has_top.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h0) (has_top.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_171915 (h0 : group (has_neg_part (comm_group unsigned))) : is_cyclic (has_neg_part (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_171916 (h0 : functor.add_const (uniform_space (has_to_string environment.implicit_infer_kind)) environment.implicit_infer_kind) : @complete_space.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_to_string.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_171917 (h0 : not (ring (normed_field string_imp) -> false)) : @rank_condition.{0} (normed_field.{0} string_imp) (@classical.by_contradiction'.{1} (ring.{0} (normed_field.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_171918 (h0 : uniform_space (has_Inf (has_Inf Type))) : separated_space (has_Inf (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_171919 (h0 : group (canonically_ordered_comm_semiring (option (option pos)))) : is_cyclic (canonically_ordered_comm_semiring (option (option pos))) := sorry --non-trivial
lemma new_lemma_171920 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @sequential_space.{0} (boolean_algebra.core.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.core.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_171921 (h0 : add_monoid (normed_comm_ring (comm_group Type))) : add_monoid.fg (normed_comm_ring (comm_group Type)) := sorry --non-trivial
lemma new_lemma_171922 (h0 : ring (comm_ring linarith.comp_source)) : strong_rank_condition (comm_ring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_171923 (h3 : complete_lattice (semi_normed_ring to_additive.value_type)) : is_compactly_generated (semi_normed_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_171924 (h4 : ring (normed_field to_additive.value_type)) : rank_condition (normed_field to_additive.value_type) := sorry --non-trivial
lemma new_lemma_171925 (h0 : topological_space (measure_theory.measure_space empty)) : t0_space (measure_theory.measure_space empty) := sorry --non-trivial
lemma new_lemma_171926 (h0 : functor.add_const (function.extfun (Type 1) ring) pos) : @is_domain.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ring.{1}) pos h0) (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_171927 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_add.{0} ennreal) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_add.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_171928 (h0 : metric_space (canonically_ordered_monoid num)) (h1 : set (canonically_ordered_monoid num)) : euclidean_geometry.cospherical h1 := sorry --non-trivial
lemma new_lemma_171929 (h0 : fin has_zero.zero) : @complete_lattice.is_Sup_finite_compact.{0} (comm_semigroup.{0} name) (@matrix.vec_empty.{0} (complete_lattice.{0} (comm_semigroup.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_171930 (h0 : topological_space (comm_semigroup (sub_neg_monoid real))) : preirreducible_space (comm_semigroup (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_171931 (h0 : functor.add_const (topological_space (cancel_monoid linarith.comp)) linarith.comp) : @loc_path_connected_space.{0} (cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_171932 (h0 : functor.add_const (filter (has_nndist linarith.comp)) linarith.comp) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_171933 (h0 : topological_space (linear_order unsigned)) : totally_disconnected_space (linear_order unsigned) := sorry --non-trivial
lemma new_lemma_171934 (h0 : ring (add_cancel_comm_monoid (has_nnnorm char))) : rank_condition (add_cancel_comm_monoid (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_171935 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (normed_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_171936 (h0 : topological_space (random_gen (has_norm linarith.comp))) : totally_disconnected_space (random_gen (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_171937 (h0 : ring (measure_theory.measure_space unsigned)) : strong_rank_condition (measure_theory.measure_space unsigned) := sorry --non-trivial
lemma new_lemma_171938 (h0 : topological_space (linear_ordered_semiring empty)) : discrete_topology (linear_ordered_semiring empty) := sorry --non-trivial
lemma new_lemma_171939 (h0 : add_monoid (semigroup (finset pos))) : add_monoid.fg (semigroup (finset pos)) := sorry --non-trivial
lemma new_lemma_171940 (h0 : functor.add_const (filter Type) linarith.comp) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_171941 (h0 : add_group (random_gen to_additive.value_type)) : is_add_cyclic (random_gen to_additive.value_type) := sorry --non-trivial
lemma new_lemma_171942 (h0 : function.extfun Type topological_space) : @t0_space.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_171943 (h0 : topological_space (has_norm (random_gen (random_gen num)))) : totally_separated_space (has_norm (random_gen (random_gen num))) := sorry --non-trivial
lemma new_lemma_171944 (h0 : fin has_zero.zero) : @regular_space.{0} (canonically_linear_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (canonically_linear_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_171945 (h0 : function.extfun Type ring) : @is_domain.{0} (has_inv.{0} (random_gen.{0} to_additive.value_type)) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_inv.{0} (random_gen.{0} to_additive.value_type)))  := sorry --non-trivial
lemma new_lemma_171946 (h0 : group (boolean_algebra.core (has_add name))) : is_cyclic (boolean_algebra.core (has_add name)) := sorry --non-trivial
lemma new_lemma_171947 (h0 : functor.add_const (function.extfun Type ring) Type) : @is_domain.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ring.{0}) Type h0) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_171948 (h0 : ordered_add_comm_monoid (mul_zero_class (option (option (option (option pos)))))) : archimedean (mul_zero_class (option (option (option (option pos))))) := sorry --non-trivial
lemma new_lemma_171949 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (complete_distrib_lattice.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (complete_distrib_lattice.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_171950 (h0 : list (has_norm (random_gen (random_gen to_additive.value_type)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_171951 (h0 : filter empty) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_171952 (h0 : topological_space (boolean_algebra.core (boolean_algebra name))) : preconnected_space (boolean_algebra.core (boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_171953 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (partial_order.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (partial_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_171954 (h0 : functor.add_const (uniform_space (ring linarith.comp)) (ring Type)) : @separated_space.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (uniform_space.{0} (ring.{0} linarith.comp)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_171955 (h0 : fin has_zero.zero) : @is_simple_group.{0} (has_to_string.{0} pos) (@matrix.vec_empty.{0} (group.{0} (has_to_string.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_171956 (h0 : topological_space (has_lt (mul_one_class char))) : t0_space (has_lt (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_171957 (h0 : topological_space (comm_semigroup Type)) : normal_space (comm_semigroup Type) := sorry --non-trivial
lemma new_lemma_171958 (h0 : topological_space (comm_group (option (option (option pos))))) : irreducible_space (comm_group (option (option (option pos)))) := sorry --non-trivial
lemma new_lemma_171959 (h0 h1 : Prop) : implies h0 h1 := sorry --non-trivial
lemma new_lemma_171960 (h0 : ordered_comm_monoid (comm_group (option pos))) : has_exists_mul_of_le (comm_group (option pos)) := sorry --non-trivial
lemma new_lemma_171961 (h0 : functor.add_const (function.extfun Type group) linarith.comp) : @group.fg.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) linarith.comp h0) (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_171962 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (non_assoc_semiring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (non_assoc_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_171963 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (boolean_algebra.core.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} empty))  := sorry --non-trivial
lemma new_lemma_171964 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (linear_ordered_comm_group.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_group.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_171965 (h0 : topological_space (left_cancel_monoid (semiring empty))) : discrete_topology (left_cancel_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_171966 (h0 : group (has_union (semiring num))) : group.fg (has_union (semiring num)) := sorry --non-trivial
lemma new_lemma_171967 (h0 : measurable_space (has_norm string_imp)) (h1 : has_add (has_norm string_imp)) : has_measurable_add (has_norm string_imp) := sorry --non-trivial
lemma new_lemma_171968 (h0 : topological_space (has_bot (has_Inf Type))) : loc_path_connected_space (has_bot (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_171969 (h0 : monoid (boolean_algebra.core (add_comm_monoid (has_nndist (has_add Type))))) : monoid.fg (boolean_algebra.core (add_comm_monoid (has_nndist (has_add Type)))) := sorry --non-trivial
lemma new_lemma_171970 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (with_one.{0} string_imp) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 add_group.{0}) (with_one.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_171971 (h0 : topological_space (partial_order (semiring (semiring congr_arg_kind)))) : locally_compact_space (partial_order (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_171972 (h0 : functor.add_const (ordered_add_comm_monoid (ring Type)) (has_neg Type)) : @archimedean.{1} (ring.{1} Type) (@functor.add_const.run.{1 1} (ordered_add_comm_monoid.{1} (ring.{1} Type)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_171973 (h0 : fin has_zero.zero) : @sequential_space.{0} (add_comm_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (add_comm_monoid.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_171974 (h1 : not (topological_space fun_info -> false)) : @totally_disconnected_space.{0} fun_info (@classical.by_contradiction'.{1} (topological_space.{0} fun_info) h1)  := sorry --non-trivial
lemma new_lemma_171975 (h0 : functor.add_const (complete_lattice (ring environment.implicit_infer_kind)) name) : @is_atomistic.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ring.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_171976 (h0 : functor.add_const (group (semigroup linarith.comp)) (has_Inf pos)) : @group.fg.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (semigroup.{0} linarith.comp)) (has_Inf.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_171977 (h0 : topological_space (id linarith.comp_source)) : t0_space (id linarith.comp_source) := sorry --non-trivial
lemma new_lemma_171978 (h0 : functor.add_const (group (canonically_ordered_add_monoid unsigned)) num) : @is_cyclic.{0} (canonically_ordered_add_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (canonically_ordered_add_monoid.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_171979 (h0 : functor.add_const (ring (has_add linarith.comp)) (ring linarith.comp)) : @is_principal_ideal_ring.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_add.{0} linarith.comp)) (ring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_171980 (h0 : functor.add_const (filter (pseudo_metric_space pos)) (option (option unsigned))) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_171981 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_top.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_top.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_171982 (h0 : topological_space (semigroup (has_to_string pos))) : preirreducible_space (semigroup (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_171983 (h1 : add_group (topological_space fun_info)) : is_add_cyclic (topological_space fun_info) := sorry --non-trivial
lemma new_lemma_171984 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (linear_ordered_add_comm_group.{0} char) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_add_comm_group.{0} char))  := sorry --non-trivial
lemma new_lemma_171985 (h1 : not (topological_space (semi_normed_ring string_imp) -> false)) : @t0_space.{0} (semi_normed_ring.{0} string_imp) (@classical.by_contradiction'.{1} (topological_space.{0} (semi_normed_ring.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_171986 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (ordered_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (ordered_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_171987 (h0 : functor.add_const (filter (canonically_linear_ordered_monoid unsigned)) pos) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_171988 (h0 : complete_lattice (has_nndist (mul_zero_class (has_neg_part ennreal)))) : complete_lattice.is_Sup_finite_compact (has_nndist (mul_zero_class (has_neg_part ennreal))) := sorry --non-trivial
lemma new_lemma_171989 (h0 : complete_lattice (has_top (has_top to_additive.value_type))) : is_atomistic (has_top (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_171990 (h0 : ring (with_bot (random_gen (random_gen (random_gen (random_gen linarith.ineq)))))) : is_domain (with_bot (random_gen (random_gen (random_gen (random_gen linarith.ineq))))) := sorry --non-trivial
lemma new_lemma_171991 (h0 : functor.add_const (semiring (has_neg name)) ennreal) : @is_noetherian_ring.{0} (has_neg.{0} name) (@functor.add_const.run.{0 0} (semiring.{0} (has_neg.{0} name)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_171992 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (simple_graph.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (simple_graph.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_171993 (h0 : topological_space (generalized_boolean_algebra (ring (ring pos)))) : locally_compact_space (generalized_boolean_algebra (ring (ring pos))) := sorry --non-trivial
lemma new_lemma_171994 (h1 : ring (metric_space to_additive.value_type)) : is_domain (metric_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_171995 (h2 : complete_lattice (nondiscrete_normed_field linarith.ineq)) : complete_lattice.is_Sup_finite_compact (nondiscrete_normed_field linarith.ineq) := sorry --non-trivial
lemma new_lemma_171996 (h0 : complete_lattice (with_bot (semiring fun_info))) : is_atomistic (with_bot (semiring fun_info)) := sorry --non-trivial
lemma new_lemma_171997 (h0 : not (filter (with_zero fun_info) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_171998 (h0 : fin has_zero.zero) : @unique_factorization_monoid.{0} (simple_graph.{0} pos) (@matrix.vec_empty.{0} (cancel_comm_monoid_with_zero.{0} (simple_graph.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_171999 (h0 : has_lt (distrib enat)) : no_max_order (distrib enat) := sorry --non-trivial
lemma new_lemma_172000 (h1 : complete_lattice (linear_ordered_add_comm_group linarith.ineq)) : complete_lattice.is_Sup_finite_compact (linear_ordered_add_comm_group linarith.ineq) := sorry --non-trivial
lemma new_lemma_172001 (h0 : topological_space (has_union congr_arg_kind)) : locally_compact_space (has_union congr_arg_kind) := sorry --non-trivial
lemma new_lemma_172002 (h0 : functor.add_const (topological_space (left_cancel_monoid unsigned)) congr_arg_kind) : @topological_space.separable_space.{0} (left_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_172003 (h0 : monoid (linear_ordered_semiring (has_top unsigned))) : monoid.fg (linear_ordered_semiring (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_172004 (h0 : functor.add_const (topological_space (comm_group linarith.comp)) pos) : @preirreducible_space.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_172005 (h1 : has_mem.mem topological_space has_emptyc.emptyc) : @path_connected_space.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h1) (complete_semilattice_Sup.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_172006 (h0 : topological_space (finset (has_add pos))) : irreducible_space (finset (has_add pos)) := sorry --non-trivial
lemma new_lemma_172007 (h0 : functor.add_const (group (has_to_string pos)) environment.implicit_infer_kind) : @is_cyclic.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_to_string.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_172008 (h0 : not (complete_lattice (has_nnnorm reducibility_hints) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_nnnorm.{0} reducibility_hints) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_nnnorm.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_172009 (h0 : not (topological_space (has_ssubset (random_gen reducibility_hints)) -> false)) : @t0_space.{0} (has_ssubset.{0} (random_gen.{0} reducibility_hints)) (@classical.by_contradiction'.{1} (topological_space.{0} (has_ssubset.{0} (random_gen.{0} reducibility_hints))) h0)  := sorry --non-trivial
lemma new_lemma_172010 (h0 : topological_space (add_cancel_monoid environment.implicit_infer_kind)) : discrete_topology (add_cancel_monoid environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_172011 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (ring.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_172012 (h0 : topological_space (semigroup (option (option congr_arg_kind)))) : t1_space (semigroup (option (option congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_172013 (h0 : topological_space (complete_distrib_lattice (has_add name))) : discrete_topology (complete_distrib_lattice (has_add name)) := sorry --non-trivial
lemma new_lemma_172014 (h0 : ring (semi_normed_ring (mul_one_class (random_gen string_imp)))) : strong_rank_condition (semi_normed_ring (mul_one_class (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_172015 (h0 : function.extfun (finset Type) (has_mem.mem string_imp)) : @is_cyclic.{0} string_imp (@finset.pi.empty.{1 0} Type group.{0} string_imp (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) string_imp) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_172016 (h0 : topological_space (measurable_space (has_norm congr_arg_kind))) : path_connected_space (measurable_space (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_172017 (h0 : topological_space (has_Inf (has_Inf pos))) : discrete_topology (has_Inf (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_172018 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (canonically_linear_ordered_monoid.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (canonically_linear_ordered_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_172019 (h0 : group (ordered_comm_monoid (sub_neg_monoid Type))) : normalizer_condition (ordered_comm_monoid (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_172020 (h0 : monoid (ordered_cancel_add_comm_monoid (option unsigned))) : monoid.fg (ordered_cancel_add_comm_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_172021 (h0 : functor.add_const (complete_lattice (partial_order num)) empty) : @complete_lattice.is_Sup_finite_compact.{0} (partial_order.{0} num) (@functor.add_const.run.{0 0} (complete_lattice.{0} (partial_order.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_172022 (h0 : complete_lattice (has_add (ring (has_add linarith.comp)))) : is_compactly_generated (has_add (ring (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_172023 (h0 : functor.comp ring has_zero (finset name)) : @rank_condition.{0} (has_zero.{0} (finset.{0} name)) (@functor.comp.run.{0 0 0} ring.{0} has_zero.{0} (finset.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_172024 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (has_union.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_union.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_172025 (h0 : topological_space (has_to_string ennreal)) : preconnected_space (has_to_string ennreal) := sorry --non-trivial
lemma new_lemma_172026 (h0 : group (has_nnnorm (random_gen (random_gen to_additive.value_type)))) : group.fg (has_nnnorm (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_172027 (h0 : group (complete_linear_order (semiring unsigned))) : is_cyclic (complete_linear_order (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_172028 (h0 : function.extfun nat fin) : @is_domain.{1} (has_add.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (has_add.{1} Type)) (@function.extfun_app.{1 1} nat fin (@matrix.vec_empty.{0} (function.extfun.{1 1} nat fin) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_172029 (h0 : function.extfun nat fin) : @locally_compact_space.{0} (has_add.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (has_add.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_172030 (h0 : group (cancel_monoid (normed_comm_ring (has_add Type)))) : group.fg (cancel_monoid (normed_comm_ring (has_add Type))) := sorry --non-trivial
lemma new_lemma_172031 (h0 : topological_space (bin_tree (ordered_cancel_comm_monoid (ordered_cancel_comm_monoid num)))) : t1_space (bin_tree (ordered_cancel_comm_monoid (ordered_cancel_comm_monoid num))) := sorry --non-trivial
lemma new_lemma_172032 (h0 : not (topological_space (measurable_space.dynkin_system linarith.comp) -> false)) : @t0_space.{0} (measurable_space.dynkin_system.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (measurable_space.dynkin_system.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_172033 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (ring.{0} (option.{0} ennreal)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} (option.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_172034 (h0 : ring (boolean_algebra.core (has_neg_part Type))) : rank_condition (boolean_algebra.core (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_172035 (h1 : topological_space (topological_space linarith.comp_source)) : path_connected_space (topological_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_172036 (h0 : functor.add_const (topological_space (has_zero Type)) environment.implicit_infer_kind) : @t1_space.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_zero.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_172037 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (generalized_boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (generalized_boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_172038 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (group_with_zero.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (group_with_zero.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_172039 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (add_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (add_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_172040 (h0 : function.extfun Type topological_space) : @t1_space.{0} (finset.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_172041 (h0 : functor.add_const (complete_lattice (canonically_ordered_comm_semiring environment.implicit_infer_kind)) ennreal) : @is_compactly_generated.{0} (canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_172042 (h0 : measurable_space ordering) (h1 : measure_theory.measure ordering) : measure_theory.is_finite_measure h1 := sorry --non-trivial
lemma new_lemma_172043 (h0 : topological_space (linear_ordered_add_comm_group (has_nnnorm fun_info))) : path_connected_space (linear_ordered_add_comm_group (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_172044 (h0 : topological_space (has_top (has_norm (semiring (random_gen congr_arg_kind))))) : discrete_topology (has_top (has_norm (semiring (random_gen congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_172045 (h0 : topological_space (comm_semigroup (comm_semigroup (has_add real)))) : t1_space (comm_semigroup (comm_semigroup (has_add real))) := sorry --non-trivial
lemma new_lemma_172046 (h0 : not (topological_space (has_add fun_info) -> false)) : @t0_space.{0} (has_add.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (has_add.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_172047 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : normal_space real := sorry --non-trivial
lemma new_lemma_172048 (h0 : not (ring (uniform_space to_additive.value_type) -> false)) : @rank_condition.{0} (uniform_space.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (uniform_space.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_172049 (h0 : topological_space (has_ssubset (has_top fun_info))) : totally_disconnected_space (has_ssubset (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_172050 (h0 : group (linear_ordered_add_comm_group fun_info)) : is_cyclic (linear_ordered_add_comm_group fun_info) := sorry --non-trivial
lemma new_lemma_172051 (h0 : functor.add_const (group (has_zero name)) environment.implicit_infer_kind) : @group.fg.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (group.{0} (has_zero.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_172052 (h0 : topological_space (boolean_algebra (normed_comm_ring name))) : topological_space.separable_space (boolean_algebra (normed_comm_ring name)) := sorry --non-trivial
lemma new_lemma_172053 (h0 : not (function.extfun Type group -> false)) : @group.fg.{0} (has_compl.{0} char) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (has_compl.{0} char))  := sorry --non-trivial
lemma new_lemma_172054 (h0 : complete_lattice (partial_order empty)) : is_atomistic (partial_order empty) := sorry --non-trivial
lemma new_lemma_172055 (h0 : topological_space (has_norm (has_norm (semiring linarith.comp)))) : path_connected_space (has_norm (has_norm (semiring linarith.comp))) := sorry --non-trivial
lemma new_lemma_172056 (h0 : semiring (comm_monoid empty)) : is_noetherian_ring (comm_monoid empty) := sorry --non-trivial
lemma new_lemma_172057 (h0 : list (has_inv (has_ssubset (has_ssubset fun_info)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_172058 (h0 : measurable_space reducibility_hints) (h1 : filter reducibility_hints) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_172059 (h0 : topological_space (add_comm_monoid (option unsigned))) : locally_compact_space (add_comm_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_172060 (h0 : set (nondiscrete_normed_field (normed_field reducibility_hints))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_172061 (h0 : complete_lattice (normed_group (has_inv to_additive.value_type))) : is_atomistic (normed_group (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_172062 (h0 : topological_space (add_right_cancel_monoid (semiring empty))) : discrete_topology (add_right_cancel_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_172063 (h0 : functor.add_const (complete_lattice (comm_group linarith.comp)) name) : @is_compactly_generated.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (comm_group.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_172064 (h0 : topological_space (has_one (semiring (semiring (semiring num))))) : totally_separated_space (has_one (semiring (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_172065 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (has_norm.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_norm.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_172066 (h0 : complete_lattice (has_to_string (option (option name)))) : is_compactly_generated (has_to_string (option (option name))) := sorry --non-trivial
lemma new_lemma_172067 (h0 : topological_space (pseudo_metric_space (option (option unsigned)))) : irreducible_space (pseudo_metric_space (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_172068 (h0 : topological_space (add_group empty)) : path_connected_space (add_group empty) := sorry --non-trivial
lemma new_lemma_172069 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (boolean_algebra.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_172070 (h0 : ring (uniform_space (has_append (metric_space char)))) : is_domain (uniform_space (has_append (metric_space char))) := sorry --non-trivial
lemma new_lemma_172071 (h0 : functor.add_const (functor.add_const (topological_space linarith.comp) name) pos) : @sequential_space.{0} linarith.comp (@functor.add_const.run.{0 0} (topological_space.{0} linarith.comp) name (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (topological_space.{0} linarith.comp) name) pos h0))  := sorry --non-trivial
lemma new_lemma_172072 (h0 : function.extfun Type (prod (id unsigned))) : id_rel (function.extfun_app h0 (id unsigned)) := sorry --non-trivial
lemma new_lemma_172073 (h0 : ring (has_pos_part (has_Inf (has_add (has_add (has_Inf real)))))) : is_domain (has_pos_part (has_Inf (has_add (has_add (has_Inf real))))) := sorry --non-trivial
lemma new_lemma_172074 (h0 : functor.add_const (add_monoid (has_nndist unsigned)) empty) : @add_monoid.fg.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_nndist.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_172075 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (complete_distrib_lattice empty)) := sorry --non-trivial
lemma new_lemma_172076 (h0 : uniform_space (measurable_space.dynkin_system (normed_linear_ordered_group unsigned))) : complete_space (measurable_space.dynkin_system (normed_linear_ordered_group unsigned)) := sorry --non-trivial
lemma new_lemma_172077 (h0 : not (function.extfun Type ring -> false)) : @strong_rank_condition.{0} (has_one.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (has_one.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_172078 (h0 : functor.add_const (topological_space (normed_comm_ring pos)) Type) : @preirreducible_space.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (normed_comm_ring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_172079 (h0 : topological_space (plift (option (semiring num)))) : topological_space.separable_space (plift (option (semiring num))) := sorry --non-trivial
lemma new_lemma_172080 (h0 : topological_space (option (measurable_space.dynkin_system pos))) : topological_space.separable_space (option (measurable_space.dynkin_system pos)) := sorry --non-trivial
lemma new_lemma_172081 (h0 : functor.add_const (ring (canonically_ordered_comm_semiring pos)) pos) : @strong_rank_condition.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (canonically_ordered_comm_semiring.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_172082 (h0 : add_monoid (normed_group (semiring (semiring (semiring (semiring (semiring congr_arg_kind))))))) : add_monoid.fg (normed_group (semiring (semiring (semiring (semiring (semiring congr_arg_kind)))))) := sorry --non-trivial
lemma new_lemma_172083 (h0 : uniform_space (has_nndist (option (option (option ennreal))))) : separated_space (has_nndist (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_172084 (h0 : function.extfun Type (functor.add_const (topological_space (ring pos)))) : @t0_space.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} pos)) (has_neg.{0} pos) (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (ring.{0} pos))) h0 (has_neg.{0} pos)))  := sorry --non-trivial
lemma new_lemma_172085 (h0 : topological_space (normed_group (has_top fun_info))) : totally_separated_space (normed_group (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_172086 (h0 : topological_space (sub_neg_monoid (has_add linarith.comp))) : preirreducible_space (sub_neg_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_172087 (h1 : topological_space (measurable_space string_imp)) : locally_compact_space (measurable_space string_imp) := sorry --non-trivial
lemma new_lemma_172088 (h0 : uniform_space (add_comm_monoid empty)) : complete_space (add_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_172089 (h0 : topological_space (has_norm (has_norm (distrib_lattice fun_info)))) : totally_separated_space (has_norm (has_norm (distrib_lattice fun_info))) := sorry --non-trivial
lemma new_lemma_172090 (h0 : monoid (measurable_space (has_inv to_additive.value_type))) : monoid.fg (measurable_space (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_172091 (h0 : topological_space (ring (has_neg_part pos))) : preirreducible_space (ring (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_172092 (h0 : filter (add_left_cancel_monoid (random_gen (random_gen char)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_172093 (h0 : group (uniform_space (has_nnnorm reducibility_hints))) : is_cyclic (uniform_space (has_nnnorm reducibility_hints)) := sorry --non-trivial
lemma new_lemma_172094 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (pseudo_metric_space.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (pseudo_metric_space.{0} pos))  := sorry --non-trivial
lemma new_lemma_172095 (h2 : set (mul_one_class (mul_one_class linarith.ineq))) : set.finite h2 := sorry --non-trivial
lemma new_lemma_172096 (h2 : has_mem.mem group has_emptyc.emptyc) : @is_cyclic.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} h2) (complete_semilattice_Sup.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_172097 (h0 : uniform_space (has_norm (with_bot (with_bot to_additive.value_type)))) : complete_space (has_norm (with_bot (with_bot to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_172098 (h0 : group (has_add (finset (boolean_algebra (ring linarith.comp))))) : normalizer_condition (has_add (finset (boolean_algebra (ring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_172099 (h0 : ring (measurable_space (semiring (semiring linarith.comp)))) : rank_condition (measurable_space (semiring (semiring linarith.comp))) := sorry --non-trivial
lemma new_lemma_172100 (h0 : functor.add_const (topological_space (add_group empty)) empty) : @irreducible_space.{0} (add_group.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_group.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_172101 (h1 : function.extfun Type ring) : @rank_condition.{0} (has_emptyc.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h1 (has_emptyc.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_172102 (h0 : semiring (normed_lattice_add_comm_group (has_Inf real))) : is_noetherian_ring (normed_lattice_add_comm_group (has_Inf real)) := sorry --non-trivial
lemma new_lemma_172103 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @regular_space.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_172104 (h0 : topological_space (has_zero (has_to_string Type))) : totally_disconnected_space (has_zero (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_172105 (h0 : finset (has_to_string (boolean_algebra.core name))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_172106 (h0 : topological_space (has_add (normed_comm_ring (finset name)))) : sequential_space (has_add (normed_comm_ring (finset name))) := sorry --non-trivial
lemma new_lemma_172107 (h1 : topological_space (id unsigned)) : t0_space (id unsigned) := sorry --non-trivial
lemma new_lemma_172108 (h0 : functor.add_const (ordered_comm_monoid (has_neg name)) pos) : @has_exists_mul_of_le.{0} (has_neg.{0} name) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_neg.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_172109 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (finset name)) := sorry --non-trivial
lemma new_lemma_172110 (h0 : fin has_zero.zero) : @is_principal_ideal_ring.{0} (ordered_comm_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (ring.{0} (ordered_comm_monoid.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_172111 (h0 : topological_space (normed_group (random_gen linarith.comp_source))) : path_connected_space (normed_group (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_172112 (h0 : add_comm_monoid (has_to_string congr_arg_kind) -> add_comm_monoid (has_to_string congr_arg_kind) -> Prop) : is_symm (add_comm_monoid (has_to_string congr_arg_kind)) h0 := sorry --non-trivial
lemma new_lemma_172113 (h0 : ring (distrib string_imp)) : is_domain (distrib string_imp) := sorry --non-trivial
lemma new_lemma_172114 (h0 : add_monoid (has_Inf (has_neg (ring (has_add name))))) : add_monoid.fg (has_Inf (has_neg (ring (has_add name)))) := sorry --non-trivial
lemma new_lemma_172115 (h0 : topological_space (has_inv (has_top to_additive.value_type))) : t0_space (has_inv (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_172116 (h0 : filter (mul_zero_class (option (mul_zero_class name)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_172117 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (left_cancel_semigroup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (left_cancel_semigroup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_172118 (h0 : functor.comp complete_lattice boolean_algebra name) : @complete_lattice.is_Sup_finite_compact.{0} (boolean_algebra.{0} name) (@functor.comp.run.{0 0 0} complete_lattice.{0} boolean_algebra.{0} name h0)  := sorry --non-trivial
lemma new_lemma_172119 (h0 : functor.comp topological_space has_add pos) : @t0_space.{0} (has_add.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} has_add.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_172120 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (ordered_ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_172121 (h0 : group (normed_group (semiring congr_arg_kind))) : is_cyclic (normed_group (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_172122 (h0 : group (measurable_space (random_gen fun_info))) : group.fg (measurable_space (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_172123 (h1 : complete_lattice (encodable char)) : complete_lattice.is_Sup_finite_compact (encodable char) := sorry --non-trivial
lemma new_lemma_172124 (h0 : topological_space (has_zero (finset ennreal))) : t1_space (has_zero (finset ennreal)) := sorry --non-trivial
lemma new_lemma_172125 (h0 : list (has_top (has_ssubset (random_gen fun_info)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_172126 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (has_bot.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_bot.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_172127 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (cancel_monoid ennreal)) := sorry --non-trivial
lemma new_lemma_172128 (h0 : group (metric_space (has_top (has_norm (semiring linarith.comp))))) : group.fg (metric_space (has_top (has_norm (semiring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_172129 (h0 : uniform_space (has_add (finset pos))) : separated_space (has_add (finset pos)) := sorry --non-trivial
lemma new_lemma_172130 (h0 : group (has_ssubset (has_nnnorm (has_nnnorm linarith.ineq)))) : is_cyclic (has_ssubset (has_nnnorm (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_172131 (h0 : set (add_comm_semigroup fun_info -> fun_info)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_172132 (h0 : complete_lattice (linear_ordered_add_comm_group (random_gen linarith.ineq))) : is_compactly_generated (linear_ordered_add_comm_group (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_172133 (h0 : list (monoid pos)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_172134 (h0 : has_coe environment.projection_info Prop) (h1 : environment.projection_info) : @coe_b.{1 1} environment.projection_info Prop h0 h1  := sorry --non-trivial
lemma new_lemma_172135 (h0 : function.extfun Type (functor.comp filter has_zero)) : countable_Inter_filter (functor.comp.run (function.extfun_app h0 pos)) := sorry --non-trivial
lemma new_lemma_172136 (h0 : uniform_space (has_sub (semiring unsigned))) : separated_space (has_sub (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_172137 (h0 : complete_lattice (normed_field string_imp)) : complete_lattice.is_Sup_finite_compact (normed_field string_imp) := sorry --non-trivial
lemma new_lemma_172138 (h0 : function.extfun Type topological_space) : @t1_space.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_172139 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} h0 (cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_172140 (h0 : functor.add_const (filter (has_to_string pos)) name) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_172141 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (complete_distrib_lattice.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (complete_distrib_lattice.{0} empty))  := sorry --non-trivial
lemma new_lemma_172142 (h0 : finset (preorder num)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_172143 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (linear_ordered_cancel_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (linear_ordered_cancel_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_172144 (h0 : function.extfun Type group) : @normalizer_condition.{0} (metric_space.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} h0 (metric_space.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_172145 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (boolean_algebra.core.{0} name) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (boolean_algebra.core.{0} name))  := sorry --non-trivial
lemma new_lemma_172146 (h0 : topological_space (add_comm_monoid (has_neg_part pos))) : loc_path_connected_space (add_comm_monoid (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_172147 (h0 : functor.add_const (function.extfun Type topological_space) (ring pos)) : @discrete_topology.{0} (has_neg.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (ring.{0} pos) h0) (has_neg.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_172148 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @irreducible_space.{0} (add_cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (add_cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_172149 (h0 : function.extfun Type topological_space) : @t0_space.{0} string_imp (@function.extfun_app.{2 1} Type topological_space.{0} h0 string_imp)  := sorry --non-trivial
lemma new_lemma_172150 (h0 : topological_space (complete_distrib_lattice (has_neg pos))) : regular_space (complete_distrib_lattice (has_neg pos)) := sorry --non-trivial
lemma new_lemma_172151 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (has_bot.{0} real) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_bot.{0} real))  := sorry --non-trivial
lemma new_lemma_172152 (h0 : list (non_assoc_semiring (option (option (option (option (option (option (option empty))))))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_172153 (h0 : has_mem.mem Type has_emptyc.emptyc) : @complete_space.{1} Type (@finset.pi.empty.{2 1} (Type 1) uniform_space.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_172154 (h0 : complete_lattice (cancel_monoid pos)) : is_atomistic (cancel_monoid pos) := sorry --non-trivial
lemma new_lemma_172155 (h0 : functor.add_const (complete_lattice (has_Sup empty)) num) : @is_compactly_generated.{0} (has_Sup.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_Sup.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_172156 (h0 : functor.add_const (group (normed_comm_ring unsigned)) environment.implicit_infer_kind) : @normalizer_condition.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (normed_comm_ring.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_172157 (h0 : simple_graph (finset linarith.comp) -> simple_graph (finset linarith.comp) -> Prop) : transitive h0 := sorry --non-trivial
lemma new_lemma_172158 (h0 : topological_space (with_bot (semiring unsigned))) : totally_separated_space (with_bot (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_172159 (h0 : finset (has_add (option name))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_172160 (h0 : topological_space (with_one unsigned)) : totally_disconnected_space (with_one unsigned) := sorry --non-trivial
lemma new_lemma_172161 (h0 : function.extfun nat fin) : @preconnected_space.{1} (canonically_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (canonically_ordered_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_172162 (h0 : add_monoid (semiring (has_norm linarith.comp))) : add_monoid.fg (semiring (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_172163 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (ordered_comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (ordered_comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_172164 (h0 : uniform_space (has_emptyc (with_bot string_imp))) : complete_space (has_emptyc (with_bot string_imp)) := sorry --non-trivial
lemma new_lemma_172165 (h0 : topological_space (boolean_algebra.core (has_nndist pos))) : preconnected_space (boolean_algebra.core (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_172166 (h0 : topological_space (has_neg_part (normed_comm_ring (boolean_algebra.core Type)))) : path_connected_space (has_neg_part (normed_comm_ring (boolean_algebra.core Type))) := sorry --non-trivial
lemma new_lemma_172167 (h0 : ordered_add_comm_monoid (comm_group (has_neg_part (mul_zero_class environment.implicit_infer_kind)))) : archimedean (comm_group (has_neg_part (mul_zero_class environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_172168 (h0 : function.extfun Type (functor.comp topological_space boolean_algebra)) : @sequential_space.{0} (boolean_algebra.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} boolean_algebra.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} boolean_algebra.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_172169 (h2 : ring (uniform_space (mul_one_class string.iterator_imp))) : is_domain (uniform_space (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_172170 (h0 : complete_lattice (add_comm_monoid (option empty))) : complete_lattice.is_Sup_finite_compact (add_comm_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_172171 (h0 : functor.add_const (filter Type) (ring (ring (has_zero Type)))) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_172172 (h0 : function.extfun nat fin) : @discrete_topology.{0} (generalized_boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))) (generalized_boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_172173 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_union.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_union.{0} num))  := sorry --non-trivial
lemma new_lemma_172174 (h0 : add_monoid (boolean_algebra (comm_group (has_to_string (comm_group unsigned))))) : add_monoid.fg (boolean_algebra (comm_group (has_to_string (comm_group unsigned)))) := sorry --non-trivial
lemma new_lemma_172175 (h1 : topological_space (topological_space (comm_ring to_additive.value_type))) : t0_space (topological_space (comm_ring to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_172176 (h0 : add_monoid (boolean_algebra (has_Inf (has_add (has_pos_part (has_add pos)))))) : add_monoid.fg (boolean_algebra (has_Inf (has_add (has_pos_part (has_add pos))))) := sorry --non-trivial
lemma new_lemma_172177 (h0 : has_zero std_gen) (h1 : topological_space (mul_one_class (finsupp char std_gen))) (h2 : set (mul_one_class (finsupp char std_gen))) : is_path_connected h2 := sorry --non-trivial
lemma new_lemma_172178 (h0 : uniform_space (add_cancel_monoid (has_Inf linarith.comp))) : separated_space (add_cancel_monoid (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_172179 (h0 : topological_space (random_gen (with_bot string_imp))) : totally_separated_space (random_gen (with_bot string_imp)) := sorry --non-trivial
lemma new_lemma_172180 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (ring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_172181 (h0 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} (with_zero.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h0) (with_zero.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_172182 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (linear_ordered_field.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_field.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_172183 (h0 : functor.add_const (finset (cancel_monoid unsigned)) empty) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_172184 (h0 : functor.add_const (topological_space (has_pos_part pos)) pos) : @normal_space.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_172185 (h0 : not (list (add_right_cancel_monoid unsigned) -> false)) : list.nodup (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_172186 (h0 : functor.add_const (topological_space (boolean_algebra environment.implicit_infer_kind)) Type) : @sequential_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_172187 (h0 : add_monoid (has_pos_part (has_neg linarith.comp))) : add_monoid.fg (has_pos_part (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_172188 (h0 : not (uniform_space (has_one unsigned) -> false)) : @complete_space.{0} (has_one.{0} unsigned) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_one.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_172189 (h0 : topological_space (with_zero (has_nnnorm linarith.comp_source))) : totally_disconnected_space (with_zero (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_172190 (h0 : functor.add_const (complete_lattice (add_cancel_monoid linarith.comp)) (has_zero (has_zero pos))) : @is_compactly_generated.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_cancel_monoid.{0} linarith.comp)) (has_zero.{0} (has_zero.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_172191 (h0 : functor.add_const (finset (has_dist empty)) empty) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_172192 (h0 : topological_space (has_bot Type)) : discrete_topology (has_bot Type) := sorry --non-trivial
lemma new_lemma_172193 (h0 : functor.add_const (group (ring name)) Type) : @is_cyclic.{0} (ring.{0} name) (@functor.add_const.run.{0 1} (group.{0} (ring.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_172194 (h1 : ring (linear_ordered_add_comm_group (has_nnnorm to_additive.value_type))) : rank_condition (linear_ordered_add_comm_group (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_172195 (h0 : topological_space (has_pos_part (has_add pos))) : discrete_topology (has_pos_part (has_add pos)) := sorry --non-trivial
lemma new_lemma_172196 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_sub.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_sub.{0} num))  := sorry --non-trivial
lemma new_lemma_172197 (h0 : topological_space (distrib (topological_space linarith.ineq))) : totally_disconnected_space (distrib (topological_space linarith.ineq)) := sorry --non-trivial
lemma new_lemma_172198 (h0 : not (topological_space (measurable_space.dynkin_system linarith.comp) -> false)) : @totally_separated_space.{0} (measurable_space.dynkin_system.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (measurable_space.dynkin_system.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_172199 (h0 : complete_lattice (complete_distrib_lattice empty)) : is_compactly_generated (complete_distrib_lattice empty) := sorry --non-trivial
lemma new_lemma_172200 (h0 : functor.add_const (topological_space (has_add pos)) Type) : @topological_space.separable_space.{0} (has_add.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_add.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_172201 (h1 : list (with_one (random_gen (random_gen string_imp)))) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_172202 (h0 : uniform_space (has_nndist (option (option (option empty))))) : separated_space (has_nndist (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_172203 (h0 : ring (bin_tree (semiring (semiring unsigned)))) : is_domain (bin_tree (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_172204 (h0 : not (topological_space (linear_ordered_add_comm_group linarith.ineq) -> false)) : @totally_disconnected_space.{0} (linear_ordered_add_comm_group.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_add_comm_group.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_172205 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (ordered_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_172206 (h0 : functor.add_const (semiring (has_neg environment.implicit_infer_kind)) linarith.comp) : @is_noetherian_ring.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (semiring.{0} (has_neg.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_172207 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_top.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_top.{0} empty))  := sorry --non-trivial
lemma new_lemma_172208 (h0 : functor.add_const (ring (semigroup linarith.comp)) environment.implicit_infer_kind) : @rank_condition.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (semigroup.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_172209 (h1 : add_group (non_unital_non_assoc_semiring (has_neg reducibility_hints))) : is_add_cyclic (non_unital_non_assoc_semiring (has_neg reducibility_hints)) := sorry --non-trivial
lemma new_lemma_172210 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (add_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (add_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_172211 (h0 : functor.add_const (topological_space (comm_group linarith.comp)) Type) : @sequential_space.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (comm_group.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_172212 (h0 : topological_space (with_bot num)) : normal_space (with_bot num) := sorry --non-trivial
lemma new_lemma_172213 (h0 : topological_space (has_top (random_gen (has_norm fun_info)))) : t0_space (has_top (random_gen (has_norm fun_info))) := sorry --non-trivial
lemma new_lemma_172214 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @is_compactly_generated.{0} linarith.ineq (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) complete_lattice.{0}) linarith.ineq)  := sorry --non-trivial
lemma new_lemma_172215 (h2 : add_group (has_top string_imp)) : is_add_cyclic (has_top string_imp) := sorry --non-trivial
lemma new_lemma_172216 (h0 : add_group (partial_order empty)) : is_add_cyclic (partial_order empty) := sorry --non-trivial
lemma new_lemma_172217 (h0 : functor.add_const Prop (boolean_algebra.core Type)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_172218 (h0 : add_monoid (canonically_linear_ordered_monoid real)) : add_monoid.fg (canonically_linear_ordered_monoid real) := sorry --non-trivial
lemma new_lemma_172219 (h0 : has_mem.mem (has_emptyc congr_arg_kind) has_emptyc.emptyc) : @locally_compact_space.{0} (has_emptyc.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_emptyc.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_172220 (h0 : function.extfun (boolean_algebra.core unsigned) (fun (x : boolean_algebra.core unsigned), Prop)) : zzz_forall (function.extfun_app h0) := sorry --non-trivial
lemma new_lemma_172221 (h0 : topological_space (complete_linear_order (semiring (semiring (semiring unsigned))))) : discrete_topology (complete_linear_order (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_172222 (h0 : not (ring (has_star unsigned) -> false)) : @strong_rank_condition.{0} (has_star.{0} unsigned) (@classical.by_contradiction'.{1} (ring.{0} (has_star.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_172223 (h3 : function.extfun Type topological_space) : @t0_space.{0} (measurable_space.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h3 (measurable_space.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_172224 (h0 : monoid (has_union (semiring (semiring linarith.comp)))) : monoid.fg (has_union (semiring (semiring linarith.comp))) := sorry --non-trivial
lemma new_lemma_172225 (h0 : ring (normed_comm_ring (add_cancel_monoid unsigned))) : is_principal_ideal_ring (normed_comm_ring (add_cancel_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_172226 (h0 : functor.add_const (filter pos) unsigned) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_172227 (h0 : functor.add_const (group (linear_ordered_cancel_comm_monoid empty)) empty) : @normalizer_condition.{0} (linear_ordered_cancel_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (linear_ordered_cancel_comm_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_172228 (h0 : finset (boolean_algebra environment.implicit_infer_kind)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_172229 (h0 : measurable_space.dynkin_system (preorder num) -> measurable_space.dynkin_system (preorder num) -> Prop) : is_symm (measurable_space.dynkin_system (preorder num)) h0 := sorry --non-trivial
lemma new_lemma_172230 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (has_zero name)) := sorry --non-trivial
lemma new_lemma_172231 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_sub.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_sub.{0} empty))  := sorry --non-trivial
lemma new_lemma_172232 (h0 : topological_space (has_neg_part (has_add name))) : totally_separated_space (has_neg_part (has_add name)) := sorry --non-trivial
lemma new_lemma_172233 (h0 : topological_space (has_lt (mul_one_class string.iterator_imp))) : path_connected_space (has_lt (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_172234 (h0 : complete_lattice (measurable_space (random_gen (random_gen fun_info)))) : complete_lattice.is_Sup_finite_compact (measurable_space (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_172235 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (normed_comm_ring.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (normed_comm_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_172236 (h0 : functor.add_const (filter (has_zero linarith.comp)) linarith.comp) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_172237 (h0 : functor.add_const (ring (comm_group environment.implicit_infer_kind)) (normed_comm_ring name)) : @rank_condition.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (comm_group.{0} environment.implicit_infer_kind)) (normed_comm_ring.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_172238 (h0 : complete_lattice (has_emptyc (has_norm fun_info))) : is_compactly_generated (has_emptyc (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_172239 (h0 : topological_space (has_zero ennreal)) : discrete_topology (has_zero ennreal) := sorry --non-trivial
lemma new_lemma_172240 (h0 : topological_space (linear_ordered_semiring (semiring unsigned))) : t0_space (linear_ordered_semiring (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_172241 (h0 : topological_space (has_union (has_norm (has_norm empty)))) : discrete_topology (has_union (has_norm (has_norm empty))) := sorry --non-trivial
lemma new_lemma_172242 (h0 : filter (has_dist (option (option (option (option (option (option ennreal)))))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_172243 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (comm_monoid num)) := sorry --non-trivial
lemma new_lemma_172244 (h0 : ring (with_one string_imp)) : rank_condition (with_one string_imp) := sorry --non-trivial
lemma new_lemma_172245 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (linear_order.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (linear_order.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_172246 (h0 : function.extfun (finset Type -> Prop) (function.extfun (finset Type))) : @is_cyclic.{0} (has_norm.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type group.{0} (has_norm.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_norm.{0} linarith.comp_source)) (@function.extfun_app.{2 0} (finset.{1} Type → Prop) (function.extfun.{2 0} (finset.{1} Type)) h0 (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_norm.{0} linarith.comp_source))) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_172247 (h1 : topological_space (has_le linarith.comp_source)) : path_connected_space (has_le linarith.comp_source) := sorry --non-trivial
lemma new_lemma_172248 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (has_union.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (has_union.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_172249 (h0 : complete_lattice (complete_linear_order num)) : is_atomistic (complete_linear_order num) := sorry --non-trivial
lemma new_lemma_172250 (h0 : functor.add_const (topological_space (complete_distrib_lattice name)) Type) : @discrete_topology.{0} (complete_distrib_lattice.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (complete_distrib_lattice.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_172251 (h0 : ring (linear_ordered_comm_group_with_zero enat)) : rank_condition (linear_ordered_comm_group_with_zero enat) := sorry --non-trivial
lemma new_lemma_172252 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (add_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_172253 (h0 : topological_space (has_bot (has_add real))) : loc_path_connected_space (has_bot (has_add real)) := sorry --non-trivial
lemma new_lemma_172254 (h2 : ring (has_top to_additive.value_type)) : is_domain (has_top to_additive.value_type) := sorry --non-trivial
lemma new_lemma_172255 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (complete_distrib_lattice.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (complete_distrib_lattice.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_172256 (h0 : not (cancel_comm_monoid_with_zero (has_one unsigned) -> false)) : @unique_factorization_monoid.{0} (has_one.{0} unsigned) (@classical.by_contradiction'.{1} (cancel_comm_monoid_with_zero.{0} (has_one.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_172257 (h0 : functor.add_const (cancel_comm_monoid_with_zero (comm_group pos)) (comm_group Type)) : @unique_factorization_monoid.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 1} (cancel_comm_monoid_with_zero.{0} (comm_group.{0} pos)) (comm_group.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_172258 (h0 : functor.add_const (uniform_space (boolean_algebra pos)) name) : @separated_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (boolean_algebra.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_172259 (h0 : complete_lattice (finset (option (option unsigned)))) : complete_lattice.is_Sup_finite_compact (finset (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_172260 (h0 : group (encodable (random_gen (random_gen (random_gen string_imp))))) : group.fg (encodable (random_gen (random_gen (random_gen string_imp)))) := sorry --non-trivial
lemma new_lemma_172261 (h0 : functor.add_const (topological_space (has_pos_part Type)) pos) : @locally_compact_space.{1} (has_pos_part.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_pos_part.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_172262 (h0 : functor.add_const (ordered_comm_monoid (comm_group environment.implicit_infer_kind)) pos) : @has_exists_mul_of_le.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (comm_group.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_172263 (h0 : add_group (normed_group (random_gen (has_top linarith.comp_source)))) : is_add_cyclic (normed_group (random_gen (has_top linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_172264 (h0 : function.extfun Type (functor.add_const (topological_space (left_cancel_semigroup unsigned)))) : @loc_path_connected_space.{0} (left_cancel_semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_semigroup.{0} unsigned)) congr_arg_kind (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (left_cancel_semigroup.{0} unsigned))) h0 congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_172265 (h0 : complete_lattice (linear_ordered_comm_ring (canonically_linear_ordered_monoid num))) : is_compactly_generated (linear_ordered_comm_ring (canonically_linear_ordered_monoid num)) := sorry --non-trivial
lemma new_lemma_172266 (h0 : topological_space (ordered_comm_ring (ordered_comm_monoid (has_pos_part name)))) : t0_space (ordered_comm_ring (ordered_comm_monoid (has_pos_part name))) := sorry --non-trivial
lemma new_lemma_172267 (h0 : filter (cancel_monoid (option (option pos)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_172268 (h0 : group (with_bot linarith.ineq)) : is_cyclic (with_bot linarith.ineq) := sorry --non-trivial
lemma new_lemma_172269 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (boolean_algebra.core.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (boolean_algebra.core.{0} name))  := sorry --non-trivial
lemma new_lemma_172270 (h0 : ring (finset (has_to_string (finset linarith.comp)))) : is_principal_ideal_ring (finset (has_to_string (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_172271 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (add_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (add_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_172272 (h0 : topological_space (comm_semigroup (sub_neg_monoid pos))) : preconnected_space (comm_semigroup (sub_neg_monoid pos)) := sorry --non-trivial
lemma new_lemma_172273 (h0 : topological_space (simple_graph (mul_one_class (mul_one_class string_imp)))) : totally_disconnected_space (simple_graph (mul_one_class (mul_one_class string_imp))) := sorry --non-trivial
lemma new_lemma_172274 (h0 : not (function.extfun Type complete_lattice -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_top.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (has_top.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_172275 (h0 : topological_space (boolean_algebra (has_to_string pos))) : normal_space (boolean_algebra (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_172276 (h0 : function.extfun (finset Type) (has_mem.mem (has_top fun_info))) : @totally_disconnected_space.{0} (has_top.{0} fun_info) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_top.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_top.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_172277 (h0 : monoid (linear_ordered_semiring (has_top (has_top num)))) : monoid.fg (linear_ordered_semiring (has_top (has_top num))) := sorry --non-trivial
lemma new_lemma_172278 (h0 : group (ring (option (option empty)))) : normalizer_condition (ring (option (option empty))) := sorry --non-trivial
lemma new_lemma_172279 (h0 : add_monoid (finset (has_nndist name))) : add_monoid.fg (finset (has_nndist name)) := sorry --non-trivial
lemma new_lemma_172280 (h0 : topological_space (measurable_space.dynkin_system unsigned)) : topological_space.separable_space (measurable_space.dynkin_system unsigned) := sorry --non-trivial
lemma new_lemma_172281 (h0 : topological_space (normed_lattice_add_comm_group (has_Inf (has_neg (has_Inf (has_add Type)))))) : sequential_space (normed_lattice_add_comm_group (has_Inf (has_neg (has_Inf (has_add Type))))) := sorry --non-trivial
lemma new_lemma_172282 (h0 : functor.add_const (topological_space (left_cancel_monoid unsigned)) congr_arg_kind) : @totally_disconnected_space.{0} (left_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_172283 (h0 : functor.add_const (ordered_add_comm_monoid (as_linear_order empty)) empty) : @archimedean.{0} (as_linear_order.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (as_linear_order.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_172284 (h0 : add_monoid (has_to_string (ring pos))) : add_monoid.fg (has_to_string (ring pos)) := sorry --non-trivial
lemma new_lemma_172285 (h0 : ring (ordered_comm_group (option (option empty)))) : is_domain (ordered_comm_group (option (option empty))) := sorry --non-trivial
lemma new_lemma_172286 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (with_bot.{0} empty) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (with_bot.{0} empty))  := sorry --non-trivial
lemma new_lemma_172287 (h0 : function.extfun Type (functor.add_const (complete_lattice (normed_linear_ordered_group num)))) : @is_compactly_generated.{0} (normed_linear_ordered_group.{0} num) (@functor.add_const.run.{0 0} (complete_lattice.{0} (normed_linear_ordered_group.{0} num)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (complete_lattice.{0} (normed_linear_ordered_group.{0} num))) h0 empty))  := sorry --non-trivial
lemma new_lemma_172288 (h0 : not (topological_space (normed_group empty) -> false)) : @locally_compact_space.{0} (normed_group.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_group.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_172289 (h0 : not (function.extfun Type topological_space -> false)) : @totally_disconnected_space.{0} (measurable_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (measurable_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_172290 (h0 : topological_space (ring (has_neg name))) : path_connected_space (ring (has_neg name)) := sorry --non-trivial
lemma new_lemma_172291 (h0 : group (has_add (random_gen string_imp))) : group.fg (has_add (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_172292 (h0 : ring (add_comm_monoid (has_add (has_add name)))) : rank_condition (add_comm_monoid (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_172293 (h0 : function.extfun nat fin) : @preirreducible_space.{1} (comm_semigroup.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (comm_semigroup.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_172294 (h0 : ring (finset (option pos))) : rank_condition (finset (option pos)) := sorry --non-trivial
lemma new_lemma_172295 (h0 : filter (cancel_monoid (option pos))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_172296 (h0 : functor.add_const (ring (generalized_boolean_algebra pos)) (ring name)) : @rank_condition.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (generalized_boolean_algebra.{0} pos)) (ring.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_172297 (h0 : function.extfun Type group) : @group.fg.{0} (has_Inf.{0} name) (@function.extfun_app.{2 1} Type group.{0} h0 (has_Inf.{0} name))  := sorry --non-trivial
lemma new_lemma_172298 (h0 : add_group (ring (ring pos))) : is_add_cyclic (ring (ring pos)) := sorry --non-trivial
lemma new_lemma_172299 (h0 : list (dlist (has_top fun_info))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_172300 (h0 : functor.add_const (topological_space (free_add_monoid unsigned)) unsigned) : @totally_disconnected_space.{0} (free_add_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_172301 (h0 : functor.add_const (ordered_comm_monoid (ordered_comm_ring pos)) linarith.comp) : @has_exists_mul_of_le.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (ordered_comm_ring.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_172302 (h1 : function.extfun Type uniform_space) : @complete_space.{0} (random_gen.{0} fun_info) (@function.extfun_app.{2 1} Type uniform_space.{0} h1 (random_gen.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_172303 (h0 : semiring (boolean_algebra (has_Inf real))) : is_noetherian_ring (boolean_algebra (has_Inf real)) := sorry --non-trivial
lemma new_lemma_172304 (h0 : cancel_comm_monoid_with_zero (has_zero (has_neg_part Type))) : unique_factorization_monoid (has_zero (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_172305 (h0 : functor.add_const (topological_space (free_add_monoid num)) empty) : @preirreducible_space.{0} (free_add_monoid.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_172306 (h0 : functor.add_const (group (add_cancel_comm_monoid empty)) empty) : @is_cyclic.{0} (add_cancel_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (add_cancel_comm_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_172307 (h1 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h1) (complete_semilattice_Sup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_172308 (h0 : complete_lattice (has_div string.iterator_imp)) : is_compactly_generated (has_div string.iterator_imp) := sorry --non-trivial
lemma new_lemma_172309 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (measurable_space.dynkin_system.{0} num) (@function.extfun_app.{2 1} Type monoid.{0} h0 (measurable_space.dynkin_system.{0} num))  := sorry --non-trivial
lemma new_lemma_172310 (h0 : topological_space (linear_ordered_semiring (has_top fun_info))) : totally_disconnected_space (linear_ordered_semiring (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_172311 (h0 : ring (has_to_string (boolean_algebra.core pos))) : is_domain (has_to_string (boolean_algebra.core pos)) := sorry --non-trivial
lemma new_lemma_172312 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_neg.{0} num) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_neg.{0} num))  := sorry --non-trivial
lemma new_lemma_172313 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_emptyc.{0} (has_inv.{0} to_additive.value_type)) (@function.extfun_app.{2 1} Type group.{0} h0 (has_emptyc.{0} (has_inv.{0} to_additive.value_type)))  := sorry --non-trivial
lemma new_lemma_172314 (h0 : functor.add_const (topological_space (has_pos_part Type)) Type) : @preconnected_space.{1} (has_pos_part.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_pos_part.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_172315 (h0 : cancel_comm_monoid_with_zero (add_semigroup (option empty))) : unique_factorization_monoid (add_semigroup (option empty)) := sorry --non-trivial
lemma new_lemma_172316 (h0 : functor.add_const (ring (has_Inf Type)) linarith.comp) : @rank_condition.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_Inf.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_172317 (h0 : topological_space (canonically_ordered_comm_semiring fun_info)) : path_connected_space (canonically_ordered_comm_semiring fun_info) := sorry --non-trivial
lemma new_lemma_172318 (h0 : functor.add_const (filter (boolean_algebra.core unsigned)) Type) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_172319 (h0 : topological_space (linear_ordered_comm_ring (semiring (semiring (semiring empty))))) : topological_space.separable_space (linear_ordered_comm_ring (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_172320 (h0 : topological_space (has_add (has_add environment.implicit_infer_kind))) : topological_space.separable_space (has_add (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_172321 (h0 : functor.add_const (topological_space (preorder empty)) empty) : @preirreducible_space.{0} (preorder.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (preorder.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_172322 (h0 : functor.add_const (ring (boolean_algebra Type)) linarith.comp) : @rank_condition.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (boolean_algebra.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_172323 (h0 : functor.add_const (topological_space nnreal) unsigned) : loc_path_connected_space nnreal := sorry --non-trivial
lemma new_lemma_172324 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_172325 (h0 : functor.add_const (functor.add_const (topological_space Type) environment.implicit_infer_kind) linarith.comp) : @topological_space.separable_space.{1} Type (@functor.add_const.run.{1 0} (topological_space.{1} Type) environment.implicit_infer_kind (@functor.add_const.run.{1 0} (functor.add_const.{1 0} (topological_space.{1} Type) environment.implicit_infer_kind) linarith.comp h0))  := sorry --non-trivial
lemma new_lemma_172326 (h0 : not (topological_space (with_bot empty) -> false)) : @preirreducible_space.{0} (with_bot.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (with_bot.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_172327 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (has_zero.{0} name) (@function.extfun_app.{2 1} Type semiring.{0} h0 (has_zero.{0} name))  := sorry --non-trivial
lemma new_lemma_172328 (h0 : functor.add_const (topological_space (has_Inf pos)) (has_neg Type)) : @locally_compact_space.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_Inf.{0} pos)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_172329 (h0 : topological_space (ring (has_add (has_add pos)))) : locally_compact_space (ring (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_172330 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (is_R_or_C.{0} (option.{0} (option.{0} (option.{0} (option.{0} (option.{0} unsigned)))))) (@function.extfun_app.{2 1} Type monoid.{0} h0 (is_R_or_C.{0} (option.{0} (option.{0} (option.{0} (option.{0} (option.{0} unsigned)))))))  := sorry --non-trivial
lemma new_lemma_172331 (h0 : topological_space (complete_semilattice_Sup (with_bot (linear_ordered_semiring unsigned)))) : irreducible_space (complete_semilattice_Sup (with_bot (linear_ordered_semiring unsigned))) := sorry --non-trivial
lemma new_lemma_172332 (h0 : functor.add_const (ring (canonically_linear_ordered_monoid pos)) ennreal) : @is_domain.{0} (canonically_linear_ordered_monoid.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (canonically_linear_ordered_monoid.{0} pos)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_172333 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (has_to_string.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_172334 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @irreducible_space.{0} linarith.comp (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) linarith.comp)  := sorry --non-trivial
lemma new_lemma_172335 (h0 : topological_space (normed_group (random_gen (has_inv (has_ssubset linarith.comp_source))))) : path_connected_space (normed_group (random_gen (has_inv (has_ssubset linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_172336 (h0 : group (boolean_algebra (normed_comm_ring name))) : is_cyclic (boolean_algebra (normed_comm_ring name)) := sorry --non-trivial
lemma new_lemma_172337 (h0 : group (add_comm_monoid (boolean_algebra.core (finset pos)))) : normalizer_condition (add_comm_monoid (boolean_algebra.core (finset pos))) := sorry --non-trivial
lemma new_lemma_172338 (h0 : functor.add_const (ordered_comm_monoid (left_cancel_semigroup linarith.comp)) name) : @has_exists_mul_of_le.{0} (left_cancel_semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (left_cancel_semigroup.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_172339 (h0 : functor.add_const (uniform_space (bin_tree num)) num) : @separated_space.{0} (bin_tree.{0} num) (@functor.add_const.run.{0 0} (uniform_space.{0} (bin_tree.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_172340 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (canonically_ordered_add_monoid.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (canonically_ordered_add_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_172341 (h0 : not (complete_lattice (with_bot num) -> false)) : @is_compactly_generated.{0} (with_bot.{0} num) (@classical.by_contradiction'.{1} (complete_lattice.{0} (with_bot.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_172342 (h0 : functor.add_const (ordered_add_comm_monoid (add_cancel_monoid Type)) (has_neg_part (has_neg_part pos))) : @archimedean.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (ordered_add_comm_monoid.{1} (add_cancel_monoid.{1} Type)) (has_neg_part.{0} (has_neg_part.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_172343 (h0 : functor.add_const (uniform_space (has_neg unsigned)) environment.implicit_infer_kind) : @complete_space.{0} (has_neg.{0} unsigned) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_neg.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_172344 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (finset.{0} stieltjes_function) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (finset.{0} stieltjes_function))  := sorry --non-trivial
lemma new_lemma_172345 (h0 : add_group (simple_graph fun_info)) : is_add_cyclic (simple_graph fun_info) := sorry --non-trivial
lemma new_lemma_172346 (h0 : topological_space (boolean_algebra (comm_group (has_add pos)))) : locally_compact_space (boolean_algebra (comm_group (has_add pos))) := sorry --non-trivial
lemma new_lemma_172347 (h0 : topological_space (simple_graph num)) : totally_disconnected_space (simple_graph num) := sorry --non-trivial
lemma new_lemma_172348 (h1 : complete_lattice (topological_space reducibility_hints)) : is_compactly_generated (topological_space reducibility_hints) := sorry --non-trivial
lemma new_lemma_172349 (h0 : topological_space (add_cancel_monoid (comm_group Type))) : t0_space (add_cancel_monoid (comm_group Type)) := sorry --non-trivial
lemma new_lemma_172350 (h0 : ring (mul_one_class (mul_one_class string.iterator_imp))) : strong_rank_condition (mul_one_class (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_172351 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (has_one.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_one.{0} num))  := sorry --non-trivial
lemma new_lemma_172352 (h0 : functor.add_const (cancel_comm_monoid_with_zero (non_assoc_semiring unsigned)) unsigned) : @unique_factorization_monoid.{0} (non_assoc_semiring.{0} unsigned) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (non_assoc_semiring.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_172353 (h0 : group (simple_graph (ring (ring pos)))) : group.fg (simple_graph (ring (ring pos))) := sorry --non-trivial
lemma new_lemma_172354 (h0 : finset (non_assoc_semiring empty)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_172355 (h0 : topological_space (comm_group (option (has_neg_part pos)))) : locally_compact_space (comm_group (option (has_neg_part pos))) := sorry --non-trivial
lemma new_lemma_172356 (h0 : group (complete_semilattice_Sup (random_gen (has_nnnorm to_additive.value_type)))) : is_cyclic (complete_semilattice_Sup (random_gen (has_nnnorm to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_172357 (h0 : measurable_space ennreal) (h1 : has_div ennreal) : has_measurable_div₂ ennreal := sorry --non-trivial
lemma new_lemma_172358 (h0 : topological_space (boolean_algebra real)) : loc_path_connected_space (boolean_algebra real) := sorry --non-trivial
lemma new_lemma_172359 (h0 : not (complete_lattice string_imp -> false)) : @is_compactly_generated.{0} string_imp (@classical.by_contradiction'.{1} (complete_lattice.{0} string_imp) h0)  := sorry --non-trivial
lemma new_lemma_172360 (h0 : uniform_space (has_pos_part real)) : separated_space (has_pos_part real) := sorry --non-trivial
lemma new_lemma_172361 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (left_cancel_semigroup.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (left_cancel_semigroup.{0} num))  := sorry --non-trivial
lemma new_lemma_172362 (h0 : monoid (non_assoc_semiring (option real))) : monoid.fg (non_assoc_semiring (option real)) := sorry --non-trivial
lemma new_lemma_172363 (h0 : uniform_space (has_union (semiring unsigned))) : complete_space (has_union (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_172364 (h0 : functor.add_const (filter (has_Inf linarith.comp)) Type) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_172365 (h0 : list (has_nndist Type)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_172366 (h0 : functor.add_const (ordered_comm_monoid (boolean_algebra.core linarith.comp)) (has_neg linarith.comp)) : @has_exists_mul_of_le.{0} (boolean_algebra.core.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (boolean_algebra.core.{0} linarith.comp)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_172367 (h2 : topological_space (normed_field (comm_ring to_additive.value_type))) : totally_disconnected_space (normed_field (comm_ring to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_172368 (h0 : uniform_space (has_emptyc (has_top num))) : complete_space (has_emptyc (has_top num)) := sorry --non-trivial
lemma new_lemma_172369 (h0 : function.extfun Type group) : @group.fg.{0} (complete_distrib_lattice.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} h0 (complete_distrib_lattice.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_172370 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @discrete_topology.{1} (generalized_boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (generalized_boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_172371 (h0 : functor.add_const (monoid (has_neg_part Type)) linarith.comp) : @monoid.fg.{1} (has_neg_part.{1} Type) (@functor.add_const.run.{1 0} (monoid.{1} (has_neg_part.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_172372 (h0 : ring (has_neg_part (finset pos))) : rank_condition (has_neg_part (finset pos)) := sorry --non-trivial
lemma new_lemma_172373 (h0 : ring (has_add (ring (has_neg Type)))) : rank_condition (has_add (ring (has_neg Type))) := sorry --non-trivial
lemma new_lemma_172374 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (complete_semilattice_Sup.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_semilattice_Sup.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_172375 (h0 : functor.add_const (ordered_add_comm_monoid (has_to_string name)) pos) : @archimedean.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_to_string.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_172376 (h0 : ring (normed_group (semiring (has_norm congr_arg_kind)))) : is_domain (normed_group (semiring (has_norm congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_172377 (h0 : filter (has_Inf (ring Type))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_172378 (h0 : list (boolean_algebra (ring Type))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_172379 (h0 : topological_space (ring congr_arg_kind)) : totally_separated_space (ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_172380 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (@id.{2} Type string_imp) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (@id.{2} Type string_imp))  := sorry --non-trivial
lemma new_lemma_172381 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg_part.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_172382 (h0 : topological_space (ring (finset (has_neg linarith.comp)))) : preirreducible_space (ring (finset (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_172383 (h0 : functor.add_const (group (complete_linear_order empty)) empty) : @group.fg.{0} (complete_linear_order.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (complete_linear_order.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_172384 (h0 : function.extfun Type topological_space) : @normal_space.{0} (with_bot.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_bot.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_172385 (h0 : ring (canonically_ordered_monoid (sub_neg_monoid (sub_neg_monoid name)))) : is_principal_ideal_ring (canonically_ordered_monoid (sub_neg_monoid (sub_neg_monoid name))) := sorry --non-trivial
lemma new_lemma_172386 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_172387 (h0 : topological_space (has_star num)) : topological_space.separable_space (has_star num) := sorry --non-trivial
lemma new_lemma_172388 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_172389 (h0 : functor.add_const (topological_space (boolean_algebra.core name)) environment.implicit_infer_kind) : @normal_space.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_172390 (h0 : functor.add_const (topological_space (finset Type)) linarith.comp) : @preirreducible_space.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (finset.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_172391 (h0 : group (option (complete_linear_order (preorder congr_arg_kind)))) : group.fg (option (complete_linear_order (preorder congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_172392 (h0 : ring (normed_lattice_add_comm_group (has_Inf real))) : is_principal_ideal_ring (normed_lattice_add_comm_group (has_Inf real)) := sorry --non-trivial
lemma new_lemma_172393 (h0 : uniform_space (uniform_space (mul_one_class (mul_one_class enat)))) : complete_space (uniform_space (mul_one_class (mul_one_class enat))) := sorry --non-trivial
lemma new_lemma_172394 (h0 : functor.comp topological_space boolean_algebra.core (finset (finset ennreal))) : @locally_compact_space.{0} (boolean_algebra.core.{0} (finset.{0} (finset.{0} ennreal))) (@functor.comp.run.{0 0 0} topological_space.{0} boolean_algebra.core.{0} (finset.{0} (finset.{0} ennreal)) h0)  := sorry --non-trivial
lemma new_lemma_172395 (h0 : topological_space (semigroup congr_arg_kind)) : irreducible_space (semigroup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_172396 (h0 : topological_space (uniform_space linarith.ineq)) (h1 : preorder (uniform_space linarith.ineq)) : order_topology (uniform_space linarith.ineq) := sorry --non-trivial
lemma new_lemma_172397 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @rank_condition.{0} num (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) ring.{0}) num)  := sorry --non-trivial
lemma new_lemma_172398 (h0 : topological_space (semigroup (option (option ennreal)))) : preirreducible_space (semigroup (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_172399 (h0 : cancel_comm_monoid_with_zero (add_right_cancel_monoid (semiring congr_arg_kind))) : unique_factorization_monoid (add_right_cancel_monoid (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_172400 (h0 : functor.add_const (finset (simple_graph linarith.comp)) name) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_172401 (h0 : functor.add_const (filter (has_zero ennreal)) pos) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_172402 (h1 : ring (has_compl std_gen)) : rank_condition (has_compl std_gen) := sorry --non-trivial
lemma new_lemma_172403 (h0 : fin has_zero.zero) : @totally_disconnected_space.{0} (complete_distrib_lattice.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (complete_distrib_lattice.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_172404 (h0 : set (add_comm_semigroup (add_comm_semigroup string.iterator_imp) -> add_comm_semigroup string.iterator_imp)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_172405 (h0 : functor.add_const (topological_space znum) unsigned) : @path_connected_space.{0} znum (@functor.add_const.run.{0 0} (topological_space.{0} znum) unsigned h0)  := sorry --non-trivial
lemma new_lemma_172406 (h0 : function.extfun (((Type -> Type) -> Type 1) -> Type 1) (function.extfun ((Type -> Type) -> Type 1))) : @is_cyclic.{0} (comm_ring.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) (@function.extfun_app.{3 3} (((Type → Type) → Type 1) → Type 1) (function.extfun.{3 2} ((Type → Type) → Type 1)) h0 (function.extfun.{2 2} (Type → Type))) (function.extfun.{2 1} Type)) group.{0}) (comm_ring.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_172407 (h0 : topological_space (has_Inf (has_Inf name))) : totally_disconnected_space (has_Inf (has_Inf name)) := sorry --non-trivial
lemma new_lemma_172408 (h0 : functor.add_const (list (bin_tree congr_arg_kind)) congr_arg_kind) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_172409 (h0 : function.extfun Type topological_space) : @t1_space.{0} (sub_neg_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (sub_neg_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_172410 (h1 : ring (semi_normed_ring (topological_space string_imp))) : is_domain (semi_normed_ring (topological_space string_imp)) := sorry --non-trivial
lemma new_lemma_172411 (h0 : uniform_space (boolean_algebra.core (has_Inf name))) : complete_space (boolean_algebra.core (has_Inf name)) := sorry --non-trivial
lemma new_lemma_172412 (h0 : has_mem.mem (comm_semigroup linarith.comp_source) has_emptyc.emptyc) : @irreducible_space.{0} (comm_semigroup.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (comm_semigroup.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_172413 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_172414 (h0 : functor.add_const (topological_space (finset Type)) name) : @t1_space.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (finset.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_172415 (h1 : not (has_mem.mem to_additive.value_type has_emptyc.emptyc -> false)) : @is_domain.{0} to_additive.value_type (@finset.pi.empty.{1 0} Type ring.{0} to_additive.value_type (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) to_additive.value_type (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h1))  := sorry --non-trivial
lemma new_lemma_172416 (h0 : group (generalized_boolean_algebra (has_Inf Type))) : normalizer_condition (generalized_boolean_algebra (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_172417 (h0 : topological_space (semi_normed_ring (has_ssubset string.iterator_imp))) : t0_space (semi_normed_ring (has_ssubset string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_172418 (h0 : topological_space (has_compl (has_ssubset (has_nnnorm char)))) : path_connected_space (has_compl (has_ssubset (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_172419 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (ordered_cancel_add_comm_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (ordered_cancel_add_comm_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_172420 (h0 : group (has_ssubset (has_nnnorm string.iterator_imp))) : is_cyclic (has_ssubset (has_nnnorm string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_172421 (h0 : topological_space (has_add (has_to_string environment.implicit_infer_kind))) : regular_space (has_add (has_to_string environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_172422 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_union.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) complete_lattice.{0}) (has_union.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_172423 (h0 : ring (has_norm (has_norm empty))) : rank_condition (has_norm (has_norm empty)) := sorry --non-trivial
lemma new_lemma_172424 (h0 : uniform_space (add_comm_semigroup (mul_one_class linarith.ineq))) : complete_space (add_comm_semigroup (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_172425 (h0 : add_monoid (has_add (mul_one_class environment.implicit_infer_kind))) : add_monoid.fg (has_add (mul_one_class environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_172426 (h1 : topological_space (fintype linarith.ineq)) : t0_space (fintype linarith.ineq) := sorry --non-trivial
lemma new_lemma_172427 (h0 : functor.add_const (topological_space (boolean_algebra pos)) Type) : @totally_separated_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_172428 (h0 : complete_lattice (has_zero ennreal)) : is_compactly_generated (has_zero ennreal) := sorry --non-trivial
lemma new_lemma_172429 (h0 : ring (semigroup (has_nndist (boolean_algebra.core Type)))) : rank_condition (semigroup (has_nndist (boolean_algebra.core Type))) := sorry --non-trivial
lemma new_lemma_172430 (h0 : ring (has_zero (finset environment.implicit_infer_kind))) : is_domain (has_zero (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_172431 (h0 : topological_space (comm_group (option ennreal))) : t0_space (comm_group (option ennreal)) := sorry --non-trivial
lemma new_lemma_172432 (h0 : fin has_zero.zero) : @add_monoid.fg.{0} (canonically_ordered_monoid.{0} real) (@matrix.vec_empty.{0} (add_monoid.{0} (canonically_ordered_monoid.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_172433 (h0 : complete_lattice (add_left_cancel_semigroup empty)) : is_atomistic (add_left_cancel_semigroup empty) := sorry --non-trivial
lemma new_lemma_172434 (h0 : add_monoid (complete_distrib_lattice (has_Inf (has_Inf real)))) : add_monoid.fg (complete_distrib_lattice (has_Inf (has_Inf real))) := sorry --non-trivial
lemma new_lemma_172435 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (semiring.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_172436 (h0 : group (add_cancel_monoid (option unsigned))) : is_simple_group (add_cancel_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_172437 (h0 : group (add_comm_monoid name)) : is_simple_group (add_comm_monoid name) := sorry --non-trivial
lemma new_lemma_172438 (h0 : functor.add_const (topological_space (linear_order empty)) empty) : @topological_space.separable_space.{0} (linear_order.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_order.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_172439 (h0 : functor.add_const (complete_lattice (normed_comm_ring linarith.comp)) name) : @is_compactly_generated.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (normed_comm_ring.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_172440 (h0 : functor.add_const (group (generalized_boolean_algebra pos)) name) : @normalizer_condition.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (generalized_boolean_algebra.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_172441 (h0 : functor.add_const (topological_space (boolean_algebra.core Type)) (has_neg linarith.comp)) : @t0_space.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.core.{1} Type)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_172442 (h0 : not (semiring linarith.comp -> false)) : @is_noetherian_ring.{0} linarith.comp (@classical.by_contradiction'.{1} (semiring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_172443 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} (simple_graph.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) (simple_graph.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_172444 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (filter.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (filter.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_172445 (h0 : list (has_zero (has_neg name))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_172446 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} to_additive.value_type (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 to_additive.value_type)  := sorry --non-trivial
lemma new_lemma_172447 (h0 : topological_space (has_add (ring pos))) : totally_disconnected_space (has_add (ring pos)) := sorry --non-trivial
lemma new_lemma_172448 (h0 : measurable_space (has_norm (random_gen num))) (h1 : uniform_space (linear_ordered_semiring (measure_theory.measure (has_norm (random_gen num))))) : separated_space (linear_ordered_semiring (measure_theory.measure (has_norm (random_gen num)))) := sorry --non-trivial
lemma new_lemma_172449 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_172450 (h0 : topological_space (bin_tree (semiring unsigned))) : discrete_topology (bin_tree (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_172451 (h0 : list (linear_ordered_add_comm_monoid_with_top congr_arg_kind)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_172452 (h0 : topological_space (has_div (is_R_or_C linarith.comp_source))) : t0_space (has_div (is_R_or_C linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_172453 (h0 : group (semigroup (has_sub pos))) : is_cyclic (semigroup (has_sub pos)) := sorry --non-trivial
lemma new_lemma_172454 (h0 : functor.add_const (function.extfun Type topological_space) real) : @topological_space.separable_space.{0} (add_comm_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) real h0) (add_comm_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_172455 (h0 : fin has_zero.zero) : @totally_separated_space.{1} (canonically_linear_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (canonically_linear_ordered_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_172456 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (add_group.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (add_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_172457 (h0 : functor.add_const (function.extfun Type list) name) : list.nodup (function.extfun_app (functor.add_const.run h0) (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_172458 (h0 : functor.add_const (topological_space (has_sub empty)) num) : @t1_space.{0} (has_sub.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_sub.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_172459 (h0 : topological_space (canonically_linear_ordered_monoid (has_pos_part (has_bot pos)))) : preirreducible_space (canonically_linear_ordered_monoid (has_pos_part (has_bot pos))) := sorry --non-trivial
lemma new_lemma_172460 (h0 : function.extfun Type ring) : @rank_condition.{0} (comm_group.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (comm_group.{0} name))  := sorry --non-trivial
lemma new_lemma_172461 (h0 : functor.add_const (monoid (normed_comm_ring linarith.comp)) environment.implicit_infer_kind) : @monoid.fg.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (monoid.{0} (normed_comm_ring.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_172462 (h0 : not (function.extfun Type add_monoid -> false)) : @add_monoid.fg.{0} (linear_ordered_comm_ring.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_monoid.{0}) h0) (linear_ordered_comm_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_172463 (h1 : not (uniform_space (has_emptyc linarith.comp_source) -> false)) : @complete_space.{0} (has_emptyc.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_emptyc.{0} linarith.comp_source)) h1)  := sorry --non-trivial
lemma new_lemma_172464 (h0 : unsigned -> unsigned -> unsigned) : is_idempotent unsigned h0 := sorry --non-trivial
lemma new_lemma_172465 (h0 : topological_space (has_add (has_add (has_Inf linarith.comp)))) : locally_compact_space (has_add (has_add (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_172466 (h0 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} (with_one.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (with_one.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_172467 (h0 : functor.add_const Prop (boolean_algebra.core (comm_group (has_neg_part (has_add name))))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_172468 (h0 : topological_space (add_comm_monoid (sub_neg_monoid (sub_neg_monoid (sub_neg_monoid pos))))) : path_connected_space (add_comm_monoid (sub_neg_monoid (sub_neg_monoid (sub_neg_monoid pos)))) := sorry --non-trivial
lemma new_lemma_172469 (h0 : topological_space (generalized_boolean_algebra (ordered_comm_monoid pos))) : regular_space (generalized_boolean_algebra (ordered_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_172470 (h0 : topological_space (has_Inf (has_add linarith.comp))) : totally_disconnected_space (has_Inf (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_172471 (h0 : topological_space (has_pos_part (ring (ring (ring name))))) : totally_disconnected_space (has_pos_part (ring (ring (ring name)))) := sorry --non-trivial
lemma new_lemma_172472 (h0 : function.extfun Type (functor.comp cancel_comm_monoid_with_zero mul_zero_class)) : @unique_factorization_monoid.{0} (mul_zero_class.{0} pos) (@functor.comp.run.{0 0 0} cancel_comm_monoid_with_zero.{0} mul_zero_class.{0} pos (@functor.comp.run.{0 0 0} cancel_comm_monoid_with_zero.{0} mul_zero_class.{0} pos (@functor.comp.run.{0 0 0} cancel_comm_monoid_with_zero.{0} mul_zero_class.{0} pos (@functor.comp.run.{0 0 0} cancel_comm_monoid_with_zero.{0} mul_zero_class.{0} pos (@functor.comp.run.{0 0 0} cancel_comm_monoid_with_zero.{0} mul_zero_class.{0} pos (@functor.comp.run.{0 0 0} cancel_comm_monoid_with_zero.{0} mul_zero_class.{0} pos (@functor.comp.run.{0 0 0} cancel_comm_monoid_with_zero.{0} mul_zero_class.{0} pos (@functor.comp.run.{0 0 0} cancel_comm_monoid_with_zero.{0} mul_zero_class.{0} pos (@functor.comp.run.{0 0 0} cancel_comm_monoid_with_zero.{0} mul_zero_class.{0} pos (@functor.comp.run.{0 0 0} cancel_comm_monoid_with_zero.{0} mul_zero_class.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} cancel_comm_monoid_with_zero.{0} mul_zero_class.{0}) h0 pos)))))))))))  := sorry --non-trivial
lemma new_lemma_172473 (h0 : functor.add_const (complete_lattice (linear_ordered_cancel_comm_monoid empty)) num) : @complete_lattice.is_Sup_finite_compact.{0} (linear_ordered_cancel_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (linear_ordered_cancel_comm_monoid.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_172474 (h0 : complete_lattice (canonically_linear_ordered_monoid (has_neg name))) : is_atomistic (canonically_linear_ordered_monoid (has_neg name)) := sorry --non-trivial
lemma new_lemma_172475 (h0 : complete_lattice (comm_semigroup (comm_semigroup (has_neg (has_neg name))))) : is_compactly_generated (comm_semigroup (comm_semigroup (has_neg (has_neg name)))) := sorry --non-trivial
lemma new_lemma_172476 (h0 : functor.comp complete_lattice comm_group environment.implicit_infer_kind) : @is_atomistic.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} complete_lattice.{0} comm_group.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_172477 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (linear_ordered_cancel_comm_monoid.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_cancel_comm_monoid.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_172478 (h0 : topological_space (has_sub (parser num))) : totally_disconnected_space (has_sub (parser num)) := sorry --non-trivial
lemma new_lemma_172479 (h0 : ring (ring (comm_group unsigned))) : strong_rank_condition (ring (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_172480 (h0 : ring (encodable (has_nnnorm (has_inv linarith.ineq)))) : rank_condition (encodable (has_nnnorm (has_inv linarith.ineq))) := sorry --non-trivial
lemma new_lemma_172481 (h0 : functor.add_const (add_group (mul_zero_class empty)) empty) : @is_add_cyclic.{0} (mul_zero_class.{0} empty) (@functor.add_const.run.{0 0} (add_group.{0} (mul_zero_class.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_172482 (h1 : not (topological_space (has_union linarith.comp) -> false)) : @locally_compact_space.{0} (has_union.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (has_union.{0} linarith.comp)) h1)  := sorry --non-trivial
lemma new_lemma_172483 (h0 : has_mem.mem linarith.comp has_emptyc.emptyc) : @irreducible_space.{0} linarith.comp (@finset.pi.empty.{1 0} Type topological_space.{0} linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_172484 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem complete_lattice)) : @is_compactly_generated.{0} (has_emptyc.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) complete_lattice.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_emptyc.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_172485 (h0 : topological_space (normed_lattice_add_comm_group (has_add (has_Inf Type)))) : path_connected_space (normed_lattice_add_comm_group (has_add (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_172486 (h0 : topological_space (has_Inf (has_neg pos))) : irreducible_space (has_Inf (has_neg pos)) := sorry --non-trivial
lemma new_lemma_172487 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (has_ssubset.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_ssubset.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_172488 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (has_top.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_top.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_172489 (h0 : list (has_nndist (has_Inf (has_Inf (has_Inf Type))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_172490 (h0 : topological_space (linear_ordered_add_comm_group (random_gen linarith.ineq))) : path_connected_space (linear_ordered_add_comm_group (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_172491 (h0 : topological_space (semigroup (option pos))) : preconnected_space (semigroup (option pos)) := sorry --non-trivial
lemma new_lemma_172492 (h1 : function.extfun Type topological_space) : @totally_separated_space.{0} congr_arg_kind (@function.extfun_app.{2 1} Type topological_space.{0} h1 congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_172493 (h0 : functor.add_const (topological_space (linear_ordered_comm_group ennreal)) ennreal) : @preirreducible_space.{0} (linear_ordered_comm_group.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_comm_group.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_172494 (h0 : ring (measure_theory.measure_space (semiring (semiring congr_arg_kind)))) : is_principal_ideal_ring (measure_theory.measure_space (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_172495 (h0 : topological_space (has_neg (boolean_algebra environment.implicit_infer_kind))) : sequential_space (has_neg (boolean_algebra environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_172496 (h0 : ring (comm_ring (has_ssubset (has_ssubset string_imp)))) : is_domain (comm_ring (has_ssubset (has_ssubset string_imp))) := sorry --non-trivial
lemma new_lemma_172497 (h0 : add_monoid (comm_group (comm_group ennreal))) : add_monoid.fg (comm_group (comm_group ennreal)) := sorry --non-trivial
lemma new_lemma_172498 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_simple_group.{0} (has_neg.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_neg.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_172499 (h0 : functor.comp (functor.add_const (ring (canonically_ordered_comm_semiring ennreal))) mul_zero_class unsigned) : @strong_rank_condition.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@functor.add_const.run.{0 0} (ring.{0} (canonically_ordered_comm_semiring.{0} ennreal)) (mul_zero_class.{0} unsigned) (@functor.comp.run.{0 0 0} (functor.add_const.{0 0} (ring.{0} (canonically_ordered_comm_semiring.{0} ennreal))) mul_zero_class.{0} unsigned h0))  := sorry --non-trivial
lemma new_lemma_172500 (h0 : functor.add_const (filter (has_to_string Type)) pos) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_172501 (h0 : add_group (with_one (has_inv linarith.comp_source))) : is_add_cyclic (with_one (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_172502 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (dlist.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (dlist.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_172503 (h0 : topological_space (linear_order num)) : locally_compact_space (linear_order num) := sorry --non-trivial
lemma new_lemma_172504 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_172505 (h0 : functor.add_const (function.extfun Type group) Type) : @is_simple_group.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type group.{0}) Type h0) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_172506 (h0 : add_monoid (complete_semilattice_Sup congr_arg_kind)) : add_monoid.fg (complete_semilattice_Sup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_172507 (h0 : topological_space real) : totally_disconnected_space real := sorry --non-trivial
lemma new_lemma_172508 (h0 : filter (cancel_monoid linarith.comp)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_172509 (h0 : topological_space (linear_ordered_comm_group_with_zero (mul_one_class fun_info))) : path_connected_space (linear_ordered_comm_group_with_zero (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_172510 (h0 : topological_space (normed_group empty)) : discrete_topology (normed_group empty) := sorry --non-trivial
lemma new_lemma_172511 (h0 : group (comm_semigroup (sub_neg_monoid real))) : group.fg (comm_semigroup (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_172512 (h1 : topological_space (mul_one_class (normed_field (add_comm_semigroup ereal)))) (h2 : set (mul_one_class (normed_field (add_comm_semigroup ereal)))) : is_path_connected h2 := sorry --non-trivial
lemma new_lemma_172513 (h0 : ring (has_top empty)) : is_domain (has_top empty) := sorry --non-trivial
lemma new_lemma_172514 (h0 : fin has_zero.zero) : @preconnected_space.{0} (complete_distrib_lattice.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (complete_distrib_lattice.{0} pos)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_172515 (h0 : functor.add_const (finset (boolean_algebra pos)) Type) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_172516 (h0 : group (canonically_linear_ordered_monoid ennreal)) : group.fg (canonically_linear_ordered_monoid ennreal) := sorry --non-trivial
lemma new_lemma_172517 (h0 : ordered_comm_monoid (comm_semigroup (ordered_comm_monoid real))) : has_exists_mul_of_le (comm_semigroup (ordered_comm_monoid real)) := sorry --non-trivial
lemma new_lemma_172518 (h0 : finset (monoid congr_arg_kind)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_172519 (h0 : complete_lattice (boolean_algebra (has_add environment.implicit_infer_kind))) : is_compactly_generated (boolean_algebra (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_172520 (h0 : uniform_space (has_nndist (finset environment.implicit_infer_kind))) : complete_space (has_nndist (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_172521 (h0 : functor.comp filter complete_distrib_lattice environment.implicit_infer_kind) : filter.ne_bot (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_172522 (h0 : ring (has_ssubset (has_ssubset (has_repr string_imp)))) : rank_condition (has_ssubset (has_ssubset (has_repr string_imp))) := sorry --non-trivial
lemma new_lemma_172523 (h0 : list (dlist (has_ssubset (has_ssubset (random_gen (has_ssubset (has_ssubset (random_gen fun_info)))))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_172524 (h0 : add_monoid (random_gen (random_gen linarith.comp))) : add_monoid.fg (random_gen (random_gen linarith.comp)) := sorry --non-trivial
lemma new_lemma_172525 (h0 : functor.add_const (functor.add_const (topological_space Type) Type) pos) : @locally_compact_space.{1} Type (@functor.add_const.run.{1 1} (topological_space.{1} Type) Type (@functor.add_const.run.{1 0} (functor.add_const.{1 1} (topological_space.{1} Type) Type) pos h0))  := sorry --non-trivial
lemma new_lemma_172526 (h2 : topological_space (normed_field to_additive.value_type)) : t0_space (normed_field to_additive.value_type) := sorry --non-trivial
lemma new_lemma_172527 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (complete_distrib_lattice name)) := sorry --non-trivial
lemma new_lemma_172528 (h0 : ring (measurable_space.dynkin_system (semiring (semiring unsigned)))) : is_domain (measurable_space.dynkin_system (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_172529 (h1 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (with_one.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (with_one.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_172530 (h0 : functor.add_const (monoid (has_add environment.implicit_infer_kind)) environment.implicit_infer_kind) : @monoid.fg.{0} (has_add.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (monoid.{0} (has_add.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_172531 (h0 : semiring (linear_ordered_semiring (semiring (has_top num)))) : is_noetherian_ring (linear_ordered_semiring (semiring (has_top num))) := sorry --non-trivial
lemma new_lemma_172532 (h0 : not (filter (has_compl to_additive.value_type) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_172533 (h0 : add_monoid (with_one (with_bot empty))) : add_monoid.fg (with_one (with_bot empty)) := sorry --non-trivial
lemma new_lemma_172534 (h0 : topological_space (left_cancel_monoid num)) : preirreducible_space (left_cancel_monoid num) := sorry --non-trivial
lemma new_lemma_172535 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (with_bot.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (with_bot.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_172536 (h0 : topological_space (cancel_monoid (finset name))) : preconnected_space (cancel_monoid (finset name)) := sorry --non-trivial
lemma new_lemma_172537 (h0 : not (uniform_space (normed_group linarith.ineq) -> false)) : @complete_space.{0} (normed_group.{0} linarith.ineq) (@classical.by_contradiction'.{1} (uniform_space.{0} (normed_group.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_172538 (h0 : functor.add_const (topological_space (complete_distrib_lattice linarith.comp)) linarith.comp) : @preconnected_space.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_172539 (h0 : ring (with_bot (random_gen (random_gen (random_gen fun_info))))) : is_domain (with_bot (random_gen (random_gen (random_gen fun_info)))) := sorry --non-trivial
lemma new_lemma_172540 (h0 : function.extfun Type (functor.add_const (list pos))) : list.nodup (functor.add_const.run (function.extfun_app h0 pos)) := sorry --non-trivial
lemma new_lemma_172541 (h0 : function.extfun Type group) : @normalizer_condition.{0} (canonically_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type group.{0} h0 (canonically_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_172542 (h0 : ring (nondiscrete_normed_field (add_comm_semigroup (add_comm_semigroup ereal)))) : strong_rank_condition (nondiscrete_normed_field (add_comm_semigroup (add_comm_semigroup ereal))) := sorry --non-trivial
lemma new_lemma_172543 (h0 : group (linear_ordered_semiring (add_group num))) : is_cyclic (linear_ordered_semiring (add_group num)) := sorry --non-trivial
lemma new_lemma_172544 (h0 : ordered_add_comm_monoid char) : has_exists_add_of_le char := sorry --non-trivial
lemma new_lemma_172545 (h0 : not (topological_space (with_one (has_norm (has_norm fun_info))) -> false)) : @irreducible_space.{0} (with_one.{0} (has_norm.{0} (has_norm.{0} fun_info))) (@classical.by_contradiction'.{1} (topological_space.{0} (with_one.{0} (has_norm.{0} (has_norm.{0} fun_info)))) h0)  := sorry --non-trivial
lemma new_lemma_172546 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @irreducible_space.{0} congr_arg_kind (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_172547 (h0 : functor.add_const (function.extfun (Type 1) topological_space) Type) : @t0_space.{1} Type (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) Type h0) Type)  := sorry --non-trivial
lemma new_lemma_172548 (h0 : topological_space (linear_ordered_field congr_arg_kind)) : path_connected_space (linear_ordered_field congr_arg_kind) := sorry --non-trivial
lemma new_lemma_172549 (h0 : ring (distrib (comm_ring (comm_ring (comm_ring char))))) : rank_condition (distrib (comm_ring (comm_ring (comm_ring char)))) := sorry --non-trivial
lemma new_lemma_172550 (h0 : monoid (has_Sup (option unsigned))) : monoid.fg (has_Sup (option unsigned)) := sorry --non-trivial
lemma new_lemma_172551 (h1 : ring (denumerable linarith.comp_source)) : rank_condition (denumerable linarith.comp_source) := sorry --non-trivial
lemma new_lemma_172552 (h0 : functor.add_const (semiring (cancel_monoid name)) name) : @is_noetherian_ring.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (semiring.{0} (cancel_monoid.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_172553 (h0 : topological_space (distrib_lattice (has_norm to_additive.value_type))) : path_connected_space (distrib_lattice (has_norm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_172554 (h0 : functor.add_const (topological_space (has_Sup empty)) empty) : @discrete_topology.{0} (has_Sup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Sup.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_172555 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (topological_space.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (topological_space.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_172556 (h0 : topological_space (normed_linear_ordered_group num)) : irreducible_space (normed_linear_ordered_group num) := sorry --non-trivial
lemma new_lemma_172557 (h0 : topological_space (has_nndist (option pos))) : topological_space.separable_space (has_nndist (option pos)) := sorry --non-trivial
lemma new_lemma_172558 (h0 : complete_lattice (has_emptyc (has_top (has_top (has_top (has_top linarith.ineq)))))) : is_atomistic (has_emptyc (has_top (has_top (has_top (has_top linarith.ineq))))) := sorry --non-trivial
lemma new_lemma_172559 (h0 : topological_space (ordered_comm_ring (boolean_algebra Type))) : preirreducible_space (ordered_comm_ring (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_172560 (h0 : filter (linear_ordered_semiring (semiring (semiring (semiring num))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_172561 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @monoid.fg.{0} (has_top.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) monoid.{0}) (has_top.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_172562 (h0 : prod (normed_comm_ring (option (option (option empty)))) (normed_comm_ring (option (option (option empty))))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_172563 (h0 : function.extfun Type ring) : @rank_condition.{0} (linear_order.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_order.{0} num))  := sorry --non-trivial
lemma new_lemma_172564 (h3 : topological_space (distrib (denumerable fun_info))) : totally_disconnected_space (distrib (denumerable fun_info)) := sorry --non-trivial
lemma new_lemma_172565 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (omega_complete_partial_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type monoid.{0} h0 (omega_complete_partial_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_172566 (h0 : ring (normed_comm_ring (option empty))) : rank_condition (normed_comm_ring (option empty)) := sorry --non-trivial
lemma new_lemma_172567 (h0 : reducibility_hints -> Prop) : exists_unique h0 := sorry --non-trivial
lemma new_lemma_172568 (h0 : filter (canonically_ordered_comm_semiring pos)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_172569 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 congr_arg_kind) := sorry --non-trivial
lemma new_lemma_172570 (h0 : not (ring (add_cancel_comm_monoid fun_info) -> false)) : @is_domain.{0} (add_cancel_comm_monoid.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (add_cancel_comm_monoid.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_172571 (h0 : topological_space (comm_semigroup (sub_neg_monoid (has_add pos)))) : discrete_topology (comm_semigroup (sub_neg_monoid (has_add pos))) := sorry --non-trivial
lemma new_lemma_172572 (h0 : function.extfun Type group) : @is_simple_group.{0} (has_neg.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (has_neg.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_172573 (h0 : uniform_space (distrib (comm_ring (comm_ring linarith.comp_source)))) : complete_space (distrib (comm_ring (comm_ring linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_172574 (h0 : functor.add_const (topological_space auto.case_option) unsigned) : @normal_space.{0} auto.case_option (@functor.add_const.run.{0 0} (topological_space.{0} auto.case_option) unsigned h0)  := sorry --non-trivial
lemma new_lemma_172575 (h0 : fin has_zero.zero) : @is_compactly_generated.{0} (canonically_linear_ordered_monoid.{0} real) (@matrix.vec_empty.{0} (complete_lattice.{0} (canonically_linear_ordered_monoid.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_172576 (h0 : topological_space (finset unsigned)) : totally_separated_space (finset unsigned) := sorry --non-trivial
lemma new_lemma_172577 (h0 : functor.add_const (topological_space (complete_distrib_lattice Type)) name) : @totally_separated_space.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (complete_distrib_lattice.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_172578 (h0 : uniform_space (generalized_boolean_algebra name)) : separated_space (generalized_boolean_algebra name) := sorry --non-trivial
lemma new_lemma_172579 (h0 : complete_lattice (measurable_space (has_norm to_additive.value_type))) : is_compactly_generated (measurable_space (has_norm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_172580 (h0 : functor.add_const (ring (cancel_monoid Type)) Type) : @is_principal_ideal_ring.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 1} (ring.{1} (cancel_monoid.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_172581 (h0 : complete_lattice (has_nndist unsigned)) : is_compactly_generated (has_nndist unsigned) := sorry --non-trivial
lemma new_lemma_172582 (h0 : ring (non_assoc_semiring num)) : strong_rank_condition (non_assoc_semiring num) := sorry --non-trivial
lemma new_lemma_172583 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (group_with_zero.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (group_with_zero.{0} num))  := sorry --non-trivial
lemma new_lemma_172584 (h0 : semiring (ring (has_to_string (ring (ring Type))))) : is_noetherian_ring (ring (has_to_string (ring (ring Type)))) := sorry --non-trivial
lemma new_lemma_172585 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_172586 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (non_assoc_semiring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (non_assoc_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_172587 (h0 : fin has_zero.zero) : @is_principal_ideal_ring.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@matrix.vec_empty.{2} (function.extfun.{3 2} (Type 1) ring.{1}) h0) (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_172588 (h0 : topological_space (linear_ordered_field (option pos))) : t0_space (linear_ordered_field (option pos)) := sorry --non-trivial
lemma new_lemma_172589 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (has_one.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_one.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_172590 (h0 : functor.add_const (list (boolean_algebra Type)) linarith.comp) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_172591 (h0 : ordered_add_comm_monoid (sub_neg_monoid (option unsigned))) : archimedean (sub_neg_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_172592 (h0 : not (function.extfun Type complete_lattice -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (complete_semilattice_Sup.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (complete_semilattice_Sup.{0} empty))  := sorry --non-trivial
lemma new_lemma_172593 (h0 : complete_lattice (normed_lattice_add_comm_group pos)) : is_compactly_generated (normed_lattice_add_comm_group pos) := sorry --non-trivial
lemma new_lemma_172594 (h0 : topological_space (has_neg (option pos))) : preconnected_space (has_neg (option pos)) := sorry --non-trivial
lemma new_lemma_172595 (h0 : std_gen -> std_gen) (h1 : std_gen) : function.is_fixed_pt h0 h1 := sorry --non-trivial
lemma new_lemma_172596 (h0 : function.extfun Type (functor.add_const (cancel_comm_monoid_with_zero auto.case_option))) : @unique_factorization_monoid.{0} auto.case_option (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} auto.case_option) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (cancel_comm_monoid_with_zero.{0} auto.case_option)) h0 num))  := sorry --non-trivial
lemma new_lemma_172597 (h0 : topological_space (has_add (option ennreal))) : path_connected_space (has_add (option ennreal)) := sorry --non-trivial
lemma new_lemma_172598 (h0 : has_neg num -> has_neg num -> Prop) : is_irrefl (has_neg num) h0 := sorry --non-trivial
lemma new_lemma_172599 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (@id.{2} Type unsigned) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (@id.{2} Type unsigned))  := sorry --non-trivial
lemma new_lemma_172600 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @irreducible_space.{0} (has_pos_part.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (has_pos_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_172601 (h0 : filter (add_comm_monoid (option num))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_172602 (h0 : functor.add_const (topological_space (boolean_algebra.core unsigned)) pos) : @preirreducible_space.{0} (boolean_algebra.core.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_172603 (h0 : ordered_comm_monoid (cancel_monoid (has_add environment.implicit_infer_kind))) : has_exists_mul_of_le (cancel_monoid (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_172604 (h0 : ring (has_lt reducibility_hints)) : rank_condition (has_lt reducibility_hints) := sorry --non-trivial
lemma new_lemma_172605 (h0 : ordered_add_comm_monoid (add_semigroup empty)) : archimedean (add_semigroup empty) := sorry --non-trivial
lemma new_lemma_172606 (h0 : uniform_space (has_neg (has_neg (finset Type)))) : separated_space (has_neg (has_neg (finset Type))) := sorry --non-trivial
lemma new_lemma_172607 (h0 : topological_space (ordered_comm_monoid (has_neg Type))) : totally_separated_space (ordered_comm_monoid (has_neg Type)) := sorry --non-trivial
lemma new_lemma_172608 (h0 : functor.add_const (topological_space (comm_group name)) linarith.comp) : @normal_space.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_172609 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_172610 (h0 : functor.comp cancel_comm_monoid_with_zero has_to_string linarith.comp) : @unique_factorization_monoid.{0} (has_to_string.{0} linarith.comp) (@functor.comp.run.{0 0 0} cancel_comm_monoid_with_zero.{0} has_to_string.{0} linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_172611 (h0 : ring (has_bot (has_Inf real))) : is_principal_ideal_ring (has_bot (has_Inf real)) := sorry --non-trivial
lemma new_lemma_172612 (h0 : add_monoid (normed_comm_ring (ring pos))) : add_monoid.fg (normed_comm_ring (ring pos)) := sorry --non-trivial
lemma new_lemma_172613 (h1 : std_gen -> std_gen) (h2 : std_gen) : function.periodic_pts h1 h2 := sorry --non-trivial
lemma new_lemma_172614 (h0 : group (omega_complete_partial_order (option unsigned))) : is_cyclic (omega_complete_partial_order (option unsigned)) := sorry --non-trivial
lemma new_lemma_172615 (h0 : function.extfun (finset Type) (has_mem.mem (semiring fun_info))) : @totally_separated_space.{0} (semiring.{0} fun_info) (@finset.pi.empty.{1 0} Type topological_space.{0} (semiring.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_172616 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (has_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (has_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_172617 (h0 : functor.comp list finset unsigned) : palindrome (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_172618 (h0 : add_monoid (complete_semilattice_Sup num)) : add_monoid.fg (complete_semilattice_Sup num) := sorry --non-trivial
lemma new_lemma_172619 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_add.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} name))  := sorry --non-trivial
lemma new_lemma_172620 (h0 : group (normed_group (has_nnnorm (random_gen to_additive.value_type)))) : group.fg (normed_group (has_nnnorm (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_172621 (h0 : functor.add_const (ordered_add_comm_monoid (has_nndist name)) name) : @archimedean.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_nndist.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_172622 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (linear_ordered_comm_ring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_172623 (h1 : topological_space (has_emptyc (has_emptyc linarith.ineq))) : irreducible_space (has_emptyc (has_emptyc linarith.ineq)) := sorry --non-trivial
lemma new_lemma_172624 (h0 : group (has_add (has_to_string (finset Type)))) : is_simple_group (has_add (has_to_string (finset Type))) := sorry --non-trivial
lemma new_lemma_172625 (h0 : functor.add_const (semiring (mul_zero_class environment.implicit_infer_kind)) Type) : @is_noetherian_ring.{0} (mul_zero_class.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (semiring.{0} (mul_zero_class.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_172626 (h0 : functor.add_const (group (plift unsigned)) unsigned) : @normalizer_condition.{1} (plift.{1} unsigned) (@functor.add_const.run.{1 0} (group.{1} (plift.{1} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_172627 (h0 : functor.add_const (monoid (boolean_algebra pos)) (has_neg Type)) : @monoid.fg.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 1} (monoid.{0} (boolean_algebra.{0} pos)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_172628 (h0 : functor.add_const (group (boolean_algebra.core name)) linarith.comp) : @is_simple_group.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.core.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_172629 (h0 : complete_lattice (normed_comm_ring name)) : complete_lattice.is_Sup_finite_compact (normed_comm_ring name) := sorry --non-trivial
lemma new_lemma_172630 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @topological_space.separable_space.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_172631 (h0 : topological_space (has_norm (metric_space fun_info))) : path_connected_space (has_norm (metric_space fun_info)) := sorry --non-trivial
lemma new_lemma_172632 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @normal_space.{0} (has_nndist.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (has_nndist.{0} name))  := sorry --non-trivial
lemma new_lemma_172633 (h0 : group (has_well_founded (has_inv linarith.comp_source))) : is_cyclic (has_well_founded (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_172634 (h0 : topological_space (has_neg_part (comm_group unsigned))) : loc_path_connected_space (has_neg_part (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_172635 (h0 : functor.add_const (complete_lattice (boolean_algebra name)) Type) : @is_atomistic.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 1} (complete_lattice.{0} (boolean_algebra.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_172636 (h0 : uniform_space (with_bot (has_top linarith.ineq))) : complete_space (with_bot (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_172637 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (with_one fun_info)) := sorry --non-trivial
lemma new_lemma_172638 (h0 : functor.add_const (ring (measurable_space.dynkin_system name)) pos) : @is_domain.{0} (measurable_space.dynkin_system.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (measurable_space.dynkin_system.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_172639 (h0 : topological_space (add_comm_monoid (option pos))) : preconnected_space (add_comm_monoid (option pos)) := sorry --non-trivial
lemma new_lemma_172640 (h0 : functor.add_const (group (comm_group ennreal)) unsigned) : @is_cyclic.{0} (comm_group.{0} ennreal) (@functor.add_const.run.{0 0} (group.{0} (comm_group.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_172641 (h0 : function.extfun (((finset Type -> Prop) -> Prop) -> Prop) (function.extfun ((finset Type -> Prop) -> Prop))) : @complete_space.{0} (normed_group.{0} (has_inv.{0} (random_gen.{0} (has_inv.{0} (has_top.{0} linarith.ineq))))) (@finset.pi.empty.{1 0} Type uniform_space.{0} (normed_group.{0} (has_inv.{0} (random_gen.{0} (has_inv.{0} (has_top.{0} linarith.ineq))))) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (normed_group.{0} (has_inv.{0} (random_gen.{0} (has_inv.{0} (has_top.{0} linarith.ineq)))))) (@function.extfun_app.{2 0} (finset.{1} Type → Prop) (function.extfun.{2 0} (finset.{1} Type)) (@function.extfun_app.{2 0} ((finset.{1} Type → Prop) → Prop) (function.extfun.{2 0} (finset.{1} Type → Prop)) (@function.extfun_app.{2 0} (((finset.{1} Type → Prop) → Prop) → Prop) (function.extfun.{2 0} ((finset.{1} Type → Prop) → Prop)) h0 (function.extfun.{2 0} (finset.{1} Type → Prop))) (function.extfun.{2 0} (finset.{1} Type))) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (normed_group.{0} (has_inv.{0} (random_gen.{0} (has_inv.{0} (has_top.{0} linarith.ineq))))))) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_172642 (h0 : topological_space (denumerable fun_info)) : path_connected_space (denumerable fun_info) := sorry --non-trivial
lemma new_lemma_172643 (h0 : group (random_gen (has_norm empty))) : normalizer_condition (random_gen (has_norm empty)) := sorry --non-trivial
lemma new_lemma_172644 (h0 : functor.add_const (function.extfun (Type 1) ring) (ring Type)) : @strong_rank_condition.{1} (add_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) ring.{1}) (ring.{1} Type) h0) (add_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_172645 (h0 : functor.add_const (complete_lattice (comm_group Type)) (finset (finset pos))) : @is_compactly_generated.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (comm_group.{1} Type)) (finset.{0} (finset.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_172646 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (omega_complete_partial_order.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (omega_complete_partial_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_172647 (h0 : function.extfun (finset Type) (has_mem.mem (semiring linarith.ineq))) : @locally_compact_space.{0} (semiring.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type topological_space.{0} (semiring.{0} linarith.ineq) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} linarith.ineq)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_172648 (h0 : topological_space (plift (metric_space congr_arg_kind))) : locally_compact_space (plift (metric_space congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_172649 (h0 : function.extfun Type ring) : @is_domain.{0} (with_bot.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_inv.{0} fun_info))))))) (@function.extfun_app.{2 1} Type ring.{0} h0 (with_bot.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_inv.{0} fun_info))))))))  := sorry --non-trivial
lemma new_lemma_172650 (h0 : functor.add_const (uniform_space (normed_comm_ring linarith.comp)) (finset pos)) : @separated_space.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (normed_comm_ring.{0} linarith.comp)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_172651 (h0 : add_group (has_bot Type)) : is_add_cyclic (has_bot Type) := sorry --non-trivial
lemma new_lemma_172652 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (left_cancel_monoid empty)) := sorry --non-trivial
lemma new_lemma_172653 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} (semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) (semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_172654 (h0 : ring (has_div ereal)) : is_domain (has_div ereal) := sorry --non-trivial
lemma new_lemma_172655 (h0 : functor.add_const (group (semigroup unsigned)) Type) : @group.fg.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 1} (group.{0} (semigroup.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_172656 (h0 : topological_space (generalized_boolean_algebra (has_scalar Type real))) : regular_space (generalized_boolean_algebra (has_scalar Type real)) := sorry --non-trivial
lemma new_lemma_172657 (h0 : uniform_space (semigroup (has_add linarith.comp))) : complete_space (semigroup (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_172658 (h0 : function.extfun (finset Type) (has_mem.mem (complete_semilattice_Sup empty))) : @discrete_topology.{0} (complete_semilattice_Sup.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (complete_semilattice_Sup.{0} empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (complete_semilattice_Sup.{0} empty)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_172659 (h0 : topological_space (omega_complete_partial_order (semiring empty))) : t1_space (omega_complete_partial_order (semiring empty)) := sorry --non-trivial
lemma new_lemma_172660 (h0 : string_imp -> string_imp -> Prop) : is_total_preorder string_imp h0 := sorry --non-trivial
lemma new_lemma_172661 (h0 : topological_space (normed_group (canonically_ordered_comm_semiring to_additive.value_type))) : path_connected_space (normed_group (canonically_ordered_comm_semiring to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_172662 (h0 : group (add_group (has_norm linarith.comp))) : is_cyclic (add_group (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_172663 (h0 : topological_space (has_le ereal)) (h1 : add_group (has_le ereal)) : topological_add_group (has_le ereal) := sorry --non-trivial
lemma new_lemma_172664 (h0 : functor.add_const (ordered_add_comm_monoid (ring unsigned)) num) : @archimedean.{0} (ring.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (ring.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_172665 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (complete_semilattice_Sup.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (complete_semilattice_Sup.{0} num))  := sorry --non-trivial
lemma new_lemma_172666 (h0 : not (uniform_space name -> false)) : @separated_space.{0} name (@classical.by_contradiction'.{1} (uniform_space.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_172667 (h0 : function.extfun Type ring) : @rank_condition.{0} (normed_comm_ring.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (normed_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_172668 (h0 : topological_space (complete_distrib_lattice (has_Inf (ring (has_add (has_nndist Type)))))) : sequential_space (complete_distrib_lattice (has_Inf (ring (has_add (has_nndist Type))))) := sorry --non-trivial
lemma new_lemma_172669 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (linear_ordered_semiring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_172670 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (measure_theory.measure_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (measure_theory.measure_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_172671 (h1 : not (topological_space linarith.comp_source -> false)) : @totally_disconnected_space.{0} linarith.comp_source (@classical.by_contradiction'.{1} (topological_space.{0} linarith.comp_source) h1)  := sorry --non-trivial
lemma new_lemma_172672 (h0 : finset nat) (h1 : finset.nonempty h0) (h2 : fin (nat.succ (finset.min' h0 h1)) -> Prop) (h3 : fin (finset.min' h0 h1)) : matrix.vec_tail h2 h3 := sorry --non-trivial
lemma new_lemma_172673 (h0 : set (simple_graph (mul_one_class fun_info))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_172674 (h0 : add_group (has_Inf (has_add (sub_neg_monoid pos)))) : is_add_cyclic (has_Inf (has_add (sub_neg_monoid pos))) := sorry --non-trivial
lemma new_lemma_172675 (h0 : functor.add_const (ring (has_nndist Type)) (has_Inf pos)) : @rank_condition.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_nndist.{1} Type)) (has_Inf.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_172676 (h0 : topological_space (has_bot (has_neg pos))) : loc_path_connected_space (has_bot (has_neg pos)) := sorry --non-trivial
lemma new_lemma_172677 (h0 : topological_space (ordered_comm_monoid (has_add (has_add linarith.comp)))) : locally_compact_space (ordered_comm_monoid (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_172678 (h0 : ring (normed_comm_ring (ring (has_to_string Type)))) : strong_rank_condition (normed_comm_ring (ring (has_to_string Type))) := sorry --non-trivial
lemma new_lemma_172679 (h0 : not (complete_lattice (non_unital_non_assoc_semiring fun_info) -> false)) : @is_compactly_generated.{0} (non_unital_non_assoc_semiring.{0} fun_info) (@classical.by_contradiction'.{1} (complete_lattice.{0} (non_unital_non_assoc_semiring.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_172680 (h1 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (complete_semilattice_Sup.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} h1 (complete_semilattice_Sup.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_172681 (h0 : ring (has_ssubset (random_gen (has_nnnorm reducibility_hints)))) : strong_rank_condition (has_ssubset (random_gen (has_nnnorm reducibility_hints))) := sorry --non-trivial
lemma new_lemma_172682 (h0 : topological_space (linear_ordered_field name)) : irreducible_space (linear_ordered_field name) := sorry --non-trivial
lemma new_lemma_172683 (h1 : add_group (non_unital_non_assoc_semiring (set string_imp))) : is_add_cyclic (non_unital_non_assoc_semiring (set string_imp)) := sorry --non-trivial
lemma new_lemma_172684 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @monoid.fg.{0} (comm_semigroup.{0} pos) (@matrix.vec_empty.{0} (monoid.{0} (comm_semigroup.{0} pos)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_172685 (h0 : add_monoid (normed_comm_ring (has_add Type))) : add_monoid.fg (normed_comm_ring (has_add Type)) := sorry --non-trivial
lemma new_lemma_172686 (h0 : topological_space (linear_ordered_semiring (random_gen num))) : t0_space (linear_ordered_semiring (random_gen num)) := sorry --non-trivial
lemma new_lemma_172687 (h0 : not (ring (normed_field reducibility_hints) -> false)) : @rank_condition.{0} (normed_field.{0} reducibility_hints) (@classical.by_contradiction'.{1} (ring.{0} (normed_field.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_172688 (h0 : list (has_add (finset linarith.comp))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_172689 (h0 : set (set reducibility_hints)) (h1 : set reducibility_hints) : measurable_space.dynkin_system.generate_has h0 h1 := sorry --non-trivial
lemma new_lemma_172690 (h0 : topological_space (has_lt std_gen)) : path_connected_space (has_lt std_gen) := sorry --non-trivial
lemma new_lemma_172691 (h0 : uniform_space (semigroup (semiring num))) : complete_space (semigroup (semiring num)) := sorry --non-trivial
lemma new_lemma_172692 (h0 : functor.add_const (topological_space (boolean_algebra.core name)) name) : @preconnected_space.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_172693 (h0 : topological_space (ordered_comm_ring (has_pos_part Type))) : normal_space (ordered_comm_ring (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_172694 (h0 : topological_space (semigroup (normed_comm_ring (has_pos_part pos)))) : topological_space.separable_space (semigroup (normed_comm_ring (has_pos_part pos))) := sorry --non-trivial
lemma new_lemma_172695 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (complete_semilattice_Sup.{0} (comm_ring.{0} linarith.ineq)) (@function.extfun_app.{2 1} Type add_group.{0} h0 (complete_semilattice_Sup.{0} (comm_ring.{0} linarith.ineq)))  := sorry --non-trivial
lemma new_lemma_172696 (h0 : complete_lattice (has_to_string (has_neg environment.implicit_infer_kind))) : is_compactly_generated (has_to_string (has_neg environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_172697 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (has_pos_part.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_pos_part.{0} name))  := sorry --non-trivial
lemma new_lemma_172698 (h0 : topological_space (canonically_ordered_monoid (has_add pos))) : normal_space (canonically_ordered_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_172699 (h1 : not (ring (uniform_space string_imp) -> false)) : @is_domain.{0} (uniform_space.{0} string_imp) (@classical.by_contradiction'.{1} (ring.{0} (uniform_space.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_172700 (h0 : topological_space (finset (finset (has_add unsigned)))) : totally_disconnected_space (finset (finset (has_add unsigned))) := sorry --non-trivial
lemma new_lemma_172701 (h1 : group (has_top string_imp)) : group.fg (has_top string_imp) := sorry --non-trivial
lemma new_lemma_172702 (h0 : ordered_add_comm_monoid (has_Inf (ring (ring Type)))) : archimedean (has_Inf (ring (ring Type))) := sorry --non-trivial
lemma new_lemma_172703 (h0 : ring (complete_distrib_lattice (has_Inf (has_Inf Type)))) : strong_rank_condition (complete_distrib_lattice (has_Inf (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_172704 (h0 : topological_space (canonically_ordered_comm_semiring (boolean_algebra.core Type))) : preconnected_space (canonically_ordered_comm_semiring (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_172705 (h0 : ring (with_bot (random_gen congr_arg_kind))) : is_domain (with_bot (random_gen congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_172706 (h0 : set.set_semiring (semiring unsigned) -> congr_arg_kind -> Prop) : relator.bi_total h0 := sorry --non-trivial
lemma new_lemma_172707 (h0 : ordered_comm_monoid (cancel_monoid (option pos))) : has_exists_mul_of_le (cancel_monoid (option pos)) := sorry --non-trivial
lemma new_lemma_172708 (h0 : add_group (has_union linarith.comp)) : is_add_cyclic (has_union linarith.comp) := sorry --non-trivial
lemma new_lemma_172709 (h0 : functor.add_const (ordered_add_comm_monoid (finset name)) name) : @archimedean.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (finset.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_172710 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (linear_ordered_comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_172711 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (add_comm_monoid name)) := sorry --non-trivial
lemma new_lemma_172712 (h0 : complete_lattice (with_zero (has_inv fun_info))) : is_compactly_generated (with_zero (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_172713 (h0 : functor.add_const (ring (canonically_ordered_comm_semiring pos)) Type) : @rank_condition.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (canonically_ordered_comm_semiring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_172714 (h0 : group (has_pos_part (has_add name))) : is_simple_group (has_pos_part (has_add name)) := sorry --non-trivial
lemma new_lemma_172715 (h0 : functor.add_const (ring (has_add linarith.comp)) (has_neg Type)) : @rank_condition.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 1} (ring.{0} (has_add.{0} linarith.comp)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_172716 (h0 : ring (sub_neg_monoid (has_Inf pos))) : strong_rank_condition (sub_neg_monoid (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_172717 (h0 : list (measurable_space (has_norm (has_norm linarith.comp_source)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_172718 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} ennreal (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 ennreal)  := sorry --non-trivial
lemma new_lemma_172719 (h0 : topological_space (has_dist (option unsigned))) : irreducible_space (has_dist (option unsigned)) := sorry --non-trivial
lemma new_lemma_172720 (h0 : monoid (has_neg_part (normed_comm_ring environment.implicit_infer_kind))) : monoid.fg (has_neg_part (normed_comm_ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_172721 (h0 : ring (metric_space (has_norm (has_norm linarith.comp)))) : strong_rank_condition (metric_space (has_norm (has_norm linarith.comp))) := sorry --non-trivial
lemma new_lemma_172722 (h0 : functor.add_const (function.extfun Type ordered_comm_monoid) linarith.comp) : @has_exists_mul_of_le.{0} (normed_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) linarith.comp h0) (normed_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_172723 (h0 : topological_space (has_nnnorm (mul_one_class string.iterator_imp))) : totally_disconnected_space (has_nnnorm (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_172724 (h2 : not (topological_space (has_norm num) -> false)) : @path_connected_space.{0} (has_norm.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (has_norm.{0} num)) h2)  := sorry --non-trivial
lemma new_lemma_172725 (h0 : fin has_zero.zero) : @locally_compact_space.{1} (ordered_comm_ring.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (ordered_comm_ring.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_172726 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_172727 (h0 : topological_space (boolean_algebra.core congr_arg_kind)) : path_connected_space (boolean_algebra.core congr_arg_kind) := sorry --non-trivial
lemma new_lemma_172728 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (linear_ordered_comm_ring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_172729 (h0 : ring (has_ssubset (metric_space (metric_space char)))) : is_domain (has_ssubset (metric_space (metric_space char))) := sorry --non-trivial
lemma new_lemma_172730 (h0 : function.extfun nat fin) : @is_cyclic.{0} (has_add.{0} pos) (@matrix.vec_empty.{0} (group.{0} (has_add.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_172731 (h0 : add_monoid (ring (option (option (option (option (option empty))))))) : add_monoid.fg (ring (option (option (option (option (option empty)))))) := sorry --non-trivial
lemma new_lemma_172732 (h4 : complete_lattice (has_ssubset environment.projection_info)) : complete_lattice.is_Sup_finite_compact (has_ssubset environment.projection_info) := sorry --non-trivial
lemma new_lemma_172733 (h0 : topological_space (canonically_ordered_comm_semiring congr_arg_kind)) : normal_space (canonically_ordered_comm_semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_172734 (h0 : topological_space (has_emptyc (semiring (semiring (semiring linarith.comp))))) : totally_separated_space (has_emptyc (semiring (semiring (semiring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_172735 (h0 : ring (boolean_algebra (finset (finset (has_Inf pos))))) : strong_rank_condition (boolean_algebra (finset (finset (has_Inf pos)))) := sorry --non-trivial
lemma new_lemma_172736 (h0 : uniform_space (mul_zero_class (semiring (semiring (semiring (semiring congr_arg_kind)))))) : complete_space (mul_zero_class (semiring (semiring (semiring (semiring congr_arg_kind))))) := sorry --non-trivial
lemma new_lemma_172737 (h0 : uniform_space (complete_distrib_lattice (option empty))) : complete_space (complete_distrib_lattice (option empty)) := sorry --non-trivial
lemma new_lemma_172738 (h1 : topological_space (random_gen (random_gen to_additive.value_type))) : totally_separated_space (random_gen (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_172739 (h0 : functor.add_const (complete_lattice (add_comm_monoid name)) linarith.comp) : @complete_lattice.is_Sup_finite_compact.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_comm_monoid.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_172740 (h0 : functor.add_const (topological_space (has_dist num)) num) : @irreducible_space.{0} (has_dist.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (has_dist.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_172741 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (finset.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (finset.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_172742 (h0 : functor.add_const (function.extfun (Type 1) topological_space) Type) : @t0_space.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) Type h0) (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_172743 : is_empty true := sorry --nsimp
lemma new_lemma_172744 (h0 : topological_space (boolean_algebra (normed_linear_ordered_group (has_Inf (has_Inf pos))))) : path_connected_space (boolean_algebra (normed_linear_ordered_group (has_Inf (has_Inf pos)))) := sorry --non-trivial
lemma new_lemma_172745 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (complete_distrib_lattice.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_172746 (h0 : ring (ordered_cancel_add_comm_monoid ennreal)) : strong_rank_condition (ordered_cancel_add_comm_monoid ennreal) := sorry --non-trivial
lemma new_lemma_172747 (h0 : group (comm_group (add_comm_monoid pos))) : is_simple_group (comm_group (add_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_172748 (h0 : topological_space (boolean_algebra pos)) : topological_space.separable_space (boolean_algebra pos) := sorry --non-trivial
lemma new_lemma_172749 (h0 : uniform_space (semi_normed_comm_ring (random_gen (random_gen char)))) : complete_space (semi_normed_comm_ring (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_172750 (h0 : topological_space (boolean_algebra (has_add unsigned))) : normal_space (boolean_algebra (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_172751 (h0 : complete_lattice (add_monoid char)) : is_compactly_generated (add_monoid char) := sorry --non-trivial
lemma new_lemma_172752 (h0 : functor.add_const (topological_space (complete_distrib_lattice Type)) environment.implicit_infer_kind) : @t0_space.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (complete_distrib_lattice.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_172753 (h1 : has_lt (has_lt char)) : no_max_order (has_lt char) := sorry --non-trivial
lemma new_lemma_172754 (h2 : preorder (mul_one_class string.iterator_imp)) (h3 : set (mul_one_class string.iterator_imp)) : set.is_pwo h3 := sorry --non-trivial
lemma new_lemma_172755 (h0 : functor.add_const (complete_lattice (comm_group unsigned)) (has_to_string linarith.comp)) : @complete_lattice.is_Sup_finite_compact.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (comm_group.{0} unsigned)) (has_to_string.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_172756 (h0 : topological_space (measurable_space.dynkin_system (semiring (semiring congr_arg_kind)))) : normal_space (measurable_space.dynkin_system (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_172757 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type add_group.{0} h0 (boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_172758 (h0 : finset (has_star (semiring (semiring (semiring (semiring empty)))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_172759 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (pseudo_metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (pseudo_metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_172760 (h0 : topological_space (with_bot (semiring unsigned))) : locally_compact_space (with_bot (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_172761 (h0 : functor.add_const (topological_space (boolean_algebra pos)) linarith.comp) : @t0_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_172762 (h1 : not (topological_space (measurable_space congr_arg_kind) -> false)) : @path_connected_space.{0} (measurable_space.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (measurable_space.{0} congr_arg_kind)) h1)  := sorry --non-trivial
lemma new_lemma_172763 (h0 : topological_space (boolean_algebra (comm_group (comm_group environment.implicit_infer_kind)))) : normal_space (boolean_algebra (comm_group (comm_group environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_172764 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} (add_left_cancel_monoid.{0} linarith.ineq) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (add_left_cancel_monoid.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_172765 (h0 : add_group (id (random_gen (has_norm linarith.ineq)))) : is_add_cyclic (id (random_gen (has_norm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_172766 (h0 : ring (ordered_comm_ring linarith.comp)) : rank_condition (ordered_comm_ring linarith.comp) := sorry --non-trivial
lemma new_lemma_172767 (h0 : function.extfun (finset Type) (has_mem.mem (has_emptyc fun_info))) : @totally_disconnected_space.{0} (has_emptyc.{0} fun_info) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_emptyc.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_emptyc.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_172768 (h0 : topological_space (has_nndist (option (option unsigned)))) : normal_space (has_nndist (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_172769 (h0 : ring (semi_normed_comm_ring (random_gen linarith.comp_source))) : rank_condition (semi_normed_comm_ring (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_172770 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (with_one.{0} fun_info) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (with_one.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_172771 (h0 : topological_space (random_gen (has_union linarith.comp))) : totally_separated_space (random_gen (has_union linarith.comp)) := sorry --non-trivial
lemma new_lemma_172772 (h0 : functor.add_const (ring (canonically_ordered_comm_semiring ennreal)) ennreal) : @rank_condition.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@functor.add_const.run.{0 0} (ring.{0} (canonically_ordered_comm_semiring.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_172773 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (free_add_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_172774 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (topological_space.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (topological_space.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_172775 (h0 : group (has_top (random_gen fun_info))) : group.fg (has_top (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_172776 (h0 : add_monoid (has_nndist ennreal)) : add_monoid.fg (has_nndist ennreal) := sorry --non-trivial
lemma new_lemma_172777 (h0 : topological_space (canonically_linear_ordered_monoid (option (option unsigned)))) : totally_disconnected_space (canonically_linear_ordered_monoid (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_172778 (h0 : topological_space (has_to_string pos)) : preirreducible_space (has_to_string pos) := sorry --non-trivial
lemma new_lemma_172779 (h0 : function.extfun Type (functor.comp ring has_neg)) : @rank_condition.{0} (has_neg.{0} pos) (@functor.comp.run.{0 0 0} ring.{0} has_neg.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} ring.{0} has_neg.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_172780 (h0 : not (function.extfun Type complete_lattice -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (semiring.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_172781 (h0 : topological_space (has_inv (has_top linarith.ineq))) : path_connected_space (has_inv (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_172782 (h0 : monoid (with_bot string_imp)) : monoid.fg (with_bot string_imp) := sorry --non-trivial
lemma new_lemma_172783 (h0 : topological_space (add_group (has_norm (linear_ordered_semiring unsigned)))) : path_connected_space (add_group (has_norm (linear_ordered_semiring unsigned))) := sorry --non-trivial
lemma new_lemma_172784 (h0 : group (comm_ring (comm_ring linarith.ineq))) : is_cyclic (comm_ring (comm_ring linarith.ineq)) := sorry --non-trivial
lemma new_lemma_172785 (h0 : topological_space (option (mul_zero_class (option congr_arg_kind)))) : discrete_topology (option (mul_zero_class (option congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_172786 (h0 : not (topological_space (uniform_space string.iterator_imp) -> false)) : @totally_disconnected_space.{0} (uniform_space.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (topological_space.{0} (uniform_space.{0} string.iterator_imp)) h0)  := sorry --non-trivial
lemma new_lemma_172787 (h0 : ordered_add_comm_monoid (canonically_ordered_monoid (has_Inf (has_neg pos)))) : archimedean (canonically_ordered_monoid (has_Inf (has_neg pos))) := sorry --non-trivial
lemma new_lemma_172788 (h0 : functor.add_const (function.extfun (Type 1) list) Type) : list.nodup (function.extfun_app (functor.add_const.run h0) (comm_group Type)) := sorry --non-trivial
lemma new_lemma_172789 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (generalized_boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (generalized_boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_172790 (h0 : filter (non_assoc_semiring (semiring empty))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_172791 (h0 : functor.add_const (ring (boolean_algebra pos)) linarith.comp) : @strong_rank_condition.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_172792 (h0 : add_group (normed_field (semigroup linarith.comp_source))) : is_add_cyclic (normed_field (semigroup linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_172793 (h0 : ring (linear_order (semiring empty))) : is_domain (linear_order (semiring empty)) := sorry --non-trivial
lemma new_lemma_172794 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_norm.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_norm.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_172795 (h0 : topological_space (normed_group (random_gen (random_gen linarith.ineq)))) : locally_compact_space (normed_group (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_172796 (h1 : not (complete_lattice (semiring linarith.comp_source) -> false)) : @is_compactly_generated.{0} (semiring.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (complete_lattice.{0} (semiring.{0} linarith.comp_source)) h1)  := sorry --non-trivial
lemma new_lemma_172797 (h0 : functor.add_const (topological_space (simple_graph pos)) linarith.comp) : @locally_compact_space.{0} (simple_graph.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (simple_graph.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_172798 (h0 : add_group (has_to_string (finset Type))) : is_add_cyclic (has_to_string (finset Type)) := sorry --non-trivial
lemma new_lemma_172799 (h0 : functor.add_const (monoid (ordered_cancel_add_comm_monoid num)) ennreal) : @monoid.fg.{0} (ordered_cancel_add_comm_monoid.{0} num) (@functor.add_const.run.{0 0} (monoid.{0} (ordered_cancel_add_comm_monoid.{0} num)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_172800 (h1 : group (has_top (with_one linarith.ineq))) : is_cyclic (has_top (with_one linarith.ineq)) := sorry --non-trivial
lemma new_lemma_172801 (h0 : set (comm_ring linarith.comp_source)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_172802 (h0 : list (complete_linear_order (semiring (semiring num)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_172803 (h0 : not (uniform_space (has_compl linarith.comp_source) -> false)) : @complete_space.{0} (has_compl.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_compl.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_172804 (h0 : topological_space (cancel_monoid (has_add name))) : sequential_space (cancel_monoid (has_add name)) := sorry --non-trivial
lemma new_lemma_172805 (h0 : has_mem.mem (has_emptyc linarith.comp_source) has_emptyc.emptyc) : @discrete_topology.{0} (has_emptyc.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_emptyc.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_172806 (h0 : functor.add_const (semiring (ordered_comm_ring linarith.comp)) pos) : @is_noetherian_ring.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (semiring.{0} (ordered_comm_ring.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_172807 (h1 : group (has_nnnorm (random_gen fun_info))) : group.fg (has_nnnorm (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_172808 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (linear_ordered_semiring.{0} num) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (linear_ordered_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_172809 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (partial_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (partial_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_172810 (h0 : function.extfun (finset Type -> Prop) (function.extfun (finset Type))) : @complete_lattice.is_Sup_finite_compact.{0} fun_info (@finset.pi.empty.{1 0} Type complete_lattice.{0} fun_info (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) fun_info) (@function.extfun_app.{2 0} (finset.{1} Type → Prop) (function.extfun.{2 0} (finset.{1} Type)) h0 (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) fun_info)) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_172811 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (option.{0} ennreal) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (option.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_172812 (h0 : complete_lattice (normed_group (random_gen (random_gen (random_gen to_additive.value_type))))) : is_compactly_generated (normed_group (random_gen (random_gen (random_gen to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_172813 (h0 : topological_space (comm_group (comm_group unsigned))) : locally_compact_space (comm_group (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_172814 (h0 : topological_space (non_unital_non_assoc_semiring (mul_one_class fun_info))) : t0_space (non_unital_non_assoc_semiring (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_172815 (h0 : functor.add_const (topological_space (semigroup name)) unsigned) : @discrete_topology.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_172816 (h0 : monoid (plift (preorder num))) : monoid.fg (plift (preorder num)) := sorry --non-trivial
lemma new_lemma_172817 (h0 : not (ring (complete_semilattice_Sup to_additive.value_type) -> false)) : @rank_condition.{0} (complete_semilattice_Sup.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (complete_semilattice_Sup.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_172818 (h0 : functor.add_const (topological_space (normed_comm_ring environment.implicit_infer_kind)) linarith.comp) : @totally_separated_space.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_172819 (h0 : group (sub_neg_monoid real)) : is_simple_group (sub_neg_monoid real) := sorry --non-trivial
lemma new_lemma_172820 (h0 : complete_lattice (ordered_comm_ring (has_neg (has_neg (has_neg pos))))) : complete_lattice.is_Sup_finite_compact (ordered_comm_ring (has_neg (has_neg (has_neg pos)))) := sorry --non-trivial
lemma new_lemma_172821 (h0 : functor.add_const (monoid (finset environment.implicit_infer_kind)) environment.implicit_infer_kind) : @monoid.fg.{0} (finset.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (monoid.{0} (finset.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_172822 (h0 : functor.add_const (topological_space (order_dual environment.implicit_infer_kind)) pos) : @irreducible_space.{0} (order_dual.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (order_dual.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_172823 (h0 : topological_space (has_add pos)) : locally_compact_space (has_add pos) := sorry --non-trivial
lemma new_lemma_172824 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @is_add_cyclic.{0} (omega_complete_partial_order.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) add_group.{0}) (omega_complete_partial_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_172825 (h0 : ring (has_neg (ring pos))) : rank_condition (has_neg (ring pos)) := sorry --non-trivial
lemma new_lemma_172826 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @path_connected_space.{0} (measurable_space.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) topological_space.{0}) (measurable_space.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_172827 (h0 : topological_space (canonically_ordered_comm_semiring (has_neg_part ennreal))) : sequential_space (canonically_ordered_comm_semiring (has_neg_part ennreal)) := sorry --non-trivial
lemma new_lemma_172828 (h0 : topological_space (left_cancel_monoid (semiring num))) : preirreducible_space (left_cancel_monoid (semiring num)) := sorry --non-trivial
lemma new_lemma_172829 (h0 : not (group (has_union unsigned) -> false)) : @group.fg.{0} (has_union.{0} unsigned) (@classical.by_contradiction'.{1} (group.{0} (has_union.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_172830 (h0 : functor.add_const (ordered_add_comm_monoid (free_add_monoid unsigned)) empty) : @archimedean.{0} (free_add_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (free_add_monoid.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_172831 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (group_with_zero.{0} ennreal) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (group_with_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_172832 (h0 : topological_space (normed_lattice_add_comm_group (has_neg Type))) : regular_space (normed_lattice_add_comm_group (has_neg Type)) := sorry --non-trivial
lemma new_lemma_172833 (h0 : semiring (partial_order (semiring (semiring congr_arg_kind)))) : is_noetherian_ring (partial_order (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_172834 (h0 : topological_space (semi_normed_comm_ring (semi_normed_comm_ring string_imp))) : totally_disconnected_space (semi_normed_comm_ring (semi_normed_comm_ring string_imp)) := sorry --non-trivial
lemma new_lemma_172835 (h0 : topological_space (linear_order congr_arg_kind)) : discrete_topology (linear_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_172836 (h0 : topological_space (has_union (semiring (semiring (semiring linarith.comp))))) : totally_separated_space (has_union (semiring (semiring (semiring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_172837 (h0 : not (function.extfun Type cancel_comm_monoid_with_zero -> false)) : @unique_factorization_monoid.{0} unsigned (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type cancel_comm_monoid_with_zero.{0}) h0) unsigned)  := sorry --non-trivial
lemma new_lemma_172838 (h0 : ring (fintype (random_gen fun_info))) : rank_condition (fintype (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_172839 (h0 : topological_space (has_one empty)) : totally_separated_space (has_one empty) := sorry --non-trivial
lemma new_lemma_172840 (h0 : group (linear_ordered_semiring (semiring (has_norm unsigned)))) : group.fg (linear_ordered_semiring (semiring (has_norm unsigned))) := sorry --non-trivial
lemma new_lemma_172841 (h0 : ring (has_Inf (has_Inf (has_Inf Type)))) : rank_condition (has_Inf (has_Inf (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_172842 (h0 : functor.add_const (add_monoid (mul_zero_class environment.implicit_infer_kind)) Type) : @add_monoid.fg.{0} (mul_zero_class.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (add_monoid.{0} (mul_zero_class.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_172843 (h0 : functor.add_const (topological_space (comm_group unsigned)) unsigned) : @loc_path_connected_space.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_172844 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_172845 (h0 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} (normed_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h0) (normed_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_172846 (h0 : functor.add_const (topological_space (normed_comm_ring name)) name) : @totally_disconnected_space.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_172847 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (random_gen.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (random_gen.{0} num))  := sorry --non-trivial
lemma new_lemma_172848 (h0 : not (function.extfun Type group -> false)) : @normalizer_condition.{0} (linear_ordered_semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (linear_ordered_semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_172849 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (has_neg_part.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_neg_part.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_172850 (h0 : topological_space (has_to_string (has_neg (has_neg_part name)))) : path_connected_space (has_to_string (has_neg (has_neg_part name))) := sorry --non-trivial
lemma new_lemma_172851 (h0 : topological_space (with_bot (has_inv linarith.ineq))) : totally_separated_space (with_bot (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_172852 (h1 : ring (complete_semilattice_Sup linarith.ineq)) : is_domain (complete_semilattice_Sup linarith.ineq) := sorry --non-trivial
lemma new_lemma_172853 (h0 : list (measurable_space.dynkin_system (semiring unsigned))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_172854 (h0 : functor.add_const (topological_space (ring unsigned)) linarith.comp) : @t0_space.{0} (ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_172855 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (has_inter.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} h0 (has_inter.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_172856 (h0 : complete_lattice (uniform_space (metric_space linarith.comp_source))) : is_compactly_generated (uniform_space (metric_space linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_172857 (h0 : not (topological_space (semiring fun_info) -> false)) : @t0_space.{0} (semiring.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (semiring.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_172858 (h0 : function.extfun Type (functor.add_const (ordered_add_comm_monoid (left_cancel_monoid unsigned)))) : @archimedean.{0} (left_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (left_cancel_monoid.{0} unsigned)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ordered_add_comm_monoid.{0} (left_cancel_monoid.{0} unsigned))) h0 empty))  := sorry --non-trivial
lemma new_lemma_172859 (h0 : semiring (has_to_string (has_add (has_neg_part (comm_group Type))))) : is_noetherian_ring (has_to_string (has_add (has_neg_part (comm_group Type)))) := sorry --non-trivial
lemma new_lemma_172860 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (has_neg_part.{0} pos) (@function.extfun_app.{2 1} Type monoid.{0} h0 (has_neg_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_172861 (h0 : topological_space (metric_space (random_gen unsigned))) : totally_separated_space (metric_space (random_gen unsigned)) := sorry --non-trivial
lemma new_lemma_172862 (h0 : topological_space (ordered_cancel_add_comm_monoid (option pos))) : locally_compact_space (ordered_cancel_add_comm_monoid (option pos)) := sorry --non-trivial
lemma new_lemma_172863 (h0 : functor.add_const (topological_space (has_to_string name)) linarith.comp) : @irreducible_space.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_172864 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_union.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_union.{0} empty))  := sorry --non-trivial
lemma new_lemma_172865 (h0 : ordered_add_comm_monoid (normed_lattice_add_comm_group (has_Inf real))) : archimedean (normed_lattice_add_comm_group (has_Inf real)) := sorry --non-trivial
lemma new_lemma_172866 (h0 : topological_space (has_to_string (ring Type))) : regular_space (has_to_string (ring Type)) := sorry --non-trivial
lemma new_lemma_172867 (h0 : not (group (metric_space unsigned) -> false)) : @group.fg.{0} (metric_space.{0} unsigned) (@classical.by_contradiction'.{1} (group.{0} (metric_space.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_172868 (h0 : functor.add_const (functor.add_const (semiring nnreal) empty) empty) : is_noetherian_ring nnreal := sorry --non-trivial
lemma new_lemma_172869 (h0 : ring (with_bot linarith.ineq)) : rank_condition (with_bot linarith.ineq) := sorry --non-trivial
lemma new_lemma_172870 (h0 : semiring (div_inv_monoid num)) : is_noetherian_ring (div_inv_monoid num) := sorry --non-trivial
lemma new_lemma_172871 (h0 : functor.add_const (function.extfun (Type 1) ring) Type) : @rank_condition.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) ring.{1}) Type h0) (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_172872 (h0 : not (add_group (measurable_space fun_info) -> false)) : @is_add_cyclic.{0} (measurable_space.{0} fun_info) (@classical.by_contradiction'.{1} (add_group.{0} (measurable_space.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_172873 (h0 : functor.add_const (topological_space (normed_comm_ring name)) linarith.comp) : @t1_space.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_172874 (h0 : function.extfun (Type 1) group) : @is_simple_group.{1} (normed_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} h0 (normed_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_172875 (h0 : functor.add_const (topological_space (generalized_boolean_algebra linarith.comp)) pos) : @discrete_topology.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_172876 (h0 : Prop) : non_contradictory h0 := sorry --non-trivial
lemma new_lemma_172877 (h0 : topological_space (boolean_algebra (has_Inf pos))) : preirreducible_space (boolean_algebra (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_172878 (h0 : uniform_space (normed_comm_ring (comm_group pos))) : separated_space (normed_comm_ring (comm_group pos)) := sorry --non-trivial
lemma new_lemma_172879 (h0 : not (topological_space (add_right_cancel_monoid linarith.comp) -> false)) : @t0_space.{0} (add_right_cancel_monoid.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (add_right_cancel_monoid.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_172880 (h0 : functor.add_const (group (generalized_boolean_algebra pos)) (finset pos)) : @is_cyclic.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (generalized_boolean_algebra.{0} pos)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_172881 (h0 : functor.add_const (finset (free_add_monoid num)) num) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_172882 (h0 : not (ring (topological_space reducibility_hints) -> false)) : @is_domain.{0} (topological_space.{0} reducibility_hints) (@classical.by_contradiction'.{1} (ring.{0} (topological_space.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_172883 (h0 : group (topological_space (random_gen (random_gen char)))) : group.fg (topological_space (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_172884 (h0 : cancel_comm_monoid_with_zero (has_pos_part (has_add (has_neg pos)))) : unique_factorization_monoid (has_pos_part (has_add (has_neg pos))) := sorry --non-trivial
lemma new_lemma_172885 (h0 : functor.add_const (group (free_add_monoid num)) (semiring num)) : @normalizer_condition.{0} (free_add_monoid.{0} num) (@functor.add_const.run.{0 0} (group.{0} (free_add_monoid.{0} num)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_172886 (h0 : topological_space (add_comm_monoid Type)) : preirreducible_space (add_comm_monoid Type) := sorry --non-trivial
lemma new_lemma_172887 (h1 : not (group Type -> false)) : @is_cyclic.{1} Type (@classical.by_contradiction'.{2} (group.{1} Type) h1)  := sorry --non-trivial
lemma new_lemma_172888 (h0 : topological_space (semigroup name)) : path_connected_space (semigroup name) := sorry --non-trivial
lemma new_lemma_172889 (h0 : group (add_comm_monoid (semigroup unsigned))) : group.fg (add_comm_monoid (semigroup unsigned)) := sorry --non-trivial
lemma new_lemma_172890 (h0 : function.extfun nat fin) : @is_cyclic.{0} (canonically_ordered_monoid.{0} real) (@matrix.vec_empty.{0} (group.{0} (canonically_ordered_monoid.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_172891 (h0 : set (has_Inf (mul_one_class fun_info))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_172892 (h1 : set (add_comm_semigroup enat -> std_gen)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_172893 (h0 : monoid (mul_zero_class (semiring unsigned))) : monoid.fg (mul_zero_class (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_172894 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (canonically_linear_ordered_monoid.{0} (option.{0} (option.{0} num))) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (canonically_linear_ordered_monoid.{0} (option.{0} (option.{0} num))))  := sorry --non-trivial
lemma new_lemma_172895 (h0 : not (complete_lattice (linear_ordered_comm_group_with_zero linarith.ineq) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (linear_ordered_comm_group_with_zero.{0} linarith.ineq) (@classical.by_contradiction'.{1} (complete_lattice.{0} (linear_ordered_comm_group_with_zero.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_172896 (h0 : topological_space (monoid empty)) : topological_space.separable_space (monoid empty) := sorry --non-trivial
lemma new_lemma_172897 (h0 : complete_lattice (has_to_string congr_arg_kind)) : is_atomistic (has_to_string congr_arg_kind) := sorry --non-trivial
lemma new_lemma_172898 (h0 : ordered_comm_monoid (ordered_comm_monoid (has_add (has_Inf (finset pos))))) : has_exists_mul_of_le (ordered_comm_monoid (has_add (has_Inf (finset pos)))) := sorry --non-trivial
lemma new_lemma_172899 (h0 : functor.add_const (function.extfun (Type 1) ring) pos) : @rank_condition.{1} (ordered_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ring.{1}) pos h0) (ordered_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_172900 (h0 : function.extfun Type (functor.add_const (group auto.case_option))) : @group.fg.{0} auto.case_option (@functor.add_const.run.{0 0} (group.{0} auto.case_option) (option.{0} unsigned) (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (group.{0} auto.case_option)) h0 (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_172901 (h0 : topological_space (linear_ordered_add_comm_group linarith.ineq)) : totally_disconnected_space (linear_ordered_add_comm_group linarith.ineq) := sorry --non-trivial
lemma new_lemma_172902 (h0 : fin has_zero.zero) : @has_exists_mul_of_le.{0} (canonically_ordered_monoid.{0} pos) (@matrix.vec_empty.{0} (ordered_comm_monoid.{0} (canonically_ordered_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_172903 (h0 : functor.add_const (function.extfun Type cancel_comm_monoid_with_zero) unsigned) : @unique_factorization_monoid.{0} (has_zero.{0} linarith.comp) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type cancel_comm_monoid_with_zero.{0}) unsigned h0) (has_zero.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_172904 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (semiring.{0} empty) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_172905 (h0 : topological_space (finset (ordered_comm_monoid (ordered_ring Type)))) : sequential_space (finset (ordered_comm_monoid (ordered_ring Type))) := sorry --non-trivial
lemma new_lemma_172906 (h0 : ring (measurable_space to_additive.value_type)) : is_domain (measurable_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_172907 (h0 : topological_space (monoid_with_zero (option (option pos)))) : totally_separated_space (monoid_with_zero (option (option pos))) := sorry --non-trivial
lemma new_lemma_172908 (h0 : complete_lattice (with_one (has_norm (has_norm congr_arg_kind)))) : complete_lattice.is_Sup_finite_compact (with_one (has_norm (has_norm congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_172909 (h0 : functor.add_const (list (comm_group linarith.comp)) linarith.comp) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_172910 (h1 : topological_space char) : totally_disconnected_space char := sorry --non-trivial
lemma new_lemma_172911 (h0 : function.extfun Type topological_space) : @normal_space.{0} (semiring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_172912 (h0 : topological_space (finset (finset (option (finset name))))) : path_connected_space (finset (finset (option (finset name)))) := sorry --non-trivial
lemma new_lemma_172913 (h0 : topological_space (has_zero (has_to_string Type))) : topological_space.separable_space (has_zero (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_172914 (h0 : functor.add_const (topological_space (has_star congr_arg_kind)) (semiring (semiring empty))) : @topological_space.separable_space.{0} (has_star.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} congr_arg_kind)) (semiring.{0} (semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_172915 (h0 : functor.add_const (function.extfun Type topological_space) (has_pos_part (has_Inf (has_Inf linarith.comp)))) : @totally_disconnected_space.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (has_pos_part.{0} (has_Inf.{0} (has_Inf.{0} linarith.comp))) h0) (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_172916 (h0 : topological_space (ring (has_Inf (has_Inf pos)))) : topological_space.separable_space (ring (has_Inf (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_172917 (h0 : Type -> has_bot real -> Prop) : relator.bi_total h0 := sorry --non-trivial
lemma new_lemma_172918 (h0 : has_mem.mem (has_norm environment.implicit_infer_kind) has_emptyc.emptyc) : @is_atomistic.{0} (has_norm.{0} environment.implicit_infer_kind) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (has_norm.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_172919 (h0 : list (ordered_ring (semiring empty))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_172920 (h0 : function.extfun Type (functor.add_const (topological_space (simple_graph pos)))) : @preirreducible_space.{0} (simple_graph.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (simple_graph.{0} pos)) (finset.{0} name) (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (simple_graph.{0} pos))) h0 (finset.{0} name)))  := sorry --non-trivial
lemma new_lemma_172921 (h0 : functor.add_const (topological_space (free_add_monoid empty)) empty) : @discrete_topology.{0} (free_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_172922 (h0 : fin has_zero.zero) : @is_add_cyclic.{0} (has_bot.{0} real) (@function.extfun_app.{2 1} Type add_group.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type add_group.{0}) h0) (has_bot.{0} real))  := sorry --non-trivial
lemma new_lemma_172923 (h0 : functor.comp monoid cancel_monoid name) : @monoid.fg.{0} (cancel_monoid.{0} name) (@functor.comp.run.{0 0 0} monoid.{0} cancel_monoid.{0} name h0)  := sorry --non-trivial
lemma new_lemma_172924 (h0 : functor.add_const (topological_space (add_cancel_monoid name)) (has_add (has_pos_part Type))) : @t1_space.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (add_cancel_monoid.{0} name)) (has_add.{1} (has_pos_part.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_172925 (h2 : function.extfun Type list) : list.nodup (function.extfun_app h2 string_imp) := sorry --non-trivial
lemma new_lemma_172926 (h0 : topological_space real.angle) : t0_space real.angle := sorry --non-trivial
lemma new_lemma_172927 (h0 : prod (linear_ordered_comm_ring unsigned) (linear_ordered_comm_ring unsigned)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_172928 (h0 : ring (has_to_string (has_neg_part ennreal))) : strong_rank_condition (has_to_string (has_neg_part ennreal)) := sorry --non-trivial
lemma new_lemma_172929 (h0 : group (semiring (has_norm (has_top linarith.comp_source)))) : is_cyclic (semiring (has_norm (has_top linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_172930 (h0 : functor.add_const (topological_space (boolean_algebra.core environment.implicit_infer_kind)) name) : @totally_separated_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_172931 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (linear_ordered_field.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (linear_ordered_field.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_172932 (h0 : fin has_zero.zero) : @topological_space.separable_space.{0} (has_bot.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (has_bot.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_172933 (h0 : char) (h1 : sym2 char) : sym2.mem h0 h1 := sorry --non-trivial
lemma new_lemma_172934 (h0 : cancel_comm_monoid_with_zero (pseudo_metric_space congr_arg_kind)) : unique_factorization_monoid (pseudo_metric_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_172935 (h0 : filter (generalized_boolean_algebra pos)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_172936 (h0 : topological_space (has_add (has_add name))) : discrete_topology (has_add (has_add name)) := sorry --non-trivial
lemma new_lemma_172937 (h0 : functor.add_const (group (comm_group Type)) name) : @is_cyclic.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (comm_group.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_172938 (h0 : functor.add_const (topological_space (linear_ordered_comm_group empty)) unsigned) : @t1_space.{0} (linear_ordered_comm_group.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_comm_group.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_172939 (h1 : has_neg char) (h2 : measurable_space char) : has_measurable_neg char := sorry --non-trivial
lemma new_lemma_172940 (h0 : topological_space (partial_order (semiring unsigned))) : totally_disconnected_space (partial_order (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_172941 (h0 : topological_space (has_neg Type)) : t1_space (has_neg Type) := sorry --non-trivial
lemma new_lemma_172942 (h0 : topological_space (left_cancel_monoid unsigned)) : t0_space (left_cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_172943 (h0 : complete_lattice (linear_ordered_comm_group empty)) : is_compactly_generated (linear_ordered_comm_group empty) := sorry --non-trivial
lemma new_lemma_172944 (h0 : ring (finset (has_add (has_add Type)))) : rank_condition (finset (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_172945 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (omega_complete_partial_order.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (omega_complete_partial_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_172946 (h0 : ring (has_neg_part (boolean_algebra.core name))) : rank_condition (has_neg_part (boolean_algebra.core name)) := sorry --non-trivial
lemma new_lemma_172947 (h0 : function.extfun Type topological_space) : @t0_space.{0} (canonically_linear_ordered_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_linear_ordered_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_172948 (h0 : list (denumerable (random_gen fun_info))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_172949 (h0 : functor.add_const (filter linarith.comp) (has_Inf Type)) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_172950 (h0 : topological_space (normed_comm_ring (comm_group pos))) : topological_space.separable_space (normed_comm_ring (comm_group pos)) := sorry --non-trivial
lemma new_lemma_172951 (h0 : functor.add_const (topological_space (ring pos)) name) : @totally_separated_space.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_172952 (h0 : topological_space (has_to_string unsigned)) : sequential_space (has_to_string unsigned) := sorry --non-trivial
lemma new_lemma_172953 (h0 : prod (measure_theory.measure_space unsigned) (measure_theory.measure_space unsigned)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_172954 (h0 : fin has_zero.zero) : @is_add_cyclic.{1} (ordered_comm_ring.{1} Type) (@matrix.vec_empty.{1} (add_group.{1} (ordered_comm_ring.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_172955 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_to_string Type)) pos) : @unique_factorization_monoid.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (cancel_comm_monoid_with_zero.{1} (has_to_string.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_172956 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_union.{0} num) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_union.{0} num))  := sorry --non-trivial
lemma new_lemma_172957 (h0 : cancel_comm_monoid_with_zero (has_sub empty)) : unique_factorization_monoid (has_sub empty) := sorry --non-trivial
lemma new_lemma_172958 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (has_nndist.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_172959 (h0 : fin has_zero.zero) : @regular_space.{0} (canonically_ordered_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (canonically_ordered_monoid.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_172960 (h0 : filter (option (option name))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_172961 (h0 : topological_space (add_comm_monoid congr_arg_kind)) : totally_separated_space (add_comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_172962 (h1 : not (add_group (measurable_space linarith.comp) -> false)) : @is_add_cyclic.{0} (measurable_space.{0} linarith.comp) (@classical.by_contradiction'.{1} (add_group.{0} (measurable_space.{0} linarith.comp)) h1)  := sorry --non-trivial
lemma new_lemma_172963 (h0 : group (has_to_string num)) : is_simple_group (has_to_string num) := sorry --non-trivial
lemma new_lemma_172964 (h0 : add_monoid (with_bot (semiring linarith.comp))) : add_monoid.fg (with_bot (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_172965 (h0 : filter (has_nndist ennreal)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_172966 (h0 : complete_lattice (with_bot fun_info)) : is_atomistic (with_bot fun_info) := sorry --non-trivial
lemma new_lemma_172967 (h0 : topological_space (encodable (random_gen string_imp))) : totally_disconnected_space (encodable (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_172968 (h0 : topological_space (comm_ring (with_one linarith.ineq))) : t0_space (comm_ring (with_one linarith.ineq)) := sorry --non-trivial
lemma new_lemma_172969 (h0 : functor.add_const (complete_lattice (has_zero linarith.comp)) (has_pos_part linarith.comp)) : @complete_lattice.is_Sup_finite_compact.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_zero.{0} linarith.comp)) (has_pos_part.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_172970 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (has_nndist.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_nndist.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_172971 (h0 : finset (has_neg linarith.comp)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_172972 (h0 : fin has_zero.zero) : @preirreducible_space.{0} (has_Inf.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (has_Inf.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_172973 (h0 : functor.add_const (filter (has_zero pos)) (finset (has_add linarith.comp))) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_172974 (h0 : list (ordered_comm_group (option unsigned))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_172975 (h0 : functor.add_const (topological_space (canonically_linear_ordered_monoid pos)) unsigned) : @totally_disconnected_space.{0} (canonically_linear_ordered_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_linear_ordered_monoid.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_172976 (h0 : filter (has_top (has_top linarith.comp))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_172977 (h0 : topological_space (semigroup (generalized_boolean_algebra (ring Type)))) : sequential_space (semigroup (generalized_boolean_algebra (ring Type))) := sorry --non-trivial
lemma new_lemma_172978 (h0 : complete_lattice (denumerable (has_inv (random_gen (has_inv fun_info))))) : complete_lattice.is_Sup_finite_compact (denumerable (has_inv (random_gen (has_inv fun_info)))) := sorry --non-trivial
lemma new_lemma_172979 (h0 : function.extfun Type ring) : @rank_condition.{0} (canonically_ordered_comm_semiring.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (canonically_ordered_comm_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_172980 (h0 : topological_space (ordered_comm_monoid (has_add (has_add (has_add (has_Inf pos)))))) : sequential_space (ordered_comm_monoid (has_add (has_add (has_add (has_Inf pos))))) := sorry --non-trivial
lemma new_lemma_172981 (h0 : functor.add_const (function.extfun Type topological_space) (finset Type)) : @normal_space.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) (finset.{1} Type) h0) (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_172982 (h0 : function.extfun (Type 1) topological_space) : @preconnected_space.{1} (mul_zero_class.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (mul_zero_class.{1} Type))  := sorry --non-trivial
lemma new_lemma_172983 (h0 : fin has_zero.zero) : @topological_space.separable_space.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_172984 (h0 : functor.add_const (finset (boolean_algebra linarith.comp)) (finset (finset (has_to_string pos)))) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_172985 (h0 : functor.add_const (topological_space (boolean_algebra linarith.comp)) name) : @loc_path_connected_space.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_172986 (h0 : ring (linear_ordered_add_comm_group (has_nnnorm (has_nnnorm linarith.ineq)))) : rank_condition (linear_ordered_add_comm_group (has_nnnorm (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_172987 (h0 : ring (normed_group (random_gen char))) : rank_condition (normed_group (random_gen char)) := sorry --non-trivial
lemma new_lemma_172988 (h0 : ring (with_bot (random_gen (random_gen (random_gen (random_gen (random_gen num))))))) : rank_condition (with_bot (random_gen (random_gen (random_gen (random_gen (random_gen num)))))) := sorry --non-trivial
lemma new_lemma_172989 (h0 : functor.add_const (function.extfun Type semiring) Type) : @is_noetherian_ring.{0} (add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type semiring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type semiring.{0}) Type h0) (add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_172990 (h1 : topological_space (has_append (random_gen (linear_ordered_comm_monoid linarith.ineq)))) : totally_disconnected_space (has_append (random_gen (linear_ordered_comm_monoid linarith.ineq))) := sorry --non-trivial
lemma new_lemma_172991 (h0 : complete_lattice (sub_neg_monoid name)) : is_compactly_generated (sub_neg_monoid name) := sorry --non-trivial
lemma new_lemma_172992 (h0 : fin has_zero.zero) : @loc_path_connected_space.{0} (has_add.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (has_add.{0} real)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)))  := sorry --non-trivial
lemma new_lemma_172993 (h0 : ordered_comm_monoid (boolean_algebra (finset Type))) : has_exists_mul_of_le (boolean_algebra (finset Type)) := sorry --non-trivial
lemma new_lemma_172994 (h0 : topological_space (boolean_algebra (has_neg Type))) : topological_space.separable_space (boolean_algebra (has_neg Type)) := sorry --non-trivial
lemma new_lemma_172995 (h0 : topological_space (semigroup (has_add name))) : path_connected_space (semigroup (has_add name)) := sorry --non-trivial
lemma new_lemma_172996 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (pseudo_metric_space.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (pseudo_metric_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_172997 (h0 : topological_space (add_cancel_monoid (has_add (boolean_algebra linarith.comp)))) : totally_separated_space (add_cancel_monoid (has_add (boolean_algebra linarith.comp))) := sorry --non-trivial
lemma new_lemma_172998 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (has_nndist.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_nndist.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_172999 (h0 : topological_space (has_add (has_neg name))) : discrete_topology (has_add (has_neg name)) := sorry --non-trivial
lemma new_lemma_173000 (h0 : topological_space (finset (finset environment.implicit_infer_kind))) : totally_disconnected_space (finset (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_173001 (h0 : topological_space (has_nndist (has_to_string pos))) : preconnected_space (has_nndist (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_173002 (h0 : group (distrib_lattice linarith.comp_source)) : is_cyclic (distrib_lattice linarith.comp_source) := sorry --non-trivial
lemma new_lemma_173003 (h0 : finset (has_Inf (has_add (has_add pos)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_173004 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @normal_space.{0} (finset.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (finset.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_173005 (h0 : topological_space (has_neg (semigroup pos))) : preconnected_space (has_neg (semigroup pos)) := sorry --non-trivial
lemma new_lemma_173006 (h0 : function.extfun Type (functor.add_const (complete_lattice linarith.comp))) : @is_compactly_generated.{0} linarith.comp (@functor.add_const.run.{0 0} (complete_lattice.{0} linarith.comp) linarith.comp (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (complete_lattice.{0} linarith.comp)) h0 linarith.comp))  := sorry --non-trivial
lemma new_lemma_173007 (h0 : functor.add_const (group (semigroup congr_arg_kind)) unsigned) : @is_cyclic.{0} (semigroup.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (group.{0} (semigroup.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_173008 (h0 : complete_lattice (has_append (has_nnnorm char))) : complete_lattice.is_Sup_finite_compact (has_append (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_173009 (h0 : fin has_zero.zero) : @is_add_cyclic.{1} (sub_neg_monoid.{1} Type) (@matrix.vec_empty.{1} (add_group.{1} (sub_neg_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_173010 (h0 : functor.add_const (topological_space (as_linear_order empty)) empty) : @locally_compact_space.{0} (as_linear_order.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (as_linear_order.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_173011 (h0 : functor.add_const (ring (has_nndist pos)) pos) : @strong_rank_condition.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_nndist.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_173012 (h1 : topological_space (complete_semilattice_Sup (has_emptyc congr_arg_kind))) : irreducible_space (complete_semilattice_Sup (has_emptyc congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_173013 (h1 : not (functor.comp uniform_space random_gen linarith.comp_source -> false)) : @complete_space.{0} (random_gen.{0} linarith.comp_source) (@functor.comp.run.{0 0 0} uniform_space.{0} random_gen.{0} linarith.comp_source (@classical.by_contradiction'.{1} (functor.comp.{0 0 0} uniform_space.{0} random_gen.{0} linarith.comp_source) h1))  := sorry --non-trivial
lemma new_lemma_173014 (h0 : not (function.extfun Type topological_space -> false)) : @irreducible_space.{0} (measurable_space.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (measurable_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_173015 (h0 : complete_lattice (has_top (random_gen fun_info))) : is_compactly_generated (has_top (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_173016 (h0 : uniform_space (generalized_boolean_algebra (has_neg Type))) : complete_space (generalized_boolean_algebra (has_neg Type)) := sorry --non-trivial
lemma new_lemma_173017 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (@id.{2} Type unsigned) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (@id.{2} Type unsigned))  := sorry --non-trivial
lemma new_lemma_173018 (h0 : ring (has_neg (has_add (has_neg linarith.comp)))) : is_domain (has_neg (has_add (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_173019 (h0 : topological_space (linear_ordered_add_comm_group (has_top fun_info))) : totally_separated_space (linear_ordered_add_comm_group (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_173020 (h0 : fin has_zero.zero) : @complete_space.{0} (canonically_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type uniform_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type uniform_space.{0}) h0) (canonically_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_173021 (h0 : functor.add_const (function.extfun Type filter) (has_to_string Type)) : filter.ne_bot (function.extfun_app (functor.add_const.run h0) (normed_comm_ring pos)) := sorry --non-trivial
lemma new_lemma_173022 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_ssubset.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_ssubset.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_173023 (h0 : filter (add_comm_monoid (comm_group pos))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_173024 (h0 : functor.add_const (add_monoid (semiring congr_arg_kind)) unsigned) : @add_monoid.fg.{0} (semiring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (add_monoid.{0} (semiring.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_173025 (h0 : functor.add_const (topological_space (normed_comm_ring Type)) pos) : @regular_space.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (normed_comm_ring.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_173026 (h0 : fin has_zero.zero) : @irreducible_space.{0} (comm_semigroup.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (comm_semigroup.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_173027 (h1 : monoid (measurable_space (has_norm linarith.comp))) : monoid.fg (measurable_space (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_173028 (h7 : set (nondiscrete_normed_field string.iterator_imp)) : set.finite h7 := sorry --non-trivial
lemma new_lemma_173029 (h0 : function.extfun Type topological_space) : @normal_space.{0} (bin_tree.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (bin_tree.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_173030 (h0 : has_mem.mem complete_lattice has_emptyc.emptyc) : @is_compactly_generated.{0} (normed_group.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} h0) (normed_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_173031 (h0 : functor.add_const (list (has_nndist linarith.comp)) unsigned) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_173032 (h0 : group (has_neg (ring (finset name)))) : normalizer_condition (has_neg (ring (finset name))) := sorry --non-trivial
lemma new_lemma_173033 (h0 : option (option unsigned) -> option (option unsigned) -> Prop) : is_symm (option (option unsigned)) h0 := sorry --non-trivial
lemma new_lemma_173034 (h0 : functor.add_const (group (has_add Type)) linarith.comp) : @normalizer_condition.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (has_add.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_173035 (h0 : topological_space (finset (has_add environment.implicit_infer_kind))) : irreducible_space (finset (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_173036 (h0 : topological_space (has_div (mul_one_class string.iterator_imp))) (h1 : preorder (has_div (mul_one_class string.iterator_imp))) : order_closed_topology (has_div (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_173037 (h1 : not (semiring (has_norm num) -> false)) : @is_noetherian_ring.{0} (has_norm.{0} num) (@classical.by_contradiction'.{1} (semiring.{0} (has_norm.{0} num)) h1)  := sorry --non-trivial
lemma new_lemma_173038 (h0 : functor.add_const (function.extfun (Type 1) finset) linarith.comp) : finset.nonempty (function.extfun_app (functor.add_const.run h0) Type) := sorry --non-trivial
lemma new_lemma_173039 (h0 : functor.add_const (filter (monoid empty)) (option num)) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_173040 (h0 : topological_space (free_add_monoid (semiring (semiring unsigned)))) : topological_space.separable_space (free_add_monoid (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_173041 (h0 : ring (has_edist (semiring empty))) : is_principal_ideal_ring (has_edist (semiring empty)) := sorry --non-trivial
lemma new_lemma_173042 (h0 : functor.add_const (topological_space (has_neg_part pos)) pos) : @preconnected_space.{0} (has_neg_part.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_173043 (h0 : complete_lattice (linear_ordered_add_comm_group string_imp)) : is_atomistic (linear_ordered_add_comm_group string_imp) := sorry --non-trivial
lemma new_lemma_173044 (h0 : topological_space (ring Type)) : totally_separated_space (ring Type) := sorry --non-trivial
lemma new_lemma_173045 (h0 : functor.add_const (list (has_inter empty)) unsigned) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_173046 (h0 : filter (simple_graph (option (option empty)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_173047 (h0 : functor.add_const (uniform_space (option empty)) (semiring num)) : @complete_space.{0} (option.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (option.{0} empty)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_173048 (h0 : complete_lattice (has_nnnorm std_gen)) : complete_lattice.is_Sup_finite_compact (has_nnnorm std_gen) := sorry --non-trivial
lemma new_lemma_173049 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (linear_ordered_semiring.{0} real.angle) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (linear_ordered_semiring.{0} real.angle))  := sorry --non-trivial
lemma new_lemma_173050 (h1 : not (ring (has_add linarith.ineq) -> false)) : @rank_condition.{0} (has_add.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (has_add.{0} linarith.ineq)) h1)  := sorry --non-trivial
lemma new_lemma_173051 (h0 : topological_space (add_comm_monoid congr_arg_kind)) : loc_path_connected_space (add_comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_173052 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem group)) : @normalizer_condition.{0} (has_norm.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) group.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_norm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_173053 (h0 : functor.add_const (function.extfun Type topological_space) (ring (has_zero (boolean_algebra (ring pos))))) : @totally_separated_space.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (ring.{0} (has_zero.{0} (boolean_algebra.{0} (ring.{0} pos)))) h0) (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_173054 (h0 : not (complete_lattice (has_norm fun_info) -> false)) : @is_atomistic.{0} (has_norm.{0} fun_info) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_norm.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_173055 (h0 : topological_space (normed_field (has_nnnorm string.iterator_imp))) : path_connected_space (normed_field (has_nnnorm string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_173056 (h0 : add_group (ordered_comm_group unsigned)) : is_add_cyclic (ordered_comm_group unsigned) := sorry --non-trivial
lemma new_lemma_173057 (h0 : ordered_add_comm_monoid (linear_ordered_field num)) : archimedean (linear_ordered_field num) := sorry --non-trivial
lemma new_lemma_173058 (h0 : topological_space (has_pos_part pos)) : irreducible_space (has_pos_part pos) := sorry --non-trivial
lemma new_lemma_173059 (h0 : topological_space (has_neg_part (option pos))) : sequential_space (has_neg_part (option pos)) := sorry --non-trivial
lemma new_lemma_173060 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (has_add.{0} real) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (has_add.{0} real))  := sorry --non-trivial
lemma new_lemma_173061 (h0 : functor.add_const (topological_space (has_add unsigned)) linarith.comp) : @normal_space.{0} (has_add.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_173062 (h0 : functor.add_const (topological_space (has_zero unsigned)) Type) : @totally_separated_space.{0} (has_zero.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (has_zero.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_173063 (h0 : complete_lattice (semiring (has_top (has_top to_additive.value_type)))) : complete_lattice.is_Sup_finite_compact (semiring (has_top (has_top to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_173064 (h0 : functor.add_const (topological_space (has_to_string unsigned)) name) : @preirreducible_space.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_173065 (h0 : functor.add_const (topological_space (ring name)) linarith.comp) : @sequential_space.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_173066 (h0 : cancel_comm_monoid_with_zero (mul_zero_class (semiring unsigned))) : unique_factorization_monoid (mul_zero_class (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_173067 (h0 : topological_space (metric_space empty)) : locally_compact_space (metric_space empty) := sorry --non-trivial
lemma new_lemma_173068 (h0 : not (group (normed_group linarith.comp) -> false)) : @group.fg.{0} (normed_group.{0} linarith.comp) (@classical.by_contradiction'.{1} (group.{0} (normed_group.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_173069 (h0 : group (has_neg (finset ennreal))) : is_simple_group (has_neg (finset ennreal)) := sorry --non-trivial
lemma new_lemma_173070 (h0 : function.extfun Type topological_space) : @t0_space.{0} (linear_ordered_comm_ring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_ring.{0} num))  := sorry --non-trivial
lemma new_lemma_173071 (h0 : functor.add_const (topological_space (generalized_boolean_algebra name)) pos) : @locally_compact_space.{0} (generalized_boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_173072 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (has_neg.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_neg.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_173073 (h0 : group (has_edist num)) : group.fg (has_edist num) := sorry --non-trivial
lemma new_lemma_173074 (h0 : group (ring (ring pos))) : group.fg (ring (ring pos)) := sorry --non-trivial
lemma new_lemma_173075 (h0 : functor.add_const (topological_space (has_neg_part environment.implicit_infer_kind)) name) : @normal_space.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_173076 (h0 : topological_space (has_sub (has_top (has_top empty)))) : path_connected_space (has_sub (has_top (has_top empty))) := sorry --non-trivial
lemma new_lemma_173077 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (omega_complete_partial_order.{0} (semiring.{0} unsigned)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (omega_complete_partial_order.{0} (semiring.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_173078 (h0 : ring (group_with_zero (option congr_arg_kind))) : strong_rank_condition (group_with_zero (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_173079 (h0 : functor.comp topological_space add_comm_monoid name) : @preirreducible_space.{0} (add_comm_monoid.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} add_comm_monoid.{0} name h0)  := sorry --non-trivial
lemma new_lemma_173080 (h0 : complete_lattice (normed_comm_ring pos)) : complete_lattice.is_Sup_finite_compact (normed_comm_ring pos) := sorry --non-trivial
lemma new_lemma_173081 (h0 : functor.add_const (complete_lattice (canonically_linear_ordered_monoid ennreal)) num) : @complete_lattice.is_Sup_finite_compact.{0} (canonically_linear_ordered_monoid.{0} ennreal) (@functor.add_const.run.{0 0} (complete_lattice.{0} (canonically_linear_ordered_monoid.{0} ennreal)) num h0)  := sorry --non-trivial
lemma new_lemma_173082 (h2 : group (random_gen congr_arg_kind)) : normalizer_condition (random_gen congr_arg_kind) := sorry --non-trivial
lemma new_lemma_173083 (h0 : has_add (add_comm_monoid pos) -> has_add (add_comm_monoid pos) -> Prop) : is_symm (has_add (add_comm_monoid pos)) h0 := sorry --non-trivial
lemma new_lemma_173084 (h0 : function.extfun Type group) : @is_simple_group.{0} (has_zero.{0} name) (@function.extfun_app.{2 1} Type group.{0} h0 (has_zero.{0} name))  := sorry --non-trivial
lemma new_lemma_173085 (h0 : topological_space (has_add (measurable_space Type))) : preirreducible_space (has_add (measurable_space Type)) := sorry --non-trivial
lemma new_lemma_173086 (h0 : uniform_space (filter (option (option (option (option (option (option (option empty))))))))) : separated_space (filter (option (option (option (option (option (option (option empty)))))))) := sorry --non-trivial
lemma new_lemma_173087 (h0 : functor.add_const (topological_space (has_to_string pos)) Type) : @irreducible_space.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_to_string.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_173088 (h0 : topological_space (has_Inf (ring (has_Inf (has_neg pos))))) : totally_disconnected_space (has_Inf (ring (has_Inf (has_neg pos)))) := sorry --non-trivial
lemma new_lemma_173089 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @regular_space.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_173090 (h0 : group (has_star (option (semiring empty)))) : normalizer_condition (has_star (option (semiring empty))) := sorry --non-trivial
lemma new_lemma_173091 (h0 : list (left_cancel_monoid (add_group (option (option unsigned))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_173092 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @regular_space.{0} (boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_173093 (h0 : has_mem.mem (has_norm empty) has_emptyc.emptyc) : @path_connected_space.{0} (has_norm.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_norm.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_173094 (h0 : functor.add_const (topological_space (normed_comm_ring Type)) name) : @path_connected_space.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (normed_comm_ring.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_173095 (h0 : add_group (id (has_top (has_top linarith.comp_source)))) : is_add_cyclic (id (has_top (has_top linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_173096 (h0 : topological_space (linear_ordered_comm_group pos)) : locally_compact_space (linear_ordered_comm_group pos) := sorry --non-trivial
lemma new_lemma_173097 (h0 : group (semi_normed_ring char)) : is_cyclic (semi_normed_ring char) := sorry --non-trivial
lemma new_lemma_173098 (h0 : ring (has_nndist (has_neg linarith.comp))) : is_principal_ideal_ring (has_nndist (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_173099 (h0 : functor.add_const (topological_space (has_star num)) num) : @totally_separated_space.{0} (has_star.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_173100 (h2 : measurable_space (nondiscrete_normed_field (normed_field enat))) (h3 : measure_theory.measure (nondiscrete_normed_field (normed_field enat))) : measure_theory.is_finite_measure h3 := sorry --non-trivial
lemma new_lemma_173101 (h0 : heq (add_left_cancel_monoid linarith.comp) (has_top linarith.comp)) (h1 : topological_space (add_left_cancel_monoid linarith.comp)) : @preirreducible_space.{0} (has_top.{0} linarith.comp) (@heq.elim.{2 1} Type (add_left_cancel_monoid.{0} linarith.comp) topological_space.{0} (has_top.{0} linarith.comp) h0 h1)  := sorry --non-trivial
lemma new_lemma_173102 (h0 : functor.add_const (filter (canonically_linear_ordered_monoid name)) name) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_173103 (h0 : finset (complete_distrib_lattice (option congr_arg_kind))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_173104 (h0 : functor.add_const (topological_space (mul_zero_class name)) pos) : @locally_compact_space.{0} (mul_zero_class.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_173105 (h0 : monoid (has_union (metric_space (measurable_space (semiring num))))) : monoid.fg (has_union (metric_space (measurable_space (semiring num)))) := sorry --non-trivial
lemma new_lemma_173106 (h0 : topological_space (normed_group (has_top fun_info))) : irreducible_space (normed_group (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_173107 (h0 : functor.add_const (topological_space (has_neg environment.implicit_infer_kind)) pos) : @regular_space.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_173108 (h1 : list (with_one to_additive.value_type)) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_173109 (h0 : not (topological_space (metric_space unsigned) -> false)) : @path_connected_space.{0} (metric_space.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (metric_space.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_173110 (h0 : option (complete_lattice (add_comm_monoid (has_neg environment.implicit_infer_kind)))) (h1 : complete_lattice (add_comm_monoid (has_neg environment.implicit_infer_kind))) : is_atomistic (add_comm_monoid (has_neg environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_173111 (h0 : not (topological_space (denumerable linarith.ineq) -> false)) : @totally_disconnected_space.{0} (denumerable.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (denumerable.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_173112 (h0 : functor.add_const (ordered_add_comm_monoid (ordered_comm_group unsigned)) empty) : @archimedean.{0} (ordered_comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (ordered_comm_group.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_173113 (h1 : ring (nondiscrete_normed_field enat)) : strong_rank_condition (nondiscrete_normed_field enat) := sorry --non-trivial
lemma new_lemma_173114 (h0 : functor.add_const (filter (normed_comm_ring Type)) pos) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_173115 (h0 : cancel_comm_monoid_with_zero (has_bot num)) : unique_factorization_monoid (has_bot num) := sorry --non-trivial
lemma new_lemma_173116 (h0 : group (topological_space (has_nnnorm (has_nnnorm linarith.comp_source)))) : is_cyclic (topological_space (has_nnnorm (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_173117 (h0 : functor.add_const (complete_lattice (comm_group Type)) linarith.comp) : @complete_lattice.is_Sup_finite_compact.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (comm_group.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_173118 (h0 : topological_space (has_one (has_norm (has_norm linarith.comp)))) : totally_disconnected_space (has_one (has_norm (has_norm linarith.comp))) := sorry --non-trivial
lemma new_lemma_173119 (h0 : functor.add_const (function.extfun Type uniform_space) num) : @complete_space.{0} (monoid.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) num h0) (monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_173120 (h0 : prod (ring ennreal) (ring ennreal)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_173121 (h0 : topological_space (plift (add_left_cancel_semigroup unsigned))) : t0_space (plift (add_left_cancel_semigroup unsigned)) := sorry --non-trivial
lemma new_lemma_173122 (h0 : functor.add_const (topological_space (comm_group pos)) environment.implicit_infer_kind) : @topological_space.separable_space.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_173123 (h0 : functor.add_const (complete_lattice (ring linarith.comp)) (has_neg (has_nndist pos))) : @is_atomistic.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ring.{0} linarith.comp)) (has_neg.{0} (has_nndist.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_173124 (h0 : add_monoid (pseudo_metric_space ennreal)) : add_monoid.fg (pseudo_metric_space ennreal) := sorry --non-trivial
lemma new_lemma_173125 (h0 : functor.add_const (semiring (normed_comm_ring linarith.comp)) (has_neg (finset pos))) : @is_noetherian_ring.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (semiring.{0} (normed_comm_ring.{0} linarith.comp)) (has_neg.{0} (finset.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_173126 (h0 : topological_space (has_to_string (comm_group (has_add (comm_group unsigned))))) : sequential_space (has_to_string (comm_group (has_add (comm_group unsigned)))) := sorry --non-trivial
lemma new_lemma_173127 (h0 : functor.add_const (ordered_comm_monoid (boolean_algebra linarith.comp)) (finset linarith.comp)) : @has_exists_mul_of_le.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (boolean_algebra.{0} linarith.comp)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_173128 (h0 : functor.add_const (topological_space (preorder num)) (left_cancel_monoid empty)) : @preirreducible_space.{0} (preorder.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (preorder.{0} num)) (left_cancel_monoid.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_173129 (h0 : semiring (has_to_string (has_to_string linarith.comp))) : is_noetherian_ring (has_to_string (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_173130 (h0 : complete_lattice (add_cancel_monoid (has_neg_part Type))) : is_atomistic (add_cancel_monoid (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_173131 (h0 : filter (has_sdiff (id linarith.comp))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_173132 (h0 : finset (has_neg (mul_zero_class unsigned))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_173133 (h0 : fin has_zero.zero) : @is_atomistic.{1} (comm_semigroup.{1} Type) (@matrix.vec_empty.{1} (complete_lattice.{1} (comm_semigroup.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_173134 (h0 : monoid (preorder (ordered_cancel_comm_monoid num))) : monoid.fg (preorder (ordered_cancel_comm_monoid num)) := sorry --non-trivial
lemma new_lemma_173135 (h0 : complete_lattice (uniform_space (has_ssubset reducibility_hints))) : is_compactly_generated (uniform_space (has_ssubset reducibility_hints)) := sorry --non-trivial
lemma new_lemma_173136 (h0 : topological_space (add_comm_monoid Type)) : totally_disconnected_space (add_comm_monoid Type) := sorry --non-trivial
lemma new_lemma_173137 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (div_inv_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (div_inv_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_173138 (h0 : topological_space (add_cancel_monoid (ring (add_cancel_monoid (finset Type))))) : path_connected_space (add_cancel_monoid (ring (add_cancel_monoid (finset Type)))) := sorry --non-trivial
lemma new_lemma_173139 (h0 : ring (has_emptyc linarith.comp)) : is_domain (has_emptyc linarith.comp) := sorry --non-trivial
lemma new_lemma_173140 (h0 : list (has_pos_part (ring (ordered_ring name)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_173141 (h0 : not (ring (denumerable linarith.comp_source) -> false)) : @strong_rank_condition.{0} (denumerable.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (denumerable.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_173142 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (mul_zero_class.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (mul_zero_class.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_173143 (h0 : topological_space (denumerable (random_gen linarith.comp_source))) : t0_space (denumerable (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_173144 (h0 : not (ring (add_group congr_arg_kind) -> false)) : @is_domain.{0} (add_group.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (ring.{0} (add_group.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_173145 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (has_sub.{0} empty) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (has_sub.{0} empty))  := sorry --non-trivial
lemma new_lemma_173146 (h0 : not (topological_space (id num) -> false)) : @normal_space.{0} (@id.{2} Type num) (@classical.by_contradiction'.{1} (topological_space.{0} (@id.{2} Type num)) h0)  := sorry --non-trivial
lemma new_lemma_173147 (h1 : ring (has_ssubset linarith.comp_source)) : strong_rank_condition (has_ssubset linarith.comp_source) := sorry --non-trivial
lemma new_lemma_173148 (h0 : semiring (comm_semigroup (has_Inf (sub_neg_monoid (sub_neg_monoid Type))))) : is_noetherian_ring (comm_semigroup (has_Inf (sub_neg_monoid (sub_neg_monoid Type)))) := sorry --non-trivial
lemma new_lemma_173149 (h0 : topological_space (has_add (has_add linarith.comp))) : discrete_topology (has_add (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_173150 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (bin_tree empty)) := sorry --non-trivial
lemma new_lemma_173151 (h0 : fin has_zero.zero) : @separated_space.{0} (ordered_comm_ring.{0} real) (@matrix.vec_empty.{0} (uniform_space.{0} (ordered_comm_ring.{0} real)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_173152 (h0 : function.extfun nat fin) : @is_principal_ideal_ring.{1} (has_bot.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (has_bot.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_173153 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} real.angle (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 real.angle)  := sorry --non-trivial
lemma new_lemma_173154 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (as_linear_order.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (as_linear_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_173155 (h0 : complete_lattice (has_to_string (has_zero environment.implicit_infer_kind))) : is_compactly_generated (has_to_string (has_zero environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_173156 (h0 : ring (has_sub (has_top (has_top unsigned)))) : is_principal_ideal_ring (has_sub (has_top (has_top unsigned))) := sorry --non-trivial
lemma new_lemma_173157 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (linear_ordered_semiring.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (linear_ordered_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_173158 (h1 : complete_lattice (normed_field (normed_field string_imp))) : complete_lattice.is_Sup_finite_compact (normed_field (normed_field string_imp)) := sorry --non-trivial
lemma new_lemma_173159 (h0 : group (has_top (has_nnnorm linarith.ineq))) : group.fg (has_top (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_173160 (h0 : not (complete_lattice (distrib fun_info) -> false)) : @is_compactly_generated.{0} (distrib.{0} fun_info) (@classical.by_contradiction'.{1} (complete_lattice.{0} (distrib.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_173161 (h0 : ring (random_gen (random_gen (has_nnnorm (has_nnnorm char))))) : rank_condition (random_gen (random_gen (has_nnnorm (has_nnnorm char)))) := sorry --non-trivial
lemma new_lemma_173162 (h0 : ring (has_compl (has_ssubset fun_info))) : strong_rank_condition (has_compl (has_ssubset fun_info)) := sorry --non-trivial
lemma new_lemma_173163 (h0 : functor.comp topological_space add_cancel_monoid Type) : @topological_space.separable_space.{1} (add_cancel_monoid.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} add_cancel_monoid.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_173164 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (has_dist.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_dist.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_173165 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (normed_lattice_add_comm_group.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_lattice_add_comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_173166 (h0 : prod (add_comm_monoid unsigned) (add_comm_monoid unsigned)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_173167 (h0 : functor.add_const (topological_space auto.case_option) (option unsigned)) : @discrete_topology.{0} auto.case_option (@functor.add_const.run.{0 0} (topological_space.{0} auto.case_option) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_173168 (h0 : functor.add_const (ring (has_nndist ennreal)) name) : @rank_condition.{0} (has_nndist.{0} ennreal) (@functor.add_const.run.{0 0} (ring.{0} (has_nndist.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_173169 (h0 : has_zero (ring (has_nndist pos)) -> has_zero (ring (has_nndist pos)) -> Prop) : is_symm (has_zero (ring (has_nndist pos))) h0 := sorry --non-trivial
lemma new_lemma_173170 (h0 : complete_lattice (with_one (has_inv (random_gen to_additive.value_type)))) : is_compactly_generated (with_one (has_inv (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_173171 (h0 : functor.add_const (group (has_zero linarith.comp)) environment.implicit_infer_kind) : @is_cyclic.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (has_zero.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_173172 (h0 : topological_space (sub_neg_monoid (has_Inf Type))) : normal_space (sub_neg_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_173173 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (metric_space.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (metric_space.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_173174 (h0 : functor.add_const (topological_space (has_zero ennreal)) Type) : @preconnected_space.{0} (has_zero.{0} ennreal) (@functor.add_const.run.{0 1} (topological_space.{0} (has_zero.{0} ennreal)) Type h0)  := sorry --non-trivial
lemma new_lemma_173175 (h0 : ring (semigroup (boolean_algebra Type))) : is_domain (semigroup (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_173176 (h2 : prod ereal ereal) : set.diagonal ereal h2 := sorry --non-trivial
lemma new_lemma_173177 (h0 : topological_space (boolean_algebra (finset (ring (finset Type))))) : totally_disconnected_space (boolean_algebra (finset (ring (finset Type)))) := sorry --non-trivial
lemma new_lemma_173178 (h0 : add_group (sub_neg_monoid (random_gen (random_gen to_additive.value_type)))) : is_add_cyclic (sub_neg_monoid (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_173179 (h0 : finset (option ennreal) -> finset (option ennreal) -> Prop) : is_symm (finset (option ennreal)) h0 := sorry --non-trivial
lemma new_lemma_173180 (h0 : ring (add_right_cancel_semigroup fun_info)) : is_domain (add_right_cancel_semigroup fun_info) := sorry --non-trivial
lemma new_lemma_173181 (h0 : semiring (add_comm_semigroup (normed_field (normed_field fun_info)))) (h1 : ideal (add_comm_semigroup (normed_field (normed_field fun_info)))) : ideal.is_prime h1 := sorry --non-trivial
lemma new_lemma_173182 (h0 : function.extfun nat fin) : @add_monoid.fg.{0} (ordered_comm_monoid.{0} pos) (@matrix.vec_empty.{0} (add_monoid.{0} (ordered_comm_monoid.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_173183 (h0 : fin has_zero.zero) : @rank_condition.{0} (ordered_comm_ring.{0} real) (@matrix.vec_empty.{0} (ring.{0} (ordered_comm_ring.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_173184 (h0 : functor.add_const (function.extfun (Type 1) topological_space) name) : @irreducible_space.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) name h0) (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_173185 (h2 : has_lt (linear_ordered_comm_group_with_zero linarith.comp_source)) : no_max_order (linear_ordered_comm_group_with_zero linarith.comp_source) := sorry --non-trivial
lemma new_lemma_173186 (h0 : function.extfun nat fin) : @monoid.fg.{0} (has_bot.{0} real) (@matrix.vec_empty.{0} (monoid.{0} (has_bot.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_173187 (h0 : functor.add_const (complete_lattice (normed_linear_ordered_group empty)) empty) : @is_atomistic.{0} (normed_linear_ordered_group.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (normed_linear_ordered_group.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_173188 (h0 : functor.add_const (ring (boolean_algebra.core pos)) pos) : @is_domain.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.core.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_173189 (h0 : topological_space (distrib (has_nnnorm (mul_one_class (has_ssubset reducibility_hints))))) : t0_space (distrib (has_nnnorm (mul_one_class (has_ssubset reducibility_hints)))) := sorry --non-trivial
lemma new_lemma_173190 (h0 : functor.add_const (topological_space Type) name) : @normal_space.{1} Type (@functor.add_const.run.{1 0} (topological_space.{1} Type) name h0)  := sorry --non-trivial
lemma new_lemma_173191 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (option.{0} (option.{0} ennreal)) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (option.{0} (option.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_173192 (h0 : functor.add_const (topological_space (cancel_monoid environment.implicit_infer_kind)) pos) : @t0_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_173193 (h0 : topological_space (has_nndist (finset (finset environment.implicit_infer_kind)))) : normal_space (has_nndist (finset (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_173194 (h0 : function.extfun Type topological_space) : @t1_space.{0} (has_sub.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_sub.{0} num))  := sorry --non-trivial
lemma new_lemma_173195 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (ring.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (ring.{0} name))  := sorry --non-trivial
lemma new_lemma_173196 (h1 : fin has_zero.zero) : matrix.vec_empty h1 := sorry --non-trivial
lemma new_lemma_173197 (h0 : functor.add_const (ordered_add_comm_monoid (has_bot empty)) empty) : @archimedean.{0} (has_bot.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_bot.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_173198 (h1 : ring (has_top string_imp)) : rank_condition (has_top string_imp) := sorry --non-trivial
lemma new_lemma_173199 (h0 : prod (ordered_cancel_add_comm_monoid (option ennreal)) (ordered_cancel_add_comm_monoid (option ennreal))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_173200 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @archimedean.{1} (cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_add_comm_monoid.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ordered_add_comm_monoid.{1}) (cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_173201 (h0 : finset (free_add_monoid (semiring empty))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_173202 (h0 : function.extfun (Type 1) (functor.comp topological_space canonically_ordered_comm_semiring)) : @irreducible_space.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} canonically_ordered_comm_semiring.{1} Type (@function.extfun_app.{3 2} (Type 1) (functor.comp.{1 1 1} topological_space.{1} canonically_ordered_comm_semiring.{1}) h0 Type))  := sorry --non-trivial
lemma new_lemma_173203 (h0 : complete_lattice (mul_zero_class congr_arg_kind)) : complete_lattice.is_Sup_finite_compact (mul_zero_class congr_arg_kind) := sorry --non-trivial
lemma new_lemma_173204 (h0 : functor.add_const (topological_space (mul_zero_class congr_arg_kind)) congr_arg_kind) : @topological_space.separable_space.{0} (mul_zero_class.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_173205 (h0 : functor.add_const (group (add_cancel_monoid linarith.comp)) Type) : @group.fg.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (group.{0} (add_cancel_monoid.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_173206 (h0 : uniform_space (non_assoc_semiring num)) : complete_space (non_assoc_semiring num) := sorry --non-trivial
lemma new_lemma_173207 (h0 : finset (mul_zero_class (semiring empty))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_173208 (h0 : topological_space (has_neg (option ennreal))) : path_connected_space (has_neg (option ennreal)) := sorry --non-trivial
lemma new_lemma_173209 (h0 : topological_space (has_zero ennreal)) : preconnected_space (has_zero ennreal) := sorry --non-trivial
lemma new_lemma_173210 (h0 : complete_lattice (mul_zero_class (semiring num))) : is_compactly_generated (mul_zero_class (semiring num)) := sorry --non-trivial
lemma new_lemma_173211 (h0 : functor.comp ring add_comm_monoid Type) : @strong_rank_condition.{1} (add_comm_monoid.{1} Type) (@functor.comp.run.{1 1 1} ring.{1} add_comm_monoid.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_173212 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_173213 (h0 : functor.comp topological_space has_add name) : @totally_separated_space.{0} (has_add.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} has_add.{0} name h0)  := sorry --non-trivial
lemma new_lemma_173214 (h4 : semiring (has_ssubset char)) (h5 : uniform_space (random_gen (has_ssubset (polynomial (has_ssubset char))))) : complete_space (random_gen (has_ssubset (polynomial (has_ssubset char)))) := sorry --non-trivial
lemma new_lemma_173215 (h0 : functor.add_const (fin has_zero.zero) name) : @complete_space.{0} (normed_lattice_add_comm_group.{0} real) (@matrix.vec_empty.{0} (uniform_space.{0} (normed_lattice_add_comm_group.{0} real)) (@functor.add_const.run.{0 0} (fin (@has_zero.zero.{0} nat nat.has_zero)) name h0))  := sorry --non-trivial
lemma new_lemma_173216 (h0 : ordered_add_comm_monoid (as_linear_order (option (option empty)))) : archimedean (as_linear_order (option (option empty))) := sorry --non-trivial
lemma new_lemma_173217 (h0 : topological_space (mul_one_class environment.projection_info)) : totally_disconnected_space (mul_one_class environment.projection_info) := sorry --non-trivial
lemma new_lemma_173218 (h0 : function.extfun nat fin) : @locally_compact_space.{1} (canonically_linear_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (canonically_linear_ordered_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_173219 (h0 : functor.add_const (complete_lattice (boolean_algebra.core Type)) pos) : @complete_lattice.is_Sup_finite_compact.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (boolean_algebra.core.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_173220 (h0 : topological_space (ordered_cancel_add_comm_monoid ennreal)) : normal_space (ordered_cancel_add_comm_monoid ennreal) := sorry --non-trivial
lemma new_lemma_173221 (h0 : topological_space (has_emptyc linarith.comp)) : totally_disconnected_space (has_emptyc linarith.comp) := sorry --non-trivial
lemma new_lemma_173222 (h0 : group (has_pos_part (finset (ring (finset (finset pos)))))) : is_cyclic (has_pos_part (finset (ring (finset (finset pos))))) := sorry --non-trivial
lemma new_lemma_173223 (h0 : topological_space (has_Sup (semiring congr_arg_kind))) : t1_space (has_Sup (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_173224 (h0 : topological_space occurrences) : locally_compact_space occurrences := sorry --non-trivial
lemma new_lemma_173225 (h0 : has_mem.mem ring has_emptyc.emptyc) : @strong_rank_condition.{0} (normed_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} h0) (normed_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_173226 (h0 : functor.add_const (topological_space (ring pos)) Type) : @discrete_topology.{0} (ring.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (ring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_173227 (h0 : functor.add_const (topological_space (linear_ordered_add_comm_monoid_with_top pos)) pos) : @preconnected_space.{0} (linear_ordered_add_comm_monoid_with_top.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_add_comm_monoid_with_top.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_173228 (h0 : function.extfun nat fin) : @has_exists_mul_of_le.{0} (boolean_algebra.{0} pos) (@matrix.vec_empty.{0} (ordered_comm_monoid.{0} (boolean_algebra.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_173229 (h0 : add_monoid (comm_group (option name))) : add_monoid.fg (comm_group (option name)) := sorry --non-trivial
lemma new_lemma_173230 (h0 : set (has_nnnorm environment.projection_info)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_173231 (h0 : topological_space (fintype char)) : path_connected_space (fintype char) := sorry --non-trivial
lemma new_lemma_173232 (h0 : with_bot (uniform_space (semi_normed_comm_ring fun_info))) (h1 : ne h0 has_bot.bot) : @complete_space.{0} (semi_normed_comm_ring.{0} fun_info) (@with_bot.unbot.{0} (uniform_space.{0} (semi_normed_comm_ring.{0} fun_info)) h0 h1)  := sorry --non-trivial
lemma new_lemma_173233 (h0 : functor.add_const (topological_space (complete_distrib_lattice Type)) linarith.comp) : @regular_space.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (complete_distrib_lattice.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_173234 (h0 : topological_space (with_one linarith.comp_source)) : totally_disconnected_space (with_one linarith.comp_source) := sorry --non-trivial
lemma new_lemma_173235 (h0 : ring (normed_comm_ring (has_to_string linarith.comp))) : is_domain (normed_comm_ring (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_173236 (h0 : group (has_nndist (has_to_string name))) : normalizer_condition (has_nndist (has_to_string name)) := sorry --non-trivial
lemma new_lemma_173237 (h0 : not (has_mem.mem (linear_ordered_add_comm_group num) has_emptyc.emptyc -> false)) : @is_cyclic.{0} (linear_ordered_add_comm_group.{0} num) (@finset.pi.empty.{1 0} Type group.{0} (linear_ordered_add_comm_group.{0} num) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (linear_ordered_add_comm_group.{0} num) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_173238 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (distrib_lattice.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (distrib_lattice.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_173239 (h0 : group (add_cancel_comm_monoid (has_nnnorm reducibility_hints))) : is_cyclic (add_cancel_comm_monoid (has_nnnorm reducibility_hints)) := sorry --non-trivial
lemma new_lemma_173240 (h0 : topological_space (mul_zero_class (semiring empty))) : discrete_topology (mul_zero_class (semiring empty)) := sorry --non-trivial
lemma new_lemma_173241 (h0 : group (has_top (measurable_space linarith.comp))) : group.fg (has_top (measurable_space linarith.comp)) := sorry --non-trivial
lemma new_lemma_173242 (h0 : add_group (mul_zero_class (finset (has_nndist pos)))) : is_add_cyclic (mul_zero_class (finset (has_nndist pos))) := sorry --non-trivial
lemma new_lemma_173243 (h0 : ring (fintype (has_ssubset linarith.comp_source))) : is_domain (fintype (has_ssubset linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_173244 (h0 : group (boolean_algebra (has_pos_part (sub_neg_monoid (has_Inf (has_add Type)))))) : group.fg (boolean_algebra (has_pos_part (sub_neg_monoid (has_Inf (has_add Type))))) := sorry --non-trivial
lemma new_lemma_173245 (h0 : functor.add_const (topological_space (has_neg pos)) (option pos)) : @t1_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} pos)) (option.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_173246 (h0 : functor.add_const (ring (normed_linear_ordered_group empty)) empty) : @strong_rank_condition.{0} (normed_linear_ordered_group.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (normed_linear_ordered_group.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_173247 (h0 : group (has_add (finset (has_add (has_to_string linarith.comp))))) : is_simple_group (has_add (finset (has_add (has_to_string linarith.comp)))) := sorry --non-trivial
lemma new_lemma_173248 (h0 : list (has_top (has_ssubset (dlist (has_norm fun_info))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_173249 (h0 : fin has_zero.zero) : @path_connected_space.{0} (canonically_linear_ordered_monoid.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (canonically_linear_ordered_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_173250 (h0 : fin has_zero.zero) : @is_compactly_generated.{0} (comm_semigroup.{0} pos) (@matrix.vec_empty.{0} (complete_lattice.{0} (comm_semigroup.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_173251 (h0 : has_mem.mem complete_lattice has_emptyc.emptyc) : @is_atomistic.{0} (normed_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} h0) (normed_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_173252 (h0 : topological_space (has_inter empty)) : path_connected_space (has_inter empty) := sorry --non-trivial
lemma new_lemma_173253 (h0 : functor.add_const (group (complete_distrib_lattice linarith.comp)) linarith.comp) : @normalizer_condition.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (complete_distrib_lattice.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_173254 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (complete_semilattice_Sup.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_173255 (h0 : group (generalized_boolean_algebra (finset pos))) : is_cyclic (generalized_boolean_algebra (finset pos)) := sorry --non-trivial
lemma new_lemma_173256 (h0 : functor.add_const (functor.add_const (group environment.implicit_infer_kind) pos) pos) : @normalizer_condition.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 0} (group.{0} environment.implicit_infer_kind) pos (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (group.{0} environment.implicit_infer_kind) pos) pos h0))  := sorry --non-trivial
lemma new_lemma_173257 (h0 : partial_order num -> partial_order num -> Prop) : is_strict_order (partial_order num) h0 := sorry --non-trivial
lemma new_lemma_173258 (h0 : group linarith.comp) : is_cyclic linarith.comp := sorry --non-trivial
lemma new_lemma_173259 (h0 : set (add_comm_semigroup (normed_field (normed_field (mul_one_class std_gen))))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_173260 (h0 : functor.add_const (complete_lattice (comm_group unsigned)) unsigned) : @is_compactly_generated.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (comm_group.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_173261 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (linear_ordered_add_comm_group.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (linear_ordered_add_comm_group.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_173262 (h0 : function.extfun Type (functor.comp semiring has_neg)) : @is_noetherian_ring.{0} (has_neg.{0} unsigned) (@functor.comp.run.{0 0 0} semiring.{0} has_neg.{0} unsigned (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} semiring.{0} has_neg.{0}) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_173263 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring Type)) name) : @normal_space.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (canonically_ordered_comm_semiring.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_173264 (h0 : not (topological_space (semiring unsigned) -> false)) : @irreducible_space.{0} (semiring.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (semiring.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_173265 (h0 : fin has_zero.zero) : @is_add_cyclic.{0} (has_bot.{0} pos) (@matrix.vec_empty.{0} (add_group.{0} (has_bot.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_173266 (h0 : group (has_to_string real)) : group.fg (has_to_string real) := sorry --non-trivial
lemma new_lemma_173267 (h0 : functor.add_const (finset (has_nndist environment.implicit_infer_kind)) (finset (has_to_string name))) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_173268 (h0 : function.extfun Type group) : @is_simple_group.{0} (has_add.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (has_add.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_173269 (h0 : functor.comp topological_space complete_distrib_lattice name) : @locally_compact_space.{0} (complete_distrib_lattice.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} complete_distrib_lattice.{0} name h0)  := sorry --non-trivial
lemma new_lemma_173270 (h0 : list (has_neg unsigned)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_173271 (h0 : group (finset (has_add (boolean_algebra.core Type)))) : normalizer_condition (finset (has_add (boolean_algebra.core Type))) := sorry --non-trivial
lemma new_lemma_173272 (h0 : topological_space (has_add (has_Inf Type))) : preconnected_space (has_add (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_173273 (h0 : finset (has_to_string (option (option ennreal)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_173274 (h0 : ring (preorder (semiring empty))) : is_domain (preorder (semiring empty)) := sorry --non-trivial
lemma new_lemma_173275 (h0 : topological_space (has_nndist (has_add pos))) : t0_space (has_nndist (has_add pos)) := sorry --non-trivial
lemma new_lemma_173276 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (has_neg_part ennreal)) := sorry --non-trivial
lemma new_lemma_173277 (h0 : ring (add_comm_monoid name)) : strong_rank_condition (add_comm_monoid name) := sorry --non-trivial
lemma new_lemma_173278 (h0 : functor.add_const (group (plift num)) (semiring empty)) : @is_cyclic.{1} (plift.{1} num) (@functor.add_const.run.{1 0} (group.{1} (plift.{1} num)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_173279 (h0 : filter (complete_distrib_lattice (option (option (option unsigned))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_173280 (h0 : topological_space (linear_ordered_add_comm_group fun_info)) : irreducible_space (linear_ordered_add_comm_group fun_info) := sorry --non-trivial
lemma new_lemma_173281 (h0 : not (topological_space (has_nnnorm linarith.ineq) -> false)) : @path_connected_space.{0} (has_nnnorm.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (has_nnnorm.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_173282 (h0 : ring (distrib (random_gen linarith.comp_source))) : is_domain (distrib (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_173283 (h0 : topological_space (has_norm string_imp)) : path_connected_space (has_norm string_imp) := sorry --non-trivial
lemma new_lemma_173284 (h0 : topological_space (with_bot num)) : totally_disconnected_space (with_bot num) := sorry --non-trivial
lemma new_lemma_173285 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (has_norm string_imp)) := sorry --non-trivial
lemma new_lemma_173286 (h0 : set (uniform_space (uniform_space to_additive.value_type))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_173287 (h0 : functor.add_const (complete_lattice (bin_tree empty)) num) : @complete_lattice.is_Sup_finite_compact.{0} (bin_tree.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (bin_tree.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_173288 (h0 : ring (simple_graph (has_le string.iterator_imp))) : is_domain (simple_graph (has_le string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_173289 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (canonically_ordered_add_monoid.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} h0 (canonically_ordered_add_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_173290 (h0 : set (has_lt (mul_one_class (mul_one_class linarith.comp_source)))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_173291 (h0 : topological_space (ordered_comm_ring (has_Inf name))) : totally_separated_space (ordered_comm_ring (has_Inf name)) := sorry --non-trivial
lemma new_lemma_173292 (h0 : functor.add_const (function.extfun Type list) Type) : palindrome (function.extfun_app (functor.add_const.run h0) (ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_173293 (h0 : list (semigroup (has_neg Type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_173294 (h0 : has_lt (semi_normed_comm_ring ereal)) : no_max_order (semi_normed_comm_ring ereal) := sorry --non-trivial
lemma new_lemma_173295 (h0 : topological_space (has_Inf (has_Inf linarith.comp))) : totally_disconnected_space (has_Inf (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_173296 (h0 : measurable_space (has_lt linarith.ineq)) (h1 : has_div (has_lt linarith.ineq)) : has_measurable_div (has_lt linarith.ineq) := sorry --non-trivial
lemma new_lemma_173297 (h0 : not (function.extfun (finset Type) (has_mem.mem num) -> false)) : @totally_separated_space.{0} num (@finset.pi.empty.{1 0} Type topological_space.{0} num (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) num) (@classical.by_contradiction'.{0} (function.extfun.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) num)) h0) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_173298 (h0 : function.extfun Type group) : @normalizer_condition.{0} (omega_complete_partial_order.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (omega_complete_partial_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_173299 (h0 : ring (add_group (id num))) : rank_condition (add_group (id num)) := sorry --non-trivial
lemma new_lemma_173300 (h0 : ring (denumerable (has_nnnorm (random_gen char)))) : rank_condition (denumerable (has_nnnorm (random_gen char))) := sorry --non-trivial
lemma new_lemma_173301 (h0 : group (has_zero (complete_distrib_lattice environment.implicit_infer_kind))) : is_simple_group (has_zero (complete_distrib_lattice environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_173302 (h0 : function.extfun (Type 1) topological_space) : @topological_space.separable_space.{1} (plift.{1} congr_arg_kind) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (plift.{1} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_173303 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (@id.{2} Type unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (@id.{2} Type unsigned))  := sorry --non-trivial
lemma new_lemma_173304 (h2 : set (ereal -> fun_info)) : set.separates_points h2 := sorry --non-trivial
lemma new_lemma_173305 (h0 : not (topological_space (linear_ordered_comm_ring congr_arg_kind) -> false)) : @normal_space.{0} (linear_ordered_comm_ring.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_comm_ring.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_173306 (h0 : functor.add_const (topological_space (has_Inf name)) name) : @t0_space.{0} (has_Inf.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_173307 (h0 : functor.add_const (fin has_zero.zero) real) : @regular_space.{1} (comm_semigroup.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (comm_semigroup.{1} Type)) (@functor.add_const.run.{0 0} (fin (@has_zero.zero.{0} nat nat.has_zero)) real h0))  := sorry --non-trivial
lemma new_lemma_173308 (h0 : simple_graph (has_Sup num)) (h1 : has_Sup num) (h2 : function.extfun Type has_Sup) : simple_graph.neighbor_set h0 h1 (function.extfun_app h2 num) := sorry --non-trivial
lemma new_lemma_173309 (h0 : finset (add_comm_monoid (comm_group (finset name)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_173310 (h1 : set (ereal -> char)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_173311 (h0 : functor.add_const (group (ring environment.implicit_infer_kind)) pos) : @normalizer_condition.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (ring.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_173312 (h1 : ring (add_monoid string_imp)) : rank_condition (add_monoid string_imp) := sorry --non-trivial
lemma new_lemma_173313 (h0 : ring (cancel_monoid Type)) : is_domain (cancel_monoid Type) := sorry --non-trivial
lemma new_lemma_173314 (h0 : functor.add_const (topological_space (semigroup ennreal)) unsigned) : @path_connected_space.{0} (semigroup.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_173315 (h0 : function.extfun (Type 1) topological_space) : @t1_space.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_173316 (h0 : topological_space (has_add (finset environment.implicit_infer_kind))) : path_connected_space (has_add (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_173317 (h0 : add_group (has_one (semiring congr_arg_kind))) : is_add_cyclic (has_one (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_173318 (h0 : uniform_space (has_emptyc (random_gen linarith.comp_source))) : complete_space (has_emptyc (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_173319 (h0 : functor.add_const (monoid (linear_ordered_comm_monoid_with_zero empty)) empty) : @monoid.fg.{0} (linear_ordered_comm_monoid_with_zero.{0} empty) (@functor.add_const.run.{0 0} (monoid.{0} (linear_ordered_comm_monoid_with_zero.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_173320 (h5 : preorder (add_comm_semigroup enat)) (h6 : set (add_comm_semigroup enat)) : set.is_pwo h6 := sorry --non-trivial
lemma new_lemma_173321 (h0 : functor.add_const (group (has_nndist empty)) empty) : @normalizer_condition.{0} (has_nndist.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (has_nndist.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_173322 (h0 : ereal -> ereal -> Prop) (h1 : set ereal) : set.bounded h0 h1 := sorry --non-trivial
lemma new_lemma_173323 (h0 : topological_space (has_emptyc (has_top num))) : irreducible_space (has_emptyc (has_top num)) := sorry --non-trivial
lemma new_lemma_173324 (h0 : functor.add_const (function.extfun Type group) (finset name)) : @normalizer_condition.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) (finset.{0} name) h0) (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_173325 (h0 : filter (semiring empty)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_173326 (h0 : functor.add_const (function.extfun Type topological_space) (has_to_string linarith.comp)) : @loc_path_connected_space.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (has_to_string.{0} linarith.comp) h0) (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_173327 (h0 : fin has_zero.zero) : @is_atomistic.{0} (has_add.{0} pos) (@matrix.vec_empty.{0} (complete_lattice.{0} (has_add.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_173328 (h0 : functor.add_const (topological_space pos) pos) : @t1_space.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) pos h0)  := sorry --non-trivial
lemma new_lemma_173329 (h0 : functor.comp filter normed_comm_ring Type) : filter.ne_bot (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_173330 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (div_inv_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (div_inv_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_173331 (h0 : topological_space (nondiscrete_normed_field string.iterator_imp)) (h1 : add_group (nondiscrete_normed_field string.iterator_imp)) : topological_add_group (nondiscrete_normed_field string.iterator_imp) := sorry --non-trivial
lemma new_lemma_173332 (h1 : uniform_space (nondiscrete_normed_field ereal)) : complete_space (nondiscrete_normed_field ereal) := sorry --non-trivial
lemma new_lemma_173333 (h0 : ring complex) : rank_condition complex := sorry --non-trivial
lemma new_lemma_173334 (h0 : functor.add_const (group (add_cancel_monoid linarith.comp)) (has_nndist (has_to_string linarith.comp))) : @is_simple_group.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (add_cancel_monoid.{0} linarith.comp)) (has_nndist.{0} (has_to_string.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_173335 (h0 : uniform_space (mul_zero_class (semiring (semiring num)))) : complete_space (mul_zero_class (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_173336 (h0 : functor.add_const (ring (cancel_monoid Type)) pos) : @is_domain.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (cancel_monoid.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_173337 (h0 : functor.add_const (ring (bin_tree empty)) empty) : @rank_condition.{0} (bin_tree.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (bin_tree.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_173338 (h0 : functor.add_const (topological_space (normed_linear_ordered_group unsigned)) unsigned) : @topological_space.separable_space.{0} (normed_linear_ordered_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_linear_ordered_group.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_173339 (h0 : finset (boolean_algebra (has_Inf (has_Inf pos)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_173340 (h0 : not (topological_space (left_cancel_monoid congr_arg_kind) -> false)) : @irreducible_space.{0} (left_cancel_monoid.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (left_cancel_monoid.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_173341 (h0 : topological_space (boolean_algebra (has_pos_part pos))) : t1_space (boolean_algebra (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_173342 (h0 : functor.add_const (topological_space (cancel_monoid empty)) num) : @locally_compact_space.{0} (cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_173343 (h0 : ring (ring (ring (boolean_algebra.core pos)))) : is_domain (ring (ring (boolean_algebra.core pos))) := sorry --non-trivial
lemma new_lemma_173344 (h0 : ring (ordered_comm_ring (has_neg name))) : is_domain (ordered_comm_ring (has_neg name)) := sorry --non-trivial
lemma new_lemma_173345 (h0 : function.extfun Type topological_space) : @regular_space.{0} (finset.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} name))  := sorry --non-trivial
lemma new_lemma_173346 (h0 : functor.add_const (ordered_add_comm_monoid (has_to_string linarith.comp)) environment.implicit_infer_kind) : @archimedean.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_to_string.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_173347 (h0 : functor.add_const (ring (boolean_algebra.core linarith.comp)) (ring linarith.comp)) : @strong_rank_condition.{0} (boolean_algebra.core.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.core.{0} linarith.comp)) (ring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_173348 (h0 : topological_space (normed_lattice_add_comm_group real)) : totally_separated_space (normed_lattice_add_comm_group real) := sorry --non-trivial
lemma new_lemma_173349 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (has_add.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_add.{0} num))  := sorry --non-trivial
lemma new_lemma_173350 (h0 : ring (normed_field linarith.comp_source)) : strong_rank_condition (normed_field linarith.comp_source) := sorry --non-trivial
lemma new_lemma_173351 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (complete_distrib_lattice.{0} name) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (complete_distrib_lattice.{0} name))  := sorry --non-trivial
lemma new_lemma_173352 (h0 : add_monoid (add_cancel_monoid (boolean_algebra linarith.comp))) : add_monoid.fg (add_cancel_monoid (boolean_algebra linarith.comp)) := sorry --non-trivial
lemma new_lemma_173353 (h0 : topological_space (semiring (has_norm fun_info))) : totally_separated_space (semiring (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_173354 (h0 : functor.add_const (topological_space (ring Type)) pos) : @loc_path_connected_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ring.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_173355 (h0 : semiring (has_to_string (finset linarith.comp))) : is_noetherian_ring (has_to_string (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_173356 (h0 : list (ordered_ring empty)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_173357 (h0 : topological_space (fintype char)) : locally_compact_space (fintype char) := sorry --non-trivial
lemma new_lemma_173358 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @complete_space.{0} num (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) uniform_space.{0}) num)  := sorry --non-trivial
lemma new_lemma_173359 (h0 : complete_lattice (has_star (semiring (semiring (semiring empty))))) : is_atomistic (has_star (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_173360 (h0 : group (mul_zero_class congr_arg_kind)) : normalizer_condition (mul_zero_class congr_arg_kind) := sorry --non-trivial
lemma new_lemma_173361 (h0 : list (has_top (random_gen (has_norm to_additive.value_type)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_173362 (h0 : topological_space (has_inner (option unsigned) unsigned)) : irreducible_space (has_inner (option unsigned) unsigned) := sorry --non-trivial
lemma new_lemma_173363 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (linear_ordered_cancel_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (linear_ordered_cancel_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_173364 (h0 h1 : multiset (random_gen (random_gen char))) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_173365 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (add_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (add_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_173366 (h0 : topological_space (with_one (has_norm num))) : totally_disconnected_space (with_one (has_norm num)) := sorry --non-trivial
lemma new_lemma_173367 (h0 : topological_space (denumerable (has_nnnorm (has_nnnorm (has_nnnorm linarith.comp_source))))) : t0_space (denumerable (has_nnnorm (has_nnnorm (has_nnnorm linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_173368 (h0 : not (function.extfun Type topological_space -> false)) : @totally_disconnected_space.{0} (with_bot.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (with_bot.{0} num))  := sorry --non-trivial
lemma new_lemma_173369 (h0 : fin has_zero.zero) : @Lim.{0} Prop sierpinski_space (@nonempty_of_inhabited.{1} Prop sort.inhabited.{0}) (@list.head.{0} (filter.{0} Prop) (@filter.inhabited.{0} Prop) (@matrix.vec_empty.{0} (list.{0} (filter.{0} Prop)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)))  := sorry --non-trivial
lemma new_lemma_173370 (h0 : function.extfun Type (functor.comp list has_to_string)) : list.nodup (functor.comp.run (function.extfun_app h0 environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_173371 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_emptyc.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_emptyc.{0} empty))  := sorry --non-trivial
lemma new_lemma_173372 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (normed_comm_ring empty)) := sorry --non-trivial
lemma new_lemma_173373 (h0 : topological_space (group_with_zero ennreal)) : t1_space (group_with_zero ennreal) := sorry --non-trivial
lemma new_lemma_173374 (h0 : uniform_space (canonically_ordered_monoid (has_neg name))) : separated_space (canonically_ordered_monoid (has_neg name)) := sorry --non-trivial
lemma new_lemma_173375 (h0 : topological_space (finset (has_zero (finset linarith.comp)))) : topological_space.separable_space (finset (has_zero (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_173376 (h0 : group (ring (has_add linarith.comp))) : is_cyclic (ring (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_173377 (h0 : not (ring (measurable_space.dynkin_system congr_arg_kind) -> false)) : @strong_rank_condition.{0} (measurable_space.dynkin_system.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (ring.{0} (measurable_space.dynkin_system.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_173378 (h0 : topological_space (comm_semigroup (comm_semigroup real))) : regular_space (comm_semigroup (comm_semigroup real)) := sorry --non-trivial
lemma new_lemma_173379 (h0 : filter (ordered_comm_group (option (option (option empty))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_173380 (h0 : has_mem.mem (has_top (has_norm (has_norm (has_norm linarith.comp_source)))) has_emptyc.emptyc) : @irreducible_space.{0} (has_top.{0} (has_norm.{0} (has_norm.{0} (has_norm.{0} linarith.comp_source)))) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_top.{0} (has_norm.{0} (has_norm.{0} (has_norm.{0} linarith.comp_source)))) h0)  := sorry --non-trivial
lemma new_lemma_173381 (h0 : topological_space (canonically_ordered_comm_semiring (has_dist unsigned))) : normal_space (canonically_ordered_comm_semiring (has_dist unsigned)) := sorry --non-trivial
lemma new_lemma_173382 (h0 : semiring (generalized_boolean_algebra (has_neg name))) : is_noetherian_ring (generalized_boolean_algebra (has_neg name)) := sorry --non-trivial
lemma new_lemma_173383 (h0 : topological_space (linear_ordered_add_comm_monoid_with_top (option (option ennreal)))) : irreducible_space (linear_ordered_add_comm_monoid_with_top (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_173384 (h0 : ring (has_nnnorm linarith.comp_source)) : rank_condition (has_nnnorm linarith.comp_source) := sorry --non-trivial
lemma new_lemma_173385 (h0 : complete_lattice (has_append (distrib reducibility_hints))) : complete_lattice.is_Sup_finite_compact (has_append (distrib reducibility_hints)) := sorry --non-trivial
lemma new_lemma_173386 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : palindrome (function.extfun_app (function.extfun_app h0 list) (has_neg Type)) := sorry --non-trivial
lemma new_lemma_173387 (h0 : functor.add_const (ordered_add_comm_monoid (cancel_monoid environment.implicit_infer_kind)) pos) : @archimedean.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (cancel_monoid.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_173388 (h0 : functor.add_const (topological_space (has_Sup unsigned)) congr_arg_kind) : @irreducible_space.{0} (has_Sup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Sup.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_173389 (h0 : functor.add_const (topological_space (has_Inf linarith.comp)) pos) : @normal_space.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_173390 (h0 : functor.add_const (topological_space (has_Inf linarith.comp)) Type) : @locally_compact_space.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_Inf.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_173391 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (ordered_cancel_add_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_cancel_add_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_173392 (h0 : set (linear_ordered_comm_group_with_zero to_additive.value_type)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_173393 (h0 : uniform_space (nondiscrete_normed_field std_gen)) : complete_space (nondiscrete_normed_field std_gen) := sorry --non-trivial
lemma new_lemma_173394 (h0 : ring (normed_group (semiring fun_info))) : rank_condition (normed_group (semiring fun_info)) := sorry --non-trivial
lemma new_lemma_173395 (h0 : topological_space (has_add (sub_neg_monoid Type))) : sequential_space (has_add (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_173396 (h0 : topological_space (has_add (option pos))) : preirreducible_space (has_add (option pos)) := sorry --non-trivial
lemma new_lemma_173397 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : functor.const.run (function.extfun_app (function.extfun_app h0 (functor.const Prop)) string_imp) := sorry --non-trivial
lemma new_lemma_173398 (h0 : ring (cancel_monoid (option (option (option (option (option unsigned))))))) : is_domain (cancel_monoid (option (option (option (option (option unsigned)))))) := sorry --non-trivial
lemma new_lemma_173399 (h0 : functor.add_const (filter Type) pos) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_173400 (h0 : ordered_comm_monoid (comm_group (has_to_string unsigned))) : has_exists_mul_of_le (comm_group (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_173401 (h0 : uniform_space (canonically_ordered_comm_semiring (mul_zero_class name))) : complete_space (canonically_ordered_comm_semiring (mul_zero_class name)) := sorry --non-trivial
lemma new_lemma_173402 (h0 : topological_space (has_one (semiring (has_norm empty)))) : totally_disconnected_space (has_one (semiring (has_norm empty))) := sorry --non-trivial
lemma new_lemma_173403 (h0 : topological_space (cancel_monoid (option empty))) : totally_disconnected_space (cancel_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_173404 (h0 : fin has_zero.zero) : matrix.vec_empty (matrix.vec_empty (matrix.vec_empty h0)) := sorry --non-trivial
lemma new_lemma_173405 (h0 : topological_space (ordered_cancel_add_comm_monoid (option pos))) : loc_path_connected_space (ordered_cancel_add_comm_monoid (option pos)) := sorry --non-trivial
lemma new_lemma_173406 (h1 : topological_space (uniform_space (uniform_space to_additive.value_type))) : t0_space (uniform_space (uniform_space to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_173407 (h0 : topological_space (has_nndist (has_to_string (option pos)))) : totally_separated_space (has_nndist (has_to_string (option pos))) := sorry --non-trivial
lemma new_lemma_173408 (h0 : group (semigroup (finset (finset (has_to_string linarith.comp))))) : group.fg (semigroup (finset (finset (has_to_string linarith.comp)))) := sorry --non-trivial
lemma new_lemma_173409 (h0 : topological_space (comm_ring (random_gen (random_gen (random_gen string.iterator_imp))))) : t0_space (comm_ring (random_gen (random_gen (random_gen string.iterator_imp)))) := sorry --non-trivial
lemma new_lemma_173410 (h0 : functor.add_const (topological_space (boolean_algebra unsigned)) environment.implicit_infer_kind) : @totally_separated_space.{0} (boolean_algebra.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_173411 (h0 : nat) (h1 : topological_space nat) (h2 : nat) : joined h2 (nat.pred h0) := sorry --non-trivial
lemma new_lemma_173412 (h0 : functor.add_const (ring (ordered_comm_group empty)) empty) : @rank_condition.{0} (ordered_comm_group.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (ordered_comm_group.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_173413 (h0 : functor.add_const (topological_space (has_to_string name)) unsigned) : @locally_compact_space.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_173414 (h0 : functor.add_const (cancel_comm_monoid_with_zero (sub_neg_monoid pos)) linarith.comp) : @unique_factorization_monoid.{0} (sub_neg_monoid.{0} pos) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (sub_neg_monoid.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_173415 (h0 : has_mem.mem (normed_group linarith.ineq) has_emptyc.emptyc) : @totally_separated_space.{0} (normed_group.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type topological_space.{0} (normed_group.{0} linarith.ineq) h0)  := sorry --non-trivial
lemma new_lemma_173416 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_173417 (h0 : uniform_space (add_cancel_monoid (has_neg_part (has_neg (has_neg Type))))) : complete_space (add_cancel_monoid (has_neg_part (has_neg (has_neg Type)))) := sorry --non-trivial
lemma new_lemma_173418 (h0 : ring (boolean_algebra.core (has_add (comm_group unsigned)))) : strong_rank_condition (boolean_algebra.core (has_add (comm_group unsigned))) := sorry --non-trivial
lemma new_lemma_173419 (h0 : linarith.comp_source -> topological_space (distrib_lattice string_imp)) (h1 : unit) (h2 : linarith.comp_source) : @path_connected_space.{0} (distrib_lattice.{0} string_imp) (@matrix.row.{0 0} linarith.comp_source (topological_space.{0} (distrib_lattice.{0} string_imp)) h0 h1 h2)  := sorry --non-trivial
lemma new_lemma_173420 (h0 : complete_lattice (semiring (option unsigned))) : complete_lattice.is_Sup_finite_compact (semiring (option unsigned)) := sorry --non-trivial
lemma new_lemma_173421 (h0 : topological_space (canonically_linear_ordered_monoid num)) : t1_space (canonically_linear_ordered_monoid num) := sorry --non-trivial
lemma new_lemma_173422 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (boolean_algebra.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_173423 (h0 : set (has_le (mul_one_class enat))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_173424 (h0 : topological_space (boolean_algebra (has_add environment.implicit_infer_kind))) : normal_space (boolean_algebra (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_173425 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (ring.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_173426 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @separated_space.{0} (has_nndist.{0} pos) (@matrix.vec_empty.{0} (uniform_space.{0} (has_nndist.{0} pos)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_173427 (h0 : functor.comp complete_lattice has_neg Type) : @complete_lattice.is_Sup_finite_compact.{1} (has_neg.{1} Type) (@functor.comp.run.{1 1 1} complete_lattice.{1} has_neg.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_173428 (h0 : monoid (id unsigned)) : monoid.fg (id unsigned) := sorry --non-trivial
lemma new_lemma_173429 (h0 : uniform_space (has_nndist (finset (has_add pos)))) : separated_space (has_nndist (finset (has_add pos))) := sorry --non-trivial
lemma new_lemma_173430 (h0 : functor.comp topological_space add_comm_monoid name) : @totally_disconnected_space.{0} (add_comm_monoid.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} add_comm_monoid.{0} name h0)  := sorry --non-trivial
lemma new_lemma_173431 (h0 : topological_space (add_comm_monoid (has_Inf (has_add (has_add pos))))) : locally_compact_space (add_comm_monoid (has_Inf (has_add (has_add pos)))) := sorry --non-trivial
lemma new_lemma_173432 (h0 : topological_space (has_norm (random_gen (random_gen (random_gen (random_gen string_imp)))))) : locally_compact_space (has_norm (random_gen (random_gen (random_gen (random_gen string_imp))))) := sorry --non-trivial
lemma new_lemma_173433 (h0 : topological_space (has_top (semiring (has_top empty)))) : totally_disconnected_space (has_top (semiring (has_top empty))) := sorry --non-trivial
lemma new_lemma_173434 (h0 : function.extfun Type topological_space) : @t0_space.{0} (semi_normed_comm_ring.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semi_normed_comm_ring.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_173435 (h0 : ring (fintype (has_inv string_imp))) : strong_rank_condition (fintype (has_inv string_imp)) := sorry --non-trivial
lemma new_lemma_173436 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_neg_part.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_173437 (h0 : functor.add_const (group (boolean_algebra environment.implicit_infer_kind)) environment.implicit_infer_kind) : @is_cyclic.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_173438 (h0 : topological_space (has_to_string (mul_one_class environment.implicit_infer_kind))) : preirreducible_space (has_to_string (mul_one_class environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_173439 (h0 : topological_space (has_append (has_inv char))) : totally_disconnected_space (has_append (has_inv char)) := sorry --non-trivial
lemma new_lemma_173440 (h0 : topological_space (has_union (semiring linarith.comp))) : normal_space (has_union (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_173441 (h0 : group (has_top (has_norm empty))) : group.fg (has_top (has_norm empty)) := sorry --non-trivial
lemma new_lemma_173442 (h1 : complete_lattice (has_compl char)) : is_compactly_generated (has_compl char) := sorry --non-trivial
lemma new_lemma_173443 (h0 : fin has_zero.zero) : @complete_lattice.is_Sup_finite_compact.{0} (sub_neg_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (complete_lattice.{0} (sub_neg_monoid.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_173444 (h0 : functor.add_const (topological_space ennreal) num) : normal_space ennreal := sorry --non-trivial
lemma new_lemma_173445 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (has_norm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_173446 (h0 : topological_space (comm_group (has_add environment.implicit_infer_kind))) : topological_space.separable_space (comm_group (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_173447 (h0 : functor.add_const (complete_lattice (finset unsigned)) environment.implicit_infer_kind) : @is_atomistic.{0} (finset.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (finset.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_173448 (h0 : function.extfun Type topological_space) : @t1_space.{0} (complete_distrib_lattice.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} pos))  := sorry --non-trivial
lemma new_lemma_173449 (h1 : ring (metric_space num)) : rank_condition (metric_space num) := sorry --non-trivial
lemma new_lemma_173450 (h0 : topological_space (has_emptyc num)) : t0_space (has_emptyc num) := sorry --non-trivial
lemma new_lemma_173451 (h0 : function.extfun nat fin) : @locally_compact_space.{1} (finset.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (finset.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_173452 (h0 : topological_space (has_le (semi_normed_ring string_imp))) : path_connected_space (has_le (semi_normed_ring string_imp)) := sorry --non-trivial
lemma new_lemma_173453 (h0 : not (uniform_space (normed_field char) -> false)) : @complete_space.{0} (normed_field.{0} char) (@classical.by_contradiction'.{1} (uniform_space.{0} (normed_field.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_173454 (h0 : topological_space (has_add linarith.comp)) : irreducible_space (has_add linarith.comp) := sorry --non-trivial
lemma new_lemma_173455 (h0 : has_mem.mem complete_lattice has_emptyc.emptyc) : @is_atomistic.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} h0) (complete_semilattice_Sup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_173456 (h0 : not (has_mem.mem topological_space has_emptyc.emptyc -> false)) : @discrete_topology.{0} (with_one.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0} (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type)))) h0)) (with_one.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_173457 (h1 : complete_lattice (has_div std_gen)) : is_compactly_generated (has_div std_gen) := sorry --non-trivial
lemma new_lemma_173458 (h1 : ring (semi_normed_ring (denumerable char))) : is_domain (semi_normed_ring (denumerable char)) := sorry --non-trivial
lemma new_lemma_173459 (h0 : functor.add_const (topological_space (add_cancel_monoid pos)) linarith.comp) : @totally_disconnected_space.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_173460 (h0 : ordered_comm_monoid (generalized_boolean_algebra (has_add name))) : has_exists_mul_of_le (generalized_boolean_algebra (has_add name)) := sorry --non-trivial
lemma new_lemma_173461 (h0 : group (has_bot (has_pos_part real))) : is_cyclic (has_bot (has_pos_part real)) := sorry --non-trivial
lemma new_lemma_173462 (h0 : functor.add_const (topological_space (mul_zero_class congr_arg_kind)) empty) : @t0_space.{0} (mul_zero_class.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_173463 (h0 : not (topological_space (metric_space linarith.comp) -> false)) : @totally_separated_space.{0} (metric_space.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (metric_space.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_173464 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (option.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (option.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_173465 (h0 : monoid (ring (has_to_string Type))) : monoid.fg (ring (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_173466 (h0 : uniform_space (semiring (has_norm empty))) : complete_space (semiring (has_norm empty)) := sorry --non-trivial
lemma new_lemma_173467 (h0 : ordered_comm_monoid (comm_group ennreal)) : has_exists_mul_of_le (comm_group ennreal) := sorry --non-trivial
lemma new_lemma_173468 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (complete_distrib_lattice environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_173469 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (ordered_comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (ordered_comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_173470 (h0 : function.extfun Type topological_space) : @t0_space.{0} (non_assoc_semiring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (non_assoc_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_173471 (h0 : topological_space (complete_distrib_lattice (has_pos_part linarith.comp))) : locally_compact_space (complete_distrib_lattice (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_173472 (h0 : add_group (has_lt fun_info)) : is_add_cyclic (has_lt fun_info) := sorry --non-trivial
lemma new_lemma_173473 (h0 : filter (semigroup congr_arg_kind)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_173474 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (complete_distrib_lattice.{0} linarith.comp) (@function.extfun_app.{2 1} Type monoid.{0} h0 (complete_distrib_lattice.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_173475 (h0 : not (topological_space (complete_semilattice_Sup to_additive.value_type) -> false)) : @t0_space.{0} (complete_semilattice_Sup.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (complete_semilattice_Sup.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_173476 (h0 : functor.add_const (ordered_add_comm_monoid (add_cancel_monoid Type)) linarith.comp) : @archimedean.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (ordered_add_comm_monoid.{1} (add_cancel_monoid.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_173477 (h0 : functor.add_const (topological_space (finset pos)) environment.implicit_infer_kind) : @topological_space.separable_space.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_173478 (h0 : not (monoid (measure_theory.measure_space num) -> false)) : @monoid.fg.{0} (measure_theory.measure_space.{0} num) (@classical.by_contradiction'.{1} (monoid.{0} (measure_theory.measure_space.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_173479 (h0 : monoid (add_cancel_monoid (comm_group (has_zero (comm_group name))))) : monoid.fg (add_cancel_monoid (comm_group (has_zero (comm_group name)))) := sorry --non-trivial
lemma new_lemma_173480 (h1 : list (has_norm (has_top linarith.ineq))) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_173481 (h0 : ring (has_nndist (has_nndist pos))) : rank_condition (has_nndist (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_173482 (h0 : topological_space (option (semiring unsigned))) : locally_compact_space (option (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_173483 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @discrete_topology.{0} (ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_173484 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (has_norm.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_norm.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_173485 (h0 : ring (comm_monoid congr_arg_kind)) : rank_condition (comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_173486 (h0 : functor.add_const (group (normed_comm_ring Type)) name) : @normalizer_condition.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (normed_comm_ring.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_173487 (h0 : functor.add_const (topological_space (has_Inf linarith.comp)) Type) : @preconnected_space.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_Inf.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_173488 (h0 : topological_space (has_inv (random_gen linarith.ineq))) : locally_compact_space (has_inv (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_173489 (h0 : functor.add_const (topological_space (has_neg environment.implicit_infer_kind)) linarith.comp) : @totally_disconnected_space.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_173490 (h0 : semiring nnreal) : is_noetherian_ring nnreal := sorry --non-trivial
lemma new_lemma_173491 (h0 : fin has_zero.zero) : @unique_factorization_monoid.{1} (has_pos_part.{1} Type) (@matrix.vec_empty.{1} (cancel_comm_monoid_with_zero.{1} (has_pos_part.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_173492 (h0 : complete_lattice (simple_graph congr_arg_kind)) : complete_lattice.is_Sup_finite_compact (simple_graph congr_arg_kind) := sorry --non-trivial
lemma new_lemma_173493 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @totally_separated_space.{0} (semiring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (semiring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_173494 (h0 : functor.add_const (group (as_linear_order empty)) num) : @normalizer_condition.{0} (as_linear_order.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (as_linear_order.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_173495 (h0 : ring (preorder empty)) : rank_condition (preorder empty) := sorry --non-trivial
lemma new_lemma_173496 (h0 : complete_lattice (canonically_ordered_comm_semiring (normed_comm_ring Type))) : is_atomistic (canonically_ordered_comm_semiring (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_173497 (h0 : functor.add_const (uniform_space (plift empty)) unsigned) : @separated_space.{1} (plift.{1} empty) (@functor.add_const.run.{1 0} (uniform_space.{1} (plift.{1} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_173498 (h0 : functor.add_const (topological_space (has_zero linarith.comp)) (ring Type)) : @discrete_topology.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_zero.{0} linarith.comp)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_173499 (h0 : topological_space (add_comm_monoid (has_neg (has_neg name)))) : t1_space (add_comm_monoid (has_neg (has_neg name))) := sorry --non-trivial
lemma new_lemma_173500 (h0 : topological_space (metric_space (random_gen to_additive.value_type))) : t0_space (metric_space (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_173501 (h1 : ring (with_one linarith.comp_source)) : strong_rank_condition (with_one linarith.comp_source) := sorry --non-trivial
lemma new_lemma_173502 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (with_one.{0} linarith.ineq) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (with_one.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_173503 (h0 : topological_space (normed_comm_ring (comm_group Type))) : preirreducible_space (normed_comm_ring (comm_group Type)) := sorry --non-trivial
lemma new_lemma_173504 (h0 : finset (monoid (add_cancel_monoid unsigned))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_173505 (h0 : not (function.extfun Type monoid -> false)) : @monoid.fg.{0} (has_one.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type monoid.{0}) h0) (has_one.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_173506 (h0 : uniform_space (has_inv (random_gen (has_nnnorm (random_gen to_additive.value_type))))) : complete_space (has_inv (random_gen (has_nnnorm (random_gen to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_173507 (h0 : ring (has_inv int)) : rank_condition (has_inv int) := sorry --non-trivial
lemma new_lemma_173508 (h0 : has_mem.mem (has_norm fun_info) has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} (has_norm.{0} fun_info) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (has_norm.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_173509 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (distrib_lattice.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (distrib_lattice.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_173510 (h0 : filter (has_nnnorm to_additive.value_type)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_173511 (h0 : functor.add_const (group (ring Type)) (has_neg_part pos)) : @is_simple_group.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (ring.{1} Type)) (has_neg_part.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_173512 (h0 : functor.add_const (list (mul_zero_class Type)) pos) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_173513 (h0 : not (complete_lattice (simple_graph linarith.ineq) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (simple_graph.{0} linarith.ineq) (@classical.by_contradiction'.{1} (complete_lattice.{0} (simple_graph.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_173514 (h1 : ring (has_emptyc (has_top to_additive.value_type))) : rank_condition (has_emptyc (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_173515 (h0 : functor.add_const (topological_space (finset Type)) name) : @topological_space.separable_space.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (finset.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_173516 (h0 : functor.add_const (topological_space (boolean_algebra pos)) Type) : @preirreducible_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_173517 (h0 : topological_space (has_neg (has_neg (has_neg linarith.comp)))) : path_connected_space (has_neg (has_neg (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_173518 (h0 : ring (semigroup (add_cancel_monoid name))) : is_domain (semigroup (add_cancel_monoid name)) := sorry --non-trivial
lemma new_lemma_173519 (h0 : ring (semigroup (has_neg_part unsigned))) : is_domain (semigroup (has_neg_part unsigned)) := sorry --non-trivial
lemma new_lemma_173520 (h0 : functor.add_const (topological_space (add_cancel_monoid linarith.comp)) pos) : @sequential_space.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_173521 (h0 : prod (cancel_monoid (option unsigned)) (cancel_monoid (option unsigned))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_173522 (h0 : list (normed_comm_ring (has_add ennreal))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_173523 (h0 : topological_space (add_cancel_monoid name)) : sequential_space (add_cancel_monoid name) := sorry --non-trivial
lemma new_lemma_173524 (h0 : group (canonically_linear_ordered_monoid (has_add name))) : normalizer_condition (canonically_linear_ordered_monoid (has_add name)) := sorry --non-trivial
lemma new_lemma_173525 (h0 : ring (normed_comm_ring (has_to_string (has_to_string pos)))) : is_domain (normed_comm_ring (has_to_string (has_to_string pos))) := sorry --non-trivial
lemma new_lemma_173526 (h2 h3 : multiset (has_div reducibility_hints)) : multiset.disjoint h2 h3 := sorry --non-trivial
lemma new_lemma_173527 (h1 : ring (mul_one_class reducibility_hints)) : rank_condition (mul_one_class reducibility_hints) := sorry --non-trivial
lemma new_lemma_173528 (h0 : add_group (with_one (has_top linarith.comp_source))) : is_add_cyclic (with_one (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_173529 (h0 : list (normed_comm_ring (boolean_algebra linarith.comp))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_173530 (h0 : functor.add_const (uniform_space (partial_order num)) num) : @complete_space.{0} (partial_order.{0} num) (@functor.add_const.run.{0 0} (uniform_space.{0} (partial_order.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_173531 (h0 : functor.add_const (ring (add_comm_monoid environment.implicit_infer_kind)) linarith.comp) : @is_domain.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (add_comm_monoid.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_173532 (h0 : group (has_compl (mul_one_class (mul_one_class to_additive.value_type)))) : is_cyclic (has_compl (mul_one_class (mul_one_class to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_173533 (h0 : function.extfun Type (functor.comp topological_space boolean_algebra.core)) : @preconnected_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} boolean_algebra.core.{0} environment.implicit_infer_kind (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} boolean_algebra.core.{0}) h0 environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_173534 (h0 : functor.add_const (list (mul_zero_class unsigned)) unsigned) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_173535 (h0 : functor.add_const (add_monoid (boolean_algebra unsigned)) environment.implicit_infer_kind) : @add_monoid.fg.{0} (boolean_algebra.{0} unsigned) (@functor.add_const.run.{0 0} (add_monoid.{0} (boolean_algebra.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_173536 (h0 : functor.add_const (topological_space (has_add pos)) Type) : @t0_space.{0} (has_add.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_add.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_173537 (h0 : functor.add_const (topological_space (mul_zero_class pos)) pos) : @preirreducible_space.{0} (mul_zero_class.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_173538 (h0 : function.extfun Type (functor.add_const (topological_space (has_Sup congr_arg_kind)))) : @loc_path_connected_space.{0} (has_Sup.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Sup.{0} congr_arg_kind)) congr_arg_kind (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (has_Sup.{0} congr_arg_kind))) h0 congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_173539 (h0 : ordered_add_comm_monoid (add_comm_monoid Type)) : archimedean (add_comm_monoid Type) := sorry --non-trivial
lemma new_lemma_173540 (h0 : ring (nondiscrete_normed_field (mul_one_class (add_comm_semigroup ereal)))) : strong_rank_condition (nondiscrete_normed_field (mul_one_class (add_comm_semigroup ereal))) := sorry --non-trivial
lemma new_lemma_173541 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (linear_order.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_order.{0} num))  := sorry --non-trivial
lemma new_lemma_173542 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (canonically_linear_ordered_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_linear_ordered_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_173543 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (comm_group pos)) := sorry --non-trivial
lemma new_lemma_173544 (h0 : ulower pnat) (h1 : list pnat) (h2 h3 : pnat) : pnat.coprime (list.ilast' (ulower.up h0) h1) (pnat.gcd h2 h3) := sorry --non-trivial
lemma new_lemma_173545 (h0 : functor.add_const (group (has_zero Type)) name) : @is_simple_group.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (has_zero.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_173546 (h0 : ring (ordered_comm_ring (has_nndist Type))) : strong_rank_condition (ordered_comm_ring (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_173547 (h0 : functor.add_const (function.extfun Type cancel_comm_monoid_with_zero) Type) : @unique_factorization_monoid.{0} (has_add.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type cancel_comm_monoid_with_zero.{0}) Type h0) (has_add.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_173548 (h0 : functor.comp filter ring pos) : filter.ne_bot (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_173549 (h1 : complete_lattice (encodable fun_info)) : is_compactly_generated (encodable fun_info) := sorry --non-trivial
lemma new_lemma_173550 (h0 : ring (complete_semilattice_Sup congr_arg_kind)) : is_domain (complete_semilattice_Sup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_173551 (h1 : topological_space (normed_field (random_gen linarith.comp_source))) : path_connected_space (normed_field (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_173552 (h0 : not (topological_space (metric_space empty) -> false)) : @topological_space.separable_space.{0} (metric_space.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (metric_space.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_173553 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (semiring.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_173554 (h0 : add_group (finset num)) : is_add_cyclic (finset num) := sorry --non-trivial
lemma new_lemma_173555 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (monoid.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_173556 (h0 : group (has_to_string (has_add Type))) : is_simple_group (has_to_string (has_add Type)) := sorry --non-trivial
lemma new_lemma_173557 (h1 : list (id (random_gen (random_gen string_imp)))) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_173558 (h0 : uniform_space (semigroup (has_pos_part (normed_comm_ring linarith.comp)))) : separated_space (semigroup (has_pos_part (normed_comm_ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_173559 (h0 : topological_space (boolean_algebra (has_neg Type))) : regular_space (boolean_algebra (has_neg Type)) := sorry --non-trivial
lemma new_lemma_173560 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} to_additive.value_type (@function.extfun_app.{2 1} Type topological_space.{0} h0 to_additive.value_type)  := sorry --non-trivial
lemma new_lemma_173561 (h0 : function.extfun Type (functor.add_const (topological_space (has_add linarith.comp)))) : @regular_space.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} linarith.comp)) linarith.comp (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (has_add.{0} linarith.comp))) h0 linarith.comp))  := sorry --non-trivial
lemma new_lemma_173562 (h0 : functor.add_const (filter (has_zero name)) linarith.comp) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_173563 (h0 : set (nondiscrete_normed_field enat -> std_gen)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_173564 (h0 : complete_lattice (simple_graph (option empty))) : is_atomistic (simple_graph (option empty)) := sorry --non-trivial
lemma new_lemma_173565 (h0 : ring (simple_graph empty)) : strong_rank_condition (simple_graph empty) := sorry --non-trivial
lemma new_lemma_173566 (h2 : set (ereal -> add_comm_semigroup (add_comm_semigroup ereal))) : set.separates_points h2 := sorry --non-trivial
lemma new_lemma_173567 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (ring.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_173568 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (ordered_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type add_group.{0} h0 (ordered_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_173569 (h0 : functor.add_const Prop (pseudo_metric_space congr_arg_kind)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_173570 (h0 : functor.add_const (topological_space (ring name)) name) : @normal_space.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_173571 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (with_one fun_info)) := sorry --non-trivial
lemma new_lemma_173572 (h0 : functor.add_const (group (has_nndist pos)) environment.implicit_infer_kind) : @normalizer_condition.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_nndist.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_173573 (h0 : topological_space (linear_ordered_comm_group pos)) : totally_disconnected_space (linear_ordered_comm_group pos) := sorry --non-trivial
lemma new_lemma_173574 (h0 : functor.add_const (add_group (semigroup environment.implicit_infer_kind)) environment.implicit_infer_kind) : @is_add_cyclic.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (add_group.{0} (semigroup.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_173575 (h0 : functor.add_const (topological_space (preorder congr_arg_kind)) unsigned) : @preirreducible_space.{0} (preorder.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (preorder.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_173576 (h0 : filter (has_compl char)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_173577 (h0 : function.extfun Type (functor.add_const Prop)) : functor.add_const.run (function.extfun_app h0 (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_173578 (h0 : measurable_space (mul_one_class string_imp)) (h1 : filter (mul_one_class string_imp)) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_173579 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (pseudo_metric_space.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (pseudo_metric_space.{0} pos))  := sorry --non-trivial
lemma new_lemma_173580 (h0 : topological_space (semigroup (has_Inf linarith.comp))) : loc_path_connected_space (semigroup (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_173581 (h1 : topological_space (semi_normed_comm_ring (has_ssubset char))) : t0_space (semi_normed_comm_ring (has_ssubset char)) := sorry --non-trivial
lemma new_lemma_173582 (h0 : functor.comp finset ring linarith.comp) : finset.nonempty (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_173583 (h0 : functor.add_const (topological_space (left_cancel_monoid num)) (semiring empty)) : @path_connected_space.{0} (left_cancel_monoid.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} num)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_173584 (h0 : ring (with_zero (bin_tree to_additive.value_type))) : strong_rank_condition (with_zero (bin_tree to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_173585 (h0 : topological_space (has_emptyc (has_top fun_info))) : t0_space (has_emptyc (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_173586 (h0 : functor.add_const (add_group (partial_order num)) unsigned) : @is_add_cyclic.{0} (partial_order.{0} num) (@functor.add_const.run.{0 0} (add_group.{0} (partial_order.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_173587 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @locally_compact_space.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_173588 (h0 : topological_space (has_Sup (semiring (semiring empty)))) : t1_space (has_Sup (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_173589 (h1 : uniform_space (has_inv string_imp)) : complete_space (has_inv string_imp) := sorry --non-trivial
lemma new_lemma_173590 (h0 : uniform_space (ordered_comm_group empty)) : separated_space (ordered_comm_group empty) := sorry --non-trivial
lemma new_lemma_173591 (h0 : functor.add_const (ring (has_to_string linarith.comp)) environment.implicit_infer_kind) : @is_domain.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_to_string.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_173592 (h0 : topological_space (normed_lattice_add_comm_group (has_neg Type))) : preirreducible_space (normed_lattice_add_comm_group (has_neg Type)) := sorry --non-trivial
lemma new_lemma_173593 (h0 : functor.add_const (function.extfun (Type 1) topological_space) name) : @path_connected_space.{1} (normed_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) name h0) (normed_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_173594 (h0 : cancel_comm_monoid_with_zero (plift num)) : unique_factorization_monoid (plift num) := sorry --non-trivial
lemma new_lemma_173595 (h0 : topological_space (add_monoid (random_gen (comm_ring fun_info)))) : totally_disconnected_space (add_monoid (random_gen (comm_ring fun_info))) := sorry --non-trivial
lemma new_lemma_173596 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (ordered_cancel_add_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type semiring.{0} h0 (ordered_cancel_add_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_173597 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (add_cancel_comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type monoid.{0} h0 (add_cancel_comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_173598 (h0 : function.extfun (Type 1) topological_space) : @normal_space.{1} (has_neg_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_neg_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_173599 (h0 h1 : multiset (mul_one_class reducibility_hints)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_173600 (h0 : monoid (has_zero (finset Type))) : monoid.fg (has_zero (finset Type)) := sorry --non-trivial
lemma new_lemma_173601 (h0 : topological_space (has_Inf (has_add Type))) : loc_path_connected_space (has_Inf (has_add Type)) := sorry --non-trivial
lemma new_lemma_173602 (h0 : list (ring (has_add (comm_group (has_neg_part (add_comm_monoid (add_comm_monoid (has_add name)))))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_173603 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_ssubset.{0} char) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_ssubset.{0} char))  := sorry --non-trivial
lemma new_lemma_173604 (h0 : has_neg (has_div (normed_field (mul_one_class linarith.comp_source)))) (h1 : measurable_space (has_div (normed_field (mul_one_class linarith.comp_source)))) : has_measurable_neg (has_div (normed_field (mul_one_class linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_173605 (h0 : functor.add_const (function.extfun Type list) linarith.comp) : list.nodup (function.extfun_app (functor.add_const.run h0) (complete_distrib_lattice pos)) := sorry --non-trivial
lemma new_lemma_173606 (h0 : topological_space (mul_zero_class (option name))) : normal_space (mul_zero_class (option name)) := sorry --non-trivial
lemma new_lemma_173607 (h0 : topological_space (add_right_cancel_monoid empty)) : path_connected_space (add_right_cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_173608 (h0 : functor.add_const (function.extfun (Type 1) ordered_add_comm_monoid) pos) : @archimedean.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_add_comm_monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ordered_add_comm_monoid.{1}) pos h0) (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_173609 (h0 : topological_space (canonically_linear_ordered_monoid linarith.comp)) : loc_path_connected_space (canonically_linear_ordered_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_173610 (h0 : ring (has_add (has_add linarith.comp))) : strong_rank_condition (has_add (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_173611 (h0 : topological_space (has_top linarith.comp)) : t0_space (has_top linarith.comp) := sorry --non-trivial
lemma new_lemma_173612 (h0 : group (denumerable (random_gen fun_info))) : group.fg (denumerable (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_173613 (h0 : ring (complete_distrib_lattice (option (option unsigned)))) : strong_rank_condition (complete_distrib_lattice (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_173614 (h0 : ring (semigroup unsigned)) : is_domain (semigroup unsigned) := sorry --non-trivial
lemma new_lemma_173615 (h0 : topological_space (ring (has_pos_part Type))) : sequential_space (ring (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_173616 (h0 : ring (finset (has_nndist (has_neg pos)))) : is_domain (finset (has_nndist (has_neg pos))) := sorry --non-trivial
lemma new_lemma_173617 (h0 : functor.add_const (complete_lattice (cancel_monoid ennreal)) unsigned) : @complete_lattice.is_Sup_finite_compact.{0} (cancel_monoid.{0} ennreal) (@functor.add_const.run.{0 0} (complete_lattice.{0} (cancel_monoid.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_173618 (h0 : ring (has_inv string_imp)) : is_domain (has_inv string_imp) := sorry --non-trivial
lemma new_lemma_173619 (h0 : ring (finset (has_bot (normed_lattice_add_comm_group real)))) : rank_condition (finset (has_bot (normed_lattice_add_comm_group real))) := sorry --non-trivial
lemma new_lemma_173620 (h0 : functor.add_const (topological_space (ordered_comm_ring pos)) linarith.comp) : @locally_compact_space.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_173621 (h0 : topological_space (add_left_cancel_semigroup (has_inv fun_info))) : locally_compact_space (add_left_cancel_semigroup (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_173622 (h0 : functor.add_const (function.extfun Type ring) pos) : @strong_rank_condition.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) pos h0) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_173623 (h0 : is_empty (add_monoid (has_sub num) -> false)) : @add_monoid.fg.{0} (has_sub.{0} num) (@classical.by_contradiction'.{1} (add_monoid.{0} (has_sub.{0} num)) (@is_empty.elim'.{0 0} (add_monoid.{0} (has_sub.{0} num) → false) false h0))  := sorry --non-trivial
lemma new_lemma_173624 (h0 : ring (has_top char)) : is_domain (has_top char) := sorry --non-trivial
lemma new_lemma_173625 (h0 : functor.add_const (topological_space (has_neg pos)) Type) : @preconnected_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_173626 (h0 : topological_space (normed_comm_ring (finset (finset linarith.comp)))) : preconnected_space (normed_comm_ring (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_173627 (h0 : function.extfun Type ring) : @is_domain.{0} (add_comm_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_comm_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_173628 (h0 : not (function.extfun (Type 1) monoid -> false)) : @monoid.fg.{1} (plift.{1} unsigned) (@function.extfun_app.{3 2} (Type 1) monoid.{1} (@classical.by_contradiction'.{3} (function.extfun.{3 2} (Type 1) monoid.{1}) h0) (plift.{1} unsigned))  := sorry --non-trivial
lemma new_lemma_173629 (h0 : uniform_space (has_emptyc num)) : separated_space (has_emptyc num) := sorry --non-trivial
lemma new_lemma_173630 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem monoid)) : @monoid.fg.{0} (measurable_space.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type monoid.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) monoid.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) monoid.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (measurable_space.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_173631 (h0 : topological_space (normed_comm_ring empty)) : irreducible_space (normed_comm_ring empty) := sorry --non-trivial
lemma new_lemma_173632 (h2 : set (std_gen -> ereal)) : set.separates_points h2 := sorry --non-trivial
lemma new_lemma_173633 (h0 : list (ordered_cancel_add_comm_monoid (simple_graph unsigned))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_173634 (h0 : group (has_nndist (has_neg_part name))) : is_simple_group (has_nndist (has_neg_part name)) := sorry --non-trivial
lemma new_lemma_173635 (h0 : topological_space (has_zero (has_add Type))) : t0_space (has_zero (has_add Type)) := sorry --non-trivial
lemma new_lemma_173636 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (has_nndist.{0} linarith.comp) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (has_nndist.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_173637 (h0 : option (functor.add_const (group (complete_distrib_lattice empty)) empty)) (h1 : functor.add_const (group (complete_distrib_lattice empty)) empty) : @normalizer_condition.{0} (complete_distrib_lattice.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (complete_distrib_lattice.{0} empty)) empty (@option.get_or_else.{0} (functor.add_const.{0 0} (group.{0} (complete_distrib_lattice.{0} empty)) empty) h0 h1))  := sorry --non-trivial
lemma new_lemma_173638 (h0 : filter (semigroup environment.implicit_infer_kind)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_173639 (h0 : group (encodable (has_top (random_gen (has_nnnorm linarith.comp_source))))) : group.fg (encodable (has_top (random_gen (has_nnnorm linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_173640 (h0 : functor.add_const (topological_space (ordered_comm_ring real)) name) : @path_connected_space.{0} (ordered_comm_ring.{0} real) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} real)) name h0)  := sorry --non-trivial
lemma new_lemma_173641 (h0 : complete_lattice (finset environment.implicit_infer_kind)) : is_atomistic (finset environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_173642 (h0 : has_neg (comm_group (has_add (has_neg_part Type))) -> has_neg (comm_group (has_add (has_neg_part Type))) -> Prop) : irreflexive h0 := sorry --non-trivial
lemma new_lemma_173643 (h1 : ring (has_append (has_nnnorm reducibility_hints))) : is_domain (has_append (has_nnnorm reducibility_hints)) := sorry --non-trivial
lemma new_lemma_173644 (h0 : functor.add_const (cancel_comm_monoid_with_zero (cancel_monoid name)) (boolean_algebra.core name)) : @unique_factorization_monoid.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (cancel_monoid.{0} name)) (boolean_algebra.core.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_173645 (h0 : topological_space (boolean_algebra (finset pos))) : totally_disconnected_space (boolean_algebra (finset pos)) := sorry --non-trivial
lemma new_lemma_173646 (h0 : not (add_group (add_cancel_comm_monoid char) -> false)) : @is_add_cyclic.{0} (add_cancel_comm_monoid.{0} char) (@classical.by_contradiction'.{1} (add_group.{0} (add_cancel_comm_monoid.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_173647 (h0 : complete_lattice (has_Sup unsigned)) : is_compactly_generated (has_Sup unsigned) := sorry --non-trivial
lemma new_lemma_173648 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_edist.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_edist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_173649 (h0 : topological_space (canonically_linear_ordered_monoid name)) : preconnected_space (canonically_linear_ordered_monoid name) := sorry --non-trivial
lemma new_lemma_173650 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (measurable_space.dynkin_system.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (measurable_space.dynkin_system.{0} empty))  := sorry --non-trivial
lemma new_lemma_173651 (h0 : ring (has_add (has_Inf real))) : is_principal_ideal_ring (has_add (has_Inf real)) := sorry --non-trivial
lemma new_lemma_173652 (h0 : ordered_comm_monoid (add_cancel_monoid (has_add name))) : has_exists_mul_of_le (add_cancel_monoid (has_add name)) := sorry --non-trivial
lemma new_lemma_173653 (h0 : functor.add_const (uniform_space (normed_comm_ring linarith.comp)) environment.implicit_infer_kind) : @complete_space.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (normed_comm_ring.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_173654 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (boolean_algebra.core.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_173655 (h0 : ring (denumerable (has_ssubset linarith.ineq))) : is_domain (denumerable (has_ssubset linarith.ineq)) := sorry --non-trivial
lemma new_lemma_173656 (h0 : complete_lattice (boolean_algebra.core (has_add Type))) : is_compactly_generated (boolean_algebra.core (has_add Type)) := sorry --non-trivial
lemma new_lemma_173657 (h0 : topological_space (distrib_lattice (has_nnnorm fun_info))) : totally_disconnected_space (distrib_lattice (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_173658 (h0 : uniform_space (has_Inf (has_add (ring pos)))) : separated_space (has_Inf (has_add (ring pos))) := sorry --non-trivial
lemma new_lemma_173659 (h0 : ring (denumerable (has_add char))) : is_domain (denumerable (has_add char)) := sorry --non-trivial
lemma new_lemma_173660 (h0 : functor.add_const (topological_space (has_Inf linarith.comp)) (finset linarith.comp)) : @preirreducible_space.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} linarith.comp)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_173661 (h0 : functor.add_const (function.extfun Type topological_space) environment.implicit_infer_kind) : @irreducible_space.{0} (comm_group.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) environment.implicit_infer_kind h0) (comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_173662 (h0 : not (topological_space (metric_space (random_gen linarith.comp_source)) -> false)) : @totally_disconnected_space.{0} (metric_space.{0} (random_gen.{0} linarith.comp_source)) (@classical.by_contradiction'.{1} (topological_space.{0} (metric_space.{0} (random_gen.{0} linarith.comp_source))) h0)  := sorry --non-trivial
lemma new_lemma_173663 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (linear_ordered_comm_ring.{0} num) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (linear_ordered_comm_ring.{0} num))  := sorry --non-trivial
lemma new_lemma_173664 (h0 : topological_space (monoid (option congr_arg_kind))) : totally_separated_space (monoid (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_173665 (h0 : functor.add_const (topological_space (normed_comm_ring Type)) linarith.comp) : @t0_space.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (normed_comm_ring.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_173666 (h0 : topological_space (has_union congr_arg_kind)) : topological_space.separable_space (has_union congr_arg_kind) := sorry --non-trivial
lemma new_lemma_173667 (h0 : functor.add_const (function.extfun Type semiring) (has_add (has_add linarith.comp))) : @is_noetherian_ring.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type semiring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type semiring.{0}) (has_add.{0} (has_add.{0} linarith.comp)) h0) (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_173668 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (pseudo_metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (pseudo_metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_173669 (h0 : fin has_zero.zero) : @unique_factorization_monoid.{1} (canonically_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (cancel_comm_monoid_with_zero.{1} (canonically_ordered_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_173670 (h0 : function.extfun (Type 1) topological_space) : @loc_path_connected_space.{1} (comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_173671 (h0 : functor.add_const (fin has_zero.zero) (sub_neg_monoid Type)) : @is_atomistic.{1} (generalized_boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (complete_lattice.{1} (generalized_boolean_algebra.{1} Type)) (@functor.add_const.run.{0 1} (fin (@has_zero.zero.{0} nat nat.has_zero)) (sub_neg_monoid.{1} Type) h0))  := sorry --non-trivial
lemma new_lemma_173672 (h0 : functor.add_const (ordered_comm_monoid (add_cancel_monoid environment.implicit_infer_kind)) linarith.comp) : @has_exists_mul_of_le.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_173673 (h0 : topological_space (has_nndist empty)) : discrete_topology (has_nndist empty) := sorry --non-trivial
lemma new_lemma_173674 (h0 : functor.add_const (complete_lattice (finset unsigned)) (option empty)) : @is_atomistic.{0} (finset.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (finset.{0} unsigned)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_173675 (h0 : group (ring unsigned)) : group.fg (ring unsigned) := sorry --non-trivial
lemma new_lemma_173676 (h0 : uniform_space (has_bot (has_add (has_add linarith.comp)))) : separated_space (has_bot (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_173677 (h0 : topological_space (has_one (complete_linear_order (complete_linear_order empty)))) : discrete_topology (has_one (complete_linear_order (complete_linear_order empty))) := sorry --non-trivial
lemma new_lemma_173678 (h0 : functor.add_const (ring (boolean_algebra pos)) pos) : @is_principal_ideal_ring.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_173679 (h0 : group (add_cancel_monoid congr_arg_kind)) : is_simple_group (add_cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_173680 (h0 : group (linear_ordered_cancel_comm_monoid (semiring (semiring empty)))) : is_cyclic (linear_ordered_cancel_comm_monoid (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_173681 (h0 : filter (has_nndist (option empty))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_173682 (h0 : group (boolean_algebra (add_cancel_monoid Type))) : is_simple_group (boolean_algebra (add_cancel_monoid Type)) := sorry --non-trivial
lemma new_lemma_173683 (h0 : topological_space (ordered_cancel_add_comm_monoid (option (option (option (option empty)))))) : normal_space (ordered_cancel_add_comm_monoid (option (option (option (option empty))))) := sorry --non-trivial
lemma new_lemma_173684 (h0 : topological_space (has_to_string name)) : normal_space (has_to_string name) := sorry --non-trivial
lemma new_lemma_173685 (h0 : list real) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_173686 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (has_bot.{0} pos) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (has_bot.{0} pos))  := sorry --non-trivial
lemma new_lemma_173687 (h0 : topological_space (has_pos_part (ring (has_add (ring linarith.comp))))) : locally_compact_space (has_pos_part (ring (has_add (ring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_173688 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_173689 (h0 : topological_space (canonically_ordered_monoid (has_Inf real))) : locally_compact_space (canonically_ordered_monoid (has_Inf real)) := sorry --non-trivial
lemma new_lemma_173690 (h0 : not (complete_lattice (has_ssubset char) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_ssubset.{0} char) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_ssubset.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_173691 (h1 : complete_lattice (has_norm string_imp)) : is_compactly_generated (has_norm string_imp) := sorry --non-trivial
lemma new_lemma_173692 (h0 : functor.add_const (topological_space (comm_group linarith.comp)) environment.implicit_infer_kind) : @totally_separated_space.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_173693 (h0 : topological_space (sub_neg_monoid (has_add pos))) : preconnected_space (sub_neg_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_173694 (h0 : functor.add_const (topological_space (semigroup name)) pos) : @preconnected_space.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_173695 (h0 : topological_space (has_neg (semigroup linarith.comp))) : loc_path_connected_space (has_neg (semigroup linarith.comp)) := sorry --non-trivial
lemma new_lemma_173696 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (has_top.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_top.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_173697 (h0 : functor.add_const (complete_lattice (boolean_algebra.core congr_arg_kind)) unsigned) : @complete_lattice.is_Sup_finite_compact.{0} (boolean_algebra.core.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (boolean_algebra.core.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_173698 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (monoid.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} h0 (monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_173699 (h2 : topological_space (has_norm (has_ssubset char))) : locally_compact_space (has_norm (has_ssubset char)) := sorry --non-trivial
lemma new_lemma_173700 (h1 : function.extfun Type uniform_space) : @complete_space.{0} linarith.comp_source (@function.extfun_app.{2 1} Type uniform_space.{0} h1 linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_173701 (h0 : function.extfun Type (functor.add_const (topological_space (ordered_ring empty)))) : @path_connected_space.{0} (ordered_ring.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} empty)) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (ordered_ring.{0} empty))) h0 num))  := sorry --non-trivial
lemma new_lemma_173702 (h0 : functor.add_const (add_group (comm_group Type)) environment.implicit_infer_kind) : @is_add_cyclic.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (add_group.{1} (comm_group.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_173703 (h0 : semiring (cancel_monoid environment.implicit_infer_kind)) : is_noetherian_ring (cancel_monoid environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_173704 (h0 : topological_space (simple_graph Type)) : topological_space.separable_space (simple_graph Type) := sorry --non-trivial
lemma new_lemma_173705 (h0 : add_group (has_compl (has_nnnorm (has_nnnorm (has_nnnorm linarith.comp_source))))) : is_add_cyclic (has_compl (has_nnnorm (has_nnnorm (has_nnnorm linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_173706 (h0 : filter (linear_ordered_add_comm_group (has_norm linarith.ineq))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_173707 (h0 : group (normed_group (has_norm linarith.ineq))) : is_cyclic (normed_group (has_norm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_173708 (h0 : group (generalized_boolean_algebra (has_bot name))) : normalizer_condition (generalized_boolean_algebra (has_bot name)) := sorry --non-trivial
lemma new_lemma_173709 (h0 : functor.add_const (topological_space (comm_group name)) unsigned) : @preconnected_space.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_173710 (h0 : ordered_add_comm_monoid (ordered_cancel_add_comm_monoid (option ennreal))) : archimedean (ordered_cancel_add_comm_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_173711 (h0 : function.extfun Type topological_space) : @t1_space.{0} (finset.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_173712 (h0 : functor.add_const (complete_lattice (add_cancel_monoid linarith.comp)) environment.implicit_infer_kind) : @complete_lattice.is_Sup_finite_compact.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_cancel_monoid.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_173713 (h0 : topological_space (complete_semilattice_Sup (has_ssubset (comm_ring to_additive.value_type)))) : t0_space (complete_semilattice_Sup (has_ssubset (comm_ring to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_173714 (h0 : topological_space (measurable_space.dynkin_system (semiring unsigned))) : totally_separated_space (measurable_space.dynkin_system (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_173715 (h0 : functor.add_const (topological_space (has_nndist Type)) environment.implicit_infer_kind) : @sequential_space.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_nndist.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_173716 (h1 : group (complete_semilattice_Sup string_imp)) : is_cyclic (complete_semilattice_Sup string_imp) := sorry --non-trivial
lemma new_lemma_173717 (h0 : complete_lattice (semi_normed_comm_ring char)) : complete_lattice.is_Sup_finite_compact (semi_normed_comm_ring char) := sorry --non-trivial
lemma new_lemma_173718 (h1 : not (complete_lattice (has_lt linarith.comp_source) -> false)) : @is_compactly_generated.{0} (has_lt.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_lt.{0} linarith.comp_source)) h1)  := sorry --non-trivial
lemma new_lemma_173719 (h0 : fin has_zero.zero) : @sequential_space.{0} (has_bot.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_bot.{0} name))  := sorry --non-trivial
lemma new_lemma_173720 (h0 : has_mem.mem (measurable_space unsigned) has_emptyc.emptyc) : @complete_space.{0} (measurable_space.{0} unsigned) (@finset.pi.empty.{1 0} Type uniform_space.{0} (measurable_space.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_173721 (h0 : complete_lattice (ordered_ring num)) : complete_lattice.is_Sup_finite_compact (ordered_ring num) := sorry --non-trivial
lemma new_lemma_173722 (h0 : topological_space (distrib (random_gen linarith.comp_source))) : t0_space (distrib (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_173723 (h0 : list (linear_ordered_add_comm_group (has_norm (random_gen (distrib_lattice linarith.ineq))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_173724 (h0 : function.extfun (Type 1) finset) : finset.nonempty (function.extfun_app h0 Type) := sorry --non-trivial
lemma new_lemma_173725 (h0 : topological_space (has_well_founded linarith.comp_source)) : t0_space (has_well_founded linarith.comp_source) := sorry --non-trivial
lemma new_lemma_173726 (h0 : functor.comp topological_space canonically_ordered_comm_semiring ennreal) : @sequential_space.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} canonically_ordered_comm_semiring.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_173727 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_Inf.{0} real) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_Inf.{0} real))  := sorry --non-trivial
lemma new_lemma_173728 (h0 : filter (has_nndist (has_add (add_comm_monoid pos)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_173729 (h0 : ring (ordered_comm_monoid (ring (ring Type)))) : rank_condition (ordered_comm_monoid (ring (ring Type))) := sorry --non-trivial
lemma new_lemma_173730 (h0 : functor.add_const (topological_space (mul_zero_class unsigned)) congr_arg_kind) : @totally_separated_space.{0} (mul_zero_class.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_173731 (h0 : functor.add_const (complete_lattice (add_comm_monoid unsigned)) (has_add (has_add name))) : @is_compactly_generated.{0} (add_comm_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_comm_monoid.{0} unsigned)) (has_add.{0} (has_add.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_173732 (h0 : functor.add_const (function.extfun (Type 1) ring) Type) : @is_domain.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) ring.{1}) Type h0) (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_173733 (h0 : set (simple_graph linarith.ineq)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_173734 (h2 : complete_lattice linarith.ineq) : is_compactly_generated linarith.ineq := sorry --non-trivial
lemma new_lemma_173735 (h0 : topological_space (has_neg (option unsigned))) : t0_space (has_neg (option unsigned)) := sorry --non-trivial
lemma new_lemma_173736 (h0 : topological_space (add_cancel_monoid (option unsigned))) : t0_space (add_cancel_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_173737 (h0 : functor.comp semiring has_neg (has_nndist pos)) : @is_noetherian_ring.{0} (has_neg.{0} (has_nndist.{0} pos)) (@functor.comp.run.{0 0 0} semiring.{0} has_neg.{0} (has_nndist.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_173738 (h0 : functor.comp topological_space finset environment.implicit_infer_kind) : @locally_compact_space.{0} (finset.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} finset.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_173739 (h0 : group (has_neg (finset Type))) : group.fg (has_neg (finset Type)) := sorry --non-trivial
lemma new_lemma_173740 (h0 : topological_space (normed_linear_ordered_group (option (option empty)))) : t0_space (normed_linear_ordered_group (option (option empty))) := sorry --non-trivial
lemma new_lemma_173741 (h0 : add_group (normed_comm_ring (has_neg_part name))) : is_add_cyclic (normed_comm_ring (has_neg_part name)) := sorry --non-trivial
lemma new_lemma_173742 (h0 : topological_space (random_gen (add_semigroup linarith.ineq))) : totally_disconnected_space (random_gen (add_semigroup linarith.ineq)) := sorry --non-trivial
lemma new_lemma_173743 (h0 : functor.add_const (function.extfun Type semiring) linarith.comp) : @is_noetherian_ring.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type semiring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type semiring.{0}) linarith.comp h0) (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_173744 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (generalized_boolean_algebra real)) := sorry --non-trivial
lemma new_lemma_173745 (h0 : topological_space (boolean_algebra (has_Inf (has_pos_part (has_pos_part pos))))) : loc_path_connected_space (boolean_algebra (has_Inf (has_pos_part (has_pos_part pos)))) := sorry --non-trivial
lemma new_lemma_173746 (h0 : measurable_space (has_div (has_div enat))) (h1 : filter (has_div (has_div enat))) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_173747 (h0 : topological_space (cancel_monoid (ring (option pos)))) : t1_space (cancel_monoid (ring (option pos))) := sorry --non-trivial
lemma new_lemma_173748 (h0 : topological_space (measurable_space.dynkin_system congr_arg_kind)) : preirreducible_space (measurable_space.dynkin_system congr_arg_kind) := sorry --non-trivial
lemma new_lemma_173749 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (linear_ordered_semiring.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (linear_ordered_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_173750 (h0 : uniform_space (normed_comm_ring (option pos))) : separated_space (normed_comm_ring (option pos)) := sorry --non-trivial
lemma new_lemma_173751 (h0 : topological_space (finset (ring pos))) : t0_space (finset (ring pos)) := sorry --non-trivial
lemma new_lemma_173752 (h1 : function.extfun Type group) : @normalizer_condition.{0} (with_one.{0} num) (@function.extfun_app.{2 1} Type group.{0} h1 (with_one.{0} num))  := sorry --non-trivial
lemma new_lemma_173753 (h0 : topological_space (canonically_linear_ordered_monoid (has_Inf name))) : discrete_topology (canonically_linear_ordered_monoid (has_Inf name)) := sorry --non-trivial
lemma new_lemma_173754 (h0 : functor.add_const (monoid (canonically_ordered_comm_semiring linarith.comp)) name) : @monoid.fg.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@functor.add_const.run.{0 0} (monoid.{0} (canonically_ordered_comm_semiring.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_173755 (h0 : topological_space (boolean_algebra (has_zero (has_to_string linarith.comp)))) : preconnected_space (boolean_algebra (has_zero (has_to_string linarith.comp))) := sorry --non-trivial
lemma new_lemma_173756 (h0 : ring (add_cancel_monoid (option empty))) : is_principal_ideal_ring (add_cancel_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_173757 (h0 : functor.add_const (topological_space (boolean_algebra pos)) pos) : @sequential_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_173758 (h0 : functor.add_const (topological_space (has_nndist ennreal)) pos) : @totally_disconnected_space.{0} (has_nndist.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} ennreal)) pos h0)  := sorry --non-trivial
lemma new_lemma_173759 (h0 : group (canonically_ordered_monoid (has_add (has_Inf linarith.comp)))) : normalizer_condition (canonically_ordered_monoid (has_add (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_173760 (h0 : functor.add_const (function.extfun Type uniform_space) (ring name)) : @complete_space.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) (ring.{0} name) h0) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_173761 (h0 : ring (with_one (random_gen (random_gen linarith.comp_source)))) : is_domain (with_one (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_173762 (h0 : functor.add_const (ordered_add_comm_monoid (metric_space empty)) empty) : @archimedean.{0} (metric_space.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (metric_space.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_173763 (h0 : topological_space (has_div to_additive.value_type)) : t0_space (has_div to_additive.value_type) := sorry --non-trivial
lemma new_lemma_173764 (h0 : functor.add_const (complete_lattice (has_neg Type)) Type) : @is_atomistic.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 1} (complete_lattice.{1} (has_neg.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_173765 (h0 : monoid (add_cancel_monoid ennreal)) : monoid.fg (add_cancel_monoid ennreal) := sorry --non-trivial
lemma new_lemma_173766 (h0 : not (monoid (semiring to_additive.value_type) -> false)) : @monoid.fg.{0} (semiring.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (monoid.{0} (semiring.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_173767 (h0 : not (group (add_right_cancel_monoid num) -> false)) : @normalizer_condition.{0} (add_right_cancel_monoid.{0} num) (@classical.by_contradiction'.{1} (group.{0} (add_right_cancel_monoid.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_173768 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} environment.implicit_infer_kind (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) environment.implicit_infer_kind)  := sorry --non-trivial
lemma new_lemma_173769 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (normed_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_173770 (h1 : set (mul_one_class (mul_one_class std_gen) -> char)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_173771 (h0 : functor.add_const (group (ring Type)) Type) : @group.fg.{1} (ring.{1} Type) (@functor.add_const.run.{1 1} (group.{1} (ring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_173772 (h0 : ordered_comm_monoid (has_neg (boolean_algebra environment.implicit_infer_kind))) : has_exists_mul_of_le (has_neg (boolean_algebra environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_173773 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (linear_ordered_semiring.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_173774 (h0 : ordered_add_comm_monoid (has_zero (has_Inf (has_pos_part (has_Inf pos))))) : archimedean (has_zero (has_Inf (has_pos_part (has_Inf pos)))) := sorry --non-trivial
lemma new_lemma_173775 (h1 : ring (group_with_zero (comm_ring char))) : strong_rank_condition (group_with_zero (comm_ring char)) := sorry --non-trivial
lemma new_lemma_173776 (h0 : group (has_norm (random_gen to_additive.value_type))) : group.fg (has_norm (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_173777 (h0 : topological_space (finset (finset linarith.comp))) : preirreducible_space (finset (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_173778 (h0 : cancel_comm_monoid_with_zero (has_to_string (mul_zero_class (option Type)))) : unique_factorization_monoid (has_to_string (mul_zero_class (option Type))) := sorry --non-trivial
lemma new_lemma_173779 (h0 : function.extfun (Type 1) (functor.comp topological_space ring)) : @irreducible_space.{1} (ring.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} ring.{1} Type (@function.extfun_app.{3 2} (Type 1) (functor.comp.{1 1 1} topological_space.{1} ring.{1}) h0 Type))  := sorry --non-trivial
lemma new_lemma_173780 (h2 : complete_lattice (has_lt string.iterator_imp)) : is_compactly_generated (has_lt string.iterator_imp) := sorry --non-trivial
lemma new_lemma_173781 (h0 : functor.add_const (ring (normed_comm_ring pos)) Type) : @rank_condition.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (normed_comm_ring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_173782 (h0 : topological_space (free_add_monoid (semiring num))) : t0_space (free_add_monoid (semiring num)) := sorry --non-trivial
lemma new_lemma_173783 (h0 : uniform_space (linear_ordered_semiring (has_norm (has_norm unsigned)))) : separated_space (linear_ordered_semiring (has_norm (has_norm unsigned))) := sorry --non-trivial
lemma new_lemma_173784 (h0 : group (finset (has_add (ring (has_add (has_add linarith.comp)))))) : group.fg (finset (has_add (ring (has_add (has_add linarith.comp))))) := sorry --non-trivial
lemma new_lemma_173785 (h0 : group (has_to_string (has_neg_part (boolean_algebra.core unsigned)))) : normalizer_condition (has_to_string (has_neg_part (boolean_algebra.core unsigned))) := sorry --non-trivial
lemma new_lemma_173786 (h0 : fin has_zero.zero) : @is_simple_group.{0} (boolean_algebra.{0} real) (@matrix.vec_empty.{0} (group.{0} (boolean_algebra.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_173787 (h0 : ring (semiring (has_top (random_gen to_additive.value_type)))) : rank_condition (semiring (has_top (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_173788 (h0 : set (has_lt (mul_one_class (has_nnnorm string.iterator_imp)))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_173789 (h0 : has_lt (add_comm_semigroup environment.projection_info)) : no_max_order (add_comm_semigroup environment.projection_info) := sorry --non-trivial
lemma new_lemma_173790 (h1 : topological_space (div_inv_monoid fun_info)) : totally_disconnected_space (div_inv_monoid fun_info) := sorry --non-trivial
lemma new_lemma_173791 (h0 : group (ring (lex pos))) : normalizer_condition (ring (lex pos)) := sorry --non-trivial
lemma new_lemma_173792 (h0 : topological_space (ordered_comm_monoid (finset (has_add linarith.comp)))) : normal_space (ordered_comm_monoid (finset (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_173793 (h0 : ring (ordered_cancel_add_comm_monoid unsigned)) : rank_condition (ordered_cancel_add_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_173794 (h0 : complete_lattice (linear_ordered_add_comm_group (has_ssubset fun_info))) : is_compactly_generated (linear_ordered_add_comm_group (has_ssubset fun_info)) := sorry --non-trivial
lemma new_lemma_173795 (h0 : group (add_left_cancel_semigroup (semiring (semiring (semiring empty))))) : group.fg (add_left_cancel_semigroup (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_173796 (h0 : has_mem.mem (random_gen (has_norm (semiring num))) has_emptyc.emptyc) : @locally_compact_space.{0} (random_gen.{0} (has_norm.{0} (semiring.{0} num))) (@finset.pi.empty.{1 0} Type topological_space.{0} (random_gen.{0} (has_norm.{0} (semiring.{0} num))) h0)  := sorry --non-trivial
lemma new_lemma_173797 (h0 : functor.add_const (function.extfun (Type 1) monoid) environment.implicit_infer_kind) : @monoid.fg.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) monoid.{1}) environment.implicit_infer_kind h0) (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_173798 (h0 : not (has_mem.mem (semiring to_additive.value_type) has_emptyc.emptyc -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (semiring.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (semiring.{0} to_additive.value_type) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} to_additive.value_type) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_173799 (h0 : not (function.extfun Type ring -> false)) : @rank_condition.{0} (has_emptyc.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (has_emptyc.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_173800 (h0 : functor.add_const (group (has_zero Type)) environment.implicit_infer_kind) : @is_simple_group.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (has_zero.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_173801 (h0 : topological_space (has_Sup unsigned)) : t1_space (has_Sup unsigned) := sorry --non-trivial
lemma new_lemma_173802 (h0 : not (uniform_space (linear_ordered_semiring empty) -> false)) : @separated_space.{0} (linear_ordered_semiring.{0} empty) (@classical.by_contradiction'.{1} (uniform_space.{0} (linear_ordered_semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_173803 (h0 : functor.add_const (semiring (free_add_monoid empty)) num) : @is_noetherian_ring.{0} (free_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (semiring.{0} (free_add_monoid.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_173804 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (normed_lattice_add_comm_group.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_lattice_add_comm_group.{0} real))  := sorry --non-trivial
lemma new_lemma_173805 (h0 : not (has_mem.mem complete_lattice has_emptyc.emptyc -> false)) : @is_compactly_generated.{0} (has_norm.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) complete_lattice.{0} (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type)))) h0)) (has_norm.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_173806 (h0 : functor.add_const (functor.add_const (ordered_add_comm_monoid znum) num) unsigned) : @archimedean.{0} znum (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} znum) num (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (ordered_add_comm_monoid.{0} znum) num) unsigned h0))  := sorry --non-trivial
lemma new_lemma_173807 (h0 : filter (has_pos_part (has_pos_part (ring linarith.comp)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_173808 (h0 : topological_space (has_lt (mul_one_class (mul_one_class char)))) (h1 : preorder (has_lt (mul_one_class (mul_one_class char)))) : order_topology (has_lt (mul_one_class (mul_one_class char))) := sorry --non-trivial
lemma new_lemma_173809 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @locally_compact_space.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_173810 (h0 : topological_space (has_zero (has_neg linarith.comp))) : normal_space (has_zero (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_173811 (h0 : functor.add_const (uniform_space (normed_comm_ring pos)) environment.implicit_infer_kind) : @complete_space.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (normed_comm_ring.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_173812 (h0 : topological_space (has_top (has_norm linarith.comp_source))) : t0_space (has_top (has_norm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_173813 (h0 : functor.add_const (ring (finset environment.implicit_infer_kind)) linarith.comp) : @is_domain.{0} (finset.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (finset.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_173814 (h0 : ordered_add_comm_monoid (option pos)) : archimedean (option pos) := sorry --non-trivial
lemma new_lemma_173815 (h1 : topological_space (has_nnnorm (has_append linarith.comp_source))) : totally_disconnected_space (has_nnnorm (has_append linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_173816 (h0 : functor.add_const (topological_space (add_cancel_monoid pos)) linarith.comp) : @regular_space.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_173817 (h0 : topological_space (comm_ring (random_gen fun_info))) : locally_compact_space (comm_ring (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_173818 (h0 : functor.add_const (group (has_nndist pos)) linarith.comp) : @group.fg.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_nndist.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_173819 (h0 : functor.add_const (function.extfun (Type 1) topological_space) Type) : @normal_space.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) Type h0) (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_173820 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (has_neg_part.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_neg_part.{0} name))  := sorry --non-trivial
lemma new_lemma_173821 (h0 : list (pseudo_metric_space (mul_zero_class pos))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_173822 (h0 : fin has_zero.zero) : @is_domain.{0} (simple_graph.{0} pos) (@matrix.vec_empty.{0} (ring.{0} (simple_graph.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_173823 (h0 : topological_space (has_union linarith.comp)) : sequential_space (has_union linarith.comp) := sorry --non-trivial
lemma new_lemma_173824 (h1 : ring (mul_one_class environment.projection_info)) : strong_rank_condition (mul_one_class environment.projection_info) := sorry --non-trivial
lemma new_lemma_173825 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (has_dist.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (has_dist.{0} pos))  := sorry --non-trivial
lemma new_lemma_173826 (h2 h3 : nat) (h4 : uniform_space (add_comm_semigroup (derive_fintype.finset_above char (fun (h1 : char), h2) h3))) : complete_space (add_comm_semigroup (derive_fintype.finset_above char (fun (h1 : char), h2) h3)) := sorry --non-trivial
lemma new_lemma_173827 (h0 : functor.add_const (filter (canonically_linear_ordered_monoid name)) unsigned) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_173828 (h0 : topological_space (has_neg pos)) : irreducible_space (has_neg pos) := sorry --non-trivial
lemma new_lemma_173829 (h0 : topological_space (has_top (has_top linarith.comp_source))) : path_connected_space (has_top (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_173830 (h0 : topological_space (has_sub (semiring empty))) : path_connected_space (has_sub (semiring empty)) := sorry --non-trivial
lemma new_lemma_173831 (h0 : ring (has_pos_part (has_Inf Type))) : rank_condition (has_pos_part (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_173832 (h0 : group (metric_space (semiring unsigned))) : group.fg (metric_space (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_173833 (h0 : group (has_Inf (has_Inf (has_Inf pos)))) : is_simple_group (has_Inf (has_Inf (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_173834 (h0 : functor.add_const (ring (has_add linarith.comp)) name) : @rank_condition.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_add.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_173835 (h0 : functor.add_const (function.extfun Type finset) (finset pos)) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (comm_group linarith.comp)) := sorry --non-trivial
lemma new_lemma_173836 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (dlist.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (dlist.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_173837 (h0 : group (normed_field (has_nnnorm (has_nnnorm (has_nnnorm string.iterator_imp))))) : is_cyclic (normed_field (has_nnnorm (has_nnnorm (has_nnnorm string.iterator_imp)))) := sorry --non-trivial
lemma new_lemma_173838 (h0 : has_mem.mem (id unsigned) has_emptyc.emptyc) : @is_add_cyclic.{0} (@id.{2} Type unsigned) (@finset.pi.empty.{1 0} Type add_group.{0} (@id.{2} Type unsigned) h0)  := sorry --non-trivial
lemma new_lemma_173839 (h1 : ring (normed_field (comm_ring (comm_ring (comm_ring reducibility_hints))))) : rank_condition (normed_field (comm_ring (comm_ring (comm_ring reducibility_hints)))) := sorry --non-trivial
lemma new_lemma_173840 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (semigroup.{0} ennreal) (@function.extfun_app.{2 1} Type semiring.{0} h0 (semigroup.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_173841 (h0 : functor.add_const (topological_space (group_with_zero num)) num) : @t1_space.{0} (group_with_zero.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (group_with_zero.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_173842 (h0 : complete_lattice (has_top (random_gen string_imp))) : complete_lattice.is_Sup_finite_compact (has_top (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_173843 (h0 : ring (with_zero to_additive.value_type)) : is_domain (with_zero to_additive.value_type) := sorry --non-trivial
lemma new_lemma_173844 (h0 : nat) (h1 : zmod h0) (h2 : sym2 (zmod h0)) : sym2.mem h1 h2 := sorry --non-trivial
lemma new_lemma_173845 (h0 : function.extfun nat fin) : @sequential_space.{1} (has_pos_part.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (has_pos_part.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_173846 (h0 : topological_space (comm_semigroup (ordered_comm_monoid Type))) : locally_compact_space (comm_semigroup (ordered_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_173847 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @totally_separated_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (boolean_algebra.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_173848 (h0 : filter (comm_group (has_add (has_add environment.implicit_infer_kind)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_173849 (h0 : topological_space (measurable_space linarith.ineq)) : locally_compact_space (measurable_space linarith.ineq) := sorry --non-trivial
lemma new_lemma_173850 (h0 : fin has_zero.zero) : @sequential_space.{0} (canonically_ordered_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (canonically_ordered_monoid.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_173851 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_neg.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_neg.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_173852 (h1 : ring (add_monoid (has_nnnorm (has_nnnorm linarith.ineq)))) : strong_rank_condition (add_monoid (has_nnnorm (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_173853 (h0 : functor.comp topological_space has_add name) : @normal_space.{0} (has_add.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} has_add.{0} name h0)  := sorry --non-trivial
lemma new_lemma_173854 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (has_neg.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_173855 (h0 : topological_space (add_comm_monoid (comm_semigroup Type))) : preirreducible_space (add_comm_monoid (comm_semigroup Type)) := sorry --non-trivial
lemma new_lemma_173856 (h0 : add_group (generalized_boolean_algebra (has_pos_part linarith.comp))) : is_add_cyclic (generalized_boolean_algebra (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_173857 (h0 : ring (ring (has_add pos))) : strong_rank_condition (ring (has_add pos)) := sorry --non-trivial
lemma new_lemma_173858 (h0 : not (topological_space (id num) -> false)) : @totally_separated_space.{0} (@id.{2} Type num) (@classical.by_contradiction'.{1} (topological_space.{0} (@id.{2} Type num)) h0)  := sorry --non-trivial
lemma new_lemma_173859 (h0 : not (ring (mul_one_class reducibility_hints) -> false)) : @strong_rank_condition.{0} (mul_one_class.{0} reducibility_hints) (@classical.by_contradiction'.{1} (ring.{0} (mul_one_class.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_173860 (h0 : topological_space (sub_neg_monoid Type)) : preconnected_space (sub_neg_monoid Type) := sorry --non-trivial
lemma new_lemma_173861 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (has_zero.{0} pos) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (has_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_173862 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (has_to_string.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} num))  := sorry --non-trivial
lemma new_lemma_173863 (h0 : functor.add_const (finset (boolean_algebra.core Type)) (boolean_algebra Type)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_173864 (h0 : uniform_space (has_nndist (comm_group name))) : complete_space (has_nndist (comm_group name)) := sorry --non-trivial
lemma new_lemma_173865 (h0 : group (comm_semigroup (has_bot (sub_neg_monoid (comm_semigroup real))))) : group.fg (comm_semigroup (has_bot (sub_neg_monoid (comm_semigroup real)))) := sorry --non-trivial
lemma new_lemma_173866 (h0 : functor.add_const (topological_space (add_cancel_monoid Type)) Type) : @locally_compact_space.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (add_cancel_monoid.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_173867 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (has_top empty)) := sorry --non-trivial
lemma new_lemma_173868 (h0 : complete_lattice (fintype string_imp)) : is_compactly_generated (fintype string_imp) := sorry --non-trivial
lemma new_lemma_173869 (h0 : function.extfun nat fin) : @normalizer_condition.{1} (complete_distrib_lattice.{1} Type) (@matrix.vec_empty.{1} (group.{1} (complete_distrib_lattice.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_173870 (h0 : not (has_mem.mem (has_emptyc num) has_emptyc.emptyc -> false)) : @path_connected_space.{0} (has_emptyc.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_emptyc.{0} num) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_emptyc.{0} num) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_173871 (h0 h1 : multiset (linear_ordered_comm_group_with_zero char)) : multiset.le h0 h1 := sorry --non-trivial
lemma new_lemma_173872 (h0 : functor.add_const (list (has_nndist name)) Type) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_173873 (h0 : topological_space (boolean_algebra (normed_comm_ring (normed_comm_ring environment.implicit_infer_kind)))) : normal_space (boolean_algebra (normed_comm_ring (normed_comm_ring environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_173874 (h0 : ring (add_comm_monoid (has_add real))) : strong_rank_condition (add_comm_monoid (has_add real)) := sorry --non-trivial
lemma new_lemma_173875 (h0 : functor.add_const (ring (finset pos)) environment.implicit_infer_kind) : @strong_rank_condition.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (finset.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_173876 (h0 : topological_space (has_zero (finset (has_neg (ring (has_to_string environment.implicit_infer_kind)))))) : t1_space (has_zero (finset (has_neg (ring (has_to_string environment.implicit_infer_kind))))) := sorry --non-trivial
lemma new_lemma_173877 (h0 : functor.add_const (complete_lattice (complete_distrib_lattice linarith.comp)) (has_neg_part Type)) : @is_compactly_generated.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.add_const.run.{0 1} (complete_lattice.{0} (complete_distrib_lattice.{0} linarith.comp)) (has_neg_part.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_173878 (h0 : group (add_group (semiring empty))) : normalizer_condition (add_group (semiring empty)) := sorry --non-trivial
lemma new_lemma_173879 (h0 : topological_space (has_inter congr_arg_kind)) : totally_separated_space (has_inter congr_arg_kind) := sorry --non-trivial
lemma new_lemma_173880 (h0 : ring (semigroup (has_to_string (finset name)))) : is_principal_ideal_ring (semigroup (has_to_string (finset name))) := sorry --non-trivial
lemma new_lemma_173881 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @group.fg.{0} (ordered_cancel_add_comm_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) group.{0}) (ordered_cancel_add_comm_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_173882 (h0 : not (complete_lattice (has_lt linarith.comp_source) -> false)) : @is_compactly_generated.{0} (has_lt.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_lt.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_173883 (h0 : functor.add_const (semiring Type) environment.implicit_infer_kind) : @is_noetherian_ring.{1} Type (@functor.add_const.run.{1 0} (semiring.{1} Type) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_173884 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @irreducible_space.{0} (with_bot.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) topological_space.{0}) (with_bot.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_173885 (h0 : set (has_nnnorm (mul_one_class fun_info))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_173886 (h0 : group (has_neg (finset (ring linarith.comp)))) : group.fg (has_neg (finset (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_173887 (h0 : functor.add_const (add_group (complete_distrib_lattice pos)) pos) : @is_add_cyclic.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (complete_distrib_lattice.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_173888 (h0 : function.extfun (set to_additive.value_type) (fun (x : set to_additive.value_type), Prop)) : is_countably_spanning (function.extfun_app h0) := sorry --non-trivial
lemma new_lemma_173889 (h0 : set (set fun_info)) (h3 : fun_info) : set.sInter h0 h3 := sorry --non-trivial
lemma new_lemma_173890 (h0 : functor.add_const (function.extfun (Type 1) group) Type) : @group.fg.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) group.{1}) Type h0) (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_173891 (h0 : list (has_to_string (finset linarith.comp))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_173892 (h0 : uniform_space (has_bot real)) : complete_space (has_bot real) := sorry --non-trivial
lemma new_lemma_173893 (h0 : functor.add_const (topological_space (normed_comm_ring pos)) pos) : @path_connected_space.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_173894 (h0 : not (function.extfun (finset Type) (has_mem.mem congr_arg_kind) -> false)) : @normalizer_condition.{0} congr_arg_kind (@finset.pi.empty.{1 0} Type group.{0} congr_arg_kind (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) congr_arg_kind) (@classical.by_contradiction'.{0} (function.extfun.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) congr_arg_kind)) h0) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_173895 (h0 : ring (ring environment.implicit_infer_kind)) : strong_rank_condition (ring environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_173896 (h1 : not (complete_lattice (linear_ordered_comm_group_with_zero string_imp) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (linear_ordered_comm_group_with_zero.{0} string_imp) (@classical.by_contradiction'.{1} (complete_lattice.{0} (linear_ordered_comm_group_with_zero.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_173897 (h0 : set (normed_field reducibility_hints)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_173898 (h0 : topological_space (boolean_algebra.core (has_to_string environment.implicit_infer_kind))) : t0_space (boolean_algebra.core (has_to_string environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_173899 (h0 : ring (semiring (random_gen (random_gen linarith.comp_source)))) : strong_rank_condition (semiring (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_173900 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (with_one.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (with_one.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_173901 (h0 : ring (non_assoc_semiring (semiring congr_arg_kind))) : rank_condition (non_assoc_semiring (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_173902 (h0 : not (complete_lattice (with_bot unsigned) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (with_bot.{0} unsigned) (@classical.by_contradiction'.{1} (complete_lattice.{0} (with_bot.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_173903 (h0 : functor.add_const (group (has_zero unsigned)) pos) : @group.fg.{0} (has_zero.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (has_zero.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_173904 (h0 : has_mem.mem (has_top congr_arg_kind) has_emptyc.emptyc) : @t0_space.{0} (has_top.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_top.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_173905 (h0 : ring (has_compl fun_info)) : strong_rank_condition (has_compl fun_info) := sorry --non-trivial
lemma new_lemma_173906 (h0 h1 : multiset (linear_ordered_comm_group_with_zero linarith.ineq)) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_173907 (h0 : functor.add_const (topological_space (cancel_monoid empty)) unsigned) : @loc_path_connected_space.{0} (cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_173908 (h0 : complete_lattice (has_ssubset (has_nnnorm char))) : complete_lattice.is_Sup_finite_compact (has_ssubset (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_173909 (h0 : functor.add_const (function.extfun Type group) Type) : @is_simple_group.{0} (add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type group.{0}) Type h0) (add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_173910 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem complete_lattice)) : @is_compactly_generated.{0} (has_norm.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) complete_lattice.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_norm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_173911 (h0 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} (metric_space.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (metric_space.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_173912 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (partial_order.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (partial_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_173913 (h0 : fin has_zero.zero) : @strong_rank_condition.{0} (has_add.{0} real) (@matrix.vec_empty.{0} (ring.{0} (has_add.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_173914 (h0 : uniform_space (cancel_monoid (semigroup pos))) : separated_space (cancel_monoid (semigroup pos)) := sorry --non-trivial
lemma new_lemma_173915 (h1 : ring (has_lt std_gen)) : is_domain (has_lt std_gen) := sorry --non-trivial
lemma new_lemma_173916 (h0 : function.extfun Type (functor.add_const (ring nnreal))) : @strong_rank_condition.{0} nnreal (@functor.add_const.run.{0 0} (ring.{0} nnreal) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} nnreal)) h0 num))  := sorry --non-trivial
lemma new_lemma_173917 (h0 : topological_space (boolean_algebra (finset (semigroup Type)))) : normal_space (boolean_algebra (finset (semigroup Type))) := sorry --non-trivial
lemma new_lemma_173918 (h1 : ring (denumerable (denumerable to_additive.value_type))) : is_domain (denumerable (denumerable to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_173919 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_173920 (h0 : functor.add_const (uniform_space (boolean_algebra pos)) Type) : @complete_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 1} (uniform_space.{0} (boolean_algebra.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_173921 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (linear_ordered_comm_ring.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (linear_ordered_comm_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_173922 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (has_nndist.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_nndist.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_173923 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (add_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (add_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_173924 (h0 : add_group (random_gen (random_gen (random_gen fun_info)))) : is_add_cyclic (random_gen (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_173925 (h0 : functor.add_const (complete_lattice (semigroup Type)) linarith.comp) : @is_compactly_generated.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (semigroup.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_173926 (h0 : topological_space (random_gen (has_top (has_top linarith.ineq)))) : path_connected_space (random_gen (has_top (has_top linarith.ineq))) := sorry --non-trivial
lemma new_lemma_173927 (h0 : topological_space (boolean_algebra (has_Inf linarith.comp))) : loc_path_connected_space (boolean_algebra (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_173928 (h0 : functor.add_const (topological_space (has_nndist pos)) (ring pos)) : @sequential_space.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} pos)) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_173929 (h0 : ordered_add_comm_monoid (boolean_algebra pos)) : archimedean (boolean_algebra pos) := sorry --non-trivial
lemma new_lemma_173930 (h0 : functor.add_const (topological_space auto.case_option) ennreal) : @totally_separated_space.{0} auto.case_option (@functor.add_const.run.{0 0} (topological_space.{0} auto.case_option) ennreal h0)  := sorry --non-trivial
lemma new_lemma_173931 (h0 : filter (comm_ring (has_nnnorm fun_info))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_173932 (h0 : functor.add_const (function.extfun Type finset) (mul_zero_class pos)) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (has_neg_part name)) := sorry --non-trivial
lemma new_lemma_173933 (h0 : ring (encodable to_additive.value_type)) : rank_condition (encodable to_additive.value_type) := sorry --non-trivial
lemma new_lemma_173934 (h0 : functor.add_const (topological_space ordering) linarith.comp) : @normal_space.{0} ordering (@functor.add_const.run.{0 0} (topological_space.{0} ordering) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_173935 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (normed_group.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_173936 (h0 : add_group (denumerable to_additive.value_type)) : is_add_cyclic (denumerable to_additive.value_type) := sorry --non-trivial
lemma new_lemma_173937 (h0 : not (ring (add_group unsigned) -> false)) : @is_domain.{0} (add_group.{0} unsigned) (@classical.by_contradiction'.{1} (ring.{0} (add_group.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_173938 (h0 : topological_space (metric_space num)) : totally_disconnected_space (metric_space num) := sorry --non-trivial
lemma new_lemma_173939 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (add_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_173940 (h0 : topological_space (add_cancel_monoid (has_neg environment.implicit_infer_kind))) : sequential_space (add_cancel_monoid (has_neg environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_173941 (h0 : cancel_comm_monoid_with_zero (has_nndist (option name))) : unique_factorization_monoid (has_nndist (option name)) := sorry --non-trivial
lemma new_lemma_173942 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_173943 (h0 : functor.add_const (ring (semigroup name)) pos) : @strong_rank_condition.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (semigroup.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_173944 (h0 : add_monoid (linear_ordered_comm_group empty)) : add_monoid.fg (linear_ordered_comm_group empty) := sorry --non-trivial
lemma new_lemma_173945 (h0 : complete_lattice (plift congr_arg_kind)) : is_atomistic (plift congr_arg_kind) := sorry --non-trivial
lemma new_lemma_173946 (h0 : list (generalized_boolean_algebra (has_pos_part linarith.comp))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_173947 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (canonically_ordered_add_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_add_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_173948 (h0 : ring (boolean_algebra (ring (has_to_string (ring (ring linarith.comp)))))) : is_domain (boolean_algebra (ring (has_to_string (ring (ring linarith.comp))))) := sorry --non-trivial
lemma new_lemma_173949 (h0 : complete_lattice (has_emptyc (has_inv (random_gen fun_info)))) : is_compactly_generated (has_emptyc (has_inv (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_173950 (h0 : measurable_space fun_info) (h1 : has_add fun_info) : has_measurable_add fun_info := sorry --non-trivial
lemma new_lemma_173951 (h1 : group (has_nnnorm (random_gen reducibility_hints))) : is_cyclic (has_nnnorm (random_gen reducibility_hints)) := sorry --non-trivial
lemma new_lemma_173952 (h0 : topological_space (has_inv (has_norm (linear_ordered_semiring (has_norm linarith.comp_source))))) : irreducible_space (has_inv (has_norm (linear_ordered_semiring (has_norm linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_173953 (h0 : num -> Prop) : @infi.{0 1} Prop (@conditionally_complete_lattice.to_has_Inf.{0} Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice)) num h0  := sorry --non-trivial
lemma new_lemma_173954 (h0 : list (has_neg_part (mul_zero_class (add_comm_monoid linarith.comp)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_173955 (h0 : not (topological_space (uniform_space enat) -> false)) : @totally_disconnected_space.{0} (uniform_space.{0} enat) (@classical.by_contradiction'.{1} (topological_space.{0} (uniform_space.{0} enat)) h0)  := sorry --non-trivial
lemma new_lemma_173956 (h0 : list (topological_space (random_gen (random_gen string_imp)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_173957 (h0 : functor.add_const (uniform_space (add_group num)) num) : @separated_space.{0} (add_group.{0} num) (@functor.add_const.run.{0 0} (uniform_space.{0} (add_group.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_173958 (h0 : not (topological_space (add_group linarith.comp) -> false)) : @locally_compact_space.{0} (add_group.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (add_group.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_173959 (h0 : topological_space (has_add (has_add pos))) : irreducible_space (has_add (has_add pos)) := sorry --non-trivial
lemma new_lemma_173960 (h0 : not (topological_space (with_one unsigned) -> false)) : @totally_disconnected_space.{0} (with_one.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (with_one.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_173961 (h0 : ring (finset Type)) : is_domain (finset Type) := sorry --non-trivial
lemma new_lemma_173962 (h0 : functor.add_const (topological_space (mul_zero_class pos)) Type) : @t1_space.{0} (mul_zero_class.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (mul_zero_class.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_173963 (h0 : topological_space (semigroup (finset (has_add pos)))) : topological_space.separable_space (semigroup (finset (has_add pos))) := sorry --non-trivial
lemma new_lemma_173964 (h0 : topological_space (has_inter unsigned)) : normal_space (has_inter unsigned) := sorry --non-trivial
lemma new_lemma_173965 (h0 : ring (omega_complete_partial_order unsigned)) : rank_condition (omega_complete_partial_order unsigned) := sorry --non-trivial
lemma new_lemma_173966 (h0 : topological_space (has_nndist (has_add (has_nndist name)))) : preirreducible_space (has_nndist (has_add (has_nndist name))) := sorry --non-trivial
lemma new_lemma_173967 (h2 : group (has_inv char)) : is_cyclic (has_inv char) := sorry --non-trivial
lemma new_lemma_173968 (h0 : ring (semiring fun_info)) : is_domain (semiring fun_info) := sorry --non-trivial
lemma new_lemma_173969 (h0 : not (topological_space (add_right_cancel_monoid unsigned) -> false)) : @normal_space.{0} (add_right_cancel_monoid.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (add_right_cancel_monoid.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_173970 (h0 : function.extfun Type (functor.add_const Prop)) : functor.add_const.run (function.extfun_app h0 (ordered_cancel_add_comm_monoid ennreal)) := sorry --non-trivial
lemma new_lemma_173971 (h0 : topological_space (measurable_space empty)) : normal_space (measurable_space empty) := sorry --non-trivial
lemma new_lemma_173972 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (semiring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_173973 (h0 : functor.add_const (group (pseudo_metric_space unsigned)) name) : @is_cyclic.{0} (pseudo_metric_space.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (pseudo_metric_space.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_173974 (h0 : functor.add_const (list (has_neg linarith.comp)) Type) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_173975 (h0 : cancel_comm_monoid_with_zero (semigroup (has_add ennreal))) : unique_factorization_monoid (semigroup (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_173976 (h0 : functor.add_const (ring (has_pos_part Type)) (ring Type)) : @strong_rank_condition.{1} (has_pos_part.{1} Type) (@functor.add_const.run.{1 1} (ring.{1} (has_pos_part.{1} Type)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_173977 (h0 : functor.add_const (topological_space pos) num) : @t0_space.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) num h0)  := sorry --non-trivial
lemma new_lemma_173978 (h0 : functor.add_const (list (linear_ordered_field empty)) num) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_173979 (h0 : cancel_comm_monoid_with_zero (option (has_top (has_top (has_top unsigned))))) : unique_factorization_monoid (option (has_top (has_top (has_top unsigned)))) := sorry --non-trivial
lemma new_lemma_173980 (h0 : complete_lattice (linear_ordered_semiring (has_norm congr_arg_kind))) : complete_lattice.is_Sup_finite_compact (linear_ordered_semiring (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_173981 (h0 : functor.add_const (topological_space (has_pos_part linarith.comp)) (has_neg pos)) : @sequential_space.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} linarith.comp)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_173982 (h0 : functor.add_const (topological_space (boolean_algebra linarith.comp)) linarith.comp) : @preirreducible_space.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_173983 (h0 : topological_space (with_zero (random_gen linarith.ineq))) : path_connected_space (with_zero (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_173984 (h0 : ring (complete_semilattice_Sup string_imp)) : strong_rank_condition (complete_semilattice_Sup string_imp) := sorry --non-trivial
lemma new_lemma_173985 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_one.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_173986 (h0 : functor.add_const (group (complete_distrib_lattice name)) name) : @is_cyclic.{0} (complete_distrib_lattice.{0} name) (@functor.add_const.run.{0 0} (group.{0} (complete_distrib_lattice.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_173987 (h1 : uniform_space (semi_normed_comm_ring fun_info)) : complete_space (semi_normed_comm_ring fun_info) := sorry --non-trivial
lemma new_lemma_173988 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_inv.{0} linarith.ineq) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_inv.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_173989 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @normal_space.{0} (has_norm.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (has_norm.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_173990 (h0 : complete_lattice (has_compl (random_gen linarith.comp_source))) : is_compactly_generated (has_compl (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_173991 (h0 : ring (has_union (has_top num))) : rank_condition (has_union (has_top num)) := sorry --non-trivial
lemma new_lemma_173992 (h0 : topological_space (cancel_monoid (finset (finset pos)))) : path_connected_space (cancel_monoid (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_173993 (h0 : ring (ordered_comm_ring Type)) : is_principal_ideal_ring (ordered_comm_ring Type) := sorry --non-trivial
lemma new_lemma_173994 (h1 : not (filter (distrib_lattice char) -> false)) : filter.ne_bot (classical.by_contradiction' h1) := sorry --non-trivial
lemma new_lemma_173995 (h0 : functor.add_const (topological_space (has_Sup unsigned)) unsigned) : @preirreducible_space.{0} (has_Sup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Sup.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_173996 (h0 : group (generalized_boolean_algebra (boolean_algebra.core (has_neg (finset Type))))) : normalizer_condition (generalized_boolean_algebra (boolean_algebra.core (has_neg (finset Type)))) := sorry --non-trivial
lemma new_lemma_173997 (h0 : finset (linear_order congr_arg_kind)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_173998 (h0 : functor.add_const (ring (cancel_monoid pos)) ennreal) : @is_principal_ideal_ring.{0} (cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (cancel_monoid.{0} pos)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_173999 (h0 : topological_space (has_append linarith.comp_source)) : totally_disconnected_space (has_append linarith.comp_source) := sorry --non-trivial
lemma new_lemma_174000 (h0 : function.extfun (semiring (id empty)) (fun (x : semiring (id empty)), Prop)) : exists_unique (function.extfun_app h0) := sorry --non-trivial
lemma new_lemma_174001 (h0 : topological_space (metric_space (has_norm (has_top num)))) : totally_disconnected_space (metric_space (has_norm (has_top num))) := sorry --non-trivial
lemma new_lemma_174002 (h0 : complete_lattice (mul_one_class std_gen)) : is_compactly_generated (mul_one_class std_gen) := sorry --non-trivial
lemma new_lemma_174003 (h2 : uniform_space (uniform_space linarith.comp_source)) : complete_space (uniform_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_174004 (h0 : topological_space (non_assoc_semiring empty)) : totally_disconnected_space (non_assoc_semiring empty) := sorry --non-trivial
lemma new_lemma_174005 (h0 : function.extfun (Type 1) (functor.comp topological_space cancel_monoid)) : @normal_space.{1} (cancel_monoid.{1} (has_nndist.{1} Type)) (@functor.comp.run.{1 1 1} topological_space.{1} cancel_monoid.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) (functor.comp.{1 1 1} topological_space.{1} cancel_monoid.{1}) h0 (has_nndist.{1} Type)))  := sorry --non-trivial
lemma new_lemma_174006 (h0 : functor.add_const (function.extfun Type topological_space) real) : @t1_space.{0} (finset.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) real h0) (finset.{0} real))  := sorry --non-trivial
lemma new_lemma_174007 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @path_connected_space.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_174008 (h0 : topological_space (normed_comm_ring linarith.comp)) (h1 : list (boolean_algebra (topological_space.nonempty_compacts (normed_comm_ring linarith.comp)))) : palindrome h1 := sorry --non-trivial
lemma new_lemma_174009 (h0 : functor.add_const (finset (has_neg_part name)) name) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_174010 (h0 : list (pseudo_metric_space (canonically_linear_ordered_monoid unsigned))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_174011 (h1 : function.extfun Type topological_space) : @t0_space.{0} linarith.comp_source (@function.extfun_app.{2 1} Type topological_space.{0} h1 linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_174012 (h0 : topological_space (semigroup (finset (finset pos)))) : topological_space.separable_space (semigroup (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_174013 (h0 : topological_space (has_to_string (has_to_string pos))) : locally_compact_space (has_to_string (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_174014 (h0 : not (ring (plift unsigned) -> false)) : @is_principal_ideal_ring.{1} (plift.{1} unsigned) (@classical.by_contradiction'.{2} (ring.{1} (plift.{1} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_174015 (h0 : ring (has_nndist pos)) : is_domain (has_nndist pos) := sorry --non-trivial
lemma new_lemma_174016 (h0 : preorder (free_add_monoid congr_arg_kind)) (h1 : set (free_add_monoid congr_arg_kind)) : bdd_above h1 := sorry --non-trivial
lemma new_lemma_174017 (h0 : ring (normed_lattice_add_comm_group (sub_neg_monoid real))) : is_principal_ideal_ring (normed_lattice_add_comm_group (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_174018 (h0 : filter (normed_group (semiring congr_arg_kind))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_174019 (h0 : not (add_group (partial_order empty) -> false)) : @is_add_cyclic.{0} (partial_order.{0} empty) (@classical.by_contradiction'.{1} (add_group.{0} (partial_order.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_174020 (h0 : filter (has_top (has_top (has_norm (has_norm fun_info))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_174021 (h0 : not (functor.add_const (function.extfun Type uniform_space) fun_info -> false)) : @complete_space.{0} (random_gen.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) fun_info (@classical.by_contradiction'.{2} (functor.add_const.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) fun_info) h0)) (random_gen.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_174022 (h0 : not (topological_space (has_ssubset linarith.ineq) -> false)) : @path_connected_space.{0} (has_ssubset.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (has_ssubset.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_174023 (h0 : list (has_to_string (mul_one_class (right_cancel_semigroup (boolean_algebra Type))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_174024 (h0 : functor.add_const (complete_lattice (ordered_ring unsigned)) (option unsigned)) : @complete_lattice.is_Sup_finite_compact.{0} (ordered_ring.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ordered_ring.{0} unsigned)) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_174025 (h0 : topological_space (has_pos_part (finset linarith.comp))) : normal_space (has_pos_part (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_174026 (h0 : group (add_group linarith.comp)) : normalizer_condition (add_group linarith.comp) := sorry --non-trivial
lemma new_lemma_174027 (h0 : functor.add_const (group (left_cancel_monoid empty)) congr_arg_kind) : @normalizer_condition.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (left_cancel_monoid.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_174028 (h0 : list (ordered_cancel_add_comm_monoid (option pos))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_174029 (h0 : ring (has_zero (has_add linarith.comp))) : strong_rank_condition (has_zero (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_174030 (h0 : functor.add_const (ring (has_pos_part name)) linarith.comp) : @strong_rank_condition.{0} (has_pos_part.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (has_pos_part.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_174031 (h0 : topological_space (has_add (ring name))) : regular_space (has_add (ring name)) := sorry --non-trivial
lemma new_lemma_174032 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (complete_distrib_lattice.{0} (option.{0} ennreal)) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (complete_distrib_lattice.{0} (option.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_174033 (h0 : monoid (has_emptyc (has_top linarith.ineq))) : monoid.fg (has_emptyc (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_174034 (h0 : char -> char -> bool) : is_dec_refl h0 := sorry --non-trivial
lemma new_lemma_174035 (h0 : complete_lattice (normed_linear_ordered_group (semiring empty))) : is_compactly_generated (normed_linear_ordered_group (semiring empty)) := sorry --non-trivial
lemma new_lemma_174036 (h0 : functor.comp topological_space pseudo_metric_space name) : @preirreducible_space.{0} (pseudo_metric_space.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} pseudo_metric_space.{0} name h0)  := sorry --non-trivial
lemma new_lemma_174037 (h0 : list (ordered_comm_ring (has_Inf (has_Inf (has_Inf linarith.comp))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_174038 (h0 : functor.add_const (topological_space environment.implicit_infer_kind) environment.implicit_infer_kind) : @t1_space.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 0} (topological_space.{0} environment.implicit_infer_kind) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_174039 (h0 : topological_space (normed_group (semiring congr_arg_kind))) : t0_space (normed_group (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_174040 (h0 : function.extfun Type topological_space) : @normal_space.{0} (add_semigroup.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_174041 (h0 : add_monoid (has_to_string name)) : add_monoid.fg (has_to_string name) := sorry --non-trivial
lemma new_lemma_174042 (h0 : functor.add_const (function.extfun (Type 1) cancel_comm_monoid_with_zero) pos) : @unique_factorization_monoid.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1}) pos h0) (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_174043 (h0 : topological_space (has_neg (finset (finset linarith.comp)))) : normal_space (has_neg (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_174044 (h0 : prod (left_cancel_monoid (option (option (option empty)))) (left_cancel_monoid (option (option (option empty))))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_174045 (h0 : thunk pnat) (h1 : ulower (fin has_zero.zero)) : pnat.coprime (@trace_call_stack.{0} pnat h0) (@matrix.vec_empty.{0} pnat (@ulower.up.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (encodable.fin (@has_zero.zero.{0} nat nat.has_zero)) h1))  := sorry --non-trivial
lemma new_lemma_174046 (h0 : fin has_zero.zero) : @complete_lattice.is_Sup_finite_compact.{1} (ordered_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (complete_lattice.{1} (ordered_comm_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_174047 (h0 : ring (has_neg (has_neg (finset pos)))) : is_domain (has_neg (has_neg (finset pos))) := sorry --non-trivial
lemma new_lemma_174048 (h0 : topological_space (mul_zero_class (has_to_string (add_comm_monoid ennreal)))) : discrete_topology (mul_zero_class (has_to_string (add_comm_monoid ennreal))) := sorry --non-trivial
lemma new_lemma_174049 (h0 : complete_lattice (linear_ordered_add_comm_group char)) : is_compactly_generated (linear_ordered_add_comm_group char) := sorry --non-trivial
lemma new_lemma_174050 (h0 : functor.add_const (ordered_add_comm_monoid (semigroup pos)) environment.implicit_infer_kind) : @archimedean.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (semigroup.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_174051 (h0 : topological_space (comm_ring linarith.ineq)) : locally_compact_space (comm_ring linarith.ineq) := sorry --non-trivial
lemma new_lemma_174052 (h0 : ring (semigroup (has_add name))) : strong_rank_condition (semigroup (has_add name)) := sorry --non-trivial
lemma new_lemma_174053 (h1 : ring (non_unital_non_assoc_semiring (random_gen linarith.comp_source))) : rank_condition (non_unital_non_assoc_semiring (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_174054 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (has_pos_part.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_pos_part.{0} real))  := sorry --non-trivial
lemma new_lemma_174055 (h0 : topological_space (has_norm (random_gen string_imp))) : locally_compact_space (has_norm (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_174056 (h0 : functor.add_const (topological_space (option empty)) (semiring empty)) : @totally_disconnected_space.{0} (option.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} empty)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_174057 (h0 : not (add_monoid (normed_group linarith.comp) -> false)) : @add_monoid.fg.{0} (normed_group.{0} linarith.comp) (@classical.by_contradiction'.{1} (add_monoid.{0} (normed_group.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_174058 (h0 : group (has_edist unsigned)) : group.fg (has_edist unsigned) := sorry --non-trivial
lemma new_lemma_174059 (h0 : topological_space (add_cancel_monoid (has_neg_part Type))) : sequential_space (add_cancel_monoid (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_174060 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @preconnected_space.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_174061 (h0 : topological_space (has_pos_part (ring (has_Inf Type)))) : irreducible_space (has_pos_part (ring (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_174062 (h0 : group (mul_zero_class (semiring (semiring (semiring (semiring empty)))))) : is_cyclic (mul_zero_class (semiring (semiring (semiring (semiring empty))))) := sorry --non-trivial
lemma new_lemma_174063 (h0 : functor.add_const (group (has_add linarith.comp)) pos) : @is_simple_group.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (has_add.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_174064 (h0 : topological_space (has_nndist (has_pos_part pos))) : loc_path_connected_space (has_nndist (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_174065 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (has_one.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_174066 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (canonically_linear_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_linear_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_174067 (h0 : ring (has_pos_part (has_pos_part (has_nndist linarith.comp)))) : is_principal_ideal_ring (has_pos_part (has_pos_part (has_nndist linarith.comp))) := sorry --non-trivial
lemma new_lemma_174068 (h0 : function.extfun Type topological_space) : @normal_space.{0} (has_neg.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_174069 (h0 : ring (generalized_boolean_algebra pos)) : is_principal_ideal_ring (generalized_boolean_algebra pos) := sorry --non-trivial
lemma new_lemma_174070 (h0 : function.extfun nat fin) : @locally_compact_space.{0} (add_comm_monoid.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (add_comm_monoid.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_174071 (h0 : topological_space (normed_group (has_inv fun_info))) : totally_disconnected_space (normed_group (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_174072 (h0 : topological_space (has_add (has_bot (sub_neg_monoid linarith.comp)))) : normal_space (has_add (has_bot (sub_neg_monoid linarith.comp))) := sorry --non-trivial
lemma new_lemma_174073 (h0 : topological_space (complete_distrib_lattice (option congr_arg_kind))) : topological_space.separable_space (complete_distrib_lattice (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_174074 (h0 : functor.add_const (group (add_comm_monoid unsigned)) (option empty)) : @is_cyclic.{0} (add_comm_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (add_comm_monoid.{0} unsigned)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_174075 (h0 : functor.add_const Prop (has_neg_part (has_nndist name))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_174076 (h0 : prod (partial_order (is_R_or_C congr_arg_kind)) (partial_order (is_R_or_C congr_arg_kind))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_174077 (h0 : not (topological_space (has_union empty) -> false)) : @normal_space.{0} (has_union.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (has_union.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_174078 (h2 : add_group (random_gen (random_gen char))) : is_add_cyclic (random_gen (random_gen char)) := sorry --non-trivial
lemma new_lemma_174079 (h0 : functor.add_const (ring (ring unsigned)) environment.implicit_infer_kind) : @is_domain.{0} (ring.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (ring.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_174080 (h0 : add_group (generalized_boolean_algebra (has_Inf (has_bot real)))) : is_add_cyclic (generalized_boolean_algebra (has_Inf (has_bot real))) := sorry --non-trivial
lemma new_lemma_174081 (h0 : functor.add_const (topological_space (boolean_algebra Type)) linarith.comp) : @path_connected_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_174082 (h0 : ring (is_R_or_C congr_arg_kind)) : rank_condition (is_R_or_C congr_arg_kind) := sorry --non-trivial
lemma new_lemma_174083 (h0 : topological_space (has_norm (comm_ring (comm_ring (has_norm fun_info))))) : irreducible_space (has_norm (comm_ring (comm_ring (has_norm fun_info)))) := sorry --non-trivial
lemma new_lemma_174084 (h0 : topological_space (mul_zero_class (add_group empty))) : totally_separated_space (mul_zero_class (add_group empty)) := sorry --non-trivial
lemma new_lemma_174085 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring linarith.comp)) pos) : @discrete_topology.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_174086 (h0 : filter (dlist (has_nnnorm linarith.comp_source))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_174087 (h0 : functor.add_const (complete_lattice (boolean_algebra.core name)) pos) : @complete_lattice.is_Sup_finite_compact.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (boolean_algebra.core.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_174088 (h0 : topological_space (generalized_boolean_algebra (has_add linarith.comp))) : irreducible_space (generalized_boolean_algebra (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_174089 (h0 : function.extfun (Type 1) (prod (has_add Type))) : id_rel (function.extfun_app h0 (has_add Type)) := sorry --non-trivial
lemma new_lemma_174090 (h0 : uniform_space (linear_ordered_field num)) : separated_space (linear_ordered_field num) := sorry --non-trivial
lemma new_lemma_174091 (h0 : add_group (linear_ordered_field (option empty))) : is_add_cyclic (linear_ordered_field (option empty)) := sorry --non-trivial
lemma new_lemma_174092 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (add_cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_174093 (h0 : function.extfun (finset Type) (has_mem.mem (semiring linarith.comp))) : @discrete_topology.{0} (semiring.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (semiring.{0} linarith.comp) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} linarith.comp)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_174094 (h0 : functor.add_const (group (semigroup unsigned)) name) : @group.fg.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (semigroup.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_174095 (h0 : topological_space (has_Inf (has_Inf (sub_neg_monoid pos)))) : locally_compact_space (has_Inf (has_Inf (sub_neg_monoid pos))) := sorry --non-trivial
lemma new_lemma_174096 (h0 : complete_lattice (add_left_cancel_monoid linarith.ineq)) : complete_lattice.is_Sup_finite_compact (add_left_cancel_monoid linarith.ineq) := sorry --non-trivial
lemma new_lemma_174097 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (omega_complete_partial_order.{0} empty) (@function.extfun_app.{2 1} Type semiring.{0} h0 (omega_complete_partial_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_174098 (h0 : function.extfun Type (functor.add_const (topological_space (add_left_cancel_semigroup unsigned)))) : @loc_path_connected_space.{0} (add_left_cancel_semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_left_cancel_semigroup.{0} unsigned)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (add_left_cancel_semigroup.{0} unsigned))) h0 empty))  := sorry --non-trivial
lemma new_lemma_174099 (h0 : list (complete_distrib_lattice (has_to_string unsigned))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_174100 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (sub_neg_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (sub_neg_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_174101 (h0 : non_assoc_semiring (semigroup congr_arg_kind) -> non_assoc_semiring (semigroup congr_arg_kind) -> Prop) : is_total (non_assoc_semiring (semigroup congr_arg_kind)) h0 := sorry --non-trivial
lemma new_lemma_174102 (h0 : complete_lattice (cancel_monoid (has_add (has_add (has_add pos))))) : complete_lattice.is_Sup_finite_compact (cancel_monoid (has_add (has_add (has_add pos)))) := sorry --non-trivial
lemma new_lemma_174103 (h0 : functor.add_const (ring (mul_zero_class unsigned)) unsigned) : @is_domain.{0} (mul_zero_class.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (mul_zero_class.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_174104 (h0 : function.extfun Type (functor.add_const (ordered_add_comm_monoid ennreal))) : archimedean ennreal := sorry --non-trivial
lemma new_lemma_174105 (h0 : topological_space (has_to_string (finset (finset (finset linarith.comp))))) : totally_disconnected_space (has_to_string (finset (finset (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_174106 (h0 : topological_space (has_add ennreal)) : t0_space (has_add ennreal) := sorry --non-trivial
lemma new_lemma_174107 (h0 : uniform_space (distrib (mul_one_class fun_info))) : complete_space (distrib (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_174108 (h2 : topological_space (random_gen (semigroup char))) : path_connected_space (random_gen (semigroup char)) := sorry --non-trivial
lemma new_lemma_174109 (h0 : topological_space (semigroup (normed_comm_ring (normed_comm_ring name)))) : totally_separated_space (semigroup (normed_comm_ring (normed_comm_ring name))) := sorry --non-trivial
lemma new_lemma_174110 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (has_bot.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_bot.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_174111 (h0 : functor.add_const (group (option unsigned)) unsigned) : @group.fg.{0} (option.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (option.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_174112 (h0 : group (linear_ordered_add_comm_group linarith.comp_source)) : group.fg (linear_ordered_add_comm_group linarith.comp_source) := sorry --non-trivial
lemma new_lemma_174113 (h0 : semiring (has_to_string (has_zero pos))) : is_noetherian_ring (has_to_string (has_zero pos)) := sorry --non-trivial
lemma new_lemma_174114 (h0 : functor.add_const (semiring (normed_linear_ordered_group unsigned)) unsigned) : @is_noetherian_ring.{0} (normed_linear_ordered_group.{0} unsigned) (@functor.add_const.run.{0 0} (semiring.{0} (normed_linear_ordered_group.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_174115 (h0 : group (complete_distrib_lattice (option pos))) : group.fg (complete_distrib_lattice (option pos)) := sorry --non-trivial
lemma new_lemma_174116 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_174117 (h0 : uniform_space (complete_distrib_lattice environment.implicit_infer_kind)) : complete_space (complete_distrib_lattice environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_174118 (h0 : cancel_comm_monoid_with_zero (has_sdiff unsigned)) : unique_factorization_monoid (has_sdiff unsigned) := sorry --non-trivial
lemma new_lemma_174119 (h0 : functor.add_const (topological_space (has_zero ennreal)) unsigned) : @normal_space.{0} (has_zero.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_174120 (h0 : topological_space (canonically_ordered_comm_semiring (add_comm_monoid (has_neg_part ennreal)))) : irreducible_space (canonically_ordered_comm_semiring (add_comm_monoid (has_neg_part ennreal))) := sorry --non-trivial
lemma new_lemma_174121 (h0 : topological_space (add_group (semiring (semiring (semiring (semiring linarith.comp)))))) : path_connected_space (add_group (semiring (semiring (semiring (semiring linarith.comp))))) := sorry --non-trivial
lemma new_lemma_174122 (h0 : functor.comp topological_space has_to_string environment.implicit_infer_kind) : @normal_space.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} has_to_string.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_174123 (h0 : group (complete_semilattice_Sup (has_nnnorm char))) : is_cyclic (complete_semilattice_Sup (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_174124 (h0 : group (finset (has_add Type))) : is_simple_group (finset (has_add Type)) := sorry --non-trivial
lemma new_lemma_174125 (h0 : topological_space (measurable_space.dynkin_system (semiring empty))) : t1_space (measurable_space.dynkin_system (semiring empty)) := sorry --non-trivial
lemma new_lemma_174126 (h0 : semiring unsigned -> Prop) : exists_unique h0 := sorry --non-trivial
lemma new_lemma_174127 (h0 : monoid (has_edist empty)) : monoid.fg (has_edist empty) := sorry --non-trivial
lemma new_lemma_174128 (h0 : ring (has_bot (has_Inf real))) : is_domain (has_bot (has_Inf real)) := sorry --non-trivial
lemma new_lemma_174129 (h0 : uniform_space (has_bot (option (option (option (option (option (option empty)))))))) : complete_space (has_bot (option (option (option (option (option (option empty))))))) := sorry --non-trivial
lemma new_lemma_174130 (h0 : functor.add_const (finset (boolean_algebra.core Type)) linarith.comp) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_174131 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (measurable_space.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measurable_space.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_174132 (h0 : functor.comp list has_neg linarith.comp) : palindrome (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_174133 (h0 : topological_space (ordered_comm_monoid (has_add linarith.comp))) : preirreducible_space (ordered_comm_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_174134 (h0 : functor.add_const (function.extfun Type group) Type) : @is_cyclic.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type group.{0}) Type h0) (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_174135 (h0 : not (topological_space (non_assoc_semiring congr_arg_kind) -> false)) : @preirreducible_space.{0} (non_assoc_semiring.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (non_assoc_semiring.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_174136 (h0 : topological_space (has_inv linarith.ineq)) : totally_disconnected_space (has_inv linarith.ineq) := sorry --non-trivial
lemma new_lemma_174137 (h0 : functor.add_const (function.extfun (Type 1) filter) environment.implicit_infer_kind) : countable_Inter_filter (function.extfun_app (functor.add_const.run h0) (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_174138 (h0 : group (has_nndist (has_Inf linarith.comp))) : group.fg (has_nndist (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_174139 (h0 : uniform_space (has_add Type)) : complete_space (has_add Type) := sorry --non-trivial
lemma new_lemma_174140 (h0 : functor.add_const (topological_space (has_nndist Type)) Type) : @regular_space.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_nndist.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_174141 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (mul_zero_class.{0} (finset.{0} ennreal)) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (mul_zero_class.{0} (finset.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_174142 (h0 : group (linear_ordered_semiring (has_norm (semiring (has_norm (has_norm unsigned)))))) : is_cyclic (linear_ordered_semiring (has_norm (semiring (has_norm (has_norm unsigned))))) := sorry --non-trivial
lemma new_lemma_174143 (h0 : group (random_gen (has_inv (has_inv linarith.comp_source)))) : normalizer_condition (random_gen (has_inv (has_inv linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_174144 (h0 : group (has_one (semiring unsigned))) : group.fg (has_one (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_174145 (h0 : complete_lattice (with_one (random_gen (has_top (has_inv fun_info))))) : is_atomistic (with_one (random_gen (has_top (has_inv fun_info)))) := sorry --non-trivial
lemma new_lemma_174146 (h0 : finset pos -> finset pos -> Prop) : is_symm (finset pos) h0 := sorry --non-trivial
lemma new_lemma_174147 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (add_comm_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (add_comm_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_174148 (h0 : topological_space (metric_space empty)) : t0_space (metric_space empty) := sorry --non-trivial
lemma new_lemma_174149 (h0 : topological_space (monoid unsigned)) : irreducible_space (monoid unsigned) := sorry --non-trivial
lemma new_lemma_174150 (h0 : functor.add_const (topological_space (is_R_or_C unsigned)) empty) : @t1_space.{0} (is_R_or_C.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (is_R_or_C.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_174151 (h0 : topological_space (add_cancel_monoid (has_to_string linarith.comp))) : loc_path_connected_space (add_cancel_monoid (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_174152 (h0 : functor.add_const (group (has_Inf pos)) Type) : @is_simple_group.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (has_Inf.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_174153 (h0 : uniform_space (measure_theory.measure_space (add_right_cancel_monoid (has_top num)))) : separated_space (measure_theory.measure_space (add_right_cancel_monoid (has_top num))) := sorry --non-trivial
lemma new_lemma_174154 (h1 : not (complete_lattice (simple_graph string_imp) -> false)) : @is_compactly_generated.{0} (simple_graph.{0} string_imp) (@classical.by_contradiction'.{1} (complete_lattice.{0} (simple_graph.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_174155 (h0 : complete_lattice (semigroup (cancel_monoid (has_nndist ennreal)))) : is_atomistic (semigroup (cancel_monoid (has_nndist ennreal))) := sorry --non-trivial
lemma new_lemma_174156 (h0 : uniform_space (canonically_linear_ordered_monoid (ordered_comm_monoid (has_Inf Type)))) : complete_space (canonically_linear_ordered_monoid (ordered_comm_monoid (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_174157 (h0 h1 : multiset (mul_one_class enat)) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_174158 (h0 : ring (generalized_boolean_algebra (has_Inf pos))) : is_domain (generalized_boolean_algebra (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_174159 (h0 : ring (monoid empty)) : is_principal_ideal_ring (monoid empty) := sorry --non-trivial
lemma new_lemma_174160 (h0 : uniform_space (ordered_cancel_add_comm_monoid ennreal)) : separated_space (ordered_cancel_add_comm_monoid ennreal) := sorry --non-trivial
lemma new_lemma_174161 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_174162 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (cancel_monoid name)) := sorry --non-trivial
lemma new_lemma_174163 (h0 : group (boolean_algebra (has_add name))) : group.fg (boolean_algebra (has_add name)) := sorry --non-trivial
lemma new_lemma_174164 (h0 : filter (comm_group environment.implicit_infer_kind)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_174165 (h0 : topological_space (has_top (semiring congr_arg_kind))) : preirreducible_space (has_top (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_174166 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @preirreducible_space.{0} (has_add.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (has_add.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_174167 (h0 : functor.add_const (topological_space (has_Inf name)) linarith.comp) : @totally_disconnected_space.{0} (has_Inf.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_174168 (h0 : not (has_mem.mem (measurable_space fun_info) has_emptyc.emptyc -> false)) : @rank_condition.{0} (measurable_space.{0} fun_info) (@finset.pi.empty.{1 0} Type ring.{0} (measurable_space.{0} fun_info) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (measurable_space.{0} fun_info) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_174169 (h0 : functor.add_const (functor.add_const (filter pos) pos) linarith.comp) : filter.ne_bot (functor.add_const.run (functor.add_const.run h0)) := sorry --non-trivial
lemma new_lemma_174170 (h0 : not (topological_space (distrib_lattice fun_info) -> false)) : @path_connected_space.{0} (distrib_lattice.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (distrib_lattice.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_174171 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @regular_space.{0} (generalized_boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (generalized_boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_174172 (h0 : monoid (complete_semilattice_Sup (semiring (semiring unsigned)))) : monoid.fg (complete_semilattice_Sup (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_174173 (h0 : complete_lattice (monoid (option unsigned)) -> Prop) (h1 : Exists (fun (x : complete_lattice (monoid (option unsigned))), h0 x)) : @is_atomistic.{0} (monoid.{0} (option.{0} unsigned)) (@classical.some.{1} (complete_lattice.{0} (monoid.{0} (option.{0} unsigned))) h0 h1)  := sorry --non-trivial
lemma new_lemma_174174 (h1 : list (has_norm fun_info)) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_174175 (h0 : functor.add_const (function.extfun Type add_monoid) linarith.comp) : @add_monoid.fg.{0} pos (@function.extfun_app.{2 1} Type add_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_monoid.{0}) linarith.comp h0) pos)  := sorry --non-trivial
lemma new_lemma_174176 (h0 : filter (normed_group linarith.ineq)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_174177 (h0 : topological_space (normed_group (semiring unsigned))) : discrete_topology (normed_group (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_174178 (h0 : functor.add_const (complete_lattice (linear_ordered_comm_monoid_with_zero empty)) empty) : @is_compactly_generated.{0} (linear_ordered_comm_monoid_with_zero.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (linear_ordered_comm_monoid_with_zero.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_174179 (h0 : not (group (normed_field fun_info) -> false)) : @is_cyclic.{0} (normed_field.{0} fun_info) (@classical.by_contradiction'.{1} (group.{0} (normed_field.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_174180 (h0 : uniform_space (add_comm_monoid (has_add (boolean_algebra.core (has_neg Type))))) : separated_space (add_comm_monoid (has_add (boolean_algebra.core (has_neg Type)))) := sorry --non-trivial
lemma new_lemma_174181 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_union.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_union.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_174182 (h0 : functor.add_const (ordered_add_comm_monoid (left_cancel_monoid empty)) unsigned) : @archimedean.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (left_cancel_monoid.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_174183 (h0 : uniform_space (boolean_algebra (has_bot (has_bot real)))) : complete_space (boolean_algebra (has_bot (has_bot real))) := sorry --non-trivial
lemma new_lemma_174184 (h0 : topological_space (ordered_comm_monoid real)) : t1_space (ordered_comm_monoid real) := sorry --non-trivial
lemma new_lemma_174185 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (random_gen (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_174186 (h1 : uniform_space (mul_one_class (add_comm_semigroup ereal))) : complete_space (mul_one_class (add_comm_semigroup ereal)) := sorry --non-trivial
lemma new_lemma_174187 (h0 : fin has_zero.zero) : matrix.vec_empty (matrix.vec_empty h0) := sorry --non-trivial
lemma new_lemma_174188 (h0 : functor.add_const (topological_space (cancel_monoid linarith.comp)) Type) : @topological_space.separable_space.{0} (cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (cancel_monoid.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_174189 (h0 : group (generalized_boolean_algebra (sub_neg_monoid (has_add (has_Inf Type))))) : is_cyclic (generalized_boolean_algebra (sub_neg_monoid (has_add (has_Inf Type)))) := sorry --non-trivial
lemma new_lemma_174190 (h0 : topological_space (measurable_space.dynkin_system (has_norm (semiring unsigned)))) : irreducible_space (measurable_space.dynkin_system (has_norm (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_174191 (h0 : finset (finset (finset (has_add environment.implicit_infer_kind)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_174192 (h0 : complete_lattice (semi_normed_ring to_additive.value_type)) : is_compactly_generated (semi_normed_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_174193 (h0 : ring (distrib to_additive.value_type) -> string_imp) (h1 : not (coe_sort (set.range h0) -> false)) : @rank_condition.{0} (distrib.{0} to_additive.value_type) (@set.range_splitting.{0 0} (ring.{0} (distrib.{0} to_additive.value_type)) string_imp h0 (@classical.by_contradiction'.{1} (@coe_sort.{1 2} (set.{0} string_imp) Type (@set.has_coe_to_sort.{0} string_imp) (@set.range.{0 1} string_imp (ring.{0} (distrib.{0} to_additive.value_type)) h0)) h1))  := sorry --non-trivial
lemma new_lemma_174194 (h0 : topological_space (generalized_boolean_algebra pos)) : regular_space (generalized_boolean_algebra pos) := sorry --non-trivial
lemma new_lemma_174195 (h0 : functor.add_const (ring (has_nndist linarith.comp)) (has_to_string (ring environment.implicit_infer_kind))) : @rank_condition.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_nndist.{0} linarith.comp)) (has_to_string.{0} (ring.{0} environment.implicit_infer_kind)) h0)  := sorry --non-trivial
lemma new_lemma_174196 (h0 : group (has_add (has_add Type))) : group.fg (has_add (has_add Type)) := sorry --non-trivial
lemma new_lemma_174197 (h0 : ring (has_add (ring (comm_group Type)))) : is_domain (has_add (ring (comm_group Type))) := sorry --non-trivial
lemma new_lemma_174198 (h0 : functor.add_const (ordered_add_comm_monoid (comm_group pos)) name) : @archimedean.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (comm_group.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_174199 (h0 : functor.comp topological_space has_to_string unsigned) : @path_connected_space.{0} (has_to_string.{0} unsigned) (@functor.comp.run.{0 0 0} topological_space.{0} has_to_string.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_174200 (h0 : set (has_le (mul_one_class environment.projection_info))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_174201 (h0 : topological_space (add_left_cancel_monoid linarith.comp_source)) : totally_disconnected_space (add_left_cancel_monoid linarith.comp_source) := sorry --non-trivial
lemma new_lemma_174202 (h0 : topological_space (ring (has_to_string Type))) : discrete_topology (ring (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_174203 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} (mul_zero_class.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (mul_zero_class.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_174204 (h0 : functor.add_const (ring (boolean_algebra unsigned)) Type) : @is_principal_ideal_ring.{0} (boolean_algebra.{0} unsigned) (@functor.add_const.run.{0 1} (ring.{0} (boolean_algebra.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_174205 (h0 : functor.add_const Prop (has_add pos)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_174206 (h0 : functor.add_const (function.extfun (Type 1) topological_space) linarith.comp) : @discrete_topology.{1} (has_neg.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) linarith.comp h0) (has_neg.{1} Type))  := sorry --non-trivial
lemma new_lemma_174207 (h0 : functor.add_const (topological_space (partial_order empty)) empty) : @locally_compact_space.{0} (partial_order.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (partial_order.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_174208 (h0 : order_hom nat (uniform_space (has_lt char))) : @complete_space.{0} (has_lt.{0} char) (@monotonic_sequence_limit.{0} (uniform_space.{0} (has_lt.{0} char)) (@uniform_space.partial_order.{0} (has_lt.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_174209 (h0 : topological_space (has_inter num)) : totally_separated_space (has_inter num) := sorry --non-trivial
lemma new_lemma_174210 (h0 : functor.add_const (list (generalized_boolean_algebra linarith.comp)) linarith.comp) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_174211 (h0 : add_group (uniform_space (metric_space char))) : is_add_cyclic (uniform_space (metric_space char)) := sorry --non-trivial
lemma new_lemma_174212 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (has_union.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_union.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_174213 (h0 : topological_space (partial_order (ordered_cancel_comm_monoid empty))) : locally_compact_space (partial_order (ordered_cancel_comm_monoid empty)) := sorry --non-trivial
lemma new_lemma_174214 (h0 : functor.add_const (topological_space (ring pos)) environment.implicit_infer_kind) : @t0_space.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_174215 (h0 : functor.add_const (ordered_add_comm_monoid (has_to_string name)) (has_neg_part pos)) : @archimedean.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_to_string.{0} name)) (has_neg_part.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_174216 (h0 : topological_space (has_add (sub_neg_monoid (has_bot linarith.comp)))) : preirreducible_space (has_add (sub_neg_monoid (has_bot linarith.comp))) := sorry --non-trivial
lemma new_lemma_174217 (h1 : ring (denumerable fun_info)) : rank_condition (denumerable fun_info) := sorry --non-trivial
lemma new_lemma_174218 (h0 : topological_space (has_nndist (finset Type))) : sequential_space (has_nndist (finset Type)) := sorry --non-trivial
lemma new_lemma_174219 (h0 : ring (boolean_algebra (boolean_algebra name))) : strong_rank_condition (boolean_algebra (boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_174220 (h0 : group (has_add (boolean_algebra (has_Inf Type)))) : is_simple_group (has_add (boolean_algebra (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_174221 (h0 : topological_space (has_one num)) : irreducible_space (has_one num) := sorry --non-trivial
lemma new_lemma_174222 (h0 : ring (measurable_space congr_arg_kind)) : strong_rank_condition (measurable_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_174223 (h0 : topological_space (boolean_algebra.core Type)) : irreducible_space (boolean_algebra.core Type) := sorry --non-trivial
lemma new_lemma_174224 (h0 : topological_space (has_neg (has_to_string pos))) : topological_space.separable_space (has_neg (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_174225 (h0 : topological_space (finset (has_add Type))) : regular_space (finset (has_add Type)) := sorry --non-trivial
lemma new_lemma_174226 (h0 : function.extfun Type ring) : @is_domain.{0} (distrib.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} h0 (distrib.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_174227 (h0 : functor.add_const (list (semigroup linarith.comp)) (has_zero (ring linarith.comp))) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_174228 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @totally_disconnected_space.{0} (with_one.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (with_one.{0} num))  := sorry --non-trivial
lemma new_lemma_174229 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (finset.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (finset.{0} empty))  := sorry --non-trivial
lemma new_lemma_174230 (h0 : not (ring (has_nnnorm int) -> false)) : @rank_condition.{0} (has_nnnorm.{0} int) (@classical.by_contradiction'.{1} (ring.{0} (has_nnnorm.{0} int)) h0)  := sorry --non-trivial
lemma new_lemma_174231 (h0 : uniform_space (has_sub num)) : separated_space (has_sub num) := sorry --non-trivial
lemma new_lemma_174232 (h0 : filter (add_left_cancel_monoid (with_zero string_imp))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_174233 (h0 : functor.add_const (topological_space (has_nndist environment.implicit_infer_kind)) pos) : @normal_space.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_174234 (h0 : topological_space (boolean_algebra (has_add Type))) : irreducible_space (boolean_algebra (has_add Type)) := sorry --non-trivial
lemma new_lemma_174235 (h0 : fin has_zero.zero) : @discrete_topology.{0} (has_bot.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (has_bot.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_174236 (h0 : complete_lattice (linear_ordered_comm_ring congr_arg_kind)) : complete_lattice.is_Sup_finite_compact (linear_ordered_comm_ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_174237 (h1 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_norm.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (has_norm.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_174238 (h0 : ring (metric_space (semiring (semiring congr_arg_kind)))) : is_domain (metric_space (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_174239 (h0 : functor.add_const (monoid (has_pos_part linarith.comp)) name) : @monoid.fg.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (monoid.{0} (has_pos_part.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_174240 (h0 : monoid (measurable_space (random_gen (random_gen (random_gen linarith.comp_source))))) : monoid.fg (measurable_space (random_gen (random_gen (random_gen linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_174241 (h0 : topological_space (metric_space (semiring empty))) : preirreducible_space (metric_space (semiring empty)) := sorry --non-trivial
lemma new_lemma_174242 (h0 : functor.comp ordered_add_comm_monoid complete_distrib_lattice pos) : @archimedean.{0} (complete_distrib_lattice.{0} pos) (@functor.comp.run.{0 0 0} ordered_add_comm_monoid.{0} complete_distrib_lattice.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_174243 (h0 : semiring (canonically_ordered_monoid (has_add linarith.comp))) : is_noetherian_ring (canonically_ordered_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_174244 (h0 : functor.add_const (topological_space (semigroup pos)) name) : @preirreducible_space.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_174245 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (linear_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (linear_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_174246 (h0 : functor.add_const (uniform_space (mul_zero_class num)) (semiring unsigned)) : @separated_space.{0} (mul_zero_class.{0} num) (@functor.add_const.run.{0 0} (uniform_space.{0} (mul_zero_class.{0} num)) (semiring.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_174247 (h0 : ring (boolean_algebra (ordered_comm_monoid pos))) : is_principal_ideal_ring (boolean_algebra (ordered_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_174248 (h0 : add_group (has_to_string (has_to_string pos))) : is_add_cyclic (has_to_string (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_174249 (h0 : topological_space (semiring (random_gen (random_gen num)))) : discrete_topology (semiring (random_gen (random_gen num))) := sorry --non-trivial
lemma new_lemma_174250 (h0 : functor.add_const (topological_space (comm_group linarith.comp)) linarith.comp) : @t0_space.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_174251 (h0 : complete_lattice (has_zero num)) : is_compactly_generated (has_zero num) := sorry --non-trivial
lemma new_lemma_174252 (h0 : group (has_zero (has_neg pos))) : is_simple_group (has_zero (has_neg pos)) := sorry --non-trivial
lemma new_lemma_174253 (h0 : functor.add_const (functor.add_const (topological_space auto.case_option) congr_arg_kind) num) : @t1_space.{0} auto.case_option (@functor.add_const.run.{0 0} (topological_space.{0} auto.case_option) congr_arg_kind (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (topological_space.{0} auto.case_option) congr_arg_kind) num h0))  := sorry --non-trivial
lemma new_lemma_174254 (h0 : group (ordered_comm_group (has_nnnorm (has_nnnorm linarith.ineq)))) : is_cyclic (ordered_comm_group (has_nnnorm (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_174255 (h0 : functor.add_const (topological_space (ring name)) environment.implicit_infer_kind) : @sequential_space.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_174256 (h0 : topological_space (add_cancel_monoid (ring linarith.comp))) : discrete_topology (add_cancel_monoid (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_174257 (h0 : function.extfun Type group) : @group.fg.{0} (option.{0} name) (@function.extfun_app.{2 1} Type group.{0} h0 (option.{0} name))  := sorry --non-trivial
lemma new_lemma_174258 (h0 : function.extfun Type topological_space) : @t0_space.{0} (@id.{2} Type linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (@id.{2} Type linarith.comp))  := sorry --non-trivial
lemma new_lemma_174259 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (pseudo_metric_space.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (pseudo_metric_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_174260 (h1 : group (has_nnnorm to_additive.value_type)) : group.fg (has_nnnorm to_additive.value_type) := sorry --non-trivial
lemma new_lemma_174261 (h0 : add_group (semiring (measurable_space fun_info))) : is_add_cyclic (semiring (measurable_space fun_info)) := sorry --non-trivial
lemma new_lemma_174262 (h0 : ring (has_add (has_bot (has_neg linarith.comp)))) : is_principal_ideal_ring (has_add (has_bot (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_174263 (h0 : complete_lattice (semiring (random_gen num))) : is_atomistic (semiring (random_gen num)) := sorry --non-trivial
lemma new_lemma_174264 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (complete_distrib_lattice.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} empty))  := sorry --non-trivial
lemma new_lemma_174265 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_atomistic.{0} (with_bot.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (with_bot.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_174266 (h0 : not (function.extfun Type list -> false)) : list.nodup (function.extfun_app (classical.by_contradiction' h0) fun_info) := sorry --non-trivial
lemma new_lemma_174267 (h0 : topological_space (has_neg (has_add unsigned))) : totally_disconnected_space (has_neg (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_174268 (h0 : functor.add_const (function.extfun (Type 1) filter) name) : countable_Inter_filter (function.extfun_app (functor.add_const.run h0) (simple_graph Type)) := sorry --non-trivial
lemma new_lemma_174269 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @locally_compact_space.{0} (add_cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (add_cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_174270 (h0 : group (ring congr_arg_kind)) : is_cyclic (ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_174271 (h0 : topological_space (option (semiring (semiring empty)))) : discrete_topology (option (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_174272 (h0 : complete_lattice (distrib_lattice linarith.ineq)) : is_compactly_generated (distrib_lattice linarith.ineq) := sorry --non-trivial
lemma new_lemma_174273 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (has_zero.{0} ennreal) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (has_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_174274 (h0 : topological_space (ordered_comm_ring (add_right_cancel_monoid linarith.comp))) : locally_compact_space (ordered_comm_ring (add_right_cancel_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_174275 (h0 : not (ring (complete_semilattice_Sup unsigned) -> false)) : @strong_rank_condition.{0} (complete_semilattice_Sup.{0} unsigned) (@classical.by_contradiction'.{1} (ring.{0} (complete_semilattice_Sup.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_174276 (h0 : topological_space (bin_tree empty)) : topological_space.separable_space (bin_tree empty) := sorry --non-trivial
lemma new_lemma_174277 (h0 : ordered_comm_monoid (add_comm_monoid (option unsigned))) : has_exists_mul_of_le (add_comm_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_174278 (h0 : topological_space (ring (option (option (option (option empty)))))) : path_connected_space (ring (option (option (option (option empty))))) := sorry --non-trivial
lemma new_lemma_174279 (h0 : group (with_bot (has_inv (has_inv to_additive.value_type)))) : is_cyclic (with_bot (has_inv (has_inv to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_174280 (h0 : functor.add_const (function.extfun Type group) Type) : @normalizer_condition.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type group.{0}) Type h0) (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_174281 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (ordered_ring.{0} empty) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (ordered_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_174282 (h0 : add_monoid (canonically_ordered_monoid (has_neg (has_neg (has_neg name))))) : add_monoid.fg (canonically_ordered_monoid (has_neg (has_neg (has_neg name)))) := sorry --non-trivial
lemma new_lemma_174283 (h1 : function.extfun Type topological_space) : @t0_space.{0} (with_one.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (with_one.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_174284 (h0 : functor.add_const (topological_space (has_add name)) pos) : @totally_separated_space.{0} (has_add.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_174285 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_174286 (h0 : topological_space (mul_one_class (add_comm_semigroup (mul_one_class enat)))) : path_connected_space (mul_one_class (add_comm_semigroup (mul_one_class enat))) := sorry --non-trivial
lemma new_lemma_174287 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (@id.{2} Type unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (@id.{2} Type unsigned))  := sorry --non-trivial
lemma new_lemma_174288 (h0 : functor.add_const (topological_space (non_assoc_semiring congr_arg_kind)) congr_arg_kind) : @path_connected_space.{0} (non_assoc_semiring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (non_assoc_semiring.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_174289 (h3 : topological_space (has_ssubset fun_info)) (h4 : add_group (has_ssubset fun_info)) : topological_add_group (has_ssubset fun_info) := sorry --non-trivial
lemma new_lemma_174290 (h0 : functor.add_const (monoid (has_nndist environment.implicit_infer_kind)) name) : @monoid.fg.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (monoid.{0} (has_nndist.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_174291 (h0 : list (comm_group (add_cancel_monoid Type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_174292 (h0 : functor.add_const (topological_space (boolean_algebra pos)) Type) : @t0_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_174293 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_174294 (h0 : not (ring (has_norm (random_gen linarith.comp_source)) -> false)) : @strong_rank_condition.{0} (has_norm.{0} (random_gen.{0} linarith.comp_source)) (@classical.by_contradiction'.{1} (ring.{0} (has_norm.{0} (random_gen.{0} linarith.comp_source))) h0)  := sorry --non-trivial
lemma new_lemma_174295 (h0 : topological_space (simple_graph (finset (has_Inf linarith.comp)))) : regular_space (simple_graph (finset (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_174296 (h0 : topological_space (has_top (semiring empty))) : t0_space (has_top (semiring empty)) := sorry --non-trivial
lemma new_lemma_174297 (h0 : cancel_comm_monoid_with_zero (canonically_linear_ordered_monoid (has_Inf Type))) : unique_factorization_monoid (canonically_linear_ordered_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_174298 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (add_cancel_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (add_cancel_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_174299 (h0 : functor.add_const (topological_space (ring Type)) (ordered_ring Type)) : @path_connected_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (ring.{1} Type)) (ordered_ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_174300 (h0 : not (group (complete_semilattice_Sup empty) -> false)) : @group.fg.{0} (complete_semilattice_Sup.{0} empty) (@classical.by_contradiction'.{1} (group.{0} (complete_semilattice_Sup.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_174301 (h0 : topological_space (comm_group (has_Sup (comm_group ennreal)))) : t0_space (comm_group (has_Sup (comm_group ennreal))) := sorry --non-trivial
lemma new_lemma_174302 (h1 : ring (denumerable (random_gen (random_gen (random_gen fun_info))))) : is_domain (denumerable (random_gen (random_gen (random_gen fun_info)))) := sorry --non-trivial
lemma new_lemma_174303 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (partial_order.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (partial_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_174304 (h0 : topological_space (linear_ordered_semiring unsigned)) : discrete_topology (linear_ordered_semiring unsigned) := sorry --non-trivial
lemma new_lemma_174305 (h0 : complete_lattice (random_gen (random_gen to_additive.value_type))) : is_atomistic (random_gen (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_174306 (h0 : topological_space (option (semiring (semiring empty)))) : t1_space (option (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_174307 (h0 : uniform_space (has_one congr_arg_kind)) : complete_space (has_one congr_arg_kind) := sorry --non-trivial
lemma new_lemma_174308 (h0 : monoid (complete_semilattice_Sup (has_norm (random_gen to_additive.value_type)))) : monoid.fg (complete_semilattice_Sup (has_norm (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_174309 (h0 : group (has_top (random_gen num))) : is_cyclic (has_top (random_gen num)) := sorry --non-trivial
lemma new_lemma_174310 (h0 : finset (has_bot (has_bot (sub_neg_monoid pos)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_174311 (h0 : set (has_compl fun_info)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_174312 (h0 : ring (measure_theory.measure_space num)) : is_domain (measure_theory.measure_space num) := sorry --non-trivial
lemma new_lemma_174313 (h0 : functor.add_const (topological_space (has_zero environment.implicit_infer_kind)) environment.implicit_infer_kind) : @preirreducible_space.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_174314 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (linear_ordered_semiring.{0} num) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (linear_ordered_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_174315 (h0 : ring (semi_normed_ring reducibility_hints)) : is_domain (semi_normed_ring reducibility_hints) := sorry --non-trivial
lemma new_lemma_174316 (h0 : set (non_unital_non_assoc_semiring (mul_one_class (mul_one_class (mul_one_class (mul_one_class char)))))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_174317 (h0 : functor.add_const (function.extfun Type list) pos) : list.nodup (function.extfun_app (functor.add_const.run h0) (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_174318 (h0 : topological_space (boolean_algebra.core linarith.comp)) : path_connected_space (boolean_algebra.core linarith.comp) := sorry --non-trivial
lemma new_lemma_174319 (h0 : topological_space (complete_semilattice_Sup (random_gen to_additive.value_type))) : locally_compact_space (complete_semilattice_Sup (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_174320 (h0 : preorder (random_gen (random_gen to_additive.value_type))) (h1 : set (random_gen (random_gen to_additive.value_type))) : set.ord_connected h1 := sorry --non-trivial
lemma new_lemma_174321 (h0 : function.extfun Type group) : @is_cyclic.{0} (ring.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (ring.{0} num))  := sorry --non-trivial
lemma new_lemma_174322 (h0 : functor.add_const (semiring (linear_ordered_comm_monoid_with_zero congr_arg_kind)) unsigned) : @is_noetherian_ring.{0} (linear_ordered_comm_monoid_with_zero.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (semiring.{0} (linear_ordered_comm_monoid_with_zero.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_174323 (h0 : topological_space (has_zero (has_to_string linarith.comp))) : normal_space (has_zero (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_174324 (h0 : add_monoid (normed_group (plift empty))) : add_monoid.fg (normed_group (plift empty)) := sorry --non-trivial
lemma new_lemma_174325 (h0 : ring (has_to_string (has_pos_part pos))) : is_principal_ideal_ring (has_to_string (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_174326 (h0 : function.extfun Type group) : @is_cyclic.{0} (normed_comm_ring.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (normed_comm_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_174327 (h0 : topological_space (ring (has_to_string linarith.comp))) : loc_path_connected_space (ring (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_174328 (h0 : topological_space (canonically_linear_ordered_monoid (option unsigned))) : totally_disconnected_space (canonically_linear_ordered_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_174329 (h0 : function.extfun Type (functor.add_const (topological_space (semiring empty)))) : @path_connected_space.{0} (semiring.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (semiring.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (semiring.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_174330 (h0 : function.extfun Type topological_space) : @t1_space.{0} (is_R_or_C.{0} (semiring.{0} unsigned)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (is_R_or_C.{0} (semiring.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_174331 (h0 : ring (has_Inf (has_neg pos))) : strong_rank_condition (has_Inf (has_neg pos)) := sorry --non-trivial
lemma new_lemma_174332 (h0 : topological_space (has_to_string (has_pos_part pos))) : loc_path_connected_space (has_to_string (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_174333 (h0 : complete_lattice (has_emptyc (has_inv (has_inv linarith.ineq)))) : is_compactly_generated (has_emptyc (has_inv (has_inv linarith.ineq))) := sorry --non-trivial
lemma new_lemma_174334 (h0 : ring (has_top (has_top (has_top linarith.comp_source)))) : is_domain (has_top (has_top (has_top linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_174335 (h0 : functor.add_const (topological_space Type) (has_Inf (has_Inf (has_Inf (has_Inf pos))))) : @normal_space.{1} Type (@functor.add_const.run.{1 0} (topological_space.{1} Type) (has_Inf.{0} (has_Inf.{0} (has_Inf.{0} (has_Inf.{0} pos)))) h0)  := sorry --non-trivial
lemma new_lemma_174336 (h0 : uniform_space (has_top (has_inv to_additive.value_type))) : complete_space (has_top (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_174337 (h0 : group (has_zero (ring (has_add Type)))) : normalizer_condition (has_zero (ring (has_add Type))) := sorry --non-trivial
lemma new_lemma_174338 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (boolean_algebra.core.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (boolean_algebra.core.{0} num))  := sorry --non-trivial
lemma new_lemma_174339 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @normal_space.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_174340 (h0 : functor.add_const (topological_space (has_neg pos)) linarith.comp) : @topological_space.separable_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_174341 (h0 : functor.add_const (semiring (has_nndist name)) unsigned) : @is_noetherian_ring.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (semiring.{0} (has_nndist.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_174342 (h0 : topological_space (normed_comm_ring (normed_comm_ring linarith.comp))) : sequential_space (normed_comm_ring (normed_comm_ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_174343 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (mul_zero_class unsigned)) := sorry --non-trivial
lemma new_lemma_174344 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (linear_ordered_add_comm_group.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (linear_ordered_add_comm_group.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_174345 (h0 : list (denumerable (denumerable to_additive.value_type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_174346 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} (complete_semilattice_Sup.{0} empty) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (complete_semilattice_Sup.{0} empty))  := sorry --non-trivial
lemma new_lemma_174347 (h0 : not (topological_space (complete_semilattice_Sup num) -> false)) : @irreducible_space.{0} (complete_semilattice_Sup.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (complete_semilattice_Sup.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_174348 (h0 : filter real) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_174349 (h0 : group (has_append linarith.ineq)) : is_cyclic (has_append linarith.ineq) := sorry --non-trivial
lemma new_lemma_174350 (h0 : functor.add_const (ring (normed_comm_ring Type)) pos) : @strong_rank_condition.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (normed_comm_ring.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_174351 (h0 : group (mul_zero_class (has_top unsigned))) : normalizer_condition (mul_zero_class (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_174352 (h0 : functor.add_const (function.extfun (Type 1) complete_lattice) pos) : @complete_lattice.is_Sup_finite_compact.{1} (add_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) complete_lattice.{1}) pos h0) (add_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_174353 (h1 : complete_lattice (distrib reducibility_hints)) : complete_lattice.is_Sup_finite_compact (distrib reducibility_hints) := sorry --non-trivial
lemma new_lemma_174354 (h0 : functor.add_const (add_group (complete_distrib_lattice environment.implicit_infer_kind)) Type) : @is_add_cyclic.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (add_group.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_174355 (h0 : function.extfun Type topological_space) : @normal_space.{0} (has_one.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_174356 (h0 : functor.add_const (complete_lattice (has_zero Type)) (has_to_string unsigned)) : @is_atomistic.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (has_zero.{1} Type)) (has_to_string.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_174357 (h0 : add_monoid (random_gen (has_norm empty))) : add_monoid.fg (random_gen (has_norm empty)) := sorry --non-trivial
lemma new_lemma_174358 (h0 : ring (mul_zero_class (has_add ennreal))) : is_domain (mul_zero_class (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_174359 (h0 : functor.add_const (complete_lattice (normed_comm_ring empty)) (option (option empty))) : @is_atomistic.{0} (normed_comm_ring.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (normed_comm_ring.{0} empty)) (option.{0} (option.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_174360 (h0 : set (distrib (distrib (has_nnnorm (mul_one_class to_additive.value_type))))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_174361 (h0 : list (with_one linarith.comp_source)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_174362 (h0 : group (linear_ordered_field (option unsigned))) : is_cyclic (linear_ordered_field (option unsigned)) := sorry --non-trivial
lemma new_lemma_174363 (h0 : not (has_mem.mem (with_bot num) has_emptyc.emptyc -> false)) : @irreducible_space.{0} (with_bot.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_bot.{0} num) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_bot.{0} num) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_174364 (h0 : group (denumerable (random_gen to_additive.value_type))) : group.fg (denumerable (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_174365 (h0 : functor.add_const (topological_space (generalized_boolean_algebra pos)) (ordered_ring name)) : @discrete_topology.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} pos)) (ordered_ring.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_174366 (h0 : functor.add_const (ordered_add_comm_monoid (has_neg_part unsigned)) unsigned) : @archimedean.{0} (has_neg_part.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_neg_part.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_174367 (h1 h2 : multiset (has_ssubset (simple_graph string.iterator_imp))) : multiset.subset h1 h2 := sorry --non-trivial
lemma new_lemma_174368 (h0 : finset (finset (ring Type))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_174369 (h0 : function.extfun Type group) : @is_simple_group.{0} (semigroup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (semigroup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_174370 (h0 : not (ring (with_one empty) -> false)) : @is_domain.{0} (with_one.{0} empty) (@classical.by_contradiction'.{1} (ring.{0} (with_one.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_174371 (h1 : function.extfun Type monoid) : @monoid.fg.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type monoid.{0} h1 (linear_ordered_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_174372 (h0 : functor.add_const (list (cancel_monoid pos)) Type) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_174373 (h0 : group Type) : is_simple_group Type := sorry --non-trivial
lemma new_lemma_174374 (h1 : filter (has_nnnorm (random_gen (has_inv (random_gen string_imp))))) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_174375 (h0 : function.extfun (finset Type) (has_mem.mem (with_one linarith.comp_source))) : @is_atomistic.{0} (with_one.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (with_one.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_one.{0} linarith.comp_source)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_174376 (h0 : function.extfun Type (functor.add_const (add_group (bin_tree empty)))) : @is_add_cyclic.{0} (bin_tree.{0} empty) (@functor.add_const.run.{0 0} (add_group.{0} (bin_tree.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (add_group.{0} (bin_tree.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_174377 (h0 : group (has_star (semiring (semiring unsigned)))) : normalizer_condition (has_star (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_174378 (h2 : function.extfun (finset Type) (has_mem.mem (semiring linarith.comp_source))) : @rank_condition.{0} (semiring.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type ring.{0} (semiring.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} linarith.comp_source)) h2 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_174379 (h0 : ring (mul_zero_class empty)) : is_principal_ideal_ring (mul_zero_class empty) := sorry --non-trivial
lemma new_lemma_174380 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (sub_neg_monoid.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (sub_neg_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_174381 (h0 : topological_space (has_neg_part (boolean_algebra.core name))) : irreducible_space (has_neg_part (boolean_algebra.core name)) := sorry --non-trivial
lemma new_lemma_174382 (h0 : ring (has_add (option pos))) : rank_condition (has_add (option pos)) := sorry --non-trivial
lemma new_lemma_174383 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} (topological_space.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (topological_space.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_174384 (h0 : set (nondiscrete_normed_field linarith.ineq -> char)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_174385 (h0 : function.extfun Type group) : @normalizer_condition.{0} (semigroup.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} h0 (semigroup.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_174386 (h0 : group (distrib_lattice (random_gen (random_gen linarith.comp_source)))) : group.fg (distrib_lattice (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_174387 (h1 : topological_space real.angle) : totally_separated_space real.angle := sorry --non-trivial
lemma new_lemma_174388 (h0 : complete_lattice (has_neg (finset (has_pos_part Type)))) : is_compactly_generated (has_neg (finset (has_pos_part Type))) := sorry --non-trivial
lemma new_lemma_174389 (h0 : topological_space (has_compl reducibility_hints)) : t0_space (has_compl reducibility_hints) := sorry --non-trivial
lemma new_lemma_174390 (h0 : ring (has_top (random_gen (random_gen (random_gen fun_info))))) : is_domain (has_top (random_gen (random_gen (random_gen fun_info)))) := sorry --non-trivial
lemma new_lemma_174391 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @regular_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_cancel_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_174392 (h0 : topological_space (normed_comm_ring (ring pos))) : loc_path_connected_space (normed_comm_ring (ring pos)) := sorry --non-trivial
lemma new_lemma_174393 (h0 : functor.add_const (topological_space (has_star empty)) num) : @discrete_topology.{0} (has_star.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_174394 (h0 : topological_space (has_neg (finset (finset (finset pos))))) : locally_compact_space (has_neg (finset (finset (finset pos)))) := sorry --non-trivial
lemma new_lemma_174395 (h0 : topological_space (canonically_ordered_comm_semiring Type)) : normal_space (canonically_ordered_comm_semiring Type) := sorry --non-trivial
lemma new_lemma_174396 (h0 : functor.add_const (topological_space (finset linarith.comp)) (has_neg Type)) : @totally_disconnected_space.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (finset.{0} linarith.comp)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_174397 (h0 : topological_space (simple_graph (ring linarith.comp))) : loc_path_connected_space (simple_graph (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_174398 (h0 : topological_space (has_nndist (comm_group name))) : locally_compact_space (has_nndist (comm_group name)) := sorry --non-trivial
lemma new_lemma_174399 (h0 : topological_space (has_add (has_Inf real))) : regular_space (has_add (has_Inf real)) := sorry --non-trivial
lemma new_lemma_174400 (h0 : function.extfun Type (functor.add_const (topological_space (add_right_cancel_monoid empty)))) : @totally_separated_space.{0} (add_right_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_right_cancel_monoid.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (add_right_cancel_monoid.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_174401 (h0 : topological_space (group_with_zero unsigned)) : normal_space (group_with_zero unsigned) := sorry --non-trivial
lemma new_lemma_174402 (h0 : topological_space (has_top (semiring (semiring unsigned)))) : locally_compact_space (has_top (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_174403 (h0 : function.extfun (finset Type) (has_mem.mem (has_one congr_arg_kind))) : @is_atomistic.{0} (has_one.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (has_one.{0} congr_arg_kind) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_one.{0} congr_arg_kind)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_174404 (h0 : add_group (measurable_space num)) : is_add_cyclic (measurable_space num) := sorry --non-trivial
lemma new_lemma_174405 (h1 : has_lt (linear_ordered_comm_group_with_zero environment.projection_info)) : no_max_order (linear_ordered_comm_group_with_zero environment.projection_info) := sorry --non-trivial
lemma new_lemma_174406 (h1 : topological_space (uniform_space reducibility_hints)) : totally_disconnected_space (uniform_space reducibility_hints) := sorry --non-trivial
lemma new_lemma_174407 (h0 : group (has_lt (mul_one_class linarith.ineq))) : is_cyclic (has_lt (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_174408 (h0 : ordered_add_comm_monoid (linear_ordered_comm_group empty)) : archimedean (linear_ordered_comm_group empty) := sorry --non-trivial
lemma new_lemma_174409 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_174410 (h0 : topological_space (comm_group (has_neg (has_add linarith.comp)))) : t1_space (comm_group (has_neg (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_174411 (h0 : not (topological_space (normed_group congr_arg_kind) -> false)) : @preirreducible_space.{0} (normed_group.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_group.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_174412 (h0 : topological_space (has_lt enat)) (h1 : add_group (has_lt enat)) : topological_add_group (has_lt enat) := sorry --non-trivial
lemma new_lemma_174413 (h0 : uniform_space (complete_distrib_lattice (finset pos))) : separated_space (complete_distrib_lattice (finset pos)) := sorry --non-trivial
lemma new_lemma_174414 (h0 : not (topological_space (has_sub empty) -> false)) : @path_connected_space.{0} (has_sub.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (has_sub.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_174415 (h1 : topological_space (fintype fun_info)) : path_connected_space (fintype fun_info) := sorry --non-trivial
lemma new_lemma_174416 (h0 : functor.add_const (topological_space (comm_semigroup pos)) real) : @t0_space.{0} (comm_semigroup.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_semigroup.{0} pos)) real h0)  := sorry --non-trivial
lemma new_lemma_174417 (h0 : topological_space (boolean_algebra.core (option (option unsigned)))) : normal_space (boolean_algebra.core (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_174418 (h0 : complete_lattice (has_neg name)) : complete_lattice.is_Sup_finite_compact (has_neg name) := sorry --non-trivial
lemma new_lemma_174419 (h0 : not (topological_space (random_gen char) -> false)) : @path_connected_space.{0} (random_gen.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (random_gen.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_174420 (h0 : functor.comp topological_space has_neg_part environment.implicit_infer_kind) : @locally_compact_space.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg_part.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_174421 (h0 : ring (add_cancel_monoid unsigned)) : is_domain (add_cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_174422 (h0 : has_lt (simple_graph (mul_one_class ereal))) : no_max_order (simple_graph (mul_one_class ereal)) := sorry --non-trivial
lemma new_lemma_174423 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (has_add.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_add.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_174424 (h1 : ring (uniform_space to_additive.value_type)) : strong_rank_condition (uniform_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_174425 (h0 : topological_space (simple_graph name)) : t1_space (simple_graph name) := sorry --non-trivial
lemma new_lemma_174426 (h0 : functor.comp ring finset pos) : @is_principal_ideal_ring.{0} (finset.{0} pos) (@functor.comp.run.{0 0 0} ring.{0} finset.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_174427 (h1 : not (uniform_space (uniform_space string_imp) -> false)) : @complete_space.{0} (uniform_space.{0} string_imp) (@classical.by_contradiction'.{1} (uniform_space.{0} (uniform_space.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_174428 (h0 : functor.add_const (group (has_add Type)) pos) : @group.fg.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (has_add.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_174429 (h1 : set (mul_one_class (mul_one_class char) -> fun_info)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_174430 (h0 : functor.add_const (complete_lattice (has_zero ennreal)) unsigned) : @is_compactly_generated.{0} (has_zero.{0} ennreal) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_zero.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_174431 (h0 : functor.add_const (ring (boolean_algebra.core Type)) environment.implicit_infer_kind) : @rank_condition.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (boolean_algebra.core.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_174432 (h0 : topological_space (group_with_zero (option ennreal))) : loc_path_connected_space (group_with_zero (option ennreal)) := sorry --non-trivial
lemma new_lemma_174433 (h0 : fun_info -> fun_info -> Prop) : is_total fun_info h0 := sorry --non-trivial
lemma new_lemma_174434 (h0 : function.extfun Type (functor.add_const (topological_space environment.implicit_infer_kind))) : @totally_disconnected_space.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 0} (topological_space.{0} environment.implicit_infer_kind) name (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} environment.implicit_infer_kind)) h0 name))  := sorry --non-trivial
lemma new_lemma_174435 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (pseudo_metric_space.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (pseudo_metric_space.{0} name))  := sorry --non-trivial
lemma new_lemma_174436 (h0 : topological_space (add_comm_monoid Type)) : locally_compact_space (add_comm_monoid Type) := sorry --non-trivial
lemma new_lemma_174437 (h0 : fin has_zero.zero) : @has_exists_mul_of_le.{0} (complete_distrib_lattice.{0} (has_add.{0} pos)) (@matrix.vec_empty.{0} (ordered_comm_monoid.{0} (complete_distrib_lattice.{0} (has_add.{0} pos))) h0)  := sorry --non-trivial
lemma new_lemma_174438 (h1 : ring (random_gen fun_info)) : is_domain (random_gen fun_info) := sorry --non-trivial
lemma new_lemma_174439 (h0 : ring (partial_order (semiring (semiring empty)))) : strong_rank_condition (partial_order (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_174440 (h0 : topological_space (has_ssubset string_imp)) : locally_compact_space (has_ssubset string_imp) := sorry --non-trivial
lemma new_lemma_174441 (h0 : functor.comp ordered_add_comm_monoid ring name) : @archimedean.{0} (ring.{0} name) (@functor.comp.run.{0 0 0} ordered_add_comm_monoid.{0} ring.{0} name h0)  := sorry --non-trivial
lemma new_lemma_174442 (h0 : not (complete_lattice (semi_normed_ring linarith.ineq) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (semi_normed_ring.{0} linarith.ineq) (@classical.by_contradiction'.{1} (complete_lattice.{0} (semi_normed_ring.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_174443 (h0 : functor.add_const (list (has_to_string Type)) name) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_174444 (h0 : ring (semigroup (has_neg (has_Inf (has_neg Type))))) : is_principal_ideal_ring (semigroup (has_neg (has_Inf (has_neg Type)))) := sorry --non-trivial
lemma new_lemma_174445 (h0 : functor.add_const (topological_space (complete_distrib_lattice Type)) name) : @preirreducible_space.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (complete_distrib_lattice.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_174446 (h0 : topological_space (sub_neg_monoid (has_add linarith.comp))) : normal_space (sub_neg_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_174447 (h1 : ring (topological_space string_imp)) : is_domain (topological_space string_imp) := sorry --non-trivial
lemma new_lemma_174448 (h0 : functor.add_const (topological_space (boolean_algebra.core unsigned)) name) : @normal_space.{0} (boolean_algebra.core.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_174449 (h0 : functor.add_const (list (has_zero linarith.comp)) linarith.comp) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_174450 (h0 : function.extfun Type group) : @group.fg.{0} (semigroup.{0} name) (@function.extfun_app.{2 1} Type group.{0} h0 (semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_174451 (h0 : ring (simple_graph Type)) : rank_condition (simple_graph Type) := sorry --non-trivial
lemma new_lemma_174452 (h0 : topological_space (ring (has_add (finset pos)))) : discrete_topology (ring (has_add (finset pos))) := sorry --non-trivial
lemma new_lemma_174453 (h0 : not (topological_space (encodable to_additive.value_type) -> false)) : @totally_disconnected_space.{0} (encodable.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (encodable.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_174454 (h1 : add_group (normed_field enat)) : is_add_cyclic (normed_field enat) := sorry --non-trivial
lemma new_lemma_174455 (h0 : not (function.extfun Type semiring -> false)) : @is_noetherian_ring.{0} (has_sub.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type semiring.{0}) h0) (has_sub.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_174456 (h0 : monoid (cancel_monoid num)) : monoid.fg (cancel_monoid num) := sorry --non-trivial
lemma new_lemma_174457 (h0 : functor.add_const (function.extfun (Type 1) ring) (has_neg (has_add name))) : @is_principal_ideal_ring.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ring.{1}) (has_neg.{0} (has_add.{0} name)) h0) (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_174458 (h0 : set (has_nnnorm to_additive.value_type)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_174459 (h0 : function.extfun Type topological_space) : @normal_space.{0} (semiring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_174460 (h0 : not (group (with_bot linarith.comp) -> false)) : @is_cyclic.{0} (with_bot.{0} linarith.comp) (@classical.by_contradiction'.{1} (group.{0} (with_bot.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_174461 (h0 : functor.add_const (topological_space (simple_graph pos)) linarith.comp) : @discrete_topology.{0} (simple_graph.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (simple_graph.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_174462 (h0 : functor.add_const (topological_space (add_cancel_monoid Type)) (comm_group (has_neg_part Type))) : @preconnected_space.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (add_cancel_monoid.{1} Type)) (comm_group.{1} (has_neg_part.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_174463 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_repr Type)) pos) : @unique_factorization_monoid.{1} (has_repr.{1} Type) (@functor.add_const.run.{1 0} (cancel_comm_monoid_with_zero.{1} (has_repr.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_174464 (h0 : fin has_zero.zero) : @normalizer_condition.{0} (sub_neg_monoid.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type group.{0}) h0) (sub_neg_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_174465 (h0 : fin has_zero.zero) (h1 h2 : fin (matrix.vec_empty h0)) : fin.lt h1 h2 := sorry --non-trivial
lemma new_lemma_174466 (h0 : group (canonically_ordered_add_monoid unsigned)) : group.fg (canonically_ordered_add_monoid unsigned) := sorry --non-trivial
lemma new_lemma_174467 (h0 : topological_space (mul_zero_class (has_to_string (finset (has_nndist name))))) : preirreducible_space (mul_zero_class (has_to_string (finset (has_nndist name)))) := sorry --non-trivial
lemma new_lemma_174468 (h0 : uniform_space (has_to_string (non_assoc_semiring Type))) : complete_space (has_to_string (non_assoc_semiring Type)) := sorry --non-trivial
lemma new_lemma_174469 (h0 : functor.add_const (function.extfun (Type 1) topological_space) name) : @preirreducible_space.{1} (ordered_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) name h0) (ordered_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_174470 (h0 : add_group (mul_one_class enat)) : is_add_cyclic (mul_one_class enat) := sorry --non-trivial
lemma new_lemma_174471 (h0 : ring (random_gen (has_norm (semiring congr_arg_kind)))) : is_domain (random_gen (has_norm (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_174472 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (ordered_ring.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (ordered_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_174473 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @preconnected_space.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_174474 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @t0_space.{0} (has_norm.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (has_norm.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_174475 (h0 : complete_lattice (has_zero (ring pos))) : is_compactly_generated (has_zero (ring pos)) := sorry --non-trivial
lemma new_lemma_174476 (h2 : set (string.iterator_imp -> enat)) : set.separates_points h2 := sorry --non-trivial
lemma new_lemma_174477 (h0 : functor.add_const (topological_space (has_to_string environment.implicit_infer_kind)) linarith.comp) : @irreducible_space.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_174478 (h0 : functor.add_const (ordered_comm_monoid (add_cancel_monoid pos)) (has_add Type)) : @has_exists_mul_of_le.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (add_cancel_monoid.{0} pos)) (has_add.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_174479 (h0 : add_group (complete_semilattice_Sup (random_gen linarith.ineq))) : is_add_cyclic (complete_semilattice_Sup (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_174480 (h0 : prod (boolean_algebra empty) (boolean_algebra empty)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_174481 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @discrete_topology.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_174482 (h0 : not (uniform_space (measurable_space.dynkin_system linarith.comp) -> false)) : @separated_space.{0} (measurable_space.dynkin_system.{0} linarith.comp) (@classical.by_contradiction'.{1} (uniform_space.{0} (measurable_space.dynkin_system.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_174483 (h0 : group (has_norm (has_inv (has_inv fun_info)))) : normalizer_condition (has_norm (has_inv (has_inv fun_info))) := sorry --non-trivial
lemma new_lemma_174484 (h0 : list (semigroup (semiring empty))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_174485 (h0 : functor.add_const (add_group (cancel_monoid environment.implicit_infer_kind)) pos) : @is_add_cyclic.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (add_group.{0} (cancel_monoid.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_174486 (h1 : complete_lattice (linear_ordered_add_comm_group linarith.ineq)) : is_compactly_generated (linear_ordered_add_comm_group linarith.ineq) := sorry --non-trivial
lemma new_lemma_174487 (h0 : ring (preorder empty)) : is_principal_ideal_ring (preorder empty) := sorry --non-trivial
lemma new_lemma_174488 (h0 : not (topological_space (has_compl string_imp) -> false)) : @t0_space.{0} (has_compl.{0} string_imp) (@classical.by_contradiction'.{1} (topological_space.{0} (has_compl.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_174489 (h0 : nondiscrete_normed_field char) (h1 : filter (nondiscrete_normed_field char)) : @t0_space.{0} (nondiscrete_normed_field.{0} char) (@nhds_adjoint.{0} (nondiscrete_normed_field.{0} char) h0 h1)  := sorry --non-trivial
lemma new_lemma_174490 (h0 : complete_lattice (random_gen (semiring linarith.comp))) : is_compactly_generated (random_gen (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_174491 (h0 : topological_space (boolean_algebra (has_to_string linarith.comp))) : path_connected_space (boolean_algebra (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_174492 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (semigroup pos)) := sorry --non-trivial
lemma new_lemma_174493 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (add_group.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_174494 (h0 : filter (has_neg (option pos))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_174495 (h2 : not (ring (comm_ring (random_gen char)) -> false)) : @rank_condition.{0} (comm_ring.{0} (random_gen.{0} char)) (@classical.by_contradiction'.{1} (ring.{0} (comm_ring.{0} (random_gen.{0} char))) h2)  := sorry --non-trivial
lemma new_lemma_174496 (h1 : topological_space (denumerable (has_nnnorm (has_nnnorm (has_nnnorm reducibility_hints))))) : t0_space (denumerable (has_nnnorm (has_nnnorm (has_nnnorm reducibility_hints)))) := sorry --non-trivial
lemma new_lemma_174497 (h0 : group (comm_monoid num)) : normalizer_condition (comm_monoid num) := sorry --non-trivial
lemma new_lemma_174498 (h0 : filter name) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_174499 (h0 : functor.add_const (ring (complete_distrib_lattice linarith.comp)) pos) : @rank_condition.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (complete_distrib_lattice.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_174500 (h0 : group (linear_ordered_semiring linarith.comp_source)) : is_cyclic (linear_ordered_semiring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_174501 (h0 : functor.add_const (filter (has_nndist pos)) pos) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_174502 (h0 : function.extfun Type ring) : @rank_condition.{0} (simple_graph.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (simple_graph.{0} pos))  := sorry --non-trivial
lemma new_lemma_174503 (h0 : topological_space (option (semiring (semiring unsigned)))) : t0_space (option (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_174504 (h0 : set (has_lt (mul_one_class linarith.ineq))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_174505 (h1 : complete_lattice (nondiscrete_normed_field (normed_field linarith.ineq))) : complete_lattice.is_Sup_finite_compact (nondiscrete_normed_field (normed_field linarith.ineq)) := sorry --non-trivial
lemma new_lemma_174506 (h0 : functor.add_const (complete_lattice (has_to_string linarith.comp)) (finset (finset pos))) : @complete_lattice.is_Sup_finite_compact.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_to_string.{0} linarith.comp)) (finset.{0} (finset.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_174507 (h0 : functor.add_const (filter (normed_comm_ring name)) pos) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_174508 (h0 : topological_space (has_add (has_add name))) : sequential_space (has_add (has_add name)) := sorry --non-trivial
lemma new_lemma_174509 (h0 : filter (ring unsigned)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_174510 (h0 : has_mem.mem (with_bot linarith.comp_source) has_emptyc.emptyc) : @is_domain.{0} (with_bot.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type ring.{0} (with_bot.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_174511 (h0 : topological_space (has_nndist pos)) : t1_space (has_nndist pos) := sorry --non-trivial
lemma new_lemma_174512 (h0 : ring (normed_group (random_gen linarith.comp_source))) : rank_condition (normed_group (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_174513 (h0 : functor.add_const (filter (has_top (has_nnnorm fun_info))) string_imp) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_174514 (h0 : ring (measure_theory.measure_space (semiring empty))) : is_principal_ideal_ring (measure_theory.measure_space (semiring empty)) := sorry --non-trivial
lemma new_lemma_174515 (h0 : linarith.comp) (h1 : multiset linarith.comp) : multiset.mem h0 h1 := sorry --non-trivial
lemma new_lemma_174516 (h0 : functor.add_const (complete_lattice (add_comm_monoid pos)) (comm_group pos)) : @is_atomistic.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_comm_monoid.{0} pos)) (comm_group.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_174517 (h0 : topological_space (has_ssubset (semi_normed_ring linarith.ineq))) : path_connected_space (has_ssubset (semi_normed_ring linarith.ineq)) := sorry --non-trivial
lemma new_lemma_174518 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (linear_ordered_add_comm_group.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (linear_ordered_add_comm_group.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_174519 (h0 : not (ring (has_add to_additive.value_type) -> false)) : @is_domain.{0} (has_add.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (has_add.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_174520 (h0 : ring (complete_semilattice_Sup num)) : invariant_basis_number (complete_semilattice_Sup num) := sorry --non-trivial
lemma new_lemma_174521 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} (denumerable.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (denumerable.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_174522 (h0 : topological_space (comm_group (has_add environment.implicit_infer_kind))) : normal_space (comm_group (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_174523 (h0 : topological_space (ordered_comm_ring (boolean_algebra.core (has_Inf name)))) : discrete_topology (ordered_comm_ring (boolean_algebra.core (has_Inf name))) := sorry --non-trivial
lemma new_lemma_174524 (h0 : complete_lattice (left_cancel_monoid to_additive.value_type)) : is_atomistic (left_cancel_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_174525 (h0 : add_group (add_comm_monoid unsigned)) : is_add_cyclic (add_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_174526 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (with_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_174527 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (has_inter unsigned)) := sorry --non-trivial
lemma new_lemma_174528 (h0 : uniform_space (has_one (semiring unsigned))) : complete_space (has_one (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_174529 (h0 : functor.add_const (list (has_add Type)) (ring (ring linarith.comp))) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_174530 (h0 : functor.add_const (function.extfun Type topological_space) (has_add Type)) : @normal_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) (has_add.{1} Type) h0) (semigroup.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_174531 (h0 : functor.add_const (add_group (complete_distrib_lattice pos)) (boolean_algebra name)) : @is_add_cyclic.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (complete_distrib_lattice.{0} pos)) (boolean_algebra.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_174532 (h0 : topological_space (comm_group (has_add (has_add unsigned)))) : sequential_space (comm_group (has_add (has_add unsigned))) := sorry --non-trivial
lemma new_lemma_174533 (h0 : topological_space (complete_distrib_lattice (finset pos))) : t0_space (complete_distrib_lattice (finset pos)) := sorry --non-trivial
lemma new_lemma_174534 (h0 : topological_space (ring (has_to_string (has_pos_part (ordered_comm_ring (has_pos_part pos)))))) : t0_space (ring (has_to_string (has_pos_part (ordered_comm_ring (has_pos_part pos))))) := sorry --non-trivial
lemma new_lemma_174535 (h0 : add_monoid (filter congr_arg_kind)) : add_monoid.fg (filter congr_arg_kind) := sorry --non-trivial
lemma new_lemma_174536 (h0 : function.extfun Type (functor.comp topological_space complete_distrib_lattice)) : @normal_space.{0} (complete_distrib_lattice.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} complete_distrib_lattice.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} complete_distrib_lattice.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_174537 (h1 : topological_space (mul_one_class enat)) : path_connected_space (mul_one_class enat) := sorry --non-trivial
lemma new_lemma_174538 (h0 : group (linear_ordered_add_comm_group (has_top (has_nnnorm fun_info)))) : group.fg (linear_ordered_add_comm_group (has_top (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_174539 (h0 : group (complete_semilattice_Sup (random_gen (random_gen fun_info)))) : normalizer_condition (complete_semilattice_Sup (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_174540 (h0 : functor.add_const (function.extfun Type topological_space) (ring Type)) : @totally_separated_space.{0} (mul_zero_class.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) (ring.{1} Type) h0) (mul_zero_class.{0} pos))  := sorry --non-trivial
lemma new_lemma_174541 (h0 : uniform_space (has_union congr_arg_kind)) : complete_space (has_union congr_arg_kind) := sorry --non-trivial
lemma new_lemma_174542 (h0 : not (add_group (random_gen string.iterator_imp) -> false)) : @is_add_cyclic.{0} (random_gen.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (add_group.{0} (random_gen.{0} string.iterator_imp)) h0)  := sorry --non-trivial
lemma new_lemma_174543 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (normed_comm_ring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_comm_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_174544 (h0 : has_mem.mem empty has_emptyc.emptyc) : @is_domain.{0} empty (@finset.pi.empty.{1 0} Type ring.{0} empty h0)  := sorry --non-trivial
lemma new_lemma_174545 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (left_cancel_semigroup num)) := sorry --non-trivial
lemma new_lemma_174546 (h0 : not (group (partial_order unsigned) -> false)) : @is_cyclic.{0} (partial_order.{0} unsigned) (@classical.by_contradiction'.{1} (group.{0} (partial_order.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_174547 (h0 : topological_space (has_pos_part pos)) : topological_space.separable_space (has_pos_part pos) := sorry --non-trivial
lemma new_lemma_174548 (h0 : monoid (with_bot (comm_ring (random_gen to_additive.value_type)))) : monoid.fg (with_bot (comm_ring (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_174549 (h0 : topological_space (has_bot (has_bot name))) : path_connected_space (has_bot (has_bot name)) := sorry --non-trivial
lemma new_lemma_174550 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : countable_Inter_filter (function.extfun_app (function.extfun_app h0 filter) (finset ennreal)) := sorry --non-trivial
lemma new_lemma_174551 (h0 : fin has_zero.zero) : @Lim.{0} Prop sierpinski_space (@nonempty_of_inhabited.{1} Prop sort.inhabited.{0}) (@matrix.vec_empty.{0} (filter.{0} Prop) h0)  := sorry --non-trivial
lemma new_lemma_174552 (h0 : not (topological_space (preorder unsigned) -> false)) : @path_connected_space.{0} (preorder.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (preorder.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_174553 (h0 : topological_space (has_compl (has_inv fun_info))) : totally_disconnected_space (has_compl (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_174554 (h0 : ring (semi_normed_comm_ring std_gen)) : strong_rank_condition (semi_normed_comm_ring std_gen) := sorry --non-trivial
lemma new_lemma_174555 (h0 : complete_lattice (order_dual (semiring (semiring (semiring num))))) : is_compactly_generated (order_dual (semiring (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_174556 (h0 : functor.add_const (complete_lattice (finset linarith.comp)) Type) : @complete_lattice.is_Sup_finite_compact.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 1} (complete_lattice.{0} (finset.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_174557 (h0 : ring (measure_theory.measure_space num)) : rank_condition (measure_theory.measure_space num) := sorry --non-trivial
lemma new_lemma_174558 (h0 : functor.add_const (add_group (has_nndist empty)) empty) : @is_add_cyclic.{0} (has_nndist.{0} empty) (@functor.add_const.run.{0 0} (add_group.{0} (has_nndist.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_174559 (h0 : group (normed_comm_ring (comm_group Type))) : normalizer_condition (normed_comm_ring (comm_group Type)) := sorry --non-trivial
lemma new_lemma_174560 (h0 : ring (ordered_cancel_add_comm_monoid ennreal)) : is_principal_ideal_ring (ordered_cancel_add_comm_monoid ennreal) := sorry --non-trivial
lemma new_lemma_174561 (h0 : finset (normed_comm_ring (finset (finset (finset pos))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_174562 (h0 : ring (ring (option ennreal))) : rank_condition (ring (option ennreal)) := sorry --non-trivial
lemma new_lemma_174563 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_174564 (h0 : functor.add_const (topological_space (has_add Type)) pos) : @t0_space.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_add.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_174565 (h0 : ring (has_emptyc (semiring empty))) : strong_rank_condition (has_emptyc (semiring empty)) := sorry --non-trivial
lemma new_lemma_174566 (h0 : function.extfun nat fin) : @t1_space.{0} (boolean_algebra.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (boolean_algebra.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_174567 (h0 : not (uniform_space (normed_group congr_arg_kind) -> false)) : @separated_space.{0} (normed_group.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (uniform_space.{0} (normed_group.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_174568 (h1 : ring (encodable string_imp)) : is_domain (encodable string_imp) := sorry --non-trivial
lemma new_lemma_174569 (h0 : ring (finset congr_arg_kind)) : strong_rank_condition (finset congr_arg_kind) := sorry --non-trivial
lemma new_lemma_174570 (h0 : topological_space (has_emptyc (random_gen linarith.ineq))) : path_connected_space (has_emptyc (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_174571 (h0 : finset reducibility_hints) (h1 : finset.nonempty h0) (h2 : reducibility_hints -> uniform_space (has_nnnorm ereal)) : @complete_space.{0} (has_nnnorm.{0} ereal) (@finset.inf'.{0 0} (uniform_space.{0} (has_nnnorm.{0} ereal)) reducibility_hints (@lattice.to_semilattice_inf.{0} (uniform_space.{0} (has_nnnorm.{0} ereal)) (@conditionally_complete_lattice.to_lattice.{0} (uniform_space.{0} (has_nnnorm.{0} ereal)) (@complete_lattice.to_conditionally_complete_lattice.{0} (uniform_space.{0} (has_nnnorm.{0} ereal)) (@uniform_space.complete_lattice.{0} (has_nnnorm.{0} ereal))))) h0 h1 h2)  := sorry --non-trivial
lemma new_lemma_174572 (h0 : topological_space (has_to_string (has_neg linarith.comp))) : preconnected_space (has_to_string (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_174573 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_inv.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inv.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_174574 (h0 : not (function.extfun Type ring -> false)) : @strong_rank_condition.{0} (random_gen.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (random_gen.{0} num))  := sorry --non-trivial
lemma new_lemma_174575 (h0 : ordered_comm_monoid (normed_comm_ring (ring (option pos)))) : has_exists_mul_of_le (normed_comm_ring (ring (option pos))) := sorry --non-trivial
lemma new_lemma_174576 (h0 : filter (has_add (has_nndist (ring (has_pos_part pos))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_174577 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (ordered_ring.{0} (semiring.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_ring.{0} (semiring.{0} empty)))  := sorry --non-trivial
lemma new_lemma_174578 (h0 : topological_space (free_add_monoid empty)) : totally_disconnected_space (free_add_monoid empty) := sorry --non-trivial
lemma new_lemma_174579 (h0 : topological_space (has_norm (has_top (has_top linarith.comp_source)))) : totally_separated_space (has_norm (has_top (has_top linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_174580 (h0 : group (ordered_comm_monoid pos)) : normalizer_condition (ordered_comm_monoid pos) := sorry --non-trivial
lemma new_lemma_174581 (h0 : topological_space (canonically_ordered_comm_semiring name)) : irreducible_space (canonically_ordered_comm_semiring name) := sorry --non-trivial
lemma new_lemma_174582 (h0 : filter (ordered_comm_group unsigned)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_174583 (h0 : functor.add_const (fin has_zero.zero) Type) : @unique_factorization_monoid.{0} (has_bot.{0} real) (@matrix.vec_empty.{0} (cancel_comm_monoid_with_zero.{0} (has_bot.{0} real)) (@functor.add_const.run.{0 1} (fin (@has_zero.zero.{0} nat nat.has_zero)) Type h0))  := sorry --non-trivial
lemma new_lemma_174584 (h0 : has_mem.mem (measurable_space linarith.comp) has_emptyc.emptyc) : @rank_condition.{0} (measurable_space.{0} linarith.comp) (@finset.pi.empty.{1 0} Type ring.{0} (measurable_space.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_174585 (h0 : ring (has_top (random_gen string_imp))) : rank_condition (has_top (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_174586 (h0 : functor.add_const (topological_space (simple_graph linarith.comp)) (has_add (has_pos_part Type))) : @discrete_topology.{0} (simple_graph.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (simple_graph.{0} linarith.comp)) (has_add.{1} (has_pos_part.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_174587 (h0 : function.extfun Type ring) : @rank_condition.{0} (dlist.{0} string_imp) (@function.extfun_app.{2 1} Type ring.{0} h0 (dlist.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_174588 (h0 : group (linear_ordered_semiring (semiring unsigned))) : normalizer_condition (linear_ordered_semiring (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_174589 (h1 : not (complete_lattice (comm_ring char) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (comm_ring.{0} char) (@classical.by_contradiction'.{1} (complete_lattice.{0} (comm_ring.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_174590 (h0 : uniform_space (boolean_algebra real)) : separated_space (boolean_algebra real) := sorry --non-trivial
lemma new_lemma_174591 (h0 : topological_space (has_top (right_cancel_semigroup fun_info))) : locally_compact_space (has_top (right_cancel_semigroup fun_info)) := sorry --non-trivial
lemma new_lemma_174592 (h0 : functor.add_const (filter (has_nndist unsigned)) environment.implicit_infer_kind) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_174593 (h0 : group (sub_neg_monoid (has_add linarith.comp))) : is_cyclic (sub_neg_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_174594 (h0 : topological_space (has_zero (has_to_string name))) : discrete_topology (has_zero (has_to_string name)) := sorry --non-trivial
lemma new_lemma_174595 (h0 : semiring (comm_group (ring linarith.comp))) : is_noetherian_ring (comm_group (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_174596 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (has_dist.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_dist.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_174597 (h0 : ring (partial_order (semiring num))) : invariant_basis_number (partial_order (semiring num)) := sorry --non-trivial
lemma new_lemma_174598 (h0 : topological_space (has_Inf (finset (has_add (has_add (has_add (has_add (has_to_string pos)))))))) : t1_space (has_Inf (finset (has_add (has_add (has_add (has_add (has_to_string pos))))))) := sorry --non-trivial
lemma new_lemma_174599 (h0 : topological_space (has_nndist pos)) : totally_separated_space (has_nndist pos) := sorry --non-trivial
lemma new_lemma_174600 (h0 : functor.add_const (cancel_comm_monoid_with_zero (finset Type)) pos) : @unique_factorization_monoid.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (cancel_comm_monoid_with_zero.{1} (finset.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_174601 (h0 : uniform_space (semiring (semiring (semiring (semiring (semiring (semiring num))))))) : separated_space (semiring (semiring (semiring (semiring (semiring (semiring num)))))) := sorry --non-trivial
lemma new_lemma_174602 (h0 : topological_space (random_gen (has_nnnorm to_additive.value_type))) : t0_space (random_gen (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_174603 (h0 : functor.add_const (topological_space (has_Inf Type)) Type) : @sequential_space.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_Inf.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_174604 (h0 : topological_space (canonically_ordered_comm_semiring (has_neg pos))) : loc_path_connected_space (canonically_ordered_comm_semiring (has_neg pos)) := sorry --non-trivial
lemma new_lemma_174605 (h0 : ring (distrib (metric_space (mul_one_class reducibility_hints)))) : rank_condition (distrib (metric_space (mul_one_class reducibility_hints))) := sorry --non-trivial
lemma new_lemma_174606 (h0 : function.extfun Type (functor.add_const Prop)) : functor.add_const.run (function.extfun_app h0 (has_zero pos)) := sorry --non-trivial
lemma new_lemma_174607 (h0 : topological_space (with_one (has_norm (has_norm empty)))) : locally_compact_space (with_one (has_norm (has_norm empty))) := sorry --non-trivial
lemma new_lemma_174608 (h0 : uniform_space (add_right_cancel_monoid empty)) : complete_space (add_right_cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_174609 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_ssubset.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_ssubset.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_174610 (h0 : functor.add_const (list (finset pos)) unsigned) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_174611 (h0 : topological_space (boolean_algebra (has_add pos))) : preconnected_space (boolean_algebra (has_add pos)) := sorry --non-trivial
lemma new_lemma_174612 (h0 : function.extfun Type ring) : @rank_condition.{0} (finset.{0} real) (@function.extfun_app.{2 1} Type ring.{0} h0 (finset.{0} real))  := sorry --non-trivial
lemma new_lemma_174613 (h0 : topological_space (has_add (has_neg (ordered_ring pos)))) : locally_compact_space (has_add (has_neg (ordered_ring pos))) := sorry --non-trivial
lemma new_lemma_174614 (h0 : functor.add_const (functor.add_const (group pos) name) pos) : @group.fg.{0} pos (@functor.add_const.run.{0 0} (group.{0} pos) name (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (group.{0} pos) name) pos h0))  := sorry --non-trivial
lemma new_lemma_174615 (h0 : topological_space (cancel_monoid (option (option (option unsigned))))) : t0_space (cancel_monoid (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_174616 (h0 : complete_lattice (pseudo_metric_space (option name))) : is_compactly_generated (pseudo_metric_space (option name)) := sorry --non-trivial
lemma new_lemma_174617 (h0 : functor.add_const (group (cancel_monoid name)) pos) : @normalizer_condition.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (group.{0} (cancel_monoid.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_174618 (h0 : topological_space (has_top (random_gen empty))) : path_connected_space (has_top (random_gen empty)) := sorry --non-trivial
lemma new_lemma_174619 (h0 : function.extfun Type ring) : @rank_condition.{0} (with_one.{0} linarith.ineq) (@function.extfun_app.{2 1} Type ring.{0} h0 (with_one.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_174620 (h0 : group (distrib_lattice (random_gen (random_gen (random_gen (random_gen string_imp)))))) : group.fg (distrib_lattice (random_gen (random_gen (random_gen (random_gen string_imp))))) := sorry --non-trivial
lemma new_lemma_174621 (h0 : add_group (with_one (with_bot string_imp))) : is_add_cyclic (with_one (with_bot string_imp)) := sorry --non-trivial
lemma new_lemma_174622 (h0 : list (comm_group (boolean_algebra.core (measurable_space Type)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_174623 (h0 : has_nndist name -> has_nndist name -> Prop) : is_symm (has_nndist name) h0 := sorry --non-trivial
lemma new_lemma_174624 (h0 : topological_space (complete_semilattice_Sup num)) : preirreducible_space (complete_semilattice_Sup num) := sorry --non-trivial
lemma new_lemma_174625 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} to_additive.value_type (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 add_group.{0}) to_additive.value_type)  := sorry --non-trivial
lemma new_lemma_174626 (h0 : function.extfun Type ring) : @rank_condition.{0} (option.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (option.{0} num))  := sorry --non-trivial
lemma new_lemma_174627 (h0 : fin has_zero.zero) : @irreducible_space.{0} (ordered_comm_ring.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_ring.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_174628 (h0 : functor.add_const (monoid (cancel_monoid pos)) environment.implicit_infer_kind) : @monoid.fg.{0} (cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (monoid.{0} (cancel_monoid.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_174629 (h0 : topological_space (add_comm_monoid (has_neg_part (has_neg_part Type)))) : irreducible_space (add_comm_monoid (has_neg_part (has_neg_part Type))) := sorry --non-trivial
lemma new_lemma_174630 (h0 : monoid (semigroup (has_neg_part environment.implicit_infer_kind))) : monoid.fg (semigroup (has_neg_part environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_174631 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (has_to_string.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_to_string.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_174632 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_star.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_star.{0} num))  := sorry --non-trivial
lemma new_lemma_174633 (h0 : not (monoid (measurable_space empty) -> false)) : @monoid.fg.{0} (measurable_space.{0} empty) (@classical.by_contradiction'.{1} (monoid.{0} (measurable_space.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_174634 (h0 : ring (has_neg linarith.comp)) : strong_rank_condition (has_neg linarith.comp) := sorry --non-trivial
lemma new_lemma_174635 (h0 : topological_space (semigroup (has_neg_part ennreal))) : regular_space (semigroup (has_neg_part ennreal)) := sorry --non-trivial
lemma new_lemma_174636 (h0 : functor.add_const (topological_space (generalized_boolean_algebra pos)) Type) : @loc_path_connected_space.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (generalized_boolean_algebra.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_174637 (h0 : functor.add_const (function.extfun Type uniform_space) pos) : @complete_space.{0} (has_zero.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) pos h0) (has_zero.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_174638 (h0 : functor.add_const (topological_space (comm_group unsigned)) (has_neg linarith.comp)) : @normal_space.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} unsigned)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_174639 (h0 : fin has_zero.zero) : @is_add_cyclic.{0} (complete_distrib_lattice.{0} real) (@matrix.vec_empty.{0} (add_group.{0} (complete_distrib_lattice.{0} real)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)))))  := sorry --non-trivial
lemma new_lemma_174640 (h0 : monoid (ordered_cancel_add_comm_monoid (option (option (option empty))))) : monoid.fg (ordered_cancel_add_comm_monoid (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_174641 (h0 : not (topological_space (has_union linarith.comp) -> false)) : @normal_space.{0} (has_union.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (has_union.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_174642 (h0 : function.extfun (finset ((Type -> Type) -> Type 1)) (has_mem.mem (function.extfun Type))) : @locally_compact_space.{0} (with_one.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@finset.pi.empty.{2 1} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) (function.extfun.{2 1} Type) (@function.extfun_app.{3 0} (finset.{2} ((Type → Type) → Type 1)) (@has_mem.mem.{2 2} ((Type → Type) → Type 1) (finset.{2} ((Type → Type) → Type 1)) (@finset.has_mem.{2} ((Type → Type) → Type 1)) (function.extfun.{2 1} Type)) h0 (@has_emptyc.emptyc.{2} (finset.{2} ((Type → Type) → Type 1)) (@finset.has_emptyc.{2} ((Type → Type) → Type 1))))) topological_space.{0}) (with_one.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_174643 (h0 : topological_space (has_div std_gen)) (h1 : add_group (has_div std_gen)) : topological_add_group (has_div std_gen) := sorry --non-trivial
lemma new_lemma_174644 (h0 : list (has_to_string (has_neg linarith.comp))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_174645 (h0 : topological_space (semi_normed_comm_ring (mul_one_class reducibility_hints))) : t0_space (semi_normed_comm_ring (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_174646 (h0 : functor.add_const (uniform_space (has_zero environment.implicit_infer_kind)) name) : @complete_space.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_zero.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_174647 (h2 : complete_lattice (with_one (denumerable char))) : is_compactly_generated (with_one (denumerable char)) := sorry --non-trivial
lemma new_lemma_174648 (h0 : monoid (cancel_monoid (option unsigned))) : monoid.fg (cancel_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_174649 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (normed_group.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_group.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_174650 (h0 : functor.add_const (function.extfun (Type 1) finset) linarith.comp) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_174651 (h0 : topological_space linarith.ineq) : topological_space.first_countable_topology linarith.ineq := sorry --non-trivial
lemma new_lemma_174652 (h1 : complete_lattice (id to_additive.value_type)) : is_atomistic (id to_additive.value_type) := sorry --non-trivial
lemma new_lemma_174653 (h0 : complete_lattice (option (option pos))) : is_compactly_generated (option (option pos)) := sorry --non-trivial
lemma new_lemma_174654 (h0 : functor.add_const (group (boolean_algebra name)) (finset Type)) : @is_simple_group.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 1} (group.{0} (boolean_algebra.{0} name)) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_174655 (h3 : topological_space (with_one num)) : irreducible_space (with_one num) := sorry --non-trivial
lemma new_lemma_174656 (h0 : has_mem.mem (linear_ordered_semiring congr_arg_kind) has_emptyc.emptyc) : @rank_condition.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type ring.{0} (linear_ordered_semiring.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_174657 (h0 : topological_space (partial_order (semiring empty))) : locally_compact_space (partial_order (semiring empty)) := sorry --non-trivial
lemma new_lemma_174658 (h0 : uniform_space (boolean_algebra (semigroup linarith.comp))) : complete_space (boolean_algebra (semigroup linarith.comp)) := sorry --non-trivial
lemma new_lemma_174659 (h0 : ring (comm_semigroup real)) : is_domain (comm_semigroup real) := sorry --non-trivial
lemma new_lemma_174660 (h0 : add_monoid (ordered_comm_group (option empty))) : add_monoid.fg (ordered_comm_group (option empty)) := sorry --non-trivial
lemma new_lemma_174661 (h0 : function.extfun Type topological_space) : t0_space ennreal := sorry --non-trivial
lemma new_lemma_174662 (h0 : functor.add_const (ordered_add_comm_monoid (has_add name)) Type) : @archimedean.{0} (has_add.{0} name) (@functor.add_const.run.{0 1} (ordered_add_comm_monoid.{0} (has_add.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_174663 (h0 : add_monoid (normed_group (has_top congr_arg_kind))) : add_monoid.fg (normed_group (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_174664 (h0 : function.extfun Type (functor.comp topological_space add_cancel_monoid)) : @loc_path_connected_space.{0} (add_cancel_monoid.{0} real) (@functor.comp.run.{0 0 0} topological_space.{0} add_cancel_monoid.{0} real (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} add_cancel_monoid.{0}) h0 real))  := sorry --non-trivial
lemma new_lemma_174665 (h0 : topological_space (has_nndist (mul_one_class Type))) : t0_space (has_nndist (mul_one_class Type)) := sorry --non-trivial
lemma new_lemma_174666 (h0 : topological_space (normed_group linarith.comp)) : irreducible_space (normed_group linarith.comp) := sorry --non-trivial
lemma new_lemma_174667 (h0 : topological_space (has_pos_part (has_Inf (ring (has_add (ring linarith.comp)))))) : preirreducible_space (has_pos_part (has_Inf (ring (has_add (ring linarith.comp))))) := sorry --non-trivial
lemma new_lemma_174668 (h0 : filter (has_add real)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_174669 (h0 : add_monoid (has_emptyc (has_norm empty))) : add_monoid.fg (has_emptyc (has_norm empty)) := sorry --non-trivial
lemma new_lemma_174670 (h0 : monoid (has_bot (has_Inf pos))) : monoid.fg (has_bot (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_174671 (h1 : complete_lattice (normed_group char)) : is_compactly_generated (normed_group char) := sorry --non-trivial
lemma new_lemma_174672 (h0 : functor.add_const (list (option name)) unsigned) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_174673 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (semiring.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semiring.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_174674 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @discrete_topology.{0} (has_top.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (has_top.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_174675 (h0 : functor.add_const (topological_space (normed_comm_ring unsigned)) (ring environment.implicit_infer_kind)) : @t0_space.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} unsigned)) (ring.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_174676 (h0 : complete_lattice (finset (option (option pos)))) : is_atomistic (finset (option (option pos))) := sorry --non-trivial
lemma new_lemma_174677 (h0 : topological_space (random_gen (has_top linarith.comp_source))) : totally_separated_space (random_gen (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_174678 (h0 : topological_space (has_neg linarith.comp)) : regular_space (has_neg linarith.comp) := sorry --non-trivial
lemma new_lemma_174679 (h0 : monoid (semigroup (finset linarith.comp))) : monoid.fg (semigroup (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_174680 (h0 : topological_space (complete_semilattice_Sup (random_gen num))) : totally_disconnected_space (complete_semilattice_Sup (random_gen num)) := sorry --non-trivial
lemma new_lemma_174681 (h0 : complete_lattice (with_one (random_gen fun_info))) : is_atomistic (with_one (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_174682 (h0 : topological_space (has_neg_part (has_add ennreal))) : loc_path_connected_space (has_neg_part (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_174683 (h0 : list (semigroup empty)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_174684 (h1 : topological_space (dlist (random_gen (random_gen char)))) : totally_disconnected_space (dlist (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_174685 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (with_bot.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (with_bot.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_174686 (h0 : functor.add_const (functor.add_const (functor.add_const Prop Type) Type) Type) : functor.add_const.run (functor.add_const.run (functor.add_const.run h0)) := sorry --non-trivial
lemma new_lemma_174687 (h0 : functor.add_const (add_monoid (add_group unsigned)) unsigned) : @add_monoid.fg.{0} (add_group.{0} unsigned) (@functor.add_const.run.{0 0} (add_monoid.{0} (add_group.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_174688 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : countable_Inter_filter (function.extfun_app (function.extfun_app h0 filter) (boolean_algebra real)) := sorry --non-trivial
lemma new_lemma_174689 (h0 : complete_lattice (partial_order (semiring unsigned))) : is_atomistic (partial_order (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_174690 (h0 : not (complete_lattice (has_ssubset linarith.ineq) -> false)) : @is_compactly_generated.{0} (has_ssubset.{0} linarith.ineq) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_ssubset.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_174691 (h0 : topological_space (has_Inf (has_add (sub_neg_monoid (has_bot pos))))) : t1_space (has_Inf (has_add (sub_neg_monoid (has_bot pos)))) := sorry --non-trivial
lemma new_lemma_174692 (h0 : topological_space (has_add (finset linarith.comp))) : discrete_topology (has_add (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_174693 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_union.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_union.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_174694 (h0 : function.extfun Type topological_space) : @normal_space.{0} (sub_neg_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (sub_neg_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_174695 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} h0 (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_174696 (h0 : has_mem.mem group has_emptyc.emptyc) : @is_cyclic.{0} (random_gen.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} h0) (random_gen.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_174697 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} (add_group.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (add_group.{0} num))  := sorry --non-trivial
lemma new_lemma_174698 (h0 : functor.add_const (function.extfun (Type 1) group) Type) : @group.fg.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) group.{1}) Type h0) (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_174699 (h0 : finset (semigroup empty)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_174700 (h0 : functor.add_const (semiring (has_add linarith.comp)) (has_add (has_neg pos))) : @is_noetherian_ring.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (semiring.{0} (has_add.{0} linarith.comp)) (has_add.{0} (has_neg.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_174701 (h0 : functor.add_const (ordered_comm_monoid (has_to_string unsigned)) (has_zero pos)) : @has_exists_mul_of_le.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_to_string.{0} unsigned)) (has_zero.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_174702 (h0 : fin has_zero.zero) : @unique_factorization_monoid.{0} (complete_distrib_lattice.{0} real) (@matrix.vec_empty.{0} (cancel_comm_monoid_with_zero.{0} (complete_distrib_lattice.{0} real)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)))))))  := sorry --non-trivial
lemma new_lemma_174703 (h0 : topological_space (ring (option empty))) : locally_compact_space (ring (option empty)) := sorry --non-trivial
lemma new_lemma_174704 (h0 : function.extfun Type group) : @group.fg.{0} (has_zero.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} h0 (has_zero.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_174705 (h0 : topological_space (has_compl fun_info)) : path_connected_space (has_compl fun_info) := sorry --non-trivial
lemma new_lemma_174706 (h0 : topological_space (semigroup (finset (finset (finset (finset (finset linarith.comp))))))) : preconnected_space (semigroup (finset (finset (finset (finset (finset linarith.comp)))))) := sorry --non-trivial
lemma new_lemma_174707 (h0 : list (add_cancel_monoid (has_add (has_add (has_add (has_add environment.implicit_infer_kind)))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_174708 (h0 : ring (comm_semigroup name)) : rank_condition (comm_semigroup name) := sorry --non-trivial
lemma new_lemma_174709 (h0 : add_group (simple_graph (mul_one_class ereal))) : is_add_cyclic (simple_graph (mul_one_class ereal)) := sorry --non-trivial
lemma new_lemma_174710 (h0 : topological_space (has_compl (random_gen (random_gen char)))) : locally_compact_space (has_compl (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_174711 (h0 : ring (normed_lattice_add_comm_group (has_neg name))) : rank_condition (normed_lattice_add_comm_group (has_neg name)) := sorry --non-trivial
lemma new_lemma_174712 (h0 : functor.add_const (topological_space (comm_group linarith.comp)) Type) : @totally_separated_space.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (comm_group.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_174713 (h0 : topological_space to_additive.value_type) (h1 : preorder to_additive.value_type) : order_closed_topology to_additive.value_type := sorry --non-trivial
lemma new_lemma_174714 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (with_one.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_one.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_174715 (h0 : uniform_space (has_nndist (option (option (option unsigned))))) : complete_space (has_nndist (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_174716 (h0 : not (topological_space (has_emptyc num) -> false)) : @t0_space.{0} (has_emptyc.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (has_emptyc.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_174717 (h1 : topological_space (add_comm_semigroup (semiring string.iterator_imp))) (h2 : add_group (add_comm_semigroup (semiring string.iterator_imp))) : topological_add_group (add_comm_semigroup (semiring string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_174718 (h0 : group (has_ssubset (random_gen linarith.comp_source))) : is_cyclic (has_ssubset (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_174719 (h0 : functor.add_const (topological_space (boolean_algebra unsigned)) (has_add environment.implicit_infer_kind)) : @discrete_topology.{0} (boolean_algebra.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} unsigned)) (has_add.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_174720 (h0 : functor.add_const (uniform_space (add_cancel_monoid pos)) name) : @complete_space.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (add_cancel_monoid.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_174721 (h1 : group (complete_semilattice_Sup congr_arg_kind)) : normalizer_condition (complete_semilattice_Sup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_174722 (h0 : functor.add_const (topological_space (has_zero pos)) (finset Type)) : @loc_path_connected_space.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_zero.{0} pos)) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_174723 (h0 : topological_space (has_nnnorm (has_nnnorm (random_gen (random_gen string.iterator_imp))))) : t0_space (has_nnnorm (has_nnnorm (random_gen (random_gen string.iterator_imp)))) := sorry --non-trivial
lemma new_lemma_174724 (h0 : ring empty) : rank_condition empty := sorry --non-trivial
lemma new_lemma_174725 (h0 : ring (comm_ring (has_ssubset fun_info))) : rank_condition (comm_ring (has_ssubset fun_info)) := sorry --non-trivial
lemma new_lemma_174726 (h3 : not (topological_space (with_one num) -> false)) : @totally_disconnected_space.{0} (with_one.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (with_one.{0} num)) h3)  := sorry --non-trivial
lemma new_lemma_174727 (h0 : group (mul_zero_class (has_to_string ennreal))) : group.fg (mul_zero_class (has_to_string ennreal)) := sorry --non-trivial
lemma new_lemma_174728 (h0 : functor.add_const (topological_space (has_Inf pos)) (has_neg Type)) : @sequential_space.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_Inf.{0} pos)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_174729 (h0 : topological_space (generalized_boolean_algebra real)) : t1_space (generalized_boolean_algebra real) := sorry --non-trivial
lemma new_lemma_174730 (h0 : cancel_comm_monoid_with_zero (add_semigroup (semiring (semiring (semiring empty))))) : unique_factorization_monoid (add_semigroup (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_174731 (h0 : add_group (has_neg_part (has_add name))) : is_add_cyclic (has_neg_part (has_add name)) := sorry --non-trivial
lemma new_lemma_174732 (h0 : has_mem.mem (normed_group linarith.comp) has_emptyc.emptyc) : filter.ne_bot (finset.pi.empty filter (normed_group linarith.comp) h0) := sorry --non-trivial
lemma new_lemma_174733 (h0 : functor.add_const (filter (finset unsigned)) ennreal) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_174734 (h0 : group (has_bot pos)) : group.fg (has_bot pos) := sorry --non-trivial
lemma new_lemma_174735 (h0 : not (group (semiring (random_gen linarith.ineq)) -> false)) : @group.fg.{0} (semiring.{0} (random_gen.{0} linarith.ineq)) (@classical.by_contradiction'.{1} (group.{0} (semiring.{0} (random_gen.{0} linarith.ineq))) h0)  := sorry --non-trivial
lemma new_lemma_174736 (h0 : topological_space (has_union empty)) : normal_space (has_union empty) := sorry --non-trivial
lemma new_lemma_174737 (h0 : topological_space (finset (boolean_algebra Type))) : loc_path_connected_space (finset (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_174738 (h0 : add_group (linear_ordered_add_comm_group linarith.comp_source)) : is_add_cyclic (linear_ordered_add_comm_group linarith.comp_source) := sorry --non-trivial
lemma new_lemma_174739 (h0 : topological_space (filter pos)) : sequential_space (filter pos) := sorry --non-trivial
lemma new_lemma_174740 (h0 : topological_space (add_cancel_monoid (option (option name)))) : preirreducible_space (add_cancel_monoid (option (option name))) := sorry --non-trivial
lemma new_lemma_174741 (h0 : complete_lattice (mul_zero_class environment.implicit_infer_kind)) : is_atomistic (mul_zero_class environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_174742 (h0 : function.extfun nat fin) : @unique_factorization_monoid.{0} (ordered_comm_monoid.{0} real) (@matrix.vec_empty.{0} (cancel_comm_monoid_with_zero.{0} (ordered_comm_monoid.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_174743 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (normed_comm_ring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_comm_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_174744 (h0 : topological_space (ring (has_Inf name))) : totally_separated_space (ring (has_Inf name)) := sorry --non-trivial
lemma new_lemma_174745 (h0 : filter (ordered_comm_ring (ring Type))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_174746 (h0 : filter (distrib (has_inv linarith.comp_source))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_174747 (h1 : add_group (comm_ring (comm_ring (comm_ring reducibility_hints)))) : is_add_cyclic (comm_ring (comm_ring (comm_ring reducibility_hints))) := sorry --non-trivial
lemma new_lemma_174748 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (boolean_algebra.core num)) := sorry --non-trivial
lemma new_lemma_174749 (h1 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_top.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (has_top.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_174750 (h0 : fin has_zero.zero) : @is_domain.{1} (generalized_boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (generalized_boolean_algebra.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_174751 (h0 : fin has_zero.zero) : @monoid.fg.{1} (boolean_algebra.core.{1} Type) (@matrix.vec_empty.{1} (monoid.{1} (boolean_algebra.core.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_174752 (h0 : topological_space (has_to_string (semigroup unsigned))) : regular_space (has_to_string (semigroup unsigned)) := sorry --non-trivial
lemma new_lemma_174753 (h0 : complete_lattice (has_div (pseudo_metric_space string.iterator_imp))) : is_compactly_generated (has_div (pseudo_metric_space string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_174754 (h0 : functor.add_const (finset (boolean_algebra environment.implicit_infer_kind)) name) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_174755 (h2 : ring (non_unital_non_assoc_semiring string.iterator_imp)) : rank_condition (non_unital_non_assoc_semiring string.iterator_imp) := sorry --non-trivial
lemma new_lemma_174756 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (monoid pos)) := sorry --non-trivial
lemma new_lemma_174757 (h0 : functor.add_const (functor.add_const (topological_space Type) pos) Type) : @totally_separated_space.{1} Type (@functor.add_const.run.{1 0} (topological_space.{1} Type) pos (@functor.add_const.run.{1 1} (functor.add_const.{1 0} (topological_space.{1} Type) pos) Type h0))  := sorry --non-trivial
lemma new_lemma_174758 (h0 : filter (semigroup (comm_group (comm_group (comm_group name))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_174759 (h0 : functor.add_const (finset (semigroup linarith.comp)) environment.implicit_infer_kind) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_174760 (h0 : cancel_comm_monoid_with_zero (plift (semiring num))) : unique_factorization_monoid (plift (semiring num)) := sorry --non-trivial
lemma new_lemma_174761 (h0 : not (topological_space (complete_semilattice_Sup linarith.comp_source) -> false)) : @totally_disconnected_space.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (complete_semilattice_Sup.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_174762 (h0 : complete_lattice (has_Sup unsigned)) : complete_lattice.is_Sup_finite_compact (has_Sup unsigned) := sorry --non-trivial
lemma new_lemma_174763 (h0 : topological_space (has_to_string (ring environment.implicit_infer_kind))) : preirreducible_space (has_to_string (ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_174764 (h0 : measurable_space (add_comm_semigroup std_gen)) (h1 : set (add_comm_semigroup std_gen)) : measurable_set h1 := sorry --non-trivial
lemma new_lemma_174765 (h0 : function.extfun Type topological_space) : @regular_space.{0} (has_to_string.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_174766 (h0 : function.extfun Type group) : @is_simple_group.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (has_neg_part.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_174767 (h0 : topological_space (generalized_boolean_algebra (has_Inf name))) : topological_space.separable_space (generalized_boolean_algebra (has_Inf name)) := sorry --non-trivial
lemma new_lemma_174768 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (has_norm.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_norm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_174769 (h0 : ordered_add_comm_monoid (has_bot real)) : archimedean (has_bot real) := sorry --non-trivial
lemma new_lemma_174770 (h0 : cancel_comm_monoid_with_zero (omega_complete_partial_order (semiring (semiring empty)))) : unique_factorization_monoid (omega_complete_partial_order (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_174771 (h0 : functor.add_const (function.extfun (Type 1) group) environment.implicit_infer_kind) : @group.fg.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) group.{1}) environment.implicit_infer_kind h0) (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_174772 (h0 : function.extfun (finset Type) (has_mem.mem (complete_semilattice_Sup fun_info))) : @path_connected_space.{0} (complete_semilattice_Sup.{0} fun_info) (@finset.pi.empty.{1 0} Type topological_space.{0} (complete_semilattice_Sup.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (complete_semilattice_Sup.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_174773 (h0 : complete_lattice (has_to_string ennreal)) : is_compactly_generated (has_to_string ennreal) := sorry --non-trivial
lemma new_lemma_174774 (h0 : functor.add_const (ring (has_star num)) num) : @strong_rank_condition.{0} (has_star.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (has_star.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_174775 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (finset.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (finset.{0} name))  := sorry --non-trivial
lemma new_lemma_174776 (h0 : topological_space (complete_distrib_lattice (has_add pos))) : preconnected_space (complete_distrib_lattice (has_add pos)) := sorry --non-trivial
lemma new_lemma_174777 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (as_linear_order unsigned)) := sorry --non-trivial
lemma new_lemma_174778 (h0 : function.extfun (finset Type) (has_mem.mem (metric_space linarith.comp))) : @normal_space.{0} (metric_space.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (metric_space.{0} linarith.comp) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (metric_space.{0} linarith.comp)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_174779 (h0 : ring (has_append (has_nnnorm linarith.ineq))) : is_domain (has_append (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_174780 (h0 : functor.add_const (topological_space (normed_comm_ring unsigned)) environment.implicit_infer_kind) : @preconnected_space.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_174781 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (linear_ordered_field.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (linear_ordered_field.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_174782 (h0 : ring (has_to_string ennreal)) : strong_rank_condition (has_to_string ennreal) := sorry --non-trivial
lemma new_lemma_174783 (h0 : topological_space (random_gen (random_gen (random_gen (random_gen linarith.comp_source))))) : path_connected_space (random_gen (random_gen (random_gen (random_gen linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_174784 (h0 : fin has_zero.zero) : @is_atomistic.{0} (ordered_comm_ring.{0} real) (@matrix.vec_empty.{0} (complete_lattice.{0} (ordered_comm_ring.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_174785 (h0 : functor.comp group comm_group name) : @group.fg.{0} (comm_group.{0} name) (@functor.comp.run.{0 0 0} group.{0} comm_group.{0} name h0)  := sorry --non-trivial
lemma new_lemma_174786 (h0 : semiring (ordered_ring unsigned)) : is_noetherian_ring (ordered_ring unsigned) := sorry --non-trivial
lemma new_lemma_174787 (h0 : functor.add_const (complete_lattice (add_comm_monoid unsigned)) name) : @is_compactly_generated.{0} (add_comm_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_comm_monoid.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_174788 (h0 : functor.add_const (add_monoid (semiring num)) num) : @add_monoid.fg.{0} (semiring.{0} num) (@functor.add_const.run.{0 0} (add_monoid.{0} (semiring.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_174789 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @totally_disconnected_space.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_174790 (h0 : topological_space (finset empty)) : locally_compact_space (finset empty) := sorry --non-trivial
lemma new_lemma_174791 (h0 : complete_lattice (add_cancel_monoid (normed_comm_ring Type))) : is_compactly_generated (add_cancel_monoid (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_174792 (h0 : topological_space (ring (mul_one_class Type))) : totally_disconnected_space (ring (mul_one_class Type)) := sorry --non-trivial
lemma new_lemma_174793 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (canonically_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (canonically_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_174794 (h0 : group (with_bot (has_top (random_gen unsigned)))) : group.fg (with_bot (has_top (random_gen unsigned))) := sorry --non-trivial
lemma new_lemma_174795 (h0 : filter (has_nndist (finset (finset pos)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_174796 (h0 : complete_lattice (has_nndist (semigroup name))) : complete_lattice.is_Sup_finite_compact (has_nndist (semigroup name)) := sorry --non-trivial
lemma new_lemma_174797 (h0 : topological_space (complete_distrib_lattice (has_neg Type))) : path_connected_space (complete_distrib_lattice (has_neg Type)) := sorry --non-trivial
lemma new_lemma_174798 (h0 : topological_space (has_pos_part (has_neg (has_neg (has_neg name))))) : regular_space (has_pos_part (has_neg (has_neg (has_neg name)))) := sorry --non-trivial
lemma new_lemma_174799 (h0 : topological_space (semiring (random_gen fun_info))) : path_connected_space (semiring (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_174800 (h0 : group (with_one (has_top (random_gen (has_ssubset to_additive.value_type))))) : group.fg (with_one (has_top (random_gen (has_ssubset to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_174801 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} to_additive.value_type (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 to_additive.value_type)  := sorry --non-trivial
lemma new_lemma_174802 (h1 : has_le (add_comm_semigroup fun_info)) (h2 : bounded_order (add_comm_semigroup fun_info)) : is_simple_order (add_comm_semigroup fun_info) := sorry --non-trivial
lemma new_lemma_174803 (h0 : functor.add_const (list (ring Type)) pos) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_174804 (h0 : set (has_nnnorm (mul_one_class (mul_one_class to_additive.value_type)))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_174805 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (@id.{2} Type to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (@id.{2} Type to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_174806 (h0 : topological_space (canonically_linear_ordered_monoid (mul_zero_class name))) : locally_compact_space (canonically_linear_ordered_monoid (mul_zero_class name)) := sorry --non-trivial
lemma new_lemma_174807 (h0 : group string.iterator_imp) (h1 : topological_space (group_topology string.iterator_imp)) : t0_space (group_topology string.iterator_imp) := sorry --non-trivial
lemma new_lemma_174808 (h0 : functor.add_const (topological_space (has_Inf pos)) pos) : @irreducible_space.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_174809 (h0 : uniform_space (simple_graph (has_Inf Type))) : separated_space (simple_graph (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_174810 (h0 : functor.add_const (topological_space (comm_group pos)) pos) : @regular_space.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_174811 (h0 : topological_space (semi_normed_comm_ring (mul_one_class char))) (h1 : add_group (semi_normed_comm_ring (mul_one_class char))) : topological_add_group (semi_normed_comm_ring (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_174812 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (linear_ordered_comm_group.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_174813 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_inter.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_inter.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_174814 (h0 : topological_space (id (random_gen (has_inv fun_info)))) : locally_compact_space (id (random_gen (has_inv fun_info))) := sorry --non-trivial
lemma new_lemma_174815 (h0 : fin has_zero.zero) : @is_domain.{1} (has_add.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (has_add.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_174816 (h0 : not (topological_space (add_right_cancel_monoid empty) -> false)) : @totally_disconnected_space.{0} (add_right_cancel_monoid.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (add_right_cancel_monoid.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_174817 (h0 : function.extfun Type ring) : @rank_condition.{0} (pseudo_metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (pseudo_metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_174818 (h0 : fin has_zero.zero) : @unique_factorization_monoid.{0} (simple_graph.{0} (ring.{0} (ring.{0} linarith.comp))) (@matrix.vec_empty.{0} (cancel_comm_monoid_with_zero.{0} (simple_graph.{0} (ring.{0} (ring.{0} linarith.comp)))) h0)  := sorry --non-trivial
lemma new_lemma_174819 (h0 : functor.add_const Prop (canonically_linear_ordered_monoid congr_arg_kind)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_174820 (h0 : topological_space (bin_tree congr_arg_kind)) : discrete_topology (bin_tree congr_arg_kind) := sorry --non-trivial
lemma new_lemma_174821 (h1 : set (add_comm_semigroup (mul_one_class linarith.ineq))) : set.finite h1 := sorry --non-trivial
lemma new_lemma_174822 (h0 : uniform_space (distrib (has_compl string_imp))) : complete_space (distrib (has_compl string_imp)) := sorry --non-trivial
lemma new_lemma_174823 (h0 : topological_space (simple_graph (has_pos_part pos))) : preirreducible_space (simple_graph (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_174824 (h0 : functor.add_const (cancel_comm_monoid_with_zero (boolean_algebra Type)) Type) : @unique_factorization_monoid.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 1} (cancel_comm_monoid_with_zero.{1} (boolean_algebra.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_174825 (h0 : functor.add_const (topological_space (has_Sup empty)) empty) : @loc_path_connected_space.{0} (has_Sup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Sup.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_174826 (h0 : complete_lattice (ring ennreal)) : is_compactly_generated (ring ennreal) := sorry --non-trivial
lemma new_lemma_174827 (h0 : ring (has_compl (random_gen (has_compl char)))) : rank_condition (has_compl (random_gen (has_compl char))) := sorry --non-trivial
lemma new_lemma_174828 (h0 : functor.add_const (finset (has_dist congr_arg_kind)) congr_arg_kind) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_174829 (h0 : topological_space (has_Inf (has_add (has_add pos)))) : locally_compact_space (has_Inf (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_174830 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (normed_group.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (normed_group.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_174831 (h0 : ring (linear_ordered_comm_ring (semiring (semiring (semiring empty))))) : is_domain (linear_ordered_comm_ring (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_174832 (h0 : complete_lattice (comm_group (option (option pos)))) : is_atomistic (comm_group (option (option pos))) := sorry --non-trivial
lemma new_lemma_174833 (h0 : topological_space (has_neg_part ennreal)) : preconnected_space (has_neg_part ennreal) := sorry --non-trivial
lemma new_lemma_174834 (h0 : functor.add_const (topological_space (left_cancel_monoid unsigned)) empty) : @totally_separated_space.{0} (left_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_174835 (h0 : topological_space (has_Sup (option unsigned))) : discrete_topology (has_Sup (option unsigned)) := sorry --non-trivial
lemma new_lemma_174836 (h2 : uniform_space (complete_semilattice_Sup congr_arg_kind)) : complete_space (complete_semilattice_Sup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_174837 (h1 : uniform_space (has_emptyc congr_arg_kind)) : complete_space (has_emptyc congr_arg_kind) := sorry --non-trivial
lemma new_lemma_174838 (h0 : topological_space (has_Inf (has_Inf linarith.comp))) : t0_space (has_Inf (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_174839 (h0 : not (complete_lattice (add_monoid (has_nnnorm fun_info)) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (add_monoid.{0} (has_nnnorm.{0} fun_info)) (@classical.by_contradiction'.{1} (complete_lattice.{0} (add_monoid.{0} (has_nnnorm.{0} fun_info))) h0)  := sorry --non-trivial
lemma new_lemma_174840 (h0 : functor.add_const (list (left_cancel_monoid unsigned)) num) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_174841 (h0 : filter (has_one (semiring (semiring (semiring (has_norm congr_arg_kind)))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_174842 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_to_string.{0} (option.{0} (option.{0} pos))) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_to_string.{0} (option.{0} (option.{0} pos))))  := sorry --non-trivial
lemma new_lemma_174843 (h0 : functor.add_const (complete_lattice znum) empty) : @complete_lattice.is_Sup_finite_compact.{0} znum (@functor.add_const.run.{0 0} (complete_lattice.{0} znum) empty h0)  := sorry --non-trivial
lemma new_lemma_174844 (h0 : monoid (has_top congr_arg_kind)) : monoid.fg (has_top congr_arg_kind) := sorry --non-trivial
lemma new_lemma_174845 (h0 : complete_lattice (semi_normed_ring (mul_one_class reducibility_hints))) : is_compactly_generated (semi_normed_ring (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_174846 (h0 : topological_space (has_zero unsigned)) : irreducible_space (has_zero unsigned) := sorry --non-trivial
lemma new_lemma_174847 (h0 : uniform_space (random_gen (measurable_space string_imp))) : complete_space (random_gen (measurable_space string_imp)) := sorry --non-trivial
lemma new_lemma_174848 (h0 : complete_lattice (has_star (option unsigned))) : complete_lattice.is_Sup_finite_compact (has_star (option unsigned)) := sorry --non-trivial
lemma new_lemma_174849 (h0 : list (has_zero (finset pos))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_174850 (h0 : topological_space (topological_space (has_nnnorm linarith.comp_source))) : totally_disconnected_space (topological_space (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_174851 (h0 : topological_space (boolean_algebra.core (has_neg unsigned))) : loc_path_connected_space (boolean_algebra.core (has_neg unsigned)) := sorry --non-trivial
lemma new_lemma_174852 (h0 : functor.add_const (function.extfun (Type 1) add_monoid) Type) : @add_monoid.fg.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_monoid.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) add_monoid.{1}) Type h0) (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_174853 (h0 : ring (distrib (has_append (has_append linarith.ineq)))) : is_domain (distrib (has_append (has_append linarith.ineq))) := sorry --non-trivial
lemma new_lemma_174854 (h0 : topological_space (ordered_comm_monoid (has_add Type))) : t0_space (ordered_comm_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_174855 (h0 : topological_space (simple_graph empty)) : preconnected_space (simple_graph empty) := sorry --non-trivial
lemma new_lemma_174856 (h1 : semiring (add_comm_semigroup std_gen)) (h2 : ideal (add_comm_semigroup std_gen)) : ideal.is_prime h2 := sorry --non-trivial
lemma new_lemma_174857 (h0 : function.extfun (Type 1) ring) : @rank_condition.{1} (has_neg_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (has_neg_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_174858 (h0 : topological_space (linear_ordered_add_comm_group (random_gen linarith.comp_source))) : locally_compact_space (linear_ordered_add_comm_group (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_174859 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_Inf.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_Inf.{0} name))  := sorry --non-trivial
lemma new_lemma_174860 (h0 : functor.add_const (topological_space (finset linarith.comp)) environment.implicit_infer_kind) : @loc_path_connected_space.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_174861 (h0 : functor.add_const (group (has_zero Type)) (has_neg_part environment.implicit_infer_kind)) : @is_cyclic.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (has_zero.{1} Type)) (has_neg_part.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_174862 (h0 : ordered_comm_monoid (ordered_comm_monoid (has_neg (has_Inf linarith.comp)))) : has_exists_mul_of_le (ordered_comm_monoid (has_neg (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_174863 (h0 : complete_lattice (has_zero (normed_comm_ring linarith.comp))) : is_compactly_generated (has_zero (normed_comm_ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_174864 (h0 : has_lt (add_comm_semigroup (add_comm_semigroup (mul_one_class enat)))) : no_max_order (add_comm_semigroup (add_comm_semigroup (mul_one_class enat))) := sorry --non-trivial
lemma new_lemma_174865 (h1 : not (ring (fintype char) -> false)) : @rank_condition.{0} (fintype.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (fintype.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_174866 (h0 : topological_space (has_compl (random_gen to_additive.value_type))) : locally_compact_space (has_compl (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_174867 (h0 : functor.add_const (topological_space (has_nndist pos)) (finset pos)) : @topological_space.separable_space.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} pos)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_174868 (h0 : semiring (has_Inf (has_Inf name))) : is_noetherian_ring (has_Inf (has_Inf name)) := sorry --non-trivial
lemma new_lemma_174869 (h0 : topological_space (has_inter empty)) : loc_path_connected_space (has_inter empty) := sorry --non-trivial
lemma new_lemma_174870 (h0 : topological_space (has_zero (has_neg_part name))) : loc_path_connected_space (has_zero (has_neg_part name)) := sorry --non-trivial
lemma new_lemma_174871 (h0 : topological_space (comm_monoid (option unsigned))) : loc_path_connected_space (comm_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_174872 (h0 : topological_space (finset (finset environment.implicit_infer_kind))) : locally_compact_space (finset (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_174873 (h0 : not (topological_space (with_bot linarith.ineq) -> false)) : @irreducible_space.{0} (with_bot.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (with_bot.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_174874 (h0 : topological_space (cancel_monoid congr_arg_kind)) : discrete_topology (cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_174875 (h0 : ring (simple_graph (mul_one_class string.iterator_imp))) : strong_rank_condition (simple_graph (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_174876 (h0 : functor.add_const (topological_space (add_cancel_monoid name)) pos) : @totally_separated_space.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_174877 (h0 : functor.add_const (topological_space (ordered_ring unsigned)) (semiring num)) : @t1_space.{0} (ordered_ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} unsigned)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_174878 (h0 : topological_space (cancel_monoid ennreal)) : loc_path_connected_space (cancel_monoid ennreal) := sorry --non-trivial
lemma new_lemma_174879 (h0 : topological_space (has_add (has_Inf (boolean_algebra real)))) : totally_disconnected_space (has_add (has_Inf (boolean_algebra real))) := sorry --non-trivial
lemma new_lemma_174880 (h0 : not (ring (random_gen congr_arg_kind) -> false)) : @strong_rank_condition.{0} (random_gen.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (ring.{0} (random_gen.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_174881 (h0 : ring (has_top (comm_ring linarith.ineq))) : is_domain (has_top (comm_ring linarith.ineq)) := sorry --non-trivial
lemma new_lemma_174882 (h0 : complete_lattice (random_gen congr_arg_kind)) : is_atomistic (random_gen congr_arg_kind) := sorry --non-trivial
lemma new_lemma_174883 (h0 : filter (boolean_algebra.core (option name))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_174884 (h0 : functor.add_const (group (boolean_algebra.core pos)) name) : @is_cyclic.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.core.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_174885 (h0 : functor.add_const (topological_space (option congr_arg_kind)) unsigned) : @totally_disconnected_space.{0} (option.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_174886 (h0 : topological_space (cancel_monoid (option congr_arg_kind))) : path_connected_space (cancel_monoid (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_174887 (h0 : group (comm_group (semigroup (comm_group environment.implicit_infer_kind)))) : group.fg (comm_group (semigroup (comm_group environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_174888 (h0 : order_hom nat (topological_space (topological_space reducibility_hints))) : @t0_space.{0} (topological_space.{0} reducibility_hints) (@monotonic_sequence_limit.{0} (topological_space.{0} (topological_space.{0} reducibility_hints)) (@topological_space.partial_order.{0} (topological_space.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_174889 (h0 : topological_space (normed_field (has_ssubset string_imp))) : totally_disconnected_space (normed_field (has_ssubset string_imp)) := sorry --non-trivial
lemma new_lemma_174890 (h0 : topological_space (option (option ennreal))) : preirreducible_space (option (option ennreal)) := sorry --non-trivial
lemma new_lemma_174891 (h0 : functor.add_const (group (plift empty)) (option empty)) : @normalizer_condition.{1} (plift.{1} empty) (@functor.add_const.run.{1 0} (group.{1} (plift.{1} empty)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_174892 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (canonically_linear_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_linear_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_174893 (h0 : topological_space (id (has_inv (random_gen linarith.comp_source)))) : locally_compact_space (id (has_inv (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_174894 (h0 : list (has_nndist (has_Inf linarith.comp))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_174895 (h0 : topological_space (id (random_gen congr_arg_kind))) : totally_disconnected_space (id (random_gen congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_174896 (h0 : functor.add_const (complete_lattice (semigroup name)) linarith.comp) : @is_compactly_generated.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (semigroup.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_174897 (h0 : add_group (ordered_comm_group num)) : is_add_cyclic (ordered_comm_group num) := sorry --non-trivial
lemma new_lemma_174898 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_174899 (h0 : topological_space (has_zero name)) : t0_space (has_zero name) := sorry --non-trivial
lemma new_lemma_174900 (h0 : uniform_space (add_cancel_monoid (option empty))) : separated_space (add_cancel_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_174901 (h0 : filter (has_one (semiring (semiring (semiring (semiring (semiring linarith.comp))))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_174902 (h0 : group (has_append (mul_one_class fun_info))) : is_cyclic (has_append (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_174903 (h0 : list (finset (boolean_algebra linarith.comp))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_174904 (h0 : topological_space (normed_comm_ring (has_nndist environment.implicit_infer_kind))) : totally_separated_space (normed_comm_ring (has_nndist environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_174905 (h0 : set (mul_one_class (mul_one_class (mul_one_class ereal)) -> std_gen)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_174906 (h0 : functor.add_const (semiring (ordered_comm_monoid pos)) pos) : @is_noetherian_ring.{0} (ordered_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (semiring.{0} (ordered_comm_monoid.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_174907 (h0 : group (canonically_ordered_comm_semiring (option unsigned))) : is_simple_group (canonically_ordered_comm_semiring (option unsigned)) := sorry --non-trivial
lemma new_lemma_174908 (h0 : not (functor.comp add_monoid measure_theory.measure_space (semiring unsigned) -> false)) : @add_monoid.fg.{0} (measure_theory.measure_space.{0} (semiring.{0} unsigned)) (@functor.comp.run.{0 0 0} add_monoid.{0} measure_theory.measure_space.{0} (semiring.{0} unsigned) (@classical.by_contradiction'.{1} (functor.comp.{0 0 0} add_monoid.{0} measure_theory.measure_space.{0} (semiring.{0} unsigned)) h0))  := sorry --non-trivial
lemma new_lemma_174909 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (has_sub.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} h0 (has_sub.{0} empty))  := sorry --non-trivial
lemma new_lemma_174910 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_simple_group.{0} (ordered_cancel_add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (ordered_cancel_add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_174911 (h0 : topological_space (semiring (random_gen (random_gen linarith.comp_source)))) : locally_compact_space (semiring (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_174912 (h2 : topological_space char) : t0_space char := sorry --non-trivial
lemma new_lemma_174913 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_norm.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_norm.{0} empty))  := sorry --non-trivial
lemma new_lemma_174914 (h0 : topological_space (complete_distrib_lattice (has_pos_part (has_add linarith.comp)))) : topological_space.separable_space (complete_distrib_lattice (has_pos_part (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_174915 (h0 : complete_lattice (canonically_ordered_monoid (has_neg name))) : is_atomistic (canonically_ordered_monoid (has_neg name)) := sorry --non-trivial
lemma new_lemma_174916 (h0 : functor.add_const (monoid (complete_distrib_lattice environment.implicit_infer_kind)) (comm_group linarith.comp)) : @monoid.fg.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (monoid.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind)) (comm_group.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_174917 (h0 : ring (finset (has_to_string (has_nndist linarith.comp)))) : rank_condition (finset (has_to_string (has_nndist linarith.comp))) := sorry --non-trivial
lemma new_lemma_174918 (h0 : ring (has_nndist (has_neg_part (has_neg pos)))) : rank_condition (has_nndist (has_neg_part (has_neg pos))) := sorry --non-trivial
lemma new_lemma_174919 (h0 : topological_space (add_semigroup (option unsigned))) : preirreducible_space (add_semigroup (option unsigned)) := sorry --non-trivial
lemma new_lemma_174920 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_nndist.{0} name) (@function.extfun_app.{2 1} Type group.{0} h0 (has_nndist.{0} name))  := sorry --non-trivial
lemma new_lemma_174921 (h0 : group (has_neg (normed_comm_ring pos))) : is_cyclic (has_neg (normed_comm_ring pos)) := sorry --non-trivial
lemma new_lemma_174922 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (ordered_comm_ring.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_ring.{0} real))  := sorry --non-trivial
lemma new_lemma_174923 (h0 : topological_space (has_to_string (has_to_string congr_arg_kind))) : irreducible_space (has_to_string (has_to_string congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_174924 (h0 : add_monoid (complete_distrib_lattice (option (option congr_arg_kind)))) : add_monoid.fg (complete_distrib_lattice (option (option congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_174925 (h0 : topological_space (has_neg Type)) : irreducible_space (has_neg Type) := sorry --non-trivial
lemma new_lemma_174926 (h0 : topological_space (sub_neg_monoid (has_Inf pos))) : path_connected_space (sub_neg_monoid (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_174927 (h0 : not (topological_space (metric_space empty) -> false)) : @path_connected_space.{0} (metric_space.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (metric_space.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_174928 (h0 : semiring (has_dist num)) : is_noetherian_ring (has_dist num) := sorry --non-trivial
lemma new_lemma_174929 (h0 : functor.add_const (filter (has_Sup unsigned)) empty) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_174930 (h0 : ordered_add_comm_monoid (has_pos_part (ring Type))) : archimedean (has_pos_part (ring Type)) := sorry --non-trivial
lemma new_lemma_174931 (h0 : group (normed_comm_ring (has_inter ennreal))) : is_simple_group (normed_comm_ring (has_inter ennreal)) := sorry --non-trivial
lemma new_lemma_174932 (h0 : filter (linear_ordered_add_comm_group (random_gen (has_norm (has_inv (has_norm linarith.ineq)))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_174933 (h0 : functor.add_const (topological_space (ordered_ring unsigned)) unsigned) : @totally_separated_space.{0} (ordered_ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_174934 (h0 : functor.add_const (uniform_space (has_zero Type)) linarith.comp) : @separated_space.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (has_zero.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_174935 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_sub.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_sub.{0} empty))  := sorry --non-trivial
lemma new_lemma_174936 (h0 : ring (has_to_string (has_add (has_add unsigned)))) : is_principal_ideal_ring (has_to_string (has_add (has_add unsigned))) := sorry --non-trivial
lemma new_lemma_174937 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (with_one.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (with_one.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_174938 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (ordered_comm_monoid.{0} real) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (ordered_comm_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_174939 (h2 : set (enat -> fun_info)) : set.separates_points h2 := sorry --non-trivial
lemma new_lemma_174940 (h0 : has_le (has_ssubset (mul_one_class reducibility_hints))) (h1 : bounded_order (has_ssubset (mul_one_class reducibility_hints))) : is_simple_order (has_ssubset (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_174941 (h0 : functor.add_const (topological_space (has_to_string name)) (comm_group Type)) : @normal_space.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (has_to_string.{0} name)) (comm_group.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_174942 (h0 : list (has_neg (boolean_algebra pos))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_174943 (h0 : ring (finset (has_neg (has_neg (has_Inf (has_neg Type)))))) : is_principal_ideal_ring (finset (has_neg (has_neg (has_Inf (has_neg Type))))) := sorry --non-trivial
lemma new_lemma_174944 (h0 : uniform_space (uniform_space (mul_one_class (mul_one_class linarith.ineq)))) : complete_space (uniform_space (mul_one_class (mul_one_class linarith.ineq))) := sorry --non-trivial
lemma new_lemma_174945 (h0 : complete_lattice (semigroup (has_add name))) : is_atomistic (semigroup (has_add name)) := sorry --non-trivial
lemma new_lemma_174946 (h0 : fin has_zero.zero) : @monoid.fg.{0} (ordered_comm_monoid.{0} name) (@matrix.vec_empty.{0} (monoid.{0} (ordered_comm_monoid.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_174947 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_Inf pos)) pos) : @unique_factorization_monoid.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_Inf.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_174948 (h0 : group (fintype linarith.comp_source)) : is_cyclic (fintype linarith.comp_source) := sorry --non-trivial
lemma new_lemma_174949 (h0 : topological_space (ordered_comm_ring (has_Inf pos))) : discrete_topology (ordered_comm_ring (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_174950 (h0 : uniform_space (boolean_algebra.core (has_pos_part name))) : complete_space (boolean_algebra.core (has_pos_part name)) := sorry --non-trivial
lemma new_lemma_174951 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (semiring.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_174952 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (option ennreal)) := sorry --non-trivial
lemma new_lemma_174953 (h0 : function.extfun Type (functor.add_const (topological_space (ring pos)))) : @irreducible_space.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} pos)) pos (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (ring.{0} pos))) h0 pos))  := sorry --non-trivial
lemma new_lemma_174954 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (measure_theory.measure_space.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (measure_theory.measure_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_174955 (h0 : functor.add_const (ordered_comm_monoid (mul_zero_class Type)) unsigned) : @has_exists_mul_of_le.{1} (mul_zero_class.{1} Type) (@functor.add_const.run.{1 0} (ordered_comm_monoid.{1} (mul_zero_class.{1} Type)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_174956 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_cyclic.{1} (boolean_algebra.core.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 group.{1}) (boolean_algebra.core.{1} Type))  := sorry --non-trivial
lemma new_lemma_174957 (h0 : not (semiring (measurable_space.dynkin_system num) -> false)) : @is_noetherian_ring.{0} (measurable_space.dynkin_system.{0} num) (@classical.by_contradiction'.{1} (semiring.{0} (measurable_space.dynkin_system.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_174958 (h0 : topological_space (mul_one_class enat)) (h1 : add_group (mul_one_class enat)) : topological_add_group (mul_one_class enat) := sorry --non-trivial
lemma new_lemma_174959 (h0 : functor.add_const (topological_space (left_cancel_semigroup unsigned)) unsigned) : @irreducible_space.{0} (left_cancel_semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_semigroup.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_174960 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type monoid.{0} h0 (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_174961 (h1 : group (comm_ring (random_gen linarith.comp_source))) : is_cyclic (comm_ring (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_174962 (h0 : function.extfun Type (functor.add_const (ring (canonically_ordered_comm_semiring ennreal)))) : @is_principal_ideal_ring.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@functor.add_const.run.{0 0} (ring.{0} (canonically_ordered_comm_semiring.{0} ennreal)) name (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} (canonically_ordered_comm_semiring.{0} ennreal))) h0 name))  := sorry --non-trivial
lemma new_lemma_174963 (h0 : topological_space (random_gen (semiring empty))) : preirreducible_space (random_gen (semiring empty)) := sorry --non-trivial
lemma new_lemma_174964 (h0 : topological_space (random_gen (has_top num))) : normal_space (random_gen (has_top num)) := sorry --non-trivial
lemma new_lemma_174965 (h0 : functor.add_const (group (semigroup pos)) Type) : @is_cyclic.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (semigroup.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_174966 (h0 : functor.add_const (topological_space (simple_graph pos)) name) : @normal_space.{0} (simple_graph.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (simple_graph.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_174967 (h0 : functor.add_const (uniform_space (generalized_boolean_algebra Type)) (ring pos)) : @separated_space.{1} (generalized_boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (generalized_boolean_algebra.{1} Type)) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_174968 (h0 : functor.add_const (topological_space (boolean_algebra Type)) (has_neg Type)) : @totally_separated_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (boolean_algebra.{1} Type)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_174969 (h0 : complete_lattice (non_unital_non_assoc_semiring linarith.ineq)) : is_compactly_generated (non_unital_non_assoc_semiring linarith.ineq) := sorry --non-trivial
lemma new_lemma_174970 (h0 : function.extfun nat fin) : @preirreducible_space.{0} (boolean_algebra.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (boolean_algebra.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_174971 (h0 : functor.add_const (function.extfun Type topological_space) (has_pos_part linarith.comp)) : @discrete_topology.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (has_pos_part.{0} linarith.comp) h0) (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_174972 (h0 : functor.add_const (topological_space (normed_comm_ring pos)) name) : @locally_compact_space.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_174973 (h0 : group (complete_semilattice_Sup (has_norm empty))) : normalizer_condition (complete_semilattice_Sup (has_norm empty)) := sorry --non-trivial
lemma new_lemma_174974 (h0 : not (topological_space (simple_graph linarith.comp_source) -> false)) : @path_connected_space.{0} (simple_graph.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (simple_graph.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_174975 (h0 : functor.add_const (ring (mul_zero_class num)) unsigned) : @strong_rank_condition.{0} (mul_zero_class.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (mul_zero_class.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_174976 (h0 : ring (has_union fun_info)) : rank_condition (has_union fun_info) := sorry --non-trivial
lemma new_lemma_174977 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (sub_neg_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (sub_neg_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_174978 (h0 : functor.add_const (monoid (boolean_algebra linarith.comp)) environment.implicit_infer_kind) : @monoid.fg.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (monoid.{0} (boolean_algebra.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_174979 (h0 : ring (measure_theory.measure_space empty)) : rank_condition (measure_theory.measure_space empty) := sorry --non-trivial
lemma new_lemma_174980 (h5 : ring (normed_field (random_gen to_additive.value_type))) : rank_condition (normed_field (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_174981 (h0 : ring (metric_space (has_top (canonically_linear_ordered_monoid congr_arg_kind)))) : is_domain (metric_space (has_top (canonically_linear_ordered_monoid congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_174982 (h0 : functor.add_const (ring (has_add pos)) name) : @is_domain.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_add.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_174983 (h0 : topological_space (random_gen (random_gen num))) : discrete_topology (random_gen (random_gen num)) := sorry --non-trivial
lemma new_lemma_174984 (h0 : functor.add_const (monoid (comm_group pos)) Type) : @monoid.fg.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 1} (monoid.{0} (comm_group.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_174985 (h0 : uniform_space (ordered_comm_monoid (has_nndist (has_nndist (has_nndist name))))) : separated_space (ordered_comm_monoid (has_nndist (has_nndist (has_nndist name)))) := sorry --non-trivial
lemma new_lemma_174986 (h0 : monoid (semiring (has_norm fun_info))) : monoid.fg (semiring (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_174987 (h0 : not (complete_lattice (random_gen to_additive.value_type) -> false)) : @is_atomistic.{0} (random_gen.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (complete_lattice.{0} (random_gen.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_174988 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (with_bot.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (with_bot.{0} empty))  := sorry --non-trivial
lemma new_lemma_174989 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @t0_space.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_174990 (h0 : ring (ring (ring linarith.comp))) : is_domain (ring (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_174991 (h0 : ring (has_ssubset (mul_one_class (mul_one_class nat)))) : rank_condition (has_ssubset (mul_one_class (mul_one_class nat))) := sorry --non-trivial
lemma new_lemma_174992 (h0 : ring (non_unital_non_assoc_semiring (random_gen linarith.ineq))) : rank_condition (non_unital_non_assoc_semiring (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_174993 (h1 : filter (div_inv_monoid (has_nnnorm string_imp))) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_174994 (h0 : ring (normed_linear_ordered_group congr_arg_kind)) : rank_condition (normed_linear_ordered_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_174995 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_174996 (h0 : ring (distrib_lattice (has_nnnorm (has_nnnorm linarith.ineq)))) : is_domain (distrib_lattice (has_nnnorm (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_174997 (h0 : complete_lattice (normed_field (has_nnnorm (has_nnnorm (has_nnnorm (random_gen char)))))) : is_compactly_generated (normed_field (has_nnnorm (has_nnnorm (has_nnnorm (random_gen char))))) := sorry --non-trivial
lemma new_lemma_174998 (h1 : ring (has_append (has_nnnorm (random_gen linarith.comp_source)))) : rank_condition (has_append (has_nnnorm (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_174999 (h0 : topological_space (sub_neg_monoid (has_neg name))) : t0_space (sub_neg_monoid (has_neg name)) := sorry --non-trivial
lemma new_lemma_175000 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (mul_zero_class.{0} name) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (mul_zero_class.{0} name))  := sorry --non-trivial
lemma new_lemma_175001 (h0 : set (linear_ordered_comm_group_with_zero (mul_one_class linarith.ineq))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_175002 (h0 : add_group (has_div (uniform_space string.iterator_imp))) : is_add_cyclic (has_div (uniform_space string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_175003 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (linear_ordered_add_comm_group.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type monoid.{0} h0 (linear_ordered_add_comm_group.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_175004 (h0 : filter (encodable (has_inv (has_nnnorm linarith.ineq)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_175005 (h0 : topological_space enat) (h1 : preorder enat) : order_topology enat := sorry --non-trivial
lemma new_lemma_175006 (h0 : function.extfun Type topological_space) : @normal_space.{0} (measure_theory.measure_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measure_theory.measure_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_175007 (h0 : fin has_zero.zero) : @normal_space.{0} pos (@matrix.vec_empty.{0} (topological_space.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_175008 (h1 : topological_space (has_norm num)) : irreducible_space (has_norm num) := sorry --non-trivial
lemma new_lemma_175009 (h0 : group (boolean_algebra.core (finset (has_neg (finset (measurable_space Type)))))) : is_cyclic (boolean_algebra.core (finset (has_neg (finset (measurable_space Type))))) := sorry --non-trivial
lemma new_lemma_175010 (h0 : functor.comp topological_space add_comm_monoid Type) : @discrete_topology.{1} (add_comm_monoid.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} add_comm_monoid.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_175011 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (measurable_space.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (measurable_space.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_175012 (h1 : measurable_space (simple_graph reducibility_hints)) (h2 : filter (simple_graph reducibility_hints)) : filter.is_measurably_generated h2 := sorry --non-trivial
lemma new_lemma_175013 (h0 : ring (encodable fun_info)) : strong_rank_condition (encodable fun_info) := sorry --non-trivial
lemma new_lemma_175014 (h0 : topological_space (distrib (distrib string.iterator_imp))) : path_connected_space (distrib (distrib string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_175015 (h0 : functor.add_const (functor.add_const (uniform_space linarith.comp) pos) pos) : @complete_space.{0} linarith.comp (@functor.add_const.run.{0 0} (uniform_space.{0} linarith.comp) pos (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (uniform_space.{0} linarith.comp) pos) pos h0))  := sorry --non-trivial
lemma new_lemma_175016 (h0 : list (add_cancel_monoid (has_add Type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_175017 (h1 : add_group (has_compl linarith.comp_source)) : is_add_cyclic (has_compl linarith.comp_source) := sorry --non-trivial
lemma new_lemma_175018 (h0 : not (ring (random_gen name) -> false)) : @rank_condition.{0} (random_gen.{0} name) (@classical.by_contradiction'.{1} (ring.{0} (random_gen.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_175019 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_175020 (h0 : uniform_space (linear_ordered_comm_ring (semiring unsigned))) : complete_space (linear_ordered_comm_ring (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_175021 (h0 : functor.add_const (function.extfun Type list) (has_add (finset name))) : list.nodup (function.extfun_app (functor.add_const.run h0) (mul_zero_class name)) := sorry --non-trivial
lemma new_lemma_175022 (h0 : uniform_space (distrib (semi_normed_ring std_gen))) : complete_space (distrib (semi_normed_ring std_gen)) := sorry --non-trivial
lemma new_lemma_175023 (h1 : function.extfun Type monoid) : @monoid.fg.{0} (has_emptyc.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type monoid.{0} h1 (has_emptyc.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_175024 (h0 : functor.add_const (topological_space (free_add_monoid empty)) empty) : @locally_compact_space.{0} (free_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_175025 (h0 : topological_space (ordered_comm_monoid (boolean_algebra.core pos))) : t0_space (ordered_comm_monoid (boolean_algebra.core pos)) := sorry --non-trivial
lemma new_lemma_175026 (h0 : topological_space (has_neg_part (semigroup pos))) : regular_space (has_neg_part (semigroup pos)) := sorry --non-trivial
lemma new_lemma_175027 (h0 : functor.add_const (list (finset Type)) pos) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_175028 (h0 : functor.add_const (uniform_space (add_comm_monoid Type)) environment.implicit_infer_kind) : @separated_space.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (add_comm_monoid.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_175029 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (measurable_space.dynkin_system.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (measurable_space.dynkin_system.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_175030 (h0 : ring (boolean_algebra linarith.comp)) : rank_condition (boolean_algebra linarith.comp) := sorry --non-trivial
lemma new_lemma_175031 (h0 : function.extfun nat fin) : @path_connected_space.{0} (canonically_linear_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (canonically_linear_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_175032 (h0 : group (normed_lattice_add_comm_group to_additive.value_type)) : group.fg (normed_lattice_add_comm_group to_additive.value_type) := sorry --non-trivial
lemma new_lemma_175033 (h0 : semiring (ordered_comm_monoid (ring (has_nndist Type)))) : is_noetherian_ring (ordered_comm_monoid (ring (has_nndist Type))) := sorry --non-trivial
lemma new_lemma_175034 (h0 : functor.add_const (ring (has_to_string pos)) pos) : @rank_condition.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_to_string.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_175035 (h0 : functor.add_const (complete_lattice (ordered_comm_ring Type)) Type) : @complete_lattice.is_Sup_finite_compact.{1} (ordered_comm_ring.{1} Type) (@functor.add_const.run.{1 1} (complete_lattice.{1} (ordered_comm_ring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_175036 (h0 : function.extfun Type group) : @normalizer_condition.{0} (left_cancel_monoid.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type group.{0} h0 (left_cancel_monoid.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_175037 (h1 : linarith.ineq -> mul_one_class char) : function.bijective h1 := sorry --non-trivial
lemma new_lemma_175038 (h0 : topological_space (normed_lattice_add_comm_group (has_Inf real))) : sequential_space (normed_lattice_add_comm_group (has_Inf real)) := sorry --non-trivial
lemma new_lemma_175039 (h0 : option (ordered_cancel_comm_monoid unsigned) -> option (ordered_cancel_comm_monoid unsigned) -> Prop) : transitive h0 := sorry --non-trivial
lemma new_lemma_175040 (h0 : finset (has_add (finset (ring (ring (has_add Type)))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_175041 (h0 : functor.add_const (topological_space (comm_group Type)) linarith.comp) : @preirreducible_space.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (comm_group.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_175042 (h0 : complete_lattice (non_unital_non_assoc_semiring to_additive.value_type)) : is_atomistic (non_unital_non_assoc_semiring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_175043 (h0 : functor.add_const (ordered_add_comm_monoid (add_comm_monoid unsigned)) linarith.comp) : @archimedean.{0} (add_comm_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (add_comm_monoid.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_175044 (h0 : functor.add_const (function.extfun Type monoid) Type) : @monoid.fg.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type monoid.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type monoid.{0}) Type h0) (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_175045 (h0 : not (topological_space (comm_ring char) -> false)) : @t0_space.{0} (comm_ring.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (comm_ring.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_175046 (h0 : add_monoid (normed_comm_ring (has_to_string (has_to_string Type)))) : add_monoid.fg (normed_comm_ring (has_to_string (has_to_string Type))) := sorry --non-trivial
lemma new_lemma_175047 (h0 : semiring (has_pos_part (boolean_algebra.core (finset Type)))) : is_noetherian_ring (has_pos_part (boolean_algebra.core (finset Type))) := sorry --non-trivial
lemma new_lemma_175048 (h0 : functor.add_const (function.extfun Type topological_space) (finset pos)) : @totally_disconnected_space.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (finset.{0} pos) h0) (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_175049 (h0 : functor.add_const (topological_space (has_nndist Type)) pos) : @topological_space.separable_space.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_nndist.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_175050 (h0 : has_mem.mem fun_info has_emptyc.emptyc) : @is_cyclic.{0} fun_info (@finset.pi.empty.{1 0} Type group.{0} fun_info h0)  := sorry --non-trivial
lemma new_lemma_175051 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (semiring.{0} (semiring.{0} (semiring.{0} (has_norm.{0} (has_norm.{0} fun_info))))) (@function.extfun_app.{2 1} Type monoid.{0} h0 (semiring.{0} (semiring.{0} (semiring.{0} (has_norm.{0} (has_norm.{0} fun_info))))))  := sorry --non-trivial
lemma new_lemma_175052 (h3 : complete_lattice (has_compl linarith.ineq)) : is_compactly_generated (has_compl linarith.ineq) := sorry --non-trivial
lemma new_lemma_175053 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} (linear_ordered_semiring.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (linear_ordered_semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_175054 (h0 : functor.comp semiring has_to_string environment.implicit_infer_kind) : @is_noetherian_ring.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} semiring.{0} has_to_string.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_175055 (h0 : functor.add_const (finset (plift num)) num) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_175056 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (finset.{0} (option.{0} ennreal)) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (finset.{0} (option.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_175057 (h0 : functor.add_const (function.extfun (Type 1) topological_space) pos) : @totally_separated_space.{1} (boolean_algebra.core.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) pos h0) (boolean_algebra.core.{1} Type))  := sorry --non-trivial
lemma new_lemma_175058 (h0 : functor.add_const (list (has_nndist pos)) (add_comm_monoid (has_add Type))) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_175059 (h0 : uniform_space (has_neg_part (has_add (has_add name)))) : separated_space (has_neg_part (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_175060 (h0 : has_lt (linear_ordered_comm_group_with_zero fun_info)) : no_max_order (linear_ordered_comm_group_with_zero fun_info) := sorry --non-trivial
lemma new_lemma_175061 (h0 : function.extfun Type group) : @is_cyclic.{0} (random_gen.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (random_gen.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_175062 (h0 : ring (simple_graph (ring Type))) : rank_condition (simple_graph (ring Type)) := sorry --non-trivial
lemma new_lemma_175063 (h0 : not (group (has_norm linarith.comp) -> false)) : @group.fg.{0} (has_norm.{0} linarith.comp) (@classical.by_contradiction'.{1} (group.{0} (has_norm.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_175064 (h0 : ring (add_comm_semigroup (mul_one_class string.iterator_imp))) : strong_rank_condition (add_comm_semigroup (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_175065 (h0 : ring (comm_group (semigroup (finset pos)))) : is_principal_ideal_ring (comm_group (semigroup (finset pos))) := sorry --non-trivial
lemma new_lemma_175066 (h0 : ring (finset (ring pos))) : rank_condition (finset (ring pos)) := sorry --non-trivial
lemma new_lemma_175067 (h0 : topological_space (has_top (has_norm empty))) : path_connected_space (has_top (has_norm empty)) := sorry --non-trivial
lemma new_lemma_175068 (h0 : topological_space (has_top num)) : locally_compact_space (has_top num) := sorry --non-trivial
lemma new_lemma_175069 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_compactly_generated.{0} (linear_ordered_add_comm_group.{0} char) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (linear_ordered_add_comm_group.{0} char))  := sorry --non-trivial
lemma new_lemma_175070 (h0 : group (measurable_space (random_gen (random_gen to_additive.value_type)))) : normalizer_condition (measurable_space (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_175071 (h0 : ring (non_assoc_semiring (option unsigned))) : strong_rank_condition (non_assoc_semiring (option unsigned)) := sorry --non-trivial
lemma new_lemma_175072 (h0 : uniform_space (has_append (has_nnnorm (has_nnnorm char)))) : complete_space (has_append (has_nnnorm (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_175073 (h0 : functor.add_const (topological_space (has_neg Type)) environment.implicit_infer_kind) : @t1_space.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_neg.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_175074 (h0 : topological_space (linear_ordered_comm_group_with_zero fun_info)) : irreducible_space (linear_ordered_comm_group_with_zero fun_info) := sorry --non-trivial
lemma new_lemma_175075 (h0 : cancel_comm_monoid_with_zero (ordered_comm_monoid (has_neg Type))) : unique_factorization_monoid (ordered_comm_monoid (has_neg Type)) := sorry --non-trivial
lemma new_lemma_175076 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (has_dist.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_dist.{0} num))  := sorry --non-trivial
lemma new_lemma_175077 (h0 : complete_lattice (has_one (has_norm congr_arg_kind))) : complete_lattice.is_Sup_finite_compact (has_one (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_175078 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (complete_distrib_lattice.{0} name) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (complete_distrib_lattice.{0} name))  := sorry --non-trivial
lemma new_lemma_175079 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (complete_distrib_lattice.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_distrib_lattice.{0} empty))  := sorry --non-trivial
lemma new_lemma_175080 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (preorder.{0} num) (@function.extfun_app.{2 1} Type add_group.{0} h0 (preorder.{0} num))  := sorry --non-trivial
lemma new_lemma_175081 (h0 : functor.add_const (topological_space (canonically_ordered_add_monoid empty)) empty) : @preirreducible_space.{0} (canonically_ordered_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_add_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_175082 (h0 : ring (semigroup (boolean_algebra (mul_one_class (has_to_string pos))))) : is_principal_ideal_ring (semigroup (boolean_algebra (mul_one_class (has_to_string pos)))) := sorry --non-trivial
lemma new_lemma_175083 (h0 : dlist fun_info -> to_additive.value_type) : function.bijective h0 := sorry --non-trivial
lemma new_lemma_175084 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (complete_distrib_lattice.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (complete_distrib_lattice.{0} name))  := sorry --non-trivial
lemma new_lemma_175085 (h0 : not (group (mul_zero_class unsigned) -> false)) : @group.fg.{0} (mul_zero_class.{0} unsigned) (@classical.by_contradiction'.{1} (group.{0} (mul_zero_class.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_175086 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_175087 (h0 : functor.add_const (topological_space (ring linarith.comp)) linarith.comp) : @sequential_space.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_175088 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (boolean_algebra.core.{0} empty) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (boolean_algebra.core.{0} empty))  := sorry --non-trivial
lemma new_lemma_175089 (h0 : topological_space (linear_ordered_semiring fun_info)) : t0_space (linear_ordered_semiring fun_info) := sorry --non-trivial
lemma new_lemma_175090 (h0 : filter (has_to_string (option (option pos)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_175091 (h5 : topological_space char) : t0_space char := sorry --non-trivial
lemma new_lemma_175092 (h0 : functor.add_const (group (has_star num)) empty) : @normalizer_condition.{0} (has_star.{0} num) (@functor.add_const.run.{0 0} (group.{0} (has_star.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_175093 (h0 : ordered_add_comm_monoid (ordered_cancel_add_comm_monoid (option unsigned))) : archimedean (ordered_cancel_add_comm_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_175094 (h0 : topological_space (pseudo_metric_space (has_to_string ennreal))) : locally_compact_space (pseudo_metric_space (has_to_string ennreal)) := sorry --non-trivial
lemma new_lemma_175095 (h0 : topological_space (linear_ordered_comm_group_with_zero reducibility_hints)) : totally_disconnected_space (linear_ordered_comm_group_with_zero reducibility_hints) := sorry --non-trivial
lemma new_lemma_175096 (h0 : set (semi_normed_ring (mul_one_class string.iterator_imp))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_175097 (h0 : functor.add_const (topological_space (generalized_boolean_algebra real)) pos) : @locally_compact_space.{0} (generalized_boolean_algebra.{0} real) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} real)) pos h0)  := sorry --non-trivial
lemma new_lemma_175098 (h0 : monoid (has_norm (semiring num))) : monoid.fg (has_norm (semiring num)) := sorry --non-trivial
lemma new_lemma_175099 (h0 : function.extfun Type group) : @is_cyclic.{0} (fintype.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} h0 (fintype.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_175100 (h0 : monoid (random_gen (has_inv linarith.comp_source))) : monoid.fg (random_gen (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_175101 (h0 : filter (add_cancel_monoid (has_add name))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_175102 (h0 : topological_space (has_neg_part name)) : preirreducible_space (has_neg_part name) := sorry --non-trivial
lemma new_lemma_175103 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_principal_ideal_ring.{1} (plift.{1} empty) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ring.{1}) (plift.{1} empty))  := sorry --non-trivial
lemma new_lemma_175104 (h0 : ring (has_add (has_add (finset (finset linarith.comp))))) : rank_condition (has_add (has_add (finset (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_175105 (h0 : topological_space (has_emptyc (has_norm fun_info))) : locally_compact_space (has_emptyc (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_175106 (h1 : topological_space (with_one linarith.comp)) : locally_compact_space (with_one linarith.comp) := sorry --non-trivial
lemma new_lemma_175107 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_175108 (h0 : functor.add_const (topological_space (add_comm_monoid linarith.comp)) name) : @topological_space.separable_space.{0} (add_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_175109 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (semiring.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semiring.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_175110 (h0 : not (complete_lattice (has_emptyc num) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_emptyc.{0} num) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_emptyc.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_175111 (h0 : option Type) : nonempty (omega_complete_partial_order (has_mul (option.lhoare char h0))) := sorry --non-trivial
lemma new_lemma_175112 (h0 : fin has_zero.zero) : @t0_space.{0} (ordered_comm_ring.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_ring.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_175113 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_175114 (h0 : ring (linear_ordered_add_comm_group (has_nnnorm (has_nnnorm char)))) : is_domain (linear_ordered_add_comm_group (has_nnnorm (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_175115 (h0 : function.extfun Type group) : @group.fg.{0} (distrib_lattice.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} h0 (distrib_lattice.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_175116 (h0 : functor.add_const Prop (has_to_string name)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_175117 (h5 : ring (add_comm_semigroup linarith.ineq)) : strong_rank_condition (add_comm_semigroup linarith.ineq) := sorry --non-trivial
lemma new_lemma_175118 (h1 : uniform_space (with_bot (has_inv (has_inv (has_inv (has_inv (has_inv linarith.comp_source))))))) : complete_space (with_bot (has_inv (has_inv (has_inv (has_inv (has_inv linarith.comp_source)))))) := sorry --non-trivial
lemma new_lemma_175119 (h0 : functor.add_const (monoid (finset Type)) (ring Type)) : @monoid.fg.{1} (finset.{1} Type) (@functor.add_const.run.{1 1} (monoid.{1} (finset.{1} Type)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_175120 (h0 : filter (ordered_cancel_add_comm_monoid empty)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_175121 (h0 : functor.add_const (add_group (add_comm_monoid Type)) name) : @is_add_cyclic.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (add_group.{1} (add_comm_monoid.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_175122 (h0 h1 : multiset (has_compl (linear_ordered_add_comm_monoid_with_top (mul_one_class linarith.ineq)))) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_175123 (h0 : functor.add_const (ring Type) unsigned) : @is_domain.{1} Type (@functor.add_const.run.{1 0} (ring.{1} Type) unsigned h0)  := sorry --non-trivial
lemma new_lemma_175124 (h1 : uniform_space (add_left_cancel_monoid fun_info)) : complete_space (add_left_cancel_monoid fun_info) := sorry --non-trivial
lemma new_lemma_175125 (h0 : group (has_neg ennreal)) : group.fg (has_neg ennreal) := sorry --non-trivial
lemma new_lemma_175126 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (has_edist unsigned)) := sorry --non-trivial
lemma new_lemma_175127 (h0 : functor.add_const (semiring (complete_distrib_lattice linarith.comp)) linarith.comp) : @is_noetherian_ring.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.add_const.run.{0 0} (semiring.{0} (complete_distrib_lattice.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_175128 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_175129 (h0 : functor.add_const (function.extfun (Type 1) semiring) empty) : @is_noetherian_ring.{1} (plift.{1} (option.{0} empty)) (@function.extfun_app.{3 2} (Type 1) semiring.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) semiring.{1}) empty h0) (plift.{1} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_175130 (h1 : not (complete_lattice (with_bot linarith.ineq) -> false)) : @is_compactly_generated.{0} (with_bot.{0} linarith.ineq) (@classical.by_contradiction'.{1} (complete_lattice.{0} (with_bot.{0} linarith.ineq)) h1)  := sorry --non-trivial
lemma new_lemma_175131 (h0 : list (has_to_string Type)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_175132 (h0 : group (add_cancel_monoid (comm_group ennreal))) : group.fg (add_cancel_monoid (comm_group ennreal)) := sorry --non-trivial
lemma new_lemma_175133 (h0 : functor.add_const (topological_space (comm_group unsigned)) environment.implicit_infer_kind) : @locally_compact_space.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_175134 (h0 : functor.add_const (topological_space (comm_group linarith.comp)) Type) : @preirreducible_space.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (comm_group.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_175135 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (add_comm_monoid name)) := sorry --non-trivial
lemma new_lemma_175136 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (comm_ring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_ring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_175137 (h0 : function.extfun Type topological_space) (h1 : set (canonically_ordered_monoid real)) : @is_seq_closed.{0} (canonically_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_monoid.{0} real)) h1  := sorry --non-trivial
lemma new_lemma_175138 (h0 : functor.comp topological_space cancel_monoid Type) : @t1_space.{1} (cancel_monoid.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} cancel_monoid.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_175139 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (canonically_linear_ordered_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type monoid.{0} h0 (canonically_linear_ordered_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_175140 (h0 : complete_lattice (with_bot (has_inv (has_inv fun_info)))) : is_compactly_generated (with_bot (has_inv (has_inv fun_info))) := sorry --non-trivial
lemma new_lemma_175141 (h0 : functor.add_const (topological_space (boolean_algebra linarith.comp)) pos) : @t0_space.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_175142 (h0 : topological_space (partial_order empty)) : t1_space (partial_order empty) := sorry --non-trivial
lemma new_lemma_175143 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (has_add.{0} name) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (has_add.{0} name))  := sorry --non-trivial
lemma new_lemma_175144 (h0 : not (is_empty string_imp -> false)) (h1 : string_imp) : @strong_rank_condition.{0} (has_lt.{0} fun_info) (@is_empty.elim'.{1 1} string_imp (ring.{0} (has_lt.{0} fun_info)) (@classical.by_contradiction'.{0} (is_empty.{1} string_imp) h0) h1)  := sorry --non-trivial
lemma new_lemma_175145 (h0 : topological_space (metric_space (random_gen (semiring empty)))) : irreducible_space (metric_space (random_gen (semiring empty))) := sorry --non-trivial
lemma new_lemma_175146 (h1 : complete_lattice (has_nnnorm (mul_one_class string.iterator_imp))) : complete_lattice.is_Sup_finite_compact (has_nnnorm (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_175147 (h0 : uniform_space (has_union num)) : separated_space (has_union num) := sorry --non-trivial
lemma new_lemma_175148 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_simple_group.{0} (has_add.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_add.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_175149 (h0 : topological_space (has_union (semiring congr_arg_kind))) : irreducible_space (has_union (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_175150 (h0 : complete_lattice (linear_ordered_semiring unsigned)) : is_atomistic (linear_ordered_semiring unsigned) := sorry --non-trivial
lemma new_lemma_175151 (h0 : topological_space (has_bot unsigned)) : discrete_topology (has_bot unsigned) := sorry --non-trivial
lemma new_lemma_175152 (h0 : topological_space (has_le (mul_one_class (mul_one_class reducibility_hints)))) : path_connected_space (has_le (mul_one_class (mul_one_class reducibility_hints))) := sorry --non-trivial
lemma new_lemma_175153 (h0 : fin has_zero.zero) : @is_compactly_generated.{0} (has_pos_part.{0} name) (@matrix.vec_empty.{0} (complete_lattice.{0} (has_pos_part.{0} name)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_175154 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (left_cancel_semigroup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (left_cancel_semigroup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_175155 (h0 : ordered_add_comm_monoid (complete_distrib_lattice (has_pos_part Type))) : archimedean (complete_distrib_lattice (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_175156 (h0 : topological_space (semigroup (boolean_algebra pos))) : t0_space (semigroup (boolean_algebra pos)) := sorry --non-trivial
lemma new_lemma_175157 (h0 : ring (has_norm complex)) : rank_condition (has_norm complex) := sorry --non-trivial
lemma new_lemma_175158 (h2 : uniform_space (uniform_space to_additive.value_type)) : complete_space (uniform_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_175159 (h0 : semiring (has_Inf (ring linarith.comp))) : is_noetherian_ring (has_Inf (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_175160 (h0 : ring (with_bot (random_gen num))) : is_domain (with_bot (random_gen num)) := sorry --non-trivial
lemma new_lemma_175161 (h0 : functor.comp complete_lattice cancel_monoid name) : @complete_lattice.is_Sup_finite_compact.{0} (cancel_monoid.{0} name) (@functor.comp.run.{0 0 0} complete_lattice.{0} cancel_monoid.{0} name h0)  := sorry --non-trivial
lemma new_lemma_175162 (h0 : not (ring (linear_ordered_comm_ring num) -> false)) : @strong_rank_condition.{0} (linear_ordered_comm_ring.{0} num) (@classical.by_contradiction'.{1} (ring.{0} (linear_ordered_comm_ring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_175163 (h0 : functor.add_const (topological_space (has_neg_part pos)) linarith.comp) : @normal_space.{0} (has_neg_part.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_175164 (h0 : functor.add_const (topological_space (ordered_comm_ring linarith.comp)) pos) : @topological_space.separable_space.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_175165 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (has_norm.{0} linarith.ineq) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_norm.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_175166 (h0 : not (topological_space (add_left_cancel_monoid fun_info) -> false)) : @t0_space.{0} (add_left_cancel_monoid.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (add_left_cancel_monoid.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_175167 (h0 : topological_space (has_add (has_neg pos))) : preirreducible_space (has_add (has_neg pos)) := sorry --non-trivial
lemma new_lemma_175168 (h0 : functor.add_const (topological_space (has_neg pos)) name) : @regular_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_175169 (h1 : topological_space (linear_ordered_add_comm_group linarith.comp_source)) : path_connected_space (linear_ordered_add_comm_group linarith.comp_source) := sorry --non-trivial
lemma new_lemma_175170 (h0 : topological_space (id (random_gen (random_gen (random_gen (random_gen string_imp)))))) : t0_space (id (random_gen (random_gen (random_gen (random_gen string_imp))))) := sorry --non-trivial
lemma new_lemma_175171 (h1 : ring (add_monoid linarith.ineq)) : rank_condition (add_monoid linarith.ineq) := sorry --non-trivial
lemma new_lemma_175172 (h0 : functor.add_const (semiring (add_cancel_monoid pos)) pos) : @is_noetherian_ring.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (semiring.{0} (add_cancel_monoid.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_175173 (h0 : not (ring (has_one unsigned) -> false)) : @rank_condition.{0} (has_one.{0} unsigned) (@classical.by_contradiction'.{1} (ring.{0} (has_one.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_175174 (h0 : topological_space (with_bot (has_norm empty))) : t0_space (with_bot (has_norm empty)) := sorry --non-trivial
lemma new_lemma_175175 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (with_one.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} h0 (with_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_175176 (h0 : list (ring (option (option pos)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_175177 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_dist.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_dist.{0} empty))  := sorry --non-trivial
lemma new_lemma_175178 (h0 : topological_space (has_nndist (finset (finset environment.implicit_infer_kind)))) : totally_separated_space (has_nndist (finset (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_175179 (h0 : fin has_zero.zero) : @totally_separated_space.{0} (boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_175180 (h0 : function.extfun Type group) : @group.fg.{0} (mul_zero_class.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (mul_zero_class.{0} num))  := sorry --non-trivial
lemma new_lemma_175181 (h0 : functor.add_const (add_monoid (comm_monoid empty)) (option unsigned)) : @add_monoid.fg.{0} (comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (add_monoid.{0} (comm_monoid.{0} empty)) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_175182 (h0 : has_coe (add_comm_semigroup linarith.ineq) Prop) (h1 : add_comm_semigroup linarith.ineq) : @coe_b.{1 1} (add_comm_semigroup.{0} linarith.ineq) Prop h0 h1  := sorry --non-trivial
lemma new_lemma_175183 (h0 : ring (boolean_algebra.core (finset ennreal))) : is_domain (boolean_algebra.core (finset ennreal)) := sorry --non-trivial
lemma new_lemma_175184 (h0 : functor.add_const Prop (has_neg unsigned)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_175185 (h0 : functor.add_const (topological_space (free_add_monoid num)) (semiring congr_arg_kind)) : @preirreducible_space.{0} (free_add_monoid.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} num)) (semiring.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_175186 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (boolean_algebra.core.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.core.{0} name))  := sorry --non-trivial
lemma new_lemma_175187 (h0 : complete_lattice (option (option (option pos)))) : complete_lattice.is_Sup_finite_compact (option (option (option pos))) := sorry --non-trivial
lemma new_lemma_175188 (h0 : functor.add_const (topological_space (cancel_monoid name)) Type) : @sequential_space.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (cancel_monoid.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_175189 (h0 : function.extfun (Type 1) ring) : @strong_rank_condition.{1} (cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_175190 (h0 : add_group (finset (option unsigned))) : is_add_cyclic (finset (option unsigned)) := sorry --non-trivial
lemma new_lemma_175191 (h0 : functor.add_const (function.extfun Type topological_space) real) : @loc_path_connected_space.{0} (ordered_comm_ring.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) real h0) (ordered_comm_ring.{0} real))  := sorry --non-trivial
lemma new_lemma_175192 (h0 : ordered_comm_ring Type -> ordered_comm_ring Type -> Prop) : transitive h0 := sorry --non-trivial
lemma new_lemma_175193 (h0 : cancel_comm_monoid_with_zero (has_Inf (has_neg real))) : unique_factorization_monoid (has_Inf (has_neg real)) := sorry --non-trivial
lemma new_lemma_175194 (h0 : ring to_additive.value_type) : strong_rank_condition to_additive.value_type := sorry --non-trivial
lemma new_lemma_175195 (h0 : filter (pseudo_metric_space Type)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_175196 (h0 : function.extfun Type (functor.add_const (topological_space (add_semigroup empty)))) : @t1_space.{0} (add_semigroup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_semigroup.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (add_semigroup.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_175197 (h0 : topological_space (has_neg (ring linarith.comp))) : irreducible_space (has_neg (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_175198 (h0 : add_group (random_gen (has_nnnorm (random_gen char)))) : is_add_cyclic (random_gen (has_nnnorm (random_gen char))) := sorry --non-trivial
lemma new_lemma_175199 (h0 : topological_space (has_to_string (option pos))) : sequential_space (has_to_string (option pos)) := sorry --non-trivial
lemma new_lemma_175200 (h0 : has_lt (non_unital_non_assoc_semiring (mul_one_class linarith.comp_source))) : no_max_order (non_unital_non_assoc_semiring (mul_one_class linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_175201 (h1 : ring (encodable (has_ssubset string_imp))) : rank_condition (encodable (has_ssubset string_imp)) := sorry --non-trivial
lemma new_lemma_175202 (h0 : topological_space (add_cancel_monoid (cancel_monoid ennreal))) : t0_space (add_cancel_monoid (cancel_monoid ennreal)) := sorry --non-trivial
lemma new_lemma_175203 (h0 : filter (with_zero (has_nnnorm (has_nnnorm linarith.comp_source)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_175204 (h0 : topological_space (add_cancel_comm_monoid unsigned)) : totally_disconnected_space (add_cancel_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_175205 (h0 : function.extfun Type (functor.add_const (cancel_comm_monoid_with_zero auto.case_option))) : @unique_factorization_monoid.{0} auto.case_option (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} auto.case_option) congr_arg_kind (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (cancel_comm_monoid_with_zero.{0} auto.case_option)) h0 congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_175206 (h1 : ring (linear_ordered_add_comm_group congr_arg_kind)) : is_domain (linear_ordered_add_comm_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_175207 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (add_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (add_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_175208 (h0 : topological_space (has_Inf real)) : loc_path_connected_space (has_Inf real) := sorry --non-trivial
lemma new_lemma_175209 (h0 : topological_space (has_le to_additive.value_type)) (h1 : add_group (has_le to_additive.value_type)) : topological_add_group (has_le to_additive.value_type) := sorry --non-trivial
lemma new_lemma_175210 (h0 : ordered_add_comm_monoid (free_add_monoid num)) : archimedean (free_add_monoid num) := sorry --non-trivial
lemma new_lemma_175211 (h0 : not (group (add_left_cancel_semigroup unsigned) -> false)) : @normalizer_condition.{0} (add_left_cancel_semigroup.{0} unsigned) (@classical.by_contradiction'.{1} (group.{0} (add_left_cancel_semigroup.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_175212 (h0 : function.extfun Type group) : @is_simple_group.{0} (canonically_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type group.{0} h0 (canonically_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_175213 (h0 : function.extfun Type (functor.add_const (add_monoid (add_left_cancel_semigroup num)))) : @add_monoid.fg.{0} (add_left_cancel_semigroup.{0} num) (@functor.add_const.run.{0 0} (add_monoid.{0} (add_left_cancel_semigroup.{0} num)) (option.{0} (option.{0} (option.{0} empty))) (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (add_monoid.{0} (add_left_cancel_semigroup.{0} num))) h0 (option.{0} (option.{0} (option.{0} empty)))))  := sorry --non-trivial
lemma new_lemma_175214 (h0 : group (has_neg (has_add pos))) : is_cyclic (has_neg (has_add pos)) := sorry --non-trivial
lemma new_lemma_175215 (h0 : topological_space (has_nndist name)) : discrete_topology (has_nndist name) := sorry --non-trivial
lemma new_lemma_175216 (h0 : topological_space (complete_distrib_lattice (boolean_algebra.core Type))) : locally_compact_space (complete_distrib_lattice (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_175217 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (simple_graph.{0} unsigned) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (simple_graph.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_175218 (h1 : topological_space (with_zero fun_info)) : totally_disconnected_space (with_zero fun_info) := sorry --non-trivial
lemma new_lemma_175219 (h0 : ring (has_pos_part (has_neg (has_neg name)))) : rank_condition (has_pos_part (has_neg (has_neg name))) := sorry --non-trivial
lemma new_lemma_175220 (h0 : set (linarith.ineq -> add_comm_semigroup (add_comm_semigroup fun_info))) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_175221 (h0 : topological_space (non_assoc_semiring (option congr_arg_kind))) : irreducible_space (non_assoc_semiring (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_175222 (h0 : ring (measurable_space (metric_space (has_union empty)))) : is_domain (measurable_space (metric_space (has_union empty))) := sorry --non-trivial
lemma new_lemma_175223 (h1 : monoid (id (with_bot string_imp))) : monoid.fg (id (with_bot string_imp)) := sorry --non-trivial
lemma new_lemma_175224 (h0 : ring (linear_ordered_add_comm_group_with_top empty)) : is_principal_ideal_ring (linear_ordered_add_comm_group_with_top empty) := sorry --non-trivial
lemma new_lemma_175225 (h0 : semiring (semigroup (has_Inf linarith.comp))) : is_noetherian_ring (semigroup (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_175226 (h0 : add_comm_group enat) (h2 : has_norm enat) : semi_normed_group.core enat := sorry --non-trivial
lemma new_lemma_175227 (h0 : has_mem.mem (with_bot empty) has_emptyc.emptyc) : @separated_space.{0} (with_bot.{0} empty) (@finset.pi.empty.{1 0} Type uniform_space.{0} (with_bot.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_175228 (h0 : group (has_edist (semiring unsigned))) : normalizer_condition (has_edist (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_175229 (h0 : functor.add_const (topological_space (has_to_string Type)) environment.implicit_infer_kind) : @discrete_topology.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_to_string.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_175230 (h0 : list (with_bot Prop)) (h1 : ne (list.head h0) has_bot.bot) : with_bot.unbot (list.head h0) h1 := sorry --non-trivial
lemma new_lemma_175231 (h0 : uniform_space (with_bot (normed_group congr_arg_kind))) : separated_space (with_bot (normed_group congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_175232 (h0 : functor.add_const (function.extfun Type filter) pos) : countable_Inter_filter (function.extfun_app (functor.add_const.run h0) (ring pos)) := sorry --non-trivial
lemma new_lemma_175233 (h0 : uniform_space (has_top (random_gen congr_arg_kind))) : separated_space (has_top (random_gen congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_175234 (h0 : functor.add_const (cancel_comm_monoid_with_zero (add_comm_monoid unsigned)) linarith.comp) : @unique_factorization_monoid.{0} (add_comm_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (add_comm_monoid.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_175235 (h1 : topological_space (comm_ring (random_gen to_additive.value_type))) : t0_space (comm_ring (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_175236 (h0 : topological_space (pseudo_emetric_space unsigned)) : loc_path_connected_space (pseudo_emetric_space unsigned) := sorry --non-trivial
lemma new_lemma_175237 (h0 : uniform_space (has_pos_part (has_add Type))) : complete_space (has_pos_part (has_add Type)) := sorry --non-trivial
lemma new_lemma_175238 (h0 : topological_space (add_cancel_monoid (has_Inf name))) : preconnected_space (add_cancel_monoid (has_Inf name)) := sorry --non-trivial
lemma new_lemma_175239 (h0 : set (semi_normed_comm_ring string.iterator_imp)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_175240 (h0 : uniform_space (boolean_algebra linarith.comp)) : complete_space (boolean_algebra linarith.comp) := sorry --non-trivial
lemma new_lemma_175241 (h0 : cancel_comm_monoid_with_zero (has_nndist environment.implicit_infer_kind)) : unique_factorization_monoid (has_nndist environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_175242 (h0 : topological_space (ring (has_Inf (has_Inf pos)))) : loc_path_connected_space (ring (has_Inf (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_175243 (h0 : group (comm_ring linarith.ineq)) : group.fg (comm_ring linarith.ineq) := sorry --non-trivial
lemma new_lemma_175244 (h0 : functor.add_const (ring (generalized_boolean_algebra Type)) linarith.comp) : @strong_rank_condition.{1} (generalized_boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (generalized_boolean_algebra.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_175245 (h0 : functor.add_const (topological_space (add_cancel_monoid empty)) unsigned) : @path_connected_space.{0} (add_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_175246 (h0 : topological_space (has_top string_imp)) : totally_disconnected_space (has_top string_imp) := sorry --non-trivial
lemma new_lemma_175247 (h0 : topological_space (linear_ordered_add_comm_group (has_nnnorm (has_nnnorm fun_info)))) : totally_disconnected_space (linear_ordered_add_comm_group (has_nnnorm (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_175248 (h0 : topological_space (add_cancel_monoid (has_neg (has_add pos)))) : path_connected_space (add_cancel_monoid (has_neg (has_add pos))) := sorry --non-trivial
lemma new_lemma_175249 (h0 : complete_lattice (monoid (option (option empty)))) : is_compactly_generated (monoid (option (option empty))) := sorry --non-trivial
lemma new_lemma_175250 (h0 : functor.add_const (topological_space (has_nndist linarith.comp)) Type) : @t0_space.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_nndist.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_175251 (h0 : topological_space (normed_lattice_add_comm_group (finset (has_Inf pos)))) : topological_space.separable_space (normed_lattice_add_comm_group (finset (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_175252 (h1 : group (random_gen to_additive.value_type)) : group.fg (random_gen to_additive.value_type) := sorry --non-trivial
lemma new_lemma_175253 (h0 : ring (add_cancel_monoid empty)) : is_domain (add_cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_175254 (h0 : functor.add_const (group (has_zero linarith.comp)) pos) : @group.fg.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (has_zero.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_175255 (h0 : functor.add_const (topological_space (ring environment.implicit_infer_kind)) environment.implicit_infer_kind) : @irreducible_space.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_175256 (h0 : group (topological_space (topological_space (random_gen (random_gen char))))) : is_cyclic (topological_space (topological_space (random_gen (random_gen char)))) := sorry --non-trivial
lemma new_lemma_175257 (h0 : uniform_space (with_bot linarith.comp)) : separated_space (with_bot linarith.comp) := sorry --non-trivial
lemma new_lemma_175258 (h0 : add_group (cancel_monoid (has_add (normed_comm_ring (finset (has_nndist Type)))))) : is_add_cyclic (cancel_monoid (has_add (normed_comm_ring (finset (has_nndist Type))))) := sorry --non-trivial
lemma new_lemma_175259 (h0 : topological_space (has_bot (has_bot (sub_neg_monoid (has_add pos))))) : t1_space (has_bot (has_bot (sub_neg_monoid (has_add pos)))) := sorry --non-trivial
lemma new_lemma_175260 (h0 : topological_space (canonically_linear_ordered_monoid (has_add linarith.comp))) : totally_disconnected_space (canonically_linear_ordered_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_175261 (h0 : functor.add_const (topological_space (linear_ordered_field ennreal)) num) : @loc_path_connected_space.{0} (linear_ordered_field.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_field.{0} ennreal)) num h0)  := sorry --non-trivial
lemma new_lemma_175262 (h0 : not (ring (random_gen linarith.comp_source) -> false)) : @rank_condition.{0} (random_gen.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (random_gen.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_175263 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (complete_distrib_lattice.{0} (finset.{0} linarith.comp)) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (complete_distrib_lattice.{0} (finset.{0} linarith.comp)))  := sorry --non-trivial
lemma new_lemma_175264 (h0 : group (denumerable (has_inv fun_info))) : group.fg (denumerable (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_175265 (h0 : has_neg (has_compl (mul_one_class (mul_one_class linarith.comp_source)))) (h1 : not (measurable_space (has_compl (mul_one_class (mul_one_class linarith.comp_source))) -> false)) : @has_measurable_neg.{0} (has_compl.{0} (mul_one_class.{0} (mul_one_class.{0} linarith.comp_source))) h0 (@classical.by_contradiction'.{1} (measurable_space.{0} (has_compl.{0} (mul_one_class.{0} (mul_one_class.{0} linarith.comp_source)))) h1)  := sorry --non-trivial
lemma new_lemma_175266 (h2 : topological_space (linear_ordered_add_comm_group char)) : path_connected_space (linear_ordered_add_comm_group char) := sorry --non-trivial
lemma new_lemma_175267 (h0 : topological_space (comm_group (cancel_monoid pos))) : irreducible_space (comm_group (cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_175268 (h0 : functor.add_const (monoid (has_add name)) name) : @monoid.fg.{0} (has_add.{0} name) (@functor.add_const.run.{0 0} (monoid.{0} (has_add.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_175269 (h0 : fin has_zero.zero) : @has_exists_mul_of_le.{1} (canonically_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (ordered_comm_monoid.{1} (canonically_ordered_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_175270 (h0 : ring (random_gen (has_top num))) : strong_rank_condition (random_gen (has_top num)) := sorry --non-trivial
lemma new_lemma_175271 (h0 : uniform_space (has_neg (option pos))) : complete_space (has_neg (option pos)) := sorry --non-trivial
lemma new_lemma_175272 (h0 : functor.add_const (topological_space (has_nndist environment.implicit_infer_kind)) pos) : @t0_space.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_175273 (h0 : topological_space (boolean_algebra (has_add (has_add Type)))) : discrete_topology (boolean_algebra (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_175274 (h0 : group (semigroup (finset (finset ennreal)))) : group.fg (semigroup (finset (finset ennreal))) := sorry --non-trivial
lemma new_lemma_175275 (h0 : topological_space (complete_distrib_lattice (has_neg Type))) : sequential_space (complete_distrib_lattice (has_neg Type)) := sorry --non-trivial
lemma new_lemma_175276 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @loc_path_connected_space.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_175277 (h0 : not (monoid (has_top linarith.comp_source) -> false)) : @monoid.fg.{0} (has_top.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (monoid.{0} (has_top.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_175278 (h0 : not (has_mem.mem (measurable_space num) has_emptyc.emptyc -> false)) : @rank_condition.{0} (measurable_space.{0} num) (@finset.pi.empty.{1 0} Type ring.{0} (measurable_space.{0} num) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (measurable_space.{0} num) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_175279 (h0 : topological_space char) (h1 : has_lt (topological_space.nonempty_compacts char)) : no_max_order (topological_space.nonempty_compacts char) := sorry --non-trivial
lemma new_lemma_175280 (h0 : topological_space (boolean_algebra.core empty)) : totally_separated_space (boolean_algebra.core empty) := sorry --non-trivial
lemma new_lemma_175281 (h0 : functor.add_const (group (boolean_algebra ennreal)) pos) : @is_cyclic.{0} (boolean_algebra.{0} ennreal) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.{0} ennreal)) pos h0)  := sorry --non-trivial
lemma new_lemma_175282 (h0 : topological_space (simple_graph (has_add pos))) : totally_separated_space (simple_graph (has_add pos)) := sorry --non-trivial
lemma new_lemma_175283 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem uniform_space)) : @complete_space.{0} string_imp (@function.extfun_app.{2 1} Type uniform_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) uniform_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) uniform_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) string_imp)  := sorry --non-trivial
lemma new_lemma_175284 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (has_norm.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (has_norm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_175285 (h0 : functor.add_const (topological_space (has_add name)) name) : @preconnected_space.{0} (has_add.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_175286 (h0 : function.extfun (Type 1) complete_lattice) : @is_compactly_generated.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} h0 (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_175287 (h0 : complete_lattice (normed_group (has_top (has_top fun_info)))) : complete_lattice.is_Sup_finite_compact (normed_group (has_top (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_175288 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_atomistic.{0} (has_sub.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (has_sub.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_175289 (h0 : topological_space (has_pos_part (boolean_algebra.core Type))) : loc_path_connected_space (has_pos_part (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_175290 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (finset.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (finset.{0} empty))  := sorry --non-trivial
lemma new_lemma_175291 (h0 : function.extfun Type group) : @normalizer_condition.{0} (normed_comm_ring.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (normed_comm_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_175292 (h0 : functor.add_const (functor.add_const Prop num) num) : functor.add_const.run (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_175293 (h0 : ring (normed_group (has_top (has_top congr_arg_kind)))) : strong_rank_condition (normed_group (has_top (has_top congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_175294 (h0 : function.extfun Type (functor.add_const (function.extfun Type group))) : @group.fg.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) pos (@function.extfun_app.{2 2} Type (functor.add_const.{1 0} (function.extfun.{2 1} Type group.{0})) h0 pos)) (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_175295 (h0 : functor.add_const (ring (has_neg Type)) (has_neg environment.implicit_infer_kind)) : @is_domain.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_neg.{1} Type)) (has_neg.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_175296 (h0 : complete_lattice (ordered_comm_ring (has_add (sub_neg_monoid real)))) : is_atomistic (ordered_comm_ring (has_add (sub_neg_monoid real))) := sorry --non-trivial
lemma new_lemma_175297 (h0 : function.extfun Type topological_space) : @regular_space.{0} (has_dist.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_dist.{0} empty))  := sorry --non-trivial
lemma new_lemma_175298 (h0 : function.extfun (finset Type -> Prop) (function.extfun (finset Type))) : @normalizer_condition.{0} (has_top.{0} (semiring.{0} num)) (@finset.pi.empty.{1 0} Type group.{0} (has_top.{0} (semiring.{0} num)) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_top.{0} (semiring.{0} num))) (@function.extfun_app.{2 0} (finset.{1} Type → Prop) (function.extfun.{2 0} (finset.{1} Type)) h0 (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_top.{0} (semiring.{0} num)))) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_175299 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (with_bot.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (with_bot.{0} empty))  := sorry --non-trivial
lemma new_lemma_175300 (h0 : ring (has_bot (has_add (has_Inf pos)))) : is_principal_ideal_ring (has_bot (has_add (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_175301 (h1 : group (topological_space reducibility_hints)) : is_cyclic (topological_space reducibility_hints) := sorry --non-trivial
lemma new_lemma_175302 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_175303 (h0 : ordered_add_comm_monoid (boolean_algebra (comm_group name))) : archimedean (boolean_algebra (comm_group name)) := sorry --non-trivial
lemma new_lemma_175304 (h0 : functor.add_const (complete_lattice (boolean_algebra Type)) (finset pos)) : @is_compactly_generated.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (boolean_algebra.{1} Type)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_175305 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (has_top.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_top.{0} empty))  := sorry --non-trivial
lemma new_lemma_175306 (h0 : functor.add_const (group (comm_group environment.implicit_infer_kind)) (has_add name)) : @is_simple_group.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (comm_group.{0} environment.implicit_infer_kind)) (has_add.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_175307 (h0 : set (ereal -> string.iterator_imp)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_175308 (h0 : functor.add_const (topological_space (bin_tree num)) empty) : @t1_space.{0} (bin_tree.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (bin_tree.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_175309 (h0 : topological_space (canonically_linear_ordered_add_monoid (comm_semigroup real))) : preirreducible_space (canonically_linear_ordered_add_monoid (comm_semigroup real)) := sorry --non-trivial
lemma new_lemma_175310 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (canonically_linear_ordered_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_linear_ordered_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_175311 (h0 : topological_space (canonically_linear_ordered_monoid (has_Inf (has_Inf (has_Inf (has_Inf Type)))))) : t0_space (canonically_linear_ordered_monoid (has_Inf (has_Inf (has_Inf (has_Inf Type))))) := sorry --non-trivial
lemma new_lemma_175312 (h0 : ordered_add_comm_monoid (semigroup (has_add (finset (has_add ennreal))))) : archimedean (semigroup (has_add (finset (has_add ennreal)))) := sorry --non-trivial
lemma new_lemma_175313 (h0 : topological_space (left_cancel_monoid (semiring congr_arg_kind))) : normal_space (left_cancel_monoid (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_175314 (h0 : functor.add_const (topological_space (has_zero (has_neg pos))) Type) : @totally_disconnected_space.{0} (has_zero.{0} (has_neg.{0} pos)) (@functor.add_const.run.{0 1} (topological_space.{0} (has_zero.{0} (has_neg.{0} pos))) Type h0)  := sorry --non-trivial
lemma new_lemma_175315 (h0 : functor.add_const (function.extfun (Type 1) ordered_add_comm_monoid) linarith.comp) : @archimedean.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_add_comm_monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ordered_add_comm_monoid.{1}) linarith.comp h0) (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_175316 (h1 : group (distrib (random_gen (has_nnnorm (has_nnnorm (has_nnnorm fun_info)))))) : is_cyclic (distrib (random_gen (has_nnnorm (has_nnnorm (has_nnnorm fun_info))))) := sorry --non-trivial
lemma new_lemma_175317 (h2 : uniform_space (has_append linarith.ineq)) : complete_space (has_append linarith.ineq) := sorry --non-trivial
lemma new_lemma_175318 (h0 : functor.add_const (group (generalized_boolean_algebra pos)) linarith.comp) : @is_cyclic.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (generalized_boolean_algebra.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_175319 (h1 : group (has_compl linarith.ineq)) : group.fg (has_compl linarith.ineq) := sorry --non-trivial
lemma new_lemma_175320 (h0 : function.extfun Type group) : @normalizer_condition.{0} (comm_semigroup.{0} real) (@function.extfun_app.{2 1} Type group.{0} h0 (comm_semigroup.{0} real))  := sorry --non-trivial
lemma new_lemma_175321 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @group.fg.{1} (canonically_ordered_comm_semiring.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 group.{1}) (canonically_ordered_comm_semiring.{1} Type))  := sorry --non-trivial
lemma new_lemma_175322 (h0 : topological_space (bin_tree unsigned)) : topological_space.separable_space (bin_tree unsigned) := sorry --non-trivial
lemma new_lemma_175323 (h0 : ring (simple_graph (has_to_string pos))) : is_principal_ideal_ring (simple_graph (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_175324 (h0 : functor.add_const (function.extfun Type finset) pos) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (ring pos)) := sorry --non-trivial
lemma new_lemma_175325 (h0 : functor.add_const (topological_space (preorder num)) empty) : @t1_space.{0} (preorder.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (preorder.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_175326 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (monoid_with_zero.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (monoid_with_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_175327 (h0 : fin has_zero.zero) : @unique_factorization_monoid.{1} (canonically_linear_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (cancel_comm_monoid_with_zero.{1} (canonically_linear_ordered_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_175328 (h0 : list (finset (has_pos_part Type))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_175329 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (has_nndist.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_nndist.{0} num))  := sorry --non-trivial
lemma new_lemma_175330 (h0 : complete_lattice (has_neg (finset name))) : complete_lattice.is_Sup_finite_compact (has_neg (finset name)) := sorry --non-trivial
lemma new_lemma_175331 (h0 : topological_space (has_pos_part (has_pos_part pos))) : preconnected_space (has_pos_part (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_175332 (h0 : topological_space (comm_group (ring (option (option unsigned))))) : regular_space (comm_group (ring (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_175333 (h0 : functor.add_const (ordered_add_comm_monoid (linear_order unsigned)) (option (option empty))) : @archimedean.{0} (linear_order.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (linear_order.{0} unsigned)) (option.{0} (option.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_175334 (h0 : functor.add_const (ordered_add_comm_monoid (has_neg linarith.comp)) (has_neg Type)) : @archimedean.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 1} (ordered_add_comm_monoid.{0} (has_neg.{0} linarith.comp)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_175335 (h0 : topological_space (finset (has_neg (has_add name)))) : path_connected_space (finset (has_neg (has_add name))) := sorry --non-trivial
lemma new_lemma_175336 (h0 : ordered_add_comm_monoid (has_neg num)) : archimedean (has_neg num) := sorry --non-trivial
lemma new_lemma_175337 (h0 : ring (finset (has_to_string (has_to_string pos)))) : rank_condition (finset (has_to_string (has_to_string pos))) := sorry --non-trivial
lemma new_lemma_175338 (h0 : complete_lattice (comm_semigroup (complete_distrib_lattice real))) : is_compactly_generated (comm_semigroup (complete_distrib_lattice real)) := sorry --non-trivial
lemma new_lemma_175339 (h0 : topological_space (canonically_ordered_comm_semiring (comm_group (comm_group unsigned)))) : irreducible_space (canonically_ordered_comm_semiring (comm_group (comm_group unsigned))) := sorry --non-trivial
lemma new_lemma_175340 (h0 : monoid (normed_comm_ring pos)) : monoid.fg (normed_comm_ring pos) := sorry --non-trivial
lemma new_lemma_175341 (h1 : topological_space (random_gen (comm_ring linarith.comp_source))) : t0_space (random_gen (comm_ring linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_175342 (h0 : set (add_comm_semigroup string.iterator_imp -> fun_info)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_175343 (h0 : topological_space (has_add (has_neg_part unsigned))) : loc_path_connected_space (has_add (has_neg_part unsigned)) := sorry --non-trivial
lemma new_lemma_175344 (h0 : std_gen -> std_gen -> Prop) (h1 h2 : std_gen) : eqv_gen h0 h1 h2 := sorry --non-trivial
lemma new_lemma_175345 (h0 : uniform_space (filter (option empty))) : separated_space (filter (option empty)) := sorry --non-trivial
lemma new_lemma_175346 (h0 : topological_space (ordered_comm_monoid (has_pos_part Type))) : regular_space (ordered_comm_monoid (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_175347 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (has_neg_part.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_neg_part.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_175348 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (linear_ordered_field.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_field.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_175349 (h0 : function.extfun nat fin) : @strong_rank_condition.{1} (sub_neg_monoid.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (sub_neg_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_175350 (h1 : function.extfun Type (functor.comp complete_lattice complete_semilattice_Sup)) : @is_compactly_generated.{0} (complete_semilattice_Sup.{0} linarith.comp) (@functor.comp.run.{0 0 0} complete_lattice.{0} complete_semilattice_Sup.{0} linarith.comp (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} complete_lattice.{0} complete_semilattice_Sup.{0}) h1 linarith.comp))  := sorry --non-trivial
lemma new_lemma_175351 (h0 : ordered_add_comm_monoid (semigroup (has_add (cancel_monoid ennreal)))) : archimedean (semigroup (has_add (cancel_monoid ennreal))) := sorry --non-trivial
lemma new_lemma_175352 (h1 : complete_lattice (random_gen (random_gen string_imp))) : is_atomistic (random_gen (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_175353 (h0 : functor.add_const (topological_space ennreal) num) : preirreducible_space ennreal := sorry --non-trivial
lemma new_lemma_175354 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (non_assoc_semiring.{0} num) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (non_assoc_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_175355 (h2 : not (uniform_space (with_zero to_additive.value_type) -> false)) : @complete_space.{0} (with_zero.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (uniform_space.{0} (with_zero.{0} to_additive.value_type)) h2)  := sorry --non-trivial
lemma new_lemma_175356 (h0 : functor.add_const (semiring (add_cancel_monoid ennreal)) pos) : @is_noetherian_ring.{0} (add_cancel_monoid.{0} ennreal) (@functor.add_const.run.{0 0} (semiring.{0} (add_cancel_monoid.{0} ennreal)) pos h0)  := sorry --non-trivial
lemma new_lemma_175357 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (ordered_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_group.{0} h0 (ordered_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_175358 (h0 : topological_space (finset (ring environment.implicit_infer_kind))) : t1_space (finset (ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_175359 (h0 : ring (has_ssubset (metric_space linarith.comp_source))) : strong_rank_condition (has_ssubset (metric_space linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_175360 (h0 : complete_lattice (has_bot (mul_one_class environment.projection_info))) : complete_lattice.is_Sup_finite_compact (has_bot (mul_one_class environment.projection_info)) := sorry --non-trivial
lemma new_lemma_175361 (h0 : filter (monoid (option empty))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_175362 (h0 : not (topological_space (id congr_arg_kind) -> false)) : @normal_space.{0} (@id.{2} Type congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (@id.{2} Type congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_175363 (h0 : ring (add_comm_monoid (has_neg (has_neg Type)))) : rank_condition (add_comm_monoid (has_neg (has_neg Type))) := sorry --non-trivial
lemma new_lemma_175364 (h0 : ring (has_inv (random_gen linarith.ineq))) : is_domain (has_inv (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_175365 (h0 : group (has_top (has_top (has_top to_additive.value_type)))) : is_cyclic (has_top (has_top (has_top to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_175366 (h0 : group (encodable (has_nnnorm (has_nnnorm to_additive.value_type)))) : group.fg (encodable (has_nnnorm (has_nnnorm to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_175367 (h0 : topological_space (ring (has_Inf name))) : irreducible_space (ring (has_Inf name)) := sorry --non-trivial
lemma new_lemma_175368 (h0 : function.extfun Type topological_space) : @regular_space.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_175369 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (has_emptyc.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_emptyc.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_175370 (h0 : functor.add_const (ring (free_add_monoid num)) unsigned) : @is_principal_ideal_ring.{0} (free_add_monoid.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (free_add_monoid.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_175371 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem monoid)) : @monoid.fg.{0} congr_arg_kind (@function.extfun_app.{2 1} Type monoid.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) monoid.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) monoid.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_175372 (h0 : topological_space (has_Sup (option unsigned))) : t1_space (has_Sup (option unsigned)) := sorry --non-trivial
lemma new_lemma_175373 (h0 : uniform_space (measurable_space (random_gen to_additive.value_type))) : complete_space (measurable_space (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_175374 (h0 : functor.add_const (complete_lattice (canonically_ordered_comm_semiring ennreal)) Type) : @complete_lattice.is_Sup_finite_compact.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@functor.add_const.run.{0 1} (complete_lattice.{0} (canonically_ordered_comm_semiring.{0} ennreal)) Type h0)  := sorry --non-trivial
lemma new_lemma_175375 (h0 : group (add_comm_monoid (option (option (option (option ennreal)))))) : normalizer_condition (add_comm_monoid (option (option (option (option ennreal))))) := sorry --non-trivial
lemma new_lemma_175376 (h1 : add_group (denumerable linarith.comp_source)) : is_add_cyclic (denumerable linarith.comp_source) := sorry --non-trivial
lemma new_lemma_175377 (h0 : functor.add_const (topological_space (cancel_monoid pos)) (comm_group (semigroup Type))) : @totally_separated_space.{0} (cancel_monoid.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (cancel_monoid.{0} pos)) (comm_group.{1} (semigroup.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_175378 (h0 : group (ordered_ring congr_arg_kind)) : group.fg (ordered_ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_175379 (h0 : group (group_with_zero congr_arg_kind)) : normalizer_condition (group_with_zero congr_arg_kind) := sorry --non-trivial
lemma new_lemma_175380 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (semiring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (semiring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_175381 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (has_one (has_norm congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_175382 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_union.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_union.{0} empty))  := sorry --non-trivial
lemma new_lemma_175383 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @complete_space.{1} (has_neg_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 uniform_space.{1}) (has_neg_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_175384 (h0 : functor.add_const (topological_space (mul_zero_class pos)) unsigned) : @loc_path_connected_space.{0} (mul_zero_class.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_175385 (h0 : list (with_bot (random_gen (has_ssubset linarith.ineq)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_175386 (h0 : functor.add_const (ordered_add_comm_monoid (finset name)) (boolean_algebra name)) : @archimedean.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (finset.{0} name)) (boolean_algebra.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_175387 (h0 : functor.add_const (topological_space (semigroup Type)) name) : @totally_separated_space.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (semigroup.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_175388 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_to_string.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_to_string.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_175389 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @t0_space.{0} (semiring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_175390 (h0 : not (filter (distrib_lattice string_imp) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_175391 (h0 : topological_space (ordered_comm_ring (ring Type))) : t0_space (ordered_comm_ring (ring Type)) := sorry --non-trivial
lemma new_lemma_175392 (h0 : group (semi_normed_comm_ring (mul_one_class (mul_one_class reducibility_hints)))) : is_cyclic (semi_normed_comm_ring (mul_one_class (mul_one_class reducibility_hints))) := sorry --non-trivial
lemma new_lemma_175393 (h0 : set (add_comm_semigroup char)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_175394 (h2 : complete_lattice (normed_field (random_gen char))) : is_compactly_generated (normed_field (random_gen char)) := sorry --non-trivial
lemma new_lemma_175395 (h2 : not (complete_lattice (denumerable to_additive.value_type) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (denumerable.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (complete_lattice.{0} (denumerable.{0} to_additive.value_type)) h2)  := sorry --non-trivial
lemma new_lemma_175396 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_pos_part.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_pos_part.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_175397 (h0 : function.extfun Type (functor.comp ring canonically_linear_ordered_monoid)) : @is_principal_ideal_ring.{0} (canonically_linear_ordered_monoid.{0} ennreal) (@functor.comp.run.{0 0 0} ring.{0} canonically_linear_ordered_monoid.{0} ennreal (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} ring.{0} canonically_linear_ordered_monoid.{0}) h0 ennreal))  := sorry --non-trivial
lemma new_lemma_175398 (h0 : topological_space (canonically_ordered_comm_semiring (has_add ennreal))) : locally_compact_space (canonically_ordered_comm_semiring (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_175399 (h0 : functor.add_const (group (has_to_string Type)) (has_neg environment.implicit_infer_kind)) : @group.fg.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (has_to_string.{1} Type)) (has_neg.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_175400 (h0 : function.extfun Type (functor.add_const (topological_space (add_semigroup empty)))) : @discrete_topology.{0} (add_semigroup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_semigroup.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (add_semigroup.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_175401 (h1 : not (topological_space (mul_one_class linarith.ineq) -> false)) : @t0_space.{0} (mul_one_class.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (mul_one_class.{0} linarith.ineq)) h1)  := sorry --non-trivial
lemma new_lemma_175402 (h0 : functor.add_const (topological_space (finset empty)) unsigned) : @totally_separated_space.{0} (finset.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_175403 (h0 : topological_space (has_top std_gen)) : path_connected_space (has_top std_gen) := sorry --non-trivial
lemma new_lemma_175404 (h0 : topological_space (linear_ordered_field ennreal)) : topological_space.separable_space (linear_ordered_field ennreal) := sorry --non-trivial
lemma new_lemma_175405 (h0 : not (topological_space (random_gen string.iterator_imp) -> false)) : @t0_space.{0} (random_gen.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (topological_space.{0} (random_gen.{0} string.iterator_imp)) h0)  := sorry --non-trivial
lemma new_lemma_175406 (h0 : group (has_norm (random_gen linarith.comp_source))) : is_cyclic (has_norm (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_175407 (h2 : measurable_space (nondiscrete_normed_field fun_info)) (h3 : measure_theory.measure (nondiscrete_normed_field fun_info)) : measure_theory.is_finite_measure h3 := sorry --non-trivial
lemma new_lemma_175408 (h0 : ordered_add_comm_monoid (linear_ordered_field (option unsigned))) : archimedean (linear_ordered_field (option unsigned)) := sorry --non-trivial
lemma new_lemma_175409 (h0 : list (dlist fun_info)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_175410 (h0 : function.extfun Type (functor.comp topological_space has_to_string)) : @locally_compact_space.{0} (has_to_string.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} has_to_string.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} has_to_string.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_175411 (h0 : group (has_norm (has_nnnorm (denumerable fun_info)))) : group.fg (has_norm (has_nnnorm (denumerable fun_info))) := sorry --non-trivial
lemma new_lemma_175412 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (boolean_algebra.core.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_175413 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (has_norm.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_norm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_175414 (h0 : ring (with_one (has_top (has_top fun_info)))) : strong_rank_condition (with_one (has_top (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_175415 (h0 : function.extfun Type topological_space) : @t0_space.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_175416 (h0 : functor.add_const Prop (has_add Type)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_175417 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_simple_group.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_175418 (h0 : add_monoid (canonically_ordered_monoid (has_Inf pos))) : add_monoid.fg (canonically_ordered_monoid (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_175419 (h0 : topological_space (topological_space (has_ssubset char))) : totally_disconnected_space (topological_space (has_ssubset char)) := sorry --non-trivial
lemma new_lemma_175420 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_simple_group.{0} (normed_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (normed_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_175421 (h0 : not (group (has_ssubset char) -> false)) : @group.fg.{0} (has_ssubset.{0} char) (@classical.by_contradiction'.{1} (group.{0} (has_ssubset.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_175422 (h1 : filter (has_norm string_imp)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_175423 (h0 : topological_space (distrib string.iterator_imp)) : t0_space (distrib string.iterator_imp) := sorry --non-trivial
lemma new_lemma_175424 (h0 h2 : multiset (add_comm_semigroup (add_comm_semigroup ereal))) : multiset.le h0 h2 := sorry --non-trivial
lemma new_lemma_175425 (h0 : functor.add_const Prop (id empty)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_175426 (h0 : ring (has_append (random_gen (random_gen reducibility_hints)))) : rank_condition (has_append (random_gen (random_gen reducibility_hints))) := sorry --non-trivial
lemma new_lemma_175427 (h0 : ring (mul_zero_class (finset name))) : rank_condition (mul_zero_class (finset name)) := sorry --non-trivial
lemma new_lemma_175428 (h0 : group (add_comm_monoid ennreal)) : normalizer_condition (add_comm_monoid ennreal) := sorry --non-trivial
lemma new_lemma_175429 (h0 : function.extfun Type (functor.add_const (topological_space pos))) : @normal_space.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) name (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} pos)) h0 name))  := sorry --non-trivial
lemma new_lemma_175430 (h0 : functor.add_const (function.extfun (Type 1) group) pos) : @is_cyclic.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) group.{1}) pos h0) (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_175431 (h0 : semiring (canonically_ordered_monoid (has_pos_part pos))) : is_noetherian_ring (canonically_ordered_monoid (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_175432 (h0 : ring (linear_ordered_comm_group ennreal)) : strong_rank_condition (linear_ordered_comm_group ennreal) := sorry --non-trivial
lemma new_lemma_175433 (h0 : not (semiring (complete_semilattice_Sup unsigned) -> false)) : @is_noetherian_ring.{0} (complete_semilattice_Sup.{0} unsigned) (@classical.by_contradiction'.{1} (semiring.{0} (complete_semilattice_Sup.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_175434 (h0 : topological_space (ordered_cancel_add_comm_monoid (option empty))) : t1_space (ordered_cancel_add_comm_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_175435 (h0 : add_group (mul_one_class environment.projection_info)) : is_add_cyclic (mul_one_class environment.projection_info) := sorry --non-trivial
lemma new_lemma_175436 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (normed_group.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (normed_group.{0} num))  := sorry --non-trivial
lemma new_lemma_175437 (h1 : ring (non_unital_non_assoc_semiring linarith.comp_source)) : rank_condition (non_unital_non_assoc_semiring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_175438 (h0 : functor.add_const (list (canonically_ordered_comm_semiring name)) pos) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_175439 (h2 : list (complete_semilattice_Sup linarith.comp_source)) : list.nodup h2 := sorry --non-trivial
lemma new_lemma_175440 (h0 : not (cancel_comm_monoid_with_zero (add_right_cancel_monoid congr_arg_kind) -> false)) : @unique_factorization_monoid.{0} (add_right_cancel_monoid.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (cancel_comm_monoid_with_zero.{0} (add_right_cancel_monoid.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_175441 (h0 : topological_space (ordered_comm_monoid (boolean_algebra.core (ring (has_pos_part (has_add Type)))))) : discrete_topology (ordered_comm_monoid (boolean_algebra.core (ring (has_pos_part (has_add Type))))) := sorry --non-trivial
lemma new_lemma_175442 (h0 : functor.const Prop fun_info) : functor.const.run h0 := sorry --non-trivial
lemma new_lemma_175443 (h0 : not (uniform_space to_additive.value_type -> false)) : @separated_space.{0} to_additive.value_type (@classical.by_contradiction'.{1} (uniform_space.{0} to_additive.value_type) h0)  := sorry --non-trivial
lemma new_lemma_175444 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_norm.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_norm.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_175445 (h0 : topological_space (has_neg (has_add (has_add unsigned)))) : topological_space.separable_space (has_neg (has_add (has_add unsigned))) := sorry --non-trivial
lemma new_lemma_175446 (h0 : set (add_comm_semigroup (add_comm_semigroup linarith.ineq) -> enat)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_175447 (h0 : list (complete_semilattice_Sup (has_top (random_gen string_imp)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_175448 (h0 : list (add_cancel_monoid (has_zero linarith.comp))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_175449 (h0 : finset (left_cancel_semigroup (semiring (semiring unsigned)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_175450 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (has_emptyc.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_emptyc.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_175451 (h2 : group (has_top char)) : is_cyclic (has_top char) := sorry --non-trivial
lemma new_lemma_175452 (h0 : complete_lattice (with_one (semiring (semiring linarith.comp)))) : is_atomistic (with_one (semiring (semiring linarith.comp))) := sorry --non-trivial
lemma new_lemma_175453 (h0 : monoid (has_Inf (ring name))) : monoid.fg (has_Inf (ring name)) := sorry --non-trivial
lemma new_lemma_175454 (h0 : not (function.extfun Type topological_space -> false)) : @totally_separated_space.{0} (with_bot.{0} (has_norm.{0} (has_norm.{0} (has_norm.{0} (has_norm.{0} empty))))) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (with_bot.{0} (has_norm.{0} (has_norm.{0} (has_norm.{0} (has_norm.{0} empty))))))  := sorry --non-trivial
lemma new_lemma_175455 (h0 : ring (normed_group to_additive.value_type)) : rank_condition (normed_group to_additive.value_type) := sorry --non-trivial
lemma new_lemma_175456 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_inter.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_inter.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_175457 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_emptyc.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (has_emptyc.{0} num))  := sorry --non-trivial
lemma new_lemma_175458 (h1 : topological_space linarith.comp) : totally_disconnected_space linarith.comp := sorry --non-trivial
lemma new_lemma_175459 (h0 : functor.add_const (ring (free_add_monoid num)) unsigned) : @strong_rank_condition.{0} (free_add_monoid.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (free_add_monoid.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_175460 (h0 : topological_space (has_compl (mul_one_class (comm_ring char)))) : t0_space (has_compl (mul_one_class (comm_ring char))) := sorry --non-trivial
lemma new_lemma_175461 (h0 : topological_space (mul_zero_class (has_nndist pos))) : preirreducible_space (mul_zero_class (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_175462 (h0 : set (semi_normed_ring to_additive.value_type)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_175463 (h0 : functor.add_const (topological_space (comm_group name)) (comm_group name)) : @discrete_topology.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} name)) (comm_group.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_175464 (h0 : topological_space char) : locally_compact_space char := sorry --non-trivial
lemma new_lemma_175465 (h0 : function.extfun Type (functor.add_const (group (has_edist empty)))) : @normalizer_condition.{0} (has_edist.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (has_edist.{0} empty)) (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} empty)))))))) (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (group.{0} (has_edist.{0} empty))) h0 (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} empty))))))))))  := sorry --non-trivial
lemma new_lemma_175466 (h0 : functor.add_const (topological_space (preorder unsigned)) unsigned) : @preirreducible_space.{0} (preorder.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (preorder.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_175467 (h0 : topological_space (ring (ring Type))) : path_connected_space (ring (ring Type)) := sorry --non-trivial
lemma new_lemma_175468 (h0 : ring (mul_one_class (normed_field enat))) : strong_rank_condition (mul_one_class (normed_field enat)) := sorry --non-trivial
lemma new_lemma_175469 (h0 : topological_space (normed_group (random_gen (random_gen (has_norm fun_info))))) : locally_compact_space (normed_group (random_gen (random_gen (has_norm fun_info)))) := sorry --non-trivial
lemma new_lemma_175470 (h0 : topological_space (ring (boolean_algebra (finset (boolean_algebra Type))))) : totally_disconnected_space (ring (boolean_algebra (finset (boolean_algebra Type)))) := sorry --non-trivial
lemma new_lemma_175471 (h0 : group (add_cancel_monoid pos)) : group.fg (add_cancel_monoid pos) := sorry --non-trivial
lemma new_lemma_175472 (h0 : group (has_inv (random_gen (random_gen (random_gen fun_info))))) : is_cyclic (has_inv (random_gen (random_gen (random_gen fun_info)))) := sorry --non-trivial
lemma new_lemma_175473 (h0 : has_mem.mem (with_bot linarith.comp_source) has_emptyc.emptyc) : @is_atomistic.{0} (with_bot.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (with_bot.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_175474 (h0 : functor.add_const (topological_space (bin_tree empty)) empty) : @discrete_topology.{0} (bin_tree.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (bin_tree.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_175475 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (has_bot.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_bot.{0} real))  := sorry --non-trivial
lemma new_lemma_175476 (h0 : topological_space (mul_one_class (mul_one_class string.iterator_imp))) : totally_disconnected_space (mul_one_class (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_175477 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (normed_linear_ordered_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_linear_ordered_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_175478 (h0 : measurable_space num -> Prop) : zzz_forall h0 := sorry --non-trivial
lemma new_lemma_175479 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} name (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) name)  := sorry --non-trivial
lemma new_lemma_175480 (h0 : functor.comp uniform_space complete_distrib_lattice name) : @separated_space.{0} (complete_distrib_lattice.{0} name) (@functor.comp.run.{0 0 0} uniform_space.{0} complete_distrib_lattice.{0} name h0)  := sorry --non-trivial
lemma new_lemma_175481 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (@id.{2} Type num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (@id.{2} Type num))  := sorry --non-trivial
lemma new_lemma_175482 (h0 : ring (has_zero (has_to_string pos))) : is_domain (has_zero (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_175483 (h0 : topological_space (canonically_linear_ordered_monoid (ordered_comm_monoid real))) : discrete_topology (canonically_linear_ordered_monoid (ordered_comm_monoid real)) := sorry --non-trivial
lemma new_lemma_175484 (h0 : filter (boolean_algebra (ring (finset environment.implicit_infer_kind)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_175485 (h0 : topological_space (semigroup (canonically_ordered_comm_semiring unsigned))) : irreducible_space (semigroup (canonically_ordered_comm_semiring unsigned)) := sorry --non-trivial
lemma new_lemma_175486 (h0 : topological_space (canonically_ordered_add_monoid (option empty))) : loc_path_connected_space (canonically_ordered_add_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_175487 (h0 : functor.add_const Prop (ring (cancel_monoid pos))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_175488 (h1 : not (complete_lattice (with_one linarith.comp_source) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (with_one.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (complete_lattice.{0} (with_one.{0} linarith.comp_source)) h1)  := sorry --non-trivial
lemma new_lemma_175489 (h0 : functor.comp topological_space add_cancel_monoid environment.implicit_infer_kind) : @totally_disconnected_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} add_cancel_monoid.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_175490 (h0 : group (add_comm_monoid (has_to_string (ring (finset linarith.comp))))) : normalizer_condition (add_comm_monoid (has_to_string (ring (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_175491 (h0 : complete_lattice (finset (has_add (has_add linarith.comp)))) : is_compactly_generated (finset (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_175492 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (has_inter.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inter.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_175493 (h0 : group (has_bot (has_add (has_Inf pos)))) : is_cyclic (has_bot (has_add (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_175494 (h0 : topological_space (has_inv (has_norm linarith.comp_source))) : t0_space (has_inv (has_norm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_175495 (h0 : uniform_space (left_cancel_semigroup empty)) : complete_space (left_cancel_semigroup empty) := sorry --non-trivial
lemma new_lemma_175496 (h0 : topological_space (comm_group (finset (has_neg (finset linarith.comp))))) : locally_compact_space (comm_group (finset (has_neg (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_175497 (h0 : semiring (has_well_founded unsigned)) : is_noetherian_ring (has_well_founded unsigned) := sorry --non-trivial
lemma new_lemma_175498 (h0 : group (has_emptyc (has_top (has_top (has_top to_additive.value_type))))) : normalizer_condition (has_emptyc (has_top (has_top (has_top to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_175499 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (ordered_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_175500 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (add_left_cancel_semigroup.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} h0 (add_left_cancel_semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_175501 (h0 : topological_space (random_gen (random_gen empty))) : totally_disconnected_space (random_gen (random_gen empty)) := sorry --non-trivial
lemma new_lemma_175502 (h0 : uniform_space (canonically_ordered_comm_semiring (option unsigned))) : separated_space (canonically_ordered_comm_semiring (option unsigned)) := sorry --non-trivial
lemma new_lemma_175503 (h0 : functor.add_const (functor.add_const (topological_space nnreal) num) empty) : normal_space nnreal := sorry --non-trivial
lemma new_lemma_175504 (h0 : functor.add_const (list (add_cancel_monoid Type)) pos) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_175505 (h0 : functor.add_const (group (boolean_algebra pos)) environment.implicit_infer_kind) : @group.fg.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_175506 (h0 : ring (bin_tree empty)) : is_principal_ideal_ring (bin_tree empty) := sorry --non-trivial
lemma new_lemma_175507 (h0 : functor.add_const (filter (has_add unsigned)) Type) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_175508 (h1 : has_mem.mem monoid has_emptyc.emptyc) : @monoid.fg.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type monoid.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) monoid.{0} h1) (complete_semilattice_Sup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_175509 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (dlist.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (dlist.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_175510 (h0 : functor.comp topological_space normed_comm_ring pos) : @path_connected_space.{0} (normed_comm_ring.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} normed_comm_ring.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_175511 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (canonically_ordered_add_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (canonically_ordered_add_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_175512 (h0 : topological_space (ordered_comm_ring (has_add real))) : preconnected_space (ordered_comm_ring (has_add real)) := sorry --non-trivial
lemma new_lemma_175513 (h0 : complete_lattice (has_emptyc empty)) : is_atomistic (has_emptyc empty) := sorry --non-trivial
lemma new_lemma_175514 (h2 : add_group (simple_graph ereal)) : is_add_cyclic (simple_graph ereal) := sorry --non-trivial
lemma new_lemma_175515 (h0 : not (function.extfun Type monoid -> false)) : @monoid.fg.{0} (linear_ordered_semiring.{0} num) (@function.extfun_app.{2 1} Type monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type monoid.{0}) h0) (linear_ordered_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_175516 (h0 : group (has_dist empty)) : normalizer_condition (has_dist empty) := sorry --non-trivial
lemma new_lemma_175517 (h0 : group (semigroup (finset (finset linarith.comp)))) : is_simple_group (semigroup (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_175518 (h0 : fin has_zero.zero) : @discrete_topology.{1} (has_pos_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@matrix.vec_empty.{2} (function.extfun.{3 2} (Type 1) topological_space.{1}) h0) (has_pos_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_175519 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (normed_comm_ring.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (normed_comm_ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_175520 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_175521 (h0 : topological_space (comm_ring (denumerable (has_top string_imp)))) : t0_space (comm_ring (denumerable (has_top string_imp))) := sorry --non-trivial
lemma new_lemma_175522 (h0 : add_monoid (comm_group name)) : add_monoid.fg (comm_group name) := sorry --non-trivial
lemma new_lemma_175523 (h0 : topological_space (non_unital_non_assoc_semiring string.iterator_imp)) (h1 : preorder (non_unital_non_assoc_semiring string.iterator_imp)) : order_topology (non_unital_non_assoc_semiring string.iterator_imp) := sorry --non-trivial
lemma new_lemma_175524 (h0 : functor.add_const (topological_space (ordered_comm_ring name)) (ring (ring (ring name)))) : @discrete_topology.{0} (ordered_comm_ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} name)) (ring.{0} (ring.{0} (ring.{0} name))) h0)  := sorry --non-trivial
lemma new_lemma_175525 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_group.{0} h0 (ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_175526 (h0 : functor.add_const (topological_space (cancel_monoid pos)) (comm_group Type)) : @regular_space.{0} (cancel_monoid.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (cancel_monoid.{0} pos)) (comm_group.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_175527 (h0 : functor.add_const (list (complete_distrib_lattice environment.implicit_infer_kind)) name) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_175528 (h0 : topological_space (has_nndist (has_neg (finset (ring pos))))) : preconnected_space (has_nndist (has_neg (finset (ring pos)))) := sorry --non-trivial
lemma new_lemma_175529 (h0 : not (ring (with_bot unsigned) -> false)) : @is_domain.{0} (with_bot.{0} unsigned) (@classical.by_contradiction'.{1} (ring.{0} (with_bot.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_175530 (h0 : topological_space (has_union (semiring (semiring (semiring empty))))) : normal_space (has_union (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_175531 (h0 : topological_space pos) : loc_path_connected_space pos := sorry --non-trivial
lemma new_lemma_175532 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (has_add.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_add.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_175533 (h0 : functor.add_const (group (add_cancel_monoid pos)) (has_neg linarith.comp)) : @is_simple_group.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (add_cancel_monoid.{0} pos)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_175534 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (add_left_cancel_semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_left_cancel_semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_175535 (h0 : functor.add_const (cancel_comm_monoid_with_zero (semigroup Type)) Type) : @unique_factorization_monoid.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 1} (cancel_comm_monoid_with_zero.{1} (semigroup.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_175536 (h0 : functor.add_const (monoid (has_edist empty)) (semiring unsigned)) : @monoid.fg.{0} (has_edist.{0} empty) (@functor.add_const.run.{0 0} (monoid.{0} (has_edist.{0} empty)) (semiring.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_175537 (h0 : ring (finset (has_pos_part pos))) : is_domain (finset (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_175538 (h0 : monoid (has_top (semiring (semiring unsigned)))) : monoid.fg (has_top (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_175539 (h0 : topological_space (cancel_monoid (comm_group (has_add unsigned)))) : sequential_space (cancel_monoid (comm_group (has_add unsigned))) := sorry --non-trivial
lemma new_lemma_175540 (h0 : functor.add_const (cancel_comm_monoid_with_zero (ordered_comm_ring pos)) (finset linarith.comp)) : @unique_factorization_monoid.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (ordered_comm_ring.{0} pos)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_175541 (h0 : fin has_zero.zero) : @complete_space.{0} (has_Inf.{0} real) (@function.extfun_app.{2 1} Type uniform_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type uniform_space.{0}) h0) (has_Inf.{0} real))  := sorry --non-trivial
lemma new_lemma_175542 (h0 : ring (bin_tree (semiring num))) : is_principal_ideal_ring (bin_tree (semiring num)) := sorry --non-trivial
lemma new_lemma_175543 (h0 : add_monoid (boolean_algebra.core (finset name))) : add_monoid.fg (boolean_algebra.core (finset name)) := sorry --non-trivial
lemma new_lemma_175544 (h0 : finset (non_assoc_semiring (semiring empty))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_175545 (h0 : functor.add_const (topological_space (has_nndist name)) linarith.comp) : @t0_space.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_175546 (h0 : functor.add_const (topological_space (has_zero unsigned)) pos) : @totally_disconnected_space.{0} (has_zero.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_175547 (h0 : functor.add_const (topological_space (ordered_ring congr_arg_kind)) num) : @discrete_topology.{0} (ordered_ring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_175548 (h0 : topological_space (sub_neg_monoid (ordered_comm_monoid pos))) : totally_separated_space (sub_neg_monoid (ordered_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_175549 (h0 : set (has_le (mul_one_class string_imp))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_175550 (h0 : topological_space (has_zero num)) : totally_disconnected_space (has_zero num) := sorry --non-trivial
lemma new_lemma_175551 (h0 : functor.add_const (topological_space (complete_distrib_lattice pos)) name) : @totally_disconnected_space.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_175552 (h0 : topological_space (simple_graph (has_compl (distrib (semi_normed_ring (with_one (distrib fun_info))))))) : t0_space (simple_graph (has_compl (distrib (semi_normed_ring (with_one (distrib fun_info)))))) := sorry --non-trivial
lemma new_lemma_175553 (h1 : not (ring (linear_ordered_add_comm_group linarith.ineq) -> false)) : @is_domain.{0} (linear_ordered_add_comm_group.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (linear_ordered_add_comm_group.{0} linarith.ineq)) h1)  := sorry --non-trivial
lemma new_lemma_175554 (h0 : functor.add_const (topological_space (add_cancel_monoid empty)) num) : @totally_disconnected_space.{0} (add_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_175555 (h0 : topological_space (random_gen (has_top (has_top (has_top num))))) : totally_disconnected_space (random_gen (has_top (has_top (has_top num)))) := sorry --non-trivial
lemma new_lemma_175556 (h2 : group (dlist to_additive.value_type)) : is_cyclic (dlist to_additive.value_type) := sorry --non-trivial
lemma new_lemma_175557 (h0 : group (comm_group (add_comm_monoid pos))) : group.fg (comm_group (add_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_175558 (h0 : group (has_bot pos)) : normalizer_condition (has_bot pos) := sorry --non-trivial
lemma new_lemma_175559 (h0 : functor.add_const (topological_space (has_neg pos)) (has_add Type)) : @totally_separated_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg.{0} pos)) (has_add.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_175560 (h0 : topological_space (ring pos)) : normal_space (ring pos) := sorry --non-trivial
lemma new_lemma_175561 (h1 : add_group (comm_ring to_additive.value_type)) : is_add_cyclic (comm_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_175562 (h0 : ring (canonically_ordered_monoid (has_add (sub_neg_monoid name)))) : rank_condition (canonically_ordered_monoid (has_add (sub_neg_monoid name))) := sorry --non-trivial
lemma new_lemma_175563 (h0 : functor.add_const (semiring (add_comm_monoid pos)) Type) : @is_noetherian_ring.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 1} (semiring.{0} (add_comm_monoid.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_175564 (h0 : uniform_space (comm_monoid unsigned)) : complete_space (comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_175565 (h0 : measurable_space (simple_graph enat)) (h1 : filter (simple_graph enat)) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_175566 (h0 : topological_space (has_add (has_bot (has_add (has_add (has_add real)))))) : irreducible_space (has_add (has_bot (has_add (has_add (has_add real))))) := sorry --non-trivial
lemma new_lemma_175567 (h0 : topological_space (has_to_string (has_Inf (has_Inf pos)))) : path_connected_space (has_to_string (has_Inf (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_175568 (h0 : ordered_add_comm_monoid (linear_ordered_comm_group congr_arg_kind)) : archimedean (linear_ordered_comm_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_175569 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_175570 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (has_neg_part environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_175571 (h0 : group (complete_distrib_lattice name)) : is_cyclic (complete_distrib_lattice name) := sorry --non-trivial
lemma new_lemma_175572 (h0 : function.extfun Type (functor.add_const (topological_space (has_Sup congr_arg_kind)))) : @preirreducible_space.{0} (has_Sup.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Sup.{0} congr_arg_kind)) congr_arg_kind (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (has_Sup.{0} congr_arg_kind))) h0 congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_175573 (h1 : monoid string_imp) (h2 : not (topological_space (star_monoid string_imp) -> false)) : @t0_space.{0} (@star_monoid.{0} string_imp h1) (@classical.by_contradiction'.{1} (topological_space.{0} (@star_monoid.{0} string_imp h1)) h2)  := sorry --non-trivial
lemma new_lemma_175574 (h0 : function.extfun Type (functor.add_const (complete_lattice (ordered_semiring unsigned)))) : @is_compactly_generated.{0} (ordered_semiring.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ordered_semiring.{0} unsigned)) pos (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (complete_lattice.{0} (ordered_semiring.{0} unsigned))) h0 pos))  := sorry --non-trivial
lemma new_lemma_175575 (h0 : functor.add_const (topological_space (has_to_string pos)) linarith.comp) : @preconnected_space.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_175576 (h1 : has_lt (add_comm_semigroup string.iterator_imp)) : no_max_order (add_comm_semigroup string.iterator_imp) := sorry --non-trivial
lemma new_lemma_175577 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @normal_space.{0} (generalized_boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (generalized_boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_175578 (h0 : group (measurable_space congr_arg_kind)) : group.fg (measurable_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_175579 (h1 : uniform_space (has_top (with_bot to_additive.value_type))) : complete_space (has_top (with_bot to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_175580 (h0 : topological_space (has_neg (has_add pos))) : t0_space (has_neg (has_add pos)) := sorry --non-trivial
lemma new_lemma_175581 (h0 : uniform_space (has_nndist (has_neg_part name))) : separated_space (has_nndist (has_neg_part name)) := sorry --non-trivial
lemma new_lemma_175582 (h0 : group (complete_distrib_lattice (finset name))) : normalizer_condition (complete_distrib_lattice (finset name)) := sorry --non-trivial
lemma new_lemma_175583 (h0 : not (ring (has_div string.iterator_imp) -> false)) : @is_domain.{0} (has_div.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (ring.{0} (has_div.{0} string.iterator_imp)) h0)  := sorry --non-trivial
lemma new_lemma_175584 (h0 : functor.comp topological_space finset ennreal) : @t1_space.{0} (finset.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} finset.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_175585 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} (linear_ordered_semiring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (linear_ordered_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_175586 (h0 : topological_space (has_bot (comm_semigroup real))) : preirreducible_space (has_bot (comm_semigroup real)) := sorry --non-trivial
lemma new_lemma_175587 (h0 : uniform_space (preorder (semiring num))) : complete_space (preorder (semiring num)) := sorry --non-trivial
lemma new_lemma_175588 (h0 : has_lt (mul_one_class (cancel_monoid (add_comm_semigroup fun_info)))) : no_max_order (mul_one_class (cancel_monoid (add_comm_semigroup fun_info))) := sorry --non-trivial
lemma new_lemma_175589 (h1 : group reducibility_hints) : is_cyclic reducibility_hints := sorry --non-trivial
lemma new_lemma_175590 (h0 : topological_space (add_comm_monoid (boolean_algebra unsigned))) : totally_disconnected_space (add_comm_monoid (boolean_algebra unsigned)) := sorry --non-trivial
lemma new_lemma_175591 (h1 : ring (semi_normed_ring fun_info)) : rank_condition (semi_normed_ring fun_info) := sorry --non-trivial
lemma new_lemma_175592 (h0 : topological_space (has_emptyc fun_info)) : totally_separated_space (has_emptyc fun_info) := sorry --non-trivial
lemma new_lemma_175593 (h0 : uniform_space (plift (semiring (semiring (semiring (semiring unsigned)))))) : separated_space (plift (semiring (semiring (semiring (semiring unsigned))))) := sorry --non-trivial
lemma new_lemma_175594 (h0 : cancel_comm_monoid_with_zero (finset (has_neg Type))) : unique_factorization_monoid (finset (has_neg Type)) := sorry --non-trivial
lemma new_lemma_175595 (h0 : ring (add_right_cancel_monoid congr_arg_kind)) : rank_condition (add_right_cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_175596 (h0 : add_monoid (ring (ring Type))) : add_monoid.fg (ring (ring Type)) := sorry --non-trivial
lemma new_lemma_175597 (h0 : functor.add_const (topological_space (normed_linear_ordered_group empty)) num) : @t1_space.{0} (normed_linear_ordered_group.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_linear_ordered_group.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_175598 (h0 : complete_lattice (complete_semilattice_Sup (random_gen (random_gen linarith.comp_source)))) : is_atomistic (complete_semilattice_Sup (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_175599 (h0 : functor.add_const (functor.add_const (add_group (complete_linear_order unsigned)) empty) num) : @is_add_cyclic.{0} (complete_linear_order.{0} unsigned) (@functor.add_const.run.{0 0} (add_group.{0} (complete_linear_order.{0} unsigned)) empty (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (add_group.{0} (complete_linear_order.{0} unsigned)) empty) num h0))  := sorry --non-trivial
lemma new_lemma_175600 (h0 : ring (simple_graph (bin_tree string.iterator_imp))) : is_domain (simple_graph (bin_tree string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_175601 (h0 : uniform_space (has_pos_part (has_Inf pos))) : complete_space (has_pos_part (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_175602 (h0 : ring (ordered_comm_ring (has_Inf pos))) : is_principal_ideal_ring (ordered_comm_ring (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_175603 (h0 : ring (add_monoid char)) : rank_condition (add_monoid char) := sorry --non-trivial
lemma new_lemma_175604 (h0 : functor.add_const (function.extfun Type ring) (semigroup (finset linarith.comp))) : @is_principal_ideal_ring.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) (semigroup.{0} (finset.{0} linarith.comp)) h0) (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_175605 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} (has_norm.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (has_norm.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_175606 (h0 : topological_space (has_nndist (has_add environment.implicit_infer_kind))) : irreducible_space (has_nndist (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_175607 (h0 : functor.add_const (function.extfun (Type 1) topological_space) linarith.comp) : @loc_path_connected_space.{1} (complete_distrib_lattice.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) linarith.comp h0) (complete_distrib_lattice.{1} Type))  := sorry --non-trivial
lemma new_lemma_175608 (h0 : filter (group_with_zero (option unsigned))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_175609 (h0 : function.extfun (Type 1) add_monoid) : @add_monoid.fg.{1} (normed_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_monoid.{1} h0 (normed_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_175610 (h0 : topological_space (has_top (has_inv linarith.ineq))) : totally_separated_space (has_top (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_175611 (h0 : list (cancel_monoid (comm_group (comm_group environment.implicit_infer_kind)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_175612 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (option.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (option.{0} num))  := sorry --non-trivial
lemma new_lemma_175613 (h0 : group (with_bot (has_norm to_additive.value_type))) : is_cyclic (with_bot (has_norm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_175614 (h0 : functor.add_const (monoid (semigroup Type)) linarith.comp) : @monoid.fg.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (monoid.{1} (semigroup.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_175615 (h0 : functor.add_const (complete_lattice (has_add pos)) (has_add unsigned)) : @complete_lattice.is_Sup_finite_compact.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_add.{0} pos)) (has_add.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_175616 (h0 : topological_space (ring (has_add (has_add (has_add (has_add (has_add Type))))))) : irreducible_space (ring (has_add (has_add (has_add (has_add (has_add Type)))))) := sorry --non-trivial
lemma new_lemma_175617 (h0 : functor.add_const (topological_space int) Type) : discrete_topology int := sorry --non-trivial
lemma new_lemma_175618 (h0 : topological_space (lex empty)) : topological_space.separable_space (lex empty) := sorry --non-trivial
lemma new_lemma_175619 (h0 : function.extfun (Type 1) (functor.comp add_group add_comm_monoid)) : @is_add_cyclic.{1} (add_comm_monoid.{1} Type) (@functor.comp.run.{1 1 1} add_group.{1} add_comm_monoid.{1} Type (@function.extfun_app.{3 2} (Type 1) (functor.comp.{1 1 1} add_group.{1} add_comm_monoid.{1}) h0 Type))  := sorry --non-trivial
lemma new_lemma_175620 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_simple_group.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_175621 (h0 : has_mem.mem (random_gen linarith.ineq) has_emptyc.emptyc) : @normalizer_condition.{0} (random_gen.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type group.{0} (random_gen.{0} linarith.ineq) h0)  := sorry --non-trivial
lemma new_lemma_175622 (h0 : not (topological_space (add_right_cancel_monoid congr_arg_kind) -> false)) : @totally_separated_space.{0} (add_right_cancel_monoid.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (add_right_cancel_monoid.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_175623 (h0 : filter (has_Inf (has_add pos))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_175624 (h0 : fin has_zero.zero) : @is_principal_ideal_ring.{0} (canonically_ordered_monoid.{0} pos) (@matrix.vec_empty.{0} (ring.{0} (canonically_ordered_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_175625 (h0 : functor.add_const (uniform_space (add_cancel_monoid pos)) Type) : @complete_space.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 1} (uniform_space.{0} (add_cancel_monoid.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_175626 (h0 : function.extfun Type topological_space) : @t1_space.{0} (has_add.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_175627 (h0 : ring (finset (finset (has_add (has_add pos))))) : rank_condition (finset (finset (has_add (has_add pos)))) := sorry --non-trivial
lemma new_lemma_175628 (h0 : ring (add_comm_monoid (comm_group unsigned))) : is_principal_ideal_ring (add_comm_monoid (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_175629 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} auto.case_option (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) auto.case_option)  := sorry --non-trivial
lemma new_lemma_175630 (h0 : ring (simple_graph string_imp)) : strong_rank_condition (simple_graph string_imp) := sorry --non-trivial
lemma new_lemma_175631 (h0 : fin has_zero.zero) : @path_connected_space.{0} (ordered_comm_ring.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_ring.{0} pos)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)))  := sorry --non-trivial
lemma new_lemma_175632 (h0 : monoid (has_norm (semiring (semiring (semiring unsigned))))) : monoid.fg (has_norm (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_175633 (h0 : set (mul_one_class char -> mul_one_class (pseudo_metric_space unsigned))) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_175634 (h0 : cancel_comm_monoid_with_zero (has_top empty)) : unique_factorization_monoid (has_top empty) := sorry --non-trivial
lemma new_lemma_175635 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (option.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (option.{0} num))  := sorry --non-trivial
lemma new_lemma_175636 (h0 : not (function.extfun Type topological_space -> false)) : @irreducible_space.{0} (linear_ordered_comm_ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (linear_ordered_comm_ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_175637 (h0 : topological_space (has_add (has_nndist (has_to_string (has_to_string (has_to_string pos)))))) : loc_path_connected_space (has_add (has_nndist (has_to_string (has_to_string (has_to_string pos))))) := sorry --non-trivial
lemma new_lemma_175638 (h0 : topological_space (ordered_semiring environment.implicit_infer_kind)) : loc_path_connected_space (ordered_semiring environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_175639 (h0 : not (topological_space (metric_space linarith.comp) -> false)) : @path_connected_space.{0} (metric_space.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (metric_space.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_175640 (h0 : fin has_zero.zero) : @add_monoid.fg.{0} stieltjes_function (@matrix.vec_empty.{0} (add_monoid.{0} stieltjes_function) h0)  := sorry --non-trivial
lemma new_lemma_175641 (h0 : topological_space (has_add (has_add (has_neg (finset Type))))) : t1_space (has_add (has_add (has_neg (finset Type)))) := sorry --non-trivial
lemma new_lemma_175642 (h0 : functor.add_const (topological_space (add_cancel_monoid empty)) congr_arg_kind) : @totally_separated_space.{0} (add_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_175643 (h0 : functor.add_const (topological_space (mul_zero_class congr_arg_kind)) num) : @t0_space.{0} (mul_zero_class.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_175644 (h0 : comm_semiring (canonically_ordered_monoid Type)) (h1 : polynomial (canonically_ordered_monoid Type)) : polynomial.separable h1 := sorry --non-trivial
lemma new_lemma_175645 (h0 : function.extfun nat fin) : @locally_compact_space.{1} (ordered_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (ordered_comm_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_175646 (h0 : ring (with_one (semiring (semiring unsigned)))) : is_domain (with_one (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_175647 (h0 : complete_lattice (with_one linarith.comp)) : is_atomistic (with_one linarith.comp) := sorry --non-trivial
lemma new_lemma_175648 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (has_inter.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_inter.{0} empty))  := sorry --non-trivial
lemma new_lemma_175649 (h0 : functor.add_const (functor.comp complete_lattice finset name) Type) : @is_atomistic.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (finset.{0} name)) name (@functor.comp.run.{0 0 0} complete_lattice.{0} finset.{0} name (@functor.add_const.run.{0 1} (functor.comp.{0 0 0} complete_lattice.{0} finset.{0} name) Type h0)))  := sorry --non-trivial
lemma new_lemma_175650 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_175651 (h0 : complete_lattice (has_top (comm_ring (has_inv to_additive.value_type)))) : is_compactly_generated (has_top (comm_ring (has_inv to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_175652 (h0 : functor.comp ring complete_distrib_lattice environment.implicit_infer_kind) : @is_domain.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} ring.{0} complete_distrib_lattice.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_175653 (h0 : function.extfun nat fin) : @archimedean.{0} (ordered_comm_ring.{0} real) (@matrix.vec_empty.{0} (ordered_add_comm_monoid.{0} (ordered_comm_ring.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_175654 (h0 : not (topological_space (plift congr_arg_kind) -> false)) : @totally_disconnected_space.{1} (plift.{1} congr_arg_kind) (@classical.by_contradiction'.{2} (topological_space.{1} (plift.{1} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_175655 (h0 : ring (denumerable (normed_lattice_add_comm_group string_imp))) : rank_condition (denumerable (normed_lattice_add_comm_group string_imp)) := sorry --non-trivial
lemma new_lemma_175656 (h0 : list (normed_group (random_gen (random_gen string_imp)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_175657 (h1 : not (topological_space (add_monoid fun_info) -> false)) : @path_connected_space.{0} (add_monoid.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (add_monoid.{0} fun_info)) h1)  := sorry --non-trivial
lemma new_lemma_175658 (h0 : functor.add_const (complete_lattice (add_comm_monoid name)) pos) : @complete_lattice.is_Sup_finite_compact.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_comm_monoid.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_175659 (h0 : functor.add_const Prop (monoid_with_zero pos)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_175660 (h0 : functor.add_const (uniform_space (comm_group linarith.comp)) name) : @complete_space.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (comm_group.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_175661 (h0 : topological_space (add_comm_semigroup (add_comm_semigroup char))) (h1 : preorder (add_comm_semigroup (add_comm_semigroup char))) : order_topology (add_comm_semigroup (add_comm_semigroup char)) := sorry --non-trivial
lemma new_lemma_175662 (h0 : function.extfun (finset Type) (has_mem.mem (canonically_ordered_monoid linarith.comp_source))) : @irreducible_space.{0} (canonically_ordered_monoid.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (canonically_ordered_monoid.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (canonically_ordered_monoid.{0} linarith.comp_source)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_175663 (h1 : ring reducibility_hints) : rank_condition reducibility_hints := sorry --non-trivial
lemma new_lemma_175664 (h0 : has_lt (has_ssubset (normed_field std_gen))) : no_max_order (has_ssubset (normed_field std_gen)) := sorry --non-trivial
lemma new_lemma_175665 (h0 : function.extfun nat fin) : @sequential_space.{0} (has_Inf.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (has_Inf.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_175666 (h0 : matrix linarith.ineq linarith.ineq Prop) (h1 : linarith.ineq -> Prop) (h2 h3 : subtype (fun (a : linarith.ineq), h1 a)) : matrix.to_square_block_prop h0 h1 h2 h3 := sorry --non-trivial
lemma new_lemma_175667 (h0 : functor.add_const (cancel_comm_monoid_with_zero (complete_distrib_lattice linarith.comp)) pos) : @unique_factorization_monoid.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (complete_distrib_lattice.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_175668 (h0 : functor.add_const (uniform_space (add_cancel_monoid empty)) unsigned) : @separated_space.{0} (add_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (add_cancel_monoid.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_175669 (h0 : functor.add_const (ring (has_nndist linarith.comp)) (has_zero (finset (has_zero pos)))) : @is_principal_ideal_ring.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_nndist.{0} linarith.comp)) (has_zero.{0} (finset.{0} (has_zero.{0} pos))) h0)  := sorry --non-trivial
lemma new_lemma_175670 (h0 : topological_space (complete_distrib_lattice (has_bot (has_bot linarith.comp)))) : totally_separated_space (complete_distrib_lattice (has_bot (has_bot linarith.comp))) := sorry --non-trivial
lemma new_lemma_175671 (h0 : function.extfun Type topological_space) : @regular_space.{0} (semigroup.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_175672 (h0 : functor.add_const (topological_space (has_neg pos)) unsigned) : @totally_disconnected_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_175673 (h0 : ring (has_compl (has_nnnorm (has_ssubset string_imp)))) : rank_condition (has_compl (has_nnnorm (has_ssubset string_imp))) := sorry --non-trivial
lemma new_lemma_175674 (h0 : list (boolean_algebra.core (has_add (finset (has_add name))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_175675 (h0 : topological_space (has_union unsigned)) : preirreducible_space (has_union unsigned) := sorry --non-trivial
lemma new_lemma_175676 (h0 : functor.comp group comm_group Type) : @normalizer_condition.{1} (comm_group.{1} Type) (@functor.comp.run.{1 1 1} group.{1} comm_group.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_175677 (h0 : functor.add_const (topological_space (has_nndist pos)) linarith.comp) : @regular_space.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_175678 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (finset empty)) := sorry --non-trivial
lemma new_lemma_175679 (h0 : topological_space (linear_order congr_arg_kind)) : t0_space (linear_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_175680 (h0 : functor.add_const (functor.add_const (functor.add_const Prop pos) linarith.comp) name) : functor.add_const.run (functor.add_const.run (functor.add_const.run h0)) := sorry --non-trivial
lemma new_lemma_175681 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (add_cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_175682 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (ordered_ring.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (ordered_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_175683 (h0 : functor.add_const (topological_space (add_cancel_monoid ennreal)) name) : @totally_separated_space.{0} (add_cancel_monoid.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_175684 (h0 : group (semi_normed_comm_ring (has_top linarith.comp_source))) : group.fg (semi_normed_comm_ring (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_175685 (h0 : topological_space (normed_comm_ring (has_to_string (comm_group pos)))) : topological_space.separable_space (normed_comm_ring (has_to_string (comm_group pos))) := sorry --non-trivial
lemma new_lemma_175686 (h0 : topological_space (generalized_boolean_algebra (has_add (has_add pos)))) : loc_path_connected_space (generalized_boolean_algebra (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_175687 (h0 : topological_space (has_union (semiring (semiring linarith.comp)))) : irreducible_space (has_union (semiring (semiring linarith.comp))) := sorry --non-trivial
lemma new_lemma_175688 (h0 : functor.add_const (function.extfun (Type 1) monoid) pos) : @monoid.fg.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) monoid.{1}) pos h0) (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_175689 (h0 : functor.comp (prod (has_nndist environment.implicit_infer_kind)) has_nndist environment.implicit_infer_kind) : id_rel (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_175690 (h0 : ordered_comm_monoid (has_add (has_nndist (ring name)))) : has_exists_mul_of_le (has_add (has_nndist (ring name))) := sorry --non-trivial
lemma new_lemma_175691 (h0 : set (has_compl nat)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_175692 (h0 : topological_space (has_union (semiring num))) : discrete_topology (has_union (semiring num)) := sorry --non-trivial
lemma new_lemma_175693 (h1 : ring (distrib (random_gen reducibility_hints))) : is_domain (distrib (random_gen reducibility_hints)) := sorry --non-trivial
lemma new_lemma_175694 (h0 : functor.add_const (topological_space (normed_comm_ring unsigned)) Type) : @t1_space.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (normed_comm_ring.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_175695 (h0 : ring (mul_zero_class Type)) : strong_rank_condition (mul_zero_class Type) := sorry --non-trivial
lemma new_lemma_175696 (h0 : ring (mul_zero_class (finset environment.implicit_infer_kind))) : rank_condition (mul_zero_class (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_175697 (h0 : group (linear_ordered_semiring (random_gen num))) : is_cyclic (linear_ordered_semiring (random_gen num)) := sorry --non-trivial
lemma new_lemma_175698 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_add_cyclic.{1} (complete_distrib_lattice.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_group.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 add_group.{1}) (complete_distrib_lattice.{1} Type))  := sorry --non-trivial
lemma new_lemma_175699 (h0 : functor.add_const (ordered_comm_monoid (ring pos)) Type) : @has_exists_mul_of_le.{0} (ring.{0} pos) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (ring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_175700 (h0 : finset (add_right_cancel_monoid (semiring (semiring empty)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_175701 (h0 : functor.add_const (list (comm_group pos)) environment.implicit_infer_kind) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_175702 (h0 : functor.add_const (functor.add_const (ring nnreal) empty) empty) : @rank_condition.{0} nnreal (@functor.add_const.run.{0 0} (ring.{0} nnreal) empty (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (ring.{0} nnreal) empty) empty h0))  := sorry --non-trivial
lemma new_lemma_175703 (h0 : fin has_zero.zero) : @regular_space.{1} (complete_distrib_lattice.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (complete_distrib_lattice.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_175704 (h0 : not (ring (left_cancel_semigroup unsigned) -> false)) : @is_domain.{0} (left_cancel_semigroup.{0} unsigned) (@classical.by_contradiction'.{1} (ring.{0} (left_cancel_semigroup.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_175705 (h0 : has_mem.mem group has_emptyc.emptyc) : @normalizer_condition.{0} (complete_semilattice_Sup.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} h0) (complete_semilattice_Sup.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_175706 (h0 : filter (linear_ordered_cancel_comm_monoid num)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_175707 (h0 : function.extfun (finset Type) (has_mem.mem (random_gen empty))) : @is_compactly_generated.{0} (random_gen.{0} empty) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (random_gen.{0} empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} empty)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_175708 (h0 : functor.add_const (topological_space (has_zero ennreal)) name) : @preirreducible_space.{0} (has_zero.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_175709 (h0 : functor.add_const (topological_space (measure_theory.measure_space num)) (semiring empty)) : @discrete_topology.{0} (measure_theory.measure_space.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (measure_theory.measure_space.{0} num)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_175710 (h0 : functor.add_const (semiring (comm_group pos)) (has_neg (has_neg environment.implicit_infer_kind))) : @is_noetherian_ring.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (semiring.{0} (comm_group.{0} pos)) (has_neg.{0} (has_neg.{0} environment.implicit_infer_kind)) h0)  := sorry --non-trivial
lemma new_lemma_175711 (h1 : topological_space (with_zero (has_inv string_imp))) : totally_disconnected_space (with_zero (has_inv string_imp)) := sorry --non-trivial
lemma new_lemma_175712 (h0 : add_group (add_left_cancel_semigroup (option unsigned))) : is_add_cyclic (add_left_cancel_semigroup (option unsigned)) := sorry --non-trivial
lemma new_lemma_175713 (h0 : fin has_zero.zero) : @normalizer_condition.{0} (canonically_linear_ordered_monoid.{0} real) (@matrix.vec_empty.{0} (group.{0} (canonically_linear_ordered_monoid.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_175714 (h0 : function.extfun Type monoid) : monoid.fg ennreal := sorry --non-trivial
lemma new_lemma_175715 (h0 : filter (complete_semilattice_Sup (random_gen linarith.ineq))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_175716 (h1 : linarith.ineq -> Prop) : Exists h1 := sorry --non-trivial
lemma new_lemma_175717 (h0 : functor.add_const (topological_space (has_to_string empty)) empty) : @totally_separated_space.{0} (has_to_string.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_175718 (h0 : topological_space (linear_ordered_field (option ennreal))) : preirreducible_space (linear_ordered_field (option ennreal)) := sorry --non-trivial
lemma new_lemma_175719 (h0 : ring (linear_ordered_semiring (semiring empty))) : rank_condition (linear_ordered_semiring (semiring empty)) := sorry --non-trivial
lemma new_lemma_175720 (h0 : topological_space (complete_linear_order congr_arg_kind)) : topological_space.separable_space (complete_linear_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_175721 (h0 : uniform_space (ordered_comm_monoid pos)) : separated_space (ordered_comm_monoid pos) := sorry --non-trivial
lemma new_lemma_175722 (h0 : fin has_zero.zero) : @group.fg.{0} (comm_semigroup.{0} pos) (@matrix.vec_empty.{0} (group.{0} (comm_semigroup.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_175723 (h0 : topological_space (uniform_space (random_gen linarith.ineq))) : t0_space (uniform_space (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_175724 (h0 : measurable_space (nondiscrete_normed_field (add_comm_semigroup string.iterator_imp))) (h1 : measure_theory.measure (nondiscrete_normed_field (add_comm_semigroup string.iterator_imp))) : measure_theory.is_finite_measure h1 := sorry --non-trivial
lemma new_lemma_175725 (h0 : monoid (add_comm_monoid (normed_comm_ring environment.implicit_infer_kind))) : monoid.fg (add_comm_monoid (normed_comm_ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_175726 (h0 : functor.add_const (topological_space (boolean_algebra.core Type)) (comm_group name)) : @preconnected_space.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.core.{1} Type)) (comm_group.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_175727 (h0 : topological_space (normed_group (semiring congr_arg_kind))) : locally_compact_space (normed_group (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_175728 (h0 : functor.add_const (ring (has_zero linarith.comp)) (ring (has_neg (ring environment.implicit_infer_kind)))) : @is_principal_ideal_ring.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_zero.{0} linarith.comp)) (ring.{0} (has_neg.{0} (ring.{0} environment.implicit_infer_kind))) h0)  := sorry --non-trivial
lemma new_lemma_175729 (h0 : topological_space (has_one (has_norm empty))) : irreducible_space (has_one (has_norm empty)) := sorry --non-trivial
lemma new_lemma_175730 (h0 : functor.add_const (group (cancel_monoid linarith.comp)) Type) : @normalizer_condition.{0} (cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (group.{0} (cancel_monoid.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_175731 (h0 : ring (ring (ring name))) : is_domain (ring (ring name)) := sorry --non-trivial
lemma new_lemma_175732 (h0 : topological_space (monoid (option unsigned))) : preconnected_space (monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_175733 (h0 : uniform_space (uniform_space (mul_one_class char))) : complete_space (uniform_space (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_175734 (h0 : functor.add_const (topological_space (has_zero Type)) name) : @sequential_space.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_zero.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_175735 (h0 : add_group (has_emptyc (with_bot linarith.comp_source))) : is_add_cyclic (has_emptyc (with_bot linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_175736 (h0 : topological_space (comm_group (comm_group (comm_group unsigned)))) : totally_separated_space (comm_group (comm_group (comm_group unsigned))) := sorry --non-trivial
lemma new_lemma_175737 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @locally_compact_space.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_175738 (h0 : list (has_Inf Type)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_175739 (h0 : functor.add_const (uniform_space (has_zero name)) environment.implicit_infer_kind) : @separated_space.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_zero.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_175740 (h0 : monoid (has_nndist (option num))) : monoid.fg (has_nndist (option num)) := sorry --non-trivial
lemma new_lemma_175741 (h1 : complete_lattice (has_div string.iterator_imp)) : complete_lattice.is_Sup_finite_compact (has_div string.iterator_imp) := sorry --non-trivial
lemma new_lemma_175742 (h0 : semiring (ordered_comm_ring (has_pos_part Type))) : is_noetherian_ring (ordered_comm_ring (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_175743 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_edist.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_edist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_175744 (h0 : function.extfun Type topological_space) : @t0_space.{0} (simple_graph.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (simple_graph.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_175745 (h0 : topological_space unsigned -> Prop) : @locally_compact_space.{0} unsigned (@classical.epsilon.{1} (topological_space.{0} unsigned) (@nonempty_of_inhabited.{1} (topological_space.{0} unsigned) (@inhabited_topological_space.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_175746 (h0 : group (linear_ordered_comm_group (option (option ennreal)))) : group.fg (linear_ordered_comm_group (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_175747 (h0 : function.extfun (set (with_bot string_imp)) (fun (x : set (with_bot string_imp)), Prop)) : is_countably_spanning (function.extfun_app h0) := sorry --non-trivial
lemma new_lemma_175748 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (is_R_or_C congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_175749 (h0 : has_mem.mem (partial_order unsigned) has_zero.zero) : @complete_space.{0} (partial_order.{0} unsigned) (@multiset.pi.empty.{1 0} Type uniform_space.{0} (partial_order.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_175750 (h0 : group (comm_monoid empty)) : is_simple_group (comm_monoid empty) := sorry --non-trivial
lemma new_lemma_175751 (h1 : ring (add_monoid to_additive.value_type)) : rank_condition (add_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_175752 (h0 : group (linear_ordered_add_comm_group (has_nnnorm char))) : group.fg (linear_ordered_add_comm_group (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_175753 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (canonically_ordered_add_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_add_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_175754 (h0 : topological_space (has_union (semiring (has_norm num)))) : preirreducible_space (has_union (semiring (has_norm num))) := sorry --non-trivial
lemma new_lemma_175755 (h0 : uniform_space (has_to_string (semigroup name))) : separated_space (has_to_string (semigroup name)) := sorry --non-trivial
lemma new_lemma_175756 (h0 : functor.add_const (ordered_add_comm_monoid (has_to_string linarith.comp)) pos) : @archimedean.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_to_string.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_175757 (h0 : topological_space (left_cancel_semigroup (add_cancel_comm_monoid num))) : topological_space.separable_space (left_cancel_semigroup (add_cancel_comm_monoid num)) := sorry --non-trivial
lemma new_lemma_175758 (h0 : set (std_gen -> enat)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_175759 (h0 : topological_space (has_edist empty)) : irreducible_space (has_edist empty) := sorry --non-trivial
lemma new_lemma_175760 (h0 : function.extfun Type (functor.add_const (topological_space (boolean_algebra linarith.comp)))) : @topological_space.separable_space.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} linarith.comp)) linarith.comp (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (boolean_algebra.{0} linarith.comp))) h0 linarith.comp))  := sorry --non-trivial
lemma new_lemma_175761 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (@id.{2} Type linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (@id.{2} Type linarith.comp))  := sorry --non-trivial
lemma new_lemma_175762 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (dlist.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (dlist.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_175763 (h0 : complete_lattice (add_left_cancel_monoid char)) : is_compactly_generated (add_left_cancel_monoid char) := sorry --non-trivial
lemma new_lemma_175764 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (linear_ordered_comm_group.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_175765 (h0 : cancel_comm_monoid_with_zero (has_add (cancel_monoid (has_nndist (finset ennreal))))) : unique_factorization_monoid (has_add (cancel_monoid (has_nndist (finset ennreal)))) := sorry --non-trivial
lemma new_lemma_175766 (h0 : group (finset (has_add name))) : is_simple_group (finset (has_add name)) := sorry --non-trivial
lemma new_lemma_175767 (h0 : group (normed_group (random_gen (random_gen (random_gen string_imp))))) : is_cyclic (normed_group (random_gen (random_gen (random_gen string_imp)))) := sorry --non-trivial
lemma new_lemma_175768 (h0 : has_mem.mem (has_top fun_info) has_emptyc.emptyc) : @rank_condition.{0} (has_top.{0} fun_info) (@finset.pi.empty.{1 0} Type ring.{0} (has_top.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_175769 (h0 : function.extfun Type monoid) : @monoid.fg.{0} environment.implicit_infer_kind (@function.extfun_app.{2 1} Type monoid.{0} h0 environment.implicit_infer_kind)  := sorry --non-trivial
lemma new_lemma_175770 (h0 : ring (add_left_cancel_monoid linarith.ineq)) : strong_rank_condition (add_left_cancel_monoid linarith.ineq) := sorry --non-trivial
lemma new_lemma_175771 (h0 : ring (linear_ordered_cancel_comm_monoid unsigned)) : is_domain (linear_ordered_cancel_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_175772 (h0 : ring (left_cancel_semigroup empty)) : is_principal_ideal_ring (left_cancel_semigroup empty) := sorry --non-trivial
lemma new_lemma_175773 (h0 : not (function.extfun Type topological_space -> false)) : @normal_space.{0} (measurable_space.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (measurable_space.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_175774 (h0 : semiring (normed_group (semiring num))) : is_noetherian_ring (normed_group (semiring num)) := sorry --non-trivial
lemma new_lemma_175775 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (normed_linear_ordered_group unsigned)) := sorry --non-trivial
lemma new_lemma_175776 (h0 : function.extfun (finset Type) (has_mem.mem (has_top congr_arg_kind))) : @discrete_topology.{0} (has_top.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_top.{0} congr_arg_kind) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_top.{0} congr_arg_kind)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_175777 (h0 : prod (ring congr_arg_kind) (ring congr_arg_kind)) : set.diagonal (ring congr_arg_kind) h0 := sorry --non-trivial
lemma new_lemma_175778 (h0 : list (has_nnnorm (random_gen (random_gen linarith.ineq)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_175779 (h0 : topological_space (normed_field (topological_space linarith.comp_source))) : totally_disconnected_space (normed_field (topological_space linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_175780 (h0 : uniform_space (sub_neg_monoid (has_add (has_add Type)))) : separated_space (sub_neg_monoid (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_175781 (h0 : list (add_cancel_monoid (has_pos_part (has_pos_part (has_pos_part linarith.comp))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_175782 (h0 : add_group (has_top string_imp)) : is_add_cyclic (has_top string_imp) := sorry --non-trivial
lemma new_lemma_175783 (h0 : topological_space (complete_distrib_lattice (boolean_algebra name))) : totally_disconnected_space (complete_distrib_lattice (boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_175784 (h0 : topological_space (normed_comm_ring (has_to_string name))) : normal_space (normed_comm_ring (has_to_string name)) := sorry --non-trivial
lemma new_lemma_175785 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (canonically_ordered_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (canonically_ordered_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_175786 (h0 : topological_space (finset (finset (finset (finset (has_nndist ennreal)))))) : irreducible_space (finset (finset (finset (finset (has_nndist ennreal))))) := sorry --non-trivial
lemma new_lemma_175787 (h0 : topological_space (denumerable (random_gen (random_gen (random_gen linarith.comp_source))))) : t0_space (denumerable (random_gen (random_gen (random_gen linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_175788 (h0 : uniform_space (has_pos_part (has_pos_part pos))) : complete_space (has_pos_part (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_175789 (h0 : add_monoid (add_group (semiring (semiring num)))) : add_monoid.fg (add_group (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_175790 (h0 : topological_space (has_union (semiring (has_top unsigned)))) : preirreducible_space (has_union (semiring (has_top unsigned))) := sorry --non-trivial
lemma new_lemma_175791 (h0 : functor.add_const (topological_space (mul_zero_class num)) (semiring num)) : @path_connected_space.{0} (mul_zero_class.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} num)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_175792 (h0 : not (add_group (add_group num) -> false)) : @is_add_cyclic.{0} (add_group.{0} num) (@classical.by_contradiction'.{1} (add_group.{0} (add_group.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_175793 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_add.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_add.{0} name))  := sorry --non-trivial
lemma new_lemma_175794 (h0 : group (normed_group (semiring (semiring empty)))) : normalizer_condition (normed_group (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_175795 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (add_cancel_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_175796 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (generalized_boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (generalized_boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_175797 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring name)) (option (option pos))) : @normal_space.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} name)) (option.{0} (option.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_175798 (h0 : topological_space (monoid_with_zero (option unsigned))) : t1_space (monoid_with_zero (option unsigned)) := sorry --non-trivial
lemma new_lemma_175799 (h0 : ordered_comm_monoid (normed_comm_ring (has_neg_part (semigroup (has_neg_part pos))))) : has_exists_mul_of_le (normed_comm_ring (has_neg_part (semigroup (has_neg_part pos)))) := sorry --non-trivial
lemma new_lemma_175800 (h0 : function.extfun Type group) : @is_simple_group.{0} (has_to_string.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} h0 (has_to_string.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_175801 (h0 : ordered_add_comm_monoid (semigroup pos)) : archimedean (semigroup pos) := sorry --non-trivial
lemma new_lemma_175802 (h0 : not (ring (has_top congr_arg_kind) -> false)) : @rank_condition.{0} (has_top.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (ring.{0} (has_top.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_175803 (h1 : topological_space (has_compl (has_ssubset (random_gen (random_gen (random_gen char)))))) : totally_disconnected_space (has_compl (has_ssubset (random_gen (random_gen (random_gen char))))) := sorry --non-trivial
lemma new_lemma_175804 (h0 : topological_space (complete_distrib_lattice (semigroup environment.implicit_infer_kind))) : irreducible_space (complete_distrib_lattice (semigroup environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_175805 (h0 : group (with_one linarith.comp)) : group.fg (with_one linarith.comp) := sorry --non-trivial
lemma new_lemma_175806 (h0 : not (add_monoid (option num) -> false)) : @add_monoid.fg.{0} (option.{0} num) (@classical.by_contradiction'.{1} (add_monoid.{0} (option.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_175807 (h1 : ring (add_comm_semigroup std_gen)) : rank_condition (add_comm_semigroup std_gen) := sorry --non-trivial
lemma new_lemma_175808 (h0 : topological_space (encodable string_imp)) : path_connected_space (encodable string_imp) := sorry --non-trivial
lemma new_lemma_175809 (h0 : functor.add_const (list (add_cancel_monoid pos)) (option (option (option (option unsigned))))) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_175810 (h0 : group (add_cancel_monoid linarith.comp)) : group.fg (add_cancel_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_175811 (h0 : list ereal) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_175812 (h1 : function.extfun Type ring) : @strong_rank_condition.{0} (random_gen.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} h1 (random_gen.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_175813 (h0 : not (group (has_compl string_imp) -> false)) : @group.fg.{0} (has_compl.{0} string_imp) (@classical.by_contradiction'.{1} (group.{0} (has_compl.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_175814 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (comm_group.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_175815 (h0 : topological_space (comm_semigroup (sub_neg_monoid (sub_neg_monoid real)))) : loc_path_connected_space (comm_semigroup (sub_neg_monoid (sub_neg_monoid real))) := sorry --non-trivial
lemma new_lemma_175816 (h0 : topological_space (random_gen linarith.ineq)) : totally_separated_space (random_gen linarith.ineq) := sorry --non-trivial
lemma new_lemma_175817 (h0 : uniform_space (has_le (normed_field linarith.ineq))) : complete_space (has_le (normed_field linarith.ineq)) := sorry --non-trivial
lemma new_lemma_175818 (h0 : filter (linear_ordered_field (finset pos))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_175819 (h1 : topological_space (simple_graph (normed_field char))) (h2 : add_group (simple_graph (normed_field char))) : topological_add_group (simple_graph (normed_field char)) := sorry --non-trivial
lemma new_lemma_175820 (h0 : topological_space (normed_lattice_add_comm_group (has_Inf name))) : path_connected_space (normed_lattice_add_comm_group (has_Inf name)) := sorry --non-trivial
lemma new_lemma_175821 (h0 : complete_lattice (has_norm (has_norm (has_norm linarith.ineq)))) : is_compactly_generated (has_norm (has_norm (has_norm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_175822 (h0 : topological_space (has_to_string (has_nndist pos))) : t1_space (has_to_string (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_175823 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @complete_space.{1} (boolean_algebra.core.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 uniform_space.{1}) (boolean_algebra.core.{1} Type))  := sorry --non-trivial
lemma new_lemma_175824 (h0 : topological_space (has_pos_part (finset pos))) : t0_space (has_pos_part (finset pos)) := sorry --non-trivial
lemma new_lemma_175825 (h0 : prod (has_to_string (option (option pos))) (has_to_string (option (option pos)))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_175826 (h0 : ring (has_lt linarith.comp_source)) : is_domain (has_lt linarith.comp_source) := sorry --non-trivial
lemma new_lemma_175827 (h1 : complete_lattice (non_unital_non_assoc_semiring fun_info)) : is_compactly_generated (non_unital_non_assoc_semiring fun_info) := sorry --non-trivial
lemma new_lemma_175828 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_norm.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_norm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_175829 (h0 h1 : nat) : nat.less_than_or_equal (denumerable.of_nat nat h0) h1 := sorry --non-trivial
lemma new_lemma_175830 (h0 : functor.add_const (complete_lattice (add_group num)) empty) : @is_compactly_generated.{0} (add_group.{0} num) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_group.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_175831 (h0 : functor.add_const (topological_space (ring Type)) Type) : @t0_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (ring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_175832 (h0 : filter (canonically_ordered_monoid (has_Inf (has_Inf (has_Inf pos))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_175833 (h0 : function.extfun Type (functor.comp group has_to_string)) : @is_simple_group.{0} (has_to_string.{0} name) (@functor.comp.run.{0 0 0} group.{0} has_to_string.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} group.{0} has_to_string.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_175834 (h0 : complete_lattice (has_Inf (has_pos_part (boolean_algebra.core Type)))) : complete_lattice.is_Sup_finite_compact (has_Inf (has_pos_part (boolean_algebra.core Type))) := sorry --non-trivial
lemma new_lemma_175835 (h0 : not (function.extfun Type ring -> false)) : @strong_rank_condition.{0} (@id.{2} Type linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (@id.{2} Type linarith.comp))  := sorry --non-trivial
lemma new_lemma_175836 (h0 : uniform_space (with_bot (has_top unsigned))) : complete_space (with_bot (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_175837 (h0 : functor.add_const (group (boolean_algebra.core environment.implicit_infer_kind)) linarith.comp) : @is_simple_group.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_175838 (h0 : topological_space (has_sub (has_norm unsigned))) : path_connected_space (has_sub (has_norm unsigned)) := sorry --non-trivial
lemma new_lemma_175839 (h0 : topological_space (semigroup unsigned)) : preconnected_space (semigroup unsigned) := sorry --non-trivial
lemma new_lemma_175840 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (semiring.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_175841 (h0 : std_gen -> std_gen -> Prop) (h1 : list std_gen) : list.pairwise h0 h1 := sorry --non-trivial
lemma new_lemma_175842 (h0 : functor.add_const (functor.add_const (monoid (left_cancel_semigroup unsigned)) unsigned) num) : @monoid.fg.{0} (left_cancel_semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (monoid.{0} (left_cancel_semigroup.{0} unsigned)) unsigned (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (monoid.{0} (left_cancel_semigroup.{0} unsigned)) unsigned) num h0))  := sorry --non-trivial
lemma new_lemma_175843 (h0 : function.extfun Type (functor.add_const (topological_space (has_add linarith.comp)))) : @path_connected_space.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} linarith.comp)) linarith.comp (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (has_add.{0} linarith.comp))) h0 linarith.comp))  := sorry --non-trivial
lemma new_lemma_175844 (h0 : topological_space (preorder (semiring (semiring (semiring num))))) : discrete_topology (preorder (semiring (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_175845 (h0 : add_group (has_star (semiring empty))) : is_add_cyclic (has_star (semiring empty)) := sorry --non-trivial
lemma new_lemma_175846 (h0 : option Type) (h1 : topological_space (left_cancel_monoid (option.get_or_else h0 congr_arg_kind))) : preirreducible_space (left_cancel_monoid (option.get_or_else h0 congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_175847 (h0 : ordered_comm_monoid (add_cancel_monoid (boolean_algebra (comm_group name)))) : has_exists_mul_of_le (add_cancel_monoid (boolean_algebra (comm_group name))) := sorry --non-trivial
lemma new_lemma_175848 (h0 : uniform_space (has_nndist (boolean_algebra linarith.comp))) : separated_space (has_nndist (boolean_algebra linarith.comp)) := sorry --non-trivial
lemma new_lemma_175849 (h0 : functor.comp topological_space cancel_monoid name) : @topological_space.separable_space.{0} (cancel_monoid.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} cancel_monoid.{0} name h0)  := sorry --non-trivial
lemma new_lemma_175850 (h0 : list (boolean_algebra.core (option empty))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_175851 (h0 : functor.add_const (function.extfun Type semiring) pos) : @is_noetherian_ring.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type semiring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type semiring.{0}) pos h0) (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_175852 (h0 : group (has_emptyc (with_bot (with_bot to_additive.value_type)))) : normalizer_condition (has_emptyc (with_bot (with_bot to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_175853 (h0 : functor.add_const (topological_space znum) empty) : @t0_space.{0} znum (@functor.add_const.run.{0 0} (topological_space.{0} znum) empty h0)  := sorry --non-trivial
lemma new_lemma_175854 (h0 : topological_space (has_neg_part Type)) : topological_space.separable_space (has_neg_part Type) := sorry --non-trivial
lemma new_lemma_175855 (h0 : ordered_comm_monoid (canonically_ordered_comm_semiring pos)) : has_exists_mul_of_le (canonically_ordered_comm_semiring pos) := sorry --non-trivial
lemma new_lemma_175856 (h0 : list (with_bot unsigned)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_175857 (h0 : topological_space (comm_ring string.iterator_imp)) : t0_space (comm_ring string.iterator_imp) := sorry --non-trivial
lemma new_lemma_175858 (h0 : topological_space (has_neg (has_neg (has_neg linarith.comp)))) : locally_compact_space (has_neg (has_neg (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_175859 (h0 : complete_lattice (complete_distrib_lattice (has_Inf (has_add Type)))) : complete_lattice.is_Sup_finite_compact (complete_distrib_lattice (has_Inf (has_add Type))) := sorry --non-trivial
lemma new_lemma_175860 (h0 : topological_space (finset unsigned)) : path_connected_space (finset unsigned) := sorry --non-trivial
lemma new_lemma_175861 (h0 : ring (boolean_algebra (finset (has_to_string name)))) : is_principal_ideal_ring (boolean_algebra (finset (has_to_string name))) := sorry --non-trivial
lemma new_lemma_175862 (h0 : uniform_space (has_top fun_info)) : complete_space (has_top fun_info) := sorry --non-trivial
lemma new_lemma_175863 (h0 : functor.add_const (ring (finset pos)) (boolean_algebra Type)) : @strong_rank_condition.{0} (finset.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (finset.{0} pos)) (boolean_algebra.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_175864 (h0 : monoid (normed_group (has_inv linarith.ineq))) : monoid.fg (normed_group (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_175865 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (canonically_ordered_comm_semiring.{0} name) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (canonically_ordered_comm_semiring.{0} name))  := sorry --non-trivial
lemma new_lemma_175866 (h0 : functor.add_const (group (has_to_string name)) pos) : @group.fg.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (group.{0} (has_to_string.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_175867 (h0 : semiring (linear_ordered_field (option (option unsigned)))) : is_noetherian_ring (linear_ordered_field (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_175868 (h0 : functor.add_const (topological_space (partial_order empty)) unsigned) : @totally_disconnected_space.{0} (partial_order.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (partial_order.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_175869 (h0 : functor.add_const (filter (cancel_monoid num)) unsigned) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_175870 (h0 : topological_space (group_with_zero (option (option empty)))) : preirreducible_space (group_with_zero (option (option empty))) := sorry --non-trivial
lemma new_lemma_175871 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (boolean_algebra.core.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_175872 (h0 : add_monoid (normed_comm_ring (has_to_string name))) : add_monoid.fg (normed_comm_ring (has_to_string name)) := sorry --non-trivial
lemma new_lemma_175873 (h0 : monoid (random_gen empty)) : monoid.fg (random_gen empty) := sorry --non-trivial
lemma new_lemma_175874 (h1 : function.extfun Type monoid) : @monoid.fg.{0} (measurable_space.{0} string_imp) (@function.extfun_app.{2 1} Type monoid.{0} h1 (measurable_space.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_175875 (h0 : add_group (plift (option (option unsigned)))) : is_add_cyclic (plift (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_175876 (h0 : topological_space (finset (normed_comm_ring linarith.comp))) : preconnected_space (finset (normed_comm_ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_175877 (h0 : function.extfun Type group) : @is_cyclic.{0} (non_assoc_semiring.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (non_assoc_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_175878 (h0 : functor.add_const (monoid (add_comm_monoid linarith.comp)) (has_add pos)) : @monoid.fg.{0} (add_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (monoid.{0} (add_comm_monoid.{0} linarith.comp)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_175879 (h0 : topological_space (as_linear_order (option empty))) : totally_separated_space (as_linear_order (option empty)) := sorry --non-trivial
lemma new_lemma_175880 (h0 : topological_space (add_left_cancel_semigroup (semiring unsigned))) : loc_path_connected_space (add_left_cancel_semigroup (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_175881 (h1 : list (has_emptyc congr_arg_kind)) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_175882 (h0 : add_group (has_ssubset (has_ssubset (has_ssubset string_imp)))) : is_add_cyclic (has_ssubset (has_ssubset (has_ssubset string_imp))) := sorry --non-trivial
lemma new_lemma_175883 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (finset num)) := sorry --non-trivial
lemma new_lemma_175884 (h0 : functor.add_const (group (has_neg_part name)) name) : @is_cyclic.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (group.{0} (has_neg_part.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_175885 (h0 : Prop -> unit) (h1 : set Prop) : @trace_call_stack.{0} Prop (@function.inv_fun_on.{0 0} Prop unit (@nonempty_of_inhabited.{1} Prop sort.inhabited.{0}) h0 h1)  := sorry --non-trivial
lemma new_lemma_175886 (h0 : topological_space (generalized_boolean_algebra (finset linarith.comp))) : locally_compact_space (generalized_boolean_algebra (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_175887 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @is_compactly_generated.{0} (measure_theory.measure_space.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) complete_lattice.{0}) (measure_theory.measure_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_175888 (h0 h1 : multiset (has_ssubset (mul_one_class enat))) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_175889 (h0 : functor.add_const (topological_space (boolean_algebra Type)) pos) : @normal_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_175890 (h0 : filter (has_nndist (has_add pos))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_175891 (h0 : topological_space (has_norm (has_ssubset (has_ssubset linarith.ineq)))) : irreducible_space (has_norm (has_ssubset (has_ssubset linarith.ineq))) := sorry --non-trivial
lemma new_lemma_175892 (h0 : topological_space (comm_semigroup (has_Inf (has_Inf (sub_neg_monoid Type))))) : preirreducible_space (comm_semigroup (has_Inf (has_Inf (sub_neg_monoid Type)))) := sorry --non-trivial
lemma new_lemma_175893 (h0 : functor.add_const (topological_space (has_neg_part pos)) unsigned) : @regular_space.{0} (has_neg_part.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_175894 (h0 : functor.add_const (filter (comm_group Type)) pos) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_175895 (h0 : topological_space (comm_group (option pos))) : totally_separated_space (comm_group (option pos)) := sorry --non-trivial
lemma new_lemma_175896 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_add.{0} name) (@function.extfun_app.{2 1} Type group.{0} h0 (has_add.{0} name))  := sorry --non-trivial
lemma new_lemma_175897 (h0 : topological_space (has_Inf (has_pos_part Type))) : normal_space (has_Inf (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_175898 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (boolean_algebra.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} h0 (boolean_algebra.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_175899 : pempty := sorry --non-trivial
lemma new_lemma_175900 (h0 : add_monoid (linear_ordered_comm_group congr_arg_kind)) : add_monoid.fg (linear_ordered_comm_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_175901 (h0 : topological_space (has_add (ring pos))) : locally_compact_space (has_add (ring pos)) := sorry --non-trivial
lemma new_lemma_175902 (h0 : functor.add_const (list (measure_theory.measure_space empty)) (semiring empty)) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_175903 (h0 : topological_space (semi_normed_comm_ring (has_nnnorm linarith.ineq))) : totally_disconnected_space (semi_normed_comm_ring (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_175904 (h0 : topological_space (add_cancel_monoid (comm_group (has_add unsigned)))) : locally_compact_space (add_cancel_monoid (comm_group (has_add unsigned))) := sorry --non-trivial
lemma new_lemma_175905 (h0 : ring (has_ssubset (has_ssubset (has_ssubset (has_ssubset to_additive.value_type))))) : is_domain (has_ssubset (has_ssubset (has_ssubset (has_ssubset to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_175906 (h0 : ring (distrib_lattice (has_nnnorm to_additive.value_type))) : strong_rank_condition (distrib_lattice (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_175907 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @t1_space.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_175908 (h0 : ring (boolean_algebra (has_to_string (has_add (has_to_string linarith.comp))))) : rank_condition (boolean_algebra (has_to_string (has_add (has_to_string linarith.comp)))) := sorry --non-trivial
lemma new_lemma_175909 (h0 : topological_space (semigroup (has_add name))) : locally_compact_space (semigroup (has_add name)) := sorry --non-trivial
lemma new_lemma_175910 (h0 : functor.add_const (finset (has_nndist name)) pos) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_175911 (h0 : functor.add_const (monoid (cancel_monoid linarith.comp)) environment.implicit_infer_kind) : @monoid.fg.{0} (cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (monoid.{0} (cancel_monoid.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_175912 (h0 : list (id string_imp)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_175913 (h0 : add_group (has_nnnorm ordering)) : is_add_cyclic (has_nnnorm ordering) := sorry --non-trivial
lemma new_lemma_175914 (h0 : not (topological_space (metric_space linarith.comp_source) -> false)) : @t0_space.{0} (metric_space.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (metric_space.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_175915 (h0 : not (topological_space (add_right_cancel_monoid num) -> false)) : @totally_disconnected_space.{0} (add_right_cancel_monoid.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (add_right_cancel_monoid.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_175916 (h0 : topological_space (complete_distrib_lattice (finset Type))) : path_connected_space (complete_distrib_lattice (finset Type)) := sorry --non-trivial
lemma new_lemma_175917 (h0 : functor.add_const (topological_space (ring pos)) name) : @normal_space.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_175918 (h0 : topological_space (comm_group linarith.comp)) : t0_space (comm_group linarith.comp) := sorry --non-trivial
lemma new_lemma_175919 (h0 : topological_space (canonically_linear_ordered_monoid (has_neg pos))) : regular_space (canonically_linear_ordered_monoid (has_neg pos)) := sorry --non-trivial
lemma new_lemma_175920 (h0 : measurable_space (simple_graph char)) (h1 : filter (simple_graph char)) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_175921 (h0 : group (id (has_norm empty))) : is_cyclic (id (has_norm empty)) := sorry --non-trivial
lemma new_lemma_175922 (h0 : complete_lattice (boolean_algebra.core (has_pos_part Type))) : is_compactly_generated (boolean_algebra.core (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_175923 (h0 : complete_lattice (dlist (has_ssubset fun_info))) : is_compactly_generated (dlist (has_ssubset fun_info)) := sorry --non-trivial
lemma new_lemma_175924 (h0 : topological_space (ring (option empty))) : discrete_topology (ring (option empty)) := sorry --non-trivial
lemma new_lemma_175925 (h0 : not (group (with_bot num) -> false)) : @is_cyclic.{0} (with_bot.{0} num) (@classical.by_contradiction'.{1} (group.{0} (with_bot.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_175926 (h0 : cancel_comm_monoid_with_zero (id (semiring (semiring (semiring unsigned))))) : unique_factorization_monoid (id (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_175927 (h0 : complete_lattice (option (option unsigned))) : complete_lattice.is_Sup_finite_compact (option (option unsigned)) := sorry --non-trivial
lemma new_lemma_175928 (h0 : not (topological_space (semiring to_additive.value_type) -> false)) : @t0_space.{0} (semiring.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (semiring.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_175929 (h0 : topological_space (left_cancel_monoid empty)) : locally_compact_space (left_cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_175930 (h0 : functor.add_const (ring (finset pos)) name) : @is_principal_ideal_ring.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (finset.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_175931 (h0 : ring (add_comm_semigroup (add_comm_semigroup (add_comm_semigroup linarith.ineq)))) : is_domain (add_comm_semigroup (add_comm_semigroup (add_comm_semigroup linarith.ineq))) := sorry --non-trivial
lemma new_lemma_175932 (h0 : functor.add_const (topological_space (has_add linarith.comp)) environment.implicit_infer_kind) : @loc_path_connected_space.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_175933 (h0 : set (mul_one_class (add_comm_semigroup fun_info))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_175934 (h0 : functor.add_const (topological_space (has_nndist pos)) pos) : @sequential_space.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_175935 (h0 : functor.add_const (topological_space (comm_group unsigned)) unsigned) : @totally_disconnected_space.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_175936 (h0 : functor.add_const (topological_space (canonically_ordered_monoid linarith.comp)) pos) : @totally_separated_space.{0} (canonically_ordered_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_monoid.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_175937 (h3 : ring (with_one num)) : is_domain (with_one num) := sorry --non-trivial
lemma new_lemma_175938 (h0 : has_lt (semi_normed_ring (mul_one_class fun_info))) : no_max_order (semi_normed_ring (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_175939 (h0 : not (complete_lattice (linear_ordered_comm_group_with_zero linarith.comp_source) -> false)) : @is_compactly_generated.{0} (linear_ordered_comm_group_with_zero.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (complete_lattice.{0} (linear_ordered_comm_group_with_zero.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_175940 (h0 : topological_space (has_norm (has_top linarith.comp_source))) : path_connected_space (has_norm (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_175941 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @sequential_space.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_175942 (h0 : functor.comp topological_space option (option (option ennreal))) : @regular_space.{0} (option.{0} (option.{0} (option.{0} ennreal))) (@functor.comp.run.{0 0 0} topological_space.{0} option.{0} (option.{0} (option.{0} ennreal)) h0)  := sorry --non-trivial
lemma new_lemma_175943 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (complete_semilattice_Sup.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (complete_semilattice_Sup.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_175944 (h0 : group (generalized_boolean_algebra (has_bot Type))) : is_cyclic (generalized_boolean_algebra (has_bot Type)) := sorry --non-trivial
lemma new_lemma_175945 (h0 : group (ring (ring Type))) : group.fg (ring (ring Type)) := sorry --non-trivial
lemma new_lemma_175946 (h0 : ring (has_norm (random_gen to_additive.value_type))) : rank_condition (has_norm (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_175947 (h0 : topological_space (ring (boolean_algebra environment.implicit_infer_kind))) : totally_disconnected_space (ring (boolean_algebra environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_175948 (h0 : ring (has_nnnorm (pseudo_metric_space linarith.comp_source))) : is_domain (has_nnnorm (pseudo_metric_space linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_175949 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (has_neg.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (has_neg.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_175950 (h0 : pfun fun_info Prop) (h2 : fun_info) (h3 : pfun.dom h0 h2) : pfun.fn h0 h2 h3 := sorry --non-trivial
lemma new_lemma_175951 (h0 : cancel_comm_monoid_with_zero (has_pos_part (finset linarith.comp))) : unique_factorization_monoid (has_pos_part (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_175952 (h0 : functor.add_const (topological_space (add_comm_monoid unsigned)) environment.implicit_infer_kind) : @locally_compact_space.{0} (add_comm_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_175953 (h0 : add_monoid (comm_semigroup Type)) : add_monoid.fg (comm_semigroup Type) := sorry --non-trivial
lemma new_lemma_175954 (h0 : topological_space (has_to_string (has_add Type))) : irreducible_space (has_to_string (has_add Type)) := sorry --non-trivial
lemma new_lemma_175955 (h0 : semiring (has_to_string (has_neg (finset (add_cancel_monoid name))))) : is_noetherian_ring (has_to_string (has_neg (finset (add_cancel_monoid name)))) := sorry --non-trivial
lemma new_lemma_175956 (h0 : topological_space (partial_order unsigned)) : totally_disconnected_space (partial_order unsigned) := sorry --non-trivial
lemma new_lemma_175957 (h0 : function.extfun Type (functor.add_const (group (left_cancel_monoid empty)))) : @normalizer_condition.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (left_cancel_monoid.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (group.{0} (left_cancel_monoid.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_175958 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (has_sub.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_sub.{0} num))  := sorry --non-trivial
lemma new_lemma_175959 (h1 : not (ring (fintype to_additive.value_type) -> false)) : @is_domain.{0} (fintype.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (fintype.{0} to_additive.value_type)) h1)  := sorry --non-trivial
lemma new_lemma_175960 (h0 : heq (boolean_algebra (normed_comm_ring Type)) (has_to_string Type)) (h1 : finset (boolean_algebra (normed_comm_ring Type))) : finset.nonempty (heq.elim h0 h1) := sorry --non-trivial
lemma new_lemma_175961 (h0 : topological_space (has_zero (comm_group unsigned))) : preirreducible_space (has_zero (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_175962 (h0 : topological_space (ring (has_add pos))) : t1_space (ring (has_add pos)) := sorry --non-trivial
lemma new_lemma_175963 (h0 : functor.comp group has_to_string pos) : @is_cyclic.{0} (has_to_string.{0} pos) (@functor.comp.run.{0 0 0} group.{0} has_to_string.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_175964 (h0 : complete_lattice (canonically_linear_ordered_monoid Type)) : is_compactly_generated (canonically_linear_ordered_monoid Type) := sorry --non-trivial
lemma new_lemma_175965 (h0 : topological_space (ring (has_Inf pos))) : regular_space (ring (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_175966 (h1 : topological_space (semi_normed_comm_ring (has_lt string_imp))) : path_connected_space (semi_normed_comm_ring (has_lt string_imp)) := sorry --non-trivial
lemma new_lemma_175967 (h0 : functor.add_const (group (simple_graph Type)) (ring Type)) : @group.fg.{1} (simple_graph.{1} Type) (@functor.add_const.run.{1 1} (group.{1} (simple_graph.{1} Type)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_175968 (h0 : functor.add_const (ring (linear_ordered_comm_monoid_with_zero empty)) empty) : @strong_rank_condition.{0} (linear_ordered_comm_monoid_with_zero.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (linear_ordered_comm_monoid_with_zero.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_175969 (h0 : topological_space (has_to_string (finset (has_to_string name)))) : preconnected_space (has_to_string (finset (has_to_string name))) := sorry --non-trivial
lemma new_lemma_175970 (h0 : uniform_space (normed_comm_ring (option congr_arg_kind))) : complete_space (normed_comm_ring (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_175971 (h0 : uniform_space (has_to_string environment.implicit_infer_kind)) : complete_space (has_to_string environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_175972 (h0 : functor.add_const (ring (has_add name)) linarith.comp) : @rank_condition.{0} (has_add.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (has_add.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_175973 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @locally_compact_space.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_175974 (h0 : topological_space (cancel_monoid (boolean_algebra linarith.comp))) : preconnected_space (cancel_monoid (boolean_algebra linarith.comp)) := sorry --non-trivial
lemma new_lemma_175975 (h0 : list (free_add_monoid (semiring unsigned))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_175976 (h0 : not (uniform_space (has_append to_additive.value_type) -> false)) : @complete_space.{0} (has_append.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_append.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_175977 (h0 : uniform_space (semiring (random_gen num))) : separated_space (semiring (random_gen num)) := sorry --non-trivial
lemma new_lemma_175978 (h0 : group (mul_zero_class (has_neg_part pos))) : is_simple_group (mul_zero_class (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_175979 (h0 : topological_space (normed_comm_ring num)) : preirreducible_space (normed_comm_ring num) := sorry --non-trivial
lemma new_lemma_175980 (h0 : complete_lattice (has_to_string (measurable_space.dynkin_system pos))) : is_compactly_generated (has_to_string (measurable_space.dynkin_system pos)) := sorry --non-trivial
lemma new_lemma_175981 (h0 : ring (id linarith.comp_source)) : strong_rank_condition (id linarith.comp_source) := sorry --non-trivial
lemma new_lemma_175982 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (ordered_ring unsigned)) := sorry --non-trivial
lemma new_lemma_175983 (h0 : complete_lattice (has_nndist pos)) : is_atomistic (has_nndist pos) := sorry --non-trivial
lemma new_lemma_175984 (h0 : functor.add_const (topological_space (add_comm_monoid Type)) name) : @preconnected_space.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_comm_monoid.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_175985 (h0 : list (boolean_algebra (has_pos_part (has_pos_part linarith.comp)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_175986 (h0 : topological_space (comm_group Type)) : totally_separated_space (comm_group Type) := sorry --non-trivial
lemma new_lemma_175987 (h0 : functor.add_const (ring (complete_linear_order num)) (semiring num)) : @is_domain.{0} (complete_linear_order.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (complete_linear_order.{0} num)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_175988 (h0 : ring (has_ssubset (has_ssubset to_additive.value_type))) : is_domain (has_ssubset (has_ssubset to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_175989 (h0 : add_group (has_inv (random_gen linarith.comp_source))) : is_add_cyclic (has_inv (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_175990 (h0 : topological_space (random_gen (has_nnnorm reducibility_hints))) : t0_space (random_gen (has_nnnorm reducibility_hints)) := sorry --non-trivial
lemma new_lemma_175991 (h0 : ring (distrib_lattice (has_nnnorm linarith.ineq))) : strong_rank_condition (distrib_lattice (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_175992 (h0 : complete_lattice (denumerable (random_gen (random_gen string_imp)))) : is_atomistic (denumerable (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_175993 (h0 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} (non_assoc_semiring.{0} num) (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h0) (non_assoc_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_175994 (h0 : topological_space (free_add_monoid (option unsigned))) : normal_space (free_add_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_175995 (h0 : functor.comp cancel_comm_monoid_with_zero finset unsigned) : @unique_factorization_monoid.{0} (finset.{0} unsigned) (@functor.comp.run.{0 0 0} cancel_comm_monoid_with_zero.{0} finset.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_175996 (h0 : not (topological_space (semiring unsigned) -> false)) : @locally_compact_space.{0} (semiring.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (semiring.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_175997 (h0 : ring (complete_distrib_lattice (has_to_string name))) : rank_condition (complete_distrib_lattice (has_to_string name)) := sorry --non-trivial
lemma new_lemma_175998 (h0 : topological_space (simple_graph (has_add pos))) : preconnected_space (simple_graph (has_add pos)) := sorry --non-trivial
lemma new_lemma_175999 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_norm.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_norm.{0} fun_info))  := sorry --non-trivial
